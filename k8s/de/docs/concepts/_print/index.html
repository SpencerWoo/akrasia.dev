<!doctype html><html lang=de class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/de/docs/concepts/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Konzepte | Kubernetes</title><meta property="og:title" content="Konzepte"><meta property="og:description" content="Produktionsreife Container-Orchestrierung"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/de/docs/concepts/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Konzepte"><meta itemprop=description content="Produktionsreife Container-Orchestrierung"><meta name=twitter:card content="summary"><meta name=twitter:title content="Konzepte"><meta name=twitter:description content="Produktionsreife Container-Orchestrierung"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Im Abschnitt Konzepte erfahren Sie mehr über die Bestandteile des Kubernetes-Systems und die Abstraktionen, die Kubernetes zur Verwaltung Ihres Clusters zur Verfügung stellt. Sie erhalten zudem ein tieferes Verständnis der Funktionsweise von Kubernetes.
Überblick Um mit Kubernetes zu arbeiten, verwenden Sie Kubernetes-API-Objekte, um den gewünschten Status Ihres Clusters zu beschreiben: welche Anwendungen oder anderen Workloads Sie ausführen möchten, welche Containerimages sie verwenden, die Anzahl der Replikate, welche Netzwerk- und Festplattenressourcen Sie zur Verfügung stellen möchten, und vieles mehr."><meta property="og:description" content="Im Abschnitt Konzepte erfahren Sie mehr über die Bestandteile des Kubernetes-Systems und die Abstraktionen, die Kubernetes zur Verwaltung Ihres Clusters zur Verfügung stellt. Sie erhalten zudem ein tieferes Verständnis der Funktionsweise von Kubernetes.
Überblick Um mit Kubernetes zu arbeiten, verwenden Sie Kubernetes-API-Objekte, um den gewünschten Status Ihres Clusters zu beschreiben: welche Anwendungen oder anderen Workloads Sie ausführen möchten, welche Containerimages sie verwenden, die Anzahl der Replikate, welche Netzwerk- und Festplattenressourcen Sie zur Verfügung stellen möchten, und vieles mehr."><meta name=twitter:description content="Im Abschnitt Konzepte erfahren Sie mehr über die Bestandteile des Kubernetes-Systems und die Abstraktionen, die Kubernetes zur Verwaltung Ihres Clusters zur Verfügung stellt. Sie erhalten zudem ein tieferes Verständnis der Funktionsweise von Kubernetes.
Überblick Um mit Kubernetes zu arbeiten, verwenden Sie Kubernetes-API-Objekte, um den gewünschten Status Ihres Clusters zu beschreiben: welche Anwendungen oder anderen Workloads Sie ausführen möchten, welche Containerimages sie verwenden, die Anzahl der Replikate, welche Netzwerk- und Festplattenressourcen Sie zur Verfügung stellen möchten, und vieles mehr."><meta property="og:url" content="https://kubernetes.io/de/docs/concepts/"><meta property="og:title" content="Konzepte"><meta name=twitter:title content="Konzepte"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/de/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/de/docs/>Dokumentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/training/>Schulungen</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/partners/>Partner</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/case-studies/>Fallstudien</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/de/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/de/docs/concepts/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/de/docs/concepts/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/de/docs/concepts/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/de/docs/concepts/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/de/docs/concepts/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Deutsch (German)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/>Italiano (Italian)</a>
<a class=dropdown-item href=/es/docs/concepts/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/concepts/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/concepts/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/concepts/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Das ist eine für den Ausdruck optimierte Ansicht des gesamten Kapitels inkl. Unterseiten.
<a href=# onclick="return print(),!1">Druckvorgang starten</a>.</p><p><a href=/de/docs/concepts/>Zur Standardansicht zurückkehren</a>.</p></div><h1 class=title>Konzepte</h1><ul><li>1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>Überblick</a></li><ul><li>1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Was ist Kubernetes?</a></li><li>1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Kubernetes Komponenten</a></li></ul><li>2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>Kubernetes Architekur</a></li><ul><li>2.1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Nodes</a></li><li>2.2: <a href=#pg-63e7fdf87ba61eb2586bb8c625c23506>Master-Node Kommunikation</a></li><li>2.3: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Zugrunde liegende Konzepte des Cloud Controller Manager</a></li></ul><li>3: <a href=#pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>Container</a></li><ul><li>3.1: <a href=#pg-16042b4652ad19e565c7263824029a43>Images</a></li></ul><li>4: <a href=#pg-d52aadda80edd9f8c514cfe2321363c2>Workloads</a></li><ul><li>4.1: <a href=#pg-4d68b0ccf9c683e6368ffdcc40c838d4>Pods</a></li><ul></ul></ul><li>5: <a href=#pg-0a0a7eca3e302a3c08f8c85e15d337fd>Dienste, Lastverteilung und Netzwerkfunktionen</a></li><ul></ul><li>6: <a href=#pg-f018f568c6723865753f150c3c59bdda>Speicher</a></li><ul></ul><li>7: <a href=#pg-275bea454e1cf4c5adeca4058b5af988>Konfiguration</a></li><ul></ul><li>8: <a href=#pg-ac9161c6d952925b083ad9602b4e8e7f>Richtlinien</a></li><ul></ul><li>9: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>Cluster Administration</a></li><ul><li>9.1: <a href=#pg-08e94e6a480e0d6b2de72d84a1b97617>Proxies in Kubernetes</a></li><li>9.2: <a href=#pg-d5cc46b61677b53f61a407d20bdd0830>Controller Manager Metriken</a></li><li>9.3: <a href=#pg-85d633ae590aa20ec024f1b7af1d74fc>Addons Installieren</a></li></ul><li>10: <a href=#pg-7e0d97616b15e2c383c6a0a96ec442cb>Kubernetes erweitern</a></li><ul></ul><li>11: <a href=#pg-4c31edff4063c7b31c556b3eb1405c65>Konzept Dokumentations-Vorlage</a></li></ul><div class=content><p>Im Abschnitt Konzepte erfahren Sie mehr über die Bestandteile des Kubernetes-Systems und die Abstraktionen, die Kubernetes zur Verwaltung Ihres Clusters zur Verfügung stellt. Sie erhalten zudem ein tieferes Verständnis der Funktionsweise von Kubernetes.</p><h2 id=überblick>Überblick</h2><p>Um mit Kubernetes zu arbeiten, verwenden Sie <em>Kubernetes-API-Objekte</em>, um den <em>gewünschten Status Ihres Clusters</em> zu beschreiben:
welche Anwendungen oder anderen Workloads Sie ausführen möchten, welche Containerimages sie verwenden, die Anzahl der Replikate, welche Netzwerk- und Festplattenressourcen Sie zur Verfügung stellen möchten, und vieles mehr. Sie legen den gewünschten Status fest, indem Sie Objekte mithilfe der Kubernetes-API erstellen. Dies geschieht normalerweise über die Befehlszeilenschnittstelle <code>kubectl</code>. Sie können die Kubernetes-API auch direkt verwenden, um mit dem Cluster zu interagieren und den gewünschten Status festzulegen oder zu ändern.</p><p>Sobald Sie den gewünschten Status eingestellt haben, wird das <em>Kubernetes Control Plane</em> dafür sorgen, dass der aktuelle Status des Clusters mit dem gewünschten Status übereinstimmt. Zu diesem Zweck führt Kubernetes verschiedene Aufgaben automatisch aus, z. B. das Starten oder Neustarten von Containern, Skalieren der Anzahl der Repliken einer bestimmten Anwendung und vieles mehr. Das Kubernetes Control Plane besteht aus einer Reihe von Prozessen, die in Ihrem Cluster ausgeführt werden:</p><ul><li>Der <strong>Kubernetes Master</strong> besteht aus drei Prozessen, die auf einem einzelnen Node in Ihrem Cluster ausgeführt werden, der als Master-Node bezeichnet wird. Diese Prozesse sind: <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>, <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> und <a href=/docs/admin/kube-scheduler/>kube-scheduler</a>.</li><li>Jeder einzelne Node in Ihrem Cluster, welcher nicht der Master ist, führt zwei Prozesse aus:<ul><li><strong><a href=/docs/admin/kubelet/>kubelet</a></strong>, das mit dem Kubernetes Master kommuniziert.</li><li><strong><a href=/docs/admin/kube-proxy/>kube-proxy</a></strong>, ein Netzwerk-Proxy, der die Netzwerkdienste von Kubernetes auf jedem Node darstellt.</li></ul></li></ul><h2 id=kubernetes-objects>Kubernetes Objects</h2><p>Kubernetes enthält eine Reihe von Abstraktionen, die den Status Ihres Systems darstellen: im Container eingesetzte Anwendungen und Workloads, die zugehörigen Netzwerk- und Festplattenressourcen sowie weitere Informationen zu den Aufgaben Ihres Clusters. Diese Abstraktionen werden durch Objekte in der Kubernetes-API dargestellt. Lesen Sie <a href=/docs/concepts/abstractions/overview/>Kubernetes Objects Überblick</a> für weitere Details.</p><p>Die Basisobjekte von Kubernetes umfassen:</p><ul><li><a href=/docs/concepts/workloads/pods/pod-overview/>Pod</a></li><li><a href=/docs/concepts/services-networking/service/>Service</a></li><li><a href=/docs/concepts/storage/volumes/>Volume</a></li><li><a href=/docs/concepts/overview/working-with-objects/namespaces/>Namespace</a></li></ul><p>Darüber hinaus enthält Kubernetes Abstraktionen auf höherer Ebene, die als Controller bezeichnet werden. Controller bauen auf den Basisobjekten auf und bieten zusätzliche Funktionen und Komfortfunktionen. Sie beinhalten:</p><ul><li><a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a></li><li><a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li><li><a href=/docs/concepts/workloads/controllers/jobs-run-to-completion/>Job</a></li></ul><h2 id=kubernetes-control-plane>Kubernetes Control Plane</h2><p>Die verschiedenen Teile der Kubernetes-Steuerungsebene (Control Plane), wie der Kubernetes Master- und der Kubelet-Prozess, bestimmen, wie Kubernetes mit Ihrem Cluster kommuniziert. Das Control Plane verwaltet ein Inventar aller Kubernetes-Objekte im System und führt kontinuierlich Kontrollschleifen aus, um den Status dieser Objekte zu verwalten. Zu jeder Zeit reagieren die Kontrollschleifen des Control Plane auf Änderungen im Cluster und arbeiten daran, dass der tatsächliche Status aller Objekte im System mit dem von Ihnen definierten Status übereinstimmt.</p><p>Wenn Sie beispielsweise mit der Kubernetes-API ein Deployment-Objekt erstellen, geben Sie einen neuen gewünschten Status für das System an. Das Kubernetes Control Plane zeichnet die Objekterstellung auf und führt Ihre Anweisungen aus, indem es die erforderlichen Anwendungen startet und Sie für auf den Cluster-Nodes plant - Dadurch wird der tatsächliche Status des Clusters an den gewünschten Status angepasst.</p><h3 id=kubernetes-master>Kubernetes Master</h3><p>Der Kubernetes-Master ist für Erhalt des gewünschten Status Ihres Clusters verantwortlich. Wenn Sie mit Kubernetes interagieren, beispielsweise mit dem Kommandozeilen-Tool <code>kubectl</code>, kommunizieren Sie mit dem Kubernetes-Master Ihres Clusters.</p><blockquote><p>Der Begriff "Master" bezeichnet dabei eine Reihe von Prozessen, die den Clusterstatus verwalten. Normalerweise werden diese Prozesse alle auf einem einzigen Node im Cluster ausgeführt. Dieser Node wird auch als Master bezeichnet. Der Master kann repliziert werden, um die Verfügbarkeit und Redundanz zu erhöhen.</p></blockquote><h3 id=kubernetes-nodes>Kubernetes Nodes</h3><p>Die Nodes in einem Cluster sind die Maschinen (VMs, physische Server usw.), auf denen Ihre Anwendungen und Cloud-Workflows ausgeführt werden. Der Kubernetes-Master steuert jeden Node; Sie werden selten direkt mit Nodes interagieren.</p><h4 id=objekt-metadata>Objekt Metadata</h4><ul><li><a href=/docs/concepts/overview/working-with-objects/annotations/>Anmerkungen</a></li></ul><h2 id=nächste-schritte>Nächste Schritte</h2><p>Wenn Sie eine Konzeptseite schreiben möchten, lesen Sie <a href=/docs/home/contribute/page-templates/>Seitenvorlagen verwenden</a>
für Informationen zum Konzeptseitentyp und zur Dokumentations Vorlage.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>1 - Überblick</h1></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>1.1 - Was ist Kubernetes?</h1><p>Diese Seite ist eine Übersicht über Kubernetes.</p><p>Kubernetes ist eine portable, erweiterbare Open-Source-Plattform zur Verwaltung von
containerisierten Arbeitslasten und Services, die sowohl die deklarative Konfiguration als auch die Automatisierung erleichtert.
Es hat ein großes, schnell wachsendes Ökosystem. Kubernetes Dienstleistungen, Support und Tools sind weit verbreitet.</p><p>Google hat das Kubernetes-Projekt 2014 als Open-Source-Projekt zur Verfügung gestellt. Kubernetes baut auf anderthalb Jahrzehnten
Erfahrung auf, die Google mit der Ausführung von Produktions-Workloads in großem Maßstab hat, kombiniert mit den besten Ideen und Praktiken der Community.</p><h2 id=warum-brauche-ich-kubernetes-und-was-kann-ich-damit-tun>Warum brauche ich Kubernetes und was kann ich damit tun?</h2><p>Kubernetes hat eine Reihe von Funktionen. Es kann gesehen werden als:</p><ul><li>eine Containerplattform</li><li>eine Microservices-Plattform</li><li>eine portable Cloud-Plattform
und vieles mehr.</li></ul><p>Kubernetes bietet eine <strong>containerzentrierte</strong> Managementumgebung. Es koordiniert die Computer-, Netzwerk- und Speicherinfrastruktur
im Namen der Benutzer-Workloads. Dies bietet einen Großteil der Einfachheit von Platform as a Service (PaaS) mit der Flexibilität
von Infrastructure as a Service (IaaS) und ermöglicht die Portabilität zwischen Infrastrukturanbietern.</p><h2 id=wie-ist-kubernetes-eine-plattform>Wie ist Kubernetes eine Plattform?</h2><p>Auch wenn Kubernetes eine Menge Funktionalität bietet, gibt es immer wieder neue Szenarien,
die von neuen Funktionen profitieren würden. Anwendungsspezifische Workflows können optimiert werden,
um die Entwicklungsgeschwindigkeit zu beschleunigen.
Eine zunächst akzeptable Ad-hoc-Orchestrierung erfordert oft eine robuste Automatisierung in großem Maßstab.
Aus diesem Grund wurde Kubernetes auch als Plattform für den Aufbau eines Ökosystems von Komponenten und Tools
konzipiert, um die Bereitstellung, Skalierung und Verwaltung von Anwendungen zu erleichtern.</p><p><a href=/docs/concepts/overview/working-with-objects/labels/>Labels</a> ermöglichen es den Benutzern, ihre Ressourcen
nach Belieben zu organisieren. <a href=/docs/concepts/overview/working-with-objects/annotations/>Anmerkungen</a> ermöglichen es Benutzern,
Ressourcen mit benutzerdefinierten Informationen zu versehen, um ihre Arbeitsabläufe zu vereinfachen und eine einfache Möglichkeit
für Managementtools zu bieten, den Status von Kontrollpunkten zu ermitteln.</p><p>Darüber hinaus basiert die <a href=/docs/concepts/overview/components/>Kubernetes-Steuerungsebene</a> auf den gleichen APIs,
die Entwicklern und Anwendern zur Verfügung stehen. Benutzer können ihre eigenen Controller, wie z.B.
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/scheduler.md>Scheduler</a>, mit
ihren <a href=/docs/concepts/api-extension/custom-resources/>eigenen APIs</a> schreiben, die von einem
universellen <a href=/docs/user-guide/kubectl-overview/>Kommandozeilen-Tool</a> angesprochen werden können.</p><p>Dieses <a href=https://git.k8s.io/design-proposals-archive/architecture/architecture.md>Design</a> hat es einer Reihe anderer Systeme ermöglicht, auf Kubernetes aufzubauen.</p><h2 id=was-kubernetes-nicht-ist>Was Kubernetes nicht ist</h2><p>Kubernetes ist kein traditionelles, allumfassendes PaaS (Plattform als ein Service) System. Da Kubernetes nicht auf Hardware-,
sondern auf Containerebene arbeitet, bietet es einige allgemein anwendbare Funktionen, die PaaS-Angeboten gemeinsam sind,
wie Bereitstellung, Skalierung, Lastausgleich, Protokollierung und Überwachung.
Kubernetes ist jedoch nicht monolithisch, und diese Standardlösungen sind optional und modular erweiterbar.
Kubernetes liefert die Bausteine für den Aufbau von Entwicklerplattformen, bewahrt aber die
Wahlmöglichkeiten und Flexibilität der Benutzer, wo es wichtig ist.</p><p>Kubernetes:</p><ul><li>Schränkt nicht die Art der unterstützten Anwendungen ein. Kubernetes zielt darauf ab,
eine extrem große Vielfalt von Workloads zu unterstützen, einschließlich stateless,
stateful und datenverarbeitender Workloads. Wenn eine Anwendung in einem Container ausgeführt
werden kann, sollte sie auf Kubernetes hervorragend laufen.</li><li>Verteilt keinen Quellcode und entwickelt Ihre Anwendung nicht.
Kontinuierliche Integrations-, Liefer- und Bereitstellungs-Workflows (CI/CD) werden durch
Unternehmenskulturen und -präferenzen sowie technische Anforderungen bestimmt.</li><li>Bietet keine Dienste auf Anwendungsebene, wie Middleware (z.B. Nachrichtenbusse),
Datenverarbeitungs-Frameworks (z.B. Spark), Datenbanken (z.B. mysql), Caches oder
Cluster-Speichersysteme (z.B. Ceph) als eingebaute Dienste. Solche Komponenten können
auf Kubernetes laufen und/oder von Anwendungen, die auf Kubernetes laufen, über
portable Mechanismen wie den Open Service Broker angesprochen werden.</li><li>Bietet keine Konfigurationssprache bzw. kein Konfigurationssystem (z.B. <a href=https://github.com/google/jsonnet>jsonnet</a>).
Es bietet eine deklarative API, die von beliebigen Formen deklarativer Spezifikationen angesprochen werden kann.</li><li>Bietet keine umfassenden Systeme zur Maschinenkonfiguration, Wartung, Verwaltung oder Selbstheilung.</li></ul><p>Außerdem ist Kubernetes nicht nur ein <em>Orchestrierungssystem</em>. Fakt ist, dass es die Notwendigkeit einer Orchestrierung
überflüssig macht. Die technische Definition von <em>Orchestrierung</em> ist die Ausführung eines
definierten Workflows: zuerst A, dann B, dann C. Im Gegensatz dazu besteht Kubernetes aus einer Reihe von unabhängigen,
komponierbaren Steuerungsprozessen, die den aktuellen Zustand kontinuierlich in Richtung des bereitgestellten Soll-Zustandes vorantreiben.
Es sollte keine Rolle spielen, wie Sie von A nach C kommen. Eine zentrale Steuerung ist ebenfalls nicht erforderlich.
Das Ergebnis ist ein System, das einfacher zu bedienen und leistungsfähiger, robuster, widerstandsfähiger und erweiterbar ist.</p><h2 id=warum-container>Warum Container?</h2><p>Sie suchen nach Gründen, warum Sie Container verwenden sollten?</p><p><img src=/images/docs/why_containers.svg alt="Why Containers?"></p><p>Der <em>Altbekannte</em> Weg zur Bereitstellung von Anwendungen war die Installation
der Anwendungen auf einem Host mit dem Betriebssystempaketmanager.
Dies hatte den Nachteil, dass die ausführbaren Dateien, Konfigurationen,
Bibliotheken und Lebenszyklen der Anwendungen untereinander und mit dem
Host-Betriebssystem verwoben waren. Man könnte unveränderliche
Virtual-Machine-Images erzeugen, um vorhersehbare Rollouts
und Rollbacks zu erreichen, aber VMs sind schwergewichtig und nicht portierbar.</p><p>Der <em>Neue Weg</em> besteht darin, Container auf Betriebssystemebene und nicht auf
Hardware-Virtualisierung bereitzustellen. Diese Container sind voneinander
und vom Host isoliert: Sie haben ihre eigenen Dateisysteme, sie können die
Prozesse des anderen nicht sehen, und ihr Ressourcenverbrauch kann begrenzt
werden. Sie sind einfacher zu erstellen als VMs, und da sie von der zugrunde
liegenden Infrastruktur und dem Host-Dateisystem entkoppelt sind,
sind sie über Clouds und Betriebssystem-Distributionen hinweg portabel.</p><p>Da Container klein und schnell sind, kann in jedes Containerimage eine Anwendung gepackt werden.
Diese 1:1-Beziehung zwischen Anwendung und Image ermöglicht es, die Vorteile von Containern
voll auszuschöpfen. Mit Containern können unveränderliche Container-Images eher zur Build-/Release-Zeit
als zur Deployment-Zeit erstellt werden, da jede Anwendung nicht mit dem Rest des Anwendungsstacks komponiert
werden muss und auch nicht mit der Produktionsinfrastrukturumgebung verbunden ist. Die Generierung von
Container-Images zum Zeitpunkt der Erstellung bzw. Freigabe ermöglicht es, eine konsistente Umgebung
von der Entwicklung bis zur Produktion zu gewährleisten.
Ebenso sind Container wesentlich transparenter als VMs, was die Überwachung und Verwaltung erleichtert.
Dies gilt insbesondere dann, wenn die Prozesslebenszyklen der Container von der Infrastruktur verwaltet
werden und nicht von einem Prozess-Supervisor im Container versteckt werden.
Schließlich, mit einer einzigen Anwendung pro Container, wird die Verwaltung
der Container gleichbedeutend mit dem Management des Deployments der Anwendung.</p><p>Zusammenfassung der Container-Vorteile:</p><ul><li><strong>Agile Anwendungserstellung und -bereitstellung</strong>:
Einfachere und effizientere Erstellung von Container-Images im Vergleich zur Verwendung von VM-Images.</li><li><strong>Kontinuierliche Entwicklung, Integration und Bereitstellung</strong>:
Bietet eine zuverlässige und häufige Erstellung und Bereitstellung von Container-Images
mit schnellen und einfachen Rollbacks (aufgrund der Unveränderlichkeit des Images).</li><li><strong>Dev und Ops Trennung der Bedenken</strong>:
Erstellen Sie Anwendungscontainer-Images nicht zum Deployment-, sondern zum Build-Releasezeitpunkt
und entkoppeln Sie so Anwendungen von der Infrastruktur.</li><li><strong>Überwachbarkeit</strong>:
Nicht nur Informationen und Metriken auf Betriebssystemebene werden angezeigt,
sondern auch der Zustand der Anwendung und andere Signale.</li><li><strong>Umgebungskontinuität in Entwicklung, Test und Produktion</strong>:
Läuft auf einem Laptop genauso wie in der Cloud.</li><li><strong>Cloud- und OS-Distribution-Portabilität</strong>:
Läuft auf Ubuntu, RHEL, CoreOS, On-Prem, Google Kubernetes Engine und überall sonst.</li><li><strong>Anwendungsorientiertes Management</strong>:
Erhöht den Abstraktionsgrad vom Ausführen eines Betriebssystems auf virtueller Hardware
bis zum Ausführen einer Anwendung auf einem Betriebssystem unter Verwendung logischer Ressourcen.</li><li><strong>Locker gekoppelte, verteilte, elastische, freie <a href=https://martinfowler.com/articles/microservices.html>Microservices</a></strong>:
Anwendungen werden in kleinere, unabhängige Teile zerlegt und können dynamisch bereitgestellt
und verwaltet werden -- nicht ein monolithischer Stack, der auf einer großen Single-Purpose-Maschine läuft.</li><li><strong>Ressourcenisolierung</strong>:
Vorhersehbare Anwendungsleistung.</li><li><strong>Ressourcennutzung</strong>:
Hohe Effizienz und Dichte.</li></ul><h2 id=was-bedeutet-kubernetes-k8s>Was bedeutet Kubernetes? K8s?</h2><p>Der Name <strong>Kubernetes</strong> stammt aus dem Griechischen, bedeutet <em>Steuermann</em> oder
<em>Pilot</em>, und ist der Ursprung von <em>Gouverneur</em> und
<a href="http://www.etymonline.com/index.php?term=cybernetics">cybernetic</a>. <em>K8s</em>
ist eine Abkürzung, die durch Ersetzen der 8 Buchstaben "ubernete" mit "8" abgeleitet wird.</p><h2 id=nächste-schritte>Nächste Schritte</h2><ul><li><a href=/docs/setup/>Bereit loszulegen</a>?</li><li>Weitere Einzelheiten finden Sie in der <a href=/docs/home/>Kubernetes Dokumentation</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>1.2 - Kubernetes Komponenten</h1><p>In diesem Dokument werden die verschiedenen binären Komponenten beschrieben, die zur Bereitstellung eines funktionsfähigen Kubernetes-Clusters erforderlich sind.</p><h2 id=master-komponenten>Master-Komponenten</h2><p>Master-Komponenten stellen die Steuerungsebene des Clusters bereit. Master-Komponenten treffen globale Entscheidungen über den Cluster (z. B. Zeitplanung) und das Erkennen und Reagieren auf Clusterereignisse (Starten eines neuen Pods, wenn das <code>replicas</code>-Feld eines Replikationscontrollers nicht zufriedenstellend ist).</p><p>Master-Komponenten können auf jedem Computer im Cluster ausgeführt werden.
Der Einfachheit halber starten Setup-Skripts normalerweise alle Master-Komponenten auf demselben Computer, und es werden keine Benutzercontainer auf diesem Computer ausgeführt.
Lesen Sie <a href=/docs/admin/high-availability/>Cluster mit hoher Verfügbarkeit erstellen</a> für ein Beispiel für ein Multi-Master-VM-Setup.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>Komponente auf dem Master, der die Kubernetes-API verfügbar macht. Es ist das Frontend für die Kubernetes-Steuerebene.</p><p>Es ist für die horizontale Skalierung konzipiert, d. H. Es skaliert durch die Bereitstellung von mehr Instanzen. Mehr informationen finden Sie unter <a href=/docs/admin/high-availability/>Cluster mit hoher Verfügbarkeit erstellen</a>.</p><h3 id=etcd>etcd</h3><p>Konsistenter und hochverfügbarer Key-Value Speicher, der als Backupspeicher von Kubernetes für alle Clusterdaten verwendet wird.</p><p>Halten Sie immer einen Sicherungsplan für etcds Daten für Ihren Kubernetes-Cluster bereit. Ausführliche Informationen zu etcd finden Sie in der <a href=https://etcd.io/docs>etcd Dokumentation</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Komponente auf dem Master, die neu erstellte Pods überwacht, denen kein Node zugewiesen ist. Sie wählt den Node aus, auf dem sie ausgeführt werden sollen.</p><p>Zu den Faktoren, die bei Planungsentscheidungen berücksichtigt werden, zählen individuelle und kollektive Ressourcenanforderungen, Hardware- / Software- / Richtlinieneinschränkungen, Affinitäts- und Anti-Affinitätsspezifikationen, Datenlokalität, Interworkload-Interferenz und Deadlines.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Komponente auf dem Master, auf dem <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a> ausgeführt werden.</p><p>Logisch gesehen ist jeder <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> ein separater Prozess, aber zur Vereinfachung der Komplexität werden sie alle zu einer einzigen Binärdatei zusammengefasst und in einem einzigen Prozess ausgeführt.</p><p>Diese Controller umfassen:</p><ul><li>Node Controller: Verantwortlich für das Erkennen und Reagieren, wenn Nodes ausfallen.</li><li>Replication Controller: Verantwortlich für die Aufrechterhaltung der korrekten Anzahl von Pods für jedes Replikationscontrollerobjekt im System.</li><li>Endpoints Controller: Füllt das Endpoints-Objekt aus (d.h. verbindet Services & Pods).</li><li>Service Account & Token Controllers: Erstellt Standardkonten und API-Zugriffstoken für neue Namespaces.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/>cloud-controller-manager</a> führt Controller aus, die mit den entsprechenden Cloud-Anbietern interagieren.
Der cloud-controller-manager ist eine Alpha-Funktion, die in Kubernetes Version 1.6 eingeführt wurde.</p><p>cloud-controller-manager führt nur Cloud-Provider-spezifische Controller-Schleifen aus. Sie müssen diese Controller-Schleifen im Cube-Controller-Manager deaktivieren. Sie können die Controller-Schleifen deaktivieren, indem Sie beim Starten des kube-controller-manager das Flag <code>--cloud-provider</code> auf <code>external</code> setzen.</p><p>cloud-controller-manager erlaubt es dem Cloud-Anbieter Code und dem Kubernetes-Code, sich unabhängig voneinander zu entwickeln.
In früheren Versionen war der Kerncode von Kubernetes für die Funktionalität von Cloud-Provider-spezifischem Code abhängig.
In zukünftigen Versionen sollte der für Cloud-Anbieter spezifische Code vom Cloud-Anbieter selbst verwaltet und mit dem Cloud-Controller-Manager verknüpft werden, während Kubernetes ausgeführt wird.</p><p>Die folgenden Controller haben Abhängigkeiten von Cloud-Anbietern:</p><ul><li>Node Controller: Zum Überprüfen, ob ein Node in der Cloud beim Cloud-Anbieter gelöscht wurde, nachdem er nicht mehr reagiert</li><li>Route Controller: Zum Einrichten von Routen in der zugrunde liegenden Cloud-Infrastruktur</li><li>Service Controller: Zum Erstellen, Aktualisieren und Löschen von Lastverteilern von Cloud-Anbietern</li><li>Volume Controller: Zum Erstellen, Verbinden und Bereitstellen von Volumes und zur Interaktion mit dem Cloud-Provider zum Orchestrieren von Volumes</li></ul><h2 id=node-komponenten>Node-Komponenten</h2><p>Node Komponenten werden auf jedem Knoten ausgeführt, halten laufende Pods aufrecht und stellen die Kubernetes-Laufzeitumgebung bereit.</p><h3 id=kubelet>kubelet</h3><p>Ein Agent, der auf jedem Node im Cluster ausgeführt wird. Er stellt sicher, dass Container in einem Pod ausgeführt werden.</p><p>Das Kubelet verwendet eine Reihe von PodSpecs, die über verschiedene Mechanismen bereitgestellt werden, und stellt sicher, dass die in diesen PodSpecs beschriebenen Container ordnungsgemäß ausgeführt werden. Das kubelet verwaltet keine Container, die nicht von Kubernetes erstellt wurden.</p><h3 id=kube-proxy>kube-proxy</h3><p><a href=/docs/admin/kube-proxy/>kube-proxy</a> ermöglicht die Kubernetes Service-Abstraktion, indem die Netzwerkregeln auf dem Host beibehalten und die Verbindungsweiterleitung durchgeführt wird.</p><h3 id=container-runtime>Container Runtime</h3><p>Die Containerlaufzeit ist die Software, die für das Ausführen von Containern verantwortlich ist.
Kubernetes unterstützt mehrere Laufzeiten: <a href=http://www.docker.com>Docker</a>, <a href=https://containerd.io>containerd</a>, <a href=https://cri-o.io/>cri-o</a>, <a href=https://github.com/kubernetes-incubator/rktlet>rktlet</a> und jede Implementierung des <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=addons>Addons</h2><p>Addons sind Pods und Dienste, die Clusterfunktionen implementieren. Die Pods können verwaltet werden
durch Deployments, ReplicationControllers, und so wieter.
Namespace-Addon-Objekte werden im Namespace <code>kube-system</code> erstellt.</p><p>Ausgewählte Addons werden unten beschrieben. Eine erweiterte Liste verfügbarer Addons finden Sie unter <a href=/docs/concepts/cluster-administration/addons/>Addons</a>.</p><h3 id=dns>DNS</h3><p>Während die anderen Addons nicht unbedingt erforderlich sind, sollte <a href=/docs/concepts/services-networking/dns-pod-service/>cluster DNS</a> in allen Kubernetes-Cluster vorhanden sein, da viele Beispiele davon abhängen.</p><p>Cluster-DNS ist neben anderen DNS-Servern in Ihrer Umgebung ein DNS-Server, der DNS-Einträge für Kubernetes-Dienste bereitstellt.</p><p>Von Kubernetes gestartete Container schließen diesen DNS-Server automatisch in ihre DNS-Suchen ein.</p><h3 id=web-ui-dashboard>Web UI (Dashboard)</h3><p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> ist eine allgemeine, webbasierte Benutzeroberfläche für Kubernetes-Cluster. Benutzer können damit Anwendungen, die im Cluster ausgeführt werden, sowie den Cluster selbst verwalten und Fehler beheben.</p><h3 id=container-resource-monitoring>Container Resource Monitoring</h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Container Resource Monitoring</a> zeichnet generische Zeitreihenmessdaten zu Containern in einer zentralen Datenbank auf und stellt eine Benutzeroberfläche zum Durchsuchen dieser Daten bereit.</p><h3 id=cluster-level-logging>Cluster-level Logging</h3><p>Ein <a href=/docs/concepts/cluster-administration/logging/>Cluster-level logging</a> Mechanismus ist für das Speichern von Containerprotokollen in einem zentralen Protokollspeicher mit Such- / Browsing-Schnittstelle verantwortlich.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>2 - Kubernetes Architekur</h1></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>2.1 - Nodes</h1><p>Ein Knoten (Node in Englisch) ist eine Arbeitsmaschine in Kubernetes. Ein Node
kann je nach Cluster eine VM oder eine physische Maschine sein. Jeder Node enthält
die für den Betrieb von <a href=/docs/concepts/workloads/pods/pod/>Pods</a> notwendigen Dienste
und wird von den Master-Komponenten verwaltet.
Die Dienste auf einem Node umfassen die <a href=/docs/concepts/overview/components/#node-components>Container Runtime</a>, das Kubelet und den Kube-Proxy.
Weitere Informationen finden Sie im Abschnitt Kubernetes Node in der Architekturdesign-Dokumentation.</p><h2 id=node-status>Node Status</h2><p>Der Status eines Nodes enthält folgende Informationen:</p><ul><li><a href=#adressen>Adressen</a></li><li><a href=#zustand>Zustand</a></li><li><a href=#kapazit%C3%A4t>Kapazität</a></li><li><a href=#info>Info</a></li></ul><p>Jeder Abschnitt wird folgend detailliert beschrieben.</p><h3 id=adressen>Adressen</h3><p>Die Verwendung dieser Felder hängt von Ihrem Cloud-Anbieter oder der Bare-Metal-Konfiguration ab.</p><ul><li>HostName: Der vom Kernel des Nodes gemeldete Hostname. Kann mit dem kubelet-Parameter <code>--hostname-override</code> überschrieben werden.</li><li>ExternalIP: In der Regel die IP-Adresse des Nodes, die extern geroutet werden kann (von außerhalb des Clusters verfügbar).</li><li>InternalIP: In der Regel die IP-Adresse des Nodes, die nur innerhalb des Clusters routbar ist.</li></ul><h3 id=zustand>Zustand</h3><p>Das <code>conditions</code> Feld beschreibt den Zustand, aller <code>Running</code> Nodes.</p><table><thead><tr><th>Node Condition</th><th>Beschreibung</th></tr></thead><tbody><tr><td><code>OutOfDisk</code></td><td><code>True</code> wenn auf dem Node nicht genügend freier Speicherplatz zum Hinzufügen neuer Pods vorhanden ist, andernfalls <code>False</code></td></tr><tr><td><code>Ready</code></td><td><code>True</code> wenn der Node in einem guten Zustand und bereit ist Pods aufzunehmen, <code>False</code> wenn der Node nicht in einem guten Zustand ist und nicht bereit ist Pods aufzunehmeb, und <code>Unknown</code> wenn der Node-Controller seit der letzten <code>node-monitor-grace-period</code> nichts von dem Node gehört hat (Die Standardeinstellung beträgt 40 Sekunden)</td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> wenn der verfügbare Speicher des Nodes niedrig ist; Andernfalls<code>False</code></td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> wenn zu viele Prozesse auf dem Node vorhanden sind; Andernfalls<code>False</code></td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> wenn die Festplattenkapazität niedrig ist. Andernfalls <code>False</code></td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> wenn das Netzwerk für den Node nicht korrekt konfiguriert ist, andernfalls <code>False</code></td></tr></tbody></table><p>Der Zustand eines Nodes wird als JSON-Objekt dargestellt. Die folgende Antwort beschreibt beispielsweise einen fehlerfreien Node.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Wenn der Status der <code>Ready</code>-Bedingung <code>Unknown</code> oder <code>False</code> länger als der <code>pod-eviction-timeout</code> bleibt, wird ein Parameter an den <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> übergeben und alle Pods auf dem Node werden vom Node Controller gelöscht.</p><p>Die voreingestellte Zeit vor der Entfernung beträgt <strong>fünf Minuten</strong>.
In einigen Fällen, in denen der Node nicht erreichbar ist, kann der Apiserver nicht mit dem Kubelet auf dem Node kommunizieren.
Die Entscheidung, die Pods zu löschen, kann dem Kublet erst mitgeteilt werden, wenn die Kommunikation mit dem Apiserver wiederhergestellt ist.
In der Zwischenzeit können Pods, deren Löschen geplant ist, weiterhin auf dem unzugänglichen Node laufen.</p><p>In Versionen von Kubernetes vor 1.5 würde der Node Controller das Löschen dieser unerreichbaren Pods vom Apiserver <a href=/docs/concepts/workloads/pods/pod/#force-deletion-of-pods>erzwingen</a>. In Version 1.5 und höher erzwingt der Node Controller jedoch keine Pod Löschung, bis bestätigt wird, dass sie nicht mehr im Cluster ausgeführt werden. Pods die auf einem unzugänglichen Node laufen sind eventuell in einem einem <code>Terminating</code> oder <code>Unkown</code> Status. In Fällen, in denen Kubernetes nicht aus der zugrunde liegenden Infrastruktur schließen kann, ob ein Node einen Cluster dauerhaft verlassen hat, muss der Clusteradministrator den Node möglicherweise manuell löschen.
Das Löschen des Kubernetes-Nodeobjekts bewirkt, dass alle auf dem Node ausgeführten Pod-Objekte gelöscht und deren Namen freigegeben werden.</p><p>In Version 1.12 wurde die Funktion <code>TaintNodesByCondition</code> als Beta-Version eingeführt, die es dem Node-Lebenszyklus-Controller ermöglicht, automatisch <a href=/docs/concepts/configuration/taint-and-toleration/>Markierungen</a> (<em>taints</em> in Englisch) zu erstellen, die Bedingungen darstellen.</p><p>Ebenso ignoriert der Scheduler die Bedingungen, wenn er einen Node berücksichtigt; stattdessen betrachtet er die Markierungen (taints) des Nodes und die Toleranzen eines Pod.</p><p>Anwender können jetzt zwischen dem alten Scheduling-Modell und einem neuen, flexibleren Scheduling-Modell wählen.</p><p>Ein Pod, der keine Toleranzen aufweist, wird gemäß dem alten Modell geplant.
Aber ein Pod, die die Taints eines bestimmten Node toleriert, kann auf diesem Node geplant werden.</p><div class="alert alert-warning caution callout" role=alert><strong>Achtung:</strong> Wenn Sie diese Funktion aktivieren, entsteht eine kleine Verzögerung zwischen der Zeit,
in der eine Bedingung beobachtet wird, und der Zeit, in der ein Taint entsteht.
Diese Verzögerung ist in der Regel kürzer als eine Sekunde, aber sie kann die Anzahl
der Pods erhöhen, die erfolgreich geplant, aber vom Kubelet abgelehnt werden.</div><h3 id=kapazität>Kapazität</h3><p>Beschreibt die auf dem Node verfügbaren Ressourcen: CPU, Speicher und die maximale
Anzahl der Pods, die auf dem Node ausgeführt werden können.</p><h3 id=info>Info</h3><p>Allgemeine Informationen zum Node, z. B. Kernelversion, Kubernetes-Version
(kubelet- und kube-Proxy-Version), Docker-Version (falls verwendet), Betriebssystemname.
Die Informationen werden von Kubelet vom Node gesammelt.</p><h2 id=management>Management</h2><p>Im Gegensatz zu <a href=/docs/concepts/workloads/pods/pod/>Pods</a> und <a href=/docs/concepts/services-networking/service/>Services</a>,
ein Node wird nicht von Kubernetes erstellt: Er wird extern von Cloud-Anbietern wie Google Compute Engine erstellt oder ist in Ihrem Pool physischer oder virtueller Maschinen vorhanden.
Wenn Kubernetes also einen Node erstellt, wird ein Objekt erstellt, das den Node darstellt.
Nach der Erstellung überprüft Kubernetes, ob der Node gültig ist oder nicht.</p><p>Wenn Sie beispielsweise versuchen, einen Node aus folgendem Inhalt zu erstellen:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kubernetes erstellt intern ein Node-Objekt (die Darstellung) und validiert den Node durch Zustandsprüfung basierend auf dem Feld <code>metadata.name</code>.
Wenn der Node gültig ist, d.h. wenn alle notwendigen Dienste ausgeführt werden, ist er berechtigt, einen Pod auszuführen.
Andernfalls wird er für alle Clusteraktivitäten ignoriert, bis er gültig wird.</p><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Kubernetes behält das Objekt für den ungültigen Node und prüft ständig seine Gültigkeit.
Sie müssen das Node-Objekt explizit löschen, um diesen Prozess zu stoppen.</div><p>Aktuell gibt es drei Komponenten, die mit dem Kubernetes Node-Interface interagieren: Node Controller, Kubelet und Kubectl.</p><h3 id=node-controller>Node Controller</h3><p>Der Node Controller ist eine Kubernetes-Master-Komponente, die verschiedene Aspekte von Nodes verwaltet.</p><p>Der Node Controller hat mehrere Rollen im Leben eines Nodes.
Der erste ist die Zuordnung eines CIDR-Blocks zu dem Node, wenn er registriert ist (sofern die CIDR-Zuweisung aktiviert ist).</p><p>Die zweite ist, die interne Node-Liste des Node Controllers mit der Liste der verfügbaren Computer des Cloud-Anbieters auf dem neuesten Stand zu halten.
Wenn ein Node in einer Cloud-Umgebung ausgeführt wird und sich in einem schlechten Zustand befindet, fragt der Node Controller den Cloud-Anbieter, ob die virtuelle Maschine für diesen Node noch verfügbar ist. Wenn nicht, löscht der Node Controller den Node aus seiner Node-Liste.</p><p>Der dritte ist die Überwachung des Zustands der Nodes. Der Node Controller ist dafür verantwortlich,
die NodeReady-Bedingung von NodeStatus auf ConditionUnknown zu aktualisieren, wenn ein Node unerreichbar wird (der Node Controller empfängt aus irgendeinem Grund keine Herzschläge mehr, z.B. weil der Node heruntergefahren ist) und später alle Pods aus dem Node zu entfernen (und diese ordnungsgemäss zu beenden), wenn der Node weiterhin unzugänglich ist. (Die Standard-Timeouts sind 40s, um ConditionUnknown zu melden und 5 Minuten, um mit der Evakuierung der Pods zu beginnen).</p><p>Der Node Controller überprüft den Zustand jedes Nodes alle <code>--node-monitor-period</code> Sekunden.</p><p>In Versionen von Kubernetes vor 1.13 ist NodeStatus der Herzschlag des Nodes.
Ab Kubernetes 1.13 wird das Node-Lease-Feature als Alpha-Feature eingeführt (Feature-Gate <code>NodeLease</code>, <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md>KEP-0009</a>).</p><p>Wenn die Node Lease Funktion aktiviert ist, hat jeder Node ein zugeordnetes <code>Lease</code>-Objekt im <code>kube-node-lease</code>-Namespace, das vom Node regelmäßig erneuert wird.
Sowohl NodeStatus als auch Node Lease werden als Herzschläge vom Node aus behandelt.
Node Leases werden häufig erneuert, während NodeStatus nur dann vom Node zu Master gemeldet wird, wenn sich etwas ändert oder genügend Zeit vergangen ist (Standard ist 1 Minute, was länger ist als der Standard-Timeout von 40 Sekunden für unerreichbare Nodes).
Da Node Leases viel lastärmer sind als NodeStatus, macht diese Funktion den Node Herzschlag sowohl in Bezug auf Skalierbarkeit als auch auf die Leistung deutlich effizienter.</p><p>In Kubernetes 1.4 haben wir die Logik der Node-Steuerung aktualisiert, um Fälle besser zu handhaben, in denen eine große Anzahl von Nodes Probleme hat, den Master zu erreichen (z.B. weil der Master Netzwerkprobleme hat).
Ab 1.4 betrachtet der Node-Controller den Zustand aller Nodes im Cluster, wenn er eine Entscheidung über die Enterfung eines Pods trifft.</p><p>In den meisten Fällen begrenzt der Node-Controller die Entfernungsrate auf <code>--node-eviction-rate</code> (Standard 0,1) pro Sekunde, was bedeutet, dass er die Pods nicht von mehr als einem Node pro 10 Sekunden entfernt.</p><p>Das Entfernungsverhalten von Nodes ändert sich, wenn ein Node in einer bestimmten Verfügbarkeitszone ungesund wird.
Der Node-Controller überprüft gleichzeitig, wie viel Prozent der Nodes in der Zone ungesund sind (NodeReady-Bedingung ist ConditionUnknown oder ConditionFalse).
Wenn der Anteil der ungesunden Nodes mindestens <code>--unhealthy-zone-threshold</code> (Standard 0,55) beträgt, wird die Entfernungsrate reduziert:</p><p>Wenn der Cluster klein ist (d.h. weniger als oder gleich <code>--large-cluster-size-threshold</code> Node - Standard 50), werden die Entfernungen gestoppt. Andernfalls wird die Entfernungsrate auf <code>--secondary-node-eviction-rate</code> (Standard 0,01) pro Sekunde reduziert.</p><p>Der Grund, warum diese Richtlinien pro Verfügbarkeitszone implementiert werden, liegt darin, dass eine Verfügbarkeitszone vom Master unerreichbar werden könnte, während die anderen verbunden bleiben. Wenn Ihr Cluster nicht mehrere Verfügbarkeitszonen von Cloud-Anbietern umfasst, gibt es nur eine Verfügbarkeitszone (den gesamten Cluster).</p><p>Ein wichtiger Grund für die Verteilung Ihrer Nodes auf Verfügbarkeitszonen ist, dass die Arbeitsbelastung auf gesunde Zonen verlagert werden kann, wenn eine ganze Zone ausfällt.
Wenn also alle Nodes in einer Zone ungesund sind, entfernt Node Controller mit der normalen <code>--node-eviction-rate</code> Geschwindigkeit.
Der Ausnahmefall ist, wenn alle Zonen völlig ungesund sind (d.h. es gibt keine gesunden Node im Cluster).
In diesem Fall geht der Node-Controller davon aus, dass es ein Problem mit der Master-Konnektivität gibt und stoppt alle Entfernungen, bis die Verbindung wiederhergestellt ist.</p><p>Ab Kubernetes 1.6 ist der Node-Controller auch für die Entfernung von Pods zuständig, die auf Nodes mit <code>NoExecute</code>-Taints laufen, wenn die Pods die Markierungen nicht tolerieren.
Zusätzlich ist der NodeController als Alpha-Funktion, die standardmäßig deaktiviert ist, dafür verantwortlich, Taints hinzuzufügen, die Node Probleme, wie <code>Node unreachable</code> oder <code>not ready</code> entsprechen.
Siehe <a href=/docs/concepts/configuration/taint-and-toleration/>diese Dokumentation</a> für Details über <code>NoExecute</code> Taints und die Alpha-Funktion.</p><p>Ab Version 1.8 kann der Node-Controller für die Erzeugung von Taints, die Node Bedingungen darstellen, verantwortlich gemacht werden. Dies ist eine Alpha-Funktion der Version 1.8.</p><h3 id=selbstregistrierung-von-nodes>Selbstregistrierung von Nodes</h3><p>Wenn das Kubelet-Flag <code>--register-node</code> aktiv ist (Standard), versucht das Kubelet, sich beim API-Server zu registrieren. Dies ist das bevorzugte Muster, das von den meisten Distributionen verwendet wird.</p><p>Zur Selbstregistrierung wird das kubelet mit den folgenden Optionen gestartet:</p><ul><li><code>--kubeconfig</code> - Pfad zu Anmeldeinformationen, um sich beim Apiserver zu authentifizieren.</li><li><code>--cloud-provider</code> - Wie man sich mit einem Cloud-Anbieter unterhält, um Metadaten über sich selbst zu lesen.</li><li><code>--register-node</code> - Automatisch beim API-Server registrieren.</li><li><code>--register-with-taints</code> - Registrieren Sie den Node mit der angegebenen Taints-Liste (Kommagetrennt <code>&lt;key>=&lt;value>:&lt;effect></code>). No-op wenn <code>register-node</code> false ist.</li><li><code>--node-ip</code> - IP-Adresse des Nodes.</li><li><code>--node-labels</code> - Labels, die bei der Registrierung des Nodes im Cluster hinzugefügt werden sollen (Beachten Sie die Richlinien des <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a> in 1.13+).</li><li><code>--node-status-update-frequency</code> - Gibt an, wie oft kubelet den Nodestatus an den Master übermittelt.</li></ul><p>Wenn der <a href=/docs/reference/access-authn-authz/node/>Node authorization mode</a> und
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a> aktiviert sind,
dürfen kubelets nur ihre eigene Node-Ressource erstellen / ändern.</p><h4 id=manuelle-nodeverwaltung>Manuelle Nodeverwaltung</h4><p>Ein Cluster-Administrator kann Nodeobjekte erstellen und ändern.</p><p>Wenn der Administrator Nodeobjekte manuell erstellen möchte, setzen Sie das kubelet Flag <code>--register-node=false</code>.</p><p>Der Administrator kann Node-Ressourcen ändern (unabhängig von der Einstellung von <code>--register-node</code>).
Zu den Änderungen gehören das Setzen von Labels und das Markieren des Nodes.</p><p>Labels auf Nodes können in Verbindung mit node selectors auf Pods verwendet werden, um die Planung zu steuern, z.B. um einen Pod so zu beschränken, dass er nur auf einer Teilmenge der Nodes ausgeführt werden darf.</p><p>Das Markieren eines Nodes als nicht geplant, verhindert, dass neue Pods für diesen Node geplant werden. Dies hat jedoch keine Auswirkungen auf vorhandene Pods auf dem Node.
Dies ist nützlich als vorbereitender Schritt vor einem Neustart eines Nodes usw.
Um beispielsweise einen Node als nicht geplant zu markieren, führen Sie den folgenden Befehl aus:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Pods, die von einem DaemonSet-Controller erstellt wurden, umgehen den Kubernetes-Scheduler und respektieren nicht das <em>unschedulable</em> Attribut auf einem Node.
Dies setzt voraus, dass Daemons auf dem Computer verbleiben, auch wenn während der Vorbereitung eines Neustarts keine Anwendungen mehr vorhanden sind.</div><h3 id=node-kapazität>Node Kapazität</h3><p>Die Kapazität des Nodes (Anzahl der CPU und Speichermenge) ist Teil des Nodeobjekts.
Normalerweise registrieren sich Nodes selbst und melden ihre Kapazität beim Erstellen des Nodeobjekts.
Sofern Sie <a href=#Manuelle-Nodeverwaltung>Manuelle Nodeverwaltung</a> betreiben, müssen Sie die Node Kapazität setzen, wenn Sie einen Node hinzufügen.</p><p>Der Kubernetes-Scheduler stellt sicher, dass für alle Pods auf einem Nodes genügend Ressourcen vorhanden sind.
Er prüft, dass die Summe der Requests von Containern auf dem Node nicht größer ist als die Kapazität des Nodes.
Er beinhaltet alle Container die vom kubelet gestarted worden, aber keine Container die direkt von der <a href=/docs/concepts/overview/components/#node-components>container runtime</a> gestartet wurden, noch jegleiche Prozesse die ausserhalb von Containern laufen.</p><p>Wenn Sie Ressourcen explizit für Nicht-Pod-Prozesse reservieren möchten, folgen Sie diesem Lernprogramm um <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>Ressourcen für Systemdaemons zu reservieren</a>.</p><h2 id=api-objekt>API-Objekt</h2><p>Node ist eine Top-Level-Ressource in der Kubernetes-REST-API. Weitere Details zum API-Objekt finden Sie unter:
<a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>Node API object</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-63e7fdf87ba61eb2586bb8c625c23506>2.2 - Master-Node Kommunikation</h1><p>Dieses Dokument katalogisiert die Kommunikationspfade zwischen dem Master (eigentlich dem Apiserver) und des Kubernetes-Clusters.
Die Absicht besteht darin, Benutzern die Möglichkeit zu geben, ihre Installation so anzupassen, dass die Netzwerkkonfiguration so abgesichert wird, dass der Cluster in einem nicht vertrauenswürdigen Netzwerk (oder mit vollständig öffentlichen IP-Adressen eines Cloud-Providers) ausgeführt werden kann.</p><h2 id=cluster-zum-master>Cluster zum Master</h2><p>Alle Kommunikationspfade vom Cluster zum Master enden beim Apiserver (keine der anderen Master-Komponenten ist dafür ausgelegt, Remote-Services verfügbar zu machen).
In einem typischen Setup ist der Apiserver so konfiguriert, dass er Remote-Verbindungen an einem sicheren HTTPS-Port (443) mit einer oder mehreren Formen der <a href=/docs/reference/access-authn-authz/authentication/>Clientauthentifizierung</a> überwacht.
Eine oder mehrere Formene von <a href=/docs/reference/access-authn-authz/authorization/>Autorisierung</a> sollte aktiviert sein, insbesondere wenn <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>anonyme Anfragen</a> oder <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>Service Account Tokens</a> aktiviert sind.</p><p>Nodes sollten mit dem öffentlichen Stammzertifikat für den Cluster konfiguriert werden, sodass sie eine sichere Verbindung zum Apiserver mit gültigen Client-Anmeldeinformationen herstellen können.
Beispielsweise bei einer gewöhnlichen GKE-Konfiguration enstprechen die dem kubelet zur Verfügung gestellten Client-Anmeldeinformationen eines Client-Zertifikats.
Lesen Sie über <a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS bootstrapping</a> zur automatisierten Bereitstellung von kubelet-Client-Zertifikaten.</p><p>Pods, die eine Verbindung zum Apiserver herstellen möchten, können dies auf sichere Weise tun, indem sie ein Dienstkonto verwenden, sodass Kubernetes das öffentliche Stammzertifikat und ein gültiges Trägertoken automatisch in den Pod einfügt, wenn er instanziiert wird.
Der <code>kubernetes</code>-Dienst (in allen Namespaces) ist mit einer virtuellen IP-Adresse konfiguriert, die (über den Kube-Proxy) an den HTTPS-Endpunkt auf dem Apiserver umgeleitet wird.</p><p>Die Master-Komponenten kommunizieren auch über den sicheren Port mit dem Cluster-Apiserver.</p><p>Der Standardbetriebsmodus für Verbindungen vom Cluster (Knoten und Pods, die auf den Knoten ausgeführt werden) zum Master ist daher standardmäßig gesichert und kann über nicht vertrauenswürdige und/oder öffentliche Netzwerke laufen.</p><h2 id=master-zum-cluster>Master zum Cluster</h2><p>Es gibt zwei primäre Kommunikationspfade vom Master (Apiserver) zum Cluster.
Der Erste ist vom Apiserver hin zum Kubelet-Prozess, der auf jedem Node im Cluster ausgeführt wird.
Der Zweite ist vom Apiserver zu einem beliebigen Node, Pod oder Dienst über die Proxy-Funktionalität des Apiservers.</p><h3 id=apiserver-zum-kubelet>Apiserver zum kubelet</h3><p>Die Verbindungen vom Apiserver zum Kubelet werden verwendet für:</p><ul><li>Das Abrufen von Protokollen für Pods.</li><li>Das Verbinden (durch kubectl) mit laufenden Pods.</li><li>Die Bereitstellung der Portweiterleitungsfunktion des kubelet.</li></ul><p>Diese Verbindungen enden am HTTPS-Endpunkt des kubelet.
Standardmäßig überprüft der Apiserver das Serverzertifikat des Kubelets nicht, was die Verbindung angreifbar für Man-in-the-Middle-Angriffe macht. Die Kommunikation ist daher <strong>unsicher</strong>, wenn die Verbindungen über nicht vertrauenswürdige und/oder öffentliche Netzwerke laufen.</p><p>Um diese Verbindung zu überprüfen, verwenden Sie das Flag <code>--kubelet-certificate-authority</code>, um dem Apiserver ein Stammzertifikatbündel bereitzustellen, das zur Überprüfung des Server-Zertifikats des kubelets verwendet wird.</p><p>Wenn dies nicht möglich ist, verwenden Sie <a href=/docs/concepts/architecture/master-node-communication/#ssh-tunnels>SSH tunneling</a>
zwischen dem Apiserver und dem kubelet, falls es erforderlich ist eine Verbindung über ein nicht vertrauenswürdiges oder öffentliches Netz zu vermeiden.</p><p>Außerdem sollte <a href=/docs/admin/kubelet-authentication-authorization/>Kubelet Authentifizierung und/oder Autorisierung</a> aktiviert sein, um die kubelet-API abzusichern.</p><h3 id=apiserver-zu-nodes-pods-und-services>Apiserver zu Nodes, Pods und Services</h3><p>Die Verbindungen vom Apiserver zu einem Node, Pod oder Dienst verwenden standardmäßig einfache HTTP-Verbindungen und werden daher weder authentifiziert noch verschlüsselt.
Sie können über eine sichere HTTPS-Verbindung ausgeführt werden, indem dem Node, dem Pod oder dem Servicenamen in der API-URL "https:" vorangestellt wird. Das vom HTTPS-Endpunkt bereitgestellte Zertifikat wird jedoch nicht überprüft, und es werden keine Clientanmeldeinformationen bereitgestellt. Die Verbindung wird zwar verschlüsselt, garantiert jedoch keine Integrität.
Diese Verbindungen <strong>sind derzeit nicht sicher</strong> innerhalb von nicht vertrauenswürdigen und/oder öffentlichen Netzen.</p><h3 id=ssh-tunnels>SSH Tunnels</h3><p>Kubernetes unterstützt SSH-Tunnel zum Schutz der Master -> Cluster Kommunikationspfade.
In dieser Konfiguration initiiert der Apiserver einen SSH-Tunnel zu jedem Node im Cluster (Verbindung mit dem SSH-Server, der mit Port 22 läuft), und leitet den gesamten Datenverkehr für ein kubelet, einen Node, einen Pod oder einen Dienst durch den Tunnel.
Dieser Tunnel stellt sicher, dass der Datenverkehr nicht außerhalb des Netzwerks sichtbar ist, in dem die Knoten ausgeführt werden.</p><p>SSH-Tunnel werden zur Zeit nicht unterstützt. Sie sollten also nicht verwendet werden, sei denn, man weiß, was man tut. Ein Ersatz für diesen Kommunikationskanal wird entwickelt.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>2.3 - Zugrunde liegende Konzepte des Cloud Controller Manager</h1><p>Das Konzept des Cloud Controller Managers (CCM) (nicht zu verwechseln mit der Binärdatei) wurde ursprünglich entwickelt, um Cloud-spezifischen Anbieter Code und den Kubernetes Kern unabhängig voneinander entwickeln zu können. Der Cloud Controller Manager läuft zusammen mit anderen Master Komponenten wie dem Kubernetes Controller Manager, dem API-Server und dem Scheduler auf dem Host. Es kann auch als Kubernetes Addon gestartet werden, in diesem Fall läuft er auf Kubernetes.</p><p>Das Design des Cloud Controller Managers basiert auf einem Plugin Mechanismus, der es neuen Cloud Anbietern ermöglicht, sich mit Kubernetes einfach über Plugins zu integrieren. Es gibt Pläne für die Einbindung neuer Cloud Anbieter auf Kubernetes und für die Migration von Cloud Anbietern vom alten Modell auf das neue CCM-Modell.</p><p>Dieses Dokument beschreibt die Konzepte hinter dem Cloud Controller Manager und gibt Details zu den damit verbundenen Funktionen.</p><p>Die Architektur eines Kubernetes Clusters ohne den Cloud Controller Manager sieht wie folgt aus:</p><p><img src=/images/docs/pre-ccm-arch.png alt="Pre CCM Kube Arch"></p><h2 id=design>Design</h2><p>Im vorhergehenden Diagramm sind Kubernetes und der Cloud-Provider über mehrere verschiedene Komponenten integriert:</p><ul><li>Kubelet</li><li>Kubernetes Controller Manager</li><li>Kubernetes API Server</li></ul><p>CCM konsolidiert die gesamte Abhängigkeit der Cloud Logik von den drei vorhergehenden Komponenten zu einem einzigen Integrationspunkt mit der Cloud. So sieht die neue Architektur mit dem CCM aus:</p><p><img src=/images/docs/post-ccm-arch.png alt="CCM Kube Arch"></p><h2 id=komponenten-des-ccm>Komponenten des CCM</h2><p>Der CCM löst einen Teil der Funktionalität des Kubernetes Controller Managers (KCM) ab und führt ihn als separaten Prozess aus. Konkret trennt es die Cloud abhängigen Controller im KCM. Der KCM verfügt über die folgenden Cloud abhängigen Steuerungsschleifen:</p><ul><li>Node Controller</li><li>Volume Controller</li><li>Route Controller</li><li>Service Controller</li></ul><p>In der Version 1.9 führt der CCM die folgenden Controller aus der vorhergehenden Liste aus:</p><ul><li>Node Controller</li><li>Route Controller</li><li>Service Controller</li></ul><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Der Volume Controller wurde bewusst nicht als Teil des CCM gewählt. Aufgrund der Komplexität und der bestehenden Bemühungen, herstellerspezifische Volume Logik zu abstrahieren, wurde entschieden, dass der Volume Controller nicht zum CCM verschoben wird.</div><p>Der ursprüngliche Plan, Volumes mit CCM zu integrieren, sah die Verwendung von Flex-Volumes vor welche austauschbare Volumes unterstützt. Allerdings ist eine konkurrierende Initiative namens CSI geplant, um Flex zu ersetzen.</p><p>In Anbetracht dieser Dynamik haben wir uns entschieden, eine Zwischenstopp durchzuführen um die Unterschiede zu beobachten , bis das CSI bereit ist.</p><h2 id=funktionen-des-ccm>Funktionen des CCM</h2><p>Der CCM erbt seine Funktionen von Komponenten des Kubernetes, die von einem Cloud Provider abhängig sind. Dieser Abschnitt ist auf der Grundlage dieser Komponenten strukturiert.</p><h3 id=1-kubernetes-controller-manager>1. Kubernetes Controller Manager</h3><p>Die meisten Funktionen des CCM stammen aus dem KCM. Wie im vorherigen Abschnitt erwähnt, führt das CCM die folgenden Steuerschleifen durch:</p><ul><li>Node Controller</li><li>Route Controller</li><li>Service Controller</li></ul><h4 id=node-controller>Node Controller</h4><p>Der Node Controller ist für die Initialisierung eines Knotens verantwortlich, indem er Informationen über die im Cluster laufenden Knoten vom Cloud Provider erhält. Der Node Controller führt die folgenden Funktionen aus:</p><ol><li>Initialisierung eines Knoten mit Cloud-spezifischen Zonen-/Regionen Labels.</li><li>Initialisieren von Knoten mit Cloud-spezifischen Instanzdetails, z.B. Typ und Größe.</li><li>Ermitteln der Netzwerkadressen und des Hostnamen des Knotens.</li><li>Falls ein Knoten nicht mehr reagiert, überprüft der Controller die Cloud, um festzustellen, ob der Knoten aus der Cloud gelöscht wurde.
Wenn der Knoten aus der Cloud gelöscht wurde, löscht der Controller das Kubernetes Node Objekt.</li></ol><h4 id=route-controller>Route Controller</h4><p>Der Route Controller ist dafür verantwortlich, Routen in der Cloud so zu konfigurieren, dass Container auf verschiedenen Knoten im Kubernetes Cluster miteinander kommunizieren können. Der Route Controller ist nur auf einem Google Compute Engine Cluster anwendbar.</p><h4 id=service-controller>Service Controller</h4><p>Der Service Controller ist verantwortlich für das Abhören von Ereignissen zum Erstellen, Aktualisieren und Löschen von Diensten. Basierend auf dem aktuellen Stand der Services in Kubernetes konfiguriert es Cloud Load Balancer (wie ELB, Google LB oder Oracle Cloud Infrastructure LB), um den Zustand der Services in Kubernetes abzubilden. Darüber hinaus wird sichergestellt, dass die Service Backends für Cloud Loadbalancer auf dem neuesten Stand sind.</p><h3 id=2-kubelet>2. Kubelet</h3><p>Der Node Controller enthält die Cloud-abhängige Funktionalität des Kubelets. Vor der Einführung des CCM war das Kubelet für die Initialisierung eines Knotens mit cloudspezifischen Details wie IP-Adressen, Regions-/Zonenbezeichnungen und Instanztypinformationen verantwortlich. Mit der Einführung des CCM wurde diese Initialisierungsoperation aus dem Kubelet in das CCM verschoben.</p><p>In diesem neuen Modell initialisiert das Kubelet einen Knoten ohne cloudspezifische Informationen. Es fügt jedoch dem neu angelegten Knoten einen Taint hinzu, der den Knoten nicht verplanbar macht, bis der CCM den Knoten mit cloudspezifischen Informationen initialisiert. Dann wird der Taint entfernt.</p><h2 id=plugin-mechanismus>Plugin Mechanismus</h2><p>Der Cloud Controller Manager verwendet die Go Schnittstellen, um Implementierungen aus jeder Cloud einzubinden. Konkret verwendet dieser das CloudProvider Interface, das <a href=https://github.com/kubernetes/cloud-provider/blob/9b77dc1c384685cb732b3025ed5689dd597a5971/cloud.go#L42-L62>hier</a> definiert ist.</p><p>Die Implementierung der vier oben genannten geteiltent Controllern und einigen Scaffolding sowie die gemeinsame CloudProvider Schnittstelle bleiben im Kubernetes Kern. Cloud Provider spezifische Implementierungen werden außerhalb des Kerns aufgebaut und implementieren im Kern definierte Schnittstellen.</p><p>Weitere Informationen zur Entwicklung von Plugins findest du im Bereich <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Entwickeln von Cloud Controller Manager</a>.</p><h2 id=autorisierung>Autorisierung</h2><p>Dieser Abschnitt beschreibt den Zugriff, den der CCM für die Ausführung seiner Operationen auf verschiedene API Objekte benötigt.</p><h3 id=node-controller-1>Node Controller</h3><p>Der Node Controller funktioniert nur mit Node Objekten. Es benötigt vollen Zugang zu get, list, create, update, patch, watch, und delete Node Objekten.</p><p>v1/Node:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=route-controller-1>Route Controller</h3><p>Der Route Controller horcht auf die Erstellung von Node Objekten und konfiguriert die Routen entsprechend. Es erfordert get Zugriff auf die Node Objekte.</p><p>v1/Node:</p><ul><li>Get</li></ul><h3 id=service-controller-1>Service Controller</h3><p>Der Service Controller hört auf die Service Objekt Events create, update und delete und konfiguriert dann die Endpunkte für diese Services entsprechend.</p><p>Um auf Services zuzugreifen, benötigt man list und watch Berechtigung. Um die Services zu aktualisieren, sind patch und update Zugriffsrechte erforderlich.</p><p>Um die Endpunkte für die Dienste einzurichten, benötigt der Controller Zugriff auf create, list, get, watch und update.</p><p>v1/Service:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=sonstiges>Sonstiges</h3><p>Die Implementierung des Kerns des CCM erfordert den Zugriff auf die Erstellung von Ereignissen und zur Gewährleistung eines sicheren Betriebs den Zugriff auf die Erstellung von ServiceAccounts.</p><p>v1/Event:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p>v1/ServiceAccount:</p><ul><li>Create</li></ul><p>Die RBAC ClusterRole für CCM sieht wie folgt aus:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=anbieter-implementierung>Anbieter Implementierung</h2><p>Die folgenden Cloud Anbieter haben CCMs implementiert:</p><ul><li><a href=https://github.com/digitalocean/digitalocean-cloud-controller-manager>Digital Ocean</a></li><li><a href=https://github.com/oracle/oci-cloud-controller-manager>Oracle</a></li><li><a href=https://github.com/kubernetes/cloud-provider-azure>Azure</a></li><li><a href=https://github.com/kubernetes/cloud-provider-gcp>GCP</a></li><li><a href=https://github.com/kubernetes/cloud-provider-aws>AWS</a></li><li><a href=https://github.com/baidu/cloud-provider-baiducloud>BaiduCloud</a></li><li><a href=https://github.com/linode/linode-cloud-controller-manager>Linode</a></li></ul><h2 id=cluster-administration>Cluster Administration</h2><p>Eine vollständige Anleitung zur Konfiguration und zum Betrieb des CCM findest du <a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>hier</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>3 - Container</h1></div><div class=td-content><h1 id=pg-16042b4652ad19e565c7263824029a43>3.1 - Images</h1><p>Sie erstellen Ihr Docker Image und laden es in eine Registry hoch, bevor es in einem Kubernetes Pod referenziert werden kann.</p><p>Die <code>image</code> Eigenschaft eines Containers unterstüzt die gleiche Syntax wie die des <code>docker</code> Kommandos, inklusive privater Registries und Tags.</p><h2 id=aktualisieren-von-images>Aktualisieren von Images</h2><p>Die Standardregel für das Herunterladen von Images ist <code>IfNotPresent</code>, dies führt dazu, dass das Image wird nur heruntergeladen wenn es noch nicht lokal verfügbar ist.
Wenn sie stattdessen möchten, dass ein Image immer forciert heruntergeladen wird, können sie folgendes tun:</p><ul><li>Die <code>imagePullPolicy</code> des Containers auf <code>Always</code> setzen.</li><li>Die <code>imagePullPolicy</code> auslassen und <code>:latest</code> als Image Tag nutzen.</li><li>Die <code>imagePullPolicy</code> und den Tag des Images auslassen.</li><li>Den <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> Admission Controller aktivieren.</li></ul><p>Beachten Sie, dass Sie die Nutzung des <code>:latest</code> Tags vermeiden sollten. Für weitere Informationen siehe: <a href=/docs/concepts/configuration/overview/#container-images>Best Practices for Configuration</a>.</p><h2 id=multi-architektur-images-mit-manifesten-bauen>Multi-Architektur Images mit Manifesten bauen</h2><p>Das Docker Kommandozeilenwerkzeug unterstützt jetzt das Kommando <code>docker manifest</code> mit den Subkommandos <code>create</code>, <code>annotate</code> and <code>push</code>.
Diese Kommandos können dazu genutzt werden Manifeste zu bauen und diese hochzuladen.</p><p>Weitere Informationen finden sie in der Docker Dokumentation:
<a href=https://docs.docker.com/edge/engine/reference/commandline/manifest/>https://docs.docker.com/edge/engine/reference/commandline/manifest/</a></p><p>Hier einige Beispiele wie wir dies in unserem Build - Prozess nutzen:
<a href="https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&i=nope&files=&repos=">https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&i=nope&files=&repos=</a></p><p>Diese Kommandos basieren rein auf dem Docker Kommandozeileninterface und werden auch damit ausgeführt. Sie sollten entweder die Datei <code>$HOME/.docker/config.json</code> bearbeiten und den <code>experimental</code> Schlüssel auf <code>enabled</code> setzen, oder einfach die Umgebungsvariable <code>DOCKER_CLI_EXPERIMENTAL</code> auf <code>enabled</code> setzen, wenn Sie das Docker Kommandozeileninterface aufrufen.</p><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Nutzen die bitte Docker <em>18.06 oder neuer</em>, ältere Versionen haben entweder Bugs oder unterstützen die experimentelle Kommandozeilenoption nicht. Beispiel: <a href=https://github.com/docker/cli/issues/1135>https://github.com/docker/cli/issues/1135</a> verursacht Probleme unter containerd.</div><p>Wenn mit alten Manifesten Probleme auftreten, können sie die alten Manifeste in <code>$HOME/.docker/manifests</code> entfernen, um von vorne zu beginnen.</p><p>Für Kubernetes selbst nutzen wir typischerweise Images mit dem Suffix <code>-$(ARCH)</code>. Um die Abwärtskompatibilität zu erhalten, bitten wir Sie, die älteren Images mit diesen Suffixen zu generieren. Die Idee dahinter ist z.B., das <code>pause</code> image zu generieren, welches das Manifest für alle Architekturen hat, <code>pause-amd64</code> wäre dann abwärtskompatibel zu älteren Konfigurationen, oder YAML - Dateien, die ein Image mit Suffixen hart kodiert enthalten.</p><h2 id=nutzung-einer-privaten-registry>Nutzung einer privaten Registry</h2><p>Private Registries könnten Schlüssel erfordern um Images von ihnen herunterzuladen.
Authentifizierungsdaten können auf verschiedene Weisen hinterlegt werden:</p><ul><li>Bei der Google Container Registry<ul><li>Je Cluster</li><li>Automatisch in der Google Compute Engine oder Google Kubernetes Engine</li><li>Allen Pods erlauben von der privaten Registry des Projektes lesen zu können</li></ul></li><li>Bei der Amazon Elastic Container Registry (ECR)<ul><li>IAM Rollen und Richtlinien nutzen um den Zugriff auf ECR Repositories zu kontrollieren</li><li>Automatisch ECR Authentifizierungsdaten aktualisieren</li></ul></li><li>Bei der Oracle Cloud Infrastructure Registry (OCIR)<ul><li>IAM Rollen und Richtlinien nutzen um den Zugriff auf OCIR Repositories zu kontrollieren</li></ul></li><li>Bei der Azure Container Registry (ACR)</li><li>Bei der IBM Cloud Container Registry</li><li>Nodes konfigurieren sich bei einer privaten Registry authentifizieren zu können
- Allen Pods erlauben von jeder konfigurierten privaten Registry lesen zu können
- Setzt die Konfiguration der Nodes durch einen Cluster - Aministrator voraus</li><li>Im Voraus heruntergeladene Images<ul><li>Alle Pods können jedes gecachte Image auf einem Node nutzen</li><li>Setzt root - Zugriff auf allen Nodes zum Einrichten voraus</li></ul></li><li>Spezifizieren eines ImagePullSecrets auf einem Pod<ul><li>Nur Pods, die eigene Secrets tragen, haben Zugriff auf eine private Registry</li></ul></li></ul><p>Jede Option wird im Folgenden im Detail beschrieben</p><h3 id=bei-nutzung-der-google-container-registry>Bei Nutzung der Google Container Registry</h3><p>Kubernetes hat eine native Unterstützung für die <a href=https://cloud.google.com/tools/container-registry/>Google Container
Registry (GCR)</a> wenn es auf der Google Compute
Engine (GCE) läuft. Wenn Sie ihren Cluster auf GCE oder der Google Kubernetes Engine betreiben, genügt es, einfach den vollen Image Namen zu nutzen (z.B. gcr.io/my_project/image:tag ).</p><p>Alle Pods in einem Cluster haben dann Lesezugriff auf Images in dieser Registry.</p><p>Das Kubelet authentifiziert sich bei GCR mit Nutzung des Google service Kontos der jeweiligen Instanz.
Das Google Servicekonto der Instanz hat einen <code>https://www.googleapis.com/auth/devstorage.read_only</code>, so kann es vom GCR des Projektes herunter, aber nicht hochladen.</p><h3 id=bei-nutzung-der-amazon-elastic-container-registry>Bei Nutzung der Amazon Elastic Container Registry</h3><p>Kubernetes bietet native Unterstützung für die <a href=https://aws.amazon.com/ecr/>Amazon Elastic Container Registry</a>, wenn Knoten AWS EC2 Instanzen sind.</p><p>Es muss einfach nur der komplette Image Name (z.B. <code>ACCOUNT.dkr.ecr.REGION.amazonaws.com/imagename:tag</code>) in der Pod - Definition genutzt werden.</p><p>Alle Benutzer eines Clusters, die Pods erstellen dürfen, können dann jedes der Images in der ECR Registry zum Ausführen von Pods nutzen.</p><p>Das Kubelet wird periodisch ECR Zugriffsdaten herunterladen und auffrischen, es benötigt hierfür die folgenden Berechtigungen:</p><ul><li><code>ecr:GetAuthorizationToken</code></li><li><code>ecr:BatchCheckLayerAvailability</code></li><li><code>ecr:GetDownloadUrlForLayer</code></li><li><code>ecr:GetRepositoryPolicy</code></li><li><code>ecr:DescribeRepositories</code></li><li><code>ecr:ListImages</code></li><li><code>ecr:BatchGetImage</code></li></ul><p>Voraussetzungen:</p><ul><li>Sie müssen Kubelet in der Version <code>v1.2.0</code> nutzen. (Führen sie z.B. (e.g. run <code>/usr/bin/kubelet --version=true</code> aus um die Version zu prüfen)</li><li>Sie benötigen Version <code>v1.3.0</code> oder neuer wenn ihre Knoten in einer A - Region sind und sich ihre Registry in einer anderen B - Region befindet.</li><li>ECR muss in ihrer Region angeboten werden</li></ul><p>Fehlerbehebung:</p><ul><li>Die oben genannten Voraussetzungen müssen erfüllt sein</li><li>Laden sie die $REGION (z.B. <code>us-west-2</code>) Zugriffsdaten auf ihren Arbeitsrechner. Verbinden sie sich per SSH auf den Host und nutzen die Docker mit diesen Daten. Funktioniert es?</li><li>Prüfen sie ob das Kubelet it dem Parameter <code>--cloud-provider=aws</code> läuft.</li><li>Prüfen sie die Logs des Kubelets (z.B. mit <code>journalctl -u kubelet</code>) auf Zeilen wie:<ul><li><code>plugins.go:56] Registering credential provider: aws-ecr-key</code></li><li><code>provider.go:91] Refreshing cache for provider: *aws_credentials.ecrProvider</code></li></ul></li></ul><h3 id=bei-nutzung-der-azure-container-registry-acr>Bei Nutzung der Azure Container Registry (ACR)</h3><p>Bei Nutzung der <a href=https://azure.microsoft.com/en-us/services/container-registry/>Azure Container Registry</a> können sie sich entweder als ein administrativer Nutzer, oder als ein Service Principal authentifizieren.
In jedem Fall wird die Authentifizierung über die Standard - Docker Authentifizierung ausgeführt. Diese Anleitung bezieht sich auf das <a href=https://github.com/azure/azure-cli>azure-cli</a> Kommandozeilenwerkzeug.</p><p>Sie müssen zunächst eine Registry und Authentifizierungsdaten erstellen, eine komplette Dokumentation dazu finden sie hier: <a href=https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli>Azure container registry documentation</a>.</p><p>Sobald sie ihre Container Registry erstellt haben, nutzen sie die folgenden Authentifizierungsdaten:</p><ul><li><code>DOCKER_USER</code> : Service Principal oder Administratorbenutzername</li><li><code>DOCKER_PASSWORD</code>: Service Principal Password oder Administratorpasswort</li><li><code>DOCKER_REGISTRY_SERVER</code>: <code>${some-registry-name}.azurecr.io</code></li><li><code>DOCKER_EMAIL</code>: <code>${some-email-address}</code></li></ul><p>Wenn sie diese Variablen befüllt haben, können sie:
<a href=/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>Kubernetes konfigurieren und damit einen Pod deployen</a>.</p><h3 id=bei-nutzung-der-ibm-cloud-container-registry>Bei Nutzung der IBM Cloud Container Registry</h3><p>Die IBM Cloud Container Registry bietet eine mandantenfähige Private Image Registry, die Sie nutzen können, um ihre Docker Images sicher zu speichern und zu teilen.
Standardmäßig werden Images in ihrer Private Registry vom integrierten Schwachstellenscaner durchsucht, um Sicherheitsprobleme und potentielle Schwachstellen zu finden. Benutzer können ihren IBM Cloud Account nutzen, um Zugang zu ihren Images zu erhalten, oder um einen Token zu generieren, der Zugriff auf die Registry Namespaces erlaubt.</p><p>Um das IBM Cloud Container Registry Kommandozeilenwerkzeug zu installieren und einen Namespace für ihre Images zu erstellen, folgen sie dieser Dokumentation <a href="https://cloud.ibm.com/docs/services/Registry?topic=registry-getting-started">Getting started with IBM Cloud Container Registry</a>.</p><p>Sie können die IBM Cloud Container Registry nutzen, um Container aus <a href="https://cloud.ibm.com/docs/services/Registry?topic=registry-public_images">IBM Cloud public images</a> und ihren eigenen Images in den <code>default</code> Namespace ihres IBM Cloud Kubernetes Service Clusters zu deployen.
Um einen Container in einen anderen Namespace, oder um ein Image aus einer anderen IBM Cloud Container Registry Region oder einem IBM Cloud account zu deployen, erstellen sie ein Kubernetes <code>imagePullSecret</code>.
Weitere Informationen finden sie unter: <a href="https://cloud.ibm.com/docs/containers?topic=containers-images">Building containers from images</a>.</p><h3 id=knoten-für-die-nutzung-einer-private-registry-konfigurieren>Knoten für die Nutzung einer Private Registry konfigurieren</h3><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Wenn sie Google Kubernetes Engine verwenden, gibt es schon eine <code>.dockercfg</code> auf jedem Knoten, die Zugriffsdaten für ihre Google Container Registry beinhaltet. Dann kann die folgende Vorgehensweise nicht angewendet werden.</div><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Wenn sie AWS EC2 verwenden und die EC2 Container Registry (ECR) nutzen, wird das Kubelet auf jedem Knoten die ECR Zugriffsdaten verwalten und aktualisieren. Dann kann die folgende Vorgehensweise nicht angewendet werden.</div><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Diese Vorgehensweise ist anwendbar, wenn sie ihre Knoten-Konfiguration ändern können; Sie wird nicht zuverlässig auf GCE oder einem anderen Cloud - Provider funktionieren, der automatisch Knoten ersetzt.</div><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Kubernetes unterstützt zurzeit nur die <code>auths</code> und <code>HttpHeaders</code> Abschnitte der Dockerkonfiguration. Das bedeutet, dass die Hilfswerkzeuge (<code>credHelpers</code> ooderr <code>credsStore</code>) nicht unterstützt werden.</div><p>Docker speichert Schlüssel für eigene Registries entweder unter <code>$HOME/.dockercfg</code> oder <code>$HOME/.docker/config.json</code>. Wenn sie die gleiche Datei in einen der unten aufgeführten Suchpfade speichern, wird Kubelet sie als Hilfswerkzeug für Zugriffsdaten beim Beziehen von Images nutzen.</p><ul><li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li><li><code>{cwd of kubelet}/config.json</code></li><li><code>${HOME}/.docker/config.json</code></li><li><code>/.docker/config.json</code></li><li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li><li><code>{cwd of kubelet}/.dockercfg</code></li><li><code>${HOME}/.dockercfg</code></li><li><code>/.dockercfg</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Eventuell müssen sie <code>HOME=/root</code> in ihrer Umgebungsvariablendatei setzen.</div><p>Dies sind die empfohlenen Schritte, um ihre Knoten für eine Nutzung einer eigenen Registry zu konfigurieren.
In diesem Beispiel führen sie folgende Schritte auf ihrem Desktop/Laptop aus:</p><ol><li>Führen sie <code>docker login [server]</code> für jeden Satz ihrer Zugriffsdaten aus. Dies aktualisiert <code>$HOME/.docker/config.json</code>.</li><li>Prüfen Sie <code>$HOME/.docker/config.json</code> in einem Editor darauf, ob dort nur Zugriffsdaten enthalten sind, die Sie nutzen möchten.</li><li>Erhalten sie eine Liste ihrer Knoten:<ul><li>Wenn sie die Namen benötigen: <code>nodes=$(kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}')</code></li><li>Wenn sie die IP - Adressen benötigen: <code>nodes=$(kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}')</code></li></ul></li><li>Kopieren sie ihre lokale <code>.docker/config.json</code> in einen der oben genannten Suchpfade.<ul><li>Zum Beispiel: <code>for n in $nodes; do scp ~/.docker/config.json root@$n:/var/lib/kubelet/config.json; done</code></li></ul></li></ol><p>Prüfen durch das Erstellen eines Pods, der ein eigenes Image nutzt, z.B.:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f - &lt;&lt;EOF<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-image-test-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>uses-private-image<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>$PRIVATE_IMAGE_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;echo&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;SUCCESS&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>EOF<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>pod/private-image-test-1 created<span style=color:#bbb>
</span></span></span></code></pre></div><p>Wenn alles funktioniert, sollten sie nach einigen Momenten folgendes sehen:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs private-image-test-1
</span></span><span style=display:flex><span>SUCCESS
</span></span></code></pre></div><p>Wenn es nicht funktioniert, sehen Sie:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#34;Failed&#34;</span>
</span></span><span style=display:flex><span>  Fri, <span style=color:#666>26</span> Jun <span style=color:#666>2015</span> 15:36:13 -0700    Fri, <span style=color:#666>26</span> Jun <span style=color:#666>2015</span> 15:39:13 -0700    <span style=color:#666>19</span>    <span style=color:#666>{</span>kubelet node-i2hq<span style=color:#666>}</span>    spec.containers<span style=color:#666>{</span>uses-private-image<span style=color:#666>}</span>    failed        Failed to pull image <span style=color:#b44>&#34;user/privaterepo:v1&#34;</span>: Error: image user/privaterepo:v1 not found
</span></span></code></pre></div><p>Sie müssen sich darum kümmern, dass alle Knoten im Cluster die gleiche <code>.docker/config.json</code> haben, andernfalls werden Pods auf einigen Knoten starten, auf anderen jedoch nicht.
Wenn sie zum Beispiel Knoten automatisch skalieren lassen, sollte dann jedes Instanztemplate die <code>.docker/config.json</code> beinhalten, oder ein Laufwerk einhängen, das diese beinhaltet.</p><p>Alle Pods haben Lesezugriff auf jedes Image in ihrer eigenen Registry, sobald die Registry - Schlüssel zur <code>.docker/config.json</code> hinzugefügt wurden.</p><h3 id=im-voraus-heruntergeladene-images>Im Voraus heruntergeladene Images</h3><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Wenn sie Google Kubernetes Engine verwenden, gibt es schon eine <code>.dockercfg</code> auf jedem Knoten die Zugriffsdaten für ihre Google Container Registry beinhaltet. Dann kann die folgende Vorgehensweise nicht angewendet werden.</div><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Diese Vorgehensweise ist anwendbar, wenn sie ihre Knoten-Konfiguration ändern können; Sie wird nicht zuverlässig auf GCE oder einem anderen Cloud - Provider funktionieren, der automatisch Knoten ersetzt.</div><p>Standardmäßig wird das Kubelet versuchen, jedes Image von der spezifizierten Registry herunterzuladen.
Falls jedoch die <code>imagePullPolicy</code> Eigenschaft der Containers auf <code>IfNotPresent</code> oder <code>Never</code> gesetzt wurde, wird ein lokales Image genutzt (präferiert oder exklusiv, jenachdem).</p><p>Wenn Sie sich auf im Voraus heruntergeladene Images als Ersatz für eine Registry - Authentifizierung verlassen möchten, müssen sie sicherstellen, dass alle Knoten die gleichen, im Voraus heruntergeladenen Images aufweisen.</p><p>Diese Methode kann dazu genutzt werden, bestimmte Images aus Geschwindigkeitsgründen im Voraus zu laden, oder als Alternative zur Authentifizierung an einer eigenen Registry zu nutzen.</p><p>Alle Pods haben Leserechte auf alle im Voraus geladenen Images.</p><h3 id=spezifizieren-eines-imagepullsecrets-für-einen-pod>Spezifizieren eines ImagePullSecrets für einen Pod</h3><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Diese Vorgehensweise ist aktuell die empfohlene Vorgehensweise für Google Kubernetes Engine, GCE, und jeden Cloud - Provider bei dem die Knotenerstelltung automatisiert ist.</div><p>Kubernetes unterstützt die Spezifikation von Registrierungsschlüsseln für einen Pod.</p><h4 id=erstellung-eines-secrets-mit-einer-docker-konfiguration>Erstellung eines Secrets mit einer Docker Konfiguration</h4><p>Führen sie folgenden Befehl mit Ersetzung der groß geschriebenen Werte aus:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</span></span></code></pre></div><p>Wenn Sie bereits eine Datei mit Docker-Zugriffsdaten haben, können Sie die Zugriffsdaten als ein Kubernetes Secret importieren:
<a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>Create a Secret based on existing Docker credentials</a> beschreibt die Erstellung.
Dies ist insbesondere dann sinnvoll, wenn sie mehrere eigene Container Registries nutzen, da <code>kubectl create secret docker-registry</code> ein Secret erstellt, das nur mit einer einzelnen eigenen Registry funktioniert.</p><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Pods können nur eigene Image Pull Secret in ihrem eigenen Namespace referenzieren, somit muss dieser Prozess jedes mal einzeln für jeden Namespace angewendet werden.</div><h4 id=referenzierung-eines-imagepullsecrets-bei-einem-pod>Referenzierung eines imagePullSecrets bei einem Pod</h4><p>Nun können Sie Pods erstellen, die dieses Secret referenzieren, indem Sie einen Aschnitt <code>imagePullSecrets</code> zu ihrer Pod - Definition hinzufügen.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Dies muss für jeden Pod getan werden, der eine eigene Registry nutzt.</p><p>Die Erstellung dieser Sektion kann jedoch automatisiert werden, indem man imagePullSecrets einer <a href=/docs/user-guide/service-accounts>serviceAccount</a> Ressource hinzufügt.
<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Add ImagePullSecrets to a Service Account</a> bietet detaillierte Anweisungen hierzu.</p><p>Sie können dies in Verbindung mit einer auf jedem Knoten genutzten <code>.docker/config.json</code> benutzen, die Zugriffsdaten werden dann zusammengeführt. Dieser Vorgehensweise wird in der Google Kubernetes Engine funktionieren.</p><h3 id=anwendungsfälle>Anwendungsfälle</h3><p>Es gibt eine Anzahl an Lösungen um eigene Registries zu konfigurieren, hier sind einige Anwendungsfälle und empfohlene Lösungen.</p><ol><li>Cluster die nur nicht-proprietäre Images (z.B. open-source) ausführen. Images müssen nicht versteckt werden.<ul><li>Nutzung von öffentlichen Images auf Docker Hub.<ul><li>Keine Konfiguration notwendig.</li><li>Auf GCE/Google Kubernetes Engine, wird automatisch ein lokaler Spiegel für eine verbesserte Geschwindigkeit und Verfügbarkeit genutzt.</li></ul></li></ul></li><li>Cluster die einige proprietäre Images ausführen die für Außenstehende nicht sichtbar sein dürfen, aber für alle Cluster - Benutzer sichtbar sein sollen.<ul><li>Nutzung einer gehosteten privaten Registry <a href=https://docs.docker.com/registry/>Docker registry</a>.<ul><li>Kann auf <a href=https://hub.docker.com/signup>Docker Hub</a>, oder woanders gehostet werden.</li><li>Manuelle Konfiguration der .docker/config.json auf jedem Knoten, wie oben beschrieben.</li></ul></li><li>Der Betrieb einer internen privaten Registry hinter ihrer Firewall mit offenen Leseberechtigungen.<ul><li>Keine Kubernetes - Konfiguration notwendig</li></ul></li><li>Wenn GCE/Google Kubernetes Engine genutzt wird, nutzen sie die Google Container Registry des Projektes.<ul><li>Funktioniert besser mit Cluster - Autoskalierung als mit manueller Knotenkonfiguration.</li></ul></li><li>Auf einem Cluster bei dem die Knotenkonfiguration ungünstig ist können <code>imagePullSecrets</code> genutzt werden.</li></ul></li><li>Cluster mit proprieritären Images, mit einigen Images die eine erweiterte Zugriffskontrolle erfordern.<ul><li>Stellen sie sicher das <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages admission controller</a> aktiv ist, anderenfalls können alle Pods potenziell Zugriff auf alle Images haben.</li><li>Verschieben sie sensitive Daten in eine "Secret" Ressource statt sie im Image abzulegen.</li></ul></li><li>Ein mandantenfähiger Cluster in dem jeder Mandant eine eigene private Registry benötigt.<ul><li>Stellen sie dicher das <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages admission controller</a> aktiv ist, anderenfalls können alle Pods potenziell Zugriff auf alle Images haben.</li><li>Nutzen sie eine private Registry die eine Authorisierung erfordert.</li><li>Generieren die Registry - Zugriffsdaten für jeden Mandanten, abgelegt in einem Secret das in jedem Mandanten - Namespace vorhanden ist.</li><li>Der Mandant fügt dieses Sercret zu den imagePullSecrets in jedem seiner Namespace hinzu.</li></ul></li></ol><p>Falls die Zugriff auf mehrere Registries benötigen, können sie ein Secret für jede Registry erstellen, Kubelet wird jedwede <code>imagePullSecrets</code> in einer einzelnen <code>.docker/config.json</code> zusammenfassen.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d52aadda80edd9f8c514cfe2321363c2>4 - Workloads</h1></div><div class=td-content><h1 id=pg-4d68b0ccf9c683e6368ffdcc40c838d4>4.1 - Pods</h1><p><em>Pods</em> sind die kleinsten einsetzbaren Einheiten, die in Kubernetes
erstellt und verwaltet werden können.</p><p>Ein <em>Pod</em> (übersetzt Gruppe/Schote, wie z. B. eine Gruppe von Walen oder eine
Erbsenschote) ist eine Gruppe von einem oder mehreren
<a class=glossary-tooltip title='A lightweight and portable executable image that contains software and all of its dependencies.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/ target=_blank aria-label=Containern>Containern</a> mit gemeinsam
genutzten Speicher- und Netzwerkressourcen und einer Spezifikation für die
Ausführung der Container. Die Ressourcen eines Pods befinden sich immer auf dem
gleichen (virtuellen) Server, werden gemeinsam geplant und in einem
gemeinsamen Kontext ausgeführt. Ein Pod modelliert einen anwendungsspezifischen
"logischen Server": Er enthält eine oder mehrere containerisierte Anwendungen,
die relativ stark voneinander abhängen.
In Nicht-Cloud-Kontexten sind Anwendungen, die auf
demselben physischen oder virtuellen Server ausgeführt werden, vergleichbar zu
Cloud-Anwendungen, die auf demselben logischen Server ausgeführt werden.</p><p>Ein Pod kann neben Anwendungs-Containern auch sogenannte
<a href=/docs/concepts/workloads/pods/init-containers/>Initialisierungs-Container</a>
enthalten, die beim Starten des Pods ausgeführt werden.
Es können auch
kurzlebige/<a href=/docs/concepts/workloads/pods/ephemeral-containers/>ephemere Container</a>
zum Debuggen gestartet werden, wenn dies der Cluster anbietet.</p><h2 id=was-ist-ein-pod>Was ist ein Pod?</h2><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Obwohl Kubernetes abgesehen von <a href=https://www.docker.com/>Docker</a> auch andere
<a class=glossary-tooltip title='The container runtime is the software that is responsible for running containers.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label=Container-Laufzeitumgebungen>Container-Laufzeitumgebungen</a> unterstützt, ist Docker am bekanntesten und
es ist hilfreich, Pods mit der Terminologie von Docker zu beschreiben.</div><p>Der gemeinsame Kontext eines Pods besteht aus einer Reihe von Linux-Namespaces,
Cgroups und möglicherweise anderen Aspekten der Isolation, also die gleichen
Dinge, die einen Dockercontainer isolieren. Innerhalb des Kontexts eines Pods
können die einzelnen Anwendungen weitere Unterisolierungen haben.</p><p>Im Sinne von Docker-Konzepten ähnelt ein Pod einer Gruppe von Docker-Containern,
die gemeinsame Namespaces und Dateisystem-Volumes nutzen.</p><h2 id=pods-verwenden>Pods verwenden</h2><p>Normalerweise müssen keine Pods erzeugt werden, auch keine Singleton-Pods.
Stattdessen werden sie mit Workload-Ressourcen wie <a class=glossary-tooltip title='Manages a replicated application on your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a> oder <a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> erzeugt. Für Pods, die von einem Systemzustand
abhängen, ist die Nutzung von <a class=glossary-tooltip title='Manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>-Ressourcen zu erwägen.</p><p>Pods in einem Kubernetes-Cluster werden hauptsächlich auf zwei Arten verwendet:</p><ul><li><strong>Pods, die einen einzelnen Container ausführen</strong>. Das
"Ein-Container-per-Pod"-Modell ist der häufigste Kubernetes-Anwendungsfall. In
diesem Fall kannst du dir einen einen Pod als einen Behälter vorstellen, der einen
einzelnen Container enthält; Kubernetes verwaltet die Pods anstatt die
Container direkt zu verwalten.</li><li><strong>Pods, in denen mehrere Container ausgeführt werden, die zusammenarbeiten
müssen</strong>. Wenn eine Softwareanwendung aus co-lokaliserten Containern besteht,
die sich gemeinsame Ressourcen teilen und stark voneinander abhängen, kann ein
Pod die Container verkapseln.
Diese Container bilden eine einzelne zusammenhängende
Serviceeinheit, z. B. ein Container, der Daten in einem gemeinsam genutzten
Volume öffentlich verfügbar macht, während ein separater <em>Sidecar</em>-Container
die Daten aktualisiert. Der Pod fasst die Container, die Speicherressourcen
und eine kurzlebiges Netzwerk-Identität als eine Einheit zusammen.</li></ul><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Das Gruppieren mehrerer gemeinsam lokalisierter und gemeinsam verwalteter
Container in einem einzigen Pod ist ein relativ fortgeschrittener
Anwendungsfall. Du solltest diese Architektur nur in bestimmten Fällen
verwenden, wenn deine Container stark voneinander abhängen.</div><p>Jeder Pod sollte eine einzelne Instanz einer gegebenen Anwendung ausführen. Wenn
du deine Anwendung horizontal skalieren willst (um mehr Instanzen auszuführen
und dadurch mehr Gesamtressourcen bereitstellen), solltest du mehrere Pods
verwenden, einen für jede Instanz.
In Kubernetes wird dies typischerweise als Replikation bezeichnet.
Replizierte Pods werden normalerweise als eine Gruppe durch eine
Workload-Ressource und deren
<a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=Controller>Controller</a> erstellt
und verwaltet.</p><p>Der Abschnitt <a href=#pods-und-controller>Pods und Controller</a> beschreibt, wie
Kubernetes Workload-Ressourcen und deren Controller verwendet, um Anwendungen
zu skalieren und zu heilen.</p><h3 id=wie-pods-mehrere-container-verwalten>Wie Pods mehrere Container verwalten</h3><p>Pods unterstützen mehrere kooperierende Prozesse (als Container), die eine
zusammenhängende Serviceeinheit bilden. Kubernetes plant und stellt automatisch
sicher, dass sich die Container in einem Pod auf demselben physischen oder
virtuellen Server im Cluster befinden. Die Container können Ressourcen und
Abhängigkeiten gemeinsam nutzen, miteinander kommunizieren und
ferner koordinieren wann und wie sie beendet werden.</p><p>Zum Beispiel könntest du einen Container haben, der als Webserver für Dateien in
einem gemeinsamen Volume arbeitet. Und ein separater "Sidecar" -Container
aktualisiert die Daten von einer externen Datenquelle, siehe folgenden
Abbildung:</p><figure><img src=/images/docs/pod.svg alt=Pod-Beispieldiagramm width=50%></figure><p>Einige Pods haben sowohl <a class=glossary-tooltip title='One or more initialization containers that must run to completion before any app containers run.' data-toggle=tooltip data-placement=top href='/de/docs/reference/glossary/?all=true#term-init-container' target=_blank aria-label=Initialisierungs-Container>Initialisierungs-Container</a> als auch <a class=glossary-tooltip title='A container used to run part of a workload. Compare with init container.' data-toggle=tooltip data-placement=top href='/de/docs/reference/glossary/?all=true#term-app-container' target=_blank aria-label=Anwendungs-Container>Anwendungs-Container</a>.
Initialisierungs-Container werden gestartet und beendet bevor die
Anwendungs-Container gestartet werden.</p><p>Pods stellen standardmäßig zwei Arten von gemeinsam Ressourcen für die
enthaltenen Container bereit:
<a href=#pod-netzwerk>Netzwerk</a> und <a href=#datenspeicherung-in-pods>Speicher</a>.</p><h2 id=mit-pods-arbeiten>Mit Pods arbeiten</h2><p>Du wirst selten einzelne Pods direkt in Kubernetes erstellen, selbst
Singleton-Pods. Das liegt daran, dass Pods als relativ kurzlebige
Einweg-Einheiten konzipiert sind. Wenn ein Pod erstellt wird (entweder direkt
von Ihnen oder indirekt von einem
<a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=Controller>Controller</a>), wird die
Ausführung auf einem <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a> in Ihrem Cluster
geplant. Der Pod bleibt auf diesem (virtuellen) Server, bis entweder der Pod die
Ausführung beendet hat, das Pod-Objekt gelöscht wird, der Pod aufgrund
mangelnder Ressourcen <em>evakuiert</em> wird oder der Node ausfällt.</p><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Das Neustarten eines Containers in einem Pod sollte nicht mit dem Neustarten
eines Pods verwechselt werden. Ein Pod ist kein Prozess, sondern eine Umgebung
zur Ausführung von Containern. Ein Pod bleibt bestehen bis er gelöscht wird.</div><p>Stelle beim Erstellen des Manifests für ein Pod-Objekt sicher, dass der
angegebene Name ein gültiger
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS-Subdomain-Name</a>
ist.</p><h3 id=pods-und-controller>Pods und Controller</h3><p>Mit Workload-Ressourcen kannst du mehrere Pods erstellen und verwalten. Ein
Controller für die Ressource kümmert sich um Replikation, Roll-Out sowie
automatische Wiederherstellung im Fall von versagenden Pods. Wenn beispielsweise ein Node
ausfällt, bemerkt ein Controller, dass die Pods auf dem Node nicht mehr laufen
und plant die Ausführung eines Ersatzpods auf einem funktionierenden Node.
Hier sind einige Beispiele für Workload-Ressourcen, die einen oder mehrere Pods
verwalten:</p><ul><li><a class=glossary-tooltip title='Manages a replicated application on your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a></li><li><a class=glossary-tooltip title='Manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a></li><li><a class=glossary-tooltip title='Ensures a copy of a Pod is running across a set of nodes in a cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a></li></ul><h3 id=pod-vorlagen>Pod-Vorlagen</h3><p>Controller für
<a class=glossary-tooltip title='A workload is an application running on Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/ target=_blank aria-label=Workload>Workload</a>-Ressourcen
erstellen Pods von einer <em>Pod-Vorlage</em> und verwalten diese Pods für dich.</p><p>Pod-Vorlagen sind Spezifikationen zum Erstellen von Pods und sind in
Workload-Ressourcen enthalten wie z. B.
<a href=/docs/concepts/workloads/controllers/deployment/>Deployments</a>,
<a href=/docs/concepts/workloads/controllers/job/>Jobs</a>, and
<a href=/docs/concepts/workloads/controllers/daemonset/>DaemonSets</a>.</p><p>Jeder Controller für eine Workload-Ressource verwendet die Pod-Vorlage innerhalb
des Workload-Objektes, um Pods zu erzeugen. Die Pod-Vorlage ist Teil des
gewünschten Zustands der Workload-Ressource, mit der du deine Anwendung
ausgeführt hast.</p><p>Das folgende Beispiel ist ein Manifest für einen einfachen Job mit einer
<code>Vorlage</code>, die einen Container startet. Der Container in diesem Pod druckt
eine Nachricht und pausiert dann.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Dies is the Pod-Vorlage</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo &#34;Hello, Kubernetes!&#34; &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Die Pod-Vorlage endet hier</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Das Ändern der Pod-Vorlage oder der Wechsel zu einer neuen Pod-Vorlage hat keine
direkten Auswirkungen auf bereits existierende Pods. Wenn du die Pod-Vorlage für
eine Workload-Ressource änderst, dann muss diese Ressource die Ersatz-Pods
erstellen, welche die aktualisierte Vorlage verwenden.</p><p>Beispielsweise stellt der StatefulSet-Controller sicher, dass für jedes
StatefulSet-Objekt die ausgeführten Pods mit der aktueller Pod-Vorlage
übereinstimmen. Wenn du das StatefulSet bearbeitest und die Vorlage änderst,
beginnt das StatefulSet mit der Erstellung neuer Pods basierend auf der
aktualisierten Vorlage. Schließlich werden alle alten Pods durch neue Pods
ersetzt, und das Update ist abgeschlossen.</p><p>Jede Workload-Ressource implementiert eigenen Regeln für die Umsetzung von
Änderungen der Pod-Vorlage. Wenn du mehr über StatefulSet erfahren möchtest,
dann lese die Seite
<a href=/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets>Update-Strategien</a>
im Tutorial StatefulSet Basics.</p><p>Auf Nodes beobachtet oder verwaltet das
<a class=glossary-tooltip title='Ein Agent, der auf jedem Node im Cluster ausgeführt wird. Er stellt sicher, dass Container in einem Pod ausgeführt werden.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>
nicht direkt die Details zu Pod-Vorlagen und Updates. Diese Details sind
abstrahiert. Die Abstraktion und Trennung von Aufgaben vereinfacht die
Systemsemantik und ermöglicht so das Verhalten des Clusters zu ändern ohne
vorhandenen Code zu ändern.</p><h2 id=pod-update-und-austausch>Pod Update und Austausch</h2><p>Wie im vorherigen Abschnitt erwähnt, erstellt der Controller neue Pods basierend
auf der aktualisierten Vorlage, wenn die Pod-Vorlage für eine Workload-Ressource
geändert wird anstatt die vorhandenen Pods zu aktualisieren oder zu patchen.</p><p>Kubernetes hindert dich nicht daran, Pods direkt zu verwalten. Es ist möglich,
einige Felder eines laufenden Pods zu aktualisieren. Allerdings haben
Pod-Aktualisierungsvorgänge wie zum Beispiel
<a href=/docs/reference/generated/kubernetes-api/v1.25/#patch-pod-v1-core><code>patch</code></a>,
und
<a href=/docs/reference/generated/kubernetes-api/v1.25/#replace-pod-v1-core><code>replace</code></a>
einige Einschränkungen:</p><ul><li><p>Die meisten Metadaten zu einem Pod können nicht verändert werden. Zum Beispiel kannst
du nicht die Felder <code>namespace</code>, <code>name</code>, <code>uid</code>, oder <code>creationTimestamp</code>
ändern. Das <code>generation</code>-Feld muss eindeutig sein. Es werden nur Aktualisierungen
akzeptiert, die den Wert des Feldes inkrementieren.</p></li><li><p>Wenn das Feld <code>metadata.deletionTimestamp</code> gesetzt ist, kann kein neuer
Eintrag zur Liste <code>metadata.finalizers</code> hinzugefügt werden.</p></li><li><p>Pod-Updates dürfen keine Felder ändern, die Ausnahmen sind
<code>spec.containers[*].image</code>,
<code>spec.initContainers[*].image</code>, <code>spec.activeDeadlineSeconds</code> oder
<code>spec.tolerations</code>. Für <code>spec.tolerations</code> kannnst du nur neue Einträge
hinzufügen.</p></li><li><p>Für <code>spec.activeDeadlineSeconds</code> sind nur zwei Änderungen erlaubt:</p><ol><li>ungesetztes Feld in eine positive Zahl</li><li>positive Zahl in eine kleinere positive Zahl, die nicht negativ ist</li></ol></li></ul><h2 id=gemeinsame-nutzung-von-ressourcen-und-kommunikation>Gemeinsame Nutzung von Ressourcen und Kommunikation</h2><p>Pods ermöglichen den Datenaustausch und die Kommunikation zwischen den
Containern, die im Pod enthalten sind.</p><h3 id=datenspeicherung-in-pods>Datenspeicherung in Pods</h3><p>Ein Pod kann eine Reihe von gemeinsam genutzten Speicher-
<a class=glossary-tooltip title='A directory containing data, accessible to the containers in a pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volumes>Volumes</a> spezifizieren. Alle
Container im Pod können auf die gemeinsamen Volumes zugreifen und dadurch Daten
austauschen. Volumes ermöglichen auch, dass Daten ohne Verlust gespeichert
werden, falls einer der Container neu gestartet werden muss.
Im Kapitel <a href=/docs/concepts/storage/>Datenspeicherung</a> findest du weitere
Informationen, wie Kubernetes gemeinsam genutzten Speicher implementiert und
Pods zur Verfügung stellt.</p><h3 id=pod-netzwerk>Pod-Netzwerk</h3><p>Jedem Pod wird für jede Adressenfamilie eine eindeutige IP-Adresse zugewiesen.
Jeder Container in einem Pod nutzt den gemeinsamen Netzwerk-Namespace,
einschließlich der IP-Adresse und der Ports. In einem Pod (und <strong>nur</strong> dann)
können die Container, die zum Pod gehören, über <code>localhost</code> miteinander
kommunizieren. Wenn Container in einem Pod mit Entitäten <em>außerhalb des Pods</em>
kommunizieren, müssen sie koordinieren, wie die gemeinsam genutzten
Netzwerkressourcen (z. B. Ports) verwenden werden. Innerhalb eines Pods teilen
sich Container eine IP-Adresse und eine Reihe von Ports und können sich
gegenseitig über <code>localhost</code> finden. Die Container in einem Pod können auch die
üblichen Kommunikationsverfahren zwischen Prozessen nutzen, wie z. B.
SystemV-Semaphoren oder "POSIX Shared Memory". Container in verschiedenen Pods
haben unterschiedliche IP-Adressen und können nicht per IPC ohne
<a href=/docs/concepts/policy/pod-security-policy/>spezielle Konfiguration</a>
kommunizieren. Container, die mit einem Container in einem anderen Pod
interagieren möchten, müssen IP Netzwerke verwenden.</p><p>Für die Container innerhalb eines Pods stimmt der "hostname" mit dem
konfigurierten <code>Namen</code> des Pods überein. Mehr dazu im Kapitel
<a href=/docs/concepts/cluster-administration/networking/>Netzwerke</a>.</p><h2 id=privilegierter-modus-für-container>Privilegierter Modus für Container</h2><p>Jeder Container in einem Pod kann den privilegierten Modus aktivieren, indem
das Flag <code>privileged</code> im
<a href=/docs/tasks/configure-pod-container/security-context/>Sicherheitskontext</a>
der Container-Spezifikation verwendet wird.
Dies ist nützlich für Container, die Verwaltungsfunktionen des Betriebssystems
verwenden möchten, z. B. das Manipulieren des Netzwerk-Stacks oder den Zugriff
auf Hardware. Prozesse innerhalb eines privilegierten Containers erhalten fast
die gleichen Rechte wie sie Prozessen außerhalb eines Containers zur Verfügung
stehen.</p><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Ihre
<a class=glossary-tooltip title='The container runtime is the software that is responsible for running containers.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label=Container-Umgebung>Container-Umgebung</a>
muss das Konzept eines privilegierten Containers unterstützen, damit diese
Einstellung relevant ist.</div><h2 id=statische-pods>Statische Pods</h2><p><em>Statische Pods</em> werden direkt vom Kubelet-Daemon auf einem bestimmten Node
verwaltet ohne dass sie vom
<a class=glossary-tooltip title='Komponente auf dem Master, der die Kubernetes-API verfügbar macht. Es ist das Frontend für die Kubernetes-Steuerebene.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API Server'>API Server</a> überwacht
werden.</p><p>Die meisten Pods werden von der Kontrollebene verwaltet (z. B.
<a class=glossary-tooltip title='Manages a replicated application on your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>). Aber für
statische Pods überwacht das Kubelet jeden statischen Pod direkt (und startet
ihn neu, wenn er ausfällt).</p><p>Statische Pods sind immer an ein <a class=glossary-tooltip title='Ein Agent, der auf jedem Node im Cluster ausgeführt wird. Er stellt sicher, dass Container in einem Pod ausgeführt werden.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a> auf
einem bestimmten Node gebunden. Der Hauptanwendungsfall für statische Pods
besteht darin, eine selbst gehostete Steuerebene auszuführen. Mit anderen
Worten: Das Kubelet dient zur Überwachung der einzelnen
<a href=/docs/concepts/overview/components/#control-plane-components>Komponenten der Kontrollebene</a>.</p><p>Das Kubelet versucht automatisch auf dem Kubernetes API-Server für jeden
statischen Pod einen spiegelbildlichen Pod
(im Englischen: <a class=glossary-tooltip title='An object in the API server that tracks a static pod on a kubelet.' data-toggle=tooltip data-placement=top href='/de/docs/reference/glossary/?all=true#term-mirror-pod' target=_blank aria-label='mirror pod'>mirror pod</a>)
zu erstellen.
Das bedeutet, dass die auf einem Node ausgeführten Pods auf dem API-Server
sichtbar sind jedoch von dort nicht gesteuert werden können.</p><h2 id=nächste-schritte>Nächste Schritte</h2><ul><li>Verstehe den
<a href=/docs/concepts/workloads/pods/pod-lifecycle/>Lebenszyklus eines Pods</a>.</li><li>Erfahre mehr über <a href=/docs/concepts/containers/runtime-class/>RuntimeClass</a>
und wie du damit verschiedene Pods mit unterschiedlichen
Container-Laufzeitumgebungen konfigurieren kannst.</li><li>Mehr zum Thema
<a href=/docs/concepts/workloads/pods/pod-topology-spread-constraints/>Restriktionen für die Verteilung von Pods</a>.</li><li>Lese
<a href=/docs/concepts/workloads/pods/disruptions/>Pod-Disruption-Budget</a>
und wie du es verwenden kannst, um die Verfügbarkeit von Anwendungen bei
Störungen zu verwalten. Die
<a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>Pod</a>
-Objektdefinition beschreibt das Objekt im Detail.</li><li><a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System Toolkit: Patterns for Composite Containers</a>
erläutert allgemeine Layouts für Pods mit mehr als einem Container.</li></ul><p>Um den Hintergrund zu verstehen, warum Kubernetes eine gemeinsame Pod-API in
andere Ressourcen, wie z. B.
<a class=glossary-tooltip title='Manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSets>StatefulSets</a>
oder <a class=glossary-tooltip title='Manages a replicated application on your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployments>Deployments</a> einbindet,
kannst du Artikel zu früheren Technologien lesen, unter anderem:</p><ul><li><a href=https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a></li><li><a href=https://research.google.com/pubs/pub43438.html>Borg</a></li><li><a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a></li><li><a href=https://research.google/pubs/pub41684/>Omega</a></li><li><a href=https://engineering.fb.com/data-center-engineering/tupperware/>Tupperware</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0a0a7eca3e302a3c08f8c85e15d337fd>5 - Dienste, Lastverteilung und Netzwerkfunktionen</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-f018f568c6723865753f150c3c59bdda>6 - Speicher</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-275bea454e1cf4c5adeca4058b5af988>7 - Konfiguration</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-ac9161c6d952925b083ad9602b4e8e7f>8 - Richtlinien</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-285a3785fd3d20f437c28d87ca4dadca>9 - Cluster Administration</h1></div><div class=td-content><h1 id=pg-08e94e6a480e0d6b2de72d84a1b97617>9.1 - Proxies in Kubernetes</h1><p>Auf dieser Seite werden die im Kubernetes verwendeten Proxies erläutert.</p><h2 id=proxies>Proxies</h2><p>Es gibt mehrere verschiedene Proxies, die die bei der Verwendung von Kubernetes begegnen können:</p><ol><li><p>Der <a href=/docs/tasks/access-application-cluster/access-cluster/#directly-accessing-the-rest-api>kubectl Proxy</a>:</p><ul><li>läuft auf dem Desktop eines Benutzers oder in einem Pod</li><li>Proxy von einer lokalen Host-Adresse zum Kubernetes API Server</li><li>Client zu Proxy verwendet HTTP</li><li>Proxy zu API Server verwendet HTTPS</li><li>lokalisiert den API Server</li><li>fügt Authentifizierungs-Header hinzu</li></ul></li><li><p>Der <a href=/docs/tasks/access-application-cluster/access-cluster-services/#discovering-builtin-services>API Server Proxy</a>:</p><ul><li>ist eine Bastion, die in den API Server eingebaut ist</li><li>verbindet einen Benutzer außerhalb des Clusters mit Cluster IPs, die sonst möglicherweise nicht erreichbar wären</li><li>läuft im API Server Prozess</li><li>Client zu Proxy verwendet HTTPS (oder http, wenn API Server so konfiguriert ist)</li><li>Proxy zum Ziel kann HTTP oder HTTPS verwenden, der Proxy wählt dies unter Verwendung der verfügbaren Informationen aus</li><li>kann verwendet werden, um einen Knoten, Pod oder Service zu erreichen</li><li>führt einen Lastausgleich durch um einen Service zu erreichen, wenn dieser verwendet wird</li></ul></li><li><p>Der <a href=/docs/concepts/services-networking/service/#ips-and-vips>kube Proxy</a>:</p><ul><li>läuft auf jedem Knoten</li><li>Proxy unterstüzt UDP, TCP und SCTP</li><li>versteht kein HTTP</li><li>stellt Lastausgleich zur Verfügung</li><li>wird nur zum erreichen von Services verwendet</li></ul></li><li><p>Ein Proxy/Load-balancer vor dem API Server:</p><ul><li>Existenz und Implementierung variieren von Cluster zu Cluster (z.B. nginx)</li><li>sitzt zwischen allen Clients und einem oder mehreren API Servern</li><li>fungiert als Load Balancer, wenn es mehrere API Server gibt</li></ul></li><li><p>Cloud Load Balancer für externe Services:</p><ul><li>wird von einigen Cloud Anbietern angeboten (z.B. AWS ELB, Google Cloud Load Balancer)</li><li>werden automatisch erstellt, wenn der Kubernetes Service den Typ <code>LoadBalancer</code> hat</li><li>unterstützt normalerweiße nur UDP/TCP</li><li>Die SCTP-Unterstützung hängt von der Load Balancer Implementierung des Cloud Providers ab</li><li>die Implementierung variiert je nach Cloud Anbieter</li></ul></li></ol><p>Kubernetes Benutzer müssen sich in der Regel um nichts anderes als die ersten beiden Typen kümmern. Der Cluster Administrator stellt in der Regel sicher, dass die letztgenannten Typen korrekt eingerichtet sind.</p><h2 id=anforderung-an-umleitungen>Anforderung an Umleitungen</h2><p>Proxies haben die Möglichkeit der Umleitung (redirect) ersetzt. Umleitungen sind veraltet.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d5cc46b61677b53f61a407d20bdd0830>9.2 - Controller Manager Metriken</h1><p>Controller Manager Metriken liefern wichtige Erkenntnisse über die Leistung und den Zustand von den Controller Managern.</p><h2 id=was-sind-controller-manager-metriken>Was sind Controller Manager Metriken</h2><p>Die Kennzahlen des Controller Managers liefert wichtige Erkenntnisse über die Leistung und den Zustand des Controller Managers.
Diese Metriken beinhalten gängige Go Language Laufzeitmetriken wie go_routine count und controller-spezifische Metriken wie z.B.
etcd Request Latenzen oder Cloud Provider (AWS, GCE, OpenStack) API Latenzen, die verwendet werden können um den Zustand eines Clusters zu messen.</p><p>Ab Kubernetes 1.7 stehen detaillierte Cloud Provider Metriken für den Speicherbetrieb für GCE, AWS, Vsphere und OpenStack zur Verfügung.
Diese Metriken können verwendet werden, um den Zustand persistenter Datenträgeroperationen zu überwachen.</p><p>Für GCE werden diese Metriken beispielsweise wie folgt aufgerufen:</p><pre tabindex=0><code>cloudprovider_gce_api_request_duration_seconds { request = &#34;instance_list&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;disk_insert&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;disk_delete&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;attach_disk&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;detach_disk&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;list_disk&#34;}
</code></pre><h2 id=konfiguration>Konfiguration</h2><p>In einem Cluster sind die Controller Manager Metriken unter <code>http://localhost:10252/metrics</code> auf dem Host verfügbar, auf dem der Controller Manager läuft.</p><p>Die Metriken werden im <a href=https://prometheus.io/docs/instrumenting/exposition_formats/>Prometheus Format</a> ausgegeben.</p><p>In einer Produktionsumgebung können Sie Prometheus oder einen anderen Metrik Scraper konfigurieren, um diese Metriken regelmäßig zu sammeln und in einer Art Zeitreihen Datenbank verfügbar zu machen.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-85d633ae590aa20ec024f1b7af1d74fc>9.3 - Addons Installieren</h1><p>Add-Ons erweitern die Funktionalität von Kubernetes.</p><p>Diese Seite gibt eine Übersicht über einige verfügbare Add-Ons und verweist auf die entsprechenden Installationsanleitungen.</p><p>Die Add-Ons in den einzelnen Kategorien sind alphabetisch sortiert - Die Reihenfolge impliziert keine bevorzugung einzelner Projekte.</p><h2 id=networking-und-network-policy>Networking und Network Policy</h2><ul><li><a href=https://www.github.com/noironetworks/aci-containers>ACI</a> bietet Container-Networking und Network-Security mit Cisco ACI.</li><li><a href=https://docs.projectcalico.org/latest/introduction/>Calico</a> ist ein Networking- und Network-Policy-Provider. Calico unterstützt eine Reihe von Networking-Optionen, damit Du die richtige für deinen Use-Case wählen kannst. Dies beinhaltet Non-Overlaying and Overlaying-Networks mit oder ohne BGP. Calico nutzt die gleiche Engine um Network-Policies für Hosts, Pods und (falls Du Istio & Envoy benutzt) Anwendungen auf Service-Mesh-Ebene durchzusetzen.</li><li><a href=https://projectcalico.docs.tigera.io/getting-started/kubernetes/flannel/flannel>Canal</a> vereint Flannel und Calico um Networking- und Network-Policies bereitzustellen.</li><li><a href=https://github.com/cilium/cilium>Cilium</a> ist ein L3 Network- and Network-Policy-Plugin welches das transparent HTTP/API/L7-Policies durchsetzen kann. Sowohl Routing- als auch Overlay/Encapsulation-Modes werden uterstützt. Außerdem kann Cilium auf andere CNI-Plugins aufsetzen.</li><li><a href=https://github.com/cni-genie/CNI-Genie>CNI-Genie</a> ermöglicht das nahtlose Verbinden von Kubernetes mit einer Reihe an CNI-Plugins wie z.B. Calico, Canal, Flannel, Romana, oder Weave.</li><li><a href=https://contivpp.io/>Contiv</a> bietet konfigurierbares Networking (Native L3 auf BGP, Overlay mit vxlan, Klassisches L2, Cisco-SDN/ACI) für verschiedene Anwendungszwecke und auch umfangreiches Policy-Framework. Das Contiv-Projekt ist vollständig <a href=http://github.com/contiv>Open Source</a>. Der <a href=http://github.com/contiv/install>installer</a> bietet sowohl kubeadm als auch nicht-kubeadm basierte Installationen.</li><li><a href=http://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a>, basierend auf <a href=https://tungsten.io>Tungsten Fabric</a>, ist eine Open Source, multi-Cloud Netzwerkvirtualisierungs- und Policy-Management Plattform. Contrail und Tungsten Fabric sind mit Orechstratoren wie z.B. Kubernetes, OpenShift, OpenStack und Mesos integriert und bieten Isolationsmodi für Virtuelle Maschinen, Container (bzw. Pods) und Bare Metal workloads.</li><li><a href=https://github.com/flannel-io/flannel#deploying-flannel-manually>Flannel</a> ist ein Overlay-Network-Provider der mit Kubernetes genutzt werden kann.</li><li><a href=https://github.com/ZTE/Knitter/>Knitter</a> ist eine Network-Lösung die Mehrfach-Network in Kubernetes ermöglicht.</li><li><a href=https://github.com/k8snetworkplumbingwg/multus-cni>Multus</a> ist ein Multi-Plugin für Mehrfachnetzwerk-Unterstützung um alle CNI-Plugins (z.B. Calico, Cilium, Contiv, Flannel), zusätzlich zu SRIOV-, DPDK-, OVS-DPDK- und VPP-Basierten Workloads in Kubernetes zu unterstützen.</li><li><a href=https://docs.vmware.com/en/VMware-NSX-T-Data-Center/index.html>NSX-T</a> Container Plug-in (NCP) bietet eine Integration zwischen VMware NSX-T und einem Orchestator wie z.B. Kubernetes. Außerdem bietet es eine Integration zwischen NSX-T und Containerbasierten CaaS/PaaS-Plattformen wie z.B. Pivotal Container Service (PKS) und OpenShift.</li><li><a href=https://github.com/nuagenetworks/nuage-kubernetes/blob/v5.1.1-1/docs/kubernetes-1-installation.rst>Nuage</a> ist eine SDN-Plattform die Policy-Basiertes Networking zwischen Kubernetes Pods und nicht-Kubernetes Umgebungen inklusive Sichtbarkeit und Security-Monitoring bereitstellt.</li><li><a href=https://github.com/romana/romana>Romana</a> ist eine Layer 3 Network-Lösung für Pod-Netzwerke welche auch die <a href=/docs/concepts/services-networking/network-policies/>NetworkPolicy API</a> unterstützt. Details zur Installation als kubeadm Add-On sind <a href=https://github.com/romana/romana/tree/master/containerize>hier</a> verfügbar.</li><li><a href=https://www.weave.works/docs/net/latest/kube-addon/>Weave Net</a> bietet Networking and Network-Policies und arbeitet auf beiden Seiten der Network-Partition ohne auf eine externe Datenbank angwiesen zu sein.</li></ul><h2 id=service-discovery>Service-Discovery</h2><ul><li><a href=https://coredns.io>CoreDNS</a> ist ein flexibler, erweiterbarer DNS-Server der in einem Cluster <a href=https://github.com/coredns/deployment/tree/master/kubernetes>installiert</a> werden kann und das Cluster-interne DNS für Pods bereitzustellen.</li></ul><h2 id=visualisierung-amp-überwachung>Visualisierung & Überwachung</h2><ul><li><a href=https://github.com/kubernetes/dashboard#kubernetes-dashboard>Dashboard</a> ist ein Dashboard Web Interface für Kubernetes.</li><li><a href=https://www.weave.works/documentation/scope-latest-installing/#k8s>Weave Scope</a> ist ein Tool um Container, Pods, Services usw. Grafisch zu visualieren. Kann in Verbindung mit einem <a href=https://cloud.weave.works/>Weave Cloud Account</a> genutzt oder selbst gehosted werden.</li></ul><h2 id=infrastruktur>Infrastruktur</h2><ul><li><a href=https://kubevirt.io/user-guide/docs/latest/administration/intro.html#cluster-side-add-on-deployment>KubeVirt</a> ist ein Add-On um Virtuelle Maschinen in Kubernetes auszuführen. Wird typischer auf Bare-Metal Clustern eingesetzt.</li></ul><h2 id=legacy-add-ons>Legacy Add-Ons</h2><p>Es gibt einige weitere Add-Ons die in dem abgekündigten <a href=https://git.k8s.io/kubernetes/cluster/addons>cluster/addons</a>-Verzeichnis dokumentiert sind.</p><p>Add-Ons die ordentlich gewartet werden dürfen gerne hier aufgezählt werden. Wir freuen uns auf PRs!</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7e0d97616b15e2c383c6a0a96ec442cb>10 - Kubernetes erweitern</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-4c31edff4063c7b31c556b3eb1405c65>11 - Konzept Dokumentations-Vorlage</h1><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Stellen Sie auch sicher <a href=/docs/home/contribute/write-new-topic/#creating-an-entry-in-the-table-of-contents>einen Eintrag im Inhaltsverzeichnis</a> für Ihr neues Dokument zu erstellen.</div><p>Diese Seite erklärt ...</p><h2 id=verstehen>Verstehen ...</h2><p>Kubernetes bietet ...</p><h2 id=verwenden>Verwenden ...</h2><p>Benutzen Sie ...</p><h2 id=nächste-schritte>Nächste Schritte</h2><p><strong>[Optionaler Bereich]</strong></p><ul><li>Lernen Sie mehr über <a href=/docs/home/contribute/write-new-topic/>ein neues Thema schreiben</a>.</li><li>Besuchen Sie <a href=/docs/home/contribute/page-templates/#concept_template>Seitenvorlagen verwenden - Konzeptvorlage</a> wie Sie diese Vorlage verwenden.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/de/docs/home/>Home</a>
<a class=text-white href=/de/blog/>Blog</a>
<a class=text-white href=/de/training/>Schulungen</a>
<a class=text-white href=/de/partners/>Partner</a>
<a class=text-white href=/de/community/>Community</a>
<a class=text-white href=/de/case-studies/>Fallstudien</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>