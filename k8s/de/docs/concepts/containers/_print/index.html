<!doctype html><html lang=de class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/containers/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/containers/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/containers/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/containers/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/containers/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/containers/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/containers/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/containers/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/containers/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/containers/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/de/docs/concepts/containers/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Container | Kubernetes</title><meta property="og:title" content="Container"><meta property="og:description" content="Produktionsreife Container-Orchestrierung"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/de/docs/concepts/containers/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Container"><meta itemprop=description content="Produktionsreife Container-Orchestrierung"><meta name=twitter:card content="summary"><meta name=twitter:title content="Container"><meta name=twitter:description content="Produktionsreife Container-Orchestrierung"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/de/docs/concepts/containers/"><meta property="og:title" content="Container"><meta name=twitter:title content="Container"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/de/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/de/docs/>Dokumentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/training/>Schulungen</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/partners/>Partner</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/case-studies/>Fallstudien</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/de/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/de/docs/concepts/containers/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/de/docs/concepts/containers/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/de/docs/concepts/containers/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/de/docs/concepts/containers/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/de/docs/concepts/containers/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Deutsch (German)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/containers/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/containers/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/containers/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/containers/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/containers/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/containers/>Italiano (Italian)</a>
<a class=dropdown-item href=/es/docs/concepts/containers/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/containers/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/containers/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/containers/>Tiếng Việt (Vietnamese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Das ist eine für den Ausdruck optimierte Ansicht des gesamten Kapitels inkl. Unterseiten.
<a href=# onclick="return print(),!1">Druckvorgang starten</a>.</p><p><a href=/de/docs/concepts/containers/>Zur Standardansicht zurückkehren</a>.</p></div><h1 class=title>Container</h1><ul><li>1: <a href=#pg-16042b4652ad19e565c7263824029a43>Images</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-16042b4652ad19e565c7263824029a43>1 - Images</h1><p>Sie erstellen Ihr Docker Image und laden es in eine Registry hoch, bevor es in einem Kubernetes Pod referenziert werden kann.</p><p>Die <code>image</code> Eigenschaft eines Containers unterstüzt die gleiche Syntax wie die des <code>docker</code> Kommandos, inklusive privater Registries und Tags.</p><h2 id=aktualisieren-von-images>Aktualisieren von Images</h2><p>Die Standardregel für das Herunterladen von Images ist <code>IfNotPresent</code>, dies führt dazu, dass das Image wird nur heruntergeladen wenn es noch nicht lokal verfügbar ist.
Wenn sie stattdessen möchten, dass ein Image immer forciert heruntergeladen wird, können sie folgendes tun:</p><ul><li>Die <code>imagePullPolicy</code> des Containers auf <code>Always</code> setzen.</li><li>Die <code>imagePullPolicy</code> auslassen und <code>:latest</code> als Image Tag nutzen.</li><li>Die <code>imagePullPolicy</code> und den Tag des Images auslassen.</li><li>Den <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> Admission Controller aktivieren.</li></ul><p>Beachten Sie, dass Sie die Nutzung des <code>:latest</code> Tags vermeiden sollten. Für weitere Informationen siehe: <a href=/docs/concepts/configuration/overview/#container-images>Best Practices for Configuration</a>.</p><h2 id=multi-architektur-images-mit-manifesten-bauen>Multi-Architektur Images mit Manifesten bauen</h2><p>Das Docker Kommandozeilenwerkzeug unterstützt jetzt das Kommando <code>docker manifest</code> mit den Subkommandos <code>create</code>, <code>annotate</code> and <code>push</code>.
Diese Kommandos können dazu genutzt werden Manifeste zu bauen und diese hochzuladen.</p><p>Weitere Informationen finden sie in der Docker Dokumentation:
<a href=https://docs.docker.com/edge/engine/reference/commandline/manifest/>https://docs.docker.com/edge/engine/reference/commandline/manifest/</a></p><p>Hier einige Beispiele wie wir dies in unserem Build - Prozess nutzen:
<a href="https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&i=nope&files=&repos=">https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&i=nope&files=&repos=</a></p><p>Diese Kommandos basieren rein auf dem Docker Kommandozeileninterface und werden auch damit ausgeführt. Sie sollten entweder die Datei <code>$HOME/.docker/config.json</code> bearbeiten und den <code>experimental</code> Schlüssel auf <code>enabled</code> setzen, oder einfach die Umgebungsvariable <code>DOCKER_CLI_EXPERIMENTAL</code> auf <code>enabled</code> setzen, wenn Sie das Docker Kommandozeileninterface aufrufen.</p><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Nutzen die bitte Docker <em>18.06 oder neuer</em>, ältere Versionen haben entweder Bugs oder unterstützen die experimentelle Kommandozeilenoption nicht. Beispiel: <a href=https://github.com/docker/cli/issues/1135>https://github.com/docker/cli/issues/1135</a> verursacht Probleme unter containerd.</div><p>Wenn mit alten Manifesten Probleme auftreten, können sie die alten Manifeste in <code>$HOME/.docker/manifests</code> entfernen, um von vorne zu beginnen.</p><p>Für Kubernetes selbst nutzen wir typischerweise Images mit dem Suffix <code>-$(ARCH)</code>. Um die Abwärtskompatibilität zu erhalten, bitten wir Sie, die älteren Images mit diesen Suffixen zu generieren. Die Idee dahinter ist z.B., das <code>pause</code> image zu generieren, welches das Manifest für alle Architekturen hat, <code>pause-amd64</code> wäre dann abwärtskompatibel zu älteren Konfigurationen, oder YAML - Dateien, die ein Image mit Suffixen hart kodiert enthalten.</p><h2 id=nutzung-einer-privaten-registry>Nutzung einer privaten Registry</h2><p>Private Registries könnten Schlüssel erfordern um Images von ihnen herunterzuladen.
Authentifizierungsdaten können auf verschiedene Weisen hinterlegt werden:</p><ul><li>Bei der Google Container Registry<ul><li>Je Cluster</li><li>Automatisch in der Google Compute Engine oder Google Kubernetes Engine</li><li>Allen Pods erlauben von der privaten Registry des Projektes lesen zu können</li></ul></li><li>Bei der Amazon Elastic Container Registry (ECR)<ul><li>IAM Rollen und Richtlinien nutzen um den Zugriff auf ECR Repositories zu kontrollieren</li><li>Automatisch ECR Authentifizierungsdaten aktualisieren</li></ul></li><li>Bei der Oracle Cloud Infrastructure Registry (OCIR)<ul><li>IAM Rollen und Richtlinien nutzen um den Zugriff auf OCIR Repositories zu kontrollieren</li></ul></li><li>Bei der Azure Container Registry (ACR)</li><li>Bei der IBM Cloud Container Registry</li><li>Nodes konfigurieren sich bei einer privaten Registry authentifizieren zu können
- Allen Pods erlauben von jeder konfigurierten privaten Registry lesen zu können
- Setzt die Konfiguration der Nodes durch einen Cluster - Aministrator voraus</li><li>Im Voraus heruntergeladene Images<ul><li>Alle Pods können jedes gecachte Image auf einem Node nutzen</li><li>Setzt root - Zugriff auf allen Nodes zum Einrichten voraus</li></ul></li><li>Spezifizieren eines ImagePullSecrets auf einem Pod<ul><li>Nur Pods, die eigene Secrets tragen, haben Zugriff auf eine private Registry</li></ul></li></ul><p>Jede Option wird im Folgenden im Detail beschrieben</p><h3 id=bei-nutzung-der-google-container-registry>Bei Nutzung der Google Container Registry</h3><p>Kubernetes hat eine native Unterstützung für die <a href=https://cloud.google.com/tools/container-registry/>Google Container
Registry (GCR)</a> wenn es auf der Google Compute
Engine (GCE) läuft. Wenn Sie ihren Cluster auf GCE oder der Google Kubernetes Engine betreiben, genügt es, einfach den vollen Image Namen zu nutzen (z.B. gcr.io/my_project/image:tag ).</p><p>Alle Pods in einem Cluster haben dann Lesezugriff auf Images in dieser Registry.</p><p>Das Kubelet authentifiziert sich bei GCR mit Nutzung des Google service Kontos der jeweiligen Instanz.
Das Google Servicekonto der Instanz hat einen <code>https://www.googleapis.com/auth/devstorage.read_only</code>, so kann es vom GCR des Projektes herunter, aber nicht hochladen.</p><h3 id=bei-nutzung-der-amazon-elastic-container-registry>Bei Nutzung der Amazon Elastic Container Registry</h3><p>Kubernetes bietet native Unterstützung für die <a href=https://aws.amazon.com/ecr/>Amazon Elastic Container Registry</a>, wenn Knoten AWS EC2 Instanzen sind.</p><p>Es muss einfach nur der komplette Image Name (z.B. <code>ACCOUNT.dkr.ecr.REGION.amazonaws.com/imagename:tag</code>) in der Pod - Definition genutzt werden.</p><p>Alle Benutzer eines Clusters, die Pods erstellen dürfen, können dann jedes der Images in der ECR Registry zum Ausführen von Pods nutzen.</p><p>Das Kubelet wird periodisch ECR Zugriffsdaten herunterladen und auffrischen, es benötigt hierfür die folgenden Berechtigungen:</p><ul><li><code>ecr:GetAuthorizationToken</code></li><li><code>ecr:BatchCheckLayerAvailability</code></li><li><code>ecr:GetDownloadUrlForLayer</code></li><li><code>ecr:GetRepositoryPolicy</code></li><li><code>ecr:DescribeRepositories</code></li><li><code>ecr:ListImages</code></li><li><code>ecr:BatchGetImage</code></li></ul><p>Voraussetzungen:</p><ul><li>Sie müssen Kubelet in der Version <code>v1.2.0</code> nutzen. (Führen sie z.B. (e.g. run <code>/usr/bin/kubelet --version=true</code> aus um die Version zu prüfen)</li><li>Sie benötigen Version <code>v1.3.0</code> oder neuer wenn ihre Knoten in einer A - Region sind und sich ihre Registry in einer anderen B - Region befindet.</li><li>ECR muss in ihrer Region angeboten werden</li></ul><p>Fehlerbehebung:</p><ul><li>Die oben genannten Voraussetzungen müssen erfüllt sein</li><li>Laden sie die $REGION (z.B. <code>us-west-2</code>) Zugriffsdaten auf ihren Arbeitsrechner. Verbinden sie sich per SSH auf den Host und nutzen die Docker mit diesen Daten. Funktioniert es?</li><li>Prüfen sie ob das Kubelet it dem Parameter <code>--cloud-provider=aws</code> läuft.</li><li>Prüfen sie die Logs des Kubelets (z.B. mit <code>journalctl -u kubelet</code>) auf Zeilen wie:<ul><li><code>plugins.go:56] Registering credential provider: aws-ecr-key</code></li><li><code>provider.go:91] Refreshing cache for provider: *aws_credentials.ecrProvider</code></li></ul></li></ul><h3 id=bei-nutzung-der-azure-container-registry-acr>Bei Nutzung der Azure Container Registry (ACR)</h3><p>Bei Nutzung der <a href=https://azure.microsoft.com/en-us/services/container-registry/>Azure Container Registry</a> können sie sich entweder als ein administrativer Nutzer, oder als ein Service Principal authentifizieren.
In jedem Fall wird die Authentifizierung über die Standard - Docker Authentifizierung ausgeführt. Diese Anleitung bezieht sich auf das <a href=https://github.com/azure/azure-cli>azure-cli</a> Kommandozeilenwerkzeug.</p><p>Sie müssen zunächst eine Registry und Authentifizierungsdaten erstellen, eine komplette Dokumentation dazu finden sie hier: <a href=https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli>Azure container registry documentation</a>.</p><p>Sobald sie ihre Container Registry erstellt haben, nutzen sie die folgenden Authentifizierungsdaten:</p><ul><li><code>DOCKER_USER</code> : Service Principal oder Administratorbenutzername</li><li><code>DOCKER_PASSWORD</code>: Service Principal Password oder Administratorpasswort</li><li><code>DOCKER_REGISTRY_SERVER</code>: <code>${some-registry-name}.azurecr.io</code></li><li><code>DOCKER_EMAIL</code>: <code>${some-email-address}</code></li></ul><p>Wenn sie diese Variablen befüllt haben, können sie:
<a href=/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>Kubernetes konfigurieren und damit einen Pod deployen</a>.</p><h3 id=bei-nutzung-der-ibm-cloud-container-registry>Bei Nutzung der IBM Cloud Container Registry</h3><p>Die IBM Cloud Container Registry bietet eine mandantenfähige Private Image Registry, die Sie nutzen können, um ihre Docker Images sicher zu speichern und zu teilen.
Standardmäßig werden Images in ihrer Private Registry vom integrierten Schwachstellenscaner durchsucht, um Sicherheitsprobleme und potentielle Schwachstellen zu finden. Benutzer können ihren IBM Cloud Account nutzen, um Zugang zu ihren Images zu erhalten, oder um einen Token zu generieren, der Zugriff auf die Registry Namespaces erlaubt.</p><p>Um das IBM Cloud Container Registry Kommandozeilenwerkzeug zu installieren und einen Namespace für ihre Images zu erstellen, folgen sie dieser Dokumentation <a href="https://cloud.ibm.com/docs/services/Registry?topic=registry-getting-started">Getting started with IBM Cloud Container Registry</a>.</p><p>Sie können die IBM Cloud Container Registry nutzen, um Container aus <a href="https://cloud.ibm.com/docs/services/Registry?topic=registry-public_images">IBM Cloud public images</a> und ihren eigenen Images in den <code>default</code> Namespace ihres IBM Cloud Kubernetes Service Clusters zu deployen.
Um einen Container in einen anderen Namespace, oder um ein Image aus einer anderen IBM Cloud Container Registry Region oder einem IBM Cloud account zu deployen, erstellen sie ein Kubernetes <code>imagePullSecret</code>.
Weitere Informationen finden sie unter: <a href="https://cloud.ibm.com/docs/containers?topic=containers-images">Building containers from images</a>.</p><h3 id=knoten-für-die-nutzung-einer-private-registry-konfigurieren>Knoten für die Nutzung einer Private Registry konfigurieren</h3><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Wenn sie Google Kubernetes Engine verwenden, gibt es schon eine <code>.dockercfg</code> auf jedem Knoten, die Zugriffsdaten für ihre Google Container Registry beinhaltet. Dann kann die folgende Vorgehensweise nicht angewendet werden.</div><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Wenn sie AWS EC2 verwenden und die EC2 Container Registry (ECR) nutzen, wird das Kubelet auf jedem Knoten die ECR Zugriffsdaten verwalten und aktualisieren. Dann kann die folgende Vorgehensweise nicht angewendet werden.</div><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Diese Vorgehensweise ist anwendbar, wenn sie ihre Knoten-Konfiguration ändern können; Sie wird nicht zuverlässig auf GCE oder einem anderen Cloud - Provider funktionieren, der automatisch Knoten ersetzt.</div><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Kubernetes unterstützt zurzeit nur die <code>auths</code> und <code>HttpHeaders</code> Abschnitte der Dockerkonfiguration. Das bedeutet, dass die Hilfswerkzeuge (<code>credHelpers</code> ooderr <code>credsStore</code>) nicht unterstützt werden.</div><p>Docker speichert Schlüssel für eigene Registries entweder unter <code>$HOME/.dockercfg</code> oder <code>$HOME/.docker/config.json</code>. Wenn sie die gleiche Datei in einen der unten aufgeführten Suchpfade speichern, wird Kubelet sie als Hilfswerkzeug für Zugriffsdaten beim Beziehen von Images nutzen.</p><ul><li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li><li><code>{cwd of kubelet}/config.json</code></li><li><code>${HOME}/.docker/config.json</code></li><li><code>/.docker/config.json</code></li><li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li><li><code>{cwd of kubelet}/.dockercfg</code></li><li><code>${HOME}/.dockercfg</code></li><li><code>/.dockercfg</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Eventuell müssen sie <code>HOME=/root</code> in ihrer Umgebungsvariablendatei setzen.</div><p>Dies sind die empfohlenen Schritte, um ihre Knoten für eine Nutzung einer eigenen Registry zu konfigurieren.
In diesem Beispiel führen sie folgende Schritte auf ihrem Desktop/Laptop aus:</p><ol><li>Führen sie <code>docker login [server]</code> für jeden Satz ihrer Zugriffsdaten aus. Dies aktualisiert <code>$HOME/.docker/config.json</code>.</li><li>Prüfen Sie <code>$HOME/.docker/config.json</code> in einem Editor darauf, ob dort nur Zugriffsdaten enthalten sind, die Sie nutzen möchten.</li><li>Erhalten sie eine Liste ihrer Knoten:<ul><li>Wenn sie die Namen benötigen: <code>nodes=$(kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}')</code></li><li>Wenn sie die IP - Adressen benötigen: <code>nodes=$(kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}')</code></li></ul></li><li>Kopieren sie ihre lokale <code>.docker/config.json</code> in einen der oben genannten Suchpfade.<ul><li>Zum Beispiel: <code>for n in $nodes; do scp ~/.docker/config.json root@$n:/var/lib/kubelet/config.json; done</code></li></ul></li></ol><p>Prüfen durch das Erstellen eines Pods, der ein eigenes Image nutzt, z.B.:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f - &lt;&lt;EOF<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-image-test-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>uses-private-image<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>$PRIVATE_IMAGE_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;echo&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;SUCCESS&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>EOF<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>pod/private-image-test-1 created<span style=color:#bbb>
</span></span></span></code></pre></div><p>Wenn alles funktioniert, sollten sie nach einigen Momenten folgendes sehen:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs private-image-test-1
</span></span><span style=display:flex><span>SUCCESS
</span></span></code></pre></div><p>Wenn es nicht funktioniert, sehen Sie:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#34;Failed&#34;</span>
</span></span><span style=display:flex><span>  Fri, <span style=color:#666>26</span> Jun <span style=color:#666>2015</span> 15:36:13 -0700    Fri, <span style=color:#666>26</span> Jun <span style=color:#666>2015</span> 15:39:13 -0700    <span style=color:#666>19</span>    <span style=color:#666>{</span>kubelet node-i2hq<span style=color:#666>}</span>    spec.containers<span style=color:#666>{</span>uses-private-image<span style=color:#666>}</span>    failed        Failed to pull image <span style=color:#b44>&#34;user/privaterepo:v1&#34;</span>: Error: image user/privaterepo:v1 not found
</span></span></code></pre></div><p>Sie müssen sich darum kümmern, dass alle Knoten im Cluster die gleiche <code>.docker/config.json</code> haben, andernfalls werden Pods auf einigen Knoten starten, auf anderen jedoch nicht.
Wenn sie zum Beispiel Knoten automatisch skalieren lassen, sollte dann jedes Instanztemplate die <code>.docker/config.json</code> beinhalten, oder ein Laufwerk einhängen, das diese beinhaltet.</p><p>Alle Pods haben Lesezugriff auf jedes Image in ihrer eigenen Registry, sobald die Registry - Schlüssel zur <code>.docker/config.json</code> hinzugefügt wurden.</p><h3 id=im-voraus-heruntergeladene-images>Im Voraus heruntergeladene Images</h3><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Wenn sie Google Kubernetes Engine verwenden, gibt es schon eine <code>.dockercfg</code> auf jedem Knoten die Zugriffsdaten für ihre Google Container Registry beinhaltet. Dann kann die folgende Vorgehensweise nicht angewendet werden.</div><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Diese Vorgehensweise ist anwendbar, wenn sie ihre Knoten-Konfiguration ändern können; Sie wird nicht zuverlässig auf GCE oder einem anderen Cloud - Provider funktionieren, der automatisch Knoten ersetzt.</div><p>Standardmäßig wird das Kubelet versuchen, jedes Image von der spezifizierten Registry herunterzuladen.
Falls jedoch die <code>imagePullPolicy</code> Eigenschaft der Containers auf <code>IfNotPresent</code> oder <code>Never</code> gesetzt wurde, wird ein lokales Image genutzt (präferiert oder exklusiv, jenachdem).</p><p>Wenn Sie sich auf im Voraus heruntergeladene Images als Ersatz für eine Registry - Authentifizierung verlassen möchten, müssen sie sicherstellen, dass alle Knoten die gleichen, im Voraus heruntergeladenen Images aufweisen.</p><p>Diese Methode kann dazu genutzt werden, bestimmte Images aus Geschwindigkeitsgründen im Voraus zu laden, oder als Alternative zur Authentifizierung an einer eigenen Registry zu nutzen.</p><p>Alle Pods haben Leserechte auf alle im Voraus geladenen Images.</p><h3 id=spezifizieren-eines-imagepullsecrets-für-einen-pod>Spezifizieren eines ImagePullSecrets für einen Pod</h3><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Diese Vorgehensweise ist aktuell die empfohlene Vorgehensweise für Google Kubernetes Engine, GCE, und jeden Cloud - Provider bei dem die Knotenerstelltung automatisiert ist.</div><p>Kubernetes unterstützt die Spezifikation von Registrierungsschlüsseln für einen Pod.</p><h4 id=erstellung-eines-secrets-mit-einer-docker-konfiguration>Erstellung eines Secrets mit einer Docker Konfiguration</h4><p>Führen sie folgenden Befehl mit Ersetzung der groß geschriebenen Werte aus:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</span></span></code></pre></div><p>Wenn Sie bereits eine Datei mit Docker-Zugriffsdaten haben, können Sie die Zugriffsdaten als ein Kubernetes Secret importieren:
<a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>Create a Secret based on existing Docker credentials</a> beschreibt die Erstellung.
Dies ist insbesondere dann sinnvoll, wenn sie mehrere eigene Container Registries nutzen, da <code>kubectl create secret docker-registry</code> ein Secret erstellt, das nur mit einer einzelnen eigenen Registry funktioniert.</p><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Pods können nur eigene Image Pull Secret in ihrem eigenen Namespace referenzieren, somit muss dieser Prozess jedes mal einzeln für jeden Namespace angewendet werden.</div><h4 id=referenzierung-eines-imagepullsecrets-bei-einem-pod>Referenzierung eines imagePullSecrets bei einem Pod</h4><p>Nun können Sie Pods erstellen, die dieses Secret referenzieren, indem Sie einen Aschnitt <code>imagePullSecrets</code> zu ihrer Pod - Definition hinzufügen.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Dies muss für jeden Pod getan werden, der eine eigene Registry nutzt.</p><p>Die Erstellung dieser Sektion kann jedoch automatisiert werden, indem man imagePullSecrets einer <a href=/docs/user-guide/service-accounts>serviceAccount</a> Ressource hinzufügt.
<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Add ImagePullSecrets to a Service Account</a> bietet detaillierte Anweisungen hierzu.</p><p>Sie können dies in Verbindung mit einer auf jedem Knoten genutzten <code>.docker/config.json</code> benutzen, die Zugriffsdaten werden dann zusammengeführt. Dieser Vorgehensweise wird in der Google Kubernetes Engine funktionieren.</p><h3 id=anwendungsfälle>Anwendungsfälle</h3><p>Es gibt eine Anzahl an Lösungen um eigene Registries zu konfigurieren, hier sind einige Anwendungsfälle und empfohlene Lösungen.</p><ol><li>Cluster die nur nicht-proprietäre Images (z.B. open-source) ausführen. Images müssen nicht versteckt werden.<ul><li>Nutzung von öffentlichen Images auf Docker Hub.<ul><li>Keine Konfiguration notwendig.</li><li>Auf GCE/Google Kubernetes Engine, wird automatisch ein lokaler Spiegel für eine verbesserte Geschwindigkeit und Verfügbarkeit genutzt.</li></ul></li></ul></li><li>Cluster die einige proprietäre Images ausführen die für Außenstehende nicht sichtbar sein dürfen, aber für alle Cluster - Benutzer sichtbar sein sollen.<ul><li>Nutzung einer gehosteten privaten Registry <a href=https://docs.docker.com/registry/>Docker registry</a>.<ul><li>Kann auf <a href=https://hub.docker.com/signup>Docker Hub</a>, oder woanders gehostet werden.</li><li>Manuelle Konfiguration der .docker/config.json auf jedem Knoten, wie oben beschrieben.</li></ul></li><li>Der Betrieb einer internen privaten Registry hinter ihrer Firewall mit offenen Leseberechtigungen.<ul><li>Keine Kubernetes - Konfiguration notwendig</li></ul></li><li>Wenn GCE/Google Kubernetes Engine genutzt wird, nutzen sie die Google Container Registry des Projektes.<ul><li>Funktioniert besser mit Cluster - Autoskalierung als mit manueller Knotenkonfiguration.</li></ul></li><li>Auf einem Cluster bei dem die Knotenkonfiguration ungünstig ist können <code>imagePullSecrets</code> genutzt werden.</li></ul></li><li>Cluster mit proprieritären Images, mit einigen Images die eine erweiterte Zugriffskontrolle erfordern.<ul><li>Stellen sie sicher das <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages admission controller</a> aktiv ist, anderenfalls können alle Pods potenziell Zugriff auf alle Images haben.</li><li>Verschieben sie sensitive Daten in eine "Secret" Ressource statt sie im Image abzulegen.</li></ul></li><li>Ein mandantenfähiger Cluster in dem jeder Mandant eine eigene private Registry benötigt.<ul><li>Stellen sie dicher das <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages admission controller</a> aktiv ist, anderenfalls können alle Pods potenziell Zugriff auf alle Images haben.</li><li>Nutzen sie eine private Registry die eine Authorisierung erfordert.</li><li>Generieren die Registry - Zugriffsdaten für jeden Mandanten, abgelegt in einem Secret das in jedem Mandanten - Namespace vorhanden ist.</li><li>Der Mandant fügt dieses Sercret zu den imagePullSecrets in jedem seiner Namespace hinzu.</li></ul></li></ol><p>Falls die Zugriff auf mehrere Registries benötigen, können sie ein Secret für jede Registry erstellen, Kubelet wird jedwede <code>imagePullSecrets</code> in einer einzelnen <code>.docker/config.json</code> zusammenfassen.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/de/docs/home/>Home</a>
<a class=text-white href=/de/blog/>Blog</a>
<a class=text-white href=/de/training/>Schulungen</a>
<a class=text-white href=/de/partners/>Partner</a>
<a class=text-white href=/de/community/>Community</a>
<a class=text-white href=/de/case-studies/>Fallstudien</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>