<!doctype html><html lang=de class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/tasks/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/tasks/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/><link rel=alternate hreflang=hi href=https://kubernetes.io/hi/docs/tasks/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/tasks/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/de/docs/tasks/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Aufgaben | Kubernetes</title><meta property="og:title" content="Aufgaben"><meta property="og:description" content="Produktionsreife Container-Orchestrierung"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/de/docs/tasks/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Aufgaben"><meta itemprop=description content="Produktionsreife Container-Orchestrierung"><meta name=twitter:card content="summary"><meta name=twitter:title content="Aufgaben"><meta name=twitter:description content="Produktionsreife Container-Orchestrierung"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Webbenutzeroberfläche (Dashboard) Die kubectl-Befehlszeile verwenden Pods und Container konfigurieren Anwendungen ausführen Jobs ausführen Auf Anwendungen in einem Cluster zugreifen Überwachung, Protokollierung und Fehlerbehebung Zugriff auf die Kubernetes-API TLS verwenden Cluster verwalten Föderation verwalten Managing Stateful Applications Cluster-Dämonen GPUs verwalten Verwalten von HugePages Nächste Schritte Dieser Abschnitt der Kubernetes-Dokumentation enthält Seiten, die zeigen, wie man einzelne Aufgaben erledigt. Eine Aufgabenseite zeigt, wie man eine einzelne Aufgabe ausführt, typischerweise durch eine kurze Abfolge von Schritten."><meta property="og:description" content="Webbenutzeroberfläche (Dashboard) Die kubectl-Befehlszeile verwenden Pods und Container konfigurieren Anwendungen ausführen Jobs ausführen Auf Anwendungen in einem Cluster zugreifen Überwachung, Protokollierung und Fehlerbehebung Zugriff auf die Kubernetes-API TLS verwenden Cluster verwalten Föderation verwalten Managing Stateful Applications Cluster-Dämonen GPUs verwalten Verwalten von HugePages Nächste Schritte Dieser Abschnitt der Kubernetes-Dokumentation enthält Seiten, die zeigen, wie man einzelne Aufgaben erledigt. Eine Aufgabenseite zeigt, wie man eine einzelne Aufgabe ausführt, typischerweise durch eine kurze Abfolge von Schritten."><meta name=twitter:description content="Webbenutzeroberfläche (Dashboard) Die kubectl-Befehlszeile verwenden Pods und Container konfigurieren Anwendungen ausführen Jobs ausführen Auf Anwendungen in einem Cluster zugreifen Überwachung, Protokollierung und Fehlerbehebung Zugriff auf die Kubernetes-API TLS verwenden Cluster verwalten Föderation verwalten Managing Stateful Applications Cluster-Dämonen GPUs verwalten Verwalten von HugePages Nächste Schritte Dieser Abschnitt der Kubernetes-Dokumentation enthält Seiten, die zeigen, wie man einzelne Aufgaben erledigt. Eine Aufgabenseite zeigt, wie man eine einzelne Aufgabe ausführt, typischerweise durch eine kurze Abfolge von Schritten."><meta property="og:url" content="https://kubernetes.io/de/docs/tasks/"><meta property="og:title" content="Aufgaben"><meta name=twitter:title content="Aufgaben"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/de/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/de/docs/>Dokumentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/training/>Schulungen</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/partners/>Partner</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/de/case-studies/>Fallstudien</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/de/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/de/docs/tasks/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/de/docs/tasks/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/de/docs/tasks/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/de/docs/tasks/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/de/docs/tasks/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Deutsch (German)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tasks/>English</a>
<a class=dropdown-item href=/zh-cn/docs/tasks/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/tasks/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/tasks/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/tasks/>Français (French)</a>
<a class=dropdown-item href=/es/docs/tasks/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/tasks/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/tasks/>Bahasa Indonesia</a>
<a class=dropdown-item href=/hi/docs/tasks/>हिन्दी (Hindi)</a>
<a class=dropdown-item href=/pl/docs/tasks/>Polski (Polish)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Das ist eine für den Ausdruck optimierte Ansicht des gesamten Kapitels inkl. Unterseiten.
<a href=# onclick="return print(),!1">Druckvorgang starten</a>.</p><p><a href=/de/docs/tasks/>Zur Standardansicht zurückkehren</a>.</p></div><h1 class=title>Aufgaben</h1><ul><li>1: <a href=#pg-57bf66f59d9a642b82eebeabbc66470b>Werkzeuge installieren</a></li><ul><li>1.1: <a href=#pg-bbdc530b292ab4074d1dfe69feafb3e7>Installieren und konfigurieren von kubectl</a></li><li>1.2: <a href=#pg-2142bfe0834f1bf8f47887f85adba495>Installation von Minikube</a></li></ul><li>2: <a href=#pg-34a810f1516ad9d99b2697e36e9b0d0f>Einen Cluster verwalten</a></li><ul><li>2.1: <a href=#pg-8e16d69617b175d61e2e7a6e1642c9d6>Verwaltung mit kubeadm</a></li><ul></ul></ul><li>3: <a href=#pg-f5da33b976758a9183018c421eb83f58>Pods und Container konfigurieren</a></li><ul></ul><li>4: <a href=#pg-866924fa095f897ede8dfdcab9e97942>Daten in Anwendungen injizieren</a></li><ul></ul><li>5: <a href=#pg-a78a5e7e765fd8c49c8f7c0d72499f72>Anwendungen ausführen</a></li><ul><li>5.1: <a href=#pg-0c0bb1bd76d2a9069e50e2cec6d20c2a>Horizontal Pod Autoscaler</a></li></ul><li>6: <a href=#pg-ca3bc4e31dfe46d5044a3b93eb804ee9>Jobs ausführen</a></li><ul></ul><li>7: <a href=#pg-b74b959f5a531003dd0653dfbfc2e88b>Auf Anwendungen in einem Cluster zugreifen</a></li><ul></ul><li>8: <a href=#pg-f6a755efe831d24956501e4bcd49ff96>Überwachung, Protokollierung und Fehlerbehebung</a></li><ul></ul><li>9: <a href=#pg-fd78dc15c135dedc24438431769d4d5b>Kubernetes erweitern</a></li><ul></ul><li>10: <a href=#pg-d3c88a8663f58e9ec0bed73faff5b670>TLS</a></li><ul></ul><li>11: <a href=#pg-40e9293a348cfa50147082afc09ff77f>Föderation</a></li><ul></ul><li>12: <a href=#pg-ba58efa15c6d46f10e34d799be220965>Cluster-Daemons verwalten</a></li><ul></ul><li>13: <a href=#pg-5266308e17490aeee8b018316bf47e03>Service Catalog installieren</a></li><ul></ul></ul><div class=content><nav id=TableOfContents><ul><li><a href=#webbenutzeroberfläche-dashboard>Webbenutzeroberfläche (Dashboard)</a></li><li><a href=#die-kubectl-befehlszeile-verwenden>Die kubectl-Befehlszeile verwenden</a></li><li><a href=#pods-und-container-konfigurieren>Pods und Container konfigurieren</a></li><li><a href=#anwendungen-ausführen>Anwendungen ausführen</a></li><li><a href=#jobs-ausführen>Jobs ausführen</a></li><li><a href=#auf-anwendungen-in-einem-cluster-zugreifen>Auf Anwendungen in einem Cluster zugreifen</a></li><li><a href=#überwachung-protokollierung-und-fehlerbehebung>Überwachung, Protokollierung und Fehlerbehebung</a></li><li><a href=#zugriff-auf-die-kubernetes-api>Zugriff auf die Kubernetes-API</a></li><li><a href=#tls-verwenden>TLS verwenden</a></li><li><a href=#cluster-verwalten>Cluster verwalten</a></li><li><a href=#föderation-verwalten>Föderation verwalten</a></li><li><a href=#managing-stateful-applications>Managing Stateful Applications</a></li><li><a href=#cluster-dämonen>Cluster-Dämonen</a></li><li><a href=#gpus-verwalten>GPUs verwalten</a></li><li><a href=#verwalten-von-hugepages>Verwalten von HugePages</a></li><li><a href=#nächste-schritte>Nächste Schritte</a></li></ul></nav><p>Dieser Abschnitt der Kubernetes-Dokumentation enthält Seiten, die zeigen, wie man einzelne Aufgaben erledigt.
Eine Aufgabenseite zeigt, wie man eine einzelne Aufgabe ausführt, typischerweise durch eine kurze Abfolge von Schritten.</p><h2 id=webbenutzeroberfläche-dashboard>Webbenutzeroberfläche (Dashboard)</h2><p>Stellen Sie die Dashboard-Webbenutzeroberfläche bereit, und greifen Sie auf sie zu, um Sie bei der Verwaltung und Überwachung von Containeranwendungen in einem Kubernetes-Cluster zu unterstützen.</p><h2 id=die-kubectl-befehlszeile-verwenden>Die kubectl-Befehlszeile verwenden</h2><p>Installieren und konfigurieren Sie das <code>kubectl</code>-Befehlszeilentool, mit dem Kubernetes-Cluster direkt verwaltet werden.</p><h2 id=pods-und-container-konfigurieren>Pods und Container konfigurieren</h2><p>Ausführen allgemeiner Konfigurationsaufgaben für Pods und Container.</p><h2 id=anwendungen-ausführen>Anwendungen ausführen</h2><p>Ausführen allgemeiner Aufgaben zur Anwendungsverwaltung, z. B. Aktualisierungen, Einfügen von Informationen in Pods und automatisches horizontales Skalieren der Pods.</p><h2 id=jobs-ausführen>Jobs ausführen</h2><p>Jobs mit Parallelverarbeitung ausführen.</p><h2 id=auf-anwendungen-in-einem-cluster-zugreifen>Auf Anwendungen in einem Cluster zugreifen</h2><p>Konfigurieren Sie den Lastausgleich, die Portweiterleitung oder die Einrichtung von Firewall- oder DNS-Konfigurationen für den Zugriff auf Anwendungen in einem Cluster.</p><h2 id=überwachung-protokollierung-und-fehlerbehebung>Überwachung, Protokollierung und Fehlerbehebung</h2><p>Richten Sie die Überwachung und Protokollierung ein, um einen Cluster zu behandeln oder eine Container-Anwendung zu debuggen.</p><h2 id=zugriff-auf-die-kubernetes-api>Zugriff auf die Kubernetes-API</h2><p>Lernen Sie verschiedene Methoden kennen, um direkt auf die Kubernetes-API zuzugreifen.</p><h2 id=tls-verwenden>TLS verwenden</h2><p>Konfigurieren Sie Ihre Anwendung so, dass sie der Cluster-Stammzertifizierungsstelle (Certificate Authority, CA) vertraut und diese verwendet.</p><h2 id=cluster-verwalten>Cluster verwalten</h2><p>Erfahren Sie allgemeine Aufgaben zum Verwalten eines Clusters.</p><h2 id=föderation-verwalten>Föderation verwalten</h2><p>Konfigurieren Sie Komponenten in einer Clusterföderation.</p><h2 id=managing-stateful-applications>Managing Stateful Applications</h2><p>Ausführen allgemeiner Aufgaben zum Verwalten von Stateful-Anwendungen, einschließlich Skalieren, Löschen und Debuggen von StatefulSets.</p><h2 id=cluster-dämonen>Cluster-Dämonen</h2><p>Ausführen allgemeiner Aufgaben zum Verwalten eines DaemonSet, z. B. Durchführen eines fortlaufenden Updates.</p><h2 id=gpus-verwalten>GPUs verwalten</h2><p>Konfigurieren und planen Sie NVIDIA-GPUs für die Verwendung durch Nodes in einem Cluster als Ressource.</p><h2 id=verwalten-von-hugepages>Verwalten von HugePages</h2><p>Konfigurieren und verwalten Sie <code>HugePages</code> als planbare Ressource in einem Cluster.</p><h2 id=nächste-schritte>Nächste Schritte</h2><p>Wenn Sie eine Aufgabenseite schreiben möchten, finden Sie weitere Informationen unter <a href=/docs/home/contribute/create-pull-request/>Erstellen einer Pull-Anfrage für Dokumentation</a>.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-57bf66f59d9a642b82eebeabbc66470b>1 - Werkzeuge installieren</h1></div><div class=td-content><h1 id=pg-bbdc530b292ab4074d1dfe69feafb3e7>1.1 - Installieren und konfigurieren von kubectl</h1><p>Verwenden Sie das Kubernetes Befehlszeilenprogramm, <a href=/docs/user-guide/kubectl/>kubectl</a>, um Anwendungen auf Kubernetes bereitzustellen und zu verwalten.
Mit kubectl können Sie Clusterressourcen überprüfen, Komponenten erstellen, löschen und aktualisieren; Ihren neuen Cluster betrachten; und Beispielanwendungen aufrufen.</p><h2 id=bevor-sie-beginnen>Bevor Sie beginnen</h2><p>Sie müssen eine kubectl-Version verwenden, die innerhalb eines geringfügigen Versionsunterschieds zur Version Ihres Clusters liegt. Ein v1.2-Client sollte beispielsweise mit einem v1.1, v1.2 und v1.3-Master arbeiten. Die Verwendung der neuesten Version von kubectl verhindert unvorhergesehene Probleme.</p><h2 id=kubectl-installieren>Kubectl installieren</h2><p>Nachfolgend finden Sie einige Methoden zur Installation von kubectl.</p><h2 id=installieren-der-kubectl-anwendung-mithilfe-der-systemeigenen-paketverwaltung>Installieren der kubectl Anwendung mithilfe der systemeigenen Paketverwaltung</h2><ul class="nav nav-tabs" id=kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-install-0 role=tab aria-controls=kubectl-install-0 aria-selected=true>Ubuntu, Debian oder HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-install-1 role=tab aria-controls=kubectl-install-1>CentOS, RHEL oder Fedora</a></li></ul><div class=tab-content id=kubectl-install><div id=kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-install-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo apt-get update <span style=color:#666>&amp;&amp;</span> sudo apt-get install -y apt-transport-https
</span></span><span style=display:flex><span>curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb https://apt.kubernetes.io/ kubernetes-xenial main&#34;</span> | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
</span></span><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y kubectl
</span></span></code></pre></div></div><div id=kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-install-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
</span></span></span><span style=display:flex><span><span style=color:#b44>[kubernetes]
</span></span></span><span style=display:flex><span><span style=color:#b44>name=Kubernetes
</span></span></span><span style=display:flex><span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
</span></span></span><span style=display:flex><span><span style=color:#b44>enabled=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>repo_gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>yum install -y kubectl
</span></span></code></pre></div></div></div><h2 id=installation-mit-snap-auf-ubuntu>Installation mit snap auf Ubuntu</h2><p>Wenn Sie Ubuntu oder eine der anderen Linux-Distributionen verwenden, die den <a href=https://snapcraft.io/docs/core/install>snap</a> Paketmanager unterstützen, können Sie kubectl als <a href=https://snapcraft.io/>snap</a>-Anwendung installieren.</p><ol><li><p>Wechseln Sie zum Snap-Benutzer und führen Sie den Installationsbefehl aus:</p><pre tabindex=0><code>sudo snap install kubectl --classic
</code></pre></li><li><p>Testen Sie, ob die installierte Version ausreichend aktuell ist:</p><pre tabindex=0><code>kubectl version
</code></pre></li></ol><h2 id=installation-mit-homebrew-auf-macos>Installation mit Homebrew auf macOS</h2><p>Wenn Sie mit macOS arbeiten und den <a href=https://brew.sh/>Homebrew</a> Paketmanager verwenden, können Sie kubectl mit Homebrew installieren.</p><ol><li><p>Führen Sie den Installationsbefehl aus:</p><pre tabindex=0><code>brew install kubernetes-cli
</code></pre></li><li><p>Testen Sie, ob die installierte Version ausreichend aktuell ist:</p><pre tabindex=0><code>kubectl version
</code></pre></li></ol><h2 id=installation-mit-macports-auf-macos>Installation mit Macports auf macOS</h2><p>Wenn Sie mit macOS arbeiten und den <a href=https://macports.org/>Macports</a> Paketmanager verwenden, können Sie kubectl mit Macports installieren.</p><ol><li><p>Führen Sie den Installationsbefehl aus:</p><pre tabindex=0><code>sudo port selfupdate
sudo port install kubectl
</code></pre></li><li><p>Testen Sie, ob die installierte Version ausreichend aktuell ist:</p><pre tabindex=0><code>kubectl version
</code></pre></li></ol><h2 id=installation-mit-powershell-von-psgallery>Installation mit PowerShell von PSGallery</h2><p>Wenn Sie mit Windows arbeiten und den <a href=https://www.powershellgallery.com/>Powershell Gallery</a> Paketmanager verwenden, können Sie kubectl mit Powershell installieren und aktualisieren.</p><ol><li><p>Führen Sie die Installationsbefehle aus (stellen Sie sicher, dass eine <code>DownloadLocation</code> angegeben wird):</p><pre tabindex=0><code>Install-Script -Name install-kubectl -Scope CurrentUser -Force
install-kubectl.ps1 [-DownloadLocation &lt;path&gt;]
</code></pre><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Wenn Sie keine <code>DownloadLocation</code> angeben, wird <code>kubectl</code> im temporären Verzeichnis des Benutzers installiert.</div><p>Das Installationsprogramm erstellt <code>$HOME/.kube</code> und weist es an, eine Konfigurationsdatei zu erstellen</p></li><li><p>Testen Sie, ob die installierte Version ausreichend aktuell ist:</p><pre tabindex=0><code>kubectl version
</code></pre><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Die Aktualisierung der Installation erfolgt durch erneutes Ausführen der beiden in Schritt 1 aufgelisteten Befehle.</div></li></ol><h2 id=installation-auf-windows-mit-chocolatey-oder-scoop>Installation auf Windows mit Chocolatey oder scoop</h2><p>Um kubectl unter Windows zu installieren, können Sie entweder den Paketmanager <a href=https://chocolatey.org>Chocolatey</a> oder das Befehlszeilen-Installationsprogramm <a href=https://scoop.sh>scoop</a> verwenden.</p><p><ul class="nav nav-tabs" id=kubectl-win-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-win-install-0 role=tab aria-controls=kubectl-win-install-0 aria-selected=true>choco</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-win-install-1 role=tab aria-controls=kubectl-win-install-1>scoop</a></li></ul><div class=tab-content id=kubectl-win-install><div id=kubectl-win-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-win-install-0><p><pre><code>choco install kubernetes-cli
</code></pre></div><div id=kubectl-win-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-win-install-1><p><pre><code>scoop install kubectl
</code></pre></div></div>2. Testen Sie, ob die installierte Version ausreichend aktuell ist:</p><pre><code>```
kubectl version
```
</code></pre><ol start=3><li><p>Navigieren Sie zu Ihrem Heimatverzeichnis:</p><pre tabindex=0><code>cd %USERPROFILE%
</code></pre></li><li><p>Erstellen Sie das <code>.kube</code>-Verzeichnis:</p><pre tabindex=0><code>mkdir .kube
</code></pre></li><li><p>Wechseln Sie in das soeben erstellte <code>.kube</code>-Verzeichnis:</p><pre tabindex=0><code>cd .kube
</code></pre></li><li><p>Konfigurieren Sie kubectl für die Verwendung eines Remote-Kubernetes-Clusters:</p><pre tabindex=0><code>New-Item config -type file
</code></pre><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Bearbeiten Sie die Konfigurationsdatei mit einem Texteditor Ihrer Wahl, z.B. Notepad.</div></li></ol><h2 id=download-als-teil-des-google-cloud-sdk-herunter>Download als Teil des Google Cloud SDK herunter</h2><p>Sie können kubectl als Teil des Google Cloud SDK installieren.</p><ol><li><p>Installieren Sie das <a href=https://cloud.google.com/sdk/>Google Cloud SDK</a>.</p></li><li><p>Führen Sie den <code>kubectl</code>-Installationsbefehl aus:</p><pre tabindex=0><code>gcloud components install kubectl
</code></pre></li><li><p>Testen Sie, ob die installierte Version ausreichend aktuell ist:</p><pre tabindex=0><code>kubectl version
</code></pre></li></ol><h2 id=installation-der-kubectl-anwendung-mit-curl>Installation der kubectl Anwendung mit curl</h2><ul class="nav nav-tabs" id=kubectl-install-curl role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-install-curl-0 role=tab aria-controls=kubectl-install-curl-0 aria-selected=true>macOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-install-curl-1 role=tab aria-controls=kubectl-install-curl-1>Linux</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-install-curl-2 role=tab aria-controls=kubectl-install-curl-2>Windows</a></li></ul><div class=tab-content id=kubectl-install-curl><div id=kubectl-install-curl-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-install-curl-0><p><ol><li><p>Laden Sie die neueste Version herunter:</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl
</code></pre><p>Um eine bestimmte Version herunterzuladen, ersetzen Sie den Befehlsteil <code>$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)</code> mit der jeweiligen Version.</p><p>Um beispielsweise die Version v1.25.0 auf macOS herunterzuladen, verwenden Sie den folgenden Befehl:</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/darwin/amd64/kubectl
</code></pre></li><li><p>Machen Sie die kubectl-Binärdatei ausführbar.</p><pre tabindex=0><code>chmod +x ./kubectl
</code></pre></li><li><p>Verschieben Sie die Binärdatei in Ihren PATH.</p><pre tabindex=0><code>sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre></li></ol></div><div id=kubectl-install-curl-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-install-curl-1><p><ol><li><p>Laden Sie die neueste Version mit dem Befehl herunter:</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
</code></pre><p>Um eine bestimmte Version herunterzuladen, ersetzen Sie den Befehlsteil <code>$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)</code> mit der jeweiligen Version.</p><p>Um beispielsweise die Version v1.25.0 auf Linux herunterzuladen, verwenden Sie den folgenden Befehl:</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/linux/amd64/kubectl
</code></pre></li><li><p>Machen Sie die kubectl-Binärdatei ausführbar.</p><pre tabindex=0><code>chmod +x ./kubectl
</code></pre></li><li><p>Verschieben Sie die Binärdatei in Ihren PATH.</p><pre tabindex=0><code>sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre></li></ol></div><div id=kubectl-install-curl-2 class=tab-pane role=tabpanel aria-labelledby=kubectl-install-curl-2><p><ol><li><p>Laden Sie das aktuellste Release v1.25.0 von <a href=https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/windows/amd64/kubectl.exe>diesem link</a> herunter.</p><p>Oder, sofern Sie <code>curl</code> installiert haven, verwenden Sie den folgenden Befehl:</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/windows/amd64/kubectl.exe
</code></pre><p>Informationen zur aktuellen stabilen Version (z. B. für scripting) finden Sie unter <a href=https://storage.googleapis.com/kubernetes-release/release/stable.txt>https://storage.googleapis.com/kubernetes-release/release/stable.txt</a>.</p></li><li><p>Verschieben Sie die Binärdatei in Ihren PATH.</p></li></ol></div></div><h2 id=kubectl-konfigurieren>kubectl konfigurieren</h2><p>Damit kubectl einen Kubernetes-Cluster finden und darauf zugreifen kann, benötigt es eine <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig Datei</a>. Diese wird automatisch erstellt, wenn Sie einen Cluster mit <a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a> erstellen oder einen Minikube-Cluster erfolgreich implementieren. Weitere Informationen zum Erstellen von Clustern finden Sie in den <a href=/docs/setup/>Anleitungen für die ersten Schritte</a>. Wenn Sie Zugriff auf einen Cluster benötigen, den Sie nicht erstellt haben, lesen Sie die <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Cluster-Zugriff freigeben Dokumentation</a>.
Die kubectl-Konfiguration befindet sich standardmäßig unter <code>~/.kube/config</code>.</p><h2 id=überprüfen-der-kubectl-konfiguration>Überprüfen der kubectl-Konfiguration</h2><p>Überprüfen Sie, ob kubectl ordnungsgemäß konfiguriert ist, indem Sie den Clusterstatus abrufen:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><p>Wenn Sie eine URL-Antwort sehen, ist kubectl korrekt für den Zugriff auf Ihren Cluster konfiguriert.</p><p>Wenn eine Meldung ähnlich der folgenden angezeigt wird, ist kubectl nicht richtig konfiguriert oder kann keine Verbindung zu einem Kubernetes-Cluster herstellen.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
</span></span></code></pre></div><p>Wenn Sie beispielsweise vorhaben, einen Kubernetes-Cluster auf Ihrem Laptop (lokal) auszuführen, müssen Sie zunächst ein Tool wie minikube installieren und anschließend die oben genannten Befehle erneut ausführen.</p><p>Wenn kubectl cluster-info die URL-Antwort zurückgibt, Sie jedoch nicht auf Ihren Cluster zugreifen können, verwenden Sie Folgendes, um zu überprüfen, ob er ordnungsgemäß konfiguriert ist:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info dump
</span></span></code></pre></div><h2 id=aktivieren-der-automatischen-autovervollständigung-der-shell>Aktivieren der automatischen Autovervollständigung der Shell</h2><p>kubectl bietet Autocompletion-Unterstützung für Bash und Zsh, was Ihnen viel Tipparbeit erspart!</p><p>Im Folgenden werden die Verfahren zum Einrichten der automatischen Vervollständigung für Bash (einschließlich der Unterschiede zwischen Linux und macOS) und Zsh beschrieben.</p><ul class="nav nav-tabs" id=kubectl-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-autocompletion-0 role=tab aria-controls=kubectl-autocompletion-0 aria-selected=true>Bash on Linux</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-1 role=tab aria-controls=kubectl-autocompletion-1>Bash auf macOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-2 role=tab aria-controls=kubectl-autocompletion-2>Zsh</a></li></ul><div class=tab-content id=kubectl-autocompletion><div id=kubectl-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-autocompletion-0><p><h3 id=einführung>Einführung</h3><p>Das kubectl-Vervollständigungsskript für Bash kann mit dem Befehl <code>kubectl completion bash</code> generiert werden. Durch das Sourcing des Vervollständigungsskripts in Ihrer Shell wird die automatische Vervollständigung von kubectl ermöglicht.</p><p>Das Fertigstellungsskript benötigt jedoch <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>. Dies bedeutet, dass Sie diese Software zuerst installieren müssen (Sie können testen, ob Sie bereits bash-completion installiert haben, indem Sie <code>type _init_completion</code> ausführen).</p><h3 id=installation-von-bash-completion>Installation von bash-completion</h3><p>bash-completion wird von vielen Paketmanagern bereitgestellt (siehe <a href=https://github.com/scop/bash-completion#installation>hier</a>). Sie können es mittels <code>apt-get install bash-completion</code> oder <code>yum install bash-completion</code>, usw.</p><p>Die obigen Befehle erstellen <code>/usr/share/bash-completion/bash_completion</code>,Dies ist das Hauptskript für die Bash-Vollendung. Abhängig von Ihrem Paketmanager müssen Sie diese Datei manuell in Ihre <code>~ / .bashrc</code>-Datei eingeben.</p><p>Um dies herauszufinden, laden Sie Ihre Shell erneut und führen Sie <code>type _init_completion</code> aus. Wenn der Befehl erfolgreich ist, ist bereits alles vorbereitet. Andernfalls fügen Sie der <code>~/.bashrc</code>-Datei Folgendes hinzu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>source</span> /usr/share/bash-completion/bash_completion
</span></span></code></pre></div><p>Laden Sie Ihre Shell erneut und vergewissern Sie sich, dass bash-completion korrekt installiert ist, indem Sie folgendes eingeben: <code>type _init_completion</code>.</p><h3 id=aktivieren-der-automatische-vervollständigung-von-kubectl>Aktivieren der automatische Vervollständigung von kubectl</h3><p>Sie müssen nun sicherstellen, dass das kubectl-Abschlussskript in allen Ihren Shell-Sitzungen verwendet wird. Es gibt zwei Möglichkeiten, dies zu tun:</p><ul><li><p>Fügen Sie das Vervollständigungsskript Ihrer <code>~ /.bashrc</code>-Datei hinzu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div></li><li><p>Fügen Sie das Vervollständigungsskript zum Verzeichnis <code>/etc/bash_completion.d</code> hinzu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl completion bash &gt;/etc/bash_completion.d/kubectl
</span></span></code></pre></div></li></ul><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> bash-completion bezieht alle Vervollständigungsskripte aus <code>/etc/bash_completion.d</code>.</div><p>Beide Ansätze sind gleichwertig. Nach dem erneuten Laden der Shell sollte kubectl autocompletion funktionieren.</p></div><div id=kubectl-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-1><p><div class="alert alert-danger warning callout" role=alert><strong>Warnung:</strong> macOS beinhaltet standardmäßig Bash 3.2. Das kubectl-Vervollständigunsskript erfordert Bash 4.1+ und funktioniert nicht mit Bash 3.2. Um dies zu umgehen, können Sie eine neuere Version von Bash unter macOS installieren (folgen Sie den Anweisungen <a href=https://itnext.io/upgrading-bash-on-macos-7138bd1066ba>hier</a>). Die folgenden Anweisungen funktionieren nur, wenn Sie Bash 4.1 oder höher verwenden.</div><h3 id=einführung>Einführung</h3><p>Das kubectl-Vervollständigungsskript für Bash kann mit dem Befehl <code>kubectl completion bash</code> generiert werden. Durch das Sourcing des Vervollständigungsskripts in Ihrer Shell wird die automatische Vervollständigung von kubectl ermöglicht.</p><p>Das Fertigstellungsskript benötigt jedoch <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>. Dies bedeutet, dass Sie diese Software zuerst installieren müssen (Sie können testen, ob Sie bereits bash-completion installiert haben, indem Sie <code>type _init_completion</code> ausführen).</p><h3 id=installation-von-bash-completion>Installation von bash-completion</h3><p>Sie können bash-completion mit Homebrew installieren:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew install bash-completion@2
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> <code>@2</code> steht für bash-completion 2, was vom kubectl Vervollständigungsskript benötigt wird (es funktioniert nicht mit bash-completion 1). Für bash-completion 2 ist wiederum Bash 4.1 oder höher erforderlich. Deshalb mussten Sie Bash aktualisieren.</div><p>Wie in der Ausgabe von <code>brew install</code> (Abschnitt "Vorsichtsmaßnahmen") angegeben, fügen Sie Ihrer <code>~/.bashrc</code> oder <code>~/.bash_profile</code>-Datei die folgenden Zeilen hinzu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>BASH_COMPLETION_COMPAT_DIR</span><span style=color:#666>=</span>/usr/local/etc/bash_completion.d
</span></span><span style=display:flex><span><span style=color:#666>[[</span> -r /usr/local/etc/profile.d/bash_completion.sh <span style=color:#666>]]</span> <span style=color:#666>&amp;&amp;</span> . /usr/local/etc/profile.d/bash_completion.sh
</span></span></code></pre></div><p>Laden Sie Ihre Shell erneut und vergewissern Sie sich, dass bash-completion korrekt installiert ist, indem Sie <code>type _init_completion</code> eingeben.</p><h3 id=aktivieren-der-automatischen-vervollständigung-von-kubectl>Aktivieren der automatischen Vervollständigung von kubectl</h3><p>Sie müssen nun sicherstellen, dass das kubectl-Abschlussskript in allen Ihren Shell-Sitzungen verwendet wird. Es gibt mehrere Möglichkeiten, dies zu tun:</p><ul><li><p>Fügen Sie das Vervollständigungsskript Ihrer <code>~ /.bashrc</code>-Datei hinzu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div></li><li><p>Fügen Sie das Vervollständigungsskript zum Verzeichnis <code>/etc/bash_completion.d</code> hinzu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl completion bash &gt;/usr/local/etc/bash_completion.d/kubectl
</span></span></code></pre></div></li><li><p>Wenn Sie kubectl mit Homebrew installiert haben (wie <a href=#install-with-homebrew-on-macos>hier</a> beschrieben), dann wurde das Vervollständigungsskript automatisch in <code>/usr/local/etc/bash_completion.d/kubectl</code> installiert. In diesem Fall müssen Sie nichts tun.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> bash-completion (falls mit Homebrew installiert) bezieht alle Vervollständigungsskripte aus dem Verzeichnis, das in der Umgebungsvariablen <code>BASH_COMPLETION_COMPAT_DIR</code>festgelegt ist.</div><p>Alle Ansätze sind gleichwertig. Nach dem erneuten Laden der Shell sollte kubectl Autovervollständigung funktionieren.</p></div><div id=kubectl-autocompletion-2 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-2><p><p>Das kubectl Vervollständigungsskript für Zsh kann mit dem folgenden Befehl generiert werden: <code>kubectl completion zsh</code>. Durch das Sourcing des Completion-Skripts in Ihrer Shell wird die automatische Vervollständigung von kubectl ermöglicht.</p><p>Fügen Sie Ihrer <code>~/.zshrc</code>-Datei dazu Folgendes hinzu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>
</span></span></code></pre></div><p>Nach dem erneuten Laden der Shell sollte kubectl Autovervollständigung funktionieren.</p><p>Wenn eine Fehlermeldung wie <code>complete: 13: command not found: compdef</code> angezeigt wird, fügen Sie am Anfang der Datei `~/.zshrc" folgendes hinzu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>autoload -Uz compinit
</span></span><span style=display:flex><span>compinit
</span></span></code></pre></div></div></div><h2 id=nächste-schritte>Nächste Schritte</h2><p><a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Erfahren Sie, wie Sie Ihre Anwendung starten und verfügbar machen.</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-2142bfe0834f1bf8f47887f85adba495>1.2 - Installation von Minikube</h1><p>Diese Seite zeigt Ihnen, wie Sie <a href=/docs/tutorials/hello-minikube>Minikube</a> installieren, ein Programm, das einen Kubernetes-Cluster mit einem einzigen Node in einer virtuellen Maschine auf Ihrem Laptop ausführt.</p><h2 id=bevor-sie-beginnen>Bevor Sie beginnen</h2><p>Die VT-x- oder AMD-v-Virtualisierung muss im BIOS Ihres Computers aktiviert sein. Um dies unter Linux zu überprüfen, führen Sie Folgendes aus und vergewissern Sie sich, dass die Ausgabe nicht leer ist:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>egrep --color <span style=color:#b44>&#39;vmx|svm&#39;</span> /proc/cpuinfo
</span></span></code></pre></div><h2 id=einen-hypervisor-installieren>Einen Hypervisor installieren</h2><p>Wenn noch kein Hypervisor installiert ist, installieren Sie jetzt einen für Ihr Betriebssystem:</p><table><thead><tr><th style=text-align:left>Betriebssystem</th><th style=text-align:left>Unterstützte Hypervisoren</th></tr></thead><tbody><tr><td style=text-align:left>macOS</td><td style=text-align:left><a href=https://www.virtualbox.org/wiki/Downloads>VirtualBox</a>, <a href=https://www.vmware.com/products/fusion>VMware Fusion</a>, <a href=https://github.com/moby/hyperkit>HyperKit</a></td></tr><tr><td style=text-align:left>Linux</td><td style=text-align:left><a href=https://www.virtualbox.org/wiki/Downloads>VirtualBox</a>, <a href=http://www.linux-kvm.org/>KVM</a></td></tr><tr><td style=text-align:left>Windows</td><td style=text-align:left><a href=https://www.virtualbox.org/wiki/Downloads>VirtualBox</a>, <a href=https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/quick_start/walkthrough_install>Hyper-V</a></td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Minikube unterstützt auch die Option <code>--vm-driver=none</code>, mit der die Kubernetes-Komponenten auf dem Host und nicht in einer VM ausgeführt werden. Die Verwendung dieses Treibers erfordert Docker und eine Linux-Umgebung, jedoch keinen Hypervisor.</div><h2 id=kubectl-installieren>Kubectl installieren</h2><ul><li>Installieren Sie kubectl gemäß den Anweisungen in <a href=/docs/tasks/tools/install-kubectl/>kubectl installieren und einrichten</a>.</li></ul><h2 id=minikube-installieren>Minikube installieren</h2><h3 id=macos>macOS</h3><p>Die einfachste Möglichkeit, Minikube unter macOS zu installieren, ist die Verwendung von <a href=https://brew.sh>Homebrew</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew install minikube
</span></span></code></pre></div><p>Sie können es auch auf macOS installieren, indem Sie eine statische Binärdatei herunterladen:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> chmod +x minikube
</span></span></code></pre></div><p>So fügen Sie die Minikube-Programmdatei auf einfache Weise Ihrem Pfad hinzu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo mv minikube /usr/local/bin
</span></span></code></pre></div><h3 id=linux>Linux</h3><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Dieses Dokument zeigt Ihnen, wie Sie Minikube mit einer statischen Binärdatei unter Linux installieren. Für alternative Linux-Installationsmethoden siehe <a href=https://minikube.sigs.k8s.io/docs/start/>Andere Installationsmethoden</a> im offiziellen Minikube-GitHub-Repository.</div><p>Sie können Minikube unter Linux installieren, indem Sie eine statische Binärdatei herunterladen:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> chmod +x minikube
</span></span></code></pre></div><p>So fügen Sie die Minikube-Programmdatei auf einfache Weise Ihrem Pfad hinzu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo cp minikube /usr/local/bin <span style=color:#666>&amp;&amp;</span> rm minikube
</span></span></code></pre></div><h3 id=windows>Windows</h3><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Um Minikube unter Windows auszuführen, müssen Sie zuerst <a href=https://www.virtualbox.org/>VirtualBox</a> oder <a href=https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v>Hyper-V</a> installieren. Hyper-V kann auf drei Versionen von Windows 10 ausgeführt werden: Windows 10 Enterprise, Windows 10 Professional und Windows 10 Education. Weitere Informationen zur Installation finden Sie im offiziellen <a href=https://github.com/kubernetes/minikube/#installation>Minikube GitHub-Repository</a>.</div><p>Die einfachste Möglichkeit, Minikube unter Windows zu installieren, ist die Verwendung von <a href=https://chocolatey.org/>Chocolatey</a> (als Administrator ausführen):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>choco install minikube kubernetes-cli
</span></span></code></pre></div><p>Schließen Sie nach der Installation von Minikube die aktuelle CLI-Sitzung und starten Sie sie neu. Minikube sollte automatisch zu Ihrem Pfad hinzugefügt werden.</p><h4 id=manuelle-installation-unter-windows>Manuelle installation unter Windows</h4><p>Um Minikube manuell unter Windows zu installieren, laden Sie die Datei <a href=https://github.com/kubernetes/minikube/releases/latest><code>minikube-windows-amd64</code></a> herunter, umbenennen Sie sie in <code>minikube.exe</code> und fügen Sie sie Ihrem Pfad zu.</p><h4 id=windows-installer>Windows Installer</h4><p>So installieren Sie Minikube manuell unter Windows mit <a href=https://docs.microsoft.com/en-us/windows/desktop/msi/windows-installer-portal>Windows Installer</a>, laden Sie die Datei <a href=https://github.com/kubernetes/minikube/releases/latest><code>minikube-installer.exe</code></a> und führen Sie den Installer aus.</p><h2 id=eine-bestehende-installation-bereinigen>Eine bestehende Installation bereinigen</h2><p>Wenn Sie minikube bereits installiert haben, starten Sie die Anwendung:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start
</span></span></code></pre></div><p>Und der Befehl gibt einen Fehler zurück:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>machine does not exist
</span></span></code></pre></div><p>Müssen Sie die Konfigurationsdateien löschen:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>rm -rf ~/.minikube
</span></span></code></pre></div><h2 id=nächste-schritte>Nächste Schritte</h2><ul><li><a href=/docs/setup/minikube/>Kubernetes lokal über Minikube ausführen</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-34a810f1516ad9d99b2697e36e9b0d0f>2 - Einen Cluster verwalten</h1><div class=lead>Lerne allgemeine Aufgaben zur Verwaltung eines Clusters kennen.</div></div><div class=td-content><h1 id=pg-8e16d69617b175d61e2e7a6e1642c9d6>2.1 - Verwaltung mit kubeadm</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-f5da33b976758a9183018c421eb83f58>3 - Pods und Container konfigurieren</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-866924fa095f897ede8dfdcab9e97942>4 - Daten in Anwendungen injizieren</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-a78a5e7e765fd8c49c8f7c0d72499f72>5 - Anwendungen ausführen</h1></div><div class=td-content><h1 id=pg-0c0bb1bd76d2a9069e50e2cec6d20c2a>5.1 - Horizontal Pod Autoscaler</h1><p>Der Horizontal Pod Autoscaler skaliert automatisch die Anzahl der Pods eines Replication Controller, Deployment oder Replikat Set basierend auf der beobachteten CPU-Auslastung (oder, mit Unterstützung von <a href=https://git.k8s.io/design-proposals-archive/instrumentation/custom-metrics-api.md>benutzerdefinierter Metriken</a>, von der Anwendung bereitgestellten Metriken). Beachte, dass die horizontale Pod Autoskalierung nicht für Objekte gilt, die nicht skaliert werden können, z. B. DaemonSets.</p><p>Der Horizontal Pod Autoscaler ist als Kubernetes API-Ressource und einem Controller implementiert.
Die Ressource bestimmt das Verhalten des Controllers.
Der Controller passt die Anzahl der Replikate eines Replication Controller oder Deployments regelmäßig an, um die beobachtete durchschnittliche CPU-Auslastung an das vom Benutzer angegebene Ziel anzupassen.</p><h2 id=wie-funktioniert-der-horizontal-pod-autoscaler>Wie funktioniert der Horizontal Pod Autoscaler?</h2><p><img src=/images/docs/horizontal-pod-autoscaler.svg alt="Horizontal Pod Autoscaler Diagramm"></p><p>Der Horizontal Pod Autoscaler ist als Kontrollschleife mit einer Laufzeit implementiert, die durch das Flag <code>--horizontal-pod-autoscaler-sync-period</code> am Controller Manager gesteuert wird (mit einem Standardwert von 15 Sekunden).</p><p>Während jedem Durchlauf fragt der Controller Manager die Ressourcennutzung anhand der in jeder HorizontalPodAutoscaler Definition angegebenen Metriken ab. Der Controller Manager bezieht die Metriken entweder aus der Resource Metrics API (für Ressourcenmetriken pro Pod) oder aus der Custom Metrics API (für alle anderen Metriken).</p><ul><li>Für jede pro Pod Ressourcenmetriken (wie CPU) ruft der Controller die Metriken über die Ressourcenmetriken API für jeden Pod ab, der vom HorizontalPodAutoscaler angesprochen wird. Sofern ein Zielnutzungswert eingestellt ist, berechnet der Controller den Nutzungswert als Prozentsatz der äquivalenten Ressourcenanforderung der Containern in jedem Pod. Wenn ein Ziel-Rohwert eingestellt ist, werden die Rohmetrikenwerte direkt verwendet. Der Controller nimmt dann den Mittelwert der Auslastung oder den Rohwert (je nach Art des angegebenen Ziels) über alle Zielpods und erzeugt ein Quotienten, mit dem die Anzahl der gewünschten Replikate skaliert wird.</li></ul><p>Beachte, dass, wenn einige der Container des Pods nicht über den entsprechenden Ressourcenanforderung verfügen, die CPU-Auslastung für den Pod nicht definiert wird und der Autoscaler keine Maßnahmen bezüglich dieser Metrik ergreift. Weitere Informationen zur Funktionsweise des Autoskalierungsalgorithmus finden Sie im folgenden Abschnitt über den <a href=#details-zum-algorithmus>Algorithmus</a>.</p><ul><li><p>Bei benutzerdefinierten Metriken pro Pod funktioniert die Steuerung ähnlich wie bei Ressourcenmetriken pro Pod, nur dass diese mit Rohwerten und nicht mit Nutzungswerten arbeitet.</p></li><li><p>Für Objektmetriken und externe Metriken wird eine einzelne Metrik abgerufen, die das jeweilige Objekt beschreibt. Diese Kennzahl wird mit dem Sollwert verglichen, um ein Verhältnis wie oben beschrieben zu erhalten. In der API-Version von <code>autoscaling/v2beta2</code> kann dieser Wert optional durch die Anzahl der Pods geteilt werden, bevor der Vergleich durchgeführt wird.</p></li></ul><p>Der HorizontalPodAutoscaler holt Metriken normalerweise aus einer Reihe von aggregierten APIs (<code>metrics.k8s.io</code>, <code>custom.metrics.k8s.io</code> und <code>external.metrics.k8s.io</code>). Die API <code>metrics.k8s.io</code> wird normalerweise vom Metrics Server bereitgestellt, der separat gestartet werden muss. Siehe <a href=/docs/tasks/debug-application-cluster/resource-metrics-pipeline/#metrics-server>Metrics Server</a> für weitere Anweisungen. Der HorizontalPodAutoscaler kann auch Metriken direkt aus dem Heapster beziehen.</p><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.11 [deprecated]</code></div><p>Das Verwenden von Metriken aus Heapster ist seit der Kubernetes Version 1.11 veraltet.</div><p>Siehe <a href=#unterst%C3%BCtzung-der-metrik-apis>Unterstützung der Metrik APIs</a> für weitere Details.</p><p>Der Autoscaler greift über die Scale Sub-Ressource auf die entsprechenden skalierbaren Controller (z.B. Replication Controller, Deployments und Replika Sets) zu. Scale ist eine Schnittstelle, mit der Sie die Anzahl der Replikate dynamisch einstellen und jeden ihrer aktuellen Zustände untersuchen können. Weitere Details zu der Scale Sub-Ressource findest du <a href=https://git.k8s.io/design-proposals-archive/autoscaling/horizontal-pod-autoscaler.md#scale-subresource>hier</a>.</p><h3 id=details-zum-algorithmus>Details zum Algorithmus</h3><p>Vereinfacht gesagt arbeitet der Horizontal Pod Autoscaler Controller mit dem Verhältnis zwischen dem gewünschten metrischen Wert und dem aktuellen metrischen Wert:</p><pre tabindex=0><code>desiredReplicas = ceil[currentReplicas * ( currentMetricValue / desiredMetricValue )]
</code></pre><p>Wenn beispielsweise der aktuelle metrische Wert <code>200m</code> und der gewünschte Wert <code>100m</code> ist, wird die Anzahl der Replikate verdoppelt, da <code>200.0 / 100.0 == 2.0</code> ist. Wenn der aktuelle Wert jedoch <code>50m</code> ist, halbieren sich die Anzahl der Replikate <code>50.0 / 100.0 == 0.5</code>. Es wird auf die Skalierung verzichtet, wenn das Verhältnis ausreichend nahe bei 1,0 liegt (innerhalb einer global konfigurierbaren Toleranz, vom Flag <code>--horizontal-pod-autoscaler-tolerance</code>, das standardmäßig auf 0,1 gesetzt ist).</p><p>Wenn ein <code>targetAverageValue</code> oder <code>targetAverageUtilization</code> angegeben wird, wird der <code>currentMetricValue</code> berechnet, indem der Mittelwert der gegebenen Metrik über alle Pods im Skalierungsziel des HorizontalPodAutoscaler berechnet wird. Vor der Überprüfung der Toleranz und der Entscheidung über die finalen Werte berücksichtigen wir jedoch die Pod Readiness und fehlende Metriken.</p><p>Alle Pods mit einem gesetzten Zeitstempel zur Löschung (d.h. Pods, die gerade heruntergefahren werden) und alle ausgefallenen Pods werden verworfen.</p><p>Wenn einem bestimmten Pod Metriken fehlen, wird es für später zurückgestellt; Pods mit fehlenden Metriken werden verwendet, um den endgültigen Skalierungsmenge anzupassen.</p><p>Wenn bei der Skalierung anhand der CPU ein Pod noch nicht bereit ist (d.h. er wird noch initialisiert) <em>oder</em> der letzte metrische Punkt für den Pod vor dessen Einsatzbereitschaft liegt, wird auch dieser Pod zurückgestellt.</p><p>Aufgrund technischer Einschränkungen kann der HorizontalPodAutoscaler Controller nicht genau bestimmen, wann ein Pod zum ersten Mal bereit ist, wenn es darum geht, bestimmte CPU Metriken festzulegen. Stattdessen betrachtet er eine Pod als "not yet ready", wenn dieser noch nicht bereit ist und geht in "unready" über, innerhalb eines kurzen, konfigurierbaren Zeitfensters seit dem Start.
Dieser Wert wird mit dem Flag <code>--horizontal-pod-autoscaler-initial-readiness-delay</code> konfiguriert und ist standardmäßig auf 30 Sekunden eingestellt. Sobald ein Pod bereit ist, betrachtet er jeden Übergang zu Bereit als den ersten, wenn dies innerhalb einer längeren, konfigurierbaren Zeit seit seinem Start erfolgt ist. Dieser Wert wird mit dem Flag <code>--horizontal-pod-autoscaler-cpu-initialization-period</code> gesetzt und dessen Standardwert beträgt 5 Minuten.</p><p>Das Basisskalenverhältnis <code>currentMetricValue / desiredMetricValue</code> wird dann mit den restlichen Pods berechnet, die nicht zurückgestellt oder von den oben genannten Kriterien entsorgt wurden.</p><p>Wenn es irgendwelche fehlenden Metriken gab, berechnen wir den Durchschnitt konservativer, vorausgesetzt, dass die Pods 100% des gewünschten Wertes bei der Verringerung und 0% bei einer Vergrößerung verbrauchten. Dadurch wird die Dimension einer beliebigen potenziellen Skalierung verringert.</p><p>Wenn außerdem noch nicht bereite Pods vorhanden sind und es ohne Berücksichtigung fehlender Metriken oder noch nicht bereiter Pods skaliert wurde, wird konservativ davon ausgegangen, dass die noch nicht bereiten Pods 0% der gewünschten Metrik verbrauchen, was die Dimension einer Skalierung weiter dämpft.</p><p>Nach Berücksichtigung der noch nicht bereiten Pods und fehlender Metriken wird der Nutzungsgrad neu berechnet. Wenn das neue Verhältnis die Skalierungsrichtung umkehrt oder innerhalb der Toleranz liegt, wird das weitere Skalieren übersprungen. Andernfalls wird das neue Verhältnis zur Skalierung verwendet.</p><p>Beachte, dass der <em>ursprüngliche</em> Wert für die durchschnittliche Auslastung über den HorizontalPodAutoscaler Status zurückgemeldet wird, ohne die noch nicht bereiten Pods oder fehlende Metriken zu berücksichtigen, selbst wenn das neue Nutzungsverhältnis verwendet wird.</p><p>Wenn mehrere Metriken in einem HorizontalPodAutoscaler angegeben sind, wird die Berechnung für jede Metrik durchgeführt, und dann wird die größte der gewünschten Replikanzahl ausgewählt. Wenn eine dieser Metriken nicht in eine gewünschte Replikanzahl umgewandelt werden kann (z.B. aufgrund eines Fehlers beim Abrufen der Metriken aus den Metrik APIs), wird diese Skalierung übersprungen.</p><p>Schließlich, kurz bevor HPA das Ziel skaliert, wird die Skalierungsempfehlung aufgezeichnet. Der Controller berücksichtigt alle Empfehlungen innerhalb eines konfigurierbaren Fensters und wählt aus diesem Fenster die höchste Empfehlung aus. Dieser Wert kann mit dem Flag <code>--horizontal-pod-autoscaler-downscale-stabilization</code> konfiguriert werden, das standardmäßig auf 5 Minuten eingestellt ist. Dies bedeutet, dass die Skalierung schrittweise erfolgt, wodurch die Auswirkungen schnell schwankender metrischer Werte ausgeglichen werden.</p><h2 id=api-objekt>API Objekt</h2><p>Der Horizontal Pod Autoscaler ist eine API Ressource in der Kubernetes <code>autoscaling</code> API Gruppe.
Die aktuelle stabile Version, die nur die Unterstützung für die automatische Skalierung der CPU beinhaltet, befindet sich in der <code>autoscaling/v1</code> API Version.</p><p>Die Beta-Version, welche die Skalierung des Speichers und benutzerdefinierte Metriken unterstützt, befindet sich unter <code>autoscaling/v2beta2</code>. Die in <code>autoscaling/v2beta2</code> neu eingeführten Felder bleiben bei der Arbeit mit <code>autoscaling/v1</code> als Anmerkungen erhalten.</p><p>Weitere Details über das API Objekt kann unter dem <a href=https://git.k8s.io/design-proposals-archive/autoscaling/horizontal-pod-autoscaler.md#horizontalpodautoscaler-object>HorizontalPodAutoscaler Objekt</a> gefunden werden.</p><h2 id=unterstützung-des-horizontal-pod-autoscaler-in-kubectl>Unterstützung des Horizontal Pod Autoscaler in kubectl</h2><p>Der Horizontal Pod Autoscaler wird, wie jede API-Ressource, standardmäßig von <code>kubectl</code> unterstützt.
Ein neuer Autoskalierer kann mit dem Befehl <code>kubectl create</code> erstellt werden.
Das auflisten der Autoskalierer geschieht über <code>kubectl get hpa</code> und eine detaillierte Beschreibung erhält man mit <code>kubectl describe hpa</code>.
Letzendlich können wir einen Autoskalierer mit <code>kubectl delete hpa</code> löschen.</p><p>Zusätzlich gibt es einen speziellen Befehl <code>kubectl autoscale</code> zur einfachen Erstellung eines Horizontal Pod Autoscalers.
Wenn du beispielsweise <code>kubectl autoscale rs foo --min=2 --max=5 --cpu-percent=80</code> ausführst, wird ein Autoskalierer für den ReplicaSet <em>foo</em> erstellt, wobei die Ziel-CPU-Auslastung auf <code>80%</code> und die Anzahl der Replikate zwischen 2 und 5 gesetzt wird.
Die Detaildokumentation von <code>kubectl autoscale</code> kann <a href=/docs/reference/generated/kubectl/kubectl-commands/#autoscale>hier</a> gefunden werden.</p><h2 id=autoskalieren-während-rollierender-updates>Autoskalieren während rollierender Updates</h2><p>Derzeit ist es in Kubernetes möglich, ein <a href=/docs/tasks/run-application/rolling-update-replication-controller/>rollierendes Update</a> durchzuführen, indem du den Replikationscontroller direkt verwaltest oder das Deployment Objekt verwendest, das die zugrunde liegenden Replica Sets für dich verwaltet.
Der Horizontal Pod Autoscaler unterstützt nur den letztgenannten Ansatz: Der Horizontal Pod Autoscaler ist an das Deployment Objekt gebunden, er legt die Größe für das Deployment Objekt fest, und das Deployment ist für die Festlegung der Größen der zugrunde liegenden Replica Sets verantwortlich.</p><p>Der Horizontal Pod Autoscaler funktioniert nicht mit rollierendem Update durch direkte Manipulation vom Replikationscontrollern, d.h. du kannst einen Horizontal Pod Autoscaler nicht an einen Replikationscontroller binden und rollierend aktualisieren (z.B. mit <code>kubectl rolling-update</code>).
Der Grund dafür ist, dass beim Erstellen eines neuen Replikationscontrollers durch ein rollierendes Update der Horizontal Pod Autoscaler nicht an den neue Replikationscontroller gebunden wird.</p><h2 id=unterstützung-von-abklingzeiten-verzögerungen>Unterstützung von Abklingzeiten/Verzögerungen</h2><p>Bei der Verwaltung der Größe einer Gruppe von Replikaten mit dem Horizontal Pod Autoscaler ist es möglich, dass die Anzahl der Replikate aufgrund der Dynamik der ausgewerteten Metriken häufig schwankt. Dies wird manchmal als <em>thrashing</em>, zu deutsch <em>Flattern</em>, bezeichnet.</p><p>Ab v1.6 kann ein Cluster Operator dieses Problem mitigieren, indem er die globalen HPA Einstellungen anpasst, die als Flags für die Komponente <code>kube-controller-manager</code> dargelegt werden:</p><p>Ab v1.12 erübrigt ein neues Update des Algorithmus die Notwendigkeit der Verzögerung beim hochskalieren.</p><ul><li><code>--horizontal-pod-autoscaler-downscale-stabilization</code>: Der Wert für diese Option ist eine Dauer, die angibt, wie lange der Autoscaler warten muss, bis nach Abschluss des aktuellen Skalierungsvorgangs ein weiterer Downscale durchgeführt werden kann.
Der Standardwert ist 5 Minuten (<code>5m0s</code>).</li></ul><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Beim Abstimmen dieser Parameterwerte sollte sich ein Clusterbetreiber der möglichen Konsequenzen bewusst sein. Wenn der Wert für die Verzögerung (Abklingzeit) zu groß eingestellt ist, kann es zu Beschwerden kommen, dass der Horizontal Pod Autoscaler nicht auf Änderungen der Arbeitslast reagiert. Wenn der Verzögerungswert jedoch zu kurz eingestellt ist, kann es vorkommen, dass die Skalierung der eingestellten Replikate wie gewohnt weiter flattert.</div><h2 id=unterstützung-von-mehrere-metriken>Unterstützung von mehrere Metriken</h2><p>Kubernetes 1.6 bietet Unterstützung für die Skalierung basierend auf mehreren Metriken. Du kannst die API Version <code>autoscaling/v2beta2</code> verwenden, um mehrere Metriken für den Horizontal Pod Autoscaler zum Skalieren festzulegen. Anschließend wertet der Horizontal Pod Autoscaler Controller jede Metrik aus und schlägt eine neue Skalierung basierend auf diesen Metrik vor. Die größte der vorgeschlagenen Skalierung wird als neue Skalierung verwendet.</p><h2 id=unterstützung-von-benutzerdefinierte-metriken>Unterstützung von benutzerdefinierte Metriken</h2><div class="alert alert-info note callout" role=alert><strong>Hinweis:</strong> Kubernetes 1.2 bietet Alpha Unterstützung für die Skalierung basierend auf anwendungsspezifischen Metriken über speziellen Annotations. Die Unterstützung für diese Annotations wurde in Kubernetes 1.6 zugunsten der neuen autoskalierenden API entfernt. Während die alte Methode zum Sammeln von benutzerdefinierten Metriken weiterhin verfügbar ist, stehen diese Metriken dem Horizontal Pod Autoscaler nicht mehr zur Verfügung, ebenso wenig wie die früheren Annotations zur Angabe, welche benutzerdefinierten Metriken zur Skalierung vom Horizontal Pod Autoscaler Controller berücksichtigt werden sollen.</div><p>Kubernetes 1.6 bietet Unterstützung für die Verwendung benutzerdefinierter Metriken im Horizontal Pod Autoscaler.
Du kannst benutzerdefinierte Metriken für den Horizontal Pod Autoscaler hinzufügen, die in der <code>autoscaling/v2beta2</code> API verwendet werden.
Kubernetes fragt dann die neue API für die benutzerdefinierte Metriken ab, um die Werte der entsprechenden benutzerdefinierten Metriken zu erhalten.</p><p>Die Voraussetzungen hierfür werden im nachfolgenden Kapitel <a href=#unterst%C3%BCtzung-der-metrik-apis>Unterstützung für die Metrik APIs</a> geklärt.</p><h2 id=unterstützung-der-metrik-apis>Unterstützung der Metrik APIs</h2><p>Standardmäßig ruft der HorizontalPodAutoscaler Controller Metriken aus einer Reihe von APIs ab. Damit dieser auf die APIs zugreifen kann, muss der Cluster Administratoren sicherstellen, dass:</p><ul><li><p>Der <a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/>API Aggregations Layer</a> aktiviert ist.</p></li><li><p>Die entsprechenden APIs registriert sind:</p><ul><li><p>Für Ressourcenmetriken ist dies die API <code>metrics.k8s.io</code>, die im Allgemeinen von <a href=https://github.com/kubernetes-incubator/metrics-server>metrics-server</a> bereitgestellt wird.
Es kann als Cluster-Addon gestartet werden.</p></li><li><p>Für benutzerdefinierte Metriken ist dies die API <code>custom.metrics.k8s.io</code>. Diese wird vom "Adapter" API Servern bereitgestellt, welches von Anbietern von Metrik Lösungen beliefert wird.
Überprüfe dies mit deiner Metrik Pipeline oder der <a href=https://github.com/kubernetes/metrics/blob/master/IMPLEMENTATIONS.md#custom-metrics-api>Liste bekannter Lösungen</a>.
Falls du deinen eigenen schreiben möchtest hilft dir folgender <a href=https://github.com/kubernetes-incubator/custom-metrics-apiserver>boilerplate</a> um zu starten.</p></li><li><p>Für externe Metriken ist dies die <code>external.metrics.k8s.io</code> API. Es kann sein, dass dies durch den benutzerdefinierten Metrik Adapter bereitgestellt wird.</p></li></ul></li><li><p>Das Flag <code>--horizontal-pod-autoscaler-use-rest-clients</code> ist auf <code>true</code> oder ungesetzt. Wird dies auf <code>false</code> gesetzt wird die Heapster basierte Autoskalierung aktiviert, welche veraltet ist.</p></li></ul><h2 id=nächste-schritte>Nächste Schritte</h2><ul><li>Design Dokument <a href=https://git.k8s.io/design-proposals-archive/autoscaling/horizontal-pod-autoscaler.md>Horizontal Pod Autoscaling</a>.</li><li>kubectl autoscale Befehl: <a href=/docs/reference/generated/kubectl/kubectl-commands/#autoscale>kubectl autoscale</a>.</li><li>Verwenden des <a href=/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>Horizontal Pod Autoscaler</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ca3bc4e31dfe46d5044a3b93eb804ee9>6 - Jobs ausführen</h1><div class=lead>Führen Sie Jobs mit paralleler Verarbeitung aus.</div></div><div class=td-content style=page-break-before:always><h1 id=pg-b74b959f5a531003dd0653dfbfc2e88b>7 - Auf Anwendungen in einem Cluster zugreifen</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-f6a755efe831d24956501e4bcd49ff96>8 - Überwachung, Protokollierung und Fehlerbehebung</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-fd78dc15c135dedc24438431769d4d5b>9 - Kubernetes erweitern</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-d3c88a8663f58e9ec0bed73faff5b670>10 - TLS</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-40e9293a348cfa50147082afc09ff77f>11 - Föderation</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-ba58efa15c6d46f10e34d799be220965>12 - Cluster-Daemons verwalten</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-5266308e17490aeee8b018316bf47e03>13 - Service Catalog installieren</h1></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/de/docs/home/>Home</a>
<a class=text-white href=/de/blog/>Blog</a>
<a class=text-white href=/de/training/>Schulungen</a>
<a class=text-white href=/de/partners/>Partner</a>
<a class=text-white href=/de/community/>Community</a>
<a class=text-white href=/de/case-studies/>Fallstudien</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>