<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/setup/production-environment/tools/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/setup/production-environment/tools/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/setup/production-environment/tools/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/setup/production-environment/tools/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/setup/production-environment/tools/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/setup/production-environment/tools/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>배포 도구로 쿠버네티스 설치하기 | Kubernetes</title><meta property="og:title" content="배포 도구로 쿠버네티스 설치하기"><meta property="og:description" content="운영 수준의 컨테이너 오케스트레이션"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/setup/production-environment/tools/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="배포 도구로 쿠버네티스 설치하기"><meta itemprop=description content="운영 수준의 컨테이너 오케스트레이션"><meta name=twitter:card content="summary"><meta name=twitter:title content="배포 도구로 쿠버네티스 설치하기"><meta name=twitter:description content="운영 수준의 컨테이너 오케스트레이션"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ko/docs/setup/production-environment/tools/"><meta property="og:title" content="배포 도구로 쿠버네티스 설치하기"><meta name=twitter:title content="배포 도구로 쿠버네티스 설치하기"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/setup/production-environment/tools/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/setup/production-environment/tools/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/setup/production-environment/tools/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/setup/production-environment/tools/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/setup/production-environment/tools/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/setup/production-environment/tools/>English</a>
<a class=dropdown-item href=/zh-cn/docs/setup/production-environment/tools/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/setup/production-environment/tools/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/setup/production-environment/tools/>Français (French)</a>
<a class=dropdown-item href=/id/docs/setup/production-environment/tools/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/setup/production-environment/tools/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/setup/production-environment/tools/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>배포 도구로 쿠버네티스 설치하기</h1><ul><li>1: <a href=#pg-a16f59f325a17cdeed324d5c889f7f73>kubeadm으로 클러스터 구성하기</a></li><ul><li>1.1: <a href=#pg-29e59491dd6118b23072dfe9ebb93323>kubeadm 설치하기</a></li><li>1.2: <a href=#pg-4c656c5eda3e1c06ad1aedebdc04a211>kubeadm API로 컴포넌트 사용자 정의하기</a></li><li>1.3: <a href=#pg-015edbc7cc688d31b1d1edce7c186135>고가용성 토폴로지 선택</a></li></ul><li>2: <a href=#pg-478acca1934b6d89a0bc00fb25bfe5b6>Kops로 쿠버네티스 설치하기</a></li><li>3: <a href=#pg-f8b4964187fe973644e06ee629eff1de>Kubespray로 쿠버네티스 설치하기</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-a16f59f325a17cdeed324d5c889f7f73>1 - kubeadm으로 클러스터 구성하기</h1></div><div class=td-content><h1 id=pg-29e59491dd6118b23072dfe9ebb93323>1.1 - kubeadm 설치하기</h1><p><img src=/images/kubeadm-stacked-color.png align=right width=150px></img>
이 페이지에서는 <code>kubeadm</code> 툴박스 설치 방법을 보여준다.
이 설치 프로세스를 수행한 후 kubeadm으로 클러스터를 만드는 방법에 대한 자세한 내용은 <a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadm으로 클러스터 생성하기</a> 페이지를 참고한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li>호환되는 리눅스 머신. 쿠버네티스 프로젝트는 데비안 기반 배포판, 레드햇 기반 배포판, 그리고 패키지 매니저를 사용하지 않는 경우에 대한 일반적인 가이드를 제공한다.</li><li>2 GB 이상의 램을 장착한 머신. (이 보다 작으면 사용자의 앱을 위한 공간이 거의 남지 않음)</li><li>2 이상의 CPU.</li><li>클러스터의 모든 머신에 걸친 전체 네트워크 연결. (공용 또는 사설 네트워크면 괜찮음)</li><li>모든 노드에 대해 고유한 호스트 이름, MAC 주소 및 product_uuid. 자세한 내용은 <a href=#verify-mac-address>여기</a>를 참고한다.</li><li>컴퓨터의 특정 포트들 개방. 자세한 내용은 <a href=#check-required-ports>여기</a>를 참고한다.</li><li>스왑의 비활성화. kubelet이 제대로 작동하게 하려면 <strong>반드시</strong> 스왑을 사용하지 않도록 설정한다.</li></ul><h2 id=verify-mac-address>MAC 주소 및 product_uuid가 모든 노드에 대해 고유한지 확인</h2><ul><li>사용자는 <code>ip link</code> 또는 <code>ifconfig -a</code> 명령을 사용하여 네트워크 인터페이스의 MAC 주소를 확인할 수 있다.</li><li>product_uuid는 <code>sudo cat /sys/class/dmi/id/product_uuid</code> 명령을 사용하여 확인할 수 있다.</li></ul><p>일부 가상 머신은 동일한 값을 가질 수 있지만 하드웨어 장치는 고유한 주소를 가질
가능성이 높다. 쿠버네티스는 이러한 값을 사용하여 클러스터의 노드를 고유하게 식별한다.
이러한 값이 각 노드에 고유하지 않으면 설치 프로세스가
<a href=https://github.com/kubernetes/kubeadm/issues/31>실패</a>할 수 있다.</p><h2 id=네트워크-어댑터-확인>네트워크 어댑터 확인</h2><p>네트워크 어댑터가 두 개 이상이고, 쿠버네티스 컴포넌트가 디폴트 라우트(default route)에서 도달할 수 없는
경우, 쿠버네티스 클러스터 주소가 적절한 어댑터를 통해 이동하도록 IP 경로를 추가하는 것이 좋다.</p><h2 id=check-required-ports>필수 포트 확인</h2><p><a href=/ko/docs/reference/ports-and-protocols/>필수 포트들</a>은
쿠버네티스 컴포넌트들이 서로 통신하기 위해서 열려 있어야
한다. 다음과 같이 netcat과 같은 도구를 이용하여 포트가 열려 있는지 확인해 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>nc 127.0.0.1 <span style=color:#666>6443</span>
</span></span></code></pre></div><p>사용자가 사용하는 파드 네트워크 플러그인은 특정 포트를 열어야 할 수도
있다. 이것은 각 파드 네트워크 플러그인마다 다르므로, 필요한 포트에 대한
플러그인 문서를 참고한다.</p><h2 id=installing-runtime>컨테이너 런타임 설치</h2><p>파드에서 컨테이너를 실행하기 위해, 쿠버네티스는
<a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>을 사용한다.</p><p>기본적으로, 쿠버네티스는
<a class=glossary-tooltip title='Kubelet과 컨테이너 런타임을 통합시키기 위한 API' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%9f%b0%ed%83%80%ec%9e%84 target=_blank aria-label='컨테이너 런타임 인터페이스'>컨테이너 런타임 인터페이스</a>(CRI)를
사용하여 사용자가 선택한 컨테이너 런타임과 인터페이스한다.</p><p>런타임을 지정하지 않으면, kubeadm은 잘 알려진 엔드포인트를 스캐닝하여
설치된 컨테이너 런타임을 자동으로 감지하려고 한다.</p><p>컨테이너 런타임이 여러 개 감지되거나 하나도 감지되지 않은 경우,
kubeadm은 에러를 반환하고 사용자가 어떤 것을 사용할지를 명시하도록 요청할 것이다.</p><p>더 많은 정보는
<a href=/ko/docs/setup/production-environment/container-runtimes/>컨테이너 런타임</a>을 참고한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 도커 엔진은 컨테이너 런타임이 쿠버네티스와 호환되기 위한 요구 사항인
<a href=/ko/docs/concepts/architecture/cri/>CRI</a>를 만족하지 않는다.
이러한 이유로, 추가 서비스인 <a href=https://github.com/Mirantis/cri-dockerd>cri-dockerd</a>가 설치되어야 한다.
cri-dockerd는 쿠버네티스 버전 1.24부터 kubelet에서 <a href=/dockershim/>제거</a>된
기존 내장 도커 엔진 지원을 기반으로 한 프로젝트이다.</div><p>아래 표는 지원 운영 체제에 대한 알려진 엔드포인트를 담고 있다.</p><ul class="nav nav-tabs" id=container-runtime role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#container-runtime-0 role=tab aria-controls=container-runtime-0 aria-selected=true>리눅스</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#container-runtime-1 role=tab aria-controls=container-runtime-1>윈도우</a></li></ul><div class=tab-content id=container-runtime><div id=container-runtime-0 class="tab-pane show active" role=tabpanel aria-labelledby=container-runtime-0><p><table><caption style=display:none>리눅스 컨테이너 런타임</caption><thead><tr><th>런타임</th><th>유닉스 도메인 소켓 경로</th></tr></thead><tbody><tr><td>containerd</td><td><code>unix:///var/run/containerd/containerd.sock</code></td></tr><tr><td>CRI-O</td><td><code>unix:///var/run/crio/crio.sock</code></td></tr><tr><td>도커 엔진 (cri-dockerd 사용)</td><td><code>unix:///var/run/cri-dockerd.sock</code></td></tr></tbody></table></div><div id=container-runtime-1 class=tab-pane role=tabpanel aria-labelledby=container-runtime-1><p><table><caption style=display:none>윈도우 컨테이너 런타임</caption><thead><tr><th>런타임</th><th>윈도우 네임드 파이프(named pipe) 경로</th></tr></thead><tbody><tr><td>containerd</td><td><code>npipe:////./pipe/containerd-containerd</code></td></tr><tr><td>도커 엔진 (cri-dockerd 사용)</td><td><code>npipe:////./pipe/cri-dockerd</code></td></tr></tbody></table></div></div><h2 id=kubeadm-kubelet-및-kubectl-설치>kubeadm, kubelet 및 kubectl 설치</h2><p>모든 머신에 다음 패키지들을 설치한다.</p><ul><li><p><code>kubeadm</code>: 클러스터를 부트스트랩하는 명령이다.</p></li><li><p><code>kubelet</code>: 클러스터의 모든 머신에서 실행되는 파드와 컨테이너 시작과
같은 작업을 수행하는 컴포넌트이다.</p></li><li><p><code>kubectl</code>: 클러스터와 통신하기 위한 커맨드 라인 유틸리티이다.</p></li></ul><p>kubeadm은 <code>kubelet</code> 또는 <code>kubectl</code> 을 설치하거나 관리하지 <strong>않으므로</strong>, kubeadm이
설치하려는 쿠버네티스 컨트롤 플레인의 버전과 일치하는지
확인해야 한다. 그렇지 않으면, 예상치 못한 버그 동작으로 이어질 수 있는
버전 차이(skew)가 발생할 위험이 있다. 그러나, kubelet과 컨트롤 플레인 사이에 <em>하나의</em>
마이너 버전 차이가 지원되지만, kubelet 버전은 API 서버 버전 보다
높을 수 없다. 예를 들어, 1.7.0 버전의 kubelet은 1.8.0 API 서버와 완전히 호환되어야 하지만,
그 반대의 경우는 아니다.</p><p><code>kubectl</code> 설치에 대한 정보는 <a href=/ko/docs/tasks/tools/>kubectl 설치 및 설정</a>을 참고한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 이 지침은 모든 시스템 업그레이드에서 모든 쿠버네티스 패키지를 제외한다.
이는 kubeadm 및 쿠버네티스를
<a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>업그레이드 하는 데 특별한 주의</a>가 필요하기 때문이다.</div><p>버전 차이에 대한 자세한 내용은 다음을 참고한다.</p><ul><li>쿠버네티스 <a href=/ko/releases/version-skew-policy/>버전 및 버전-차이 정책</a></li><li>Kubeadm 관련 <a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#version-skew-policy>버전 차이 정책</a></li></ul><ul class="nav nav-tabs" id=k8s-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-0 role=tab aria-controls=k8s-install-0 aria-selected=true>데비안 기반 배포판</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-1 role=tab aria-controls=k8s-install-1>레드햇 기반 배포판</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-2 role=tab aria-controls=k8s-install-2>패키지 매니저를 사용하지 않는 경우</a></li></ul><div class=tab-content id=k8s-install><div id=k8s-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-0><p><ol><li><p><code>apt</code> 패키지 색인을 업데이트하고, 쿠버네티스 <code>apt</code> 리포지터리를 사용하는 데 필요한 패키지를 설치한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y apt-transport-https ca-certificates curl
</span></span></code></pre></div></li><li><p>구글 클라우드의 공개 사이닝 키를 다운로드 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
</span></span></code></pre></div></li><li><p>쿠버네티스 <code>apt</code> 리포지터리를 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&#34;</span> | sudo tee /etc/apt/sources.list.d/kubernetes.list
</span></span></code></pre></div></li><li><p><code>apt</code> 패키지 색인을 업데이트하고, kubelet, kubeadm, kubectl을 설치하고 해당 버전을 고정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y kubelet kubeadm kubectl
</span></span><span style=display:flex><span>sudo apt-mark hold kubelet kubeadm kubectl
</span></span></code></pre></div></li></ol></div><div id=k8s-install-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
</span></span></span><span style=display:flex><span><span style=color:#b44>[kubernetes]
</span></span></span><span style=display:flex><span><span style=color:#b44>name=Kubernetes
</span></span></span><span style=display:flex><span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch
</span></span></span><span style=display:flex><span><span style=color:#b44>enabled=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span></span></span><span style=display:flex><span><span style=color:#b44>exclude=kubelet kubeadm kubectl
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># permissive 모드로 SELinux 설정(효과적으로 비활성화)</span>
</span></span><span style=display:flex><span>sudo setenforce <span style=color:#666>0</span>
</span></span><span style=display:flex><span>sudo sed -i <span style=color:#b44>&#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39;</span> /etc/selinux/config
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo yum install -y kubelet kubeadm kubectl --disableexcludes<span style=color:#666>=</span>kubernetes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo systemctl <span style=color:#a2f>enable</span> --now kubelet
</span></span></code></pre></div><p><strong>참고:</strong></p><ul><li><p><code>setenforce 0</code> 및 <code>sed ...</code> 를 실행하여 permissive 모드로 SELinux를 설정하면 효과적으로 비활성화된다.
컨테이너가 호스트 파일시스템(예를 들어, 파드 네트워크에 필요한)에 접근하도록 허용하는 데 필요하다.
kubelet에서 SELinux 지원이 개선될 때까지 이 작업을 수행해야 한다.</p></li><li><p>구성 방법을 알고 있는 경우 SELinux를 활성화된 상태로 둘 수 있지만 kubeadm에서 지원하지 않는 설정이 필요할 수 있다.</p></li><li><p>사용 중인 레드햇 배포판이 <code>basearch</code>를 해석하지 못하여 <code>baseurl</code>이 실패하면, <code>\$basearch</code>를 당신의 컴퓨터의 아키텍처로 치환한다.
<code>uname -m</code> 명령을 실행하여 해당 값을 확인한다.
예를 들어, <code>x86_64</code>에 대한 <code>baseurl</code> URL은 <code>https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</code> 이다.</p></li></ul></div><div id=k8s-install-2 class=tab-pane role=tabpanel aria-labelledby=k8s-install-2><p><p>CNI 플러그인 설치(대부분의 파드 네트워크에 필요)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>CNI_PLUGINS_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v1.1.1&#34;</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>DEST</span><span style=color:#666>=</span><span style=color:#b44>&#34;/opt/cni/bin&#34;</span>
</span></span><span style=display:flex><span>sudo mkdir -p <span style=color:#b44>&#34;</span><span style=color:#b8860b>$DEST</span><span style=color:#b44>&#34;</span>
</span></span><span style=display:flex><span>curl -L <span style=color:#b44>&#34;https://github.com/containernetworking/plugins/releases/download/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CNI_PLUGINS_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cni-plugins-linux-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CNI_PLUGINS_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>.tgz&#34;</span> | sudo tar -C <span style=color:#b44>&#34;</span><span style=color:#b8860b>$DEST</span><span style=color:#b44>&#34;</span> -xz
</span></span></code></pre></div><p>명령어 파일을 다운로드할 디렉터리 정의</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>DOWNLOAD_DIR</code> 변수는 쓰기 가능한 디렉터리로 설정되어야 한다.
Flatcar Container Linux를 실행 중인 경우, <code>DOWNLOAD_DIR="/opt/bin"</code> 을 설정한다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>DOWNLOAD_DIR</span><span style=color:#666>=</span><span style=color:#b44>&#34;/usr/local/bin&#34;</span>
</span></span><span style=display:flex><span>sudo mkdir -p <span style=color:#b44>&#34;</span><span style=color:#b8860b>$DOWNLOAD_DIR</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><p>crictl 설치(kubeadm / Kubelet 컨테이너 런타임 인터페이스(CRI)에 필요)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v1.25.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
</span></span><span style=display:flex><span>curl -L <span style=color:#b44>&#34;https://github.com/kubernetes-sigs/cri-tools/releases/download/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/crictl-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>-linux-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>.tar.gz&#34;</span> | sudo tar -C <span style=color:#b8860b>$DOWNLOAD_DIR</span> -xz
</span></span></code></pre></div><p><code>kubeadm</code>, <code>kubelet</code>, <code>kubectl</code> 설치 및 <code>kubelet</code> systemd 서비스 추가</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>RELEASE</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>curl -sSL https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> <span style=color:#b8860b>$DOWNLOAD_DIR</span>
</span></span><span style=display:flex><span>sudo curl -L --remote-name-all https://storage.googleapis.com/kubernetes-release/release/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE</span><span style=color:#b68;font-weight:700>}</span>/bin/linux/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span>/<span style=color:#666>{</span>kubeadm,kubelet,kubectl<span style=color:#666>}</span>
</span></span><span style=display:flex><span>sudo chmod +x <span style=color:#666>{</span>kubeadm,kubelet,kubectl<span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v0.4.0&#34;</span>
</span></span><span style=display:flex><span>curl -sSL <span style=color:#b44>&#34;https://raw.githubusercontent.com/kubernetes/release/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cmd/kubepkg/templates/latest/deb/kubelet/lib/systemd/system/kubelet.service&#34;</span> | sed <span style=color:#b44>&#34;s:/usr/bin:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>DOWNLOAD_DIR</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>:g&#34;</span> | sudo tee /etc/systemd/system/kubelet.service
</span></span><span style=display:flex><span>sudo mkdir -p /etc/systemd/system/kubelet.service.d
</span></span><span style=display:flex><span>curl -sSL <span style=color:#b44>&#34;https://raw.githubusercontent.com/kubernetes/release/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cmd/kubepkg/templates/latest/deb/kubeadm/10-kubeadm.conf&#34;</span> | sed <span style=color:#b44>&#34;s:/usr/bin:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>DOWNLOAD_DIR</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>:g&#34;</span> | sudo tee /etc/systemd/system/kubelet.service.d/10-kubeadm.conf
</span></span></code></pre></div><p><code>kubelet</code> 활성화 및 시작</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>systemctl <span style=color:#a2f>enable</span> --now kubelet
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> Flatcar Container Linux 배포판은 <code>/usr</code> 디렉터리를 읽기 전용 파일시스템으로 마운트한다.
클러스터를 부트스트랩하기 전에, 쓰기 가능한 디렉터리를 구성하기 위한 추가 단계를 수행해야 한다.
쓰기 가능한 디렉터리를 설정하는 방법을 알아 보려면 <a href=/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#usr-mounted-read-only/>Kubeadm 문제 해결 가이드</a>를 참고한다.</div></div></div><p>kubelet은 이제 kubeadm이 수행할 작업을 알려 줄 때까지 크래시루프(crashloop) 상태로
기다려야 하므로 몇 초마다 다시 시작된다.</p><h2 id=cgroup-드라이버-구성>cgroup 드라이버 구성</h2><p>컨테이너 런타임과 kubelet은
<a href=/ko/docs/setup/production-environment/container-runtimes/>"cgroup 드라이버"</a>라는 속성을 갖고 있으며,
cgroup 드라이버는 리눅스 머신의 cgroup 관리 측면에 있어서 중요하다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong><p>컨테이너 런타임과 kubelet의 cgroup 드라이버를 일치시켜야 하며, 그렇지 않으면 kubelet 프로세스에 오류가 발생한다.</p><p>더 자세한 사항은 <a href=/docs/tasks/administer-cluster/kubeadm/configure-cgroup-driver/>cgroup 드라이버 설정하기</a>를 참고한다.</p></div><h2 id=문제-해결>문제 해결</h2><p>kubeadm에 문제가 있는 경우, <a href=/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/>문제 해결 문서</a>를 참고한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadm을 사용하여 클러스터 생성</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4c656c5eda3e1c06ad1aedebdc04a211>1.2 - kubeadm API로 컴포넌트 사용자 정의하기</h1><p>이 페이지는 kubeadm이 배포하는 컴포넌트(component)들을 사용자 정의하는 방법을 다룬다. 컨트롤 플레인 컴포넌트에
대해서는 <code>Cluster Configuration</code> 구조에서 플래그를 사용하거나 노드당 패치를 사용할 수 있다. kubelet과
kube-proxy의 경우, <code>KubeletConfiguration</code>과 <code>KubeProxyConfiguration</code>을 각각 사용할 수 있다.</p><p>이 모든 옵션이 kubeadm 구성 API를 통해 가용하다.
구성의 각 필드 상세 사항은
<a href=/docs/reference/config-api/kubeadm-config.v1beta3/>API 참조 페이지</a>에서 찾아볼 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> kubeadm의 CoreDNS 디플로이먼트 사용자 정의는 현재 제공되지 않는다.
<code>kube-system/coredns</code> <a class=glossary-tooltip title='키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>을 수동으로
패치하고, 그 이후에 CoreDNS <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 다시 생성해야 한다. 또는,
기본 CoreDNS 디플로이먼트를 생략하고 자체 변형(variant)을 배포할 수 있다.
더 자세한 사항은 <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-phases>kubeadm에서 초기화 단계 사용하기</a>을 참고한다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이미 생성된 클러스터를 다시 구성하려면
<a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-reconfigure/>kubeadm 클러스터 다시 구성하기</a>를 참고한다.</div><h2 id=clusterconfiguration-의-플래그로-컨트롤-플레인-사용자-정의하기><code>ClusterConfiguration</code>의 플래그로 컨트롤 플레인 사용자 정의하기</h2><p>kubeadm의 <code>ClusterConfiguration</code> 오브젝트는 API 서버, 컨트롤러매니저, 스케줄러, Etcd와 같은 컨트롤 플레인 컴포넌트에 전달되는
기본 플래그를 사용자가 덮어쓸 수 있도록 노출한다.
이 컴포넌트는 다음 구조체를 사용하여 정의된다.</p><ul><li><code>apiServer</code></li><li><code>controllerManager</code></li><li><code>scheduler</code></li><li><code>etcd</code></li></ul><p>이 구조체들은 공통 필드인 <code>extraArgs</code>를 포함하며, 이 필드는 <code>키: 값</code> 쌍으로 구성된다.
컨트롤 플레인 컴포넌트를 위한 플래그를 덮어쓰려면 다음을 수행한다.</p><ol><li>사용자 구성에 적절한 <code>extraArgs</code> 필드를 추가한다.</li><li><code>extraArgs</code> 필드에 플래그를 추가한다.</li><li><code>kubeadm init</code>에 <code>--config &lt;CONFIG YAML 파일></code> 파라미터를 추가해서 실행한다.</li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubeadm config print init-defaults</code>를 실행하고 원하는 파일에 출력을
저장하여 기본값들로 구성된 <code>ClusterConfiguration</code> 오브젝트를 생성할 수 있다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>ClusterConfiguration</code> 오브젝트는 현재 kubeadm 클러스터에서 전역(global)으로 사용된다. 즉, 사용자가 추가하는 모든 플래그는
다른 노드에 있는 동일한 컴포넌트에도 모두 적용될 것이다. 다른 노드에서
컴포넌트별로 개별 구성을 적용하려면 <a href=#patches>패치</a>를 사용하면 된다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 플래그(키)를 복제하거나 동일한 플래그 <code>--foo</code>를 여러 번 전달하는 것은 현재 지원하지 않는다.
이 문제를 해결하려면 <a href=#patches>패치</a>를 사용해야 한다.</div><h3 id=apiserver-플래그>APIServer 플래그</h3><p>자세한 내용은 <a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver 레퍼런스 문서</a>를 확인한다.</p><p>사용 예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span>v1.16.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiServer</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>anonymous-auth</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;false&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>enable-admission-plugins</span>:<span style=color:#bbb> </span>AlwaysPullImages,DefaultStorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>audit-log-path</span>:<span style=color:#bbb> </span>/home/johndoe/audit.log<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=컨트롤러매니저-플래그>컨트롤러매니저 플래그</h3><p>자세한 내용은 <a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager 레퍼런스 문서</a>를 확인한다.</p><p>사용 예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span>v1.16.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>controllerManager</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster-signing-key-file</span>:<span style=color:#bbb> </span>/home/johndoe/keys/ca.key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deployment-controller-sync-period</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=스케줄러-플래그>스케줄러 플래그</h3><p>자세한 내용은 <a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler 레퍼런스 문서</a>를 확인한다.</p><p>사용 예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span>v1.16.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>scheduler</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb> </span>/etc/kubernetes/scheduler-config.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraVolumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>schedulerconfig<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb> </span>/home/johndoe/schedconfig.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/scheduler-config.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;File&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=etcd-플래그>Etcd 플래그</h3><p>자세한 사항은 <a href=https://etcd.io/docs/>etcd 서버 문서</a>를 확인한다.</p><p>사용 예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>etcd</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>local</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>election-timeout</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=patches>패치를 통해 사용자 정의하기</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.22 [beta]</code></div><p>Kubeadm을 사용하면 패치 파일이 있는 디렉토리를 개별 노드에 대한 <code>InitConfiguration</code>과 <code>JoinConfiguration</code>에
전달할 수 있다. 이 패치는 컴포넌트 구성이 디스크에 기록되기 전에 최종 사용자 정의 단계로
사용될 수 있다.</p><p><code>--config &lt;YOUR CONFIG YAML></code>을 사용하여 이 파일을 <code>kubeadm init</code>에 전달할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>InitConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>patches</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>directory</span>:<span style=color:#bbb> </span>/home/user/somedir<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubeadm init</code>의 경우, <code>---</code>로 구분된 <code>ClusterConfiguration</code>과 <code>InitConfiguration</code>을 모두
포함하는 파일을 전달할 수 있다.</div><p><code>--config &lt;YOUR CONFIG YAML></code>을 사용하여 이 파일을 <code>kubeadm join</code>에 전달할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>JoinConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>patches</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>directory</span>:<span style=color:#bbb> </span>/home/user/somedir<span style=color:#bbb>
</span></span></span></code></pre></div><p>디렉토리는 <code>target[suffix][+patchtype].extension</code> 형태의 파일을 포함해야 한다.
예를 들면, <code>kube-apiserver0+merge.yaml</code> 또는 단순히 <code>etcd.json</code>의 형태이다.</p><ul><li><code>target</code>은 <code>kube-apiserver</code>, <code>kube-controller-manager</code>, <code>kube-scheduler</code>, <code>etcd</code>
그리고 <code>kubeletconfiguration</code> 중 하나가 될 수 있다.</li><li><code>patchtype</code>은 <code>strategic</code>, <code>merge</code> 그리고 <code>json</code> 중 하나가 될 수 있으며
<a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch>kubectl에서 지원하는</a> 패치 형식을 준수해야 한다.
<code>patchtype</code>의 기본값은 <code>strategic</code>이다.</li><li><code>extension</code>은 <code>json</code> 또는 <code>yaml</code> 중 하나여야 한다.</li><li><code>suffix</code>는 어떤 패치가 먼저 적용되는지를 결정하는 데 사용할 수 있는 영숫자 형태의
선택적 문자열이다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubeadm upgrade</code>를 사용하여 kubeadm 노드를 업그레이드하는 경우, 업그레이드 이후에도
사용자 정의를 유지하려면 동일한 패치를 다시 제공해야 한다. 이는 동일한 디렉토리로 지정된 <code>--patches</code>
플래그를 사용하여 처리할 수 있다. <code>kubeadm upgrade</code>는 동일 목적으로 재사용할 수 있는 구성
API 구조를 현재는 지원하지 않는다.</div><h2 id=kubelet>kubelet 사용자 정의하기</h2><p>kubelet을 사용자 정의하려면, <a href=/docs/reference/config-api/kubelet-config.v1beta1/><code>KubeletConfiguration</code></a>을
동일한 구성 파일 내에서 <code>---</code>로 구분된 <code>ClusterConfiguration</code>이나 <code>InitConfiguration</code> 다음에 추가하면 된다.
그런 다음 <code>kubeadm init</code>에 해당 파일을 전달하면, kubeadm은 동일한 기본 <code>KubeletConfiguration</code>을
클러스터의 모든 노드에 적용한다.</p><p>기본 <code>KubeletConfiguration</code>에 더하여 인스턴스별 구성을 적용하기 위해서는
<a href=#patches><code>kubeletconfiguration</code> 패치 target</a>을 이용할 수 있다.</p><p>다른 방법으로는, kubelet 플래그를 덮어쓰기(overrides)로 사용하여,
<code>InitConfiguration</code> 및 <code>JoinConfiguration</code> 모두에서 지원되는 <code>nodeRegistration.kubeletExtraArgs</code>에 전달할 수 있다.
일부 kubelet 플래그는 더 이상 사용되지 않는다(deprecated). 따라서 사용하기 전에
<a href=/docs/reference/command-line-tools-reference/kubelet>kubelet 참조 문서</a>를 통해 상태를 확인해야 한다.</p><p>이 외 더 자세한 사항은 <a href=/docs/setup/production-environment/tools/kubeadm/kubelet-integration>kubeadm을 통해 클러스터의 각 kubelet 구성하기</a>에서 살펴본다.</p><h2 id=kube-proxy-사용자-정의하기>kube-proxy 사용자 정의하기</h2><p>kube-proxy를 사용자 정의하려면, <code>KubeProxyConfiguration</code>을 <code>---</code>로 구분된 <code>ClusterConfiguration</code>이나 <code>InitConfiguration</code>
다음에 두고 <code>kubeadm init</code>에 전달하면 된다.</p><p>자세한 사항은 <a href=/docs/reference/config-api/kubeadm-config.v1beta3/>API 참조 페이지</a>에서 살펴볼 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> kubeadm은 kube-proxy를 <a class=glossary-tooltip title='파드의 복제본을 클러스터 노드 집합에서 동작하게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋>데몬셋</a>으로 배포한다. 이것은
<code>KubeProxyConfiguration</code>이 클러스터의 모든 kube-proxy 인스턴스에 적용된다는 것을 의미한다.</div></div><div class=td-content style=page-break-before:always><h1 id=pg-015edbc7cc688d31b1d1edce7c186135>1.3 - 고가용성 토폴로지 선택</h1><p>이 페이지는 고가용성(HA) 쿠버네티스 클러스터의 토플로지를 구성하는 두 가지 선택 사항을 설명한다.</p><p>다음과 같이 HA 클러스터를 구성할 수 있다.</p><ul><li>etcd 노드와 컨트롤 플레인 노드를 함께 위치시키는 중첩된(stacked) 컨트롤 플레인 노드 방식</li><li>etcd와 컨트롤 플레인이 분리된 노드에서 운영되는 외부 etcd 노드 방식</li></ul><p>HA 클러스터를 구성하기 전에 각 토플로지의 장단점을 주의 깊게 고려해야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> kubeadm은 etcd 클러스터를 정적으로 부트스트랩한다. 자세한 내용은 etcd <a href=https://github.com/etcd-io/etcd/blob/release-3.4/Documentation/op-guide/clustering.md#static>클러스터 구성 가이드</a>
를 읽는다.</div><h2 id=중첩된-etcd-토플로지>중첩된 etcd 토플로지</h2><p>중첩된 HA 클러스터는 etcd에서 제공하는 분산 데이터 저장소 클러스터를,
컨트롤 플레인 구성 요소를 실행하는 kubeadm으로 관리되는 노드에 의해서 형성된 클러스터 상단에
중첩하는 <a href=https://en.wikipedia.org/wiki/Network_topology>토플로지</a>이다.</p><p>각 컨트롤 플레인 노드는 <code>kube-apiserver</code>, <code>kube-scheduler</code>, <code>kube-controller-manager</code> 인스턴스를 운영한다.
<code>kube-apiserver</code>는 로드 밸런서를 이용하여 워커 노드에 노출되어 있다.</p><p>각 컨트롤 플레인 노드는 지역 etcd 맴버를 생성하고
이 etcd 맴버는 오직 해당 노드의 <code>kube-apiserver</code>와 통신한다.
비슷한 방식이 지역의 <code>kube-controller-manager</code>와 <code>kube-scheduler</code>에도 적용된다.</p><p>이 토플로지는 컨트롤 플레인과 etcd 맴버가 같은 노드에 묶여 있다.
이는 외부 etcd 노드의 클러스터를 구성하는 것보다는 단순하며 복제 관리도 간단하다.</p><p>그러나 중첩된 클러스터는 커플링에 실패할 위험이 있다. 한 노드가 다운되면 etcd 맴버와 컨트롤 플레인을 모두 잃어버리고,
중복성도 손상된다. 더 많은 컨트롤 플레인 노드를 추가하여 이 위험을 완화할 수 있다.</p><p>그러므로 HA 클러스터를 위해 최소 3개인 중첩된 컨트롤 플레인 노드를 운영해야 한다.</p><p>이는 kubeadm의 기본 토플로지이다. 지역 etcd 맴버는
<code>kubeadm init</code>와 <code>kubeadm join --control-plane</code> 을 이용할 때에 컨트롤 플레인 노드에 자동으로 생성된다.</p><p><img src=/images/kubeadm/kubeadm-ha-topology-stacked-etcd.svg alt="중첩된 etcd 토플로지"></p><h2 id=외부-etcd-토플로지>외부 etcd 토플로지</h2><p>외부 etcd를 이용하는 HA 클러스터는 etcd로 제공한 분산된 데이터 스토리지 클러스터가 컨트롤 플레인 구성 요소를 운영하는 노드로 형성하는 클러스터의 외부에 있는 <a href=https://en.wikipedia.org/wiki/Network_topology>토플로지</a>이다.</p><p>중첩된 etcd 토플로지와 유사하게, 외부 etcd 토플로지에 각 컨트롤 플레인 노드는 <code>kube-apiserver</code>, <code>kube-scheduler</code>, <code>kube-controller-manager</code>의 인스턴스를 운영한다. 그리고 <code>kube-apiserver</code>는 로드 밸런서를 이용하여 워커노드에 노출한다. 그러나 etcd 맴버는 분리된 호스트에서 운영되고, 각 etcd 호스트는 각 컨트롤 플레인 노드의 <code>kube-apiserver</code>와 통신한다.</p><p>이 토플로지는 컨트롤 플레인과 etcd 맴버를 분리한다. 이는 그러므로
컨트롤 플레인 인스턴스나 etcd 맴버를 잃는 충격이 덜하고,
클러스터 중복성에 있어 중첩된 HA 토플로지만큼 영향을 미치지 않는다.</p><p>그러나, 이 토플로지는 중첩된 토플로지에 비해 호스트 개수가 두배나 필요하다.
이 토플로지로 HA 클러스터를 구성하기 위해서는 최소한 3개의 컨트롤 플레인과 3개의 etcd 노드가 필요하다.</p><p><img src=/images/kubeadm/kubeadm-ha-topology-external-etcd.svg alt="외부 etcd 토플로지"></p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/setup/production-environment/tools/kubeadm/high-availability/>kubeadm을 이용하여 고가용성 클러스터 구성하기</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-478acca1934b6d89a0bc00fb25bfe5b6>2 - Kops로 쿠버네티스 설치하기</h1><p>이곳 빠른 시작에서는 사용자가 얼마나 쉽게 AWS에 쿠버네티스 클러스터를 설치할 수 있는지 보여준다.
<a href=https://github.com/kubernetes/kops><code>kops</code></a>라는 이름의 툴을 이용할 것이다.</p><p>kops는 자동화된 프로비저닝 시스템인데,</p><ul><li>완전 자동화된 설치</li><li>DNS를 통해 클러스터들의 신원 확인</li><li>자체 복구: 모든 자원이 Auto-Scaling Groups에서 실행</li><li>다양한 OS 지원(Debian, Ubuntu 16.04 supported, CentOS & RHEL, Amazon Linux and CoreOS) - <a href=https://github.com/kubernetes/kops/blob/master/docs/operations/images.md>images.md</a> 보기</li><li>고가용성 지원 - <a href=https://github.com/kubernetes/kops/blob/master/docs/operations/high_availability.md>high_availability.md</a> 보기</li><li>직접 프로비저닝 하거나 또는 할 수 있도록 terraform 매니페스트를 생성 - <a href=https://github.com/kubernetes/kops/blob/master/docs/terraform.md>terraform.md</a> 보기</li></ul><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><p><a href=/ko/docs/tasks/tools/>kubectl</a>을 반드시 설치해야 한다.</p></li><li><p>반드시 64-bit (AMD64 그리고 Intel 64)디바이스 아키텍쳐 위에서 <code>kops</code> 를 <a href=https://github.com/kubernetes/kops#installing>설치</a> 한다.</p></li><li><p><a href=https://docs.aws.amazon.com/polly/latest/dg/setting-up.html>AWS 계정</a>이 있고 <a href=https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys>IAM 키</a>를 생성하고 <a href=https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html#cli-quick-configuration>구성</a>해야 한다. IAM 사용자는 <a href=https://github.com/kubernetes/kops/blob/master/docs/getting_started/aws.md#setup-iam-user>적절한 권한</a>이 필요하다.</p></li></ul><h2 id=클러스터-구축>클러스터 구축</h2><h3 id=1-5-kops-설치>(1/5) kops 설치</h3><h4 id=설치>설치</h4><p><a href=https://github.com/kubernetes/kops/releases>releases page</a>에서 kops를 다운로드한다(소스 코드로부터 빌드하는 것도 역시 편리하다).</p><ul class="nav nav-tabs" id=kops-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kops-installation-0 role=tab aria-controls=kops-installation-0 aria-selected=true>macOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kops-installation-1 role=tab aria-controls=kops-installation-1>리눅스</a></li></ul><div class=tab-content id=kops-installation><div id=kops-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=kops-installation-0><p><p>최신 버전의 릴리스를 다운받는 명령어:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://github.com/kubernetes/kops/releases/download/<span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest
</span></span><span style=display:flex><span>| grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>/kops-darwin-amd64
</span></span></code></pre></div><p>특정 버전을 다운로드 받는다면 명령의 다음 부분을 특정 kops 버전으로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><p>예를 들어 kops 버전을 v1.20.0을 다운로드 하려면 다음을 입력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://github.com/kubernetes/kops/releases/download/v1.20.0/kops-darwin-amd64
</span></span></code></pre></div><p>kops 바이너리를 실행 가능하게 만든다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>chmod +x kops-darwin-amd64
</span></span></code></pre></div><p>kops 바이너리를 사용자의 PATH로 이동한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo mv kops-darwin-amd64 /usr/local/bin/kops
</span></span></code></pre></div><p>사용자는 <a href=https://brew.sh/>Homebrew</a>를 이용해서 kops를 설치할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew update <span style=color:#666>&amp;&amp;</span> brew install kops
</span></span></code></pre></div></div><div id=kops-installation-1 class=tab-pane role=tabpanel aria-labelledby=kops-installation-1><p><p>최신 릴리스를 다운로드 받는 명령어:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://github.com/kubernetes/kops/releases/download/<span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>/kops-linux-amd64
</span></span></code></pre></div><p>특정 버전의 kops를 다운로드하려면 명령의 다음 부분을 특정 kops 버전으로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><p>예를 들어 kops 버전을 v1.20.0을 다운로드 하려면 다음을 입력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://github.com/kubernetes/kops/releases/download/v1.20.0/kops-linux-amd64
</span></span></code></pre></div><p>kops 바이너리를 실행 가능하게 만든다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>chmod +x kops-linux-amd64
</span></span></code></pre></div><p>kops 바이너리를 사용자의 PATH로 이동한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo mv kops-linux-amd64 /usr/local/bin/kops
</span></span></code></pre></div><p>사용자는 <a href=https://docs.brew.sh/Homebrew-on-Linux>Homebrew</a>를 이용해서 kops를 설치할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew update <span style=color:#666>&amp;&amp;</span> brew install kops
</span></span></code></pre></div></div></div><h3 id=2-5-클러스터에-사용할-route53-domain-생성>(2/5) 클러스터에 사용할 route53 domain 생성</h3><p>kops는 클러스터 내부와 외부 모두에서 검색을 위해 DNS을 사용하기에 클라이언트에서 쿠버네티스 API 서버에 연결할
수 있다.</p><p>이런 클러스터 이름에 kops는 명확한 견해을 가지는데: 반드시 유효한 DNS 이름이어야 한다. 이렇게 함으로써
사용자는 클러스터를 헷갈리지 않을것이고, 동료들과 혼선없이 공유할 수 있으며,
IP를 기억할 필요없이 접근할 수 있다.</p><p>그렇게 하고 있겠지만, 클러스터를 구분하기 위해 서브도메인을 활용할 수 있다. 예를 들어
<code>useast1.dev.example.com</code>을 이용한다면, API 서버 엔드포인트는 <code>api.useast1.dev.example.com</code>가 될 것이다.</p><p>Route53 hosted zone은 서브도메인도 지원한다. 여러분의 hosted zone은 <code>useast1.dev.example.com</code>,
<code>dev.example.com</code> 그리고 <code>example.com</code> 같은 것도 될 수 있다. kops는 이것들 모두와 잘 동작하며,
사용자는 보통 조직적인 부분을 고려해 결정한다(예를 들어, 사용자가 <code>dev.example.com</code>하위에 레코드를 생성하는것은 허용되지만,
<code>example.com</code>하위에는 그렇지 않을 수 있다).</p><p><code>dev.example.com</code>을 hosted zone으로 사용하고 있다고 가정해보자.
보통 사용자는 <a href=https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingNewSubdomain.html>일반적인 방법</a> 에 따라 생성하거나
<code>aws route53 create-hosted-zone --name dev.example.com --caller-reference 1</code> 와 같은 커맨드를 이용한다.</p><p>그 후 도메인 내 레코드들을 확인할 수 있도록 상위 도메인내에 NS 레코드를 생성해야 한다. 여기서는,
<code>dev</code> NS 레코드를 <code>example.com</code>에 생성한다. 만약 이것이 루트 도메인 네임이라면 이 NS 레코드들은
도메인 등록기관을 통해서 생성해야 한다(예를 들어, <code>example.com</code>는 <code>example.com</code>를 구매한 곳에서 설정 할 수 있다).</p><p>route53 도메인 설정을 확인한다(문제를 만드는 가장 큰 이유이다!). dig 툴을 실행해서
클러스터 설정이 정확한지 한번 더 확인한다.</p><p><code>dig NS dev.example.com</code></p><p>당신의 hosted zone용으로 할당된 3~4개의 NS 레코드를 Route53에서 확인할 수 있어야 한다.</p><h3 id=3-5-클러스터-상태-저장용-s3-버킷-생성>(3/5) 클러스터 상태 저장용 S3 버킷 생성</h3><p>kops는 설치 이후에도 클러스터를 관리할 수 있다. 이를 위해 사용자가 생성한 클러스터의 상태나
사용하는 키 정보들을 지속적으로 추적해야 한다. 이 정보가 S3에 저장된다.
이 버킷의 접근은 S3 권한으로 제어한다.</p><p>다수의 클러스터는 동일한 S3 버킷을 이용할 수 있고, 사용자는 이 S3 버킷을 같은 클러스트를
운영하는 동료에게 공유할 수 있다. 하지만 이 S3 버킷에 접근 가능한 사람은 사용자의
모든 클러스터에 관리자 접근이 가능하게 되니, 운영팀 이외로
공유되지 않도록 해야 한다.</p><p>그래서 보통 한 운영팀 당 하나의 S3 버킷을 가지도록 하기도 한다.(그리고 종종 운영팀
이름은 위에서 언급한 hosted zone과 동일하게 짓기도 한다!)</p><p>우리 예제에서는, <code>dev.example.com</code>를 hosted zone으로 했으니 <code>clusters.dev.example.com</code>를
S3 버킷 이름으로 정하자.</p><ul><li><p><code>AWS_PROFILE</code>를 선언한다. (AWS CLI 동작을 위해 다른 profile을 선택해야 할 경우)</p></li><li><p><code>aws s3 mb s3://clusters.dev.example.com</code>를 이용해 S3 버킷을 생성한다.</p></li><li><p><code>export KOPS_STATE_STORE=s3://clusters.dev.example.com</code> 하면, kops는 이 위치를 기본값으로 인식할 것이다.
이 부분을 bash profile등에 넣어두는것을 권장한다.</p></li></ul><h3 id=4-5-클러스터-설정-구성>(4/5) 클러스터 설정 구성</h3><p>클러스터 설정하려면, <code>kops create cluster</code> 를 실행한다:</p><p><code>kops create cluster --zones=us-east-1c useast1.dev.example.com</code></p><p>kops는 클러스터에 사용될 설정을 생성할것이다. 여기서 주의할 점은 실제 클러스트 리소스가 아닌 <em>설정</em>
만을 생성한다는 것에 주의하자 - 이 부분은 다음 단계에서 <code>kops update cluster</code> 으로
구성해볼 것이다. 그 때 만들어진 설정을 점검하거나 변경할 수 있다.</p><p>더 자세한 내용을 알아보기 위한 커맨드가 출력된다.</p><ul><li>클러스터 조회: <code>kops get cluster</code></li><li>클러스트 수정: <code>kops edit cluster useast1.dev.example.com</code></li><li>인스턴스 그룹 수정: <code>kops edit ig --name=useast1.dev.example.com nodes</code></li><li>마스터 인스턴스 그룹 수정: <code>kops edit ig --name=useast1.dev.example.com master-us-east-1c</code></li></ul><p>만약 kops사용이 처음이라면, 얼마 걸리지 않으니 이들을 시험해 본다. 인스턴스 그룹은
쿠버네티스 노드로 등록된 인스턴스의 집합을 말한다. AWS상에서는 auto-scaling-groups를
통해 만들어진다. 사용자는 여러 개의 인스턴스 그룹을 관리할 수 있는데,
예를 들어, spot과 on-demand 인스턴스 조합 또는 GPU 와 non-GPU 인스턴스의 조합으로 구성할 수 있다.</p><h3 id=5-5-aws에-클러스터-생성>(5/5) AWS에 클러스터 생성</h3><p><code>kops update cluster</code>를 실행해 AWS에 클러스터를 생성한다.</p><p><code>kops update cluster useast1.dev.example.com --yes</code></p><p>실행은 수 초 만에 되지만, 실제로 클러스터가 준비되기 전까지 수 분이 걸릴 수 있다.
언제든 <code>kops update cluster</code>로 클러스터 설정을 변경할 수 있다. 사용자가
변경한 클러스터 설정을 그대로 반영해 줄 것이며, 필요다하면 AWS 나 쿠버네티스를 재설정 해 줄것이다.</p><p>예를 들면, <code>kops edit ig nodes</code> 뒤에 <code>kops update cluster --yes</code>를 실행해 설정을 반영한다.
그리고 <code>kops rolling-update cluster</code>로 설정을 즉시 원복시킬 수 있다.</p><p><code>--yes</code>를 명시하지 않으면 <code>kops update cluster</code> 커맨드 후 어떤 설정이 변경될지가 표시된다.
운영계 클러스터 관리할 때 사용하기 좋다!</p><h3 id=다른-애드온-탐험>다른 애드온 탐험</h3><p><a href=/ko/docs/concepts/cluster-administration/addons/>애드온 리스트</a> 에서 쿠버네티스 클러스터용 로깅, 모니터링, 네트워크 정책, 시각화 & 제어 등을 포함한 다른 애드온을 확인해본다.</p><h2 id=정리하기>정리하기</h2><ul><li><code>kops delete cluster useast1.dev.example.com --yes</code> 로 클러스터를 삭제한다.</li></ul><h2 id=다음-내용>다음 내용</h2><ul><li>쿠버네티스 <a href=/ko/docs/concepts/>개념</a> 과 <a href=/ko/docs/reference/kubectl/><code>kubectl</code></a>에 대해 더 알아보기.</li><li>튜토리얼, 모범사례 및 고급 구성 옵션에 대한 <code>kops</code> <a href=https://kops.sigs.k8s.io/>고급 사용법</a>에 대해 더 자세히 알아본다.</li><li>슬랙(Slack)에서 <code>kops</code> 커뮤니티 토론을 할 수 있다: <a href=https://github.com/kubernetes/kops#other-ways-to-communicate-with-the-contributors>커뮤니티 토론</a></li><li>문제를 해결하거나 이슈를 제기하여 <code>kops</code> 에 기여한다. <a href=https://github.com/kubernetes/kops/issues>깃헙 이슈</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f8b4964187fe973644e06ee629eff1de>3 - Kubespray로 쿠버네티스 설치하기</h1><p>이 가이드는 <a href=https://github.com/kubernetes-sigs/kubespray>Kubespray</a>를 이용하여 GCE, Azure, OpenStack, AWS, vSphere, Equinix Metal(전 Packet), Oracle Cloud infrastructure(실험적) 또는 베어메탈 등에서 운영되는 쿠버네티스 클러스터를 설치하는 과정을 보여준다.</p><p>Kubespray는 <a href=https://docs.ansible.com/>Ansible</a> 플레이북, <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/ansible.md#inventory>인벤토리</a>, 프로비저닝 도구와 일반적인 운영체제, 쿠버네티스 클러스터의 설정 관리 작업에 대한 도메인 지식의 결합으로 만들어졌다. Kubespray는 아래와 같은 기능을 제공한다.</p><p>Kubespray 지원 사항</p><ul><li>고가용성을 지닌 클러스터</li><li>구성 가능 (인스턴스를 위한 네트워크 플러그인 선택)</li><li>대부분의 인기있는 리눅스 배포판들에 대한 지원<ul><li>Flatcar Container Linux by Kinvolk</li><li>Debian Bullseye, Buster, Jessie, Stretch</li><li>Ubuntu 16.04, 18.04, 20.04, 22.04</li><li>CentOS/RHEL 7, 8</li><li>Fedora 34, 35</li><li>Fedora CoreOS</li><li>openSUSE Leap 15.x/Tumbleweed</li><li>Oracle Linux 7, 8</li><li>Alma Linux 8</li><li>Rocky Linux 8</li><li>Amazon Linux 2</li></ul></li><li>지속적인 통합 (CI) 테스트</li></ul><p>클러스터를 설치해 줄 도구로 유스케이스와 가장 잘 맞는 것을 고르고 싶다면, kubespray를 <a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a>, <a href=/ko/docs/setup/production-environment/tools/kops/>kops</a>와 <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/comparisons.md>비교한 글</a>을 읽어보자.</p><h2 id=클러스터-생성하기>클러스터 생성하기</h2><h3 id=1-5-아래의-요건-충족하기>(1/5) 아래의 요건 충족하기</h3><p>언더레이(underlay) <a href=https://github.com/kubernetes-sigs/kubespray#requirements>요건</a>을 만족하는 프로비전 한다.</p><ul><li><strong>쿠버네티스는 최소한 v1.22 이상의 버전이 필요하다.</strong></li><li><strong>Ansible의 명령어를 실행하기 위해 Ansible v2.11+, Jinja 2.11+와 Python netaddr 라이브러리가 머신에 설치되어 있어야 한다</strong>.</li><li>타겟 서버들은 docker 이미지를 풀(pull) 하기 위해 반드시 <strong>인터넷에 접속</strong>할 수 있어야 한다. 아니라면, 추가적인 설정을 해야 한다 (<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/offline-environment.md>오프라인 환경 확인하기</a>)</li><li>타겟 서버들의 <strong>IPv4 포워딩</strong>이 활성화되어야 한다.</li><li>파드와 서비스에서 IPv6를 이용한다면, 대상 서버도 <strong>IPv6 포워딩</strong>이 활성화되어야 한다.</li><li><strong>방화벽은 kubespray가 관리하지 않는다</strong>. 사용자는 기존 방식으로 자신의 규칙을 구현해야 한다. 배포 중에 만날 문제를 예방하려면 방화벽을 비활성화해야 한다.</li><li>만약 kubespray가 루트가 아닌 사용자 계정에서 실행되었다면, 타겟 서버에서 알맞은 권한 상승 방법이 설정되어야 한다. 그 후에 <code>ansible_become</code> 플래그나 커맨드 파라미터들, <code>--become</code> 또는 <code>-b</code> 가 명시되어야 한다</li></ul><p>Kubespray는 환경에 맞는 프로비저닝을 돕기 위해 아래와 같은 서비스를 제공한다:</p><ul><li>아래 클라우드 제공 업체를 위한 <a href=https://www.terraform.io/>Terraform</a> 스크립트:<ul><li><a href=https://github.com/kubernetes-sigs/kubespray/tree/master/contrib/terraform/aws>AWS</a></li><li><a href=https://github.com/kubernetes-sigs/kubespray/tree/master/contrib/terraform/openstack>OpenStack</a></li><li><a href=https://github.com/kubernetes-sigs/kubespray/tree/master/contrib/terraform/metal>Equinix Metal</a></li></ul></li></ul><h3 id=2-5-인벤토리-파일-구성하기>(2/5) 인벤토리 파일 구성하기</h3><p>서버들을 프로비저닝 한 후, <a href=https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html>Ansible의 인벤토리 파일</a>을 만들어야 한다. 수동으로 만들 수도 있고, 동적인 인벤토리 스크립트를 통해 만들 수도 있다. 더 많이 알고싶다면 " <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#building-your-own-inventory>나만의 인벤토리 만들기</a>" 글을 확인하자.</p><h3 id=3-5-클러스터-디플로이먼트-계획하기>(3/5) 클러스터 디플로이먼트 계획하기</h3><p>Kubespray에서는 디플로이먼트의 많은 속성들을 사용자가 정의(customize)할 수 있다:</p><ul><li>디플로이먼트 모드의 선택: kubeadm 또는 그 외</li><li>CNI(네트워킹) 플러그인</li><li>DNS 설정</li><li>컨트롤 플레인 선택: 네이티브/바이너리 또는 컨테이너화 된 것</li><li>컴포넌트 버전</li><li>Calico 라우터 리플렉터</li><li>컴포넌트 런타임 옵션<ul><li><a class=glossary-tooltip title='Docker는 운영 시스템 수준의 가상화를 제공하는 소프트웨어 기술이며, 컨테이너로도 알려져 있다.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=도커(Docker)>도커(Docker)</a></li><li><a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></li><li><a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></li></ul></li><li>인증서 생성 방법</li></ul><p>Kubespray의 <a href=https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html>변수 파일들</a>을 사용자가 정의할 수 있다. 만약 Kubespray를 처음 접하는 경우, kubespray의 기본 설정값을 이용해 클러스터를 배포하고 Kubernetes를 탐색하는 것이 좋다.</p><h3 id=4-5-클러스터-배포하기>(4/5) 클러스터 배포하기</h3><p>다음으로, 클러스터를 배포한다.</p><p><a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#starting-custom-deployment>Ansible-플레이북</a>을 이용한 클러스터 디플로이먼트</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ansible-playbook -i your/inventory/inventory.ini cluster.yml -b -v <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --private-key<span style=color:#666>=</span>~/.ssh/private_key
</span></span></code></pre></div><p>규모가 큰 디플로이먼트는 (100개 이상의 노드) 최적의 결과를 얻기 위해 <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/large-deployments.md>특정한 조정</a>을 필요로 할 수도 있다.</p><h3 id=5-5-디플로이먼트-검증하기>(5/5) 디플로이먼트 검증하기</h3><p>Kubespray는 Netchecker를 사용하여 파드 사이의 연결성과 DNS 해석을 검증할 방법을 제공한다. Netchecker는 netchecker-agents 파드들이 DNS 요청을 해석하고 기본(default) 네임스페이스 내부에서 서로에게 ping을 보낼 수 있도록 보장한다. 그 파드들은 나머지 워크로드의 유사한 동작을 모방하고 클러스터의 상태 표시기 역할을 한다.</p><h2 id=클러스터-동작>클러스터 동작</h2><p>Kubespray는 클러스터를 관리하기 위한 추가적인 플레이북, <em>scale</em> 과 <em>upgrade</em> 를 제공한다.</p><h3 id=클러스터-스케일링하기>클러스터 스케일링하기</h3><p>scale 플레이북을 실행해 클러스터에 워커 노드를 추가할 수 있다. 더 자세히 알고 싶다면, "<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#adding-nodes>노드 추가하기</a>" 문서를 확인하자.
remove-node 플레이북을 실행하면 클러스터로부터 워커 노드를 제거할 수 있다. 더 알고 싶다면 "<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#remove-nodes>노드 제거하기</a>" 문서를 확인하자.</p><h3 id=클러스터-업그레이드-하기>클러스터 업그레이드 하기</h3><p>upgrade-cluster 플레이북을 실행해 클러스터를 업그레이드 할 수 있다. 더 자세히 알고 싶다면 "<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/upgrades.md>업그레이드</a>" 문서를 확인하자.</p><h2 id=클린업>클린업</h2><p><a href=https://github.com/kubernetes-sigs/kubespray/blob/master/reset.yml>reset 플레이북</a>을 이용하여 노드들을 리셋하고 Kubespray로 설치된 모든 구성요소를 삭제할 수 있다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> reset 플레이북을 실행할 때, 실수로 프로덕션 클러스터를 타겟으로 삼지 않도록 해야 한다!</div><h2 id=피드백>피드백</h2><ul><li>Slack 채널: <a href=https://kubernetes.slack.com/messages/kubespray/>#kubespray</a> (<a href=https://slack.k8s.io/>이 곳</a>에서 초대를 받을 수 있다)</li><li><a href=https://github.com/kubernetes-sigs/kubespray/issues>GitHub Issues</a></li></ul><h2 id=다음-내용>다음 내용</h2><ul><li>Kubespray의 <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/roadmap.md>로드맵</a>에서 계획중인 작업을 확인해보자.</li><li><a href=https://github.com/kubernetes-sigs/kubespray>Kubespray</a>를 더 알아보자.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>