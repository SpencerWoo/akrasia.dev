<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/administer-cluster/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/administer-cluster/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/administer-cluster/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/administer-cluster/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/administer-cluster/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/administer-cluster/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/tasks/administer-cluster/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>클러스터 운영 | Kubernetes</title><meta property="og:title" content="클러스터 운영"><meta property="og:description" content="클러스터를 운영하기 위한 공통 태스크를 배운다."><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/tasks/administer-cluster/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="클러스터 운영"><meta itemprop=description content="클러스터를 운영하기 위한 공통 태스크를 배운다."><meta name=twitter:card content="summary"><meta name=twitter:title content="클러스터 운영"><meta name=twitter:description content="클러스터를 운영하기 위한 공통 태스크를 배운다."><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="클러스터를 운영하기 위한 공통 태스크를 배운다."><meta property="og:description" content="클러스터를 운영하기 위한 공통 태스크를 배운다."><meta name=twitter:description content="클러스터를 운영하기 위한 공통 태스크를 배운다."><meta property="og:url" content="https://kubernetes.io/ko/docs/tasks/administer-cluster/"><meta property="og:title" content="클러스터 운영"><meta name=twitter:title content="클러스터 운영"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/tasks/administer-cluster/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/tasks/administer-cluster/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/tasks/administer-cluster/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/tasks/administer-cluster/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/tasks/administer-cluster/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tasks/administer-cluster/>English</a>
<a class=dropdown-item href=/zh-cn/docs/tasks/administer-cluster/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/tasks/administer-cluster/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/tasks/administer-cluster/>Français (French)</a>
<a class=dropdown-item href=/de/docs/tasks/administer-cluster/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/tasks/administer-cluster/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/tasks/administer-cluster/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/tasks/administer-cluster/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>클러스터 운영</h1><div class=lead>클러스터를 운영하기 위한 공통 태스크를 배운다.</div><ul><li>1: <a href=#pg-8e16d69617b175d61e2e7a6e1642c9d6>kubeadm으로 관리하기</a></li><ul><li>1.1: <a href=#pg-f62fba1de4084f3be070785757c8079c>kubeadm을 사용한 인증서 관리</a></li><li>1.2: <a href=#pg-2e173356df5179cab9eec90a606f0aa4>kubeadm 클러스터 업그레이드</a></li><li>1.3: <a href=#pg-e805c7d8d4ad6195cb82dbbc843bfc29>윈도우 노드 업그레이드</a></li></ul><li>2: <a href=#pg-adb6c52e773f4d890595e14a9251f59b>도커심으로부터 마이그레이션</a></li><ul><li>2.1: <a href=#pg-d81ef0973a7bb4813e1797a452864742>도커 엔진 노드를 도커심에서 cri-dockerd로 마이그레이션하기</a></li></ul><li>3: <a href=#pg-47be5dd51f686017f1766e6ec7aa6f41>메모리, CPU 와 API 리소스 관리</a></li><ul><li>3.1: <a href=#pg-337620c76587e4aeb32009cb23be46de>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></li><li>3.2: <a href=#pg-320af95e480962c538ebef7ae205845c>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></li><li>3.3: <a href=#pg-adb489b1ab985c9215657b0d4c6ae92b>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></li><li>3.4: <a href=#pg-a87cbd1f9379dac7a48ae320da68a9ad>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></li><li>3.5: <a href=#pg-fe3283559a3df299aae3ee00ecea2fad>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></li><li>3.6: <a href=#pg-40e30a9209e0c9f4153707e43243e9d7>네임스페이스에 대한 파드 쿼터 구성</a></li></ul><li>4: <a href=#pg-7743f043c43f7b12e8654e2227dbc658>인증서</a></li><li>5: <a href=#pg-8c31aafd38fad5b0de0bd191758d6f93>네트워크 폴리시 제공자(Network Policy Provider) 설치</a></li><ul><li>5.1: <a href=#pg-1239a77618c6278373832a142cd85519>네트워크 폴리시로 캘리코(Calico) 사용하기</a></li><li>5.2: <a href=#pg-95039241255a31df196beaa405b68eba>네트워크 폴리시로 실리움(Cilium) 사용하기</a></li><li>5.3: <a href=#pg-505a0a6a7e6eff361bbb3be81c84b2e0>네트워크 폴리시로 큐브 라우터(Kube-router) 사용하기</a></li><li>5.4: <a href=#pg-2842eac98aa0e229a5c6755c4c83d2a7>네트워크 폴리시로 로마나(Romana)</a></li><li>5.5: <a href=#pg-ac075c3fdfd0d41aa753cc70e42be064>네트워크 폴리시로 위브넷(Weave Net) 사용하기</a></li></ul><li>6: <a href=#pg-3d0cd7d2f13d4759094f281504cf57b8>DNS 서비스 사용자 정의하기</a></li><li>7: <a href=#pg-2bffd7f3571cdd609bd97fb2e1bdb2fe>기본 스토리지클래스(StorageClass) 변경하기</a></li><li>8: <a href=#pg-1e966f5d0540bbee0876f9d0d08d54dc>네임스페이스를 사용해 클러스터 공유하기</a></li><li>9: <a href=#pg-a3790dfb57271d13517e549dffa805b9>네트워크 폴리시(Network Policy) 선언하기</a></li><li>10: <a href=#pg-a8f6511197efcd7d0db80ade49620f9d>노드에 대한 확장 리소스 알리기</a></li><li>11: <a href=#pg-e1afcdac8d5e8458274b3c481c5ebcda>서비스 디스커버리를 위해 CoreDNS 사용하기</a></li><li>12: <a href=#pg-a02f35804917d7a269c38d7e2c475005>스토리지 사용량 제한</a></li><li>13: <a href=#pg-4a02bcca41439e16655f43fa37c81da4>중요한 애드온 파드 스케줄링 보장하기</a></li><li>14: <a href=#pg-09cc2cf3e0f23a3996e6cb31dc4d867c>쿠버네티스 API 활성화 혹은 비활성화하기</a></li><li>15: <a href=#pg-e77685d5b88d2db5c7631a27b9472eea>쿠버네티스 API를 사용하여 클러스터에 접근하기</a></li><li>16: <a href=#pg-fe5ad73163d38596340536ec03a205f0>쿠버네티스 클러스터에서 sysctl 사용하기</a></li><li>17: <a href=#pg-fe6b50655c29ab0b7c1ee549ff64c138>클러스터 업그레이드</a></li><li>18: <a href=#pg-4e9de5bc3973e5d2bb8f09ff940c3319>클러스터에서 캐스케이딩 삭제 사용</a></li><li>19: <a href=#pg-fbc9136f53eccd6eb8c80f4bbea3b8f4>퍼시스턴트볼륨 반환 정책 변경하기</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-8e16d69617b175d61e2e7a6e1642c9d6>1 - kubeadm으로 관리하기</h1></div><div class=td-content><h1 id=pg-f62fba1de4084f3be070785757c8079c>1.1 - kubeadm을 사용한 인증서 관리</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.15 [stable]</code></div><p><a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a>으로 생성된 클라이언트 인증서는 1년 후에 만료된다.
이 페이지는 kubeadm으로 인증서 갱신을 관리하는 방법을 설명하며,
kubeadm 인증서 관리와 관련된 다른 작업에 대해서도 다룬다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><a href=/ko/docs/setup/best-practices/certificates/>쿠버네티스의 PKI 인증서와 요구 조건</a>에 익숙해야 한다.</p><h2 id=custom-certificates>사용자 정의 인증서 사용</h2><p>기본적으로, kubeadm은 클러스터를 실행하는 데 필요한 모든 인증서를 생성한다.
사용자는 자체 인증서를 제공하여 이 동작을 무시할 수 있다.</p><p>이렇게 하려면, <code>--cert-dir</code> 플래그 또는 kubeadm <code>ClusterConfiguration</code> 의
<code>certificatesDir</code> 필드에 지정된 디렉터리에 배치해야 한다.
기본적으로 <code>/etc/kubernetes/pki</code> 이다.</p><p><code>kubeadm init</code> 을 실행하기 전에 지정된 인증서와 개인 키(private key) 쌍이 존재하면,
kubeadm은 이를 덮어 쓰지 않는다. 이는 예를 들어, 기존 CA를
<code>/etc/kubernetes/pki/ca.crt</code> 와 <code>/etc/kubernetes/pki/ca.key</code> 에
복사할 수 있고, kubeadm은 이 CA를 사용하여 나머지 인증서에 서명한다는 걸 의미한다.</p><h2 id=external-ca-mode>외부 CA 모드</h2><p><code>ca.key</code> 파일이 아닌 <code>ca.crt</code> 파일만 제공할
수도 있다(이는 다른 인증서 쌍이 아닌 루트 CA 파일에만 사용 가능함).
다른 모든 인증서와 kubeconfig 파일이 있으면, kubeadm은 이 조건을
인식하고 "외부 CA" 모드를 활성화한다. kubeadm은 디스크에
CA 키없이 진행한다.</p><p>대신, <code>--controllers=csrsigner</code> 사용하여 controller-manager를
독립적으로 실행하고 CA 인증서와 키를 가리킨다.</p><p><a href=/ko/docs/setup/best-practices/certificates/>PKI 인증서와 요구 조건</a>은 외부 CA를
사용하도록 클러스터 설정에 대한 지침을 포함한다.</p><h2 id=인증서-만료-확인>인증서 만료 확인</h2><p><code>check-expiration</code> 하위 명령을 사용하여 인증서가 만료되는 시기를 확인할 수 있다.</p><pre tabindex=0><code>kubeadm certs check-expiration
</code></pre><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED
admin.conf                 Dec 30, 2020 23:36 UTC   364d                                    no
apiserver                  Dec 30, 2020 23:36 UTC   364d            ca                      no
apiserver-etcd-client      Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
apiserver-kubelet-client   Dec 30, 2020 23:36 UTC   364d            ca                      no
controller-manager.conf    Dec 30, 2020 23:36 UTC   364d                                    no
etcd-healthcheck-client    Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
etcd-peer                  Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
etcd-server                Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
front-proxy-client         Dec 30, 2020 23:36 UTC   364d            front-proxy-ca          no
scheduler.conf             Dec 30, 2020 23:36 UTC   364d                                    no

CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED
ca                      Dec 28, 2029 23:36 UTC   9y              no
etcd-ca                 Dec 28, 2029 23:36 UTC   9y              no
front-proxy-ca          Dec 28, 2029 23:36 UTC   9y              no
</code></pre><p>이 명령은 <code>/etc/kubernetes/pki</code> 폴더의 클라이언트 인증서와 kubeadm이 사용하는 KUBECONFIG 파일(<code>admin.conf</code>, <code>controller-manager.conf</code> 및 <code>scheduler.conf</code>)에 포함된 클라이언트 인증서의 만료/잔여 기간을 표시한다.</p><p>또한, kubeadm은 인증서가 외부에서 관리되는지를 사용자에게 알린다. 이 경우 사용자는 수동으로 또는 다른 도구를 사용해서 인증서 갱신 관리를 해야 한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> <code>kubeadm</code> 은 외부 CA가 서명한 인증서를 관리할 수 없다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubelet.conf</code> 는 위 목록에 포함되어 있지 않은데, 이는
kubeadm이 <a href=/ko/docs/tasks/tls/certificate-rotation/>자동 인증서 갱신</a>을 위해
<code>/var/lib/kubelet/pki</code>에 있는 갱신 가능한 인증서를 이용하여 kubelet을 구성하기 때문이다.
만료된 kubelet 클라이언트 인증서를 갱신하려면
<a href=/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#kubelet-client-cert>kubelet 클라이언트 갱신 실패</a> 섹션을 확인한다.</div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong><p>kubeadm 1.17 이전의 버전에서 <code>kubeadm init</code> 으로 작성된 노드에는
<code>kubelet.conf</code> 의 내용을 수동으로 수정해야 하는 <a href=https://github.com/kubernetes/kubeadm/issues/1753>버그</a>가 있다. <code>kubeadm init</code> 수행 완료 후, <code>client-certificate-data</code> 및 <code>client-key-data</code> 를 다음과 같이 교체하여,
로테이트된 kubelet 클라이언트 인증서를 가리키도록 <code>kubelet.conf</code> 를 업데이트해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/var/lib/kubelet/pki/kubelet-client-current.pem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/var/lib/kubelet/pki/kubelet-client-current.pem<span style=color:#bbb>
</span></span></span></code></pre></div></div><h2 id=자동-인증서-갱신>자동 인증서 갱신</h2><p>kubeadm은 컨트롤 플레인 <a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>업그레이드</a> 동안 모든 인증서를 갱신한다.</p><p>이 기능은 가장 간단한 유스케이스를 해결하기 위해 설계되었다.
인증서 갱신에 대해 특별한 요구 사항이 없고 쿠버네티스 버전 업그레이드를 정기적으로(매 1년 이내 업그레이드 수행) 수행하는 경우, kubeadm은 클러스터를 최신 상태로 유지하고 합리적으로 보안을 유지한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 보안을 유지하려면 클러스터를 자주 업그레이드하는 것이 가장 좋다.</div><p>인증서 갱신에 대해 보다 복잡한 요구 사항이 있는 경우, <code>--certificate-renewal=false</code> 를 <code>kubeadm upgrade apply</code> 또는 <code>kubeadm upgrade node</code> 와 함께 사용하여 기본 동작이 수행되지 않도록 할 수 있다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> kubeadm 1.17 이전 버전에는 <code>kubeadm upgrade node</code> 명령에서
<code>--certificate-renewal</code> 의 기본값이 <code>false</code> 인 <a href=https://github.com/kubernetes/kubeadm/issues/1818>버그</a>가
있다. 이 경우 <code>--certificate-renewal=true</code> 를 명시적으로 설정해야 한다.</div><h2 id=수동-인증서-갱신>수동 인증서 갱신</h2><p><code>kubeadm certs renew</code> 명령을 사용하여 언제든지 인증서를 수동으로 갱신할 수 있다.</p><p>이 명령은 <code>/etc/kubernetes/pki</code> 에 저장된 CA(또는 프론트 프록시 CA) 인증서와 키를 사용하여 갱신을 수행한다.</p><p>명령을 실행한 후에는 컨트롤 플레인 파드를 재시작해야 한다.
이는 현재 일부 구성 요소 및 인증서에 대해 인증서를 동적으로 다시 로드하는 것이 지원되지 않기 때문이다.
<a href=/ko/docs/tasks/configure-pod-container/static-pod/>스태틱(static) 파드</a>는 API 서버가 아닌 로컬 kubelet에서 관리되므로
kubectl을 사용하여 삭제 및 재시작할 수 없다.
스태틱 파드를 다시 시작하려면 <code>/etc/kubernetes/manifests/</code>에서 매니페스트 파일을 일시적으로 제거하고
20초를 기다리면 된다 (<a href=/docs/reference/config-api/kubelet-config.v1beta1/>KubeletConfiguration struct</a>의 <code>fileCheckFrequency</code> 값을 참고한다).
파드가 매니페스트 디렉터리에 더 이상 없는 경우 kubelet은 파드를 종료한다.
그런 다음 파일을 다시 이동할 수 있으며 또 다른 <code>fileCheckFrequency</code> 기간이 지나면,
kubelet은 파드를 생성하고 구성 요소에 대한 인증서 갱신을 완료할 수 있다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> HA 클러스터를 실행 중인 경우, 모든 컨트롤 플레인 노드에서 이 명령을 실행해야 한다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>certs renew</code> 는 기존 인증서를 kubeadm-config 컨피그맵(ConfigMap) 대신 속성(공통 이름, 조직, SAN 등)의 신뢰할 수 있는 소스로 사용한다. 둘 다 동기화 상태를 유지하는 것을 강력히 권장한다.</div><p><code>kubeadm certs renew</code> 는 다음의 옵션을 제공한다.</p><p>쿠버네티스 인증서는 일반적으로 1년 후 만료일에 도달한다.</p><ul><li><p><code>--csr-only</code> 는 실제로 인증서를 갱신하지 않고 인증서 서명 요청을 생성하여 외부 CA로 인증서를 갱신하는 데 사용할 수 있다. 자세한 내용은 다음 단락을 참고한다.</p></li><li><p>모든 인증서 대신 단일 인증서를 갱신할 수도 있다.</p></li></ul><h2 id=쿠버네티스-인증서-api를-사용하여-인증서-갱신>쿠버네티스 인증서 API를 사용하여 인증서 갱신</h2><p>이 섹션에서는 쿠버네티스 인증서 API를 사용하여 수동 인증서 갱신을 실행하는 방법에 대한 자세한 정보를 제공한다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 조직의 인증서 인프라를 kubeadm으로 생성된 클러스터에 통합해야 하는 사용자를 위한 고급 주제이다. 기본 kubeadm 구성이 요구 사항을 충족하면 kubeadm이 인증서를 대신 관리하도록 해야 한다.</div><h3 id=서명자-설정>서명자 설정</h3><p>쿠버네티스 인증 기관(Certificate Authority)은 기본적으로 작동하지 않는다.
<a href=https://cert-manager.io/docs/configuration/ca/>cert-manager</a>와 같은 외부 서명자를 설정하거나, 빌트인 서명자를 사용할 수 있다.</p><p>빌트인 서명자는 <a href=/docs/reference/command-line-tools-reference/kube-controller-manager/><code>kube-controller-manager</code></a>의 일부이다.</p><p>빌트인 서명자를 활성화하려면, <code>--cluster-signing-cert-file</code> 와 <code>--cluster-signing-key-file</code> 플래그를 전달해야 한다.</p><p>새 클러스터를 생성하는 경우, kubeadm <a href=https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta3>구성 파일</a>을 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>controllerManager</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster-signing-cert-file</span>:<span style=color:#bbb> </span>/etc/kubernetes/pki/ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster-signing-key-file</span>:<span style=color:#bbb> </span>/etc/kubernetes/pki/ca.key<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=인증서-서명-요청-csr-생성>인증서 서명 요청(CSR) 생성</h3><p>쿠버네티스 API로 CSR을 작성하려면 <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#create-certificatesigningrequest>CertificateSigningRequest 생성</a>을 본다.</p><h2 id=외부-ca로-인증서-갱신>외부 CA로 인증서 갱신</h2><p>이 섹션에서는 외부 CA를 사용하여 수동 인증서 갱신을 실행하는 방법에 대한 자세한 정보를 제공한다.</p><p>외부 CA와 보다 효과적으로 통합하기 위해 kubeadm은 인증서 서명 요청(CSR)을 생성할 수도 있다.
CSR은 클라이언트의 서명된 인증서에 대한 CA 요청을 나타낸다.
kubeadm 관점에서, 일반적으로 온-디스크(on-disk) CA에 의해 서명되는 모든 인증서는 CSR로 생성될 수 있다. 그러나 CA는 CSR로 생성될 수 없다.</p><h3 id=인증서-서명-요청-csr-생성-1>인증서 서명 요청(CSR) 생성</h3><p><code>kubeadm certs renew --csr-only</code> 로 인증서 서명 요청을 만들 수 있다.</p><p>CSR과 함께 제공되는 개인 키가 모두 출력된다.
<code>--csr-dir</code> 로 사용할 디텍터리를 전달하여 지정된 위치로 CSR을 출력할 수 있다.
<code>--csr-dir</code> 을 지정하지 않으면, 기본 인증서 디렉터리(<code>/etc/kubernetes/pki</code>)가 사용된다.</p><p><code>kubeadm certs renew --csr-only</code> 로 인증서를 갱신할 수 있다.
<code>kubeadm init</code> 과 마찬가지로 출력 디렉터리를 <code>--csr-dir</code> 플래그로 지정할 수 있다.</p><p>CSR에는 인증서 이름, 도메인 및 IP가 포함되지만, 용도를 지정하지는 않는다.
인증서를 발행할 때 <a href=/ko/docs/setup/best-practices/certificates/#%EB%AA%A8%EB%93%A0-%EC%9D%B8%EC%A6%9D%EC%84%9C>올바른 인증서 용도</a>를
지정하는 것은 CA의 책임이다.</p><ul><li><code>openssl</code> 의 경우
<a href=https://superuser.com/questions/738612/openssl-ca-keyusage-extension><code>openssl ca</code> 명령</a>으로 수행한다.</li><li><code>cfssl</code> 의 경우
<a href=https://github.com/cloudflare/cfssl/blob/master/doc/cmd/cfssl.txt#L170>설정 파일에 용도</a>를 지정한다.</li></ul><p>선호하는 방법으로 인증서에 서명한 후, 인증서와 개인 키를 PKI 디렉터리(기본적으로 <code>/etc/kubernetes/pki</code>)에 복사해야 한다.</p><h2 id=certificate-authority-rotation>인증 기관(CA) 순환(rotation)</h2><p>Kubeadm은 CA 인증서의 순환이나 교체 기능을 기본적으로 지원하지 않는다.</p><p>CA의 수동 순환이나 교체에 대한 보다 상세한 정보는 <a href=/docs/tasks/tls/manual-rotation-of-ca-certificates/>CA 인증서 수동 순환</a> 문서를 참조한다.</p><h2 id=kubelet-serving-certs>서명된 kubelet 인증서 활성화하기</h2><p>기본적으로 kubeadm에 의해서 배포된 kubelet 인증서는 자가 서명된(self-signed) 것이다.
이것은 <a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a>와
같은 외부 서비스의 kubelet에 대한 연결은
TLS로 보안되지 않음을 의미한다.</p><p>제대로 서명된 인증서를 얻기 위해서 신규 kubeadm 클러스터의 kubelet을 구성하려면
다음의 최소 구성을 <code>kubeadm init</code> 에 전달해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>serverTLSBootstrap</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>만약 이미 클러스터를 생성했다면 다음을 따라 이를 조정해야 한다.</p><ul><li><code>kube-system</code> 네임스페이스에서 <code>kubelet-config-1.25</code> 컨피그맵을 찾아서 수정한다.
해당 컨피그맵에는 <code>kubelet</code> 키가
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a>
문서를 값으로 가진다. <code>serverTLSBootstrap: true</code> 가 되도록 KubeletConfiguration 문서를 수정한다.</li><li>각 노드에서, <code>serverTLSBootstrap: true</code> 필드를 <code>/var/lib/kubelet/config.yaml</code> 에 추가한다.
그리고 <code>systemctl restart kubelet</code> 로 kubelet을 재시작한다.</li></ul><p><code>serverTLSBootstrap: true</code> 필드는 kubelet 인증서를 이용한 부트스트랩을
<code>certificates.k8s.io</code> API에 요청함으로써 활성화할 것이다. 한 가지 알려진 제약은
이 인증서들에 대한 CSR(인증서 서명 요청)들이 kube-controller-manager -
<a href=/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers><code>kubernetes.io/kubelet-serving</code></a>의
기본 서명자(default signer)에 의해서 자동으로 승인될 수 없다는 점이다.
이것은 사용자나 제 3의 컨트롤러의 액션을 필요로 할 것이다.</p><p>이 CSR들은 다음을 통해 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span><span style=display:flex><span>NAME        AGE     SIGNERNAME                        REQUESTOR                      CONDITION
</span></span><span style=display:flex><span>csr-9wvgt   112s    kubernetes.io/kubelet-serving     system:node:worker-1           Pending
</span></span><span style=display:flex><span>csr-lz97v   1m58s   kubernetes.io/kubelet-serving     system:node:control-plane-1    Pending
</span></span></code></pre></div><p>이를 승인하기 위해서는 다음을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl certificate approve &lt;CSR-name&gt;
</span></span></code></pre></div><p>기본적으로, 이 인증서는 1년 후에 만기될 것이다. Kubeadm은
<code>KubeletConfiguration</code> 필드의 <code>rotateCertificates</code> 를 <code>true</code> 로 설정한다. 이것은 만기가
다가오면 인증서를 위한 신규 CSR 세트가 생성되는 것을 의미하며,
해당 순환(rotation)을 완료하기 위해서는 승인이 되어야 한다는 것을 의미한다. 더 상세한 이해를 위해서는
<a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/#certificate-rotation>인증서 순환</a>를 확인한다.</p><p>만약 이 CSR들의 자동 승인을 위한 솔루션을 찾고 있다면 클라우드 제공자와
연락하여 대역 외 메커니즘(out of band mechanism)을 통해 노드의 신분을 검증할 수 있는
CSR 서명자를 가지고 있는지 문의하는 것을 추천한다.</p><div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div><p>써드파티 커스텀 컨트롤러도 사용될 수 있다.</p><ul><li><a href=https://github.com/postfinance/kubelet-csr-approver>kubelet-csr-approver</a></li></ul><p>이러한 컨트롤러는 CSR의 CommonName과 요청된 IPs 및 도메인 네임을
모두 검증하지 않는 한, 보안이 되는 메커니즘이 아니다. 이것을 통해 악의적 행위자가
kubelet 인증서(클라이언트 인증)를 사용하여 아무 IP나 도메인 네임에 대해 인증서를
요청하는 CSR의 생성을 방지할 수 있을 것이다.</p><h2 id=kubeconfig-additional-users>추가 사용자를 위한 kubeconfig 파일 생성하기</h2><p>클러스터 생성 과정에서, kubeadm은
<code>Subject: O = system:masters, CN = kubernetes-admin</code> 값이 설정되도록 <code>admin.conf</code>의 인증서에 서명한다.
<a href=/docs/reference/access-authn-authz/rbac/#user-facing-roles><code>system:masters</code></a>는
인증 계층(예: RBAC)을 우회하는 획기적인 슈퍼유저 그룹이다.
<code>admin.conf</code>를 추가 사용자와 공유하는 것은 <strong>권장하지 않는다</strong>!</p><p>대신, <a href=/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig><code>kubeadm kubeconfig user</code></a>
명령어를 사용하여 추가 사용자를 위한 kubeconfig 파일을 생성할 수 있다.
이 명령어는 명령줄 플래그와
<a href=/docs/reference/config-api/kubeadm-config.v1beta3/>kubeadm 환경 설정</a> 옵션을 모두 인식한다.
생성된 kubeconfig는 stdout으로 출력되며,
<code>kubeadm kubeconfig user ... > somefile.conf</code> 명령어를 사용하여 파일에 기록될 수 있다.</p><p>다음은 <code>--config</code> 플래그와 함께 사용될 수 있는 환경 설정 파일 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># example.yaml</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfig에서 타겟 &#34;cluster&#34;로 사용될 것이다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusterName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfig에서 클러스터의 &#34;server&#34;(IP 또는 DNS 이름)로 사용될 것이다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>controlPlaneEndpoint</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;some-dns-address:6443&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 클러스터 CA 키 및 인증서가 이 로컬 디렉토리에서 로드될 것이다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>certificatesDir</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/pki&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이러한 항목들이 사용하고자 하는 클러스터의 상세 사항과 일치하는지 확인한다.
기존 클러스터의 환경 설정을 보려면 다음 명령을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get cm kubeadm-config -n kube-system -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.data.ClusterConfiguration}&#34;</span>
</span></span></code></pre></div><p>다음 예시는 <code>appdevs</code> 그룹의 새 사용자 <code>johndoe</code>를 위해
24시간동안 유효한 인증서와 함께 kubeconfig 파일을 생성할 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm kubeconfig user --config example.yaml --org appdevs --client-name johndoe --validity-period 24h
</span></span></code></pre></div><p>다음 예시는 1주일간 유효한 관리자 크리덴셜을 갖는 kubeconfig 파일을 생성할 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm kubeconfig user --config example.yaml --client-name admin --validity-period 168h
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-2e173356df5179cab9eec90a606f0aa4>1.2 - kubeadm 클러스터 업그레이드</h1><p>이 페이지는 kubeadm으로 생성된 쿠버네티스 클러스터를 1.24.x 버전에서 1.25.x 버전으로,
1.25.x 버전에서 1.25.y(여기서 <code>y > x</code>) 버전으로 업그레이드하는 방법을 설명한다.
업그레이드가 지원되지 않는 경우 마이너 버전을 건너뛴다.
더 자세한 정보는 <a href=/ko/releases/version-skew-policy/>버전 차이(skew) 정책</a>을 참고한다.</p><p>이전 버전의 kubeadm을 사용하여 생성된 클러스터 업그레이드에 대한 정보를 보려면,
이 페이지 대신 다음의 페이지들을 참고한다.</p><ul><li><a href=https://v1-24.docs.kubernetes.io/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadm 클러스터를 1.23에서 1.24로 업그레이드</a></li><li><a href=https://v1-23.docs.kubernetes.io/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadm 클러스터를 1.22에서 1.23로 업그레이드</a></li><li><a href=https://v1-22.docs.kubernetes.io/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadm 클러스터를 1.21에서 1.22로 업그레이드</a></li><li><a href=https://v1-21.docs.kubernetes.io/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadm 클러스터를 1.20에서 1.21으로 업그레이드</a></li></ul><p>추상적인 업그레이드 작업 절차는 다음과 같다.</p><ol><li>기본 컨트롤 플레인 노드를 업그레이드한다.</li><li>추가 컨트롤 플레인 노드를 업그레이드한다.</li><li>워커(worker) 노드를 업그레이드한다.</li></ol><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><a href=https://git.k8s.io/kubernetes/CHANGELOG>릴리스 노트</a>를 주의 깊게 읽어야 한다.</li><li>클러스터는 정적 컨트롤 플레인 및 etcd 파드 또는 외부 etcd를 사용해야 한다.</li><li>데이터베이스에 저장된 앱-레벨 상태와 같은 중요한 컴포넌트를 반드시 백업한다.
<code>kubeadm upgrade</code> 는 워크로드에 영향을 미치지 않고, 쿠버네티스 내부의 컴포넌트만 다루지만, 백업은 항상 모범 사례일 정도로 중요하다.</li><li><a href=https://serverfault.com/questions/684771/best-way-to-disable-swap-in-linux>스왑을 비활성화해야 한다</a>.</li></ul><h3 id=추가-정보>추가 정보</h3><ul><li>아래의 지침은 업그레이드 과정 중 언제 각 노드를 드레인해야 하는지를 제시한다.
kubelet에 대해 <strong>마이너</strong> 버전 업그레이드를 하는 경우,
먼저 업그레이드할 노드(들)을 드레인<strong>해야 한다</strong>.
컨트롤 플레인 노드의 경우, CoreDNS 파드 또는 다른 중요한 워크로드를 실행 중일 수 있다.
더 많은 정보는 <a href=/docs/tasks/administer-cluster/safely-drain-node/>노드 드레인하기</a>를 참조한다.</li><li>컨테이너 사양 해시 값이 변경되므로, 업그레이드 후 모든 컨테이너가 다시 시작된다.</li><li>kubelet이 업그레이드된 이후 kubelet 서비스가 성공적으로 재시작되었는지 확인하려면,
<code>systemctl status kubelet</code> 명령을 실행하거나, <code>journalctl -xeu kubelet</code> 명령을 실행하여 서비스 로그를 확인할 수 있다.</li><li>클러스터를 재구성하기 위해 <code>kubeadm upgrade</code> 시에
<a href=/docs/reference/config-api/kubeadm-config.v1beta3>kubeadm 구성 API 종류</a>를 명시하여
<code>--config</code> 플래그를 사용하는 것은 추천하지 않으며 예상치 못한 결과를 초래할 수 있다.
대신 <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-reconfigure>kubeadm 클러스터 재구성하기</a>를 참조한다.</li></ul><h2 id=업그레이드할-버전-결정>업그레이드할 버전 결정</h2><p>OS 패키지 관리자를 사용하여 쿠버네티스의 최신 패치 릴리스 버전(1.25)을 찾는다.</p><ul class="nav nav-tabs" id=k8s-install-versions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-versions-0 role=tab aria-controls=k8s-install-versions-0 aria-selected=true>Ubuntu, Debian 또는 HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-versions-1 role=tab aria-controls=k8s-install-versions-1>CentOS, RHEL 또는 Fedora</a></li></ul><div class=tab-content id=k8s-install-versions><div id=k8s-install-versions-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-versions-0><p><pre><code>apt update
apt-cache madison kubeadm
# 목록에서 최신 버전(1.25)을 찾는다
# 1.25.x-00과 같아야 한다. 여기서 x는 최신 패치이다.
</code></pre></div><div id=k8s-install-versions-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-versions-1><p><pre><code>yum list --showduplicates kubeadm --disableexcludes=kubernetes
# 목록에서 최신 버전(1.25)을 찾는다
# 1.25.x-0과 같아야 한다. 여기서 x는 최신 패치이다.
</code></pre></div></div><h2 id=컨트롤-플레인-노드-업그레이드>컨트롤 플레인 노드 업그레이드</h2><p>컨트롤 플레인 노드의 업그레이드 절차는 한 번에 한 노드씩 실행해야 한다.
먼저 업그레이드할 컨트롤 플레인 노드를 선택한다. <code>/etc/kubernetes/admin.conf</code> 파일이 있어야 한다.</p><h3 id=kubeadm-upgrade-호출>"kubeadm upgrade" 호출</h3><p><strong>첫 번째 컨트롤 플레인 노드의 경우</strong></p><ul><li><p>kubeadm 업그레이드</p><p><ul class="nav nav-tabs" id=k8s-install-kubeadm-first-cp role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-kubeadm-first-cp-0 role=tab aria-controls=k8s-install-kubeadm-first-cp-0 aria-selected=true>Ubuntu, Debian 또는 HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-kubeadm-first-cp-1 role=tab aria-controls=k8s-install-kubeadm-first-cp-1>CentOS, RHEL 또는 Fedora</a></li></ul><div class=tab-content id=k8s-install-kubeadm-first-cp><div id=k8s-install-kubeadm-first-cp-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-kubeadm-first-cp-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> <span style=color:#080;font-style:italic># 1.25.x-00에서 x를 최신 패치 버전으로 바꾼다.</span>
</span></span><span style=display:flex><span> apt-mark unhold kubeadm <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b8860b>kubeadm</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> apt-mark hold kubeadm
</span></span></code></pre></div></div><div id=k8s-install-kubeadm-first-cp-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-kubeadm-first-cp-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-0에서 x를 최신 패치 버전으로 바꾼다.</span>
</span></span><span style=display:flex><span>yum install -y kubeadm-1.25.x-0 --disableexcludes<span style=color:#666>=</span>kubernetes
</span></span></code></pre></div></div></div><br></p></li><li><p>다운로드하려는 버전이 잘 받아졌는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm version
</span></span></code></pre></div></li><li><p>업그레이드 계획을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm upgrade plan
</span></span></code></pre></div><p>이 명령은 클러스터를 업그레이드할 수 있는지를 확인하고, 업그레이드할 수 있는 버전을 가져온다.
또한 컴포넌트 구성 버전 상태가 있는 표를 보여준다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 또한 <code>kubeadm upgrade</code> 는 이 노드에서 관리하는 인증서를 자동으로 갱신한다.
인증서 갱신을 하지 않으려면 <code>--certificate-renewal=false</code> 플래그를 사용할 수 있다.
자세한 내용은 <a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-certs>인증서 관리 가이드</a>를 참고한다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubeadm upgrade plan</code> 이 수동 업그레이드가 필요한 컴포넌트 구성을 표시하는 경우, 사용자는
<code>--config</code> 커맨드 라인 플래그를 통해 대체 구성이 포함된 구성 파일을 <code>kubeadm upgrade apply</code> 에 제공해야 한다.
그렇게 하지 않으면 <code>kubeadm upgrade apply</code> 가 오류와 함께 종료되고 업그레이드를 수행하지 않는다.</div></li><li><p>업그레이드할 버전을 선택하고, 적절한 명령을 실행한다. 예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 이 업그레이드를 위해 선택한 패치 버전으로 x를 바꾼다.</span>
</span></span><span style=display:flex><span>sudo kubeadm upgrade apply v1.25.x
</span></span></code></pre></div><p>명령이 완료되면 다음을 확인해야 한다.</p><pre tabindex=0><code>[upgrade/successful] SUCCESS! Your cluster was upgraded to &#34;v1.25.x&#34;. Enjoy!

[upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets if you haven&#39;t already done so.
</code></pre></li><li><p>CNI 제공자 플러그인을 수동으로 업그레이드한다.</p><p>CNI(컨테이너 네트워크 인터페이스) 제공자는 자체 업그레이드 지침을 따를 수 있다.
<a href=/ko/docs/concepts/cluster-administration/addons/>애드온</a> 페이지에서
사용하는 CNI 제공자를 찾고 추가 업그레이드 단계가 필요한지 여부를 확인한다.</p><p>CNI 제공자가 데몬셋(DaemonSet)으로 실행되는 경우 추가 컨트롤 플레인 노드에는 이 단계가 필요하지 않다.</p></li></ul><p><strong>다른 컨트롤 플레인 노드의 경우</strong></p><p>첫 번째 컨트롤 플레인 노드와 동일하지만 다음을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm upgrade node
</span></span></code></pre></div><p>아래 명령 대신 위의 명령을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm upgrade apply
</span></span></code></pre></div><p><code>kubeadm upgrade plan</code> 을 호출하고 CNI 공급자 플러그인을 업그레이드할 필요가 없다.</p><h3 id=노드-드레인>노드 드레인</h3><ul><li><p>스케줄 불가능(unschedulable)으로 표시하고 워크로드를 축출하여 유지 보수할 노드를 준비한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 드레인하는 노드의 이름으로 바꾼다.</span>
</span></span><span style=display:flex><span>kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</span></span></code></pre></div></li></ul><h3 id=kubelet과-kubectl-업그레이드>kubelet과 kubectl 업그레이드</h3><ul><li><p>모든 컨트롤 플레인 노드에서 kubelet 및 kubectl을 업그레이드한다.</p><p><ul class="nav nav-tabs" id=k8s-install-kubelet role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-kubelet-0 role=tab aria-controls=k8s-install-kubelet-0 aria-selected=true>Ubuntu, Debian 또는 HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-kubelet-1 role=tab aria-controls=k8s-install-kubelet-1>CentOS, RHEL 또는 Fedora</a></li></ul><div class=tab-content id=k8s-install-kubelet><div id=k8s-install-kubelet-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-kubelet-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># replace x in 1.25.x-00의 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>apt-mark unhold kubelet kubectl <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b8860b>kubelet</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#b8860b>kubectl</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-mark hold kubelet kubectl
</span></span></code></pre></div></div><div id=k8s-install-kubelet-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-kubelet-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-0에서 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>yum install -y kubelet-1.25.x-0 kubectl-1.25.x-0 --disableexcludes<span style=color:#666>=</span>kubernetes
</span></span></code></pre></div></div></div><br></p></li><li><p>kubelet을 다시 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart kubelet
</span></span></code></pre></div></li></ul><h3 id=노드-uncordon>노드 uncordon</h3><ul><li><p>노드를 스케줄 가능(schedulable)으로 표시하여 노드를 다시 온라인 상태로 전환한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 드레인하려는 노드의 이름으로 바꾼다.</span>
</span></span><span style=display:flex><span>kubectl uncordon &lt;node-to-drain&gt;
</span></span></code></pre></div></li></ul><h2 id=워커-노드-업그레이드>워커 노드 업그레이드</h2><p>워커 노드의 업그레이드 절차는 워크로드를 실행하는 데 필요한 최소 용량을 보장하면서,
한 번에 하나의 노드 또는 한 번에 몇 개의 노드로 실행해야 한다.</p><h3 id=kubeadm-업그레이드>kubeadm 업그레이드</h3><ul><li><p>모든 워커 노드에서 kubeadm을 업그레이드한다.</p><ul class="nav nav-tabs" id=k8s-install-kubeadm-worker-nodes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-kubeadm-worker-nodes-0 role=tab aria-controls=k8s-install-kubeadm-worker-nodes-0 aria-selected=true>Ubuntu, Debian 또는 HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-kubeadm-worker-nodes-1 role=tab aria-controls=k8s-install-kubeadm-worker-nodes-1>CentOS, RHEL 또는 Fedora</a></li></ul><div class=tab-content id=k8s-install-kubeadm-worker-nodes><div id=k8s-install-kubeadm-worker-nodes-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-kubeadm-worker-nodes-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-00의 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>apt-mark unhold kubeadm <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b8860b>kubeadm</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-mark hold kubeadm
</span></span></code></pre></div></div><div id=k8s-install-kubeadm-worker-nodes-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-kubeadm-worker-nodes-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-0에서 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>yum install -y kubeadm-1.25.x-0 --disableexcludes<span style=color:#666>=</span>kubernetes
</span></span></code></pre></div></div></div></li></ul><h3 id=kubeadm-upgrade-호출-1>"kubeadm upgrade" 호출</h3><ul><li><p>워커 노드의 경우 로컬 kubelet 구성을 업그레이드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm upgrade node
</span></span></code></pre></div></li></ul><h3 id=노드-드레인-1>노드 드레인</h3><ul><li><p>스케줄 불가능(unschedulable)으로 표시하고 워크로드를 축출하여 유지 보수할 노드를 준비한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 드레인하려는 노드 이름으로 바꾼다.</span>
</span></span><span style=display:flex><span>kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</span></span></code></pre></div></li></ul><h3 id=kubelet과-kubectl-업그레이드-1>kubelet과 kubectl 업그레이드</h3><ul><li><p>kubelet 및 kubectl을 업그레이드한다.</p><p><ul class="nav nav-tabs" id=k8s-kubelet-and-kubectl role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-kubelet-and-kubectl-0 role=tab aria-controls=k8s-kubelet-and-kubectl-0 aria-selected=true>Ubuntu, Debian 또는 HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-kubelet-and-kubectl-1 role=tab aria-controls=k8s-kubelet-and-kubectl-1>CentOS, RHEL 또는 Fedora</a></li></ul><div class=tab-content id=k8s-kubelet-and-kubectl><div id=k8s-kubelet-and-kubectl-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-kubelet-and-kubectl-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-00의 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>apt-mark unhold kubelet kubectl <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b8860b>kubelet</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#b8860b>kubectl</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-mark hold kubelet kubectl
</span></span></code></pre></div></div><div id=k8s-kubelet-and-kubectl-1 class=tab-pane role=tabpanel aria-labelledby=k8s-kubelet-and-kubectl-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-0에서 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>yum install -y kubelet-1.25.x-0 kubectl-1.25.x-0 --disableexcludes<span style=color:#666>=</span>kubernetes
</span></span></code></pre></div></div></div><br></p></li><li><p>kubelet을 다시 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart kubelet
</span></span></code></pre></div></li></ul><h3 id=노드에-적용된-cordon-해제>노드에 적용된 cordon 해제</h3><ul><li>스케줄 가능(schedulable)으로 표시하여 노드를 다시 온라인 상태로 만든다.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 노드의 이름으로 바꾼다.</span>
</span></span><span style=display:flex><span>kubectl uncordon &lt;node-to-drain&gt;
</span></span></code></pre></div><h2 id=클러스터-상태-확인>클러스터 상태 확인</h2><p>모든 노드에서 kubelet을 업그레이드한 후 kubectl이 클러스터에 접근할 수 있는 곳에서 다음의 명령을 실행하여
모든 노드를 다시 사용할 수 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><p>모든 노드에 대해 <code>STATUS</code> 열에 <code>Ready</code> 가 표시되어야 하고, 버전 번호가 업데이트되어 있어야 한다.</p><h2 id=장애-상태에서의-복구>장애 상태에서의 복구</h2><p>예를 들어 <code>kubeadm upgrade</code> 를 실행하는 중에 예기치 못한 종료로 인해 업그레이드가 실패하고 롤백하지 않는다면, <code>kubeadm upgrade</code> 를 다시 실행할 수 있다.
이 명령은 멱등성을 보장하며 결국 실제 상태가 선언한 의도한 상태인지 확인한다.</p><p>잘못된 상태에서 복구하기 위해, 클러스터가 실행 중인 버전을 변경하지 않고 <code>kubeadm upgrade apply --force</code> 를 실행할 수도 있다.</p><p>업그레이드하는 동안 kubeadm은 <code>/etc/kubernetes/tmp</code> 아래에 다음과 같은 백업 폴더를 작성한다.</p><ul><li><code>kubeadm-backup-etcd-&lt;date>-&lt;time></code></li><li><code>kubeadm-backup-manifests-&lt;date>-&lt;time></code></li></ul><p><code>kubeadm-backup-etcd</code> 는 컨트롤 플레인 노드에 대한 로컬 etcd 멤버 데이터의 백업을 포함한다.
etcd 업그레이드가 실패하고 자동 롤백이 작동하지 않으면, 이 폴더의 내용을
<code>/var/lib/etcd</code> 에서 수동으로 복원할 수 있다. 외부 etcd를 사용하는 경우 이 백업 폴더는 비어있다.</p><p><code>kubeadm-backup-manifests</code> 는 컨트롤 플레인 노드에 대한 정적 파드 매니페스트 파일의 백업을 포함한다.
업그레이드가 실패하고 자동 롤백이 작동하지 않으면, 이 폴더의 내용을
<code>/etc/kubernetes/manifests</code> 에서 수동으로 복원할 수 있다. 어떤 이유로 특정 컴포넌트의 업그레이드 전
매니페스트 파일과 업그레이드 후 매니페스트 파일 간에 차이가 없는 경우, 백업 파일은 기록되지 않는다.</p><h2 id=작동-원리>작동 원리</h2><p><code>kubeadm upgrade apply</code> 는 다음을 수행한다.</p><ul><li>클러스터가 업그레이드 가능한 상태인지 확인한다.<ul><li>API 서버에 접근할 수 있다</li><li>모든 노드가 <code>Ready</code> 상태에 있다</li><li>컨트롤 플레인이 정상적으로 동작한다</li></ul></li><li>버전 차이(skew) 정책을 적용한다.</li><li>컨트롤 플레인 이미지가 사용 가능한지 또는 머신으로 가져올 수 있는지 확인한다.</li><li>컴포넌트 구성에 버전 업그레이드가 필요한 경우 대체 구성을 생성하거나 사용자가 제공한 것으로 덮어 쓰기한다.</li><li>컨트롤 플레인 컴포넌트 또는 롤백 중 하나라도 나타나지 않으면 업그레이드한다.</li><li>새로운 <code>CoreDNS</code> 와 <code>kube-proxy</code> 매니페스트를 적용하고 필요한 모든 RBAC 규칙이 생성되도록 한다.</li><li>API 서버의 새 인증서와 키 파일을 작성하고 180일 후에 만료될 경우 이전 파일을 백업한다.</li></ul><p><code>kubeadm upgrade node</code> 는 추가 컨트롤 플레인 노드에서 다음을 수행한다.</p><ul><li>클러스터에서 kubeadm <code>ClusterConfiguration</code> 을 가져온다.</li><li>선택적으로 kube-apiserver 인증서를 백업한다.</li><li>컨트롤 플레인 컴포넌트에 대한 정적 파드 매니페스트를 업그레이드한다.</li><li>이 노드의 kubelet 구성을 업그레이드한다.</li></ul><p><code>kubeadm upgrade node</code> 는 워커 노드에서 다음을 수행한다.</p><ul><li>클러스터에서 kubeadm <code>ClusterConfiguration</code> 을 가져온다.</li><li>이 노드의 kubelet 구성을 업그레이드한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e805c7d8d4ad6195cb82dbbc843bfc29>1.3 - 윈도우 노드 업그레이드</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [beta]</code></div><p>이 페이지는 <a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadm으로 생성된</a> 윈도우 노드를 업그레이드하는 방법을 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: 1.17.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><ul><li><a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade>남은 kubeadm 클러스터를 업그레이드하는 프로세스</a>에
익숙해져야 한다. 윈도우 노드를
업그레이드하기 전에 컨트롤 플레인 노드를 업그레이드해야 한다.</li></ul><h2 id=워커-노드-업그레이드>워커 노드 업그레이드</h2><h3 id=kubeadm-업그레이드>kubeadm 업그레이드</h3><ol><li><p>윈도우 노드에서, kubeadm을 업그레이드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#080;font-style:italic># v1.25.0을 사용 중인 쿠버네티스 버전으로 변경한다.</span>
</span></span><span style=display:flex><span>curl.exe -Lo &lt;kubeadm.exe<span>을</span> <span>저장할</span> <span>경로</span>&gt; <span style=color:#b44>&#34;https://dl.k8s.io/v1.25.0/bin/windows/amd64/kubeadm.exe&#34;</span>
</span></span></code></pre></div></li></ol><h3 id=노드-드레인>노드 드레인</h3><ol><li><p>쿠버네티스 API에 접근할 수 있는 머신에서,
스케줄 불가능한 것으로 표시하고 워크로드를 축출하여 유지 보수할 노드를 준비한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 드레이닝하려는 노드 이름으로 바꾼다</span>
</span></span><span style=display:flex><span>kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</span></span></code></pre></div><p>다음과 비슷한 출력이 표시되어야 한다.</p><pre tabindex=0><code>node/ip-172-31-85-18 cordoned
node/ip-172-31-85-18 drained
</code></pre></li></ol><h3 id=kubelet-구성-업그레이드>kubelet 구성 업그레이드</h3><ol><li><p>윈도우 노드에서, 다음의 명령을 호출하여 새 kubelet 구성을 동기화한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>kubeadm upgrade node
</span></span></code></pre></div></li></ol><h3 id=kubelet-및-kube-proxy-업그레이드>kubelet 및 kube-proxy 업그레이드</h3><ol><li><p>윈도우 노드에서, kubelet을 업그레이드하고 다시 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>stop-service</span> kubelet
</span></span><span style=display:flex><span>curl.exe -Lo &lt;kubelet.exe<span>을</span> <span>저장할</span> <span>경로</span>&gt; <span style=color:#b44>&#34;https://dl.k8s.io/v1.25.0/bin/windows/amd64/kubelet.exe&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>restart-service</span> kubelet
</span></span></code></pre></div></li><li><p>윈도우 노드에서, kube-proxy를 업그레이드하고 다시 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>stop-service</span> <span style=color:#a2f>kube-proxy</span>
</span></span><span style=display:flex><span>curl.exe -Lo &lt;<span style=color:#a2f>kube-proxy</span>.exe<span>을</span> <span>저장할</span> <span>경로</span>&gt; <span style=color:#b44>&#34;https://dl.k8s.io/v1.25.0/bin/windows/amd64/kube-proxy.exe&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>restart-service</span> <span style=color:#a2f>kube-proxy</span>
</span></span></code></pre></div></li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 만약 kube-proxy를 윈도우 서비스로 실행중이지 않고 파드 내의 HostProcess 컨테이너에서 실행중이라면, 새로운 버전의 kube-proxy 매니페스트를 적용함으로써 업그레이드할 수 있다.</div><h3 id=노드에-적용된-cordon-해제>노드에 적용된 cordon 해제</h3><ol><li><p>쿠버네티스 API에 접근할 수 있는 머신에서,
스케줄 가능으로 표시하여 노드를 다시 온라인으로 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 노드의 이름으로 바꾼다</span>
</span></span><span style=display:flex><span>kubectl uncordon &lt;node-to-drain&gt;
</span></span></code></pre></div></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-adb6c52e773f4d890595e14a9251f59b>2 - 도커심으로부터 마이그레이션</h1><p>이 섹션은 도커심에서 다른 컨테이너 런타임으로
마이그레이션할 때에 알아야 할 정보를 제공한다.</p><p>쿠버네티스 1.20에서의 <a href=/blog/2020/12/08/kubernetes-1-20-release-announcement/#dockershim-deprecation>도커심 사용 중단(deprecation)</a> 발표 이후,
이것이 다양한 워크로드와 쿠버네티스 설치에
어떻게 영향을 미칠지에 대한 질문이 많았다. <a href=/blog/2022/02/17/dockershim-faq/>도커심 제거 FAQ</a>는
관련된 문제를 더 잘 이해할 수 있도록 도움을 준다.</p><p>도커심은 쿠버네티스 릴리스 v1.24부터 제거되었다.
컨테이너 런타임으로 도커 엔진을 통한 도커심을 사용하는 상황에서 v1.24로
업그레이드하려는 경우, 다른 런타임으로 마이그레이션하거나 다른 방법을 찾아 도커 엔진 지원을 받는 것이 좋다.
선택 가능한 옵션은 <a href=/ko/docs/setup/production-environment/container-runtimes/>컨테이너 런타임</a> 섹션에서 확인한다.
마이그레이션 중 문제를 마주한다면
<a href=https://github.com/kubernetes/kubernetes/issues>문제를 보고</a>하면 좋다. 이를 통해 문제를 시기적절하게
해결할 수 있으며, 클러스터도 도커심 제거에
대비할 수 있다.</p><p>클러스터는 두 종류 이상의 노드들을 포함할 수 있지만
이는 일반적인 구성은 아니다.</p><p>다음 작업을 통해 마이그레이션을 수행할 수 있다.</p><ul><li><a href=/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-removal-affects-you/>도커심 제거가 당신에게 영향을 미치는지 확인하기</a></li><li><a href=/docs/tasks/administer-cluster/migrating-from-dockershim/migrate-dockershim-dockerd/>도커 엔진 노드를 도커심에서 cri-dockerd로 마이그레이션하기</a></li><li><a href=/docs/tasks/administer-cluster/migrating-from-dockershim/migrating-telemetry-and-security-agents/>도커심으로부터 보안 및 텔레메트리 에이전트 마이그레이션하기</a></li></ul><h2 id=다음-내용>다음 내용</h2><ul><li>컨테이너 런타임에 대한 옵션을 이해하기 위해
<a href=/ko/docs/setup/production-environment/container-runtimes/>컨테이너 런타임</a>을 확인한다.</li></ul><ul><li>도커심의
사용 중단 및 제거에 대한 논의를 추적하는
<a href=https://github.com/kubernetes/kubernetes/issues/106917>깃허브 이슈</a>가 있다.</li><li>도커심에서 마이그레이션하는 것에 관한
결함이나 다른 기술적 문제를 발견한다면,
쿠버네티스 프로젝트에 <a href=https://github.com/kubernetes/kubernetes/issues/new/choose>이슈를 남길 수 있다.</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d81ef0973a7bb4813e1797a452864742>2.1 - 도커 엔진 노드를 도커심에서 cri-dockerd로 마이그레이션하기</h1><div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div><p>이 페이지는 도커 엔진 노드가 도커심 대신 <code>cri-dockerd</code>를 사용하도록 마이그레이션하는 방법을 보여 준다.
다음 시나리오에서는 아래 단계를 따라야 한다.</p><ul><li>도커심 사용은 중단하고 싶지만,
쿠버네티스의 컨테이너 실행에는 여전히 도커 엔진을 사용하기를 원하는 경우</li><li>쿠버네티스 버전 v1.25로 업그레이드를 원하고
기존 클러스터가 도커심을 사용하는 경우.
이러한 경우에는 도커심을 다른 것으로 대체해야 하며 <code>cri-dockerd</code>도 선택지 중 하나이다.</li></ul><p>도커심 제거에 관하여 더 배우려면, <a href=/dockershim>FAQ page</a>를 읽어보자.</p><h2 id=what-is-cri-dockerd>cri-dockerd란 무엇인가?</h2><p>쿠버네티스 1.23 이하에서는 <em>도커심</em> 이라는 이름의 쿠버네티스 내장 구성요소를 사용하여
도커 엔진을 쿠버네티스 컨테이너 런타임으로 사용할 수 있었다.
도커심 구성 요소는 쿠버네티스 1.24 릴리스에서 제거되었지만,
대신 서드 파티 대체제 <code>cri-dockerd</code>를 사용할 수 있다.
<code>cri-dockerd</code> 어댑터를 사용하면 <a class=glossary-tooltip title='Kubelet과 컨테이너 런타임을 통합시키기 위한 API' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%9f%b0%ed%83%80%ec%9e%84 target=_blank aria-label='컨테이너 런타임 인터페이스(Container runtime interface, CRI)'>컨테이너 런타임 인터페이스(Container runtime interface, CRI)</a>를 통해 도커 엔진을 사용할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이미 <code>cri-dockerd</code>를 사용한다면, 도커심 제거에 의한 영향은 받지 않는다.
시작하기 전에, <a href=/docs/tasks/administer-cluster/migrating-from-dockershim/find-out-runtime-you-use/>노드가 도커심을 사용하는지 확인</a>하자.</div><p>컨테이너 런타임으로 도커 엔진을 계속 사용할 수 있도록
<code>cri-dockerd</code>로 마이그레이션하려는 경우
영향을 받는 각각의 노드에 아래 내용을 진행해야 한다.</p><ol><li><code>cri-dockerd</code>를 설치한다.</li><li>노드를 통제(cordon)하고 비운다(drain).</li><li><code>cri-dockerd</code>를 사용하도록 kubelet를 설정한다.</li><li>kubelet을 재시작한다.</li><li>노드가 정상(healthy)인지 확인한다.</li></ol><p>중요하지 않은(non-critical) 노드에서 먼저 테스트한다.</p><p><code>cri-dockerd</code>로 마이그레이션하려는 각 노드에 대해
아래 단계를 수행해야 한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><a href=https://github.com/mirantis/cri-dockerd#build-and-install><code>cri-dockerd</code></a>를
각 노드에 설치하고 시작한다.</li><li><a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>네트워크 플러그인</a>.</li></ul><h2 id=노드의-통제-cordon-와-비우기-drain>노드의 통제(Cordon)와 비우기(drain)</h2><ol><li><p>새로운 파드를 노드에 스케줄링하는 것을 막기 위해 노드를 통제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon &lt;NODE_NAME&gt;
</span></span></code></pre></div><p><code>&lt;NODE_NAME></code> 부분에 노드의 이름을 입력한다.</p></li><li><p>실행 중인 파드를 안전하게 축출하기 위해 노드를 비운다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl drain &lt;NODE_NAME&gt; <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --ignore-daemonsets
</span></span></code></pre></div></li></ol><h2 id=cri-dockerd를-사용하도록-kubelet-설정>cri-dockerd를 사용하도록 kubelet 설정</h2><p>아래의 단계는 kubeadm 도구를 사용하여 생성된 클러스터에 적용된다.
다른 도구를 사용했다면, 해당 도구에 대한 환경 설정 방법을 참고하여
kubelet 환경 설정을 수정해야 한다.</p><ol><li>영향 받는 각 노드의 <code>/var/lib/kubelet/kubeadm-flags.env</code>를 연다.</li><li><code>--container-runtime-endpoint</code> 플래그를
<code>unix:///var/run/cri-dockerd.sock</code>로 수정한다.</li></ol><p>kubeadm 도구는 노드의 소켓을 컨트롤 플레인의 <code>Node</code> 오브젝트의 어노테이션으로 저장한다.
영향을 받는 각 노드의 해당 소켓을 수정하려면 다음을 따른다.</p><ol><li><p><code>Node</code> 오브젝트의 YAML 표현식을 편집한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>/path/to/admin.conf kubectl edit no &lt;NODE_NAME&gt;
</span></span></code></pre></div><p>각 인자는 다음과 같이 입력한다.</p><ul><li><code>/path/to/admin.conf</code>:
kubectl 환경 설정 파일(<code>admin.conf</code>)의 경로.</li><li><code>&lt;NODE_NAME></code>: 수정을 원하는 노드의 이름.</li></ul></li><li><p><code>kubeadm.alpha.kubernetes.io/cri-socket</code>의 값
<code>/var/run/dockershim.sock</code>을 <code>unix:///var/run/cri-dockerd.sock</code>로 변경한다.</p></li><li><p>변경을 저장한다. <code>Node</code> 오브젝트는 저장 시 업데이트된다.</p></li></ol><h2 id=kubelet-재시작>kubelet 재시작</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>systemctl restart kubelet
</span></span></code></pre></div><h2 id=노드가-정상-healthy-인지-확인>노드가 정상(healthy)인지 확인</h2><p>노드가 <code>cri-dockerd</code> 엔드포인트를 사용하는지 확인하려면,
<a href=/docs/tasks/administer-cluster/migrating-from-dockershim/find-out-runtime-you-use/>사용 런타임 찾기</a> 지침을 따른다.
kubelet의 <code>--container-runtime-endpoint</code> 플래그는 <code>unix:///var/run/cri-dockerd.sock</code> 이어야 한다.</p><h2 id=노드-통제-해제-uncordon>노드 통제 해제(Uncordon)</h2><p>노드에 파드를 스케줄 하도록 통제를 해제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl uncordon &lt;NODE_NAME&gt;
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/dockershim/>도커심 제거 FAQ</a> 읽기.</li><li><a href=/docs/tasks/administer-cluster/migrating-from-dockershim/change-runtime-containerd/>도커 엔진의 도커심을 containerd로 마이그레이션하는 방법 알아보기</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-47be5dd51f686017f1766e6ec7aa6f41>3 - 메모리, CPU 와 API 리소스 관리</h1></div><div class=td-content><h1 id=pg-337620c76587e4aeb32009cb23be46de>3.1 - 네임스페이스에 대한 기본 메모리 요청량과 상한 구성</h1><div class=lead>한 네임스페이스에 메모리 리소스 상한의 기본값을 정의하며, 이를 통해 미리 설정한 메모리 리소스 상한이 해당 네임스페이스의 새로운 파드에 설정되도록 한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에 대한
기본 메모리 요청량(request) 및 상한(limit)을 구성하는 방법을 보여준다.</p><p>쿠버네티스 클러스터를 여러 네임스페이스로 나눌 수 있다.
기본 메모리 <a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EC%9A%94%EC%B2%AD-%EB%B0%8F-%EC%A0%9C%ED%95%9C>상한</a>이
설정되어 있는 네임스페이스에 파드를 생성했는데,
해당 파드의 모든 컨테이너에 메모리 상한이 명시되어 있지 않다면,
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>이
해당 컨테이너에
기본 메모리 상한을 할당한다.</p><p>쿠버네티스는 이 문서의 뒷부분에서 설명하는 특정 조건에서 기본 메모리 요청량을 할당한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><p>클러스터의 각 노드에는 최소 2GiB의 메모리가 있어야 한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 연습에서 생성한 리소스가 클러스터의 다른 리소스와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace default-mem-example
</span></span></code></pre></div><h2 id=리밋레인지-limitrange-와-파드-생성>리밋레인지(LimitRange)와 파드 생성</h2><p>다음은 예시 <a class=glossary-tooltip title='네임스페이스 내에 컨테이너나 파드당 리소스 소비를 한정하는 제약 조건을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/limit-range/ target=_blank aria-label=리밋레인지>리밋레인지</a>에 대한 매니페스트이다.
이 매니페스트는 기본 메모리 요청량 및
기본 메모리 상한을 지정한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-defaults.yaml download=admin/resource/memory-defaults.yaml><code>admin/resource/memory-defaults.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-defaults-yaml")' title="Copy admin/resource/memory-defaults.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-defaults-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-limit-range<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>default</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>512Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultRequest</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>256Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>default-mem-example 네임스페이스에 리밋레인지를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults.yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>이제 파드를 <code>default-mem-example</code> 네임스페이스에 생성하고,
해당 파드의 어떤 컨테이너도 자체 메모리 요청량(request)과 상한(limit)을 명시하지 않으면,
컨트롤 플레인이 해당 컨테이너에 메모리 요청량의 기본값(256 MiB)과
상한의 기본값(512 MiB)을 지정한다.</p><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
해당 컨테이너는 메모리 요청량과 상한을 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-defaults-pod.yaml download=admin/resource/memory-defaults-pod.yaml><code>admin/resource/memory-defaults-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-defaults-pod-yaml")' title="Copy admin/resource/memory-defaults-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-defaults-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod.yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod default-mem-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>출력 결과는 파드의 컨테이너에 256MiB의 메모리 요청량과
512MiB의 메모리 상한이 있음을 나타낸다. 이것은 리밋레인지에 의해 지정된 기본값이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>containers:
</span></span><span style=display:flex><span>- image: nginx
</span></span><span style=display:flex><span>  imagePullPolicy: Always
</span></span><span style=display:flex><span>  name: default-mem-demo-ctr
</span></span><span style=display:flex><span>  resources:
</span></span><span style=display:flex><span>    limits:
</span></span><span style=display:flex><span>      memory: 512Mi
</span></span><span style=display:flex><span>    requests:
</span></span><span style=display:flex><span>      memory: 256Mi
</span></span></code></pre></div><p>파드를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod default-mem-demo --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><h2 id=컨테이너-상한은-지정하고-요청량을-지정하지-않으면-어떻게-되나>컨테이너 상한은 지정하고, 요청량을 지정하지 않으면 어떻게 되나?</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
해당 컨테이너는 메모리 상한은 지정하지만, 요청량은 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-defaults-pod-2.yaml download=admin/resource/memory-defaults-pod-2.yaml><code>admin/resource/memory-defaults-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-defaults-pod-2-yaml")' title="Copy admin/resource/memory-defaults-pod-2.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-defaults-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1Gi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod-2.yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod default-mem-demo-2 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>출력 결과는 컨테이너의 메모리 요청량이 메모리 상한과 일치하도록 설정되었음을 보여준다.
참고로 컨테이너에는 기본 메모리 요청량의 값인 256Mi가 할당되지 않았다.</p><pre tabindex=0><code>resources:
  limits:
    memory: 1Gi
  requests:
    memory: 1Gi
</code></pre><h2 id=컨테이너의-요청량은-지정하고-상한을-지정하지-않으면-어떻게-되나>컨테이너의 요청량은 지정하고, 상한을 지정하지 않으면 어떻게 되나?</h2><p>다음은 컨테이너가 하나인 파드의 예시 매니페스트이다.
해당 컨테이너는 메모리 요청량은 지정하지만, 상한은 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-defaults-pod-3.yaml download=admin/resource/memory-defaults-pod-3.yaml><code>admin/resource/memory-defaults-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-defaults-pod-3-yaml")' title="Copy admin/resource/memory-defaults-pod-3.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-defaults-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod-3.yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>파드 사양을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod default-mem-demo-3 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>출력을 보면 컨테이너의 매니페스트에 명시한 값대로 컨테이너의 메모리 요청량이 설정된 것을 알 수 있다.
해당 컨테이너의 메모리 상한은 512 MiB로 설정되며,
이는 네임스페이스의 메모리 상한 기본값과 일치한다.</p><pre tabindex=0><code>resources:
  limits:
    memory: 512Mi
  requests:
    memory: 128Mi
</code></pre><h2 id=기본-메모리-상한-및-요청량에-대한-동기>기본 메모리 상한 및 요청량에 대한 동기</h2><p>네임스페이스에 <a class=glossary-tooltip title='네임스페이스당 전체 리소스 소비를 제한하는 제약을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/resource-quotas/ target=_blank aria-label='리소스 쿼터'>리소스 쿼터</a>가
설정되어 있는 경우,
메모리 상한에 기본값을 설정하는 것이 좋다.
다음은 리소스 쿼터가 네임스페이스에 적용하는 세 가지 제한 사항이다.</p><ul><li>네임스페이스에서 실행되는 모든 파드에 대해, 모든 컨테이너에 메모리 상한이 있어야 한다.
(파드의 모든 컨테이너에 대해 메모리 상한을 지정하면,
쿠버네티스가 파드 내의 컨테이너의 상한을 합산하여 파드-수준 메모리 상한을 추론할 수 있다.)</li><li>메모리 상한은 해당 파드가 스케줄링될 노드에 리소스 예약을 적용한다.
해당 네임스페이스의 모든 파드에 대해 예약된 메모리 총량이 지정된 상한을 초과하지 않아야 한다.</li><li>해당 네임스페이스의 모든 파드가 실제로 사용하고 있는 메모리의 총량 또한 지정된 상한을 초과하지 않아야 한다.</li></ul><p>리밋레인지를 추가할 때에는 다음을 고려해야 한다.</p><p>컨테이너를 갖고 있는 해당 네임스페이스의 파드가 자체 메모리 상한을 지정하지 않았다면,
컨트롤 플레인이 해당 컨테이너에 메모리 상한 기본값을 적용하며,
해당 파드는 메모리 리소스쿼터가 적용된 네임스페이스에서 실행되도록 허용될 수 있다.</p><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace default-mem-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 대한 파드 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너 및 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-320af95e480962c538ebef7ae205845c>3.2 - 네임스페이스에 대한 기본 CPU 요청량과 상한 구성</h1><div class=lead>한 네임스페이스에 CPU 리소스 상한의 기본값을 정의하며, 이를 통해 미리 설정한 CPU 리소스 상한이 해당 네임스페이스의 새로운 파드에 설정되도록 한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에 대한
기본 CPU 요청량(request) 및 상한(limit)을 구성하는 방법을 보여준다.</p><p>쿠버네티스 클러스터를 여러 네임스페이스로 나눌 수 있다.
기본 CPU <a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EC%9A%94%EC%B2%AD-%EB%B0%8F-%EC%A0%9C%ED%95%9C>상한</a>이
설정되어 있는 네임스페이스에 파드를 생성했는데,
해당 파드의 모든 컨테이너에 CPU 상한이 명시되어 있지 않다면,
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>이
해당 컨테이너에 기본 CPU 상한을 할당한다.</p><p>쿠버네티스는 기본 CPU
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EC%9A%94%EC%B2%AD-%EB%B0%8F-%EC%A0%9C%ED%95%9C>사용량</a>을 할당하는데,
이는 이 페이지의 이후 부분에서 설명될 특정 조건 하에서만 수행된다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><p>쿠버네티스에서 “1.0 CPU”가 무엇을 의미하는지 익숙하지 않다면,
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#cpu%EC%9D%98-%EC%9D%98%EB%AF%B8>CPU의 의미</a>를 참조한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 연습에서 생성한 리소스가 클러스터의 나머지와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace default-cpu-example
</span></span></code></pre></div><h2 id=리밋레인지-limitrange-와-파드-생성>리밋레인지(LimitRange)와 파드 생성</h2><p>다음은 예시 <a class=glossary-tooltip title='네임스페이스 내에 컨테이너나 파드당 리소스 소비를 한정하는 제약 조건을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/limit-range/ target=_blank aria-label=리밋레인지>리밋레인지</a>에 대한 매니페스트이다.
이 매니페스트는 기본 CPU 요청량 및 기본 CPU 상한을 지정한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-defaults.yaml download=admin/resource/cpu-defaults.yaml><code>admin/resource/cpu-defaults.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-defaults-yaml")' title="Copy admin/resource/cpu-defaults.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-defaults-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-limit-range<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>default</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultRequest</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>0.5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>default-cpu-example 네임스페이스에 리밋레인지를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</span></span></code></pre></div><p>이제 파드를 <code>default-cpu-example</code> 네임스페이스에 생성하고,
해당 파드의 어떤 컨테이너도 자체 CPU 요청량(request)과 상한(limit)을 명시하지 않으면,
컨트롤 플레인이 해당 컨테이너에 CPU 요청량의 기본값(0.5)과
상한의 기본값(1)을 지정한다.</p><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
해당 컨테이너는 CPU 요청량과 상한을 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-defaults-pod.yaml download=admin/resource/cpu-defaults-pod.yaml><code>admin/resource/cpu-defaults-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-defaults-pod-yaml")' title="Copy admin/resource/cpu-defaults-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-defaults-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</span></span></code></pre></div><p>파드의 사양을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod default-cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-cpu-example
</span></span></code></pre></div><p>출력을 보면 파드 내 유일한 컨테이너의 CPU 요청량이 500m <code>cpu</code>("500 밀리cpu"로 읽을 수 있음)이고,
CPU 상한이 1 <code>cpu</code>임을 알 수 있다.
이것은 리밋레인지에 의해 지정된 기본값이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>containers:
</span></span><span style=display:flex><span>- image: nginx
</span></span><span style=display:flex><span>  imagePullPolicy: Always
</span></span><span style=display:flex><span>  name: default-cpu-demo-ctr
</span></span><span style=display:flex><span>  resources:
</span></span><span style=display:flex><span>    limits:
</span></span><span style=display:flex><span>      cpu: <span style=color:#b44>&#34;1&#34;</span>
</span></span><span style=display:flex><span>    requests:
</span></span><span style=display:flex><span>      cpu: 500m
</span></span></code></pre></div><h2 id=컨테이너-상한은-지정하고-요청량을-지정하지-않으면-어떻게-되나>컨테이너 상한은 지정하고, 요청량을 지정하지 않으면 어떻게 되나?</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
해당 컨테이너는 CPU 상한은 지정하지만, 요청량은 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-defaults-pod-2.yaml download=admin/resource/cpu-defaults-pod-2.yaml><code>admin/resource/cpu-defaults-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-defaults-pod-2-yaml")' title="Copy admin/resource/cpu-defaults-pod-2.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-defaults-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod-2.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</span></span></code></pre></div><p>생성한 파드의
<a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%AA%85%EC%84%B8-spec-%EC%99%80-%EC%83%81%ED%83%9C-status>명세</a>를 확인한다.</p><pre tabindex=0><code>kubectl get pod default-cpu-demo-2 --output=yaml --namespace=default-cpu-example
</code></pre><p>출력 결과는 컨테이너의 CPU 요청량이 CPU 상한과 일치하도록 설정되었음을 보여준다.
참고로 컨테이너에는 CPU 요청량의 기본값인 0.5 <code>cpu</code>가 할당되지 않았다.</p><pre tabindex=0><code>resources:
  limits:
    cpu: &#34;1&#34;
  requests:
    cpu: &#34;1&#34;
</code></pre><h2 id=컨테이너의-요청량은-지정하고-상한을-지정하지-않으면-어떻게-되나>컨테이너의 요청량은 지정하고, 상한을 지정하지 않으면 어떻게 되나?</h2><p>다음은 컨테이너가 하나인 파드의 예시 매니페스트이다.
해당 컨테이너는 CPU 요청량은 지정하지만, 상한은 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-defaults-pod-3.yaml download=admin/resource/cpu-defaults-pod-3.yaml><code>admin/resource/cpu-defaults-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-defaults-pod-3-yaml")' title="Copy admin/resource/cpu-defaults-pod-3.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-defaults-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0.75&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod-3.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</span></span></code></pre></div><p>생성한 파드의
<a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%AA%85%EC%84%B8-spec-%EC%99%80-%EC%83%81%ED%83%9C-status>명세</a>를 확인한다.</p><pre tabindex=0><code>kubectl get pod default-cpu-demo-3 --output=yaml --namespace=default-cpu-example
</code></pre><p>출력을 보면 파드 생성 시 명시한 값대로
컨테이너의 CPU 요청량이 설정된 것을 알 수 있다(다시 말해, 매니페스트와 일치한다).
그러나, 해당 컨테이너의 CPU 상한은 1 <code>cpu</code>로 설정되며,
이는 네임스페이스의 CPU 상한 기본값이다.</p><pre tabindex=0><code>resources:
  limits:
    cpu: &#34;1&#34;
  requests:
    cpu: 750m
</code></pre><h2 id=cpu-상한-및-요청량의-기본값에-대한-동기>CPU 상한 및 요청량의 기본값에 대한 동기</h2><p>네임스페이스에 <a class=glossary-tooltip title='네임스페이스당 전체 리소스 소비를 제한하는 제약을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/resource-quotas/ target=_blank aria-label='리소스 쿼터'>리소스 쿼터</a>가
설정되어 있는 경우,
CPU 상한에 대해 기본값을 설정하는 것이 좋다.
다음은 CPU 리소스 쿼터가 네임스페이스에 적용하는 두 가지 제한 사항이다.</p><ul><li>네임스페이스에서 실행되는 모든 파드에 대해, 모든 컨테이너에 CPU 상한이 있어야 한다.</li><li>CPU 상한은 해당 파드가 스케줄링될 노드에 리소스 예약을 적용한다.
해당 네임스페이스의 모든 파드에 대해 예약된 CPU 총량이
지정된 상한을 초과하지 않아야 한다.</li></ul><p>리밋레인지를 추가할 때에는 다음을 고려해야 한다.</p><p>컨테이너를 갖고 있는 해당 네임스페이스의 파드가 자체 CPU 상한을 지정하지 않았다면,
컨트롤 플레인이 해당 컨테이너에 CPU 상한 기본값을 적용하며,
해당 파드는 CPU 리소스쿼터가 적용된 네임스페이스에서 실행되도록 허용될 수 있다.</p><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace default-cpu-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 대한 파드 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너 및 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-adb489b1ab985c9215657b0d4c6ae92b>3.3 - 네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</h1><div class=lead>한 네임스페이스 내에서 메모리 리소스 제한의 유효한 범위를 정의하며, 이를 통해 해당 네임스페이스의 새로운 파드가 미리 설정한 범위 안에 들어오도록 한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에서
실행되는 컨테이너가 사용하는 메모리의 최솟값과 최댓값을 설정하는 방법을 보여준다.
<a href=/docs/reference/kubernetes-api/policy-resources/limit-range-v1/>리밋레인지(LimitRange)</a>
오브젝트에 최소 및 최대 메모리 값을
지정한다. 파드가 리밋레인지에 의해 부과된 제약 조건을 충족하지 않으면,
네임스페이스에서 생성될 수 없다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><p>클러스터의 각 노드에는 파드가 사용할 수 있는 메모리가 최소 1GiB 이상 있어야 한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 연습에서 생성한 리소스가 클러스터의 나머지와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace constraints-mem-example
</span></span></code></pre></div><h2 id=리밋레인지와-파드-생성>리밋레인지와 파드 생성</h2><p>다음은 리밋레인지의 예시 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-constraints.yaml download=admin/resource/memory-constraints.yaml><code>admin/resource/memory-constraints.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-yaml")' title="Copy admin/resource/memory-constraints.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-min-max-demo-lr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>500Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>리밋레인지를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>리밋레인지에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get limitrange mem-min-max-demo-lr --namespace<span style=color:#666>=</span>constraints-mem-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력 결과는 예상대로 메모리의 최소 및 최대 제약 조건을 보여준다. 그러나
참고로 리밋레인지의 구성 파일에 기본값(default)을
지정하지 않아도 자동으로 생성된다.</p><pre tabindex=0><code>  limits:
  - default:
      memory: 1Gi
    defaultRequest:
      memory: 1Gi
    max:
      memory: 1Gi
    min:
      memory: 500Mi
    type: Container
</code></pre><p>이제 <code>constraints-mem-example</code> 네임스페이스에 파드를 생성할 때마다,
쿠버네티스는 다음 단계를 수행한다.</p><ul><li><p>해당 파드의 어떤 컨테이너도 자체 메모리 요청량(request)과 상한(limit)을 명시하지 않으면,
컨트롤 플레인이 해당 컨테이너에 메모리 요청량과 상한의 기본값(default)을 지정한다.</p></li><li><p>해당 파드의 모든 컨테이너의 메모리 요청량이 최소 500 MiB 이상인지 확인한다.</p></li><li><p>해당 파드의 모든 컨테이너의 메모리 요청량이 1024 MiB(1 GiB)를 넘지 않는지
확인한다.</p></li></ul><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
파드 명세 내에, 파드의 유일한 컨테이너는 600 MiB의 메모리 요청량 및 800 MiB의 메모리 상한을 지정하고 있다.
이는 리밋레인지에 의해 부과된 최소 및 최대 메모리 제약 조건을 충족시킨다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-constraints-pod.yaml download=admin/resource/memory-constraints-pod.yaml><code>admin/resource/memory-constraints-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-yaml")' title="Copy admin/resource/memory-constraints-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;600Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>파드가 실행 중이고 컨테이너의 상태가 정상인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-mem-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>출력을 보면 파드의 컨테이너의 메모리 요청량이 600 MiB이고 메모리 상한이 800 MiB임을 알 수 있다.
이는 리밋레인지에 의해 해당 네임스페이스에 부과된 제약 조건을
만족시킨다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>800Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>600Mi<span style=color:#bbb>
</span></span></span></code></pre></div><p>파드를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><h2 id=최대-메모리-제약-조건을-초과하는-파드-생성-시도>최대 메모리 제약 조건을 초과하는 파드 생성 시도</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
컨테이너는 800MiB의 메모리 요청량과 1.5GiB의 메모리 상한을 지정하고 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-constraints-pod-2.yaml download=admin/resource/memory-constraints-pod-2.yaml><code>admin/resource/memory-constraints-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-2-yaml")' title="Copy admin/resource/memory-constraints-pod-2.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1.5Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드 생성을 시도한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-2.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>결과를 보면 파드가 생성되지 않은 것을 확인할 수 있으며,
이는 해당 파드가 정의하고 있는 컨테이너가 허용된 것보다 더 많은 메모리를 요청하고 있기 때문이다.</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/memory-constraints-pod-2.yaml&#34;:
pods &#34;constraints-mem-demo-2&#34; is forbidden: maximum memory usage per Container is 1Gi, but limit is 1536Mi.
</code></pre><h2 id=최소-메모리-요청량을-충족하지-않는-파드-생성-시도>최소 메모리 요청량을 충족하지 않는 파드 생성 시도</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
컨테이너는 100MiB의 메모리 요청량과 800MiB의 메모리 상한을 지정하고 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-constraints-pod-3.yaml download=admin/resource/memory-constraints-pod-3.yaml><code>admin/resource/memory-constraints-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-3-yaml")' title="Copy admin/resource/memory-constraints-pod-3.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드 생성을 시도한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-3.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>결과를 보면 파드가 생성되지 않은 것을 확인할 수 있으며,
이는 해당 파드가 정의하고 있는 컨테이너가 지정된 최저 메모리 요청량보다도 낮은 메모리 요청량을 지정하고 있기 때문이다.</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/memory-constraints-pod-3.yaml&#34;:
pods &#34;constraints-mem-demo-3&#34; is forbidden: minimum memory usage per Container is 500Mi, but request is 100Mi.
</code></pre><h2 id=메모리-요청량-또는-상한을-지정하지-않은-파드-생성>메모리 요청량 또는 상한을 지정하지 않은 파드 생성</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
해당 컨테이너는 메모리 요청량과 상한을 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-constraints-pod-4.yaml download=admin/resource/memory-constraints-pod-4.yaml><code>admin/resource/memory-constraints-pod-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-4-yaml")' title="Copy admin/resource/memory-constraints-pod-4.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-4.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-mem-demo-4 --namespace<span style=color:#666>=</span>constraints-mem-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력을 보면 파드의 유일한 컨테이너에 대한 메모리 요청량이 1 GiB이고 메모리 상한도 1 GiB이다.
이 컨테이너는 어떻게 이런 값을 얻었을까?</p><pre tabindex=0><code>resources:
  limits:
    memory: 1Gi
  requests:
    memory: 1Gi
</code></pre><p>파드가 해당 컨테이너에 대해 메모리 요청량과 상한을 지정하지 않았으므로,
클러스터가 리밋레인지로부터
<a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>메모리의 요청량과 상한 기본값</a>을
적용하였다.</p><p>이는 곧 파드 정의에서 이 값들을 볼 수 있음을 의미한다.
<code>kubectl describe</code> 명령을 사용하여 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 출력에서 &#34;Requests:&#34; 섹션을 확인한다</span>
</span></span><span style=display:flex><span>kubectl describe pod constraints-mem-demo-4 --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>이 시점에서, 파드는 실행 중일 수도 있고 아닐 수도 있다. 이 태스크의 전제 조건은
노드에 최소 1GiB의 메모리가 있어야 한다는 것이다. 각 노드에
1GiB의 메모리만 있는 경우, 노드에 할당할 수 있는 메모리가 1GiB의 메모리 요청량을 수용하기에 충분하지
않을 수 있다. 메모리가 2GiB인 노드를 사용하는 경우에는, 메모리가
1GiB 요청량을 수용하기에 충분할 것이다.</p><p>파드를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod constraints-mem-demo-4 --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><h2 id=메모리의-최소-및-최대-제약-조건-적용>메모리의 최소 및 최대 제약 조건 적용</h2><p>리밋레인지에 의해 네임스페이스에 부과된 메모리의 최대 및 최소 제약 조건은
파드를 생성하거나 업데이트할 때만 적용된다. 리밋레인지를 변경해도, 이전에 생성된
파드에는 영향을 미치지 않는다.</p><h2 id=메모리의-최소-및-최대-제약-조건에-대한-동기>메모리의 최소 및 최대 제약 조건에 대한 동기</h2><p>클러스터 관리자는 파드가 사용할 수 있는 메모리 양에 제한을 둘 수 있다.
예를 들면 다음과 같다.</p><ul><li><p>클러스터의 각 노드에는 2GiB의 메모리가 있다. 클러스터의 어떤 노드도 2GiB 이상의 요청량을
지원할 수 없으므로, 2GiB 이상의 메모리를 요청하는 파드를 수락하지 않으려고 한다.</p></li><li><p>클러스터는 운영 부서와 개발 부서에서 공유한다.
프로덕션 워크로드가 최대 8GiB의 메모리를 소비하도록 하려면,
개발 워크로드를 512MiB로 제한해야 한다. 프로덕션 및 개발을 위해
별도의 네임스페이스를 만들고, 각 네임스페이스에 메모리 제약 조건을 적용한다.</p></li></ul><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace constraints-mem-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 대한 파드 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너 및 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a87cbd1f9379dac7a48ae320da68a9ad>3.4 - 네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</h1><div class=lead>한 네임스페이스 내에서 CPU 리소스 제한의 유효한 범위를 정의하며, 이를 통해 해당 네임스페이스의 새로운 파드가 미리 설정한 범위 안에 들어오도록 한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에서
컨테이너와 파드가 사용하는 CPU 리소스의 최솟값과 최댓값을 설정하는 방법을 보여준다.
<a href=/docs/reference/kubernetes-api/policy-resources/limit-range-v1/>리밋레인지(LimitRange)</a> 오브젝트에
CPU의 최솟값과 최댓값을 지정한다.
리밋레인지에 의해 부과된 제약 조건을 파드가 충족하지 않으면,
해당 네임스페이스에 생성될 수 없다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><p>클러스터의 각 노드는 파드 실행을 위해 적어도 1.0 CPU 이상이 사용 가능해야 한다.
쿠버네티스에서 “1 CPU”가 무엇을 의미하는지 알아보려면
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#cpu%EC%9D%98-%EC%9D%98%EB%AF%B8>CPU의 의미</a>를 참조한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 연습에서 생성한 리소스가 클러스터의 나머지와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace constraints-cpu-example
</span></span></code></pre></div><h2 id=리밋레인지와-파드-생성>리밋레인지와 파드 생성</h2><p>다음은 <a class=glossary-tooltip title='네임스페이스 내에 컨테이너나 파드당 리소스 소비를 한정하는 제약 조건을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/limit-range/ target=_blank aria-label=리밋레인지>리밋레인지</a> 예제 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-constraints.yaml download=admin/resource/cpu-constraints.yaml><code>admin/resource/cpu-constraints.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-constraints-yaml")' title="Copy admin/resource/cpu-constraints.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-constraints-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-min-max-demo-lr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>리밋레인지를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>리밋레인지에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get limitrange cpu-min-max-demo-lr --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>출력 결과는 예상대로 CPU의 최소와 최대 제약 조건을 보여준다. 그러나
참고로 리밋레인지에 대한 구성 파일에 기본값을
지정하지 않아도 자동으로 생성된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>default</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultRequest</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>200m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></span></span></code></pre></div><p>이제 <code>constraints-cpu-example</code> 네임스페이스에 파드를 생성할 때마다(또는
다른 쿠버네티스 API 클라이언트가 동일한 파드를 생성할 때마다), 쿠버네티스는 다음 단계를 수행한다.</p><ul><li><p>해당 파드의 어떤 컨테이너도 자체 CPU 요청량(request)과 상한(limit)을 명시하지 않으면,
컨트롤 플레인이 해당 컨테이너에 CPU 요청량과 상한의 기본값(default)을 지정한다.</p></li><li><p>해당 파드의 모든 컨테이너가 200 millicpu 이상의 CPU 요청량을 지정하는지 확인한다.</p></li><li><p>해당 파드의 모든 컨테이너가 800 millicpu 이하의 CPU 상한을 지정하는지 확인한다.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>LimitRange</code> 오브젝트를 생성할 때, huge-pages
또는 GPU에도 상한을 지정할 수 있다. 그러나, 이 리소스들에 <code>default</code> 와 <code>defaultRequest</code> 가
모두 지정되어 있으면, 두 값은 같아야 한다.</div><p>다음은 컨테이너가 하나인 파드의 매니페스트이다. 컨테이너 매니페스트는
500 millicpu의 CPU 요청량 및 800 millicpu의 CPU 상한을 지정하고 있다. 이는 이 네임스페이스의 리밋레인지에
의해 부과된 CPU의 최소와 최대 제약 조건을 충족시킨다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-constraints-pod.yaml download=admin/resource/cpu-constraints-pod.yaml><code>admin/resource/cpu-constraints-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-constraints-pod-yaml")' title="Copy admin/resource/cpu-constraints-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-constraints-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>파드가 실행 중이고 컨테이너의 상태가 정상인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-cpu-demo --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>출력 결과는 파드 내 유일한 컨테이너의 CPU 요청량이 500 millicpu이고, CPU 상한이 800 millicpu임을
나타낸다. 이는 리밋레인지에 의해 부과된 제약 조건을 만족시킨다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=파드-삭제>파드 삭제</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod constraints-cpu-demo --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><h2 id=cpu-최대-제약-조건을-초과하는-파드-생성-시도>CPU 최대 제약 조건을 초과하는 파드 생성 시도</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다. 컨테이너는
500 millicpu의 CPU 요청량과 1.5 cpu의 CPU 상한을 지정하고 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-constraints-pod-2.yaml download=admin/resource/cpu-constraints-pod-2.yaml><code>admin/resource/cpu-constraints-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-constraints-pod-2-yaml")' title="Copy admin/resource/cpu-constraints-pod-2.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-constraints-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1.5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드 생성을 시도한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-2.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>결과를 보면 파드가 생성되지 않은 것을 확인할 수 있으며, 이는 해당 파드가 수용 불가능한 컨테이너를 정의하고 있기 때문이다.
해당 컨테이너가 수용 불가능한 이유는 너무 큰 CPU 상한을 지정하고 있기 때문이다.</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/cpu-constraints-pod-2.yaml&#34;:
pods &#34;constraints-cpu-demo-2&#34; is forbidden: maximum cpu usage per Container is 800m, but limit is 1500m.
</code></pre><h2 id=최소-cpu-요청량을-충족하지-않는-파드-생성-시도>최소 CPU 요청량을 충족하지 않는 파드 생성 시도</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다. 컨테이너는
100 millicpu의 CPU 요청량과 800 millicpu의 CPU 상한을 지정하고 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-constraints-pod-3.yaml download=admin/resource/cpu-constraints-pod-3.yaml><code>admin/resource/cpu-constraints-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-constraints-pod-3-yaml")' title="Copy admin/resource/cpu-constraints-pod-3.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-constraints-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드 생성을 시도한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-3.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>결과를 보면 파드가 생성되지 않은 것을 확인할 수 있으며, 이는 해당 파드가 수용 불가능한 컨테이너를 정의하고 있기 때문이다.
해당 컨테이너가 수용 불가능한 이유는
지정된 최저 CPU 요청량보다도 낮은 CPU 요청량을 지정하고 있기 때문이다.</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/cpu-constraints-pod-3.yaml&#34;:
pods &#34;constraints-cpu-demo-3&#34; is forbidden: minimum cpu usage per Container is 200m, but request is 100m.
</code></pre><h2 id=cpu-요청량-또는-상한을-지정하지-않은-파드-생성>CPU 요청량 또는 상한을 지정하지 않은 파드 생성</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다. 컨테이너는
CPU 요청량을 지정하지 않았으며, CPU 상한도 지정하지 않았다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-constraints-pod-4.yaml download=admin/resource/cpu-constraints-pod-4.yaml><code>admin/resource/cpu-constraints-pod-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-constraints-pod-4-yaml")' title="Copy admin/resource/cpu-constraints-pod-4.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-constraints-pod-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-4-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-4.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><pre tabindex=0><code>kubectl get pod constraints-cpu-demo-4 --namespace=constraints-cpu-example --output=yaml
</code></pre><p>출력을 보면 파드의 유일한 컨테이너에 대한 CPU 요청량이 800 millicpu이고,
CPU 상한이 800 millicpu이다.
이 컨테이너는 어떻게 이런 값을 얻었을까?</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span></code></pre></div><p>컨테이너가 자체 CPU 요청량과 상한을 지정하지 않았으므로,
컨테이너가 이 네임스페이스에 대해 리밋레인지로부터
<a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>CPU 요청량과 상한의 기본값</a>을
적용했다.</p><p>이 시점에서, 파드는 실행 중일 수도 있고 아닐 수도 있다. 이 태스크의 전제 조건은
노드에 1 CPU 이상 사용 가능해야 한다는 것이다. 각 노드에 1 CPU만 있는 경우,
노드에 할당할 수 있는 CPU가 800 millicpu의 요청량을 수용하기에 충분하지 않을 수 있다.
2 CPU인 노드를 사용하는 경우에는, CPU가 800 millicpu 요청량을 수용하기에 충분할 것이다.</p><p>파드를 삭제한다.</p><pre tabindex=0><code>kubectl delete pod constraints-cpu-demo-4 --namespace=constraints-cpu-example
</code></pre><h2 id=cpu의-최소-및-최대-제약-조건의-적용>CPU의 최소 및 최대 제약 조건의 적용</h2><p>리밋레인지에 의해 네임스페이스에 부과된 CPU의 최대 및 최소 제약 조건은
파드를 생성하거나 업데이트할 때만 적용된다. 리밋레인지를 변경해도, 이전에 생성된 파드에는
영향을 미치지 않는다.</p><h2 id=cpu의-최소-및-최대-제약-조건에-대한-동기>CPU의 최소 및 최대 제약 조건에 대한 동기</h2><p>클러스터 관리자는 파드가 사용할 수 있는 CPU 리소스에 제한을 둘 수 있다.
예를 들면 다음과 같다.</p><ul><li><p>클러스터의 각 노드에는 2 CPU가 있다. 클러스터의 어떤 노드도 요청량을 지원할 수 없기 때문에,
2 CPU 이상을 요청하는 파드를 수락하지 않으려고 한다.</p></li><li><p>클러스터는 프로덕션과 개발 부서에서 공유한다.
프로덕션 워크로드가 최대 3 CPU를 소비하도록 하고 싶지만, 개발 워크로드는 1 CPU로
제한하려고 한다. 프로덕션과 개발을 위해 별도의 네임스페이스를 생성하고, 각 네임스페이스에 CPU 제약 조건을
적용한다.</p></li></ul><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace constraints-cpu-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 대한 파드 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너와 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fe3283559a3df299aae3ee00ecea2fad>3.5 - 네임스페이스에 대한 메모리 및 CPU 쿼터 구성</h1><div class=lead>한 네임스페이스에 대한 총 메모리 및 CPU 자원 상한을 정의한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에서
실행 중인 모든 파드가 사용할 수 있는
총 메모리 및 CPU 양에 대한 쿼터를 설정하는 방법을 보여준다.
<a href=/docs/reference/kubernetes-api/policy-resources/resource-quota-v1/>리소스쿼터(ResourceQuota)</a> 오브젝트에
쿼터를 지정할 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><p>클러스터의 각 노드에는 최소 1GiB의 메모리가 있어야 한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 연습에서 생성한 리소스가 클러스터의 나머지와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace quota-mem-cpu-example
</span></span></code></pre></div><h2 id=리소스쿼터-생성>리소스쿼터 생성</h2><p>다음은 예시 리소스쿼터 오브젝트에 대한 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/quota-mem-cpu.yaml download=admin/resource/quota-mem-cpu.yaml><code>admin/resource/quota-mem-cpu.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-quota-mem-cpu-yaml")' title="Copy admin/resource/quota-mem-cpu.yaml to clipboard"></img></div><div class=includecode id=admin-resource-quota-mem-cpu-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-cpu-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests.cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests.memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limits.cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limits.memory</span>:<span style=color:#bbb> </span>2Gi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>리소스쿼터를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu.yaml --namespace<span style=color:#666>=</span>quota-mem-cpu-example
</span></span></code></pre></div><p>리소스쿼터에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get resourcequota mem-cpu-demo --namespace<span style=color:#666>=</span>quota-mem-cpu-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>리소스쿼터는 이러한 요구 사항을 quota-mem-cpu-example 네임스페이스에 배치한다.</p><ul><li>네임스페이스의 모든 파드에 대해, 각 컨테이너에는 메모리 요청량(request), 메모리 상한(limit), CPU 요청량 및 CPU 상한이 있어야 한다.</li><li>네임스페이스의 모든 파드에 대한 총 메모리 요청량은 1GiB를 초과하지 않아야 한다.</li><li>네임스페이스의 모든 파드에 대한 총 메모리 상한은 2GiB를 초과하지 않아야 한다.</li><li>네임스페이스의 모든 파드에 대한 총 CPU 요청량은 1 cpu를 초과해서는 안된다.</li><li>네임스페이스의 모든 파드에 대한 총 CPU 상한은 2 cpu를 초과해서는 안된다.</li></ul><p>쿠버네티스에서 “1 CPU”가 무엇을 의미하는지 알아보려면
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#cpu%EC%9D%98-%EC%9D%98%EB%AF%B8>CPU의 의미</a>를 참조한다.</p><h2 id=파드-생성>파드 생성</h2><p>다음은 예시 파드에 대한 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/quota-mem-cpu-pod.yaml download=admin/resource/quota-mem-cpu-pod.yaml><code>admin/resource/quota-mem-cpu-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-quota-mem-cpu-pod-yaml")' title="Copy admin/resource/quota-mem-cpu-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-quota-mem-cpu-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;600Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;400m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu-pod.yaml --namespace<span style=color:#666>=</span>quota-mem-cpu-example
</span></span></code></pre></div><p>파드가 실행 중이고 파드의 (유일한) 컨테이너의 상태가 정상인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod quota-mem-cpu-demo --namespace<span style=color:#666>=</span>quota-mem-cpu-example
</span></span></code></pre></div><p>다시 한 번, 리소스쿼터에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get resourcequota mem-cpu-demo --namespace<span style=color:#666>=</span>quota-mem-cpu-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력 결과는 쿼터와 사용된 쿼터를 함께 보여준다.
파드의 메모리와 CPU 요청량 및 상한이 쿼터를 초과하지 않은 것을
볼 수 있다.</p><pre tabindex=0><code>status:
  hard:
    limits.cpu: &#34;2&#34;
    limits.memory: 2Gi
    requests.cpu: &#34;1&#34;
    requests.memory: 1Gi
  used:
    limits.cpu: 800m
    limits.memory: 800Mi
    requests.cpu: 400m
    requests.memory: 600Mi
</code></pre><p><code>jq</code> 도구가 설치되어 있으면, (<a href=/ko/docs/reference/kubectl/jsonpath/>JSONPath</a>를 사용하여) <code>used</code> 값만을 질의 <strong>하고</strong>,
정돈된 상태로 출력할 수 있다. 예시는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get resourcequota mem-cpu-demo --namespace<span style=color:#666>=</span>quota-mem-cpu-example -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{ .status.used }&#39;</span> | jq .
</span></span></code></pre></div><h2 id=두-번째-파드-생성-시도>두 번째 파드 생성 시도</h2><p>다음은 두 번째 파드에 대한 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/quota-mem-cpu-pod-2.yaml download=admin/resource/quota-mem-cpu-pod-2.yaml><code>admin/resource/quota-mem-cpu-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-quota-mem-cpu-pod-2-yaml")' title="Copy admin/resource/quota-mem-cpu-pod-2.yaml to clipboard"></img></div><div class=includecode id=admin-resource-quota-mem-cpu-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;400m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>매니페스트에서, 파드의 메모리 요청량이 700MiB임을 알 수 있다.
사용된 메모리 요청량과 이 새 메모리 요청량의 합계가
메모리 요청량 쿼터를 초과함에 유의한다(600 MiB + 700 MiB > 1 GiB).</p><p>파드 생성을 시도한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu-pod-2.yaml --namespace<span style=color:#666>=</span>quota-mem-cpu-example
</span></span></code></pre></div><p>두 번째 파드는 생성되지 않는다. 출력 결과는 두 번째 파드를 생성하면
메모리 요청량의 총 합계가 메모리 요청량 쿼터를 초과함을 보여준다.</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/quota-mem-cpu-pod-2.yaml&#34;:
pods &#34;quota-mem-cpu-demo-2&#34; is forbidden: exceeded quota: mem-cpu-demo,
requested: requests.memory=700Mi,used: requests.memory=600Mi, limited: requests.memory=1Gi
</code></pre><h2 id=토론>토론</h2><p>이 연습에서 보았듯이, 리소스쿼터를 사용하여
네임스페이스에서 실행 중인 모든 파드에 대한 메모리 요청량의 총 합계를 제한할 수 있다.
메모리 상한, CPU 요청량 및 CPU 상한의 총 합계를 제한할 수도 있다.</p><p>네임스페이스 내의 총 자원을 관리하는 것 대신,
개별 파드 또는 파드 내의 컨테이너별로 제한하고 싶을 수도 있다.
이러한 종류의 제한을 걸려면, <a href=/ko/docs/concepts/policy/limit-range/>리밋레인지(LimitRange)</a>를 사용한다.</p><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace quota-mem-cpu-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 대한 파드 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너 및 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-40e30a9209e0c9f4153707e43243e9d7>3.6 - 네임스페이스에 대한 파드 쿼터 구성</h1><div class=lead>한 네임스페이스 내에 만들 수 있는 파드의 수를 제한한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에서 실행할 수 있는 총 파드 수에 대한 쿼터를
설정하는 방법을 보여준다.
<a href=/docs/reference/kubernetes-api/policy-resources/resource-quota-v1/>리소스쿼터(ResourceQuota)</a> 오브젝트에
쿼터를 지정할 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 실습에서 생성한 리소스가 클러스터의 나머지와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace quota-pod-example
</span></span></code></pre></div><h2 id=리소스쿼터-생성>리소스쿼터 생성</h2><p>다음은 예시 리소스쿼터 오브젝트에 대한 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/quota-pod.yaml download=admin/resource/quota-pod.yaml><code>admin/resource/quota-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-quota-pod-yaml")' title="Copy admin/resource/quota-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-quota-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>리소스쿼터를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/quota-pod.yaml --namespace<span style=color:#666>=</span>quota-pod-example
</span></span></code></pre></div><p>리소스쿼터에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get resourcequota pod-demo --namespace<span style=color:#666>=</span>quota-pod-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력 결과는 네임스페이스에 두 개의 파드 쿼터가 있고, 현재 파드가 없음을
보여준다. 즉, 쿼터 중 어느 것도 사용되지 않았다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>used</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>다음은 <a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a>에 대한 예시 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/quota-pod-deployment.yaml download=admin/resource/quota-pod-deployment.yaml><code>admin/resource/quota-pod-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-quota-pod-deployment-yaml")' title="Copy admin/resource/quota-pod-deployment.yaml to clipboard"></img></div><div class=includecode id=admin-resource-quota-pod-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-quota-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>quota-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>quota-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-quota-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>매니페스트에서, <code>replicas: 3</code> 은 쿠버네티스가 모두 동일한 애플리케이션을 실행하는
세 개의 새로운 파드를 만들도록 지시한다.</p><p>디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/quota-pod-deployment.yaml --namespace<span style=color:#666>=</span>quota-pod-example
</span></span></code></pre></div><p>디플로이먼트에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment pod-quota-demo --namespace<span style=color:#666>=</span>quota-pod-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력을 보면 디플로이먼트가 3개의 레플리카를 정의하고 있음에도,
앞서 설정한 쿼터로 인해 2개의 파드만 생성되었음을 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>availableReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span>2021-04-02T20:57:05Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message: &#39;unable to create pods</span>:<span style=color:#bbb> </span>pods &#34;pod-quota-demo-1650323038-&#34; is forbidden:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>exceeded quota: pod-demo, requested: pods=1, used: pods=2, limited</span>:<span style=color:#bbb> </span>pods=2&#39;<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=리소스-선택>리소스 선택</h3><p>이 예제에서는 총 파드 수를 제한하는 리소스쿼터를 정의하였다.
하지만, 다른 종류의 오브젝트의 총 수를 제한할 수도 있다.
예를 들어, 한 네임스페이스에 존재할 수 있는
<a class=glossary-tooltip title='정기적인 일정으로 실행되는 반복 작업(잡).' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/cron-jobs/ target=_blank aria-label=크론잡>크론잡</a>의 총 수를 제한할 수 있다.</p><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace quota-pod-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너 및 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7743f043c43f7b12e8654e2227dbc658>4 - 인증서</h1><p>클라이언트 인증서로 인증을 사용하는 경우 <code>easyrsa</code>, <code>openssl</code> 또는 <code>cfssl</code>
을 통해 인증서를 수동으로 생성할 수 있다.</p><h3 id=easyrsa>easyrsa</h3><p><strong>easyrsa</strong> 는 클러스터 인증서를 수동으로 생성할 수 있다.</p><ol><li><p><code>easyrsa3</code>의 패치 버전을 다운로드하여 압축을 풀고, 초기화한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
</span></span><span style=display:flex><span>tar xzf easy-rsa.tar.gz
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> easy-rsa-master/easyrsa3
</span></span><span style=display:flex><span>./easyrsa init-pki
</span></span></code></pre></div></li><li><p>새로운 인증 기관(CA)을 생성한다. <code>--batch</code> 는 자동 모드를 설정한다.
<code>--req-cn</code> 는 CA의 새 루트 인증서에 대한 일반 이름(Common Name (CN))을 지정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./easyrsa --batch <span style=color:#b44>&#34;--req-cn=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>@`date +%s`&#34;</span> build-ca nopass
</span></span></code></pre></div></li><li><p>서버 인증서와 키를 생성한다.</p><p><code>--subject-alt-name</code> 인자로 API 서버에 접근이 가능한 IP와 DNS
이름을 설정한다. <code>MASTER_CLUSTER_IP</code> 는 일반적으로 API 서버와
컨트롤러 관리자 컴포넌트에 대해 <code>--service-cluster-ip-range</code> 인자로
지정된 서비스 CIDR의 첫 번째 IP이다. <code>--days</code> 인자는 인증서가 만료되는
일 수를 설정하는 데 사용된다.
또한, 아래 샘플에서는 <code>cluster.local</code> 을 기본 DNS 도메인
이름으로 사용하고 있다고 가정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./easyrsa --subject-alt-name<span style=color:#666>=</span><span style=color:#b44>&#34;IP:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;IP:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_CLUSTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default.svc,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default.svc.cluster,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default.svc.cluster.local&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--days<span style=color:#666>=</span><span style=color:#666>10000</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>build-server-full server nopass
</span></span></code></pre></div></li><li><p><code>pki/ca.crt</code>, <code>pki/issued/server.crt</code> 그리고 <code>pki/private/server.key</code> 를 디렉터리에 복사한다.</p></li><li><p>API 서버를 시작하는 파라미터에 다음과 같이 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--client-ca-file<span style=color:#666>=</span>/yourdirectory/ca.crt
</span></span><span style=display:flex><span>--tls-cert-file<span style=color:#666>=</span>/yourdirectory/server.crt
</span></span><span style=display:flex><span>--tls-private-key-file<span style=color:#666>=</span>/yourdirectory/server.key
</span></span></code></pre></div></li></ol><h3 id=openssl>openssl</h3><p><strong>openssl</strong> 은 클러스터 인증서를 수동으로 생성할 수 있다.</p><ol><li><p>ca.key를 2048bit로 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl genrsa -out ca.key <span style=color:#666>2048</span>
</span></span></code></pre></div></li><li><p>ca.key에 따라 ca.crt를 생성한다(인증서 유효 기간을 사용하려면 <code>-days</code>를 사용한다).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -x509 -new -nodes -key ca.key -subj <span style=color:#b44>&#34;/CN=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span> -days <span style=color:#666>10000</span> -out ca.crt
</span></span></code></pre></div></li><li><p>server.key를 2048bit로 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl genrsa -out server.key <span style=color:#666>2048</span>
</span></span></code></pre></div></li><li><p>인증서 서명 요청(Certificate Signing Request (CSR))을 생성하기 위한 설정 파일을 생성한다.</p><p>파일에 저장하기 전에 꺾쇠 괄호(예: <code>&lt;MASTER_IP></code>)로
표시된 값을 실제 값으로 대체한다(예: <code>csr.conf</code>).
<code>MASTER_CLUSTER_IP</code> 의 값은 이전 하위 섹션에서
설명한 대로 API 서버의 서비스 클러스터 IP이다.
또한, 아래 샘플에서는 <code>cluster.local</code> 을 기본 DNS 도메인
이름으로 사용하고 있다고 가정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ req ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>default_bits</span> <span style=color:#666>=</span> <span style=color:#b44>2048</span>
</span></span><span style=display:flex><span><span style=color:#b44>prompt</span> <span style=color:#666>=</span> <span style=color:#b44>no</span>
</span></span><span style=display:flex><span><span style=color:#b44>default_md</span> <span style=color:#666>=</span> <span style=color:#b44>sha256</span>
</span></span><span style=display:flex><span><span style=color:#b44>req_extensions</span> <span style=color:#666>=</span> <span style=color:#b44>req_ext</span>
</span></span><span style=display:flex><span><span style=color:#b44>distinguished_name</span> <span style=color:#666>=</span> <span style=color:#b44>dn</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ dn ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>C</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;국가(country)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>ST</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;도(state)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>L</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;시(city)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>O</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;조직(organization)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>OU</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;조직 단위(organization unit)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>CN</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;MASTER_IP&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ req_ext ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>subjectAltName</span> <span style=color:#666>=</span> <span style=color:#b44>@alt_names</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ alt_names ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.1</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.2</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.3</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default.svc</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.4</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default.svc.cluster</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.5</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default.svc.cluster.local</span>
</span></span><span style=display:flex><span><span style=color:#b44>IP.1</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;MASTER_IP&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>IP.2</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;MASTER_CLUSTER_IP&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ v3_ext ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>authorityKeyIdentifier</span><span style=color:#666>=</span><span style=color:#b44>keyid,issuer:always</span>
</span></span><span style=display:flex><span><span style=color:#b44>basicConstraints</span><span style=color:#666>=</span><span style=color:#b44>CA:FALSE</span>
</span></span><span style=display:flex><span><span style=color:#b44>keyUsage</span><span style=color:#666>=</span><span style=color:#b44>keyEncipherment,dataEncipherment</span>
</span></span><span style=display:flex><span><span style=color:#b44>extendedKeyUsage</span><span style=color:#666>=</span><span style=color:#b44>serverAuth,clientAuth</span>
</span></span><span style=display:flex><span><span style=color:#b44>subjectAltName</span><span style=color:#666>=</span><span style=color:#b44>@alt_names</span>
</span></span></code></pre></div></li><li><p>설정 파일을 기반으로 인증서 서명 요청을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -new -key server.key -out server.csr -config csr.conf
</span></span></code></pre></div></li><li><p>ca.key, ca.crt 그리고 server.csr을 사용해서 서버 인증서를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -CAcreateserial -out server.crt -days <span style=color:#666>10000</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -extensions v3_ext -extfile csr.conf
</span></span></code></pre></div></li><li><p>인증서 서명 요청을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req  -noout -text -in ./server.csr
</span></span></code></pre></div></li><li><p>인증서를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl x509  -noout -text -in ./server.crt
</span></span></code></pre></div></li></ol><p>마지막으로, API 서버 시작 파라미터에 동일한 파라미터를 추가한다.</p><h3 id=cfssl>cfssl</h3><p><strong>cfssl</strong> 은 인증서 생성을 위한 또 다른 도구이다.</p><ol><li><p>아래에 표시된 대로 커맨드 라인 도구를 다운로드하여 압축을 풀고 준비한다.</p><p>사용 중인 하드웨어 아키텍처 및 cfssl 버전에 따라 샘플
명령을 조정해야 할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl_1.5.0_linux_amd64 -o cfssl
</span></span><span style=display:flex><span>chmod +x cfssl
</span></span><span style=display:flex><span>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssljson_1.5.0_linux_amd64 -o cfssljson
</span></span><span style=display:flex><span>chmod +x cfssljson
</span></span><span style=display:flex><span>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl-certinfo_1.5.0_linux_amd64 -o cfssl-certinfo
</span></span><span style=display:flex><span>chmod +x cfssl-certinfo
</span></span></code></pre></div></li><li><p>아티팩트(artifact)를 보유할 디렉터리를 생성하고 cfssl을 초기화한다.</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir cert
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> cert
</span></span><span style=display:flex><span>../cfssl print-defaults config &gt; config.json
</span></span><span style=display:flex><span>../cfssl print-defaults csr &gt; csr.json
</span></span></code></pre></div><ol><li><p>CA 파일을 생성하기 위한 JSON 설정 파일을 <code>ca-config.json</code> 예시와 같이 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;signing&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;default&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;expiry&#34;</span>: <span style=color:#b44>&#34;8760h&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;profiles&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;usages&#34;</span>: [
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;signing&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;key encipherment&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;server auth&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;client auth&#34;</span>
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;expiry&#34;</span>: <span style=color:#b44>&#34;8760h&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>CA 인증서 서명 요청(CSR)을 위한 JSON 설정 파일을
<code>ca-csr.json</code> 예시와 같이 생성한다. 꺾쇠 괄호로 표시된
값을 사용하려는 실제 값으로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;CN&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;key&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;algo&#34;</span>: <span style=color:#b44>&#34;rsa&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;size&#34;</span>: <span style=color:#666>2048</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;names&#34;</span>:[{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;C&#34;</span>: <span style=color:#b44>&#34;국가&lt;country&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ST&#34;</span>: <span style=color:#b44>&#34;도&lt;state&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;L&#34;</span>: <span style=color:#b44>&#34;시&lt;city&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;O&#34;</span>: <span style=color:#b44>&#34;조직&lt;organization&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;OU&#34;</span>: <span style=color:#b44>&#34;조직 단위&lt;organization unit&gt;&#34;</span>
</span></span><span style=display:flex><span>  }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>CA 키(<code>ca-key.pem</code>)와 인증서(<code>ca.pem</code>)을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca
</span></span></code></pre></div></li><li><p>API 서버의 키와 인증서를 생성하기 위한 JSON 구성파일을
<code>server-csr.json</code> 예시와 같이 생성한다. 꺾쇠 괄호 안의 값을
사용하려는 실제 값으로 변경한다. <code>MASTER_CLUSTER_IP</code> 는
이전 하위 섹션에서 설명한 API 서버의 클러스터 IP이다.
아래 샘플은 기본 DNS 도메인 이름으로 <code>cluster.local</code> 을
사용한다고 가정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;CN&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;hosts&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;&lt;MASTER_IP&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;&lt;MASTER_CLUSTER_IP&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default.svc&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default.svc.cluster&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default.svc.cluster.local&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;key&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;algo&#34;</span>: <span style=color:#b44>&#34;rsa&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;size&#34;</span>: <span style=color:#666>2048</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;names&#34;</span>: [{
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;C&#34;</span>: <span style=color:#b44>&#34;&lt;국가(country)&gt;&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;ST&#34;</span>: <span style=color:#b44>&#34;&lt;도(state)&gt;&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;L&#34;</span>: <span style=color:#b44>&#34;&lt;시(city)&gt;&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;O&#34;</span>: <span style=color:#b44>&#34;&lt;조직(organization)&gt;&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;OU&#34;</span>: <span style=color:#b44>&#34;&lt;조직 단위(organization unit)&gt;&#34;</span>
</span></span><span style=display:flex><span>  }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>API 서버 키와 인증서를 생성하면, 기본적으로
<code>server-key.pem</code> 과 <code>server.pem</code> 파일에 각각 저장된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>../cfssl gencert -ca<span style=color:#666>=</span>ca.pem -ca-key<span style=color:#666>=</span>ca-key.pem <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>     --config<span style=color:#666>=</span>ca-config.json -profile<span style=color:#666>=</span>kubernetes <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>     server-csr.json | ../cfssljson -bare server
</span></span></code></pre></div></li></ol><h2 id=자체-서명된-ca-인증서의-배포>자체 서명된 CA 인증서의 배포</h2><p>클라이언트 노드는 자체 서명된 CA 인증서를 유효한 것으로 인식하지 않을 수 있다.
비-프로덕션 디플로이먼트 또는 회사 방화벽 뒤에서 실행되는
디플로이먼트의 경우, 자체 서명된 CA 인증서를 모든 클라이언트에
배포하고 유효한 인증서의 로컬 목록을 새로 고칠 수 있다.</p><p>각 클라이언트에서, 다음 작업을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt
</span></span><span style=display:flex><span>sudo update-ca-certificates
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....
done.
</code></pre><h2 id=인증서-api>인증서 API</h2><p><code>certificates.k8s.io</code> API를 사용하여
<a href=/ko/docs/tasks/tls/managing-tls-in-a-cluster/>클러스터에서 TLS 인증서 관리</a>에
설명된 대로 인증에 사용할 x509 인증서를 프로비전 할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-8c31aafd38fad5b0de0bd191758d6f93>5 - 네트워크 폴리시 제공자(Network Policy Provider) 설치</h1></div><div class=td-content><h1 id=pg-1239a77618c6278373832a142cd85519>5.1 - 네트워크 폴리시로 캘리코(Calico) 사용하기</h1><p>이 페이지는 쿠버네티스에서 캘리코(Calico) 클러스터를 생성하는 몇 가지 빠른 방법을 살펴본다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><a href=#creating-a-calico-cluster-with-google-kubernetes-engine-gke>클라우드</a>나 <a href=#creating-a-local-calico-cluster-with-kubeadm>지역</a> 클러스터 중에 어디에 배포할지 결정한다.</p><h2 id=creating-a-calico-cluster-with-google-kubernetes-engine-gke>구글 쿠버네티스 엔진(GKE)에 캘리코 클러스터 생성하기</h2><p><strong>사전요구사항</strong>: <a href=https://cloud.google.com/sdk/docs/quickstarts>gcloud</a>.</p><ol><li><p>캘리코로 GKE 클러스터를 시작하려면, <code>--enable-network-policy</code> 플래그를 추가한다.</p><p><strong>문법</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud container clusters create <span style=color:#666>[</span>클러스터_이름<span style=color:#666>]</span> --enable-network-policy
</span></span></code></pre></div><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud container clusters create my-calico-cluster --enable-network-policy
</span></span></code></pre></div></li><li><p>배포를 확인하기 위해, 다음 커맨드를 이용하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div><p>캘리코 파드는 <code>calico</code>로 시작한다. 각각의 상태가 <code>Running</code>임을 확인하자.</p></li></ol><h2 id=creating-a-local-calico-cluster-with-kubeadm>kubeadm으로 지역 캘리코 클러스터 생성하기</h2><p>Kubeadm을 이용해서 15분 이내에 지역 단일 호스트 캘리코 클러스터를 생성하려면,
<a href=https://docs.projectcalico.org/latest/getting-started/kubernetes/>캘리코 빠른 시작</a>을 참고한다.</p><h2 id=다음-내용>다음 내용</h2><p>클러스터가 동작하면, 쿠버네티스 네트워크 폴리시(NetworkPolicy)를 시도하기 위해
<a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 폴리시 선언하기</a>를 따라 할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-95039241255a31df196beaa405b68eba>5.2 - 네트워크 폴리시로 실리움(Cilium) 사용하기</h1><p>이 페이지는 어떻게 네트워크 폴리시(NetworkPolicy)로 실리움(Cilium)를 사용하는지 살펴본다.</p><p>실리움의 배경에 대해서는 <a href=https://docs.cilium.io/en/stable/intro>실리움 소개</a>를 읽어보자.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=기본-시험을-위해-실리움을-minikube에-배포하기>기본 시험을 위해 실리움을 Minikube에 배포하기</h2><p>실리움에 쉽게 친숙해지기 위해
Minikube에 실리움을 기본적인 데몬셋으로 설치를 수행하는
<a href=https://docs.cilium.io/en/stable/gettingstarted/k8s-install-default/>실리움 쿠버네티스 시작하기 안내</a>를 따라 해볼 수 있다.</p><p>Minikube를 시작하려면 최소 버전으로 >= v1.5.2 이 필요하고,
다음의 실행 파라미터로 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube version
</span></span></code></pre></div><pre tabindex=0><code>minikube version: v1.5.2
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start --network-plugin<span style=color:#666>=</span>cni
</span></span></code></pre></div><p>minikube의 경우 CLI 도구를 사용하여 실리움을 설치할 수 있다.
실리움은 클러스터 구성을 자동으로 감지하고
성공적인 설치를 위해 적절한 구성 요소를 설치한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz
</span></span><span style=display:flex><span>sudo tar xzvfC cilium-linux-amd64.tar.gz /usr/local/bin
</span></span><span style=display:flex><span>rm cilium-linux-amd64.tar.gz
</span></span><span style=display:flex><span>cilium install
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>🔮 Auto-detected Kubernetes kind: minikube
</span></span><span style=display:flex><span>✨ Running <span style=color:#b44>&#34;minikube&#34;</span> validation checks
</span></span><span style=display:flex><span>✅ Detected minikube version <span style=color:#b44>&#34;1.20.0&#34;</span>
</span></span><span style=display:flex><span>ℹ️  Cilium version not set, using default version <span style=color:#b44>&#34;v1.10.0&#34;</span>
</span></span><span style=display:flex><span>🔮 Auto-detected cluster name: minikube
</span></span><span style=display:flex><span>🔮 Auto-detected IPAM mode: cluster-pool
</span></span><span style=display:flex><span>🔮 Auto-detected datapath mode: tunnel
</span></span><span style=display:flex><span>🔑 Generating CA...
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> generate received request
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> received CSR
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> generating key: ecdsa-256
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> encoded CSR
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> signed certificate with serial number <span style=color:#666>48713764918856674401136471229482703021230538642</span>
</span></span><span style=display:flex><span>🔑 Generating certificates <span style=color:#a2f;font-weight:700>for</span> Hubble...
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> generate received request
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> received CSR
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> generating key: ecdsa-256
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> encoded CSR
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> signed certificate with serial number <span style=color:#666>3514109734025784310086389188421560613333279574</span>
</span></span><span style=display:flex><span>🚀 Creating Service accounts...
</span></span><span style=display:flex><span>🚀 Creating Cluster roles...
</span></span><span style=display:flex><span>🚀 Creating ConfigMap...
</span></span><span style=display:flex><span>🚀 Creating Agent DaemonSet...
</span></span><span style=display:flex><span>🚀 Creating Operator Deployment...
</span></span><span style=display:flex><span>⌛ Waiting <span style=color:#a2f;font-weight:700>for</span> Cilium to be installed...
</span></span></code></pre></div><p>시작하기 안내서의 나머지 부분은 예제 애플리케이션을 이용하여
L3/L4(예, IP 주소 + 포트) 모두의 보안 정책뿐만 아니라 L7(예, HTTP)의 보안 정책을
적용하는 방법을 설명한다.</p><h2 id=실리움을-실-서비스-용도로-배포하기>실리움을 실 서비스 용도로 배포하기</h2><p>실리움을 실 서비스 용도의 배포에 관련한 자세한 방법은
<a href=https://docs.cilium.io/en/stable/concepts/kubernetes/intro/>실리움 쿠버네티스 설치 안내</a>를 살펴본다.
이 문서는 자세한 요구사항, 방법과
실제 데몬셋 예시를 포함한다.</p><h2 id=실리움-구성요소-이해하기>실리움 구성요소 이해하기</h2><p>실리움으로 클러스터를 배포하면 파드가 <code>kube-system</code> 네임스페이스에 추가된다.
파드의 목록을 보려면 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>kube-system -l k8s-app<span style=color:#666>=</span>cilium
</span></span></code></pre></div><p>다음과 유사한 파드의 목록을 볼 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>NAME           READY   STATUS    RESTARTS   AGE
</span></span></span><span style=display:flex><span><span style=color:#888>cilium-kkdhz   1/1     Running   0          3m23s
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span></code></pre></div><p><code>cilium</code> 파드는 클러스터 각 노드에서 실행되며, 리눅스 BPF를 사용해서
해당 노드의 파드에 대한 트래픽 네트워크 폴리시를 적용한다.</p><h2 id=다음-내용>다음 내용</h2><p>클러스터가 동작하면,
실리움으로 쿠버네티스 네트워크 폴리시를 시도하기 위해
<a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 폴리시 선언하기</a>를 따라 할 수 있다.
재미있게 즐기고, 질문이 있다면
<a href=https://cilium.herokuapp.com/>실리움 슬랙 채널</a>을 이용하여 연락한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-505a0a6a7e6eff361bbb3be81c84b2e0>5.3 - 네트워크 폴리시로 큐브 라우터(Kube-router) 사용하기</h1><p>이 페이지는 네트워크 폴리시(NetworkPolicy)로 <a href=https://github.com/cloudnativelabs/kube-router>큐브 라우터(Kube-router)</a>를 사용하는 방법을 살펴본다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>운영 중인 쿠버네티스 클러스터가 필요하다. 클러스터가 없다면, Kops, Bootkube, Kubeadm 등을 이용해서 클러스터를 생성할 수 있다.</p><h2 id=큐브-라우터-애드온-설치하기>큐브 라우터 애드온 설치하기</h2><p>큐브 라우터 애드온은 갱신된 모든 네트워크 폴리시 및 파드에 대해 쿠버네티스 API 서버를 감시하고, 정책에 따라 트래픽을 허용하거나 차단하도록 iptables 규칙와 ipset을 구성하는 네트워크 폴리시 컨트롤러와 함께 제공된다. 큐브 라우터 애드온을 설치하는 <a href=https://www.kube-router.io/docs/user-guide/#try-kube-router-with-cluster-installers>큐브 라우터를 클러스터 인스톨러와 함께 사용하기</a> 안내서를 따라해 봅니다.</p><h2 id=다음-내용>다음 내용</h2><p>큐브 라우터 애드온을 설치한 후에는, 쿠버네티스 네트워크 폴리시를 시도하기 위해 <a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 폴리시 선언하기</a>를 따라 할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2842eac98aa0e229a5c6755c4c83d2a7>5.4 - 네트워크 폴리시로 로마나(Romana)</h1><p>이 페이지는 네트워크 폴리시(NetworkPolicy)로 로마나(Romana)를 사용하는 방법을 살펴본다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm 시작하기</a>의 1, 2, 3 단계를 완료하자.</p><h2 id=kubeadm으로-로마나-설치하기>kubeadm으로 로마나 설치하기</h2><p>Kubeadm을 위한 <a href=https://github.com/romana/romana/tree/master/containerize>컨테이너화된 설치 안내서</a>를 따른다.</p><h2 id=네트워크-폴리시-적용하기>네트워크 폴리시 적용하기</h2><p>네트워크 폴리시를 적용하기 위해 다음 중에 하나를 사용하자.</p><ul><li><a href=https://github.com/romana/romana/wiki/Romana-policies>Romana 네트워크 폴리시</a>.<ul><li><a href=https://github.com/romana/core/blob/master/doc/policy.md>Romana 네트워크 폴리시의 예</a>.</li></ul></li><li>네트워크 폴리시 API.</li></ul><h2 id=다음-내용>다음 내용</h2><p>로마나를 설치한 후에는, 쿠버네티스 네트워크 폴리시를 시도하기 위해
<a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 폴리시 선언하기</a>를
따라 할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ac075c3fdfd0d41aa753cc70e42be064>5.5 - 네트워크 폴리시로 위브넷(Weave Net) 사용하기</h1><p>이 페이지는 네트워크 폴리시(NetworkPolicy)로 위브넷(Weave Net)를 사용하는 방법을 살펴본다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하다. 맨 땅에서부터 시작하기를 위해서
<a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm 시작하기 안내서</a>를 따른다.</p><h2 id=weave-net-애드온을-설치한다>Weave Net 애드온을 설치한다</h2><p><a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/>애드온을 통한 쿠버네티스 통합하기</a> 가이드를 따른다.</p><p>쿠버네티스의 위브넷 애드온은 쿠버네티스의 모든 네임스페이스의
네크워크 정책 어노테이션을 자동으로 모니터링하며,
정책에 따라 트래픽을 허용하고 차단하는 <code>iptables</code> 규칙을 구성하는
<a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/#npc>네트워크 폴리시 컨트롤러</a>와 함께 제공된다.</p><h2 id=설치-시험>설치 시험</h2><p>위브넷이 동작하는지 확인한다.</p><p>다음 커맨드를 입력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -n kube-system -o wide
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>NAME                                    READY     STATUS    RESTARTS   AGE       IP              NODE
weave-net-1t1qg                         2/2       Running   0          9d        192.168.2.10    worknode3
weave-net-231d7                         2/2       Running   1          7d        10.2.0.17       worknodegpu
weave-net-7nmwt                         2/2       Running   3          9d        192.168.2.131   masternode
weave-net-pmw8w                         2/2       Running   0          9d        192.168.2.216   worknode2
</code></pre><p>위브넷 파드를 가진 각 노드와 모든 파드는 <code>Running</code>이고 <code>2/2 READY</code>이다(<code>2/2</code>는 각 파드가 <code>weave</code>와 <code>weave-npc</code>를 가지고 있음을 뜻한다).</p><h2 id=다음-내용>다음 내용</h2><p>위브넷 애드온을 설치하고 나서, 쿠버네티스 네트워크 폴리시를 시도하기 위해
<a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 폴리시 선언하기</a>를
따라 할 수 있다. 질문이 있으면
<a href=https://github.com/weaveworks/weave#getting-help>슬랙 #weave-community 이나 Weave 유저그룹</a>에 연락한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3d0cd7d2f13d4759094f281504cf57b8>6 - DNS 서비스 사용자 정의하기</h1><p>이 페이지는 클러스터 안에서 사용자의
DNS <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드(Pod)>파드(Pod)</a> 를 설정하고
DNS 변환(DNS resolution) 절차를 사용자 정의하는 방법을 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터는 CoreDNS 애드온을 구동하고 있어야 한다.
<a href=/ko/docs/tasks/administer-cluster/coredns/#coredns%EB%A1%9C-%EC%9D%B4%EA%B4%80%ED%95%98%EA%B8%B0>CoreDNS로 이관하기</a>
는 <code>kubeadm</code> 을 이용하여 <code>kube-dns</code> 로부터 이관하는 방법을 설명한다.</p><p>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.12.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=소개>소개</h2><p>DNS는 <em>애드온 관리자</em> 인 <a href=https://releases.k8s.io/master/cluster/addons/README.md>클러스터 애드온</a>을
사용하여 자동으로 시작되는 쿠버네티스
내장 서비스이다.</p><p>쿠버네티스 v1.12 부터, CoreDNS는 kube-dns를 대체하여 권장되는 DNS 서버이다. 만약 사용자의 클러스터가 원래 kube-dns를 사용하였을 경우,
CoreDNS 대신 <code>kube-dns</code> 를 계속 사용할 수도 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> CoreDNS 서비스는 <code>metadata.name</code> 필드에 <code>kube-dns</code> 로 이름이 지정된다.
이를 통해, 기존의 <code>kube-dns</code> 서비스 이름을 사용하여 클러스터 내부의 주소를 확인하는 워크로드에 대한 상호 운용성이 증가된다. <code>kube-dns</code> 로 서비스 이름을 사용하면, 해당 DNS 공급자가 어떤 공통 이름으로 실행되고 있는지에 대한 구현 세부 정보를 추상화한다.</div><p>CoreDNS를 디플로이먼트(Deployment)로 실행하고 있을 경우, 일반적으로 고정 IP 주소를 갖는 쿠버네티스 서비스로 노출된다.
Kubelet 은 <code>--cluster-dns=&lt;dns-service-ip></code> 플래그를 사용하여 DNS 확인자 정보를 각 컨테이너에 전달한다.</p><p>DNS 이름에도 도메인이 필요하다. 사용자는 kubelet 에 있는 <code>--cluster-domain=&lt;default-local-domain></code> 플래그를
통하여 로컬 도메인을 설정할 수 있다.</p><p>DNS 서버는 정방향 조회(A 및 AAAA 레코드), 포트 조회(SRV 레코드), 역방향 IP 주소 조회(PTR 레코드) 등을 지원한다.
더 자세한 내용은 <a href=/ko/docs/concepts/services-networking/dns-pod-service/>서비스 및 파드용 DNS</a>를 참고한다.</p><p>만약 파드의 <code>dnsPolicy</code> 가 <code>default</code> 로 지정되어 있는 경우,
파드는 자신이 실행되는 노드의 이름 변환(name resolution) 구성을 상속한다.
파드의 DNS 변환도 노드와 동일하게 작동해야 한다.
그 외에는 <a href=/docs/tasks/administer-cluster/dns-debugging-resolution/#known-issues>알려진 이슈</a>를 참고한다.</p><p>만약 위와 같은 방식을 원하지 않거나, 파드를 위해 다른 DNS 설정이 필요한 경우,
사용자는 kubelet 의 <code>--resolv-conf</code> 플래그를 사용할 수 있다.
파드가 DNS를 상속받지 못하도록 하기 위해 이 플래그를 ""로 설정한다.
DNS 상속을 위해 <code>/etc/resolv.conf</code> 이외의 파일을 지정할 경우 유효한 파일 경로를 설정한다.</p><h2 id=coredns>CoreDNS</h2><p>CoreDNS는 <a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>dns 명세</a>를 준수하며 클러스터 DNS 역할을 할 수 있는, 범용적인 권한을 갖는 DNS 서버이다.</p><h3 id=coredns-컨피그맵-configmap-옵션>CoreDNS 컨피그맵(ConfigMap) 옵션</h3><p>CoreDNS는 모듈형이자 플러그인이 가능한 DNS 서버이며, 각 플러그인들은 CoreDNS에 새로운 기능을 부가한다.
이는 CoreDNS 구성 파일인 <a href=https://coredns.io/2017/07/23/corefile-explained/>Corefile</a>을 관리하여 구성할 수 있다.
클러스터 관리자는 CoreDNS Corefile에 대한 <a class=glossary-tooltip title='키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>을 수정하여
해당 클러스터에 대한 DNS 서비스 검색 동작을
변경할 수 있다.</p><p>쿠버네티스에서 CoreDNS는 아래의 기본 Corefile 구성으로 설치된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>coredns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>Corefile</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    .:53 {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        errors
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        health {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            lameduck 5s
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        ready
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            pods insecure
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            fallthrough in-addr.arpa ip6.arpa
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            ttl 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        prometheus :9153
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        forward . /etc/resolv.conf
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        cache 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loop
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        reload
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loadbalance
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    }</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>Corefile의 구성은 CoreDNS의 아래 <a href=https://coredns.io/plugins>플러그인</a>을 포함한다.</p><ul><li><a href=https://coredns.io/plugins/errors/>errors</a>: 오류가 표준 출력(stdout)에 기록된다.</li><li><a href=https://coredns.io/plugins/health/>health</a>: CoreDNS의 상태(healthy)가 <code>http://localhost:8080/health</code> 에 기록된다. 이 확장 구문에서 <code>lameduck</code> 은 프로세스를 비정상 상태(unhealthy)로 만들고, 프로세스가 종료되기 전에 5초 동안 기다린다.</li><li><a href=https://coredns.io/plugins/ready/>ready</a>: 8181 포트의 HTTP 엔드포인트가, 모든 플러그인이 준비되었다는 신호를 보내면 200 OK 를 반환한다.</li><li><a href=https://coredns.io/plugins/kubernetes/>kubernetes</a>: CoreDNS가 쿠버네티스의 서비스 및 파드의 IP를 기반으로 DNS 쿼리에 대해 응답한다. 해당 플러그인에 대한 <a href=https://coredns.io/plugins/kubernetes/>세부 사항</a>은 CoreDNS 웹사이트에서 확인할 수 있다. <code>ttl</code> 을 사용하면 응답에 대한 사용자 정의 TTL 을 지정할 수 있으며, 기본값은 5초이다. 허용되는 최소 TTL은 0초이며, 최대값은 3600초이다. 레코드가 캐싱되지 않도록 할 경우, TTL을 0으로 설정한다.
<code>pods insecure</code> 옵션은 <em>kube-dns</em> 와의 하위 호환성을 위해 제공된다. <code>pods verified</code> 옵션을 사용하여, 일치하는 IP의 동일 네임스페이스(Namespace)에 파드가 존재하는 경우에만 A 레코드를 반환하게 할 수 있다. <code>pods disabled</code> 옵션은 파드 레코드를 사용하지 않을 경우 사용된다.</li><li><a href=https://coredns.io/plugins/metrics/>prometheus</a>: CoreDNS의 메트릭은 <a href=https://prometheus.io/>프로메테우스</a> 형식(OpenMetrics 라고도 알려진)의 <code>http://localhost:9153/metrics</code> 에서 사용 가능하다.</li><li><a href=https://coredns.io/plugins/forward/>forward</a>: 쿠버네티스 클러스터 도메인에 없는 쿼리들은 모두 사전에 정의된 리졸버(/etc/resolv.conf)로 전달된다.</li><li><a href=https://coredns.io/plugins/cache/>cache</a>: 프론트 엔드 캐시를 활성화한다.</li><li><a href=https://coredns.io/plugins/loop/>loop</a>: 간단한 전달 루프(loop)를 감지하고, 루프가 발견되면 CoreDNS 프로세스를 중단(halt)한다.</li><li><a href=https://coredns.io/plugins/reload>reload</a>: 변경된 Corefile을 자동으로 다시 로드하도록 한다. 컨피그맵 설정을 변경한 후에 변경 사항이 적용되기 위하여 약 2분정도 소요된다.</li><li><a href=https://coredns.io/plugins/loadbalance>loadbalance</a>: 응답에 대하여 A, AAAA, MX 레코드의 순서를 무작위로 선정하는 라운드-로빈 DNS 로드밸런서이다.</li></ul><p>사용자는 컨피그맵을 변경하여 기본 CoreDNS 동작을 변경할 수 있다.</p><h3 id=coredns를-사용하는-스텁-도메인-stub-domain-과-업스트림-네임서버-nameserver-의-설정>CoreDNS를 사용하는 스텁 도메인(Stub-domain)과 업스트림 네임서버(nameserver)의 설정</h3><p>CoreDNS는 <a href=https://coredns.io/plugins/forward/>포워드 플러그인</a>을 사용하여 스텁 도메인 및 업스트림 네임서버를 구성할 수 있다.</p><h4 id=예시>예시</h4><p>만약 클러스터 운영자가 10.150.0.1 에 위치한 <a href=https://www.consul.io/>Consul</a> 도메인 서버를 가지고 있고, 모든 Consul 이름의 접미사가 .consul.local 인 경우, CoreDNS에서 이를 구성하기 위해 클러스터 관리자는 CoreDNS 컨피그맵에서 다음 구문을 생성한다.</p><pre tabindex=0><code>consul.local:53 {
        errors
        cache 30
        forward . 10.150.0.1
    }
</code></pre><p>모든 비 클러스터의 DNS 조회가 172.16.0.1 의 특정 네임서버를 통과하도록 할 경우, <code>/etc/resolv.conf</code> 대신 <code>forward</code> 를 네임서버로 지정한다.</p><pre tabindex=0><code>forward .  172.16.0.1
</code></pre><p>기본 <code>Corefile</code> 구성에 따른 최종 컨피그맵은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>coredns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>Corefile</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    .:53 {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        errors
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        health
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>           pods insecure
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>           fallthrough in-addr.arpa ip6.arpa
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        prometheus :9153
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        forward . 172.16.0.1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        cache 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loop
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        reload
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loadbalance
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    consul.local:53 {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        errors
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        cache 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        forward . 10.150.0.1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    }</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p><code>Kubeadm</code> 툴은 kube-dns 컨피그맵에서 동일한 설정의 CoreDNS 컨피그맵으로의
자동 변환을 지원한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> kube-dns는 스텁 도메인 및 네임서버(예: ns.foo.com)에 대한 FQDN을 허용하지만 CoreDNS에서는 이 기능을 지원하지 않는다.
변환 과정에서, 모든 FQDN 네임서버는 CoreDNS 설정에서 생략된다.</div><h2 id=kube-dns에-대응되는-coredns-설정>kube-dns에 대응되는 CoreDNS 설정</h2><p>CoreDNS는 kube-dns 이상의 기능을 지원한다.
<code>StubDomains</code> 과 <code>upstreamNameservers</code> 를 지원하도록 생성된 kube-dns의 컨피그맵은 CoreDNS의 <code>forward</code> 플러그인으로 변환된다.</p><h3 id=예시-1>예시</h3><p>kube-dns에 대한 이 컨피그맵 예제는 stubDomains 및 upstreamNameservers를 지정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>stubDomains</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>{<span style=color:#b44>&#34;abc.com&#34;</span><span style=color:#bbb> </span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;1.2.3.4&#34;</span>],<span style=color:#bbb> </span><span style=color:#b44>&#34;my.cluster.local&#34;</span><span style=color:#bbb> </span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;2.3.4.5&#34;</span>]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>upstreamNameservers</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>[<span style=color:#b44>&#34;8.8.8.8&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;8.8.4.4&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span></code></pre></div><p>CoreDNS에서는 동등한 설정으로 Corefile을 생성한다.</p><ul><li>stubDomains 에 대응하는 설정:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>abc.com:53 {<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>errors<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>cache 30<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>forward . 1.2.3.4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>my.cluster.local:53 {<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>errors<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>cache 30<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>forward . 2.3.4.5<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>기본 플러그인으로 구성된 완전한 Corefile.</p><pre tabindex=0><code>.:53 {
    errors
    health
    kubernetes cluster.local in-addr.arpa ip6.arpa {
        pods insecure
        fallthrough in-addr.arpa ip6.arpa
    }
    federation cluster.local {
        foo foo.feddomain.com
    }
    prometheus :9153
    forward . 8.8.8.8 8.8.4.4
    cache 30
}
abc.com:53 {
    errors
    cache 30
    forward . 1.2.3.4
}
my.cluster.local:53 {
    errors
    cache 30
    forward . 2.3.4.5
}
</code></pre><h2 id=coredns로의-이관>CoreDNS로의 이관</h2><p>kube-dns에서 CoreDNS로 이관하기 위하여,
kube-dns를 CoreDNS로 교체하여 적용하는 방법에 대한 상세 정보는
<a href=https://coredns.io/2018/05/21/migration-from-kube-dns-to-coredns/>블로그 기사</a>를 참고한다.</p><p>또한 공식적인 CoreDNS <a href=https://github.com/coredns/deployment/blob/master/kubernetes/deploy.sh>배포 스크립트</a>를
사용하여 이관할 수도 있다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/tasks/administer-cluster/dns-debugging-resolution/>DNS 변환 디버깅하기</a> 읽기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2bffd7f3571cdd609bd97fb2e1bdb2fe>7 - 기본 스토리지클래스(StorageClass) 변경하기</h1><p>이 페이지는 특별한 요구사항이 없는 퍼시스턴트볼륨클레임(PersistentVolumeClaim)의 볼륨을 프로비저닝
하는데 사용되는 기본 스토리지 클래스를 변경하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=왜-기본-스토리지-클래스를-변경하는가>왜 기본 스토리지 클래스를 변경하는가?</h2><p>설치 방법에 따라, 사용자의 쿠버네티스 클러스터는 기본으로 표시된 기존
스토리지클래스와 함께 배포될 수 있다. 이 기본 스토리지클래스는 특정
스토리지 클래스가 필요하지 않은 퍼시스턴트볼륨클레임에 대해 스토리지를
동적으로 프로비저닝 하기 위해 사용된다.
더 자세한 내용은 <a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8%ED%81%B4%EB%A0%88%EC%9E%84>퍼시스턴트볼륨클레임 문서</a>를
보자.</p><p>미리 설치된 기본 스토리지클래스가 사용자의 예상되는 워크로드에 적합하지
않을수도 있다. 예를 들어, 너무 가격이 높은 스토리지를 프로비저닝 해야할
수도 있다. 이런 경우에, 기본 스토리지 클래스를 변경하거나 완전히 비활성화
하여 스토리지의 동적 프로비저닝을 방지할 수 있다.</p><p>기본 스토리지클래스를 삭제하는 경우, 사용자의 클러스터에서 구동 중인
애드온 매니저에 의해 자동으로 다시 생성될 수 있으므로 정상적으로 삭제가 되지 않을 수도 있다. 애드온 관리자
및 개별 애드온을 비활성화 하는 방법에 대한 자세한 내용은 설치 문서를 참조하자.</p><h2 id=기본-스토리지클래스-변경하기>기본 스토리지클래스 변경하기</h2><ol><li><p>사용자의 클러스터에 있는 스토리지클래스 목록을 조회한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get storageclass
</span></span></code></pre></div><p>결과는 아래와 유사하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>NAME                 PROVISIONER               AGE
</span></span><span style=display:flex><span>standard <span style=color:#666>(</span>default<span style=color:#666>)</span>   kubernetes.io/gce-pd      1d
</span></span><span style=display:flex><span>gold                 kubernetes.io/gce-pd      1d
</span></span></code></pre></div><p>기본 스토리지클래스는 <code>(default)</code> 로 표시되어 있다.</p></li><li><p>기본 스토리지클래스를 기본값이 아닌 것으로 표시한다.</p><p>기본 스토리지클래스에는
<code>storageclass.kubernetes.io/is-default-class</code> 의 값이 <code>true</code> 로 설정되어 있다.
다른 값이거나 어노테이션이 없을 경우 <code>false</code> 로 처리된다.</p><p>스토리지클래스를 기본값이 아닌 것으로 표시하려면, 그 값을 <code>false</code> 로 변경해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl patch storageclass standard -p <span style=color:#b44>&#39;{&#34;metadata&#34;: {&#34;annotations&#34;:{&#34;storageclass.kubernetes.io/is-default-class&#34;:&#34;false&#34;}}}&#39;</span>
</span></span></code></pre></div><p>여기서 <code>standard</code> 는 사용자가 선택한 스토리지클래스의 이름이다.</p></li><li><p>스토리지클래스를 기본값으로 표시한다.</p><p>이전 과정과 유사하게, 어노테이션을 추가/설정해야 한다.
<code>storageclass.kubernetes.io/is-default-class=true</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl patch storageclass gold -p <span style=color:#b44>&#39;{&#34;metadata&#34;: {&#34;annotations&#34;:{&#34;storageclass.kubernetes.io/is-default-class&#34;:&#34;true&#34;}}}&#39;</span>
</span></span></code></pre></div><p>최대 1개의 스토리지클래스를 기본값으로 표시할 수 있다는 것을 알아두자. 만약
2개 이상이 기본값으로 표시되면, 명시적으로 <code>storageClassName</code> 가 지정되지 않은 <code>PersistentVolumeClaim</code> 은 생성될 수 없다.</p></li><li><p>사용자가 선택한 스토리지클래스가 기본값으로 되어 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get storageclass
</span></span></code></pre></div><p>결과는 아래와 유사하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>NAME             PROVISIONER               AGE
</span></span><span style=display:flex><span>standard         kubernetes.io/gce-pd      1d
</span></span><span style=display:flex><span>gold <span style=color:#666>(</span>default<span style=color:#666>)</span>   kubernetes.io/gce-pd      1d
</span></span></code></pre></div></li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트볼륨(PersistentVolume)</a>에 대해 더 보기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1e966f5d0540bbee0876f9d0d08d54dc>8 - 네임스페이스를 사용해 클러스터 공유하기</h1><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>를 살펴보고, 작업하고, 삭제하는 방법에 대해 다룬다. 또한 쿠버네티스 네임스페이스를 사용해 클러스터를 세분화하는 방법에 대해서도 다룬다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><a href=/ko/docs/setup/>기존 쿠버네티스 클러스터</a>가 있다.</li><li>쿠버네티스 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>, <a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>, 그리고 <a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>에 대해 이해하고 있다.</li></ul><h2 id=네임스페이스-보기>네임스페이스 보기</h2><ol><li>아래 명령어를 사용해 클러스터의 현재 네임스페이스를 나열한다.</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE
default       Active    11d
kube-system   Active    11d
kube-public   Active    11d
</code></pre><p>쿠버네티스를 시작하면 세 개의 초기 네임스페이스가 있다.</p><ul><li><code>default</code> 다른 네임스페이스가 없는 오브젝트를 위한 기본 네임스페이스</li><li><code>kube-system</code> 쿠버네티스 시스템에서 생성된 오브젝트의 네임스페이스</li><li><code>kube-public</code> 이 네임스페이스는 자동으로 생성되며 모든 사용자(미인증 사용자를 포함)가 읽을 수 있다. 이 네임스페이스는 일부 리소스를 공개적으로 보고 읽을 수 있어야 하는 경우에 대비하여 대부분이 클러스터 사용을 위해 예약돼 있다. 그러나 이 네임스페이스의 공개적인 성격은 관례일 뿐 요구 사항은 아니다.</li></ul><p>아래 명령을 실행해 특정 네임스페이스에 대한 요약 정보를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces &lt;name&gt;
</span></span></code></pre></div><p>자세한 정보를 보는 것도 가능하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe namespaces &lt;name&gt;
</span></span></code></pre></div><pre tabindex=0><code>Name:           default
Labels:         &lt;none&gt;
Annotations:    &lt;none&gt;
Status:         Active

No resource quota.

Resource Limits
 Type       Resource    Min Max Default
 ----               --------    --- --- ---
 Container          cpu         -   -   100m
</code></pre><p>이러한 세부 정보에는 리소스 한도(limit) 범위 뿐만 아니라 리소스 쿼터(만약 있다면)까지 모두 표시된다.</p><p>리소스 쿼터는 <em>네임스페이스</em> 내 리소스의 집계 사용량을 추적하며,
<em>네임스페이스</em>에서 사용할 수 있는 <em>하드(Hard)</em> 리소스 사용 제한을 클러스터 운영자가 정의할 수 있도록 해준다.</p><p>제한 범위는 하나의 엔티티(entity)가 하나의 <em>네임스페이스</em>에서 사용할 수 있는
리소스 양에 대한 최대/최소 제약 조건을 정의한다.</p><p><a href=https://git.k8s.io/design-proposals-archive/resource-management/admission_control_limit_range.md>어드미션 컨트롤: 리밋 레인지(Limit Range)</a>를 참조하자.</p><p>네임스페이스는 다음 두 상태 중 하나에 있을 수 있다.</p><ul><li><code>Active</code> 네임스페이스가 사용 중이다.</li><li><code>Terminating</code> 네임스페이스가 삭제 중이므로 새 오브젝트에 사용할 수 없다.</li></ul><p>자세한 내용은 API 레퍼런스의 <a href=/docs/reference/kubernetes-api/cluster-resources/namespace-v1/>네임스페이스</a>를
참조한다.</p><h2 id=새-네임스페이스-생성하기>새 네임스페이스 생성하기</h2><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kube-</code> 접두사는 쿠버네티스 시스템 네임스페이스로 예약돼 있으므로 이를 사용해 네임스페이스를 생성하지 않도록 한다.</div><ol><li><p><code>my-namespace.yaml</code>이라는 YAML 파일을 생성하고 아래 내용을 작성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;insert-namespace-name-here&gt;<span style=color:#bbb>
</span></span></span></code></pre></div><p>다음 명령을 실행한다.</p><pre tabindex=0><code>kubectl create -f ./my-namespace.yaml
</code></pre></li><li><p>아래 명령으로 네임스페이스를 생성할 수도 있다.</p><pre tabindex=0><code>kubectl create namespace &lt;insert-namespace-name-here&gt;
</code></pre></li></ol><p>네임스페이스의 이름은
유효한 <a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-label-names>DNS 레이블</a>이어야 한다.</p><p>옵션 필드인 <code>finalizer</code>는 네임스페이스가 삭제 될 때 관찰자가 리소스를 제거할 수 있도록 한다. 존재하지 않는 파이널라이저(finalizer)를 명시한 경우 네임스페이스는 생성되지만 사용자가 삭제하려 하면 <code>Terminating</code> 상태가 된다.</p><p>파이널라이저에 대한 자세한 내용은 네임스페이스 <a href=https://git.k8s.io/design-proposals-archive/architecture/namespaces.md#finalizers>디자인 문서</a>에서 확인할 수 있다.</p><h2 id=네임스페이스-삭제하기>네임스페이스 삭제하기</h2><p>다음 명령을 실행해 네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespaces &lt;insert-some-namespace-name&gt;
</span></span></code></pre></div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 이렇게 하면 네임스페이스의 <em>모든 것</em> 이 삭제된다!</div><p>삭제는 비동기적이므로 삭제 후 한동안은 네임스페이스의 상태가 <code>Terminating</code>으로 보일 것이다.</p><h2 id=쿠버네티스-네임스페이스를-사용해-클러스터-세분화하기>쿠버네티스 네임스페이스를 사용해 클러스터 세분화하기</h2><ol><li><p>기본 네임스페이스 이해하기</p><p>기본적으로 쿠버네티스 클러스터는 클러스터에서 사용할 기본 파드, 서비스, 그리고 디플로이먼트(Deployment) 집합을 가지도록
클러스터를 프로비저닝 할 때 기본 네임스페이스를 인스턴스화한다.</p><p>새 클러스터가 있다고 가정하고 아래 명령을 수행하면 사용 가능한 네임스페이스를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces
</span></span></code></pre></div><pre tabindex=0><code>NAME      STATUS    AGE
default   Active    13m
</code></pre></li><li><p>새 네임스페이스 생성하기</p><p>이 예제에서는 내용을 저장할 쿠버네티스 네임스페이스를 추가로 두 개 생성할 것이다.</p><p>개발과 프로덕션 유스케이스에서 공유 쿠버네티스 클러스터를 사용하는 조직이 있다고 가정하자.</p><p>개발 팀은 애플리케이션을 구축하고 실행하는데 사용하는 파드, 서비스, 디플로이먼트의 목록을 볼 수 있는 공간을 클러스터에 유지하려 한다.
이 공간에서는 쿠버네티스 리소스가 자유롭게 추가 및 제거되고,
누가 리소스를 수정할 수 있는지 없는지에 대한 제약이 완화돼 빠른 개발이 가능해진다.</p><p>운영 팀은 운영 사이트를 실행하는 파드, 서비스, 디플로이먼트 집합을 조작할 수 있는 사람과
그렇지 않은 사람들에 대해 엄격한 절차를 적용할 수 있는 공간을 클러스터에 유지하려 한다.</p><p>이 조직이 따를 수 있는 한 가지 패턴은 쿠버네티스 클러스터를 <code>development(개발)</code>와 <code>production(운영)</code>이라는 두 개의 네임스페이스로 분할하는 것이다.</p><p>우리의 작업을 보존하기 위해 새로운 네임스페이스 두 개를 만들자.</p><p>kubectl을 사용해 <code>development</code> 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/admin/namespace-dev.json
</span></span></code></pre></div><p>그런 다음 kubectl을 사용해 <code>production</code> 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/admin/namespace-prod.json
</span></span></code></pre></div><p>제대로 생성이 되었는지 확인하기 위해 클러스터 내의 모든 네임스페이스를 나열한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces --show-labels
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE       LABELS
default       Active    32m       &lt;none&gt;
development   Active    29s       name=development
production    Active    23s       name=production
</code></pre></li><li><p>네임스페이스마다 파드 생성</p><p>쿠버네티스 네임스페이스는 클러스터의 파드, 서비스 그리고 디플로이먼트의 범위를 제공한다.</p><p>하나의 네임스페이스와 상호 작용하는 사용자는 다른 네임스페이스의 내용을 볼 수 없다.</p><p>이를 보여주기 위해 <code>development</code> 네임스페이스에 간단한 디플로이먼트와 파드를 생성하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment snowflake --image<span style=color:#666>=</span>registry.k8s.io/serve_hostname  -n<span style=color:#666>=</span>development --replicas<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>단순히 호스트명을 제공해주는 <code>snowflake</code>라는 파드의 개수를 2개로 유지하는 디플로이먼트를 생성하였다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment -n<span style=color:#666>=</span>development
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
snowflake    2/2     2            2           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>snowflake -n<span style=color:#666>=</span>development
</span></span></code></pre></div><pre tabindex=0><code>NAME                         READY     STATUS    RESTARTS   AGE
snowflake-3968820950-9dgr8   1/1       Running   0          2m
snowflake-3968820950-vgc4n   1/1       Running   0          2m
</code></pre><p>개발자들은 <code>production</code> 네임스페이스의 내용에 영향을 끼칠 걱정 없이 하고 싶은 것을 할 수 있으니 대단하지 않은가.</p><p>이제 <code>production</code> 네임스페이스로 전환해 한 네임스페이스의 리소스가 다른 네임스페이스에서는 어떻게 숨겨지는지 보자.</p><p><code>production</code> 네임스페이스는 비어있어야 하며 아래 명령은 아무 것도 반환하지 않아야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment -n<span style=color:#666>=</span>production
</span></span><span style=display:flex><span>kubectl get pods -n<span style=color:#666>=</span>production
</span></span></code></pre></div><p>프로덕션이 가축 키우는 것을 좋아하듯이, 우리도 <code>production</code> 네임스페이스에 cattle(가축)이라는 이름의 파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment cattle --image<span style=color:#666>=</span>registry.k8s.io/serve_hostname -n<span style=color:#666>=</span>production
</span></span><span style=display:flex><span>kubectl scale deployment cattle --replicas<span style=color:#666>=</span><span style=color:#666>5</span> -n<span style=color:#666>=</span>production
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl get deployment -n<span style=color:#666>=</span>production
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
cattle       5/5     5            5           10s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>cattle -n<span style=color:#666>=</span>production
</span></span></code></pre></div><pre tabindex=0><code>NAME                      READY     STATUS    RESTARTS   AGE
cattle-2263376956-41xy6   1/1       Running   0          34s
cattle-2263376956-kw466   1/1       Running   0          34s
cattle-2263376956-n4v97   1/1       Running   0          34s
cattle-2263376956-p5p3i   1/1       Running   0          34s
cattle-2263376956-sxpth   1/1       Running   0          34s
</code></pre></li></ol><p>지금 쯤이면 사용자가 한 네임스페이스에 생성한 리소스는 다른 네임스페이스에서 숨겨져 있어야 한다는 것을 잘 알고 있을 것이다.</p><p>쿠버네티스 정책 지원이 발전함에 따라, 이 시나리오를 확장해 각 네임스페이스에
서로 다른 인증 규칙을 제공하는 방법을 보이도록 하겠다.</p><h2 id=네임스페이스의-사용-동기-이해하기>네임스페이스의 사용 동기 이해하기</h2><p>단일 클러스터는 여러 사용자 및 사용자 그룹(이하 '사용자 커뮤니티')의 요구를 충족시킬 수 있어야 한다.</p><p>쿠버네티스 <em>네임스페이스</em> 는 여러 프로젝트, 팀 또는 고객이 쿠버네티스 클러스터를 공유할 수 있도록 지원한다.</p><p>이를 위해 다음을 제공한다.</p><ol><li><a href=/ko/docs/concepts/overview/working-with-objects/names/>이름</a>에 대한 범위</li><li>인증과 정책을 클러스터의 하위 섹션에 연결하는 메커니즘</li></ol><p>여러 개의 네임스페이스를 사용하는 것은 선택 사항이다.</p><p>각 사용자 커뮤니티는 다른 커뮤니티와 격리된 상태로 작업할 수 있기를 원한다.</p><p>각 사용자 커뮤니티는 다음을 가진다.</p><ol><li>리소스 (파드, 서비스, 레플리케이션 컨트롤러(replication controller) 등</li><li>정책 (커뮤니티에서 조치를 수행할 수 있거나 없는 사람)</li><li>제약 조건 (해당 커뮤니티에서는 어느 정도의 쿼터가 허용되는지 등)</li></ol><p>클러스터 운영자는 각 사용자 커뮤니티 마다 네임스페이스를 생성할 수 있다.</p><p>네임스페이스는 다음을 위한 고유한 범위를 제공한다.</p><ol><li>(기본 명명 충돌을 방지하기 위해) 명명된 리소스</li><li>신뢰할 수 있는 사용자에게 관리 권한 위임</li><li>커뮤니티 리소스 소비를 제한하는 기능</li></ol><p>유스케이스는 다음을 포함한다.</p><ol><li>클러스터 운영자로서 단일 클러스터에서 여러 사용자 커뮤니티를 지원하려 한다.</li><li>클러스터 운영자로서 클러스터 분할에 대한 권한을
해당 커뮤니티의 신뢰할 수 있는 사용자에게 위임하려 한다.</li><li>클러스터 운영자로서 클러스터를 사용하는 다른 커뮤니티에 미치는 영향을 제한하기 위해
각 커뮤니티가 사용할 수 있는 리소스의 양을 제한하고자 한다.</li><li>클러스터 사용자로서 다른 사용자 커뮤니티가 클러스터에서 수행하는 작업과는 별도로
사용자 커뮤니티와 관련된 리소스와 상호 작용하고 싶다.</li></ol><h2 id=네임스페이스와-dns-이해하기>네임스페이스와 DNS 이해하기</h2><p><a href=/ko/docs/concepts/services-networking/service/>서비스</a>를 생성하면 상응하는 <a href=/ko/docs/concepts/services-networking/dns-pod-service/>DNS 엔트리(entry)</a>가 생성된다.
이 엔트리는 <code>&lt;서비스-이름>&lt;네임스페이스=이름>.svc.cluster.local</code> 형식을 갖는데,
컨테이너가 <code>&lt;서비스-이름></code>만 갖는 경우에는 네임스페이스에 국한된 서비스로 연결된다.
이 기능은 개발, 스테이징 및 프로덕션과 같이
여러 네임스페이스 내에서 동일한 설정을 사용할 때 유용하다.
네임스페이스를 넘어서 접근하려면 전체 주소 도메인 이름(FQDN)을 사용해야 한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/overview/working-with-objects/namespaces/#%EC%84%A0%ED%98%B8%ED%95%98%EB%8A%94-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0>네임스페이스 선호(preference)</a>에 대해 자세히 알아보기.</li><li><a href=/ko/docs/concepts/overview/working-with-objects/namespaces/#%EC%9A%94%EC%B2%AD%EC%97%90-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0>요청(request)에 대한 네임스페이스 설정</a>에 대해 자세히 알아보기.</li><li><a href=https://git.k8s.io/design-proposals-archive/architecture/namespaces.md>네임스페이스 설계</a> 참조하기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a3790dfb57271d13517e549dffa805b9>9 - 네트워크 폴리시(Network Policy) 선언하기</h1><p>이 문서는 사용자가 쿠버네티스 <a href=/ko/docs/concepts/services-networking/network-policies/>네트워크폴리시 API</a>를 사용하여 파드(Pod)가 서로 통신하는 방법을 제어하는 네트워크 폴리시를 선언하는데 도움을 준다.</p><div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.8.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><p>네트워크 폴리시를 지원하는 네트워크 제공자를 구성하였는지 확인해야 한다. 다음과 같이 네트워크폴리시를 지원하는 많은 네트워크 제공자들이 있다.</p><ul><li><a href=/docs/tasks/administer-cluster/network-policy-provider/antrea-network-policy/>Antrea</a></li><li><a href=/ko/docs/tasks/administer-cluster/network-policy-provider/calico-network-policy/>캘리코(Calico)</a></li><li><a href=/ko/docs/tasks/administer-cluster/network-policy-provider/cilium-network-policy/>실리움(Cilium)</a></li><li><a href=/ko/docs/tasks/administer-cluster/network-policy-provider/kube-router-network-policy/>Kube-router</a></li><li><a href=/ko/docs/tasks/administer-cluster/network-policy-provider/romana-network-policy/>로마나(Romana)</a></li><li><a href=/ko/docs/tasks/administer-cluster/network-policy-provider/weave-network-policy/>위브넷(Weave Net)</a></li></ul><h2 id=nginx-디플로이먼트-deployment-를-생성하고-서비스-service-를-통해-노출하기><code>nginx</code> 디플로이먼트(Deployment)를 생성하고 서비스(Service)를 통해 노출하기</h2><p>쿠버네티스 네트워크 폴리시가 어떻게 동작하는지 확인하기 위해서, <code>nginx</code> 디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl create deployment nginx --image=nginx
</span></span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>deployment.apps/nginx created
</code></pre><p><code>nginx</code> 라는 이름의 서비스를 통해 디플로이먼트를 노출한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl expose deployment nginx --port=80
</span></span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>service/nginx exposed
</code></pre><p>위 명령어들은 nginx 파드에 대한 디플로이먼트를 생성하고, <code>nginx</code> 라는 이름의 서비스를 통해 디플로이먼트를 노출한다. <code>nginx</code> 파드와 디플로이먼트는 <code>default</code> 네임스페이스(namespace)에 존재한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl get svc,pod
</span></span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE
service/kubernetes          10.100.0.1    &lt;none&gt;        443/TCP    46m
service/nginx               10.100.0.16   &lt;none&gt;        80/TCP     33s

NAME                        READY         STATUS        RESTARTS   AGE
pod/nginx-701339712-e0qfq   1/1           Running       0          35s
</code></pre><h2 id=다른-파드에서-접근하여-서비스-테스트하기>다른 파드에서 접근하여 서비스 테스트하기</h2><p>사용자는 다른 파드에서 새 <code>nginx</code> 서비스에 접근할 수 있어야 한다. <code>default</code> 네임스페이스에 있는 다른 파드에서 <code>nginx</code> 서비스에 접근하기 위하여, busybox 컨테이너를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl run busybox --rm -ti --image=busybox:1.28 -- /bin/sh
</span></span></span></code></pre></div><p>사용자 쉘에서, 다음의 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre><h2 id=nginx-서비스에-대해-접근-제한하기><code>nginx</code> 서비스에 대해 접근 제한하기</h2><p><code>access: true</code> 레이블을 가지고 있는 파드만 <code>nginx</code> 서비스에 접근할 수 있도록 하기 위하여, 다음과 같은 네트워크폴리시 오브젝트를 생성한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/networking/nginx-policy.yaml download=service/networking/nginx-policy.yaml><code>service/networking/nginx-policy.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-nginx-policy-yaml")' title="Copy service/networking/nginx-policy.yaml to clipboard"></img></div><div class=includecode id=service-networking-nginx-policy-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>access-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>access</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>네트워크폴리시 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 네트워크폴리시는 정책이 적용되는 파드의 그룹을 선택하는 <code>podSelector</code> 를 포함한다. 사용자는 이 정책이 <code>app=nginx</code> 레이블을 갖는 파드를 선택하는 것을 볼 수 있다. 레이블은 <code>nginx</code> 디플로이먼트에 있는 파드에 자동으로 추가된다. 빈 <code>podSelector</code> 는 네임스페이스의 모든 파드를 선택한다.</div><h2 id=서비스에-정책-할당하기>서비스에 정책 할당하기</h2><p>kubectl을 사용하여 위 <code>nginx-policy.yaml</code> 파일로부터 네트워크폴리시를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl apply -f https://k8s.io/examples/service/networking/nginx-policy.yaml
</span></span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>networkpolicy.networking.k8s.io/access-nginx created
</code></pre><h2 id=access-레이블이-정의되지-않은-서비스에-접근-테스트>access 레이블이 정의되지 않은 서비스에 접근 테스트</h2><p>올바른 레이블이 없는 파드에서 <code>nginx</code> 서비스에 접근하려 할 경우, 요청 타임 아웃이 발생한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl run busybox --rm -ti --image=busybox:1.28 -- /bin/sh
</span></span></span></code></pre></div><p>사용자 쉘에서, 다음의 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
wget: download timed out
</code></pre><h2 id=접근-레이블을-정의하고-다시-테스트>접근 레이블을 정의하고 다시 테스트</h2><p>사용자는 요청이 허용되도록 하기 위하여 올바른 레이블을 갖는 파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl run busybox --rm -ti --labels=&#34;access=true&#34; --image=busybox:1.28 -- /bin/sh
</span></span></span></code></pre></div><p>사용자 쉘에서, 다음의 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-a8f6511197efcd7d0db80ade49620f9d>10 - 노드에 대한 확장 리소스 알리기</h1><p>이 페이지는 노드의 확장 리소스를 지정하는 방법을 보여준다.
확장 리소스를 통해 클러스터 관리자는 쿠버네티스에게
알려지지 않은 노드-레벨 리소스를 알릴 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=노드의-이름을-확인한다>노드의 이름을 확인한다</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><p>이 연습에 사용할 노드 중 하나를 선택한다.</p><h2 id=노드-중-하나에-새로운-확장-리소스를-알린다>노드 중 하나에 새로운 확장 리소스를 알린다</h2><p>노드에서 새로운 확장 리소스를 알리려면, 쿠버네티스 API 서버에
HTTP PATCH 요청을 보낸다. 예를 들어, 노드 중 하나에 4개의 동글(dongle)이 있다고
가정한다. 다음은 노드에 4개의 동글 리소스를 알리는 PATCH 요청의
예이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1
</span></span><span style=display:flex><span>Accept: application/json
</span></span><span style=display:flex><span>Content-Type: application/json-patch+json
</span></span><span style=display:flex><span>Host: k8s-master:8080
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#666>[</span>
</span></span><span style=display:flex><span>  <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;op&#34;</span>: <span style=color:#b44>&#34;add&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;path&#34;</span>: <span style=color:#b44>&#34;/status/capacity/example.com~1dongle&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;value&#34;</span>: <span style=color:#b44>&#34;4&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>]</span>
</span></span></code></pre></div><p>참고로 쿠버네티스는 동글이 무엇인지 또는 동글이 무엇을 위한 것인지 알 필요가 없다.
위의 PATCH 요청은 노드에 동글이라고 하는 네 가지 항목이 있음을
쿠버네티스에 알려준다.</p><p>쿠버네티스 API 서버에 요청을 쉽게 보낼 수 있도록 프록시를 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy
</span></span></code></pre></div><p>다른 명령 창에서 HTTP PATCH 요청을 보낸다.
<code>&lt;your-node-name></code> 을 노드의 이름으로 바꾼다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;, &#34;value&#34;: &#34;4&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이전 요청에서 <code>~1</code> 은 패치 경로의 / 문자에 대한
인코딩이다. JSON-Patch의 작업 경로값은 JSON-Pointer로
해석된다. 자세한 내용은 <a href=https://tools.ietf.org/html/rfc6901>IETF RFC 6901</a>의
섹션 3을 참고한다.</div><p>출력은 노드가 4개의 동글 용량을 가졌음을 나타낸다.</p><pre tabindex=0><code>&#34;capacity&#34;: {
  &#34;cpu&#34;: &#34;2&#34;,
  &#34;memory&#34;: &#34;2049008Ki&#34;,
  &#34;example.com/dongle&#34;: &#34;4&#34;,
</code></pre><p>노드의 정보를 확인한다.</p><pre tabindex=0><code>kubectl describe node &lt;your-node-name&gt;
</code></pre><p>다시 한 번, 출력에 동글 리소스가 표시된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb>  </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb>  </span>2049008Ki<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb>  </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이제, 애플리케이션 개발자는 특정 개수의 동글을 요청하는 파드를
만들 수 있다. <a href=/docs/tasks/configure-pod-container/extended-resource/>컨테이너에 확장 리소스 할당하기</a>를
참고한다.</p><h2 id=토론>토론</h2><p>확장 리소스는 메모리 및 CPU 리소스와 비슷하다. 예를 들어,
노드에서 실행 중인 모든 컴포넌트가 공유할 특정 양의 메모리와 CPU가
노드에 있는 것처럼, 노드에서 실행 중인 모든 컴포넌트가
특정 동글을 공유할 수 있다. 또한 애플리케이션 개발자가
특정 양의 메모리와 CPU를 요청하는 파드를 생성할 수 있는 것처럼, 특정
동글을 요청하는 파드를 생성할 수 있다.</p><p>확장 리소스는 쿠버네티스에게 불투명하다. 쿠버네티스는 그것들이
무엇인지 전혀 모른다. 쿠버네티스는 노드에 특정 개수의 노드만
있다는 것을 알고 있다. 확장 리소스는 정수로 알려야
한다. 예를 들어, 노드는 4.5개의 동글이 아닌, 4개의 동글을 알릴 수 있다.</p><h3 id=스토리지-예제>스토리지 예제</h3><p>노드에 800GiB의 특별한 종류의 디스크 스토리지가 있다고 가정한다.
example.com/special-storage와 같은 특별한 스토리지의 이름을 생성할 수 있다.
그런 다음 특정 크기, 100GiB의 청크로 알릴 수 있다. 이 경우,
노드에는 example.com/special-storage 유형의 8가지 리소스가 있다고
알린다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/special-storage</span>:<span style=color:#bbb> </span><span style=color:#666>8</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이 특별한 스토리지에 대한 임의 요청을 허용하려면,
1바이트 크기의 청크로 특별한 스토리지를 알릴 수 있다. 이 경우, example.com/special-storage 유형의
800Gi 리소스를 알린다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/special-storage</span>:<span style=color:#bbb>  </span>800Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>그런 다음 컨테이너는 최대 800Gi의 임의 바이트 수의 특별한 스토리지를 요청할 수 있다.</p><h2 id=정리>정리</h2><p>다음은 노드에서 동글 알림을 제거하는 PATCH 요청이다.</p><pre tabindex=0><code>PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1
Accept: application/json
Content-Type: application/json-patch+json
Host: k8s-master:8080

[
  {
    &#34;op&#34;: &#34;remove&#34;,
    &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;,
  }
]
</code></pre><p>쿠버네티스 API 서버에 요청을 쉽게 보낼 수 있도록 프록시를 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy
</span></span></code></pre></div><p>다른 명령 창에서 HTTP PATCH 요청을 보낸다.
<code>&lt;your-node-name></code>을 노드의 이름으로 바꾼다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status
</span></span></code></pre></div><p>동글 알림이 제거되었는지 확인한다.</p><pre tabindex=0><code>kubectl describe node &lt;your-node-name&gt; | grep dongle
</code></pre><p>(출력이 보이지 않아야 함)</p><h2 id=다음-내용>다음 내용</h2><h3 id=애플리케이션-개발자를-위한-문서>애플리케이션 개발자를 위한 문서</h3><ul><li><a href=/docs/tasks/configure-pod-container/extended-resource/>컨테이너에 확장 리소스 할당하기</a></li></ul><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></li><li><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e1afcdac8d5e8458274b3c481c5ebcda>11 - 서비스 디스커버리를 위해 CoreDNS 사용하기</h1><p>이 페이지는 CoreDNS 업그레이드 프로세스와 kube-dns 대신 CoreDNS를 설치하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.9.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=coredns-소개>CoreDNS 소개</h2><p><a href=https://coredns.io>CoreDNS</a>는 쿠버네티스 클러스터의 DNS 역할을 수행할 수 있는,
유연하고 확장 가능한 DNS 서버이다.
쿠버네티스와 동일하게, CoreDNS 프로젝트도
<a class=glossary-tooltip title='클라우드 네이티브 컴퓨팅 재단' data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a>가 관리한다.</p><p>사용자는 기존 디플로이먼트인 kube-dns를 교체하거나,
클러스터를 배포하고 업그레이드하는 kubeadm과 같은 툴을 사용하여
클러스터 안의 kube-dns 대신 CoreDNS를 사용할 수 있다.</p><h2 id=coredns-설치>CoreDNS 설치</h2><p>Kube-dns의 배포나 교체에 관한 매뉴얼은 <a href=https://github.com/coredns/deployment/tree/master/kubernetes>CoreDNS GitHub 프로젝트</a>에
있는 문서를 확인하자.</p><h2 id=coredns로-이관하기>CoreDNS로 이관하기</h2><h3 id=kubeadm을-사용해-기존-클러스터-업그레이드하기>Kubeadm을 사용해 기존 클러스터 업그레이드하기</h3><p>쿠버네티스 버전 1.21에서, kubeadm은 DNS 애플리케이션으로서의 <code>kube-dns</code> 지원을 제거했다.
<code>kubeadm</code> v1.25 버전에서는,
DNS 애플리케이션으로 CoreDNS만이 지원된다.</p><p><code>kube-dns</code>를 사용 중인 클러스터를 업그레이드하기 위하여
<code>kubeadm</code> 을 사용할 때 CoreDNS로 전환할 수 있다.
이 경우, <code>kubeadm</code> 은 <code>kube-dns</code> 컨피그맵(ConfigMap)을 기반으로
스텁 도메인(stub domain), 업스트림 네임 서버의 설정을 유지하며 CoreDNS 설정("Corefile")을 생성한다.</p><h2 id=coredns-업그레이드하기>CoreDNS 업그레이드하기</h2><p><a href=https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md>쿠버네티스에서의 CoreDNS 버전</a> 페이지에서,
쿠버네티스 각 버전에 대해 kubeadm이 설치하는
CoreDNS의 버전을 확인할 수 있다.</p><p>CoreDNS만 업그레이드하고 싶거나 커스텀 이미지를 사용하고 싶은 경우,
CoreDNS를 수동으로 업그레이드할 수 있다.
<a href=https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md>가이드라인 및 따라해보기</a>를 참고하여
부드러운 업그레이드를 수행할 수 있다.
클러스터를 업그레이드할 때
기존 CoreDNS 환경 설정("Corefile")을 보존했는지 확인한다.</p><p><code>kubeadm</code> 도구를 사용하여 클러스터를 업그레이드하는 경우,
<code>kubeadm</code>이 자동으로 기존 CoreDNS 환경 설정을 보존한다.</p><h2 id=coredns-튜닝하기>CoreDNS 튜닝하기</h2><p>리소스 활용이 중요한 경우,
CoreDNS 구성을 조정하는 것이 유용할 수 있다.
더 자세한 내용은 <a href=https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md>CoreDNS 스케일링에 대한 설명서</a>를 확인한다.</p><h2 id=다음-내용>다음 내용</h2><p>CoreDNS 환경 설정("Corefile")을 수정하여
kube-dns보다 더 많은 유스케이스를 지원하도록 <a href=https://coredns.io>CoreDNS</a>를 구성할 수 있다.
더 많은 정보는 CoreDNS의 <code>kubernetes</code> 플러그인
<a href=https://coredns.io/plugins/kubernetes/>문서</a>를 참고하거나,
CoreDNS 블로그의
<a href=https://coredns.io/2017/05/08/custom-dns-entries-for-kubernetes/>쿠버네티스를 위한 커스텀 DNS 엔트리</a>를 확인한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a02f35804917d7a269c38d7e2c475005>12 - 스토리지 사용량 제한</h1><p>이 예제는 네임스페이스(namespace)에서 사용되는 스토리지의 용량을 제한하는 방법을 보여준다.</p><p>예제에서는 다음과 같은 리소스가 사용된다. <a href=/ko/docs/concepts/policy/resource-quotas/>리소스쿼터(ResourceQuota)</a>,
<a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>리밋레인지(LimitRange)</a>,
그리고 <a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트볼륨클레임(PersistentVolumeClaim)</a>.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</li></ul><h2 id=시나리오-스토리지-사용량-제한하기>시나리오: 스토리지 사용량 제한하기</h2><p>클러스터 관리자는 사용자를 대표하여 클러스터를 운영하고
, 비용을 제어하기 위해 단일 네임스페이스에서 사용할 수 있는 스토리지의 크기를 제어하려고 한다.</p><p>관리자는 다음을 제한하려고 한다.</p><ol><li>네임스페이스에 있는 퍼시스턴트볼륨클레임의 수</li><li>각 클레임(claim)이 요청할 수 있는 스토리지의 용량</li><li>네임스페이스가 가질 수 있는 누적 스토리지 용량</li></ol><h2 id=스토리지-요청을-제한하기-위한-리밋레인지-limitrange>스토리지 요청을 제한하기 위한 리밋레인지(LimitRange)</h2><p>네임스페이스에 <code>리밋레인지(LimitRange)</code>을 추가하면 스토리지 요청 크기가 최소 및 최대값으로 설정된다.
스토리지는 퍼시스턴트 볼륨 클레임(Persistent Volume Claim)을 통해 요청하게 된다.
제한 범위를 적용하는 어드미션 컨트롤러(Admission Controller)는 관리자가 설정한 값보다 높거나 낮은 PVC를 거부한다.</p><p>이 예제에서, 10Gi의 스토리지를 요청하는 PVC는 2Gi인 최대값을 초과하기 때문에 거부된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>storagelimits<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>2Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>스토리지 요청에 대한 최솟값은 해당 스토리지의 제공자가 최소값을 특정하여 요구하는 경우 사용한다.
예를 들어, AWS EBS 볼륨을 사용할 때는 최소 1Gi를 요청해야 한다.</p><h2 id=pvc-수와-누적-스토리지-용량을-제한하는-스토리지쿼터-storagequota>PVC 수와 누적 스토리지 용량을 제한하는 스토리지쿼터(StorageQuota)</h2><p>관리자는 네임스페이스의 PVC 수와 해당 PVC의 누적 용량을 제한할 수 있다.
최대값을 초과하는 새 PVC는 거부된다.</p><p>이 예제에서 네임스페이스의 6번째 PVC는 최대 카운트 5를 초과하기 때문에 거부된다. 또한,
위의 2Gi 최대 한계(max limit)와 결합된 5Gi 최대 할당량(maximum quota)은 각각 2Gi를 갖는 3개의 PVC를 가질 수 없다.
그것은 5Gi로 한도가 정해진 네임스페이스에 대해 6Gi의 요청이 될 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>storagequota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>persistentvolumeclaims</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests.storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5Gi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=요약>요약</h2><p>리밋레인지(LimitRange)을 지정하면 요청된 스토리지 양을 제한할 수 있으며
리소스쿼터(ResourceQuota)는 네임스페이스에 클레임(claim)수와 누적 스토리지 용량을 효과적으로 제한할 수 있다.
클러스터 관리자는 어느 프로젝트도 할당량을 초과하는 위험이 없도록 클러스터의 스토리지 예산을 계획할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4a02bcca41439e16655f43fa37c81da4>13 - 중요한 애드온 파드 스케줄링 보장하기</h1><p>API 서버, 스케줄러 및 컨트롤러 매니저와 같은 쿠버네티스 주요 컴포넌트들은 컨트롤 플레인 노드에서 동작한다. 반면, 애드온들은 일반 클러스터 노드에서 동작한다.
이러한 애드온들 중 일부(예: 메트릭 서버, DNS, UI)는 클러스터 전부가 정상적으로 동작하는 데 필수적일 수 있다.
만약, 필수 애드온이 축출되고(수동 축출, 혹은 업그레이드와 같은 동작으로 인한 의도하지 않은 축출)
pending 상태가 된다면, 클러스터가 더 이상 제대로 동작하지 않을 수 있다. (사용률이 매우 높은 클러스터에서 해당 애드온이
축출되자마자 다른 대기중인 파드가 스케줄링되거나 다른 이유로 노드에서 사용할 수 있는 자원량이 줄어들어 pending 상태가 발생할 수 있다)</p><p>유의할 점은, 파드를 중요(critical)로 표시하는 것은 축출을 완전히 방지하기 위함이 아니다. 이것은 단지 파드가 영구적으로 사용할 수 없게 되는 것만을 방지하기 위함이다.
중요로 표시한 스태틱(static) 파드는 축출될 수 없다. 반면, 중요로 표시한 일반적인(non-static) 파드의 경우 항상 다시 스케줄링된다.</p><h3 id=파드를-중요-critical-로-표시하기>파드를 중요(critical)로 표시하기</h3><p>파드를 중요로 표시하기 위해서는, 해당 파드에 대해 priorityClassName을 <code>system-cluster-critical</code>이나 <code>system-node-critical</code>로 설정한다. <code>system-node-critical</code>은 가장 높은 우선 순위를 가지며, 심지어 <code>system-cluster-critical</code>보다도 우선 순위가 높다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-09cc2cf3e0f23a3996e6cb31dc4d867c>14 - 쿠버네티스 API 활성화 혹은 비활성화하기</h1><p>이 페이지는 클러스터 <a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>의
특정한 API 버전을 활성화하거나 비활성화하는 방법에 대해 설명한다.</p><p>API 서버에 <code>--runtime-config=api/&lt;version></code> 커맨드 라인 인자를 사용함으로서 특정한 API 버전을
활성화하거나 비활성화할 수 있다. 이 인자에 대한 값으로는 콤마로 구분된 API 버전의 목록을 사용한다.
뒤쪽에 위치한 값은 앞쪽의 값보다 우선적으로 사용된다.</p><p>이 <code>runtime-config</code> 커맨드 라인 인자에는 다음의 두 개의 특수 키를 사용할 수도 있다.</p><ul><li><code>api/all</code>: 사용할 수 있는 모든 API를 선택한다.</li><li><code>api/legacy</code>: 레거시 API만을 선택한다. 여기서 레거시 API란 명시적으로
<a href=/docs/reference/using-api/deprecation-policy/>사용이 중단된</a> 모든 API를 가리킨다.</li></ul><p>예를 들어서, v1을 제외한 모든 API 버전을 비활성화하기 위해서는 <code>kube-apiserver</code>에
<code>--runtime-config=api/all=false,api/v1=true</code> 인자를 사용한다.</p><h2 id=다음-내용>다음 내용</h2><p><code>kube-apiserver</code> 컴포넌트에 대한 더 자세한 내용은 다음의 <a href=/docs/reference/command-line-tools-reference/kube-apiserver/>문서</a>
를 참고한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e77685d5b88d2db5c7631a27b9472eea>15 - 쿠버네티스 API를 사용하여 클러스터에 접근하기</h1><p>이 페이지는 쿠버네티스 API를 사용하여 클러스터에 접근하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=쿠버네티스-api에-접근>쿠버네티스 API에 접근</h2><h3 id=kubectl을-사용하여-처음으로-접근>kubectl을 사용하여 처음으로 접근</h3><p>쿠버네티스 API에 처음 접근하는 경우, 쿠버네티스
커맨드 라인 도구인 <code>kubectl</code> 을 사용한다.</p><p>클러스터에 접근하려면, 클러스터 위치를 알고 접근할 수 있는 자격 증명이
있어야 한다. 일반적으로, <a href=/ko/docs/setup/>시작하기 가이드</a>를
통해 작업하거나,
다른 사람이 클러스터를 설정하고 자격 증명과 위치를 제공할 때 자동으로 설정된다.</p><p>다음의 명령으로 kubectl이 알고 있는 위치와 자격 증명을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>많은 <a href=https://github.com/kubernetes/examples/tree/master/>예제</a>는 kubectl 사용에 대한 소개를
제공한다. 전체 문서는 <a href=/ko/docs/reference/kubectl/>kubectl 매뉴얼</a>에 있다.</p><h3 id=rest-api에-직접-접근>REST API에 직접 접근</h3><p>kubectl은 API 서버 찾기와 인증을 처리한다. <code>curl</code> 이나 <code>wget</code> 과 같은 http 클라이언트 또는 브라우저를 사용하여 REST API에
직접 접근하려는 경우, API 서버를 찾고 인증할 수 있는 여러 가지 방법이 있다.</p><ol><li>프록시 모드에서 kubectl을 실행한다(권장). 이 방법은 저장된 API 서버 위치를 사용하고 자체 서명된 인증서를 사용하여 API 서버의 ID를 확인하므로 권장한다. 이 방법을 사용하면 중간자(man-in-the-middle, MITM) 공격이 불가능하다.</li><li>또는, 위치와 자격 증명을 http 클라이언트에 직접 제공할 수 있다. 이 방법은 프록시를 혼란스럽게 하는 클라이언트 코드와 동작한다. 중간자 공격으로부터 보호하려면, 브라우저로 루트 인증서를 가져와야 한다.</li></ol><p>Go 또는 Python 클라이언트 라이브러리를 사용하면 프록시 모드에서 kubectl에 접근할 수 있다.</p><h4 id=kubectl-프록시-사용>kubectl 프록시 사용</h4><p>다음 명령은 kubectl을 리버스 프록시로 작동하는 모드에서 실행한다. API
서버 찾기와 인증을 처리한다.</p><p>다음과 같이 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span> &amp;
</span></span></code></pre></div><p>자세한 내용은 <a href=/docs/reference/generated/kubectl/kubectl-commands/#proxy>kubectl 프록시</a>를 참고한다.</p><p>그런 다음 curl, wget 또는 브라우저를 사용하여 API를 탐색할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://localhost:8080/api/
</span></span></code></pre></div><p>출력은 다음과 비슷하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=kubectl-프록시-없이-접근>kubectl 프록시 없이 접근</h4><p>다음과 같이 인증 토큰을 API 서버에 직접 전달하여 kubectl 프록시
사용을 피할 수 있다.</p><p><code>grep/cut</code> 방식을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># .KUBECONFIG에 여러 콘텍스트가 있을 수 있으므로, 가능한 모든 클러스터를 확인한다.</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{&#34;Cluster name\tServer\n&#34;}{range .clusters[*]}{.name}{&#34;\t&#34;}{.cluster.server}{&#34;\n&#34;}{end}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 위의 출력에서 상호 작용하려는 클러스터의 이름을 선택한다.</span>
</span></span><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>CLUSTER_NAME</span><span style=color:#666>=</span><span style=color:#b44>&#34;some_server_name&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 클러스터 이름을 참조하는 API 서버를 가리킨다.</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.clusters[?(@.name==\&#34;</span><span style=color:#b8860b>$CLUSTER_NAME</span><span style=color:#b44>\&#34;)].cluster.server}&#34;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 기본 서비스 어카운트용 토큰을 보관할 시크릿을 생성한다.</span>
</span></span><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: default-token
</span></span></span><span style=display:flex><span><span style=color:#b44>  annotations:
</span></span></span><span style=display:flex><span><span style=color:#b44>    kubernetes.io/service-account.name: default
</span></span></span><span style=display:flex><span><span style=color:#b44>type: kubernetes.io/service-account-token
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 토큰 컨트롤러가 해당 시크릿에 토큰을 기록할 때까지 기다린다.</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>while</span> ! kubectl describe secret default-token | grep -E <span style=color:#b44>&#39;^token&#39;</span> &gt;/dev/null; <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;waiting for token...&#34;</span> &gt;&amp;<span style=color:#666>2</span>
</span></span><span style=display:flex><span>  sleep <span style=color:#666>1</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 토큰 값을 얻는다</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get secret default-token -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.token}&#39;</span> | base64 --decode<span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># TOKEN으로 API 탐색</span>
</span></span><span style=display:flex><span>curl -X GET <span style=color:#b8860b>$APISERVER</span>/api --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b8860b>$TOKEN</span><span style=color:#b44>&#34;</span> --insecure
</span></span></code></pre></div><p>출력은 다음과 비슷하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위의 예는 <code>--insecure</code> 플래그를 사용한다. 이로 인해 MITM 공격이
발생할 수 있다. kubectl이 클러스터에 접근하면 저장된 루트 인증서와
클라이언트 인증서를 사용하여 서버에 접근한다. (<code>~/.kube</code> 디렉터리에
설치된다.) 클러스터 인증서는 일반적으로 자체 서명되므로,
http 클라이언트가 루트 인증서를 사용하도록 하려면 특별한 구성이
필요할 수 있다.</p><p>일부 클러스터에서, API 서버는 인증이 필요하지 않다. 로컬 호스트에서 제공되거나,
방화벽으로 보호될 수 있다. 이에 대한 표준은 없다.
<a href=/ko/docs/concepts/security/controlling-access>쿠버네티스 API에 대한 접근 제어</a>는 클러스터
관리자로서 이를 구성하는 방법에 대해 설명한다. 이러한 접근 방식은 향후 고 가용성 지원과 충돌할 수 있다.</p><h3 id=api에-프로그래밍-방식으로-접근>API에 프로그래밍 방식으로 접근</h3><p>쿠버네티스는 공식적으로 <a href=#go-client>Go</a>, <a href=#python-client>Python</a>, <a href=#java-client>Java</a>, <a href=#dotnet-client>dotnet</a>, <a href=#javascript-client>JavaScript</a> 및 <a href=#haskell-client>Haskell</a> 용 클라이언트 라이브러리를 지원한다. 쿠버네티스 팀이 아닌 작성자가 제공하고 유지 관리하는 다른 클라이언트 라이브러리가 있다. 다른 언어에서 API에 접근하고 인증하는 방법에 대해서는 <a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리</a>를 참고한다.</p><h4 id=go-client>Go 클라이언트</h4><ul><li>라이브러리를 얻으려면, 다음 명령을 실행한다. <code>go get k8s.io/client-go@kubernetes-&lt;kubernetes-version-number></code> 어떤 버전이 지원되는지를 확인하려면 <a href=https://github.com/kubernetes/client-go/releases>https://github.com/kubernetes/client-go/releases</a>를 참고한다.</li><li>client-go 클라이언트 위에 애플리케이션을 작성한다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> client-go는 자체 API 오브젝트를 정의하므로, 필요한 경우, 기본 리포지터리가 아닌 client-go에서 API 정의를 가져온다. 예를 들어, <code>import "k8s.io/client-go/kubernetes"</code> 가 맞다.</div><p>Go 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a2f;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> (
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;context&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;k8s.io/apimachinery/pkg/apis/meta/v1&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;k8s.io/client-go/kubernetes&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;k8s.io/client-go/tools/clientcmd&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// kubeconfig에서 현재 콘텍스트를 사용한다
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#080;font-style:italic>// path-to-kubeconfig -- 예를 들어, /root/.kube/config
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  config, _ <span style=color:#666>:=</span> clientcmd.<span style=color:#00a000>BuildConfigFromFlags</span>(<span style=color:#b44>&#34;&#34;</span>, <span style=color:#b44>&#34;&lt;path-to-kubeconfig&gt;&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// clientset을 생성한다
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  clientset, _ <span style=color:#666>:=</span> kubernetes.<span style=color:#00a000>NewForConfig</span>(config)
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 파드를 나열하기 위해 API에 접근한다
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  pods, _ <span style=color:#666>:=</span> clientset.<span style=color:#00a000>CoreV1</span>().<span style=color:#00a000>Pods</span>(<span style=color:#b44>&#34;&#34;</span>).<span style=color:#00a000>List</span>(context.<span style=color:#00a000>TODO</span>(), v1.ListOptions{})
</span></span><span style=display:flex><span>  fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;There are %d pods in the cluster\n&#34;</span>, <span style=color:#a2f>len</span>(pods.Items))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>애플리케이션이 클러스터 내의 파드로 배치된 경우, <a href=/ko/docs/tasks/access-application-cluster/access-cluster/#%ED%8C%8C%EB%93%9C%EC%97%90%EC%84%9C-api-%EC%A0%91%EA%B7%BC>파드 내에서 API 접근</a>을 참고한다.</p><h4 id=python-client>Python 클라이언트</h4><p><a href=https://github.com/kubernetes-client/python>Python 클라이언트</a>를 사용하려면, 다음 명령을 실행한다. <code>pip install kubernetes</code> 추가 설치 옵션은 <a href=https://github.com/kubernetes-client/python>Python Client Library 페이지</a>를 참고한다.</p><p>Python 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://github.com/kubernetes-client/python/blob/master/examples/out_of_cluster_config.py>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a2f;font-weight:700>from</span> <span style=color:#00f;font-weight:700>kubernetes</span> <span style=color:#a2f;font-weight:700>import</span> client, config
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>config<span style=color:#666>.</span>load_kube_config()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>v1<span style=color:#666>=</span>client<span style=color:#666>.</span>CoreV1Api()
</span></span><span style=display:flex><span><span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Listing pods with their IPs:&#34;</span>)
</span></span><span style=display:flex><span>ret <span style=color:#666>=</span> v1<span style=color:#666>.</span>list_pod_for_all_namespaces(watch<span style=color:#666>=</span><span style=color:#a2f;font-weight:700>False</span>)
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i <span style=color:#a2f;font-weight:700>in</span> ret<span style=color:#666>.</span>items:
</span></span><span style=display:flex><span>    <span style=color:#a2f>print</span>(<span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>%s</span><span style=color:#b62;font-weight:700>\t</span><span style=color:#b68;font-weight:700>%s</span><span style=color:#b62;font-weight:700>\t</span><span style=color:#b68;font-weight:700>%s</span><span style=color:#b44>&#34;</span> <span style=color:#666>%</span> (i<span style=color:#666>.</span>status<span style=color:#666>.</span>pod_ip, i<span style=color:#666>.</span>metadata<span style=color:#666>.</span>namespace, i<span style=color:#666>.</span>metadata<span style=color:#666>.</span>name))
</span></span></code></pre></div><h4 id=java-client>Java 클라이언트</h4><p><a href=https://github.com/kubernetes-client/java>Java 클라이언트</a>를 설치하려면, 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># java 라이브러리를 클론한다</span>
</span></span><span style=display:flex><span>git clone --recursive https://github.com/kubernetes-client/java
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 프로젝트 아티팩트, POM 등을 설치한다</span>
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> java
</span></span><span style=display:flex><span>mvn install
</span></span></code></pre></div><p>어떤 버전이 지원되는지를 확인하려면 <a href=https://github.com/kubernetes-client/java/releases>https://github.com/kubernetes-client/java/releases</a>를 참고한다.</p><p>Java 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://github.com/kubernetes-client/java/blob/master/examples/src/main/java/io/kubernetes/client/examples/KubeConfigFileClientExample.java>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>package</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.examples</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.ApiClient</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.ApiException</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.Configuration</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.apis.CoreV1Api</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.models.V1Pod</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.models.V1PodList</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.util.ClientBuilder</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.util.KubeConfig</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>java.io.FileReader</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>java.io.IOException</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> * 쿠버네티스 클러스터 외부의 애플리케이션에서 Java API를 사용하는 방법에 대한 간단한 예
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> * &lt;p&gt;이것을 실행하는 가장 쉬운 방법: mvn exec:java
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> * -Dexec.mainClass=&#34;io.kubernetes.client.examples.KubeConfigFileClientExample&#34;
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>class</span> <span style=color:#00f>KubeConfigFileClientExample</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>main</span><span style=color:#666>(</span>String<span style=color:#666>[]</span> args<span style=color:#666>)</span> <span style=color:#a2f;font-weight:700>throws</span> IOException<span style=color:#666>,</span> ApiException <span style=color:#666>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// KubeConfig의 파일 경로
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    String kubeConfigPath <span style=color:#666>=</span> <span style=color:#b44>&#34;~/.kube/config&#34;</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 파일시스템에서 클러스터 외부 구성인 kubeconfig 로드
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    ApiClient client <span style=color:#666>=</span>
</span></span><span style=display:flex><span>        ClientBuilder<span style=color:#666>.</span><span style=color:#b44>kubeconfig</span><span style=color:#666>(</span>KubeConfig<span style=color:#666>.</span><span style=color:#b44>loadKubeConfig</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>new</span> FileReader<span style=color:#666>(</span>kubeConfigPath<span style=color:#666>))).</span><span style=color:#b44>build</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 전역 디폴트 api-client를 위에서 정의한 클러스터 내 클라이언트로 설정
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    Configuration<span style=color:#666>.</span><span style=color:#b44>setDefaultApiClient</span><span style=color:#666>(</span>client<span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// CoreV1Api는 전역 구성에서 디폴트 api-client를 로드
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    CoreV1Api api <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> CoreV1Api<span style=color:#666>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// CoreV1Api 클라이언트를 호출한다
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    V1PodList list <span style=color:#666>=</span> api<span style=color:#666>.</span><span style=color:#b44>listPodForAllNamespaces</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;Listing all pods: &#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> <span style=color:#666>(</span>V1Pod item <span style=color:#666>:</span> list<span style=color:#666>.</span><span style=color:#b44>getItems</span><span style=color:#666>())</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>      System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span>item<span style=color:#666>.</span><span style=color:#b44>getMetadata</span><span style=color:#666>().</span><span style=color:#b44>getName</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h4 id=dotnet-client>dotnet 클라이언트</h4><p><a href=https://github.com/kubernetes-client/csharp>dotnet 클라이언트</a>를 사용하려면, 다음 명령을 실행한다. <code>dotnet add package KubernetesClient --version 1.6.1</code> 추가 설치 옵션은 <a href=https://github.com/kubernetes-client/csharp>dotnet Client Library 페이지</a>를 참고한다. 어떤 버전이 지원되는지를 확인하려면 <a href=https://github.com/kubernetes-client/csharp/releases>https://github.com/kubernetes-client/csharp/releases</a>를 참고한다.</p><p>dotnet 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://github.com/kubernetes-client/csharp/blob/master/examples/simple/PodList.cs>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a2f;font-weight:700>using</span> <span style=color:#00f;font-weight:700>System</span>;
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>using</span> <span style=color:#00f;font-weight:700>k8s</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>namespace</span> <span style=color:#00f;font-weight:700>simple</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>internal</span> <span style=color:#a2f;font-weight:700>class</span> <span style=color:#00f>PodList</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>private</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#a2f;font-weight:700>void</span> Main(<span style=color:#0b0;font-weight:700>string</span>[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#0b0;font-weight:700>var</span> config = KubernetesClientConfiguration.BuildDefaultConfig();
</span></span><span style=display:flex><span>            IKubernetes client = <span style=color:#a2f;font-weight:700>new</span> Kubernetes(config);
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#b44>&#34;Starting Request!&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#0b0;font-weight:700>var</span> list = client.ListNamespacedPod(<span style=color:#b44>&#34;default&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>foreach</span> (<span style=color:#0b0;font-weight:700>var</span> item <span style=color:#a2f;font-weight:700>in</span> list.Items)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(item.Metadata.Name);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> (list.Items.Count == <span style=color:#666>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#b44>&#34;Empty!&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=javascript-client>JavaScript 클라이언트</h4><p><a href=https://github.com/kubernetes-client/javascript>JavaScript 클라이언트</a>를 설치하려면, 다음 명령을 실행한다. <code>npm install @kubernetes/client-node</code> 어떤 버전이 지원되는지를 확인하려면 <a href=https://github.com/kubernetes-client/javascript/releases>https://github.com/kubernetes-client/javascript/releases</a>를 참고한다.</p><p>JavaScript 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://github.com/kubernetes-client/javascript/blob/master/examples/example.js>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> k8s <span style=color:#666>=</span> require(<span style=color:#b44>&#39;@kubernetes/client-node&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> kc <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> k8s.KubeConfig();
</span></span><span style=display:flex><span>kc.loadFromDefault();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> k8sApi <span style=color:#666>=</span> kc.makeApiClient(k8s.CoreV1Api);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>k8sApi.listNamespacedPod(<span style=color:#b44>&#39;default&#39;</span>).then((res) =&gt; {
</span></span><span style=display:flex><span>    console.log(res.body);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h4 id=haskell-client>Haskell 클라이언트</h4><p>어떤 버전이 지원되는지를 확인하려면 <a href=https://github.com/kubernetes-client/haskell/releases>https://github.com/kubernetes-client/haskell/releases</a>를 참고한다.</p><p>Haskell 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://github.com/kubernetes-client/haskell/blob/master/kubernetes-client/example/App.hs>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a000>exampleWithKubeConfig</span> <span style=color:#a2f;font-weight:700>::</span> <span style=color:#0b0;font-weight:700>IO</span> <span style=color:#a2f>()</span>
</span></span><span style=display:flex><span><span style=color:#00a000>exampleWithKubeConfig</span> <span style=color:#a2f;font-weight:700>=</span> <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>    oidcCache <span style=color:#a2f;font-weight:700>&lt;-</span> atomically <span style=color:#666>$</span> newTVar <span style=color:#666>$</span> <span style=color:#0b0;font-weight:700>Map</span><span style=color:#666>.</span>fromList <span style=color:#0b0;font-weight:700>[]</span>
</span></span><span style=display:flex><span>    (mgr, kcfg) <span style=color:#a2f;font-weight:700>&lt;-</span> mkKubeClientConfig oidcCache <span style=color:#666>$</span> <span style=color:#0b0;font-weight:700>KubeConfigFile</span> <span style=color:#b44>&#34;/path/to/kubeconfig&#34;</span>
</span></span><span style=display:flex><span>    dispatchMime
</span></span><span style=display:flex><span>            mgr
</span></span><span style=display:flex><span>            kcfg
</span></span><span style=display:flex><span>            (<span style=color:#0b0;font-weight:700>CoreV1</span><span style=color:#666>.</span>listPodForAllNamespaces (<span style=color:#0b0;font-weight:700>Accept</span> <span style=color:#0b0;font-weight:700>MimeJSON</span>))
</span></span><span style=display:flex><span>        <span style=color:#666>&gt;&gt;=</span> print
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/run-application/access-api-from-pod/>파드 내에서 쿠버네티스 API에 접근</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fe5ad73163d38596340536ec03a205f0>16 - 쿠버네티스 클러스터에서 sysctl 사용하기</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [stable]</code></div><p>이 문서는 쿠버네티스 클러스터에서 <a class=glossary-tooltip title='유닉스 커널 파라미터를 가져오거나 설정하는 데 사용하는 인터페이스' data-toggle=tooltip data-placement=top href=/ko/docs/tasks/administer-cluster/sysctl-cluster/ target=_blank aria-label=sysctl>sysctl</a> 인터페이스를 사용하여
커널 파라미터를 어떻게 구성하고, 사용하는지를
설명한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 쿠버네티스 버전 1.23부터, kubelet은 <code>/</code> 또는 <code>.</code>를
sysctl 이름의 구분자로 사용하는 것을 지원한다.
쿠버네티스 1.25 버전부터, 파드에 대해서도 sysctl을 설정할 때 슬래시 구분자를 지원하기 시작하였다.
예를 들어, 동일한 sysctl 이름을 <code>kernel.shm_rmid_forced</code>와 같이 마침표를 구분자로 사용하여 나타내거나
<code>kernel/shm_rmid_forced</code>와 같이 슬래시를 구분자로 사용하여 나타낼 수 있다.
sysctl 파라미터 변환에 대한 세부 사항은
리눅스 맨페이지 프로젝트의
<a href=https://man7.org/linux/man-pages/man5/sysctl.d.5.html>sysctl.d(5)</a> 페이지를 참고한다.</div><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>일부 단계에서는 실행 중인 클러스터의 kubelet에서
커맨드 라인 옵션을 재구성할 필요가 있다.</p><h2 id=모든-sysctl-파라미터-나열>모든 sysctl 파라미터 나열</h2><p>리눅스에서 sysctl 인터페이스는 관리자들이 런타임에 커널 파라미터를 수정할 수 있도록
허용한다. 파라미터는 <code>/proc/sys</code> 가상 파일 시스템을 통해 이용할 수 있다. 파라미터는
다음과 같은 다양한 서브 시스템을 포함한다.</p><ul><li>커널 (공통 접두사: <code>kernel.</code>)</li><li>네트워크 (공통 접두사: <code>net.</code>)</li><li>가상 메모리 (공통 접두사: <code>vm.</code>)</li><li>MDADM (공통 접두사: <code>dev.</code>)</li><li>더 많은 서브 시스템은 <a href=https://www.kernel.org/doc/Documentation/sysctl/README>커널 문서</a>에 설명되어 있다.</li></ul><p>모든 파라미터 리스트를 가져오려면 다음 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo sysctl -a
</span></span></code></pre></div><h2 id=unsafe-sysctl-활성화하기>unsafe sysctl 활성화하기</h2><p>sysctl은 <em>safe</em> sysctl과 <em>unsafe</em> sysctl로 구성되어 있다. <em>safe</em> sysctl은
적절한 네임스페이스 뿐만 아니라 동일한 노드의 파드 사이에 <em>고립</em> 되어야 한다. 즉, 하나의
파드에 <em>safe</em> sysctl을 설정한다는 것은 다음을 의미한다.</p><ul><li>노드의 다른 파드에 영향을 미치지 않아야 한다</li><li>노드의 상태를 손상시키지 않아야 한다</li><li>CPU 또는 메모리 리소스가 파드의 리소스 제한에 벗어나는 것을
허용하지 않아야 한다</li></ul><p>아직까지 대부분 <em>네임스페이스된</em> sysctl은 <em>safe</em> sysctl로 고려되지 않았다.
다음 sysctl은 <em>safe</em> 명령을 지원한다.</p><ul><li><code>kernel.shm_rmid_forced</code>,</li><li><code>net.ipv4.ip_local_port_range</code>,</li><li><code>net.ipv4.tcp_syncookies</code>,</li><li><code>net.ipv4.ping_group_range</code> (쿠버네티스 1.18 이후),</li><li><code>net.ipv4.ip_unprivileged_port_start</code> (쿠버네티스 1.22 이후).</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>net.ipv4.tcp_syncookies</code> 예시는 리눅스 커널 버전 4.4 또는 이하에서 네임스페이스되지 않는다.</div><p>kubelet이 더 고립된 방법을 지원하면 추후 쿠버네티스 버전에서
확장될 것이다.</p><p>모든 <em>safe</em> sysctl은 기본적으로 활성화된다.</p><p>모든 <em>unsafe</em> sysctl은 기본적으로 비활성화되고, 노드별 기본 클러스터 관리자에
의해 수동으로 메뉴얼로 허용되어야 한다.
unsafe sysctl이 비활성화된 파드는 스케줄링되지만, 시작에 실패한다.</p><p>위의 경고를 염두에 두고 클러스터 관리자는
고성능 또는 실시간 애플리케이션 조정과 같은
매우 특수한 상황에 대해 특정 <em>unsafe</em> sysctl을 허용할 수 있다. <em>unsafe</em> sysctl은
kubelet 플래그를 사용하여 노드별로 활성화된다. 예를 들면, 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubelet --allowed-unsafe-sysctls <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#b44>&#39;kernel.msg*,net.core.somaxconn&#39;</span> ...
</span></span></code></pre></div><p><a class=glossary-tooltip title='로컬에서 쿠버네티스를 실행하기 위한 도구.' data-toggle=tooltip data-placement=top href=/ko/docs/tasks/tools/#minikube target=_blank aria-label=Minikube>Minikube</a>의 경우, <code>extra-config</code> 플래그를 통해 이 작업을 수행할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start --extra-config<span style=color:#666>=</span><span style=color:#b44>&#34;kubelet.allowed-unsafe-sysctls=kernel.msg*,net.core.somaxconn&#34;</span>...
</span></span></code></pre></div><p><em>네임스페이스</em> sysctl만 이 방법을 사용할 수 있다.</p><h2 id=파드에-대한-sysctl-설정>파드에 대한 sysctl 설정</h2><p>수많은 sysctl은 최근 리눅스 커널에서 <em>네임스페이스</em> 되어 있다. 이는 노드의 각 파드에
대해 개별적으로 설정할 수 있다는 것이다. 쿠버네티스의 파드 securityContext를 통해
네임스페이스 sysctl만 구성할 수 있다.</p><p>다음 sysctls는 네임스페이스로 알려져 있다.
이 목록은 이후 버전의 Linux 커널에서 변경될 수 있다.</p><ul><li><code>kernel.shm*</code>,</li><li><code>kernel.msg*</code>,</li><li><code>kernel.sem</code>,</li><li><code>fs.mqueue.*</code>,</li><li><code>net.*</code> 아래의 파라미터는 컨테이너 네트워킹 네임스페이스에서 설정할 수 있다.
그러나 예외가 존재한다. (예, <code>net.netfilter.nf_conntrack_max</code>와 <code>net.netfilter.nf_conntrack_expect_max</code>는
컨테이너 네트워킹 네임스페이스에서 설정되지만,
네임스페이스가 없다.)</li></ul><p>네임스페이스가 없는 sysctl은 <em>node-level</em> sysctl이라고 부른다.
이를 설정해야 한다면, 각 노드의 OS에서 수동으로 구성하거나
특권있는 컨테이너의 데몬셋을 사용하여야 한다.</p><p>네임스페이스 sysctl을 구성하기 위해서 파드 securityContext를 사용한다.
securityContext는 동일한 파드의 모든 컨테이너에 적용된다.</p><p>이 예시는 safe sysctl <code>kernel.shm_rmid_forced</code>와 두 개의 unsafe sysctl인
<code>net.core.somaxconn</code> 과 <code>kernel.msgmax</code> 를 설정하기 위해 파드 securityContext를 사용한다.
스펙에 따르면 <em>safe</em> sysctl과 <em>unsafe</em> sysctl 간
차이는 없다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 파라미터의 영향을 파악한 후에만 운영체제가
불안정해지지 않도록 sysctl 파라미터를 수정한다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sysctl-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>sysctls</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kernel.shm_rmid_forced<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>net.core.somaxconn<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1024&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kernel.msgmax<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;65536&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> _unsafe_의 특성으로 인해 _unsafe_sysctl는 위험 부담이 있으며
컨테이너의 잘못된 동작, 리소스 부족 혹은 노드 완전 파손과 같은
심각한 문제를 초래할 수 있다.</div><p>특별한 sysctl 설정이 있는 노드를 클러스터 내에서 _tainted_로 간주하고
sysctl 설정이 필요한 노드에만 파드를 예약하는 것이 좋다.
이를 구현하려면 쿠버네티스 <a href=/docs/reference/generated/kubectl/kubectl-commands/#taint><em>테인트(taint)와 톨러레이션(toleration)</em> 기능</a> 을
사용하는 것이 좋다.</p><p>두 <em>unsafe</em> sysctl을 명시적으로 활성화하지 않은 노드에서 <em>unsafe</em> sysctl을 사용하는
파드가 시작되지 않는다. <em>node-level</em> sysctl과 마찬가지로
<a href=/docs/reference/generated/kubectl/kubectl-commands/#taint><em>테인트와 톨러레이션</em> 특징</a> 또는
<a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>노드 테인트</a>를
사용하여 해당 파드를 오른쪽 노드에
스케줄하는 것을 추천한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-fe6b50655c29ab0b7c1ee549ff64c138>17 - 클러스터 업그레이드</h1><p>이 페이지는 쿠버네티스 클러스터를 업그레이드하기 위해 따라야 할 단계에 대한
개요를 제공한다.</p><p>클러스터를 업그레이드하는 방법은 초기 배포 방법에 의존적이며,
배포 이후 관련된 변경 사항에도 의존적일 수 있다.</p><p>고수준으로 살펴 본, 수행 단계</p><ul><li><a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a> 업그레이드하기</li><li>클러스터 내부의 노드를 업그레이드하기</li><li><a class=glossary-tooltip title='쿠버네티스 클러스터와 통신하기 위한 커맨드라인 툴.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>과 같은 클라이언트 업그레이드하기</li><li>새로운 쿠버네티스 버전에 동반되는 API 변화에 기반하여, 매니페스트 또는
다른 리소스를 조정하기</li></ul><h2 id=시작하기-전에>시작하기 전에</h2><p>기존 클러스터가 존재해야 한다. 이 페이지는 쿠버네티스 1.24에서
쿠버네티스 1.25로 업그레이드하는 것에 관해 다룬다.
클러스터에서 쿠버네티스 1.24을 실행하지 않는 경우
업그레이드하려는 쿠버네티스 버전에 대한 설명서를 참고한다.</p><h2 id=업그레이드-방법>업그레이드 방법</h2><h3 id=upgrade-kubeadm>kubeadm</h3><p>클러스터가 <code>kubeadm</code> 도구를 사용하여 배포된 경우
클러스터 업그레이드 방법에 대한 자세한 내용은
<a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadm 클러스터 업그레이드</a>를 참조한다.</p><p>클러스터를 업그레이드한 후에는
<a href=/ko/docs/tasks/tools/><code>kubectl</code> 최신 버전을 설치</a>해야 한다.</p><h3 id=수동-배포>수동 배포</h3><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 이 단계는 네트워크 및 스토리지 플러그인과 같은
타사 확장을 고려하지 않는다.</div><p>다음 순서에 따라 컨트롤 플레인을 수동으로 업데이트해야 한다.</p><ul><li>etcd (모든 인스턴스)</li><li>kube-apiserver (모든 컨트롤 플레인 호스트)</li><li>kube-controller-manager</li><li>kube-scheduler</li><li>cloud controller manager (사용하는 경우)</li></ul><p>이 때 <a href=/ko/docs/tasks/tools/><code>kubectl</code> 최신 버전을 설치</a>
해야 한다.</p><p>클러스터의 각 노드에 대해 해당 노드를 <a href=/docs/tasks/administer-cluster/safely-drain-node/>드레인(drain)</a>
한 다음 1.25 kubelet을 사용하는 새 노드로 바꾸거나
해당 노드의 kubelet을 업그레이드하고 노드를 다시 가동한다.</p><h3 id=upgrade-other>다른 방식의 배포</h3><p>사용한 클러스터 배포 도구에 따라 해당 배포 도구가
제공하는 문서를 통하여, 유지 관리를 위해 권장되는 설정 단계를 확인한다.</p><h2 id=업그레이드-후-작업>업그레이드 후 작업</h2><h3 id=클러스터의-스토리지-api-버전-전환>클러스터의 스토리지 API 버전 전환</h3><p>클러스터에서 활성화된 쿠버네티스 리소스를
클러스터 내부적으로 표현(representation)하기 위해서 etcd로 직렬화된 객체는
특정 버전의 API를 사용하여 작성된다.</p><p>지원되는 API가 변경되면 이러한 개체를 새 API에서 다시 작성해야 할 수 있다.
이렇게 하지 않으면 결국 더 이상 디코딩할 수 없거나
쿠버네티스 API 서버에서 사용할 수 없는 리소스가 된다.</p><p>영향을 받는 각 객체를 지원되는 최신 API를 사용하여
가져온(fetch) 다음, 해당 API를 사용하여 다시 쓴다.</p><h3 id=매니페스트-업그레이드>매니페스트 업그레이드</h3><p>새로운 쿠버네티스 버전으로 업그레이드하면 새로운 API를 제공할 수 있다.</p><p><code>kubectl convert</code> 명령을 사용하여 서로 다른 API 버전 간에 매니페스트를 변환할 수 있다.
예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl convert -f pod.yaml --output-version v1
</span></span></code></pre></div><p><code>kubectl</code> 도구는 <code>pod.yaml</code>의 내용을 <code>kind</code>를 파드(변경되지 않음, unchanged)로 설정하는 매니페스트로 대체하고, 수정된 <code>apiVersion</code>으로 대체한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4e9de5bc3973e5d2bb8f09ff940c3319>18 - 클러스터에서 캐스케이딩 삭제 사용</h1><p>이 페이지에서는 <a class=glossary-tooltip title='쿠버네티스가 클러스터 자원을 정리하기 위해 사용하는 다양한 방법을 종합한 용어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/garbage-collection/ target=_blank aria-label='가비지 수집'>가비지 수집</a> 중
클러스터에서 사용할 <a href=/ko/docs/concepts/architecture/garbage-collection/#cascading-deletion>캐스케이딩 삭제</a>
타입을 지정하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>또한 다양한 타입들의 캐스케이딩 삭제를 실험하려면
<a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/#nginx-%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B3%A0-%ED%83%90%EC%83%89%ED%95%98%EA%B8%B0>샘플 디플로이먼트를 생성</a>할 필요가 있다. 각 타입에 대해 디플로이먼트를
다시 생성해야 할 수도 있다.</p><h2 id=파드에서-소유자-참조-확인>파드에서 소유자 참조 확인</h2><p>파드에서 <code>ownerReferences</code> 필드가 존재하는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력은 다음과 같이 <code>ownerReferences</code> 필드를 가진다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ownerReferences</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>blockOwnerDeletion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment-6b474476c4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>4fdcd81c-bd5d-41f7-97af-3a3b759af9a7<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=use-foreground-cascading-deletion>포그라운드(foreground) 캐스케이딩 삭제 사용</h2><p>기본적으로 쿠버네티스는 종속 오브젝트를 삭제하기 위해서
<a href=/ko/docs/concepts/architecture/garbage-collection/#background-deletion>백그라운드 캐스케이딩 삭제</a>를 사용한다. 클러스터를 실행하는 쿠버네티스 버전에 따라
<code>kubectl</code> 또는 쿠버네티스 API를 사용해
포그라운드 캐스케이딩 삭제로 전환할 수 있다.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><ul class="nav nav-tabs" id=foreground-deletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#foreground-deletion-0 role=tab aria-controls=foreground-deletion-0 aria-selected=true>쿠버네티스 1.20.x 이후 버전</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#foreground-deletion-1 role=tab aria-controls=foreground-deletion-1>쿠버네티스 1.20.x 전 버전</a></li></ul><div class=tab-content id=foreground-deletion><div id=foreground-deletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=foreground-deletion-0><p><p><code>kubectl</code> 또는 쿠버네티스 API를 사용해
포그라운드 캐스케이딩 삭제로 오브젝트들을 삭제할 수 있다.</p><p><strong>kubectl 사용</strong></p><p>다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>foreground
</span></span></code></pre></div><p><strong>쿠버네티스 API 사용</strong></p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력에는 다음과 같이
<code>foregroundDeletion</code> <a class=glossary-tooltip title='쿠버네티스가 오브젝트를 완전히 삭제하기 이전, 삭제 표시를 위해 특정 조건이 충족될 때까지 대기하도록 알려주기 위한 네임스페이스에 속한 키(namespaced key)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=파이널라이저(finalizer)>파이널라이저(finalizer)</a>가 포함되어 있다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Deployment&#34;,
&#34;apiVersion&#34;: &#34;apps/v1&#34;,
&#34;metadata&#34;: {
    &#34;name&#34;: &#34;nginx-deployment&#34;,
    &#34;namespace&#34;: &#34;default&#34;,
    &#34;uid&#34;: &#34;d1ce1b02-cae8-4288-8a53-30e84d8fa505&#34;,
    &#34;resourceVersion&#34;: &#34;1363097&#34;,
    &#34;creationTimestamp&#34;: &#34;2021-07-08T20:24:37Z&#34;,
    &#34;deletionTimestamp&#34;: &#34;2021-07-08T20:27:39Z&#34;,
    &#34;finalizers&#34;: [
      &#34;foregroundDeletion&#34;
    ]
    ...
</code></pre></li></ol></div><div id=foreground-deletion-1 class=tab-pane role=tabpanel aria-labelledby=foreground-deletion-1><p><p>쿠버네티스 API를 사용해
포그라운드 캐스케이딩 삭제로 오브젝트들을 삭제할 수 있다.</p><p>상세한 내용은 <a href=/ko/docs/home/supported-doc-versions/>쿠버네티스 버전에 따른 문서</a>를 참고한다.</p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력에는 다음과 같이
<code>foregroundDeletion</code> <a class=glossary-tooltip title='쿠버네티스가 오브젝트를 완전히 삭제하기 이전, 삭제 표시를 위해 특정 조건이 충족될 때까지 대기하도록 알려주기 위한 네임스페이스에 속한 키(namespaced key)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=파이널라이저(finalizer)>파이널라이저(finalizer)</a>가 포함되어 있다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Deployment&#34;,
&#34;apiVersion&#34;: &#34;apps/v1&#34;,
&#34;metadata&#34;: {
    &#34;name&#34;: &#34;nginx-deployment&#34;,
    &#34;namespace&#34;: &#34;default&#34;,
    &#34;uid&#34;: &#34;d1ce1b02-cae8-4288-8a53-30e84d8fa505&#34;,
    &#34;resourceVersion&#34;: &#34;1363097&#34;,
    &#34;creationTimestamp&#34;: &#34;2021-07-08T20:24:37Z&#34;,
    &#34;deletionTimestamp&#34;: &#34;2021-07-08T20:27:39Z&#34;,
    &#34;finalizers&#34;: [
      &#34;foregroundDeletion&#34;
    ]
    ...
</code></pre></li></ol></div></div><h2 id=use-background-cascading-deletion>백그라운드 캐스케이딩 삭제 사용</h2><ol><li><a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/#nginx-%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B3%A0-%ED%83%90%EC%83%89%ED%95%98%EA%B8%B0>샘플 디플로이먼트를 생성한다</a>.</li><li>클러스터를 실행하는 쿠버네티스 버전에 따라
디플로이먼트를 삭제하기 위해 <code>kubectl</code> 또는 쿠버네티스 API를 사용한다.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</li></ol><ul class="nav nav-tabs" id=background-deletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#background-deletion-0 role=tab aria-controls=background-deletion-0 aria-selected=true>쿠버네티스 1.20.x 이후 버전</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#background-deletion-1 role=tab aria-controls=background-deletion-1>쿠버네티스 1.20.x 전 버전</a></li></ul><div class=tab-content id=background-deletion><div id=background-deletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=background-deletion-0><p><p><code>kubectl</code> 또는 쿠버네티스 API를 사용해
백그라운드 캐스케이딩 삭제로 오브젝트들을 삭제할 수 있다.</p><p>쿠버네티스는 기본적으로 백그라운드 캐스케이딩 삭제를 사용하므로, <code>--cascade</code> 플래그
또는 <code>propagationPolicy</code> 인수 없이
다음 명령을 실행해도 같은 작업을 수행한다.</p><p><strong>kubectl 사용</strong></p><p>다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>background
</span></span></code></pre></div><p><strong>쿠버네티스 API 사용</strong></p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Background&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Status&#34;,
&#34;apiVersion&#34;: &#34;v1&#34;,
...
&#34;status&#34;: &#34;Success&#34;,
&#34;details&#34;: {
    &#34;name&#34;: &#34;nginx-deployment&#34;,
    &#34;group&#34;: &#34;apps&#34;,
    &#34;kind&#34;: &#34;deployments&#34;,
    &#34;uid&#34;: &#34;cc9eefb9-2d49-4445-b1c1-d261c9396456&#34;
}
</code></pre></li></ol></div><div id=background-deletion-1 class=tab-pane role=tabpanel aria-labelledby=background-deletion-1><p><p>쿠버네티스는 기본적으로 백그라운드 캐스케이딩 삭제를 사용하므로, <code>--cascade</code> 플래그
또는 <code>propagationPolicy: Background</code> 인수 없이
다음 명령을 실행해도 같은 작업을 수행한다.</p><p>상세한 내용은 <a href=/ko/docs/home/supported-doc-versions/>쿠버네티스 버전에 따른 문서</a>를 참고한다.</p><p><strong>kubectl 사용</strong></p><p>다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span></code></pre></div><p><strong>쿠버네티스 API 사용</strong></p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Background&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Status&#34;,
&#34;apiVersion&#34;: &#34;v1&#34;,
...
&#34;status&#34;: &#34;Success&#34;,
&#34;details&#34;: {
    &#34;name&#34;: &#34;nginx-deployment&#34;,
    &#34;group&#34;: &#34;apps&#34;,
    &#34;kind&#34;: &#34;deployments&#34;,
    &#34;uid&#34;: &#34;cc9eefb9-2d49-4445-b1c1-d261c9396456&#34;
}
</code></pre></li></ol></div></div><h2 id=set-orphan-deletion-policy>소유자 오브젝트 및 종속된 고아(orphan) 오브젝트 삭제</h2><p>기본적으로, 쿠버네티스에 오브젝트를 삭제하도록 지시하면
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는
종속 오브젝트들도 제거한다. 클러스터를 실행하는
쿠버네티스 버전에 따라 <code>kubectl</code> 또는 쿠버네티스 API를 사용해
종속 오브젝트를 쿠버네티스 <em>고아</em>로 만들 수 있다.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><ul class="nav nav-tabs" id=orphan-objects role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#orphan-objects-0 role=tab aria-controls=orphan-objects-0 aria-selected=true>쿠버네티스 1.20.x 이후 버전</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#orphan-objects-1 role=tab aria-controls=orphan-objects-1>쿠버네티스 1.20.x 전 버전</a></li></ul><div class=tab-content id=orphan-objects><div id=orphan-objects-0 class="tab-pane show active" role=tabpanel aria-labelledby=orphan-objects-0><p><p><strong>kubectl 사용</strong></p><p>다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>orphan
</span></span></code></pre></div><p><strong>쿠버네티스 API 사용</strong></p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력에는 다음과 같이 <code>finalizers</code> 필드에 <code>orphan</code>이 포함되어 있다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Deployment&#34;,
&#34;apiVersion&#34;: &#34;apps/v1&#34;,
&#34;namespace&#34;: &#34;default&#34;,
&#34;uid&#34;: &#34;6f577034-42a0-479d-be21-78018c466f1f&#34;,
&#34;creationTimestamp&#34;: &#34;2021-07-09T16:46:37Z&#34;,
&#34;deletionTimestamp&#34;: &#34;2021-07-09T16:47:08Z&#34;,
&#34;deletionGracePeriodSeconds&#34;: 0,
&#34;finalizers&#34;: [
  &#34;orphan&#34;
],
...
</code></pre></li></ol></div><div id=orphan-objects-1 class=tab-pane role=tabpanel aria-labelledby=orphan-objects-1><p><p>상세한 내용은 <a href=/ko/docs/home/supported-doc-versions/>쿠버네티스 버전에 따른 문서</a>를 참고한다.</p><p><strong>kubectl 사용</strong></p><p>다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>orphan
</span></span></code></pre></div><p><strong>쿠버네티스 API 사용</strong></p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력에는 다음과 같이 <code>finalizers</code> 필드에 <code>orphan</code>이 포함되어 있다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Deployment&#34;,
&#34;apiVersion&#34;: &#34;apps/v1&#34;,
&#34;namespace&#34;: &#34;default&#34;,
&#34;uid&#34;: &#34;6f577034-42a0-479d-be21-78018c466f1f&#34;,
&#34;creationTimestamp&#34;: &#34;2021-07-09T16:46:37Z&#34;,
&#34;deletionTimestamp&#34;: &#34;2021-07-09T16:47:08Z&#34;,
&#34;deletionGracePeriodSeconds&#34;: 0,
&#34;finalizers&#34;: [
  &#34;orphan&#34;
],
...
</code></pre></li></ol></div></div><p>디플로이먼트가 관리하는 파드들이 계속 실행 중인지 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li>쿠버네티스의 <a href=/docs/concepts/overview/working-with-objects/owners-dependents/>소유자와 종속 오브젝트</a>에 대해 알아보자.</li><li>쿠버네티스 <a href=/ko/docs/concepts/overview/working-with-objects/finalizers/>파이널라이저(finalizers)</a>에 대해 알아보자.</li><li><a href=/ko/docs/concepts/architecture/garbage-collection/>가비지(garbage) 수집</a>에 대해 알아보자.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fbc9136f53eccd6eb8c80f4bbea3b8f4>19 - 퍼시스턴트볼륨 반환 정책 변경하기</h1><p>이 페이지는 쿠버네티스 퍼시트턴트볼륨(PersistentVolume)의 반환 정책을
변경하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=왜-퍼시스턴트볼륨-반환-정책을-변경하는가>왜 퍼시스턴트볼륨 반환 정책을 변경하는가?</h2><p>퍼시스턴트볼륨은 "Retain(보존)", "Recycle(재활용)", "Delete(삭제)" 를 포함한
다양한 반환 정책을 갖는다. 동적으로 프로비저닝 된 퍼시스턴트볼륨의 경우
기본 반환 정책은 "Delete" 이다. 이는 사용자가 해당 <code>PersistentVolumeClaim</code> 을 삭제하면,
동적으로 프로비저닝 된 볼륨이 자동적으로 삭제됨을 의미한다.
볼륨에 중요한 데이터가 포함된 경우, 이러한 자동 삭제는 부적절 할 수 있다.
이 경우에는, "Retain" 정책을 사용하는 것이 더 적합하다.
"Retain" 정책에서, 사용자가 퍼시스턴트볼륨클레임을 삭제할 경우 해당하는
퍼시스턴트볼륨은 삭제되지 않는다.
대신, <code>Released</code> 단계로 이동되어, 모든 데이터를 수동으로 복구할 수 있다.</p><h2 id=퍼시스턴트볼륨-반환-정책-변경하기>퍼시스턴트볼륨 반환 정책 변경하기</h2><ol><li><p>사용자의 클러스터에서 퍼시스턴트볼륨을 조회한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pv
</span></span></code></pre></div><p>결과는 아래와 같다.</p><pre tabindex=0><code class=language-none data-lang=none>NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM             STORAGECLASS     REASON    AGE
pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1    manual                     10s
pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2    manual                     6s
pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim3    manual                     3s
</code></pre><p>이 목록은 동적으로 프로비저닝 된 볼륨을 쉽게 식별할 수 있도록
각 볼륨에 바인딩 되어 있는 퍼시스턴트볼륨클레임(PersistentVolumeClaim)의 이름도 포함한다.</p></li><li><p>사용자의 퍼시스턴트볼륨 중 하나를 선택한 후에 반환 정책을 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch pv &lt;your-pv-name&gt; -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;persistentVolumeReclaimPolicy&#34;:&#34;Retain&#34;}}&#39;</span>
</span></span></code></pre></div><p>여기서 <code>&lt;your-pv-name></code> 는 사용자가 선택한 퍼시스턴트볼륨의 이름이다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>윈도우에서는, 공백이 포함된 모든 JSONPath 템플릿에 <em>겹</em> 따옴표를 사용해야 한다.
(bash에 대해 위에서 표시된 홑 따옴표가 아니다.)
따라서 템플릿의 모든 표현식에서 홑 따옴표를 쓰거나, 이스케이프 처리된 겹 따옴표를 써야 한다. 예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>kubectl patch pv &lt;your-pv-name&gt; -p <span style=color:#b44>&#34;{\&#34;</span>spec\<span style=color:#b44>&#34;:{\&#34;</span>persistentVolumeReclaimPolicy\<span style=color:#b44>&#34;:\&#34;</span>Retain\<span style=color:#b44>&#34;}}&#34;</span>
</span></span></code></pre></div></div></li><li><p>선택한 PersistentVolume이 올바른 정책을 갖는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pv
</span></span></code></pre></div><p>결과는 아래와 같다.</p><pre tabindex=0><code class=language-none data-lang=none>NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM             STORAGECLASS     REASON    AGE
pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1    manual                     40s
pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2    manual                     36s
pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Retain          Bound     default/claim3    manual                     33s
</code></pre><p>위 결과에서, <code>default/claim3</code> 클레임과 바인딩 되어 있는 볼륨이 <code>Retain</code> 반환 정책을
갖는 것을 볼 수 있다. 사용자가 <code>default/claim3</code> 클레임을 삭제할 경우,
볼륨은 자동으로 삭제 되지 않는다.</p></li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트볼륨</a>에 대해 더 배워 보기.</li><li><a href=/ko/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>퍼시스턴트볼륨클레임</a>에 대해 더 배워 보기.</li></ul><h3 id=reference>레퍼런스</h3><ul><li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/>PersistentVolume</a><ul><li>퍼시스턴트볼륨의 <code>.spec.persistentVolumeReclaimPolicy</code>
<a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/#PersistentVolumeSpec>필드</a>에
주의한다.</li></ul></li><li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/>PersistentVolumeClaim</a></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>