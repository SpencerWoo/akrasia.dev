<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/job/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/tasks/job/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/job/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/job/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/job/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/job/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/tasks/job/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>잡(Job) 실행 | Kubernetes</title><meta property="og:title" content="잡(Job) 실행"><meta property="og:description" content="병렬 처리를 사용하여 잡을 실행한다."><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/tasks/job/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="잡(Job) 실행"><meta itemprop=description content="병렬 처리를 사용하여 잡을 실행한다."><meta name=twitter:card content="summary"><meta name=twitter:title content="잡(Job) 실행"><meta name=twitter:description content="병렬 처리를 사용하여 잡을 실행한다."><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="병렬 처리를 사용하여 잡을 실행한다."><meta property="og:description" content="병렬 처리를 사용하여 잡을 실행한다."><meta name=twitter:description content="병렬 처리를 사용하여 잡을 실행한다."><meta property="og:url" content="https://kubernetes.io/ko/docs/tasks/job/"><meta property="og:title" content="잡(Job) 실행"><meta name=twitter:title content="잡(Job) 실행"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/tasks/job/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/tasks/job/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/tasks/job/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/tasks/job/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/tasks/job/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tasks/job/>English</a>
<a class=dropdown-item href=/zh-cn/docs/tasks/job/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/tasks/job/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/tasks/job/>Français (French)</a>
<a class=dropdown-item href=/de/docs/tasks/job/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/tasks/job/>Español (Spanish)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/tasks/job/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>잡(Job) 실행</h1><div class=lead>병렬 처리를 사용하여 잡을 실행한다.</div><ul><li>1: <a href=#pg-964bdff888520740e5e221695245678d>크론잡(CronJob)으로 자동화된 작업 실행</a></li><li>2: <a href=#pg-1058efa4d70f13c015e6a2094ff85068>작업 대기열을 사용한 거친 병렬 처리</a></li><li>3: <a href=#pg-457c9dd93aed2b05615ed28dc38075d3>작업 대기열을 사용한 정밀 병렬 처리</a></li><li>4: <a href=#pg-9e63850014876afaebd1561f70bb8f6b>정적 작업 할당을 통한 병렬 처리를 위한 색인된 잡</a></li><li>5: <a href=#pg-da7c2b067953d239eb4457e8978ad8f6>확장을 사용한 병렬 처리</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-964bdff888520740e5e221695245678d>1 - 크론잡(CronJob)으로 자동화된 작업 실행</h1><p><a class=glossary-tooltip title='정기적인 일정으로 실행되는 반복 작업(잡).' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/cron-jobs/ target=_blank aria-label=크론잡>크론잡</a>을 이용하여
<a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a>을 시간 기반의 스케줄에 따라 실행할 수 있다.
이러한 자동화된 잡은 리눅스 또는 유닉스 시스템의 <a href=https://ko.wikipedia.org/wiki/Cron>크론</a> 작업처럼 실행된다.</p><p>크론 잡은 백업을 수행하거나 이메일을 보내는 것과 같이 주기적이고 반복적인 작업들을 생성하는 데 유용하다.
크론 잡은 시스템 사용이 적은 시간에 잡을 스케줄하려는 경우처럼 특정 시간에 개별 작업을 스케줄할 수도 있다.</p><p>크론 잡에는 제한 사항과 특이점이 있다.
예를 들어, 특정 상황에서는 하나의 크론 잡이 여러 잡을 생성할 수 있다.
따라서, 잡은 멱등성을 가져야 한다.</p><p>제한 사항에 대한 자세한 내용은 <a href=/ko/docs/concepts/workloads/controllers/cron-jobs/>크론잡</a>을 참고한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul></li></ul><h2 id=creating-a-cron-job>크론잡(CronJob) 생성</h2><p>크론 잡은 구성 파일이 필요하다.
다음은 1분마다 간단한 데모 작업을 실행하는 크론잡 매니페스트다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-cronjob-yaml")' title="Copy application/job/cronjob.yaml to clipboard"></img></div><div class=includecode id=application-job-cronjob-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * *&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>다음 명령을 사용하여 크론잡 예제를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/application/job/cronjob.yaml
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>cronjob.batch/hello created
</code></pre><p>크론 잡을 생성한 후, 다음 명령을 사용하여 상태를 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get cronjob hello
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        &lt;none&gt;          10s
</code></pre><p>명령의 결과에서 알 수 있듯이, 크론 잡은 아직 잡을 스케줄하거나 실행하지 않았다.
약 1분 내로 잡이 생성되는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get <span style=color:#a2f>jobs</span> --watch
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME               COMPLETIONS   DURATION   AGE
hello-4111706356   0/1                      0s
hello-4111706356   0/1           0s         0s
hello-4111706356   1/1           5s         5s
</code></pre><p>이제 "hello" 크론 잡에 의해 스케줄된 실행 중인 작업을 확인했다.
잡 감시를 중지한 뒤에 크론 잡이 다시 스케줄되었는지를 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get cronjob hello
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        50s             75s
</code></pre><p>크론 잡 <code>hello</code> 가 <code>LAST SCHEDULE</code> 열에 명시된 시간에 잡을 성공적으로 스케줄링한 것을 볼 수 있다.
현재는 0개의 활성 잡이 있고, 이는 작업이 완료되었거나 실패했음을 의미한다.</p><p>이제, 마지막으로 스케줄된 잡이 생성한 파드를 찾고 생성된 파드 중 하나의 표준 출력을 확인한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 잡 이름과 파드 이름은 다르다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;hello-4111706356&#34;을 사용자의 시스템에 있는 잡 이름으로 바꾼다</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span>job-name<span style=color:#666>=</span>hello-4111706356 --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items<span style=color:#666>[</span>*<span style=color:#666>]</span>.metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><p>파드의 로그를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>Fri Feb 22 11:02:09 UTC 2019
Hello from the Kubernetes cluster
</code></pre><h2 id=deleting-a-cron-job>크론잡(CronJob) 삭제</h2><p>더 이상 크론 잡이 필요하지 않으면, <code>kubectl delete cronjob &lt;cronjob name></code> 명령을 사용해서 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete cronjob hello
</span></span></code></pre></div><p>크론 잡을 삭제하면 생성된 모든 잡과 파드가 제거되고 추가 잡 생성이 중지된다.
<a href=/ko/docs/concepts/architecture/garbage-collection/>가비지(garbage) 수집</a>에서 잡 제거에 대해 상세한 내용을 읽을 수 있다.</p><h2 id=writing-a-cron-job-spec>크론잡(CronJob) 명세 작성</h2><p>다른 모든 쿠버네티스 오브젝트들과 마찬가지로,
크론잡은 <code>apiVersion</code>, <code>kind</code> 그리고 <code>metadata</code> 필드가 반드시 필요하다.
쿠버네티스 오브젝트 및 그 <a class=glossary-tooltip title='하나 이상의 쿠버네티스 API 오브젝트를 직렬화한 명세(specification).' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-manifest' target=_blank aria-label=매니페스트>매니페스트</a> 다루기에 대한
자세한 내용은 <a href=/ko/docs/concepts/cluster-administration/manage-deployment/>리소스 관리하기</a>와
<a href=/ko/docs/concepts/overview/working-with-objects/object-management/>kubectl을 사용하여 리소스 관리하기</a> 문서를 참고한다.</p><p>크론잡(CronJob)의 각 매니페스트에는 <a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%AA%85%EC%84%B8-spec-%EC%99%80-%EC%83%81%ED%83%9C-status><code>.spec</code></a> 섹션도 필요하다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 크론잡(CronJob)을 수정한 경우, 수정 후 새로 실행하는 작업부터 적용된다.
이미 시작된 작업(및 해당 파드)은 변경 없이 계속 실행된다.
즉, 크론잡(CronJob)은 기존 작업이 계속 실행 중이라면, 작업을 변경하지 <em>않는다.</em></div><h3 id=스케줄>스케줄</h3><p><code>.spec.schedule</code> 은 <code>.spec</code> 의 필수 필드이다.
이 필드는 <code>0 * * * *</code> 또는 <code>@hourly</code>와 같은 <a href=https://ko.wikipedia.org/wiki/Cron>크론</a> 형식의 문자열을 받아,
해당 잡이 생성 및 실행될 스케줄 시간으로 설정한다.</p><p>이 형식은 확장된 "Vixie cron" 스텝(step) 값도 포함한다. 이 내용은
<a href=https://www.freebsd.org/cgi/man.cgi?crontab%285%29>FreeBSD 매뉴얼</a>에 설명되어 있다.</p><blockquote><p>스텝 값은 범위(range)와 함께 사용할 수 있다. 범위 뒤에 <code>/&lt;number></code> 를
지정하여 범위 내에서 숫자만큼의 값을 건너뛴다. 예를 들어,
시간 필드에 <code>0-23/2</code> 를 사용하여 매 2시간마다 명령 실행을
지정할 수 있다(V7 표준의 대안은 <code>0,2,4,6,8,10,12,14,16,18,20,22</code>
이다). 별표(asterisk) 뒤에 붙이는 스텝도 허용되며,
"2시간마다"라고 지정하고 싶으면, 간단히 <code>*/2</code> 를 사용하면 된다.</p></blockquote><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 스케줄에서 물음표(<code>?</code>)는 별표 <code>*</code> 와 동일한 의미를 가지며,
주어진 필드에 대해 사용할 수 있는 모든 값을 나타낸다.</div><h3 id=잡-템플릿>잡 템플릿</h3><p><code>.spec.jobTemplate</code> 은 잡에 대한 템플릿이며, 이것은 필수 필드다.
이것은 중첩되어(nested) 있고 <code>apiVersion</code> 이나 <code>kind</code> 가 없다는 것을 제외하면,
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a>과 정확히 같은 스키마를 가진다.
잡 <code>.spec</code> 을 작성하는 것에 대한 내용은 <a href=/ko/docs/concepts/workloads/controllers/job/#%EC%9E%A1-%EC%82%AC%EC%96%91-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0>잡 명세 작성하기</a>를 참고한다.</p><h3 id=시작-기한>시작 기한</h3><p><code>.spec.startingDeadlineSeconds</code> 필드는 선택 사항이다.
어떤 이유로든 스케줄된 시간을 놓친 경우 잡의 시작 기한을 초 단위로 나타낸다.
기한이 지나면, 크론 잡이 잡을 시작하지 않는다.
이러한 방식으로 기한을 맞추지 못한 잡은 실패한 작업으로 간주된다.
이 필드를 지정하지 않으면, 잡에 기한이 없다.</p><p><code>.spec.startingDeadlineSeconds</code> 필드가 (null이 아닌 값으로) 설정되어 있다면,
크론잡 컨트롤러는 예상 잡 생성 시각과 현재 시각의 차이를 측정하고,
시각 차이가 설정한 값보다 커지면 잡 생성 동작을 스킵한다.</p><p>예를 들어, <code>200</code> 으로 설정되었다면,
예상 잡 생성 시각으로부터 200초까지는 잡이 생성될 수 있다.</p><h3 id=동시성-정책>동시성 정책</h3><p><code>.spec.concurrencyPolicy</code> 필드도 선택 사항이다.
이것은 이 크론 잡에 의해 생성된 잡의 동시 실행을 처리하는 방법을 지정한다.
명세는 다음의 동시성 정책 중 하나만 지정할 수 있다.</p><ul><li><code>Allow</code>(기본값): 크론 잡은 동시에 실행되는 잡을 허용한다.</li><li><code>Forbid</code>: 크론 잡은 동시 실행을 허용하지 않는다.
새로운 잡을 실행할 시간이고 이전 잡 실행이 아직 완료되지 않은 경우, 크론 잡은 새로운 잡 실행을 건너뛴다.</li><li><code>Replace</code>: 새로운 잡을 실행할 시간이고 이전 잡 실행이 아직 완료되지 않은 경우,
크론 잡은 현재 실행 중인 잡 실행을 새로운 잡 실행으로 대체한다.</li></ul><p>참고로 동시성 정책은 동일한 크론 잡에 의해 생성된 잡에만 적용된다.
크론 잡이 여러 개인 경우, 각각의 잡은 항상 동시에 실행될 수 있다.</p><h3 id=일시-정지>일시 정지</h3><p><code>.spec.suspend</code> 필드도 선택 사항이다.
<code>true</code> 로 설정되면, 모든 후속 실행이 일시 정지된다.
이 설정은 이미 시작된 실행에는 적용되지 않는다.
기본값은 false이다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 스케줄된 시간 동안 잡이 일시 정지되어 있다면 누락된 잡으로 간주한다.
<a href=#%EC%8B%9C%EC%9E%91-%EA%B8%B0%ED%95%9C>시작 기한</a> 없이 기존의 크론 잡에 대해 <code>.spec.suspend</code> 가 <code>true</code> 에서 <code>false</code> 로 변경되면,
누락된 잡들이 즉시 스케줄된다.</div><h3 id=잡-히스토리-한도>잡 히스토리 한도</h3><p><code>.spec.successfulJobsHistoryLimit</code> 와 <code>.spec.failedJobsHistoryLimit</code> 필드는 선택 사항이다.
이들 필드는 기록을 보관해야 하는 완료 및 실패한 잡의 개수를 지정한다.
기본적으로, 각각 3과 1로 설정된다.
한도를 <code>0</code> 으로 설정하는 것은 잡 완료 후에 해당 잡 유형의 기록을 보관하지 않는다는 것이다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1058efa4d70f13c015e6a2094ff85068>2 - 작업 대기열을 사용한 거친 병렬 처리</h1><p>이 예제에서는, 여러 병렬 워커 프로세스를 활용해 쿠버네티스 잡(Job)을
실행한다.</p><p>이 예제에서는, 각 파드가 생성될 때 작업 대기열에서 하나의 작업 단위를
선택하여, 완료하고, 대기열에서 삭제하고, 종료한다.</p><p>이 예제에서의 단계에 대한 개요는 다음과 같다.</p><ol><li><strong>메시지 대기열 서비스를 시작한다.</strong> 이 예에서는, RabbitMQ를 사용하지만, 다른 메시지 대기열을 이용해도
된다. 실제로 사용할 때는, 한 번 메시지 대기열 서비스를 구축하고서 이를 여러 잡을 위해 재사용하기도 한다.</li><li><strong>대기열을 만들고, 메시지로 채운다.</strong> 각 메시지는 수행할 하나의 작업을 나타낸다.
이 예제에서, 메시지는 긴 계산을 수행할 정수다.</li><li><strong>대기열에서 작업을 수행하는 잡을 시작한다.</strong> 잡은 여러 파드를 시작한다. 각 파드는
메시지 대기열에서 하나의 작업을 가져와서, 처리한 다음, 대기열이 비워질 때까지 반복한다.</li></ol><h2 id=시작하기-전에>시작하기 전에</h2><p>기본적이고, 병렬 작업이 아닌,
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a>의 사용법에 대해 잘 알고 있어야 한다.</p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=메시지-대기열-서비스-시작>메시지 대기열 서비스 시작</h2><p>이 예시에서는 RabbitMQ를 사용하지만, 다른 AMQP 유형의 메시지 서비스를 사용하도록 예시를 조정할 수 있다.</p><p>실제로 사용할 때는, 클러스터에 메시지 대기열 서비스를 한 번
구축하고서, 여러 많은 잡이나 오래 동작하는 서비스에 재사용할 수 있다.</p><p>다음과 같이 RabbitMQ를 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.3/examples/celery-rabbitmq/rabbitmq-service.yaml
</span></span></code></pre></div><pre tabindex=0><code>service &#34;rabbitmq-service&#34; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.3/examples/celery-rabbitmq/rabbitmq-controller.yaml
</span></span></code></pre></div><pre tabindex=0><code>replicationcontroller &#34;rabbitmq-controller&#34; created
</code></pre><p>이 문서에서는 <a href=https://github.com/kubernetes/kubernetes/tree/release-1.3/examples/celery-rabbitmq>celery-rabbitmq 예제</a>에 나오는 정도로만 rabbitmq를 사용한다.</p><h2 id=메시지-대기열-서비스-테스트하기>메시지 대기열 서비스 테스트하기</h2><p>이제, 메시지 대기열을 이용해 실험할 수 있다. 임시
대화형 파드를 만들어 그 위에 도구들을 설치하고,
대기열을 실험해본다.</p><p>먼저 임시 대화형 파드를 만든다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 임시 대화형 컨테이너를 만든다.</span>
</span></span><span style=display:flex><span>kubectl run -i --tty temp --image ubuntu:18.04
</span></span></code></pre></div><pre tabindex=0><code>Waiting for pod default/temp-loe07 to be running, status is Pending, pod ready: false
... [ previous line repeats several times .. hit return when it stops ] ...
</code></pre><p>참고로 파드 이름과 명령 프롬프트는 위와 다를 수 있다.</p><p>다음으로 <code>amqp-tools</code>를 설치하여 메시지 대기열을 활용할 수 있게 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 도구들을 설치한다.</span>
</span></span><span style=display:flex><span>root@temp-loe07:/# apt-get update
</span></span><span style=display:flex><span>.... <span style=color:#666>[</span> lots of output <span style=color:#666>]</span> ....
</span></span><span style=display:flex><span>root@temp-loe07:/# apt-get install -y curl ca-certificates amqp-tools python dnsutils
</span></span><span style=display:flex><span>.... <span style=color:#666>[</span> lots of output <span style=color:#666>]</span> ....
</span></span></code></pre></div><p>후에, 이 패키지들을 포함하는 도커 이미지를 만든다.</p><p>다음으로, rabbitmq 서비스를 발견할 수 있는지 확인한다.</p><pre tabindex=0><code># rabbitmq-service가 쿠버네티스로부터 주어진 DNS 이름을 갖는다.

root@temp-loe07:/# nslookup rabbitmq-service
Server:        10.0.0.10
Address:    10.0.0.10#53

Name:    rabbitmq-service.default.svc.cluster.local
Address: 10.0.147.152

# 주소는 다를 수 있다.
</code></pre><p>만약 Kube-DNS가 적절히 구축되지 않았다면, 전 단계 작업이 작동하지 않을 수 있다.
환경 변수를 통해서도 서비스 IP를 찾을 수 있다.</p><pre tabindex=0><code># env | grep RABBIT | grep HOST
RABBITMQ_SERVICE_SERVICE_HOST=10.0.147.152
# 주소는 다를 수 있다.
</code></pre><p>다음으로 대기열을 생성하고, 메시지를 발행하고 사용할 수 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 다음 줄에서, rabbitmq-service는 rabbitmq-service에 접근할 수 있는 </span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 호스트네임이다. 5672는 rabbitmq의 표준 포트이다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@temp-loe07:/# <span style=color:#a2f>export</span> <span style=color:#b8860b>BROKER_URL</span><span style=color:#666>=</span>amqp://guest:guest@rabbitmq-service:5672
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 만약 전 단계에서 &#34;rabbitmq-service&#34;가 주소로 변환되지 않는다면,</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이 커맨드를 대신 사용하면 된다.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># root@temp-loe07:/# BROKER_URL=amqp://guest:guest@$RABBITMQ_SERVICE_SERVICE_HOST:5672</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이제 대기열을 생성한다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@temp-loe07:/# /usr/bin/amqp-declare-queue --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -q foo -d
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 대기열에 메시지를 하나 발행한다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@temp-loe07:/# /usr/bin/amqp-publish --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -r foo -p -b Hello
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 다시 메시지를 돌려받는다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@temp-loe07:/# /usr/bin/amqp-consume --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -q foo -c <span style=color:#666>1</span> cat <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>echo</span>
</span></span><span style=display:flex><span>Hello
</span></span><span style=display:flex><span>root@temp-loe07:/#
</span></span></code></pre></div><p>마지막 커맨드에서, <code>amqp-consume</code> 도구는 대기열로부터 하나의 메시지를
받고(<code>-c 1</code>), 그 메시지를 임의의 명령 표준입력으로 전달한다. 이 경우에는, <code>cat</code> 프로그램이 표준입력으로부터 받은 값을 출력하고, echo가 캐리지 리턴을 더해주어
출력 결과가 보여진다.</p><h2 id=작업으로-대기열-채우기>작업으로 대기열 채우기</h2><p>이제 몇 가지 "작업"으로 대기열을 채운다. 이 예제에서의 작업은 문자열을
출력하는 것이다.</p><p>실제로 사용할 때는, 메시지의 내용이 다음과 같을 수 있다.</p><ul><li>처리되어야 하는 파일들의 이름</li><li>프로그램의 추가 플래그</li><li>데이터베이스 테이블의 키(key) 범위</li><li>시뮬레이션의 구성 파라미터</li><li>렌더링해야 하는 씬(scene)의 프레임 번호</li></ul><p>실제로는, 잡의 모든 파드에서 읽기-전용 모드로 필요한 큰 데이터가
있다면, 일반적으로 그 데이터를 NFS와 같은 공유 파일시스템에 넣고
모든 파드에 읽기 전용으로 마운트하거나, 파드 안에 있는 프로그램이 기본적으로 HDFS와 같은
클러스터 파일시스템으로부터 데이터를 불러들인다.</p><p>본 예제에서는, 대기열을 만들고 amqp 커맨드라인 도구를 이용해 대기열을 채울 것이다.
실제로는, amqp 라이브러리를 이용해 대기열을 채우는 프로그램을 작성하게 된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/usr/bin/amqp-declare-queue --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -q job1  -d
</span></span><span style=display:flex><span>job1
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> f in apple banana cherry date fig grape lemon melon
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>  /usr/bin/amqp-publish --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -r job1 -p -b <span style=color:#b8860b>$f</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><p>8개의 메시지로 대기열을 채웠다.</p><h2 id=이미지-생성>이미지 생성</h2><p>이제 잡으로 실행할 이미지를 만들 준비가 되었다.</p><p><code>amqp-consume</code> 유틸리티를 이용해 대기열로부터 메시지를 읽고,
실제 프로그램을 실행해 볼 것이다.
여기에 아주 간단한 예제 프로그램이 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/rabbitmq/worker.py download=application/job/rabbitmq/worker.py><code>application/job/rabbitmq/worker.py</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-rabbitmq-worker-py")' title="Copy application/job/rabbitmq/worker.py to clipboard"></img></div><div class=includecode id=application-job-rabbitmq-worker-py><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#080;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 표준 출력만 출력하고 10초 동안 대기한다.</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>sys</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>time</span>
</span></span><span style=display:flex><span><span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Processing &#34;</span> <span style=color:#666>+</span> sys<span style=color:#666>.</span>stdin<span style=color:#666>.</span>readlines()[<span style=color:#666>0</span>])
</span></span><span style=display:flex><span>time<span style=color:#666>.</span>sleep(<span style=color:#666>10</span>)
</span></span></code></pre></div></div></div><p>스크립트에 실행 권한을 준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>chmod +x worker.py
</span></span></code></pre></div><p>이제 이미지를 빌드한다. 만약 소스 트리 안에서 작업하고
있다면, <code>examples/job/work-queue-1</code>로 디렉터리를 옮긴다.
아니면, 임시 디렉터리를 만들고, 그 디렉터리로 옮긴다.
<a href=/examples/application/job/rabbitmq/Dockerfile>Dockerfile</a>과
<a href=/examples/application/job/rabbitmq/worker.py>worker.py</a>를 다운로드한다.
위 두 경우 모두, 다음의 명령을 이용해 이미지를 빌드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker build -t job-wq-1 .
</span></span></code></pre></div><p><a href=https://hub.docker.com/>도커 허브</a>를 이용하기 위해, 앱 이미지를
사용자의 username으로 태깅하고 아래의 명령어를 이용해 허브에 푸시한다.
<code>&lt;username></code>을 사용자의 허브 username으로 대체한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker tag job-wq-1 &lt;username&gt;/job-wq-1
</span></span><span style=display:flex><span>docker push &lt;username&gt;/job-wq-1
</span></span></code></pre></div><p>만약 <a href=https://cloud.google.com/tools/container-registry/>구글 컨테이너
레지스트리</a>를 이용하고 있다면,
앱 이미지를 사용자의 프로젝트 ID를 이용해 태깅하고, GCR에 푸시한다.
<code>&lt;proejct></code> 부분을 사용자의 프로젝트 ID로 대체한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker tag job-wq-1 gcr.io/&lt;project&gt;/job-wq-1
</span></span><span style=display:flex><span>gcloud docker -- push gcr.io/&lt;project&gt;/job-wq-1
</span></span></code></pre></div><h2 id=잡-정의>잡 정의</h2><p>다음은 잡 정의이다. 잡의 사본을 만들고 위에서 정한 이름에 맞게
이미지를 수정하고, 파일 이름을 <code>./job.yaml</code>이라 정한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/rabbitmq/job.yaml download=application/job/rabbitmq/job.yaml><code>application/job/rabbitmq/job.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-rabbitmq-job-yaml")' title="Copy application/job/rabbitmq/job.yaml to clipboard"></img></div><div class=includecode id=application-job-rabbitmq-job-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>8</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/&lt;project&gt;/job-wq-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>BROKER_URL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>amqp://guest:guest@rabbitmq-service:5672<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>QUEUE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>job1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이 예시에서는, 각 파드가 대기열로부터 얻은 하나의 아이템을 수행하고 종료한다.
그래서, 잡의 완료 횟수가 완료된 작업 아이템의 숫자에 대응한다.
예시에서 <code>.spec.completions: 8</code>이라 정한 것도, 대기열에 8개의 아이템을 넣었기 때문이다.</p><h2 id=잡-실행>잡 실행</h2><p>이제 잡을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./job.yaml
</span></span></code></pre></div><p>이제 조금 기다린 다음, 잡을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe jobs/job-wq-1
</span></span></code></pre></div><pre tabindex=0><code>Name:             job-wq-1
Namespace:        default
Selector:         controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
Labels:           controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                  job-name=job-wq-1
Annotations:      &lt;none&gt;
Parallelism:      2
Completions:      8
Start Time:       Wed, 06 Sep 2017 16:42:02 +0800
Pods Statuses:    0 Running / 8 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                job-name=job-wq-1
  Containers:
   c:
    Image:      gcr.io/causal-jigsaw-637/job-wq-1
    Port:
    Environment:
      BROKER_URL:       amqp://guest:guest@rabbitmq-service:5672
      QUEUE:            job1
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Events:
  FirstSeen  LastSeen   Count    From    SubobjectPath    Type      Reason              Message
  ─────────  ────────   ─────    ────    ─────────────    ──────    ──────              ───────
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-hcobb
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-weytj
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-qaam5
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-b67sr
  26s        26s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-xe5hj
  15s        15s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-w2zqe
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-d6ppa
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-p17e0
</code></pre><p>모든 파드가 성공했다. 야호.</p><h2 id=대안>대안</h2><p>이러한 접근은 "워커" 프로그램을 작업 대기열에 맞게 수정하지 않아도
된다는 장점이 있다.</p><p>이 접근을 이용하려면, 메시지 대기열 서비스를 실행해야만 한다.
만약 메시지 대기열 서비스를 실행하는 게 불편하다면,
다른 <a href=/ko/docs/concepts/workloads/controllers/job/#%EC%9E%A1-%ED%8C%A8%ED%84%B4>잡 패턴</a>을 고려해볼 수 있다.</p><p>이 접근은 모든 작업 아이템에 대해 파드를 생성한다. 만약 작업 아이템이 오직 몇 초밖에 걸리지 않는 작업이라면,
매 작업마다 파드를 생성하는 것은 아주 큰 오버헤드를 더할 수 있다. 하나의 파드가
여러 작업 아이템을 수행하는 이 <a href=/ko/docs/tasks/job/fine-parallel-processing-work-queue/>예제</a>를 고려해보자.</p><p>이 예제에서는, <code>amqp-consume</code> 유틸리티를 이용해 대기열로부터 메시지를 읽어
실제 프로그램을 실행했다. 이러면 메시지 대기열을 이용하기 위해 프로그램을 수정하지
않아도 된다는 장점이 있다.
<a href=/ko/docs/tasks/job/fine-parallel-processing-work-queue/>다른 예제</a>는
클라이언트 라이브러리를 이용해 작업 대기열과 소통하는 방법을 보여준다.</p><h2 id=주의-사항>주의 사항</h2><p>만약 작업 완료 수가 대기열에 있는 아이템의 숫자보다 적게 설정되면,
모든 아이템 처리되지 않는다.</p><p>만약 작업 완료 수가 큐에 있는 아이템의 숫자보다 많게 설정되면,
대기열에 있는 아이템이 모두 처리되어도, 잡이 완료됐다고 표시되지
않고, 메시지를 기다리는 과정에서 막히는 파드를
추가적으로 실행시킨다.</p><p>이 패턴에서는 경쟁 상태(race)가 잘 나타나지 않는다. 만약 amqp-consume 명령으로부터
메시지가 인정되는 시간과 컨테이너가 성공적으로 종료되는
시간 사이에 컨테이너가 종료되거나, kubelet이 api-server에게 파드가 성공했음을 알리기 전에
노드가 비정상적으로 종료되면, 대기열의 모든 아이템이 처리되었다 해도,
잡이 완료되었다고 표시되지 않는다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-457c9dd93aed2b05615ed28dc38075d3>3 - 작업 대기열을 사용한 정밀 병렬 처리</h1><p>이 예에서는, 지정된 파드에서 여러 병렬 워커 프로세스가 있는
쿠버네티스 잡(Job)을 실행한다.</p><p>이 예에서는, 각 파드가 생성될 때, 작업 대기열에서 하나의 작업 단위를
선택하여, 처리하고, 대기열이 비워질 때까지 반복한다.</p><p>이 예에서의 단계에 대한 개요는 다음과 같다.</p><ol><li><strong>작업 대기열을 보관할 스토리지 서비스를 시작한다.</strong> 이 예에서는, Redis를 사용하여
작업 항목을 저장한다. 이전 예에서는, RabbitMQ를 사용했다. 이 예에서는, AMQP가 길이가
정해져 있는 작업 대기열이 비어있을 때 클라이언트가 이를 감지할 수 있는 좋은 방법을 제공하지
않기 때문에 Redis 및 사용자 지정의 작업 대기열 클라이언트 라이브러리를 사용한다. 실제로는
Redis와 같은 저장소를 한 번 설정하고 여러 작업과 다른 것들의 작업 대기열로 재사용한다.</li><li><strong>대기열을 만들고, 메시지로 채운다.</strong> 각 메시지는 수행할 하나의 작업을 나타낸다. 이
예에서, 메시지는 긴 계산을 수행할 정수다.</li><li><strong>대기열에서 작업을 수행하는 잡을 시작한다.</strong> 잡은 여러 파드를 시작한다. 각 파드는
메시지 대기열에서 하나의 작업을 가져와서, 처리한 다음, 대기열이 비워질 때까지 반복한다.</li></ol><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p><a href=/ko/docs/concepts/workloads/controllers/job/>잡</a>의 기본적이고,
병렬 작업이 아닌, 사용법에 대해 잘 알고 있어야 한다.</p><h2 id=redis-시작>Redis 시작</h2><p>이 문서의 예시에서는, 단순함을 위해, Redis의 단일 인스턴스를 시작한다.
Redis를 확장 가능하고 중복적으로 배포하는 예에 대해서는
<a href=https://github.com/kubernetes/examples/tree/master/guestbook>Redis 예시</a>를 참고한다.</p><p>다음 파일을 직접 다운로드할 수도 있다.</p><ul><li><a href=/examples/application/job/redis/redis-pod.yaml><code>redis-pod.yaml</code></a></li><li><a href=/examples/application/job/redis/redis-service.yaml><code>redis-service.yaml</code></a></li><li><a href=/examples/application/job/redis/Dockerfile><code>Dockerfile</code></a></li><li><a href=/examples/application/job/redis/job.yaml><code>job.yaml</code></a></li><li><a href=/examples/application/job/redis/rediswq.py><code>rediswq.py</code></a></li><li><a href=/examples/application/job/redis/worker.py><code>worker.py</code></a></li></ul><h2 id=작업으로-대기열-채우기>작업으로 대기열 채우기</h2><p>이제 몇 가지 "작업"으로 대기열을 채운다. 이 예제의 작업은 문자열을 출력하는
것이다.</p><p>Redis CLI를 실행하기 위한 임시 대화형 파드를 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run -i --tty temp --image redis --command <span style=color:#b44>&#34;/bin/sh&#34;</span>
</span></span><span style=display:flex><span>Waiting <span style=color:#a2f;font-weight:700>for</span> pod default/redis2-c7h78 to be running, status is Pending, pod ready: <span style=color:#a2f>false</span>
</span></span><span style=display:flex><span>Hit enter <span style=color:#a2f;font-weight:700>for</span> <span style=color:#a2f>command</span> prompt
</span></span></code></pre></div><p>이제 엔터 키를 누르고, redis CLI를 시작하고, 몇몇 작업 항목이 포함된 목록을 생성한다.</p><pre tabindex=0><code># redis-cli -h redis
redis:6379&gt; rpush job2 &#34;apple&#34;
(integer) 1
redis:6379&gt; rpush job2 &#34;banana&#34;
(integer) 2
redis:6379&gt; rpush job2 &#34;cherry&#34;
(integer) 3
redis:6379&gt; rpush job2 &#34;date&#34;
(integer) 4
redis:6379&gt; rpush job2 &#34;fig&#34;
(integer) 5
redis:6379&gt; rpush job2 &#34;grape&#34;
(integer) 6
redis:6379&gt; rpush job2 &#34;lemon&#34;
(integer) 7
redis:6379&gt; rpush job2 &#34;melon&#34;
(integer) 8
redis:6379&gt; rpush job2 &#34;orange&#34;
(integer) 9
redis:6379&gt; lrange job2 0 -1
1) &#34;apple&#34;
2) &#34;banana&#34;
3) &#34;cherry&#34;
4) &#34;date&#34;
5) &#34;fig&#34;
6) &#34;grape&#34;
7) &#34;lemon&#34;
8) &#34;melon&#34;
9) &#34;orange&#34;
</code></pre><p>자, 키 <code>job2</code> 가 있는 목록이 작업 대기열이 된다.</p><p>참고: Kube DNS를 올바르게 설정하지 않은 경우, 위 블록의
첫 번째 단계를 <code>redis-cli -h $REDIS_SERVICE_HOST</code> 로 변경해야 할 수 있다.</p><h2 id=이미지-생성>이미지 생성</h2><p>이제 실행할 이미지를 만들 준비가 되었다.</p><p>redis 클라이언트와 함께 python 워커 프로그램을 사용하여
메시지 큐에서 메시지를 읽는다.</p><p>rediswq.py(<a href=/examples/application/job/redis/rediswq.py>다운로드</a>)라는
간단한 Redis 작업 대기열 클라이언트 라이브러리가 제공된다.</p><p>잡의 각 파드에 있는 "워커" 프로그램은 작업 대기열
클라이언트 라이브러리를 사용하여 작업을 가져온다. 다음은 워커 프로그램이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/redis/worker.py download=application/job/redis/worker.py><code>application/job/redis/worker.py</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-redis-worker-py")' title="Copy application/job/redis/worker.py to clipboard"></img></div><div class=includecode id=application-job-redis-worker-py><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#080;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>time</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>rediswq</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>host<span style=color:#666>=</span><span style=color:#b44>&#34;redis&#34;</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Uncomment next two lines if you do not have Kube-DNS working.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># import os</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># host = os.getenv(&#34;REDIS_SERVICE_HOST&#34;)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>q <span style=color:#666>=</span> rediswq<span style=color:#666>.</span>RedisWQ(name<span style=color:#666>=</span><span style=color:#b44>&#34;job2&#34;</span>, host<span style=color:#666>=</span>host)
</span></span><span style=display:flex><span><span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Worker with sessionID: &#34;</span> <span style=color:#666>+</span>  q<span style=color:#666>.</span>sessionID())
</span></span><span style=display:flex><span><span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Initial queue state: empty=&#34;</span> <span style=color:#666>+</span> <span style=color:#a2f>str</span>(q<span style=color:#666>.</span>empty()))
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>while</span> <span style=color:#a2f;font-weight:700>not</span> q<span style=color:#666>.</span>empty():
</span></span><span style=display:flex><span>  item <span style=color:#666>=</span> q<span style=color:#666>.</span>lease(lease_secs<span style=color:#666>=</span><span style=color:#666>10</span>, block<span style=color:#666>=</span><span style=color:#a2f;font-weight:700>True</span>, timeout<span style=color:#666>=</span><span style=color:#666>2</span>)
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> item <span style=color:#a2f;font-weight:700>is</span> <span style=color:#a2f;font-weight:700>not</span> <span style=color:#a2f;font-weight:700>None</span>:
</span></span><span style=display:flex><span>    itemstr <span style=color:#666>=</span> item<span style=color:#666>.</span>decode(<span style=color:#b44>&#34;utf-8&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Working on &#34;</span> <span style=color:#666>+</span> itemstr)
</span></span><span style=display:flex><span>    time<span style=color:#666>.</span>sleep(<span style=color:#666>10</span>) <span style=color:#080;font-style:italic># Put your actual work here instead of sleep.</span>
</span></span><span style=display:flex><span>    q<span style=color:#666>.</span>complete(item)
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span>:
</span></span><span style=display:flex><span>    <span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Waiting for work&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Queue empty, exiting&#34;</span>)
</span></span></code></pre></div></div></div><p><a href=/examples/application/job/redis/worker.py><code>worker.py</code></a>,
<a href=/examples/application/job/redis/rediswq.py><code>rediswq.py</code></a> 및
<a href=/examples/application/job/redis/Dockerfile><code>Dockerfile</code></a> 파일을 다운로드할 수 있고, 그런 다음
이미지를 만들 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker build -t job-wq-2 .
</span></span></code></pre></div><h3 id=이미지-푸시>이미지 푸시</h3><p><a href=https://hub.docker.com/>도커 허브(Docker Hub)</a>를 위해, 아래 명령으로
사용자의 username과 앱 이미지에 태그하고 허브에 푸시한다. <code>&lt;username></code> 을
사용자의 허브 username으로 바꾼다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker tag job-wq-2 &lt;username&gt;/job-wq-2
</span></span><span style=display:flex><span>docker push &lt;username&gt;/job-wq-2
</span></span></code></pre></div><p>공용 저장소로 푸시하거나 <a href=/ko/docs/concepts/containers/images/>개인 저장소에 접근할 수 있도록
클러스터를 구성</a>해야 한다.</p><p><a href=https://cloud.google.com/tools/container-registry/>Google Container
Registry</a>를 사용하는 경우,
사용자의 프로젝트 ID로 앱 이미지에 태그를 지정하고 GCR로 푸시한다. <code>&lt;project></code> 를
사용자의 프로젝트 ID로 바꾼다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker tag job-wq-2 gcr.io/&lt;project&gt;/job-wq-2
</span></span><span style=display:flex><span>gcloud docker -- push gcr.io/&lt;project&gt;/job-wq-2
</span></span></code></pre></div><h2 id=잡-정의>잡 정의</h2><p>다음은 잡 정의이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/redis/job.yaml download=application/job/redis/job.yaml><code>application/job/redis/job.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-redis-job-yaml")' title="Copy application/job/redis/job.yaml to clipboard"></img></div><div class=includecode id=application-job-redis-job-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/myproject/job-wq-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>사용자 자신의 경로로 <code>gcr.io/myproject</code> 를
변경하려면 잡 템플릿을 편집해야 한다.</p><p>이 예에서, 각 파드는 대기열의 여러 항목에 대해 작업한 다음 더 이상 항목이 없을 때 종료된다.
워커는 작업 대기열이 비어있을 때를 감지하고 잡 컨트롤러는 작업 대기열에 대해
알지 못하기 때문에, 작업이 완료되면 워커에게 신호를 보낸다.
워커는 성공적으로 종료하여 대기열이 비어 있음을 알린다. 따라서, 워커가 성공적으로
종료하자마자, 컨트롤러는 작업이 완료되었음을 인식하고, 파드가 곧 종료된다.
따라서, 잡 완료 횟수를 1로 설정했다. 잡 컨트롤러는 다른 파드도 완료될 때까지
기다린다.</p><h2 id=잡-실행>잡 실행</h2><p>이제 잡을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./job.yaml
</span></span></code></pre></div><p>이제 조금 기다린 다음, 잡을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe jobs/job-wq-2
</span></span><span style=display:flex><span>Name:             job-wq-2
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Selector:         controller-uid<span style=color:#666>=</span>b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
</span></span><span style=display:flex><span>Labels:           controller-uid<span style=color:#666>=</span>b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
</span></span><span style=display:flex><span>                  job-name<span style=color:#666>=</span>job-wq-2
</span></span><span style=display:flex><span>Annotations:      &lt;none&gt;
</span></span><span style=display:flex><span>Parallelism:      <span style=color:#666>2</span>
</span></span><span style=display:flex><span>Completions:      &lt;unset&gt;
</span></span><span style=display:flex><span>Start Time:       Mon, <span style=color:#666>11</span> Jan <span style=color:#666>2016</span> 17:07:59 -0800
</span></span><span style=display:flex><span>Pods Statuses:    <span style=color:#666>1</span> Running / <span style=color:#666>0</span> Succeeded / <span style=color:#666>0</span> Failed
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:       controller-uid<span style=color:#666>=</span>b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
</span></span><span style=display:flex><span>                job-name<span style=color:#666>=</span>job-wq-2
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   c:
</span></span><span style=display:flex><span>    Image:              gcr.io/exampleproject/job-wq-2
</span></span><span style=display:flex><span>    Port:
</span></span><span style=display:flex><span>    Environment:        &lt;none&gt;
</span></span><span style=display:flex><span>    Mounts:             &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:              &lt;none&gt;
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message
</span></span><span style=display:flex><span>  ---------    --------    -----    ----            -------------    --------    ------            -------
</span></span><span style=display:flex><span>  33s          33s         <span style=color:#666>1</span>        <span style=color:#666>{</span>job-controller <span style=color:#666>}</span>                Normal      SuccessfulCreate  Created pod: job-wq-2-lglf8
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl logs pods/job-wq-2-7r7b2
</span></span><span style=display:flex><span>Worker with sessionID: bbd72d0a-9e5c-4dd6-abf6-416cc267991f
</span></span><span style=display:flex><span>Initial queue state: <span style=color:#b8860b>empty</span><span style=color:#666>=</span>False
</span></span><span style=display:flex><span>Working on banana
</span></span><span style=display:flex><span>Working on date
</span></span><span style=display:flex><span>Working on lemon
</span></span></code></pre></div><p>보시다시피, 사용자의 파드 중 하나가 여러 작업 단위에서 작업했다.</p><h2 id=대안>대안</h2><p>대기열 서비스를 실행하거나 작업 대기열을 사용하도록 컨테이너를 수정하는 것이 불편한 경우, 다른
<a href=/ko/docs/concepts/workloads/controllers/job/#%EC%9E%A1-%ED%8C%A8%ED%84%B4>잡 패턴</a>
중 하나를 고려할 수 있다.</p><p>만약 실행할 백그라운드 처리 작업의 연속 스트림이 있는 경우,
<code>ReplicaSet</code> 이 있는 백그라운드 워커를 실행하는 것과,
<a href=https://github.com/resque/resque>https://github.com/resque/resque</a>와 같은
백그라운드 처리 라이브러리를 실행하는 것이 좋다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9e63850014876afaebd1561f70bb8f6b>4 - 정적 작업 할당을 통한 병렬 처리를 위한 색인된 잡</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [stable]</code></div><p>이 예제에서는, 여러 병렬 워커(worker) 프로세스를 활용해 쿠버네티스 잡(Job)을
실행한다.
각 워커는 각 파드에서 실행되는 서로 다른 컨테이너다. 파드에는
컨트롤 플레인이 자동으로 설정한 <em>인덱스 번호</em> 가 부여되며, 이를 통해 각 파드는
전체 태스크 중 어느 부분을 수행해야 할 지 식별할 수 있다.</p><p>파드 인덱스는 10진수 값을 문자열로 표현한 <a class=glossary-tooltip title='임의의 식별되지 않는 메타데이터를 오브젝트에 첨부할 때 이용하는 키-밸류 쌍.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/annotations target=_blank aria-label=어노테이션>어노테이션</a>
<code>batch.kubernetes.io/job-completion-index</code> 를 통해
사용할 수 있다. 컨테이너화된 태스크 프로세스가 이 인덱스 정보를 가져갈 수 있도록,
<a href=/ko/docs/concepts/workloads/pods/downward-api/>다운워드(downward) API</a>
메커니즘을 사용하여 어노테이션의 값을 발행할 수 있다.
편의상, 컨트롤 플레인은 downward API를 자동 설정하여
<code>JOB_COMPLETION_INDEX</code> 환경변수에 인덱스를 노출할 수 있도록 한다.</p><p>이 예제에서의 단계에 대한 개요는 다음과 같다.</p><ol><li><strong>색인된 완료(indexed completion)를 사용하는 잡 매니페스트를 정의한다</strong>.
downward API를 통해 파드 인덱스 어노테이션을
환경변수 또는 파일의 형태로 컨테이너에 전달할 수 있다.</li><li><strong>해당 매니페스트를 바탕으로 색인된(<code>Indexed</code>) 잡을 시작한다</strong>.</li></ol><h2 id=시작하기-전에>시작하기 전에</h2><p>기본적이고, 병렬 작업이 아닌,
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a>의 사용법에 대해 잘 알고 있어야 한다.</p><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.21.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=접근-방법-선택하기>접근 방법 선택하기</h2><p>워커 프로그램에서 작업 항목에 접근하기 위한 몇 가지 선택지가 있다.</p><ol><li><code>JOB_COMPLETION_INDEX</code> 환경변수를 읽는다. 잡
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 는
이 환경변수를 완료 인덱스 정보를 갖고 있는 어노테이션에 자동
연결한다.</li><li>완료 인덱스 정보를 갖고 있는 파일을 읽는다.</li><li>프로그램을 수정할 수 없다면,
위 방법을 통해 인덱스를 읽고 프로그램의
입력값으로 사용 가능한 형태로 변환하는 스크립트로 감싸준다.</li></ol><p>예를 들어, 3번째 방법을 선택했으며
<a href=https://man7.org/linux/man-pages/man1/rev.1.html>rev</a> 유틸리티를 실행한다고 가정하면, 이
프로그램은 파일을 인자로 받아 그 내용을 거꾸로 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>rev data.txt
</span></span></code></pre></div><p><code>rev</code> 툴은
<a href=https://hub.docker.com/_/busybox><code>busybox</code></a> 컨테이너 이미지 내에서 실행할 것이다.</p><p>예제에 불과하므로, 각 파드는 아주 작은 작업(짧은 문자열 거꾸로 뒤집기)만을
수행한다. 실제 워크로드에서는 예를
들어
장면 정보를 바탕으로 60초 길이의 영상을 제작하는 태스크에 해당하는 잡을 생성할 수도 있다.
영상 렌더링 잡의 각 작업 항목은 영상 클립의 특정
프레임을 렌더링하는 것이다. 색인된 완료는 잡에 포함된 각 파드가
클립의 시작 지점부터 프레임 수를 세어 어느 프레임을 렌더링하고 발행해야 할 지
알고 있음을 의미한다.</p><h2 id=색인된-잡-정의하기>색인된 잡 정의하기</h2><p>다음은 색인된(<code>Indexed</code>) 완료 모드를 사용하는 잡 매니페스트의 예이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/indexed-job.yaml download=application/job/indexed-job.yaml><code>application/job/indexed-job.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-indexed-job-yaml")' title="Copy application/job/indexed-job.yaml to clipboard"></img></div><div class=includecode id=application-job-indexed-job-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;indexed-job&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completionMode</span>:<span style=color:#bbb> </span>Indexed<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;input&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/bash&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;bash&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          items=(foo bar baz qux xyz)
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt</span><span style=color:#bbb>          
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;worker&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/busybox&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;rev&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;/input/data.txt&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>위 예제에서, 잡 컨트롤러가 모든 컨테이너에 설정한 <code>JOB_COMPLETION_INDEX</code>
내장 환경 변수를 사용한다. <a href=/ko/docs/concepts/workloads/pods/init-containers/>초기화 컨테이너</a>는
인덱스를 정적 값으로 매핑하고 <a href=/ko/docs/concepts/storage/volumes/#emptydir>emptyDir 볼륨</a>을 통해
워커를 실행중인 컨테이너와 공유하는 파일에 쓴다.
선택적으로 컨테이너에 인덱스를 발행하기 위해 <a href=/ko/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>downward API를 통해
직접 환경 변수를 정의</a>할
수 있다. 또한 <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>환경변수 또는 파일로 된 컨피그맵(ConfigMap)</a>으로부터
값 목록을 불러올 수도 있다.</p><p>혹은 다음 예제와 같이 직접 <a href=/ko/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#%ED%8C%8C%EB%93%9C-%ED%95%84%EB%93%9C-%EC%A0%80%EC%9E%A5>downward API를 사용하여 어노테이션의 값을 볼륨 파일의 형태로 전달</a>할
수도 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/indexed-job-vol.yaml download=application/job/indexed-job-vol.yaml><code>application/job/indexed-job-vol.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-indexed-job-vol-yaml")' title="Copy application/job/indexed-job-vol.yaml to clipboard"></img></div><div class=includecode id=application-job-indexed-job-vol-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;indexed-job&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completionMode</span>:<span style=color:#bbb> </span>Indexed<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;worker&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/busybox&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;rev&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;/input/data.txt&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;data.txt&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.annotations[&#39;batch.kubernetes.io/job-completion-index&#39;]</span></span></code></pre></div></div></div><h2 id=잡-실행하기>잡 실행하기</h2><p>이제 잡을 실행하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 첫 번째 접근 방법을 사용한다. ($JOB_COMPLETION_INDEX 에 의존)</span>
</span></span><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/application/job/indexed-job.yaml
</span></span></code></pre></div><p>이 잡을 생성할 때, 컨트롤 플레인은 명시한 각 인덱스당 하나씩 일련의 파드를 생성한다. <code>.spec.parallelism</code>의 값은 한 번에 실행 가능한 수를 결정하는 반면 <code>.spec.completions</code>는 잡에서 총 생성되는 파드의 수를 결정한다.</p><p><code>.spec.parallelism</code>가 <code>.spec.completions</code>보다 작기 때문에, 컨트롤 플레인은 추가로 파드를 시작하기 전 최초 생성된 파드 중 일부가 완료되기를 기다린다.</p><p>잡을 생성했다면, 잠시 기다린 후 진행 상황을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe jobs/indexed-job
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>Name:              indexed-job
Namespace:         default
Selector:          controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
Labels:            controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
                   job-name=indexed-job
Annotations:       &lt;none&gt;
Parallelism:       3
Completions:       5
Start Time:        Thu, 11 Mar 2021 15:47:34 +0000
Pods Statuses:     2 Running / 3 Succeeded / 0 Failed
Completed Indexes: 0-2
Pod Template:
  Labels:  controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
           job-name=indexed-job
  Init Containers:
   input:
    Image:      docker.io/library/bash
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      bash
      -c
      items=(foo bar baz qux xyz)
      echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt

    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Containers:
   worker:
    Image:      docker.io/library/busybox
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      rev
      /input/data.txt
    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Volumes:
   input:
    Type:       EmptyDir (a temporary directory that shares a pod&#39;s lifetime)
    Medium:
    SizeLimit:  &lt;unset&gt;
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-njkjj
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-9kd4h
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-qjwsz
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-fdhq5
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-ncslj
</code></pre><p>이 예제에서는 각 인덱스에 직접 설정한 값을 갖는 잡을 실행한다. 파드
중 하나의 출력을 검사할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs indexed-job-fdhq5 <span style=color:#080;font-style:italic># 잡에 속한 파드의 이름에 맞춰 변경한다.</span>
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>xuq
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-da7c2b067953d239eb4457e8978ad8f6>5 - 확장을 사용한 병렬 처리</h1><p>이 태스크는 공통 템플릿을 기반으로 하는 여러 개의 <a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a>을
실행하는 것을 보여준다. 이 접근 방식을 사용하여 일괄 작업을 병렬로 처리할 수
있다.</p><p>이 예에는 <em>apple</em>, <em>banana</em> 그리고 <em>cherry</em> 세 항목만 있다.
샘플 잡들은 문자열을 출력한 다음 일시 정지하는 각 항목을 처리한다.</p><p>이 패턴이 보다 실질적인 유스케이스에 어떻게 부합하는지 알아 보려면
<a href=#%EC%8B%A4%EC%A0%9C-%EC%9B%8C%ED%81%AC%EB%A1%9C%EB%93%9C%EC%97%90%EC%84%9C-%EC%9E%A1-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>실제 워크로드에서 잡 사용하기</a>를 참고한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>사용자는 기본적인 내용과, 병렬 작업이 아닌
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a> 사용에 대해 익숙해야 한다.</p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>기본 템플릿을 사용하려면 커맨드 라인 유틸리티 <code>sed</code> 가 필요하다.</p><p>고급 템플릿 예제를 따라하려면, <a href=https://www.python.org/>파이썬(Python)</a>과
파이썬용 Jinja2 템플릿 라이브러리의 설치가
필요하다.</p><p>파이썬을 설정했으면, 다음을 실행하여 Jinja2를 설치할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pip install --user jinja2
</span></span></code></pre></div><h2 id=템플릿-기반의-잡-생성하기>템플릿 기반의 잡 생성하기</h2><p>먼저, 다음의 잡 템플릿을 다운로드해서 <code>job-tmpl.yaml</code> 파일로 저장한다.
다운로드할 내용은 다음과 같다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/job-tmpl.yaml download=application/job/job-tmpl.yaml><code>application/job/job-tmpl.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-job-tmpl-yaml")' title="Copy application/job/job-tmpl.yaml to clipboard"></img></div><div class=includecode id=application-job-job-tmpl-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>process-item-$ITEM<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>jobgroup</span>:<span style=color:#bbb> </span>jobexample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jobexample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>jobgroup</span>:<span style=color:#bbb> </span>jobexample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo Processing item $ITEM &amp;&amp; sleep 5&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># job-tmpl.yaml를 다운로드하기 위해 curl을 사용한다</span>
</span></span><span style=display:flex><span>curl -L -s -O https://k8s.io/examples/application/job/job-tmpl.yaml
</span></span></code></pre></div><p>다운로드한 파일은 아직 유효한 쿠버네티스
<a class=glossary-tooltip title='하나 이상의 쿠버네티스 API 오브젝트를 직렬화한 명세(specification).' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-manifest' target=_blank aria-label=매니페스트>매니페스트</a>가 아니다.
대신 해당 템플릿은 사용하기 전에 채워야하는 자리 표시자가 있는 잡 오브젝트의
YAML 표현이다. <code>$ITEM</code> 구문은 쿠버네티스에 의미가 있지 않다.</p><h3 id=템플릿에서-매니페스트-생성하기>템플릿에서 매니페스트 생성하기</h3><p>다음의 셸 스니펫은 <code>sed</code> 를 사용하여 루프 변수로 <code>$ITEM</code> 문자열을 바꾸고,
<code>jobs</code> 라는 임시 디렉터리에 기록한다. 다음과 같이 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 처리할 각 항목에 대해 하나씩, 템플릿을 여러 파일로 확장한다.</span>
</span></span><span style=display:flex><span>mkdir ./jobs
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in apple banana cherry
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>  cat job-tmpl.yaml | sed <span style=color:#b44>&#34;s/\$ITEM/</span><span style=color:#b8860b>$i</span><span style=color:#b44>/&#34;</span> &gt; ./jobs/job-<span style=color:#b8860b>$i</span>.yaml
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><p>작동하는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls jobs/
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>job-apple.yaml
job-banana.yaml
job-cherry.yaml
</code></pre><p>모든 유형의 템플릿 언어(예를 들어, Jinja2, ERB)를 사용하거나,
프로그램을 작성하여 잡 매니페스트를 생성할 수 있다.</p><h3 id=매니페스트에서-잡-생성하기>매니페스트에서 잡 생성하기</h3><p>다음으로, 하나의 kubectl 명령으로 모든 잡을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./jobs
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>job.batch/process-item-apple created
job.batch/process-item-banana created
job.batch/process-item-cherry created
</code></pre><p>이제, 작업을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get <span style=color:#a2f>jobs</span> -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME                  COMPLETIONS   DURATION   AGE
process-item-apple    1/1           14s        22s
process-item-banana   1/1           12s        21s
process-item-cherry   1/1           12s        20s
</code></pre><p>kubectl 명령에 <code>-l</code> 옵션을 사용하면 이 잡 그룹의
일부인 잡만 선택된다(시스템에서 관련이 없는 다른 잡이 있을 수 있음).</p><p>파드도 동일한 <a class=glossary-tooltip title='사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label='레이블 셀렉터'>레이블 셀렉터</a>를
사용하여 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME                        READY     STATUS      RESTARTS   AGE
process-item-apple-kixwv    0/1       Completed   0          4m
process-item-banana-wrsf7   0/1       Completed   0          4m
process-item-cherry-dnfu9   0/1       Completed   0          4m
</code></pre><p>이 단일 명령을 사용하여 모든 잡의 출력을 한 번에 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs -f -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</span></span></code></pre></div><p>출력 결과는 다음과 같아야 한다.</p><pre tabindex=0><code>Processing item apple
Processing item banana
Processing item cherry
</code></pre><h3 id=cleanup-1>정리</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 생성한 잡 제거</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 클러스터가 자동으로 잡의 파드들을 정리</span>
</span></span><span style=display:flex><span>kubectl delete job -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</span></span></code></pre></div><h2 id=고급-템플릿-파라미터-사용하기>고급 템플릿 파라미터 사용하기</h2><p><a href=#%ED%85%9C%ED%94%8C%EB%A6%BF-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%A1-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0>첫 번째 예제</a>에서, 템플릿의 각 인스턴스는 하나의
파라미터를 가지고, 해당 파라미터는 잡의 이름에도 사용되었다. 그러나,
<a href=/ko/docs/concepts/overview/working-with-objects/names/#names>이름</a>은
특정 문자들만 포함하도록 제한된다.</p><p>이런 약간 더 복잡한 예제는 <a href=https://palletsprojects.com/p/jinja/>Jinja 템플릿 언어</a>를
사용하여 각 잡에 대한 여러 파라미터로 매니페스트를 생성한 다음
해당 매니페스트에서 오브젝트를 생성한다.</p><p>태스크의 이 부분에서는, 한줄 파이썬 스크립트를 사용하여
매니페스트 집합으로 템플릿을 변환한다.</p><p>먼저, 다음의 잡 오브젝트 템플릿을 복사하고 붙여넣기하여, <code>job.yaml.jinja2</code> 파일로 저장한다.</p><pre tabindex=0><code class=language-liquid data-lang=liquid>{% set params = [{ &#34;name&#34;: &#34;apple&#34;, &#34;url&#34;: &#34;http://dbpedia.org/resource/Apple&#34;, },
                  { &#34;name&#34;: &#34;banana&#34;, &#34;url&#34;: &#34;http://dbpedia.org/resource/Banana&#34;, },
                  { &#34;name&#34;: &#34;cherry&#34;, &#34;url&#34;: &#34;http://dbpedia.org/resource/Cherry&#34; }]
%}
{% for p in params %}
{% set name = p[&#34;name&#34;] %}
{% set url = p[&#34;url&#34;] %}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: jobexample-{{ name }}
  labels:
    jobgroup: jobexample
spec:
  template:
    metadata:
      name: jobexample
      labels:
        jobgroup: jobexample
    spec:
      containers:
      - name: c
        image: busybox:1.28
        command: [&#34;sh&#34;, &#34;-c&#34;, &#34;echo Processing URL {{ url }} &amp;&amp; sleep 5&#34;]
      restartPolicy: Never
{% endfor %}
</code></pre><p>위의 템플릿은 파이썬 딕셔너리(dicts)로 구성된 항목(1-4행)을 사용하여 각 잡 오브젝트에 대해
두 개의 파라미터를 정의한다. <code>for</code> 루프는 각 파라미터의 집합(나머지 행)에 대해
하나의 잡 매니페스트를 방출한다.</p><p>이 예제는 YAML의 기능에 의존한다. 하나의 YAML 파일은 여러
문서(이 경우, 쿠버네티스 매니페스트)를 포함할 수 있으며, 행에 있는 <code>---</code> 로
구분된다.
출력 결과를 <code>kubectl</code> 에 직접 파이프를 사용해 잡을 생성할 수 있다.</p><p>다음으로, 이 한 줄 파이썬 프로그램을 사용하여 템플릿을 확장한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>render_template</span><span style=color:#666>=</span><span style=color:#b44>&#39;python -c &#34;from jinja2 import Template; import sys; print(Template(sys.stdin.read()).render());&#34;&#39;</span>
</span></span></code></pre></div><p><code>render_template</code> 을 사용해서 파라미터와 템플릿을 쿠버네티스 매니페스트가
포함된 하나의 YAML 파일로 변환한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 앞에서 정의한 앨리어스(alias)가 필요하다</span>
</span></span><span style=display:flex><span>cat job.yaml.jinja2 | render_template &gt; jobs.yaml
</span></span></code></pre></div><p><code>render_template</code> 스크립트가 제대로 동작하는지 확인하기 위해 <code>jobs.yaml</code> 을
볼 수 있다.</p><p><code>render_template</code> 스크립트가 원하는대로 동작하는 것을 확인했다면,
스크립트의 출력 결과를 파이프를 사용하여 <code>kubectl</code> 에 보낼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat job.yaml.jinja2 | render_template | kubectl apply -f -
</span></span></code></pre></div><p>쿠버네티스는 생성한 잡을 수락하고 실행한다.</p><h3 id=cleanup-2>정리</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 생성한 잡 제거</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 클러스터가 자동으로 잡이 있던 파드를 정리</span>
</span></span><span style=display:flex><span>kubectl delete job -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</span></span></code></pre></div><h2 id=실제-워크로드에서-잡-사용하기>실제 워크로드에서 잡 사용하기</h2><p>실제 유스케이스에서, 각 잡은 동영상의 프레임을 렌더링하거나, 데이터베이스에서 행 범위를
처리하는 것과 같은 상당한 규모의 계산을 수행한다. 동영상을 렌더링하는 경우 프레임 번호에
<code>$ITEM</code> 을 설정한다. 데이터베이스에서 행을 처리하는
경우, 처리할 데이터베이스 행의 범위를 나타내도록 <code>$ITEM</code> 을 설정한다.</p><p>이번 태스크에서, 로그를 가져와 파드에서 출력 결과를 수집하는 명령어를
실행했다. 실제 유스케이스에서, 잡의 각 파드는 완료하기 전에 출력 결과를
내구성있는 스토리지에 기록한다. 각 잡에 대해 퍼시스턴트볼륨(PersistentVolume)을
사용하거나 외장 스토리지 서비스를 사용할 수 있다. 예를 들어, 동영상의 프레임을 렌더링하는 경우,
HTTP를 사용하여 렌더링된 프레임 데이터를 각 프레임에 대한 다른 URL을 사용해서 URL에 <code>PUT</code>
한다.</p><h2 id=잡과-파드의-레이블>잡과 파드의 레이블</h2><p>잡을 생성한 후, 쿠버네티스는 한 잡의 파드를 다른 잡의 파드와 구별하기 위해서
추가 <a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>을
자동으로 추가한다.</p><p>이 예시에서, 각 잡과 잡의 파드 템플릿은 <code>jobgroup=jobexample</code>
레이블을 갖는다.</p><p>쿠버네티스 자체는 <code>jobgroup</code> 이라는 레이블에 신경쓰지 않는다. 템플릿에서
생성한 모든 잡에 대해 레이블을 설정하면 한번에 모든 잡을 편리하게
조작할 수 있다.
<a href=#%ED%85%9C%ED%94%8C%EB%A6%BF-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%A1-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0>첫 번째 예제</a>에서 템플릿을 사용해서
여러 잡을 생성했다. 템플릿은 각 파드도 동일한 레이블을 가질 수 있도록 보장하므로,
단일 명령어로 이러한 템플릿 기반 잡들의 모든 파드에서 확인할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 레이블 키 <code>jobgroup</code> 은 특별하거나 예약되어 있지 않다.
고유한 레이블링 체계를 선택할 수 있다.
원하는 경우 사용할 수 있는
<a href=/ko/docs/concepts/overview/working-with-objects/common-labels/#%EB%A0%88%EC%9D%B4%EB%B8%94>권장 레이블</a>이 있다.</div><h2 id=대안>대안</h2><p>많은 수의 잡 오브젝트의 생성을 계획 중이라면, 아마도 다음의 사항을 파악하게 될 것이다.</p><ul><li>레이블을 사용해도, 너무 많은 잡을 관리하는 것은 번거롭다.</li><li>일괄적으로 많은 잡을 생성하는 경우, 쿠버네티스 컨트롤 플레인에
높음 부하를 가할 수 있다. 대안으로, 쿠버네티스 API 서버가
속도를 제한하여 429 상태의 사용자 요청을 일시적으로 거부할 수 있다.</li><li>사용자는 잡의 <a class=glossary-tooltip title='네임스페이스당 전체 리소스 소비를 제한하는 제약을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/resource-quotas/ target=_blank aria-label='리소스 쿼터'>리소스 쿼터</a>로
제한될 수 있다. 한번에 많은 작업을 생성하면 API 서버가 사용자의 요청 중
일부를 영구적으로 거부한다.</li></ul><p>아주 많은 잡 오브젝트를 생성하지 않고 많은 양의 작업을 처리하는데 사용할 수 있는
다른 <a href=/ko/docs/concepts/workloads/controllers/job/#%EC%9E%A1-%ED%8C%A8%ED%84%B4>잡 패턴</a>도
있다.</p><p>잡 오브젝트를 자동으로 관리하기 위해 자체 <a href=/ko/docs/concepts/architecture/controller/>컨트롤러</a>를
작성하는 것도 고려할 수 있다.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>