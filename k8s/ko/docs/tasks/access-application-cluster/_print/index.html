<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/access-application-cluster/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/access-application-cluster/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/access-application-cluster/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/access-application-cluster/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/access-application-cluster/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/access-application-cluster/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/tasks/access-application-cluster/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>클러스터 내 어플리케이션 접근 | Kubernetes</title><meta property="og:title" content="클러스터 내 어플리케이션 접근"><meta property="og:description" content="클러스터의 애플리케이션에 접근하기 위해 로드 밸런싱, 포트 포워딩, 방화벽 설정 또는 DNS 구성을 설정한다."><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/tasks/access-application-cluster/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="클러스터 내 어플리케이션 접근"><meta itemprop=description content="클러스터의 애플리케이션에 접근하기 위해 로드 밸런싱, 포트 포워딩, 방화벽 설정 또는 DNS 구성을 설정한다."><meta name=twitter:card content="summary"><meta name=twitter:title content="클러스터 내 어플리케이션 접근"><meta name=twitter:description content="클러스터의 애플리케이션에 접근하기 위해 로드 밸런싱, 포트 포워딩, 방화벽 설정 또는 DNS 구성을 설정한다."><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="클러스터의 애플리케이션에 접근하기 위해 로드 밸런싱, 포트 포워딩, 방화벽 설정 또는 DNS 구성을 설정한다."><meta property="og:description" content="클러스터의 애플리케이션에 접근하기 위해 로드 밸런싱, 포트 포워딩, 방화벽 설정 또는 DNS 구성을 설정한다."><meta name=twitter:description content="클러스터의 애플리케이션에 접근하기 위해 로드 밸런싱, 포트 포워딩, 방화벽 설정 또는 DNS 구성을 설정한다."><meta property="og:url" content="https://kubernetes.io/ko/docs/tasks/access-application-cluster/"><meta property="og:title" content="클러스터 내 어플리케이션 접근"><meta name=twitter:title content="클러스터 내 어플리케이션 접근"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/tasks/access-application-cluster/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/tasks/access-application-cluster/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/tasks/access-application-cluster/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/tasks/access-application-cluster/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/tasks/access-application-cluster/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tasks/access-application-cluster/>English</a>
<a class=dropdown-item href=/zh-cn/docs/tasks/access-application-cluster/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/tasks/access-application-cluster/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/tasks/access-application-cluster/>Français (French)</a>
<a class=dropdown-item href=/de/docs/tasks/access-application-cluster/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/tasks/access-application-cluster/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/tasks/access-application-cluster/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/tasks/access-application-cluster/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>클러스터 내 어플리케이션 접근</h1><div class=lead>클러스터의 애플리케이션에 접근하기 위해 로드 밸런싱, 포트 포워딩, 방화벽 설정 또는 DNS 구성을 설정한다.</div><ul><li>1: <a href=#pg-777447042cd4e81df3fa5beb3357a485>쿠버네티스 대시보드를 배포하고 접속하기</a></li><li>2: <a href=#pg-6a8d9e9e05f2b6825afbb8889c957370>클러스터 접근</a></li><li>3: <a href=#pg-5a233e14205d77fe1294917d2da6f876>다중 클러스터 접근 구성</a></li><li>4: <a href=#pg-72d3dddbc0c166c9a364e753d2b31ff0>포트 포워딩을 사용해서 클러스터 내 애플리케이션에 접근하기</a></li><li>5: <a href=#pg-312f29f850826b74618634cd877aa065>클러스터 내 애플리케이션에 접근하기 위해 서비스 사용하기</a></li><li>6: <a href=#pg-f3dac629bea950fc026d920306f09fb4>서비스를 사용하여 프론트엔드를 백엔드에 연결</a></li><li>7: <a href=#pg-21cd8f87563675fb0278d3694ba9ecb0>외부 로드 밸런서 생성하기</a></li><li>8: <a href=#pg-1839d8468a083839ed1cc8d18fe1142e>NGINX 인그레스(Ingress) 컨트롤러로 Minikube에서 인그레스 설정하기</a></li><li>9: <a href=#pg-48e8f306f919c5b81265e265a2b76ab4>클러스터 내 모든 컨테이너 이미지 목록 보기</a></li><li>10: <a href=#pg-7c319a9981586e5fbcfa21b392720650>공유 볼륨을 이용하여 동일한 파드의 컨테이너 간에 통신하기</a></li><li>11: <a href=#pg-322786b38586b210fab68f785259c5f6>클러스터의 DNS 구성하기</a></li><li>12: <a href=#pg-43591bb11cc02c39e278cf07f6546810>클러스터에서 실행되는 서비스에 접근</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-777447042cd4e81df3fa5beb3357a485>1 - 쿠버네티스 대시보드를 배포하고 접속하기</h1><div class=lead>웹 UI(쿠버네티스 대시보드)를 배포하고 접속한다.</div><p>대시보드는 웹 기반 쿠버네티스 유저 인터페이스이다.
대시보드를 통해 컨테이너화 된 애플리케이션을 쿠버네티스 클러스터에 배포할 수 있고,
컨테이너화 된 애플리케이션을 트러블슈팅할 수 있으며, 클러스터 리소스들을 관리할 수 있다.
대시보드를 통해 클러스터에서 동작 중인 애플리케이션의 정보를 볼 수 있고,
개별적인 쿠버네티스 리소스들을(예를 들면 디플로이먼트, 잡, 데몬셋 등)
생성하거나 수정할 수 있다.
예를 들면, 디플로이먼트를 스케일하거나, 롤링 업데이트를 초기화하거나, 파드를 재시작하거나
또는 배포 마법사를 이용해 새로운 애플리케이션을 배포할 수 있다.</p><p>또한 대시보드는 클러스터 내 쿠버네티스 리소스들의 상태와 발생하는 모든 에러 정보를 제공한다.</p><p><img src=/images/docs/ui-dashboard.png alt="Kubernetes Dashboard UI"></p><h2 id=대시보드-ui-배포>대시보드 UI 배포</h2><p>대시보드 UI는 기본으로 배포되지 않는다. 배포하려면 다음 커맨드를 실행한다.</p><pre tabindex=0><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml
</code></pre><h2 id=대시보드-ui-접근>대시보드 UI 접근</h2><p>클러스터 데이터를 보호하기 위해, 대시보드는 기본적으로 최소한의 RBAC 설정을 제공한다.
현재, 대시보드는 Bearer 토큰으로 로그인하는 방법을 제공한다.
본 시연을 위한 토큰을 생성하기 위해서는,
<a href=https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md>샘플 사용자 만들기</a> 가이드를 따른다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 시연 중 생성한 샘플의 사용자에게는 관리자(admin) 권한이 부여되며, 이는 교육 목적으로만 사용한다.</div><h3 id=커맨드-라인-프록시>커맨드 라인 프록시</h3><p><code>kubectl</code> 커맨드라인 도구를 이용해 다음 커맨드를 실행함으로써 대시보드로의
접속을 활성화할 수 있다.</p><pre tabindex=0><code>kubectl proxy
</code></pre><p>kubectl은 <a href=http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a>를 통해 대시보드에 접속할 수 있게 해줄 것이다.</p><p>UI는 <em>오직</em> 커맨드가 실행된 머신에서만 접근 가능하다. 상세 내용은 <code>kubectl proxy --help</code> 옵션을 확인한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> Kubeconfig 인증 방법은 외부 아이덴티티 프로바이더
또는 X.509 인증서를 <strong>지원하지 않는다</strong>.</div><h2 id=웰컴-뷰>웰컴 뷰</h2><p>초기 클러스터 대시보드에 접근하면, 환영 페이지를 볼 수 있다.
이 페이지는 첫 애플리케이션을 배포하는 버튼이 있을 뿐만 아니라, 이 문서의 링크를 포함하고 있다.
게다가, 대시보드가 있는 클러스터에서 기본적으로 <code>kube-system</code>
<a href=/ko/docs/tasks/administer-cluster/namespaces/>네임스페이스</a>이 동작중인 시스템 애플리케이션을 볼 수 있다.</p><p><img src=/images/docs/ui-dashboard-zerostate.png alt="Kubernetes Dashboard welcome page"></p><h2 id=컨테이너화-된-애플리케이션-배포>컨테이너화 된 애플리케이션 배포</h2><p>대시보드를 이용하여 컨테이너화 된 애플리케이션을 디플로이먼트와 간단한 마법사를 통한 선택적인 서비스로 생성하고 배포할 수 있다.
애플리케이션 세부 정보를 수동으로 지정할 수 있고, 또는 애플리케이션 구성을 포함한 YAML 또는 JSON <em>매니페스트(manifest)</em> 파일을 업로드할 수 있다.</p><p>시작하는 페이지의 상위 오른쪽 코너에 있는 <strong>CREATE</strong> 버튼을 클릭한다.</p><h3 id=애플리케이션-세부-정보-지정>애플리케이션 세부 정보 지정</h3><p>배포 마법사는 다음 정보를 제공한다.</p><ul><li><p><strong>앱 이름</strong> (필수): 애플리케이션 이름.
<a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a> 이름은
배포할 모든 디플로이먼트와 서비스에 추가되어야 한다.</p><p>애플리케이션 이름은 선택된 쿠버네티스 <a href=/ko/docs/tasks/administer-cluster/namespaces/>네임스페이스</a> 안에서 유일해야 한다.
소문자로 시작해야 하며, 소문자 또는 숫자로 끝나고,
소문자, 숫자 및 대쉬(-)만을 포함해야 한다. 24 문자만을 제한한다.
처음과 끝의 스페이스는 무시된다.</p></li><li><p><strong>컨테이너 이미지</strong> (필수):
레지스트리에 올라간 퍼블릭 도커 <a href=/ko/docs/concepts/containers/images/>컨테이너 이미지</a>
또는 프라이빗 이미지(대체로 Google Container Registry 또는 도커 허브에 올라간)의 URL.
컨테이너 이미지 사양은 콜론으로 끝난다.</p></li><li><p><strong>파드의 수</strong> (필수): 배포하고 싶은 애플리케이션의 원하는 목표 파드 개수.
값은 양의 정수만 허용됩니다.</p><p>클러스터에 의도한 파드의 수를 유지하기 위해서
<a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>가 생성될 것이다.</p></li><li><p><strong>서비스</strong> (선택): 일부 애플리케이션의 경우, (예를 들어, 프론트엔드) 아마도 클러스터 바깥의
퍼블릭 IP 주소를 가진 (외부 서비스) 외부에 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>를
노출시키고 싶을 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 외부 서비스들을 위해, 한 개 또는 여러 개의 포트를 열어 둘 필요가 있다.</div><p>클러스터 내부에서만 보고 싶은 어떤 서비스들이 있을 것이다. 이를 내부 서비스라고 한다.</p><p>서비스 타입과는 무관하게, 서비스 생성을 선택해서 컨테이너의 (들어오는 패킷의) 포트를 리슨한다면,
두 개의 포트를 정의해야 한다.
서비스는 컨테이너가 바라보는 타겟 포트와 (들어오는 패킷의) 맵핑하는 포트가 만들어져야 할 것이다.
서비스는 배포된 파드에 라우팅 될 것이다. 지원하는 프로토콜은 TCP와 UDP이다.
서비스가 이용하는 내부 DNS 이름은 애플리케이션 이름으로 지정한 값이 될 것이다.</p></li></ul><p>만약 필요하다면, 더 많은 세팅을 지정할 수 있는 <strong>자세한 옵션 보기</strong> 섹션에서 확장할 수 있다.</p><ul><li><p><strong>설명</strong>: 입력하는 텍스트값은 디플로이먼트에
<a href=/ko/docs/concepts/overview/working-with-objects/annotations/>어노테이션</a>으로
추가될 것이고, 애플리케이션의 세부사항에 표시될 것이다.</p></li><li><p><strong>레이블</strong>: 애플리케이션에 사용되는 기본적인 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>은
애플리케이션 이름과 버전이다.
릴리스, 환경, 티어, 파티션, 그리고 릴리스 트랙과 같은 레이블을 디플로이먼트, 서비스, 그리고 파드를
생성할 때 추가적으로 정의할 수 있다.</p><p>예를 들면:</p><pre tabindex=0><code class=language-conf data-lang=conf>release=1.0
tier=frontend
environment=pod
track=stable
</code></pre></li><li><p><strong>네임스페이스</strong>: 쿠버네티스는 동일한 물리 클러스터를 바탕으로 여러 가상의 클러스터를 제공한다.
이러한 가상 클러스터들을 <a href=/ko/docs/tasks/administer-cluster/namespaces/>네임스페이스</a>라고 부른다.
논리적으로 명명된 그룹으로 리소스들을 분할할 수 있다.</p><p>대시보드는 드롭다운 리스트로 가능한 모든 네임스페이스를 제공하고, 새로운 네임스페이스를 생성할 수 있도록 한다.
네임스페이스 이름은 최대 63개의 영숫자 단어와 대시(-)를 포함하고 있지만 대문자를 가지지 못한다.
네임스페이스 이름은 숫자로만 구성할 수 없다.
만약 이름을 10이라는 숫자로 세팅한다면, 파드는 기본 네임스페이스로 배정하게 될 것이다.</p><p>네임스페이스 생성이 성공하는 경우, 생성된 네임스페이스가 기본으로 선택된다.
만약 생성에 실패하면, 첫 번째 네임스페이스가 선택된다.</p></li><li><p><strong>이미지 풀(Pull) 시크릿</strong>:
특정 도커 컨테이너 이미지가 프라이빗한 경우,
<a href=/ko/docs/concepts/configuration/secret/>풀(Pull) 시크릿</a> 자격 증명을 요구한다.</p><p>대시보드는 가능한 모든 시크릿을 드롭다운 리스트로 제공하며, 새로운 시크릿을 생성할 수 있도록 한다.
시크릿 이름은 예를 들어 <code>new.image-pull.secret</code> 과 같이 DNS 도메인 이름 구문으로 따르기로 한다.
시크릿 내용은 base64 인코딩 방식이며,
<a href=/ko/docs/concepts/containers/images/#%ED%8C%8C%EB%93%9C%EC%97%90-imagepullsecrets-%EB%AA%85%EC%8B%9C><code>.dockercfg</code></a> 파일로 정의된다.
시크릿 이름은 최대 253 문자를 포함할 수 있다.</p><p>이미지 풀(Pull) 시크릿의 생성이 성공한 경우, 기본으로 선택된다. 만약 생성에 실패하면, 시크릿은 허용되지 않는다.</p></li><li><p><strong>CPU 요구 사항 (cores)</strong> 와 <strong>메모리 요구 사항 (MiB)</strong>:
컨테이너를 위한 최소 <a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>리소스 상한</a>을
정의할 수 있다. 기본적으로, 파드는 CPU와 메모리 상한을 두지 않고 동작한다.</p></li><li><p><strong>커맨드 실행</strong> 와 <strong>커맨드 인수 실행</strong>:
기본적으로, 컨테이너는 선택된 도커 이미지의
<a href=/ko/docs/tasks/inject-data-application/define-command-argument-container/>기본 엔트리포인트 커맨드</a>를 실행한다.
커맨드 옵션과 인자를 기본 옵션에 우선 적용하여 사용할 수 있다.</p></li><li><p><strong>특권을 가진(privileged) 상태로 실행</strong>: 다음 세팅은 호스트에서 루트 권한을 가진 프로세스들이
<a href=/ko/docs/concepts/workloads/pods/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90-%EB%8C%80%ED%95%9C-%ED%8A%B9%EA%B6%8C-%EB%AA%A8%EB%93%9C>특권을 가진 컨테이너</a>의
프로세스들과 동등한지 아닌지 정의한다.
특권을 가진(privileged) 컨테이너는 네트워크 스택과 디바이스에 접근하는 것을 조작하도록 활용할 수 있다.</p></li><li><p><strong>환경 변수</strong>: 쿠버네티스 서비스를
<a href=/ko/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>환경 변수</a>를 통해 노출한다.
환경 변수 또는 인자를 환경 변수들의 값으로 커맨드를 통해 구성할 수 있다.
애플리케이션들이 서비스를 찾는데 사용된다.
값들은 <code>$(VAR_NAME)</code> 구문을 사용하는 다른 변수들로 참조할 수 있다.</p></li></ul><h3 id=yaml-또는-json-파일-업로드>YAML 또는 JSON 파일 업로드</h3><p>쿠버네티스는 선언적인 설정을 제공한다.
이 방식에서는 모든 설정이 매니페스트(YAML 또는 JSON 설정 파일)에 저장된다.
매니페스트는 쿠버네티스 <a href=/ko/docs/concepts/overview/kubernetes-api/>API</a> 리소스 스키마를
사용한다.</p><p>배포 마법사를 통해 애플리케이션 세부 사항들을 지정하는 대신, 애플리케이션을 하나 이상의 매니페스트로 정의할 수 있고 대시보드를 이용해서 파일을 업로드할 수 있다.</p><h2 id=대시보드-사용>대시보드 사용</h2><p>다음 섹션들은 어떻게 제공하고 어떻게 사용할 수 있는지에 대한 쿠버네티스 대시보드 UI의 모습을 보여준다.</p><h3 id=탐색>탐색</h3><p>클러스터에 정의된 쿠버네티스 오프젝트가 있으면, 대시보드는 초기화된 뷰를 제공한다.
기본적으로 <em>기본</em> 네임스페이스의 오프젝트만이 보이는데,
이는 탐색 창에 위치한 네임스페이스 셀렉터를 이용해 변경할 수 있다.</p><p>대시보드는 몇 가지 메뉴 카테고리 중에서 대부분의 쿠버네티스 오브젝트 종류와 그룹을 보여준다.</p><h4 id=어드민-개요>어드민 개요</h4><p>클러스터와 네임스페이스 관리자에게 대시보드는 노드, 네임스페이스 그리고 퍼시스턴트 볼륨과 세부사항들이 보여진다.
노드는 모든 노드를 통틀어 CPU와 메모리 사용량을 보여준다.
세부사항은 각 노드들에 대한 사용량, 사양, 상태,
할당된 리소스, 이벤트 그리고 노드에서 돌아가는 파드를 보여준다.</p><h4 id=워크로드>워크로드</h4><p>선택된 네임스페이스에서 구동되는 모든 애플리케이션을 보여준다.
해당 뷰는 애플리케이션의 워크로드 종류(예시: 디플로이먼트, 레플리카셋(ReplicaSet), 스테이트풀셋(StatefulSet))를 보여준다.
각각의 워크로드 종류는 분리하여 볼 수 있다.
리스트는 예를 들어 레플리카셋에서 준비된 파드의 숫자 또는 파드의 현재 메모리 사용량과 같은
워크로드에 대한 실용적인 정보를 요약한다.</p><p>워크로드에 대한 세부적인 것들은 상태와 사양 정보,
오프젝트들 간의 관계를 보여준다.
예를 들어, 레플리카셋으로 관리하는 파드들 또는 새로운 레플리카셋과 디플로이먼트를 위한 Horizontal Pod Autoscalers 이다.</p><h4 id=서비스>서비스</h4><p>외부로 노출되는 서비스들과 클러스터 내에 발견되는 서비스들을 허용하는
쿠버네티스 리소스들을 보여준다.
이러한 이유로 서비스와 인그레스는 클러스터간의 연결을 위한 내부 엔드포인트들과
외부 사용자를 위한 외부 엔드포인트들에 의해 타게팅된 파드들을 보여준다.</p><h4 id=스토리지>스토리지</h4><p>스토리지는 애플리케이션이 데이터를 저장하기 위해 사용하는 퍼시턴트볼륨클레임 리소스들을 보여준다.</p><h4 id=config-maps-and-secrets>컨피그맵과 시크릿</h4><p>클러스터에서 동작 중인 애플리케이션의 라이브 설정을 사용하는 모든 쿠버네티스 리소스들을 보여준다.
컨피그 오브젝트들을 수정하고 관리할 수 있도록 허용하며, 기본적으로는 숨겨져 있는 시크릿들을 보여준다.</p><h4 id=로그-뷰어>로그 뷰어</h4><p>파드 목록과 세부사항 페이지들은 대시보드에 구현된 로그 뷰어에 링크된다.
뷰어는 단일 파드에 있는 컨테이너들의 로그들을 내려가면 볼 수 있도록 한다.</p><p><img src=/images/docs/ui-dashboard-logs-view.png alt="Logs viewer"></p><h2 id=다음-내용>다음 내용</h2><p>더 많은 정보는
<a href=https://github.com/kubernetes/dashboard>쿠버네티스 대시보드 프로젝트 페이지</a>를 참고한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6a8d9e9e05f2b6825afbb8889c957370>2 - 클러스터 접근</h1><p>여기에서는 클러스터와 통신을 하는 다양한 방식에 대해서 다룰 것이다.</p><h2 id=처음이라면-kubectl을-사용하여-접근>처음이라면 kubectl을 사용하여 접근</h2><p>최초로 쿠버네티스 API에 접근할 때 우리는
쿠버네티스 CLI인 <code>kubectl</code>을 사용하는 것을 추천한다.</p><p>클러스터에 접근하려면 클러스터의 위치정보를 알아야 하고 클러스터에 접속하기 위한
인증정보를 가져야 한다. 일반적으로 이는 당신이
<a href=/ko/docs/setup/>Getting started guide</a>를 다 진행했을 때 자동으로 구성되거나,
다른 사람이 클러스터를 구성하고 당신에게 인증정보와 위치정보를 제공할 수도 있다.</p><p>kubectl이 인지하는 위치정보와 인증정보는 다음 커맨드로 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p><a href=/ko/docs/reference/kubectl/cheatsheet/>여기</a>에서
<code>kubectl</code> 사용 예시를 볼 수 있으며, 완전한 문서는
<a href=/ko/docs/reference/kubectl/>kubectl 레퍼런스</a>에서 확인할 수 있다.</p><h2 id=rest-api에-직접-접근>REST API에 직접 접근</h2><p>kubectl은 apiserver의 위치 파악과 인증을 처리한다.
만약 당신이 curl, wget 또는 웹브라우저와 같은 http 클라이언트로
REST API에 직접 접근하려고 한다면 위치 파악과 인증을 하는 몇 가지 방법이 존재한다.</p><ul><li>kubectl을 proxy 모드로 실행.<ul><li>권장하는 접근 방식.</li><li>저장된 apiserver 위치를 사용.</li><li>self-signed 인증서를 사용하여 apiserver의 identity를 검증. MITM은 불가능.</li><li>apiserver 인증.</li><li>앞으로는 클라이언트 측의 지능형 load balancing과 failover가 될 것이다.</li></ul></li><li>직접적으로 http 클라이언트에 위치정보와 인증정보를 제공.<ul><li>대안적인 접근 방식.</li><li>proxy 사용과 혼동되는 몇 가지 타입의 클라이언트 코드와 같이 동작한다.</li><li>MITM로부터 보호를 위해 root 인증서를 당신의 브라우저로 임포트해야 한다.</li></ul></li></ul><h3 id=kubectl-proxy-사용>kubectl proxy 사용</h3><p>다음 커맨드는 kubectl을 리버스 프록시(reverse proxy)처럼 동작하는 모드를 실행한다. 이는
apiserver의 위치지정과 인증을 처리한다.
다음과 같이 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>상세 내용은 <a href=/docs/reference/generated/kubectl/kubectl-commands/#proxy>kubectl proxy</a>를 참조한다</p><p>이후에 당신은 curl, wget, 웹브라우저로 다음과 같이 API를 탐색할 수 있다. localhost는
IPv6 주소 [::1]로도 대체할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://localhost:8080/api/
</span></span></code></pre></div><p>결괏값은 다음과 같을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=kubectl-proxy를-사용하지-않음>kubectl proxy를 사용하지 않음</h3><p><code>kubectl apply</code> 및 <code>kubectl describe secret...</code> 명령과 grep/cut을 활용하여 기본 서비스 어카운트의 토큰을 생성한다.</p><p>먼저, 기본 서비스어카운트를 위한 토큰을 요청하는 시크릿을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: default-token
</span></span></span><span style=display:flex><span><span style=color:#b44>  annotations:
</span></span></span><span style=display:flex><span><span style=color:#b44>    kubernetes.io/service-account.name: default
</span></span></span><span style=display:flex><span><span style=color:#b44>type: kubernetes.io/service-account-token
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>다음으로, 토큰 컨트롤러가 해당 시크릿에 토큰을 채우기를 기다린다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>while</span> ! kubectl describe secret default-token | grep -E <span style=color:#b44>&#39;^token&#39;</span> &gt;/dev/null; <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;waiting for token...&#34;</span> &gt;&amp;<span style=color:#666>2</span>
</span></span><span style=display:flex><span>  sleep <span style=color:#666>1</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><p>결과를 캡처하여 생성된 토큰을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view --minify | grep server | cut -f 2- -d <span style=color:#b44>&#34;:&#34;</span> | tr -d <span style=color:#b44>&#34; &#34;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl describe secret default-token | grep -E <span style=color:#b44>&#39;^token&#39;</span> | cut -f2 -d<span style=color:#b44>&#39;:&#39;</span> | tr -d <span style=color:#b44>&#34; &#34;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>curl <span style=color:#b8860b>$APISERVER</span>/api --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b8860b>$TOKEN</span><span style=color:#b44>&#34;</span> --insecure
</span></span></code></pre></div><p>결과값은 다음과 같을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>jsonpath</code>를 사용한다면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view --minify -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.clusters[0].cluster.server}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get secret default-token -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.token}&#39;</span> | base64 --decode<span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>curl <span style=color:#b8860b>$APISERVER</span>/api --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b8860b>$TOKEN</span><span style=color:#b44>&#34;</span> --insecure
</span></span></code></pre></div><p>결과값은 다음과 같을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위 예제에서는 <code>--insecure</code> flag를 사용했다. 이는 MITM 공격을 받을 수 있는 상태로
두는 것이다. kubectl로 클러스터에 접속할 때 저장된 root 인증서와 클라이언트 인증서들을
서버 접속에 사용한다.
(이들은 <code>~/.kube</code> 디렉터리에 설치된다.)
일반적으로 self-signed 인증서가 클러스터 인증서로 사용되므로 당신의 http 클라이언트가
root 인증서를 사용하려면 특수한 설정을 필요로 할 것이다.</p><p>localhost에서 제공되거나 방화벽으로 보호되는 몇몇 클러스터들에서는 apiserver가 인증을
요구하지 않지만 이는 표준이 아니다.
<a href=/ko/docs/concepts/security/controlling-access>API에 대한 접근 제어</a>은
클러스터 관리자가 이를 어떻게 구성할 수 있는지를 설명한다.</p><h2 id=api에-프로그래밍-방식으로-접근>API에 프로그래밍 방식으로 접근</h2><p>쿠버네티스는 공식적으로 <a href=#go-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8>Go</a>와 <a href=#python-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8>Python</a>
클라이언트 라이브러리를 지원한다.</p><h3 id=go-클라이언트>Go 클라이언트</h3><ul><li>라이브러리를 취득하려면 <code>go get k8s.io/client-go@kubernetes-&lt;kubernetes-version-number></code> 커맨드를 실행한다. <a href=https://github.com/kubernetes/client-go/blob/master/INSTALL.md#for-the-casual-user>INSTALL.md</a>에서 상세한 설치 방법을 알 수 있다. <a href=https://github.com/kubernetes/client-go#compatibility-matrix>https://github.com/kubernetes/client-go</a>에서 어떤 버젼이 지원되는지 확인할 수 있다.</li><li>client-go 클라이언트 위에 애플리케이션을 작성하자. client-go는 자체적으로 API 오브젝트를 정의하므로 필요하다면 main 레포지터리보다는 client-go에서 API 정의들을 import하기를 바란다. 정확하게 <code>import "k8s.io/client-go/kubernetes"</code>로 import하는 것을 예로 들 수 있다.</li></ul><p>Go 클라이언트는 apiserver의 위치지정과 인증에 kubectl CLI와 동일하게 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig file</a>을 사용할 수 있다.
<a href=https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go>예제</a>를 참고한다.</p><p>만약 애플리케이션이 클러스터 내에 파드로 배포되었다면 <a href=#%ED%8C%8C%EB%93%9C%EC%97%90%EC%84%9C-api-%EC%A0%91%EA%B7%BC>다음 장</a>을 참조하기를 바란다.</p><h3 id=python-클라이언트>Python 클라이언트</h3><p>Python 클라이언트를 사용하려면 <code>pip install kubernetes</code> 커맨드를 실행한다. 설치 옵션에 대한 상세 사항은 <a href=https://github.com/kubernetes-client/python>Python Client Library page</a>를 참조한다.</p><p>Python 클라이언트는 apiserver의 위치지정과 인증에 kubectl CLI와 동일하게 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig file</a>을 사용할 수 있다.
<a href=https://github.com/kubernetes-client/python/tree/master/examples>예제</a>를 참조한다.</p><h3 id=다른-언어>다른 언어</h3><p>다른 언어에서 API를 접속하기 위한 <a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리들</a>도 존재한다.
이들이 어떻게 인증하는지는 다른 라이브러리들의 문서를 참조한다.</p><h2 id=파드에서-api-접근>파드에서 API 접근</h2><p>파드에서 API에 접근하는 경우,
API 서버를 찾고 인증하는 방식이 약간 다를 수 있다.</p><p>더 자세한 내용은
<a href=/ko/docs/tasks/run-application/access-api-from-pod/>파드 내에서 쿠버네티스 API에 접근</a>을 참조한다.</p><h2 id=클러스터에서-실행되는-서비스로-접근>클러스터에서 실행되는 서비스로 접근</h2><p>이전 섹션에서는 쿠버네티스 API 서버에 연결하는 방법을 소개하였다.
쿠버네티스 클러스터에서 실행되는 다른 서비스에 연결하는 방법은
<a href=/ko/docs/tasks/access-application-cluster/access-cluster-services/>클러스터 서비스에 접근</a> 페이지를 참조한다.</p><h2 id=redirect-요청하기>redirect 요청하기</h2><p>redirect 기능은 deprecated되고 제거 되었다. 대신 (아래의) 프록시를 사용하기를 바란다.</p><h2 id=다양한-프록시들>다양한 프록시들</h2><p>쿠버네티스를 사용하면서 당신이 접할 수 있는 몇 가지 다른 프록시들이 존재한다.</p><ol><li><p><a href=#rest-api%EC%97%90-%EC%A7%81%EC%A0%91-%EC%A0%91%EA%B7%BC>kubectl proxy</a>:</p><ul><li>사용자의 데스크탑이나 파드 내에서 실행한다</li><li>localhost 주소에서 쿠버네티스 apiserver로 프록시한다</li><li>프록시하는 클라이언트는 HTTP를 사용한다</li><li>apiserver의 프록시는 HTTPS를 사용한다</li><li>apiserver를 위치지정한다</li><li>인증 header들을 추가한다</li></ul></li><li><p><a href=/ko/docs/tasks/access-application-cluster/access-cluster-services/#%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B2%80%EC%83%89>apiserver proxy</a>:</p><ul><li>apiserver 내의 빌트인 bastion이다</li><li>다른 방식으로는 연결할 수 없는 클러스터 외부의 사용자를 클러스터 IP로 연결한다</li><li>apiserver process들 내에서 실행된다</li><li>프록시하는 클라이언트는 HTTPS를 사용한다(또는 apiserver가 http로 구성되었다면 http)</li><li>타겟으로의 프록시는 가용정보를 사용하는 프록시에 의해서 HTTP 또는 HTTPS를 사용할 수도 있다</li><li>노드, 파드, 서비스에 접근하는 데 사용될 수 있다</li><li>서비스에 접근하는 데 사용되면 load balacing한다</li></ul></li><li><p><a href=/ko/docs/concepts/services-networking/service/#ips-and-vips>kube proxy</a>:</p><ul><li>각 노드 상에서 실행된다</li><li>UDP와 TCP를 프록시한다</li><li>HTTP를 인지하지 않는다</li><li>load balancing을 제공한다</li><li>서비스에 접근하는 데에만 사용된다</li></ul></li><li><p>apiserver(s) 전면의 Proxy/Load-balancer:</p><ul><li>존재내용과 구현사항은 클러스터 별로 다양하다(예. nginx)</li><li>모든 클라이언트와 하나 이상의 apiserver들의 사이에 위치한다</li><li>apiserver가 여러 대 존재한다면 load balancer로 동작한다</li></ul></li><li><p>외부 서비스의 Cloud Load Balancer들:</p><ul><li>Cloud provider들에 의해서 제공된다(예. AWS ELB, Google Cloud Load Balancer)</li><li>쿠버네티스 서비스의 타입이 <code>LoadBalancer</code>라면 자동으로 생성된다</li><li>UDP/TCP 만 사용한다</li><li>cloud provider마다 구현된 내용이 상이하다</li></ul></li></ol><p>일반적으로 쿠버네티스 사용자들은 처음 두 타입이 아닌 다른 방식은 고려할 필요가 없지만 클러스터 관리자는
나머지 타입을 적절하게 구성해줘야 한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5a233e14205d77fe1294917d2da6f876>3 - 다중 클러스터 접근 구성</h1><p>이 페이지에서는 구성 파일을 사용하여 다수의 클러스터에 접근할 수 있도록
설정하는 방식을 보여준다. 클러스터, 사용자, 컨텍스트가 하나 이상의
구성 파일에 정의된 다음 <code>kubectl config use-context</code> 커맨드를
사용하여 클러스터를 빠르게 변경할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 클러스터에 접근할 수 있도록 설정하는데 사용되는 파일은 종종 <em>kubeconfig file</em> 이라고
불린다. 이는 구성 파일을 참조하는 일반적인 방식으로 <code>kubeconfig</code>라는 이름을 가진 파일이
반드시 존재해야 한다는 것을 의미하는 것은 아니다.</div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 신뢰할 수 있는 소스의 kubeconfig 파일만 사용해야 한다. 특수 제작된 kubeconfig 파일은 악성코드를 실행하거나 파일을 노출시킬 수 있다.
신뢰할 수 없는 kubeconfig 파일을 꼭 사용해야 한다면, 셸 스크립트를 사용하는 경우처럼 신중한 검사가 선행되어야 한다.</div><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p><a class=glossary-tooltip title='쿠버네티스 클러스터와 통신하기 위한 커맨드라인 툴.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>이 설치되었는지 확인하려면,
<code>kubectl version --client</code>을 실행한다. kubectl 버전은 클러스터의 API 서버 버전과
<a href=/ko/releases/version-skew-policy/#kubectl>마이너 버전 하나 차이 이내</a>여야
한다.</p><h2 id=클러스터-사용자-컨텍스트-정의>클러스터, 사용자, 컨텍스트 정의</h2><p>당신이 개발 작업을 위한 클러스터와 스크래치 작업을 위한 클러스터를 가지고 있다고 가정해보자.
<code>development</code> 클러스터에서는 프런트 엔드 개발자들이 <code>frontend</code>라는 네임스페이스에서
작업을 하고 있고, 스토리지 개발자들은 <code>storage</code>라는 네임스페이스에서 작업을 하고 있다.
<code>scratch</code> 클러스터에서는 개발자들이 default 네임스페이스에서 개발하거나 필요에 따라 보조
네임스페이스들을 생성하고 있다. development 클러스터에 접근하려면 인증서로 인증을 해야 하고,
scratch 클러스터에 접근하려면 사용자네임과 패스워드로 인증을 해야 한다.</p><p><code>config-exercise</code>라는 디렉터리를 생성한다. <code>config-exercise</code> 디렉터리에
다음 내용을 가진 <code>config-demo</code>라는 파일을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exp-scratch<span style=color:#bbb>
</span></span></span></code></pre></div><p>구성 파일은 클러스터들, 사용자들, 컨텍스트들을 기술한다. <code>config-demo</code> 파일은 두 클러스터들과
두 사용자들, 세 컨텍스트들을 기술하기 위한 프레임워크를 가진다.</p><p><code>config-exercise</code> 디렉터리로 이동한다. 그리고 다음 커맨드들을 실행하여 구성 파일에 클러스터의
세부사항들을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster development --server<span style=color:#666>=</span>https://1.2.3.4 --certificate-authority<span style=color:#666>=</span>fake-ca-file
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster scratch --server<span style=color:#666>=</span>https://5.6.7.8 --insecure-skip-tls-verify
</span></span></code></pre></div><p>사용자의 세부사항들을 구성 파일에 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials developer --client-certificate<span style=color:#666>=</span>fake-cert-file --client-key<span style=color:#666>=</span>fake-key-seefile
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials experimenter --username<span style=color:#666>=</span>exp --password<span style=color:#666>=</span>some-password
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><ul><li>사용자를 삭제하려면 <code>kubectl --kubeconfig=config-demo config unset users.&lt;name></code> 를 실행한다.</li><li>클러스터를 제거하려면 <code>kubectl --kubeconfig=config-demo config unset clusters.&lt;name></code> 를 실행한다.</li><li>컨텍스트를 제거하려면 <code>kubectl --kubeconfig=config-demo config unset contexts.&lt;name></code> 를 실행한다.</li></ul></div><p>컨텍스트 세부사항들을 구성 파일에 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-frontend --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>frontend --user<span style=color:#666>=</span>developer
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-storage --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>storage --user<span style=color:#666>=</span>developer
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context exp-scratch --cluster<span style=color:#666>=</span>scratch --namespace<span style=color:#666>=</span>default --user<span style=color:#666>=</span>experimenter
</span></span></code></pre></div><p><code>config-demo</code> 파일을 열어서 세부사항들이 추가되었는지 확인한다. <code>config-demo</code> 파일을 열어보는
것 대신에 <code>config view</code> 커맨드를 사용할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view
</span></span></code></pre></div><p>두 클러스터, 두 사용자, 세 컨텍스트들이 출력 결과로 나온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>fake-ca-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://1.2.3.4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>insecure-skip-tls-verify</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://5.6.7.8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exp-scratch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>fake-cert-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>fake-key-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>some-password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>exp<span style=color:#bbb>
</span></span></span></code></pre></div><p>위 <code>fake-ca-file</code>, <code>fake-cert-file</code>, <code>fake-key-file</code>은 인증서 파일들의 실제 경로 이름을 위한
플레이스홀더(placeholder)이다.
당신의 환경에 맞게 이들을 실제 인증서 경로로 변경해줘야 한다.</p><p>만약 당신이 인증서 파일들의 경로 대신에 여기에 포함된 base64로 인코딩된 데이터를 사용하려고 한다면
이 경우 키에 <code>-data</code> 접미사를 추가해야 한다. 예를 들면 <code>certificate-authority-data</code>,
<code>client-certificate-data</code>, <code>client-key-data</code> 같이 사용할 수 있다.</p><p>컨텍스트는 세 가지(클러스터, 사용자, 네임스페이스) 요소들로 이뤄진다. 예를 들어
<code>dev-frontend</code> 컨텍스트는 "<code>development</code> 클러스터의 <code>frontend</code> 네임스페이스에 접근하는데
<code>developer</code> 사용자 자격증명을 사용하라고 알려준다."</p><p>현재 컨텍스트를 설정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-frontend
</span></span></code></pre></div><p>이제 당신이 <code>kubectl</code> 커맨드를 입력할 때마다 <code>dev-frontend</code> 컨텍스트에 명시된 클러스터와
네임스페이스 상에서 동작하게 될 것이다. 그리고 커맨드는 <code>dev-frontend</code> 컨텍스트 내에 명시된
사용자 자격증명을 사용할 것이다.</p><p>현재 컨텍스트에 관련된 구성 정보만을 보려면
<code>--minify</code> 플래그를 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><p><code>dev-frontend</code> 컨텍스트에 관련된 구성 정보가 출력 결과로 표시될 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>fake-ca-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://1.2.3.4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>fake-cert-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>fake-key-file<span style=color:#bbb>
</span></span></span></code></pre></div><p>이제 당신이 잠시 scratch 클러스터에서 작업하려고 한다고 가정해보자.</p><p>현재 컨텍스트를 <code>exp-scratch</code>로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context exp-scratch
</span></span></code></pre></div><p>이제 당신이 실행하는 모든 <code>kubectl</code> 커맨드는 <code>scratch</code> 클러스터의
default 네임스페이스에 적용되며 <code>exp-scratch</code> 컨텍스트에 나열된
사용자의 자격증명을 사용할 것이다.</p><p>현재의 컨텍스트인 <code>exp-scratch</code>에 관련된 설정을 보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><p>마지막으로 당신이 <code>development</code> 클러스터의 <code>storage</code> 네임스페이스에서
잠시 작업을 하려고 한다고 가정해보자.</p><p>현재 컨텍스트를 <code>dev-storage</code>로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-storage
</span></span></code></pre></div><p>현재 컨텍스트인 <code>dev-storage</code>에 관련된 설정을 보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><h2 id=두-번째-구성-파일-생성>두 번째 구성 파일 생성</h2><p><code>config-exercise</code> 디렉터리에서 다음 내용으로 <code>config-demo-2</code>라는 파일을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ramp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-ramp-up<span style=color:#bbb>
</span></span></span></code></pre></div><p>위 구성 파일은 <code>dev-ramp-up</code>이라는 신규 컨텍스트를 정의한다.</p><h2 id=kubeconfig-환경-변수-설정>KUBECONFIG 환경 변수 설정</h2><p><code>KUBECONFIG</code>라는 환경 변수를 가지고 있는지 확인해보자. 만약 가지고 있다면,
이후에 복원할 수 있도록 <code>KUBECONFIG</code> 환경 변수의 현재 값을 저장한다.
예:</p><h3 id=리눅스>리눅스</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG_SAVED</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$KUBECONFIG</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><h3 id=윈도우-powershell>윈도우 PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#b8860b>$Env:KUBECONFIG_SAVED</span>=<span style=color:#b8860b>$ENV:KUBECONFIG</span>
</span></span></code></pre></div><p><code>KUBECONFIG</code> 환경 변수는 구성 파일들의 경로의 리스트이다. 이 리스트는
리눅스와 Mac에서는 콜론으로 구분되며 윈도우에서는 세미콜론으로 구분된다.
<code>KUBECONFIG</code> 환경 변수를 가지고 있다면, 리스트에 포함된 구성 파일들에
익숙해지길 바란다.</p><p>다음 예와 같이 임시로 <code>KUBECONFIG</code> 환경 변수에 두 개의 경로들을 덧붙여보자.</p><h3 id=리눅스-1>리눅스</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>:config-demo:config-demo-2&#34;</span>
</span></span></code></pre></div><h3 id=윈도우-powershell-1>윈도우 PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#b8860b>$Env:KUBECONFIG</span>=(<span style=color:#b44>&#34;config-demo;config-demo-2&#34;</span>)
</span></span></code></pre></div><p><code>config-exercise</code> 디렉터리에서 다음 커맨드를 입력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>당신의 <code>KUBECONFIG</code> 환경 변수에 나열된 모든 파일들이 합쳐진 정보가 출력 결과로
표시될 것이다. 특히, 합쳐진 정보가 <code>config-demo-2</code> 파일의 <code>dev-ramp-up</code>
컨텍스트와 <code>config-demo</code> 파일의 세 개의 컨텍스트들을
가지고 있다는 것에 주목하길 바란다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ramp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-ramp-up<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exp-scratch<span style=color:#bbb>
</span></span></span></code></pre></div><p>kubeconfig 파일들을 어떻게 병합하는지에 대한 상세정보는
<a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일을 사용하여 클러스터 접근 구성하기</a>를 참조한다.</p><h2 id=home-kube-디렉터리-탐색>$HOME/.kube 디렉터리 탐색</h2><p>만약 당신이 이미 클러스터를 가지고 있고 <code>kubectl</code>을 사용하여
해당 클러스터를 제어하고 있다면, 아마 <code>$HOME/.kube</code> 디렉터리에 <code>config</code>라는
파일을 가지고 있을 것이다.</p><p><code>$HOME/.kube</code>로 가서 어떤 파일들이 존재하는지 보자.
보통 <code>config</code>라는 파일이 존재할 것이다. 해당 디렉터리 내에는 다른 구성 파일들도 있을 수 있다.
간단하게 말하자면 당신은 이 파일들의 컨텐츠에 익숙해져야 한다.</p><h2 id=home-kube-config를-kubeconfig-환경-변수에-추가>$HOME/.kube/config를 KUBECONFIG 환경 변수에 추가</h2><p>당신이 <code>$HOME/.kube/config</code> 파일을 가지고 있는데 <code>KUBECONFIG</code>
환경 변수에 나타나지 않는다면 <code>KUBECONFIG</code> 환경 변수에 추가해보자.
예:</p><h3 id=리눅스-2>리눅스</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOME</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/.kube/config&#34;</span>
</span></span></code></pre></div><h3 id=윈도우-powershell-2>윈도우 Powershell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#b8860b>$Env:KUBECONFIG</span>=<span style=color:#b44>&#34;</span><span style=color:#b8860b>$Env:KUBECONFIG</span><span style=color:#b44>;</span><span style=color:#b8860b>$HOME</span><span style=color:#b44>\.kube\config&#34;</span>
</span></span></code></pre></div><p>이제 <code>KUBECONFIG</code> 환경 변수에 리스트에 포함된 모든 파일들이 합쳐진 구성 정보를 보자.
config-exercise 디렉터리에서 다음 커맨드를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><h2 id=정리>정리</h2><p><code>KUBECONFIG</code> 환경 변수를 원래 값으로 되돌려 놓자. 예를 들면:<br></p><h3 id=리눅스-3>리눅스</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$KUBECONFIG_SAVED</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><h3 id=윈도우-powershell-3>윈도우 PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#b8860b>$Env:KUBECONFIG</span>=<span style=color:#b8860b>$ENV:KUBECONFIG_SAVED</span>
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일을 사용하여 클러스터 접근 구성하기</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-72d3dddbc0c166c9a364e753d2b31ff0>4 - 포트 포워딩을 사용해서 클러스터 내 애플리케이션에 접근하기</h1><p>이 페이지는 <code>kubectl port-forward</code> 를 사용해서 쿠버네티스 클러스터 내에서
실행중인 MongoDB 서버에 연결하는 방법을 보여준다. 이 유형의 연결은 데이터베이스
디버깅에 유용할 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.10.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p></li><li><p><a href=https://www.mongodb.com/try/download/shell>MongoDB Shell</a>을 설치한다.</p></li></ul><h2 id=mongodb-디플로이먼트와-서비스-생성하기>MongoDB 디플로이먼트와 서비스 생성하기</h2><ol><li><p>MongoDB를 실행하기 위해 디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/mongodb/mongo-deployment.yaml
</span></span></code></pre></div><p>성공적인 명령어의 출력은 디플로이먼트가 생성됐다는 것을 확인해준다.</p><pre tabindex=0><code>deployment.apps/mongo created
</code></pre><p>파드 상태를 조회하여 파드가 준비되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>출력은 파드가 생성되었다는 것을 보여준다.</p><pre tabindex=0><code>NAME                     READY   STATUS    RESTARTS   AGE
mongo-75f59d57f4-4nd6q   1/1     Running   0          2m4s
</code></pre></li></ol><pre tabindex=0><code>
 디플로이먼트 상태를 조회한다.

 ```shell
 kubectl get deployment
</code></pre><p>출력은 디플로이먼트가 생성되었다는 것을 보여준다.</p><pre tabindex=0><code>NAME    READY   UP-TO-DATE   AVAILABLE   AGE
mongo   1/1     1            1           2m21s
</code></pre><p>디플로이먼트는 자동으로 레플리카셋을 관리한다.
아래의 명령어를 사용하여 레플리카셋 상태를 조회한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get replicaset
</span></span></code></pre></div><p>출력은 레플리카셋이 생성되었다는 것을 보여준다.</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY   AGE
mongo-75f59d57f4   1         1         1       3m12s
</code></pre><ol start=2><li><p>MongoDB를 네트워크에 노출시키기 위해 서비스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/mongodb/mongo-service.yaml
</span></span></code></pre></div><p>성공적인 커맨드의 출력은 서비스가 생성되었다는 것을 확인해준다.</p><pre tabindex=0><code>service/mongo created
</code></pre><p>서비스가 생성되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> kubectl get service mongo
</span></span></code></pre></div></li></ol><pre tabindex=0><code>
 출력은 서비스가 생성되었다는 것을 보여준다.
</code></pre><p>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
mongo ClusterIP 10.96.41.183 <none>27017/TCP 11s</p><pre tabindex=0><code>
3. MongoDB 서버가 파드 안에서 실행되고 있고, 27017번 포트에서 수신하고 있는지 확인한다.

```shell
# mongo-75f59d57f4-4nd6q 를 당신의 파드 이름으로 대체한다.
kubectl get pod mongo-75f59d57f4-4nd6q --template=&#39;{{(index (index .spec.containers 0).ports 0).containerPort}}{{&#34;\n&#34;}}&#39;
</code></pre><p>출력은 파드 내 MongoDB 포트 번호를 보여준다.</p><pre tabindex=0><code>27017
</code></pre><pre><code>(27017은 인터넷 상의 MongoDB에 할당된 TCP 포트이다.)
</code></pre><h2 id=파드의-포트를-로컬-포트로-포워딩하기>파드의 포트를 로컬 포트로 포워딩하기</h2><ol><li><p><code>kubectl port-forward</code> 명령어는 파드 이름과 같이 리소스 이름을 사용하여 일치하는 파드를 선택해 포트 포워딩하는 것을 허용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># mongo-75f59d57f4-4nd6q 를 당신의 파드 이름으로 대체한다.</span>
</span></span><span style=display:flex><span>kubectl port-forward mongo-75f59d57f4-4nd6q 28015:27017
</span></span></code></pre></div><p>이것은</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward pods/mongo-75f59d57f4-4nd6q 28015:27017
</span></span></code></pre></div><p>또는</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward deployment/mongo 28015:27017
</span></span></code></pre></div><p>또는</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward replicaset/mongo-75f59d57f4 28015:27017
</span></span></code></pre></div><p>또는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward service/mongo 28015:27017
</span></span></code></pre></div><p>위의 명령어들은 모두 동일하게 동작한다. 이와 유사하게 출력된다.</p><pre tabindex=0><code>Forwarding from 127.0.0.1:28015 -&gt; 27017
Forwarding from [::1]:28015 -&gt; 27017
</code></pre></li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubectl port-forward</code> 는 프롬프트를 리턴하지 않으므로, 이 연습을 계속하려면 다른 터미널을 열어야 한다.</div><ol start=2><li><p>MongoDB 커맨드라인 인터페이스를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mongosh --port <span style=color:#666>28015</span>
</span></span></code></pre></div></li><li><p>MongoDB 커맨드라인 프롬프트에 <code>ping</code> 명령을 입력한다.</p><pre tabindex=0><code>db.runCommand( { ping: 1 } )
</code></pre><p>성공적인 핑 요청을 반환한다.</p><pre tabindex=0><code>{ ok: 1 }
</code></pre></li></ol><h3 id=let-kubectl-choose-local-port>선택적으로 <em>kubectl</em> 이 로컬 포트를 선택하게 하기</h3><p>만약 특정 로컬 포트가 필요하지 않다면, <code>kubectl</code> 이 로컬 포트를 선택 및 할당하게 하여,
조금 더 단순한 문법으로 로컬 포트 충돌 관리를 위한
부담을 줄일 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward deployment/mongo :27017
</span></span></code></pre></div><p><code>kubectl</code> 도구는 사용 중이 아닌 로컬 포트 번호를 찾는다 (낮은 포트 번호는
다른 애플리케이션에서 사용될 것이므로, 낮은 포트 번호를 피해서). 출력은 다음과 같을 것이다.</p><pre tabindex=0><code>Forwarding from 127.0.0.1:63753 -&gt; 27017
Forwarding from [::1]:63753 -&gt; 27017
</code></pre><h2 id=토의>토의</h2><p>로컬 28015 포트에 대한 연결은 MongoDB 서버가 실행중인 파드의 27017 포트로 포워딩된다.
이 연결로 로컬 워크스테이션에서 파드 안에서 실행 중인 데이터베이스를 디버깅하는데
사용할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubectl port-forward</code> 는 TCP 포트에서만 구현된다.
UDP 프로토콜에 대한 지원은
<a href=https://github.com/kubernetes/kubernetes/issues/47862>이슈 47862</a>에서 추적되고 있다.</div><h2 id=다음-내용>다음 내용</h2><p><a href=/docs/reference/generated/kubectl/kubectl-commands/#port-forward>kubectl port-forward</a>에 대해 더 알아본다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-312f29f850826b74618634cd877aa065>5 - 클러스터 내 애플리케이션에 접근하기 위해 서비스 사용하기</h1><p>이 문서는 외부 클라이언트가 클러스터에서 실행 중인 애플리케이션에 접근하기
위해 사용하는 쿠버네티스 서비스 오브젝트를 생성하는 방법을 설명한다. 서비스는
실행 중인 두 개의 인스턴스를 갖는 애플리케이션에 대한 로드 밸런싱을 제공한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=목적>목적</h2><ul><li>Hello World 애플리케이션 인스턴스 두 개를 실행한다.</li><li>노드 포트를 노출하는 서비스 오브젝트를 생성한다.</li><li>실행 중인 애플리케이션에 접근하기 위해 서비스 오브젝트를 사용한다.</li></ul><h2 id=두-개의-파드에서-실행-중인-애플리케이션에-대한-서비스-생성하기>두 개의 파드에서 실행 중인 애플리케이션에 대한 서비스 생성하기</h2><p>다음은 애플리케이션 디플로이먼트(Deployment) 설정 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/hello-application.yaml download=service/access/hello-application.yaml><code>service/access/hello-application.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-hello-application-yaml")' title="Copy service/access/hello-application.yaml to clipboard"></img></div><div class=includecode id=service-access-hello-application-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>클러스터 내 Hello World 애플리케이션을 실행하자.
위 파일을 사용하여 애플리케이션 디플로이먼트를 생성하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/access/hello-application.yaml
</span></span></code></pre></div><p>앞의 명령은
<a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>
오브젝트와 연관된
<a class=glossary-tooltip title='레플리카셋은 지정된 수의 파드 레플리카가 동시에 실행이 되도록 보장한다' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=레플리카셋(ReplicaSet)>레플리카셋(ReplicaSet)</a>
오브젝트를 생성한다. 레플리카셋은 두 개의
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 갖고,
각각은 Hello World 애플리케이션을 실행한다.</p></li><li><p>디플로이먼트에 대한 정보를 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployments hello-world
</span></span><span style=display:flex><span>kubectl describe deployments hello-world
</span></span></code></pre></div></li><li><p>레플리카셋 오브젝트에 대한 정보를 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get replicasets
</span></span><span style=display:flex><span>kubectl describe replicasets
</span></span></code></pre></div></li><li><p>디플로이먼트를 노출하는 서비스 오브젝트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment hello-world --type<span style=color:#666>=</span>NodePort --name<span style=color:#666>=</span>example-service
</span></span></code></pre></div></li><li><p>서비스에 대한 정보를 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe services example-service
</span></span></code></pre></div><p>결과는 아래와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:                   example-service
</span></span><span style=display:flex><span>Namespace:              default
</span></span><span style=display:flex><span>Labels:                 <span style=color:#b8860b>run</span><span style=color:#666>=</span>load-balancer-example
</span></span><span style=display:flex><span>Annotations:            &lt;none&gt;
</span></span><span style=display:flex><span>Selector:               <span style=color:#b8860b>run</span><span style=color:#666>=</span>load-balancer-example
</span></span><span style=display:flex><span>Type:                   NodePort
</span></span><span style=display:flex><span>IP:                     10.32.0.16
</span></span><span style=display:flex><span>Port:                   &lt;unset&gt; 8080/TCP
</span></span><span style=display:flex><span>TargetPort:             8080/TCP
</span></span><span style=display:flex><span>NodePort:               &lt;unset&gt; 31496/TCP
</span></span><span style=display:flex><span>Endpoints:              10.200.1.4:8080,10.200.2.5:8080
</span></span><span style=display:flex><span>Session Affinity:       None
</span></span><span style=display:flex><span>Events:                 &lt;none&gt;
</span></span></code></pre></div><p>서비스의 노드포트(NodePort) 값을 메모하자. 예를 들어,
앞선 결과에서, 노드포트 값은 31496이다.</p></li><li><p>Hello World 애플리케이션이 실행 중인 파드를 나열한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b44>&#34;run=load-balancer-example&#34;</span> --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><p>결과는 아래와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                           READY   STATUS    ...  IP           NODE
</span></span><span style=display:flex><span>hello-world-2895499144-bsbk5   1/1     Running   ...  10.200.1.4   worker1
</span></span><span style=display:flex><span>hello-world-2895499144-m1pwt   1/1     Running   ...  10.200.2.5   worker2
</span></span></code></pre></div></li><li><p>Hello World 파드가 실행 중인 노드들 중 하나의 노드에 대해 공용
IP 주소를 얻자. 이 주소를 얻는 방법은 어떻게 클러스터를 설치했는지에
따라 다르다. 예를 들어, Minikube를 사용하면, <code>kubectl cluster-info</code>를
실행하여 노드 주소를 알 수 있다. Google Compute Engine 인스턴스를
사용하면, <code>gcloud compute instances list</code> 명령어를
사용하여 노드들의 공용 주소를 알 수
있다.</p></li><li><p>선택한 노드에서 노드 포트에 대해 TCP 통신을 허용하도록 방화벽 규칙을
생성하자. 예를 들어, 서비스의 노드포트 값이 31568인 경우,
31568 포트로 TCP 통신을 허용하도록 방화벽 규칙을 생성하자. 다른
클라우드 공급자는 방화벽 규칙을 설정하는 다른 방법을 제공한다.</p></li><li><p>Hello World 애플리케이션 접근을 위해 노드 주소와 노드 포트를 사용하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://&lt;public-node-ip&gt;:&lt;node-port&gt;
</span></span></code></pre></div><p><code>&lt;public-node-ip></code>는 노드의 공용 IP 주소이고,
<code>&lt;node-port></code>는 서비스의 노드포트 값이다.
성공적인 요청에 대한 응답은 hello 메시지이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Hello Kubernetes!
</span></span></code></pre></div></li></ol><h2 id=서비스-설정-파일-사용하기>서비스 설정 파일 사용하기</h2><p><code>kubectl expose</code>를 사용하는 대신,
<a href=/ko/docs/concepts/services-networking/service/>서비스 설정 파일</a>을 사용해
서비스를 생성할 수 있다.</p><h2 id=정리하기>정리하기</h2><p>서비스를 삭제하기 위해 다음 명령어를 입력하자.</p><pre><code>kubectl delete services example-service
</code></pre><p>디플로이먼트, 레플리카셋, Hello World 애플리케이션이 실행 중인 파드를
삭제하기 위해 다음 명령어를 입력하자.</p><pre><code>kubectl delete deployment hello-world
</code></pre><h2 id=다음-내용>다음 내용</h2><p><a href=/ko/docs/concepts/services-networking/connect-applications-service/>서비스와 애플리케이션 연결하기</a>에
대해 더 알아본다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f3dac629bea950fc026d920306f09fb4>6 - 서비스를 사용하여 프론트엔드를 백엔드에 연결</h1><p>이 작업은 <em>프론트엔드</em> 와 <em>백엔드</em> 마이크로서비스를 어떻게 생성하는지를 설명한다. 백엔드
마이크로서비스는 인사하기(hello greeter)이다. 프론트엔드는 nginx 및 쿠버네티스
<a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a> 오브젝트를 사용해 백엔드를 노출한다.</p><h2 id=목적>목적</h2><ul><li><a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a> 오브젝트를 사용해
샘플 <code>hello</code> 백엔드 마이크로서비스를 생성하고 실행한다.</li><li>서비스 오브젝트를 사용하여 백엔드 마이크로서비스의 여러 복제본으로 트래픽을 보낸다.</li><li>디플로이먼트 오브젝트를 사용하여 <code>nginx</code> 프론트엔드 마이크로서비스를 생성하고 실행한다.</li><li>트래픽을 백엔드 마이크로서비스로 보내도록 프론트엔드 마이크로서비스를 구성한다.</li><li><code>type=LoadBalancer</code> 의 서비스 오브젝트를 사용해 클러스터 외부에 프론트엔드 마이크로서비스를
노출한다.</li></ul><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><p>이 작업은
지원되는 환경이 필요한
<a href=/ko/docs/tasks/access-application-cluster/create-external-load-balancer/>외부 로드밸런서가 있는 서비스</a>를 사용한다. 만약, 이를 지원하지 않는 환경이라면, <a href=/ko/docs/concepts/services-networking/service/#type-nodeport>노드포트</a> 서비스 타입을
대신 사용할 수 있다.</p><h2 id=디플로이먼트를-사용해-백엔드-생성하기>디플로이먼트를 사용해 백엔드 생성하기</h2><p>백엔드는 인사하기라는 간단한 마이크로서비스이다. 여기에 백엔드 디플로이먼트
구성 파일이 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/backend-deployment.yaml download=service/access/backend-deployment.yaml><code>service/access/backend-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-backend-deployment-yaml")' title="Copy service/access/backend-deployment.yaml to clipboard"></img></div><div class=includecode id=service-access-backend-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>7</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;gcr.io/google-samples/hello-go-gke:1.0&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>백엔드 디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/access/backend-deployment.yaml
</span></span></code></pre></div><p>백엔드 디플로이먼트에 관한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment backend
</span></span></code></pre></div><p>결과는 아래와 같다.</p><pre tabindex=0><code>Name:                           backend
Namespace:                      default
CreationTimestamp:              Mon, 24 Oct 2016 14:21:02 -0700
Labels:                         app=hello
                                tier=backend
                                track=stable
Annotations:                    deployment.kubernetes.io/revision=1
Selector:                       app=hello,tier=backend,track=stable
Replicas:                       3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:                   RollingUpdate
MinReadySeconds:                0
RollingUpdateStrategy:          1 max unavailable, 1 max surge
Pod Template:
  Labels:       app=hello
                tier=backend
                track=stable
  Containers:
   hello:
    Image:              &#34;gcr.io/google-samples/hello-go-gke:1.0&#34;
    Port:               80/TCP
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
OldReplicaSets:                 &lt;none&gt;
NewReplicaSet:                  hello-3621623197 (3/3 replicas created)
Events:
...
</code></pre><h2 id=hello-서비스-오브젝트-생성하기><code>hello</code> 서비스 오브젝트 생성하기</h2><p>프론트엔드에서 백엔드로 요청을 보내는 핵심은 백엔드
서비스이다. 서비스는 백엔드 마이크로서비스에 언제든 도달하기 위해
변하지 않는 IP 주소와 DNS 이름 항목을 생성한다. 서비스는
트래픽을 보내는 파드를 찾기 위해
<a class=glossary-tooltip title='사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=셀렉터>셀렉터</a>를 사용한다.</p><p>먼저, 서비스 구성 파일을 살펴보자.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/backend-service.yaml download=service/access/backend-service.yaml><code>service/access/backend-service.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-backend-service-yaml")' title="Copy service/access/backend-service.yaml to clipboard"></img></div><div class=includecode id=service-access-backend-service-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>구성 파일에서 <code>hello</code> 라는 이름의 서비스가 <code>app: hello</code> 및 <code>tier: backend</code> 레이블을 갖는
파드에 트래픽을 보내는 것을 볼 수 있다.</p><p>백엔드 서비스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/access/backend-service.yaml
</span></span></code></pre></div><p>이 시점에서 <code>hello</code> 애플리케이션의 복제본 3개를 실행하는 <code>backend</code>
디플로이먼트가 있고, 해당 백엔드로 트래픽을 보내는 서비스가 있다. 그러나, 이
서비스는 클러스터 외부에서 사용할 수 없거나 확인할 수 없다.</p><h2 id=프론트엔드-생성하기>프론트엔드 생성하기</h2><p>이제 백엔드를 실행했으므로, 클러스터 외부에서 접근할 수 있는
프론트엔드를 만들고, 백엔드로의 요청을 프록시하여 백엔드에 연결할 수 있다.</p><p>프론트엔드는 백엔드 서비스에 지정된 DNS 이름을 사용하여 백엔드
워커 파드에 요청을 보낸다. DNS 이름은
<code>examples/service/access/backend-service.yaml</code> 구성 파일의
<code>name</code> 필드 값인 <code>hello</code> 이다.</p><p>프론트엔드 디플로이먼트 안의 파드는 <code>hello</code> 백엔드 서비스에 대한 요청을
프록시하도록 구성된 nginx 이미지를 실행한다. 다음은 nginx 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/frontend-nginx.conf download=service/access/frontend-nginx.conf><code>service/access/frontend-nginx.conf</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-frontend-nginx-conf")' title="Copy service/access/frontend-nginx.conf to clipboard"></img></div><div class=includecode id=service-access-frontend-nginx-conf><pre tabindex=0><code class=language-conf data-lang=conf># The identifier Backend is internal to nginx, and used to name this specific upstream
upstream Backend {
    # hello is the internal DNS name used by the backend Service inside Kubernetes
    server hello;
}

server {
    listen 80;

    location / {
        # The following statement will proxy traffic to the upstream named Backend
        proxy_pass http://Backend;
    }
}
</code></pre></div></div><p>백엔드와 같이, 프론트엔드는 디플로이먼트와 서비스를 갖고 있다. 백엔드
서비스와 프론트엔드 서비스 간에 주목해야 할 중요한 차이점은 프론트엔드
서비스의 구성에 <code>type: LoadBalancer</code> 가 있다는 것이다. 즉,
서비스가 클라우드 공급자가 프로비저닝한 로드 밸런서를 사용하고
클러스터 외부에서 접근할 수 있음을 의미한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/frontend-service.yaml download=service/access/frontend-service.yaml><code>service/access/frontend-service.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-frontend-service-yaml")' title="Copy service/access/frontend-service.yaml to clipboard"></img></div><div class=includecode id=service-access-frontend-service-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;TCP&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span></span></span></code></pre></div></div></div><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/frontend-deployment.yaml download=service/access/frontend-deployment.yaml><code>service/access/frontend-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-frontend-deployment-yaml")' title="Copy service/access/frontend-deployment.yaml to clipboard"></img></div><div class=includecode id=service-access-frontend-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;gcr.io/google-samples/hello-frontend:1.0&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>preStop</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/usr/sbin/nginx&#34;</span>,<span style=color:#b44>&#34;-s&#34;</span>,<span style=color:#b44>&#34;quit&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span></span></span></code></pre></div></div></div><p>프론트엔드 디플로이먼트와 서비스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/access/frontend-deployment.yaml
</span></span><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/access/frontend-service.yaml
</span></span></code></pre></div><p>결과는 두 리소스가 생성되었음을 확인한다.</p><pre tabindex=0><code>deployment.apps/frontend created
service/frontend created
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> nginx 구성은 <a href=/examples/service/access/Dockerfile>컨테이너 이미지</a>에
반영 되었다. 이를 실행하는 더 좋은 방법은
구성을
보다 쉽게 변경할
수 있는 <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그맵(ConfigMap)</a>을 사용하는 것이다.</div><h2 id=프론트엔드-서비스와-통신하기>프론트엔드 서비스와 통신하기</h2><p>일단 로드밸런서 타입의 서비스를 생성하면, 이 명령어를
사용해 외부 IP를 찾을 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get service frontend --watch
</span></span></code></pre></div><p><code>frontend</code> 서비스의 구성을 보여주고, 변경 사항을
주시한다. 처음에, 외부 IP는 <code>&lt;pending></code> 으로 나열된다.</p><pre tabindex=0><code>NAME       TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)  AGE
frontend   LoadBalancer   10.51.252.116   &lt;pending&gt;     80/TCP   10s
</code></pre><p>하지만, 외부 IP가 생성되자마자 구성은
<code>EXTERNAL-IP</code> 제목 아래에 새로운 IP를 포함하여 갱신한다.</p><pre tabindex=0><code>NAME       TYPE           CLUSTER-IP      EXTERNAL-IP        PORT(S)  AGE
frontend   LoadBalancer   10.51.252.116   XXX.XXX.XXX.XXX    80/TCP   1m
</code></pre><p>이제 해당 IP는 클러스터 외부에서 <code>frontend</code> 서비스와 통신하는데
사용된다.</p><h2 id=프론트엔드-통해서-트래픽-보내기>프론트엔드 통해서 트래픽 보내기</h2><p>이제 프론트엔드와 백엔드가 연결되었다. 프론트엔드 서비스의 외부 IP에서
curl 명령을 사용해 엔드포인트에 도달할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>EXTERNAL_IP</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#080;font-style:italic># 앞의 예에서 본 EXTERNAL-IP로 수정한다</span>
</span></span></code></pre></div><p>결과로 백엔드에서 생성된 메시지가 보인다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;message&#34;</span>:<span style=color:#b44>&#34;Hello&#34;</span>}
</span></span></code></pre></div><h2 id=정리하기>정리하기</h2><p>서비스를 삭제하기 위해, 아래 명령어를 입력하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete services frontend backend
</span></span></code></pre></div><p>백엔드와 프론트엔드 애플리케이션에서 실행 중인 디플로이먼트, 레플리카셋, 파드를 삭제하기 위해, 아래 명령어를 입력하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment frontend backend
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/services-networking/service/>서비스</a>에 대해 더 알아본다.</li><li><a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그맵</a>에 대해 더 알아본다.</li><li><a href=/ko/docs/concepts/services-networking/dns-pod-service/>서비스와 파드용 DNS</a>에 대해 더 알아본다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-21cd8f87563675fb0278d3694ba9ecb0>7 - 외부 로드 밸런서 생성하기</h1><p>이 문서는 외부 로드 밸런서를 생성하는 방법에 관하여 설명한다.</p><p><a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를 생성할 때,
클라우드 로드 밸런서를 자동으로 생성하는 옵션을 사용할 수 있다.
이것은 클러스터 노드의 올바른 포트로 트래픽을 전송할 수 있도록
외부에서 접근 가능한 IP 주소를 제공한다.
<em>클러스터가 지원되는 환경과
올바른 클라우드 로드 밸런서 제공자 패키지 구성으로 실행되는 경우.</em></p><p>또한, 서비스 대신 <a class=glossary-tooltip title='클러스터 내의 서비스에 대한 외부 접근을 관리하는 API 오브젝트이며, 일반적으로 HTTP를 관리함.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/ingress/ target=_blank aria-label=인그레스(Ingress)>인그레스(Ingress)</a> 를 사용할 수 있다.
자세한 사항은 <a href=/ko/docs/concepts/services-networking/ingress/>인그레스(Ingress)</a>
문서를 참고한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터는 반드시 클라우드 또는 외부 로드 밸런서 구성을 지원하는
환경에서 실행 중이어야 한다.</p><h2 id=서비스-생성>서비스 생성</h2><h3 id=매니페스트를-사용하여-서비스-생성하기>매니페스트를 사용하여 서비스 생성하기</h3><p>외부 로드 밸런서를 생성하기 위해서, 서비스 매니페스트에
다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span></code></pre></div><p>매니페스트는 아래와 같을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8765</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=kubectl를-이용하여-서비스-생성하기>kubectl를 이용하여 서비스 생성하기</h3><p>또한, <code>kubectl expose</code> 명령어에 <code>--type=LoadBalancer</code> 플래그를 이용해
서비스를 생성할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl expose deployment example --port<span style=color:#666>=</span><span style=color:#666>8765</span> --target-port<span style=color:#666>=</span><span style=color:#666>9376</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --name<span style=color:#666>=</span>example-service --type<span style=color:#666>=</span>LoadBalancer
</span></span></code></pre></div><p>이 명령은 동일한 리소스를 셀렉터로 참조하는 새로운 서비스를 만든다.
(위 예시의 경우, <code>example</code>로 명명된
<a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a> ).</p><p>명령줄 옵션 플래그를 포함한, 더 자세한 내용은
<a href=/docs/reference/generated/kubectl/kubectl-commands/#expose><code>kubectl expose</code> 레퍼런스</a> 문서를 참고한다.</p><h2 id=ip-주소-찾기>IP 주소 찾기</h2><p><code>kubectl</code> 명령어를 사용해 서비스 정보를 얻어,
생성된 서비스에 관한 IP 주소를 찾을 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe services example-service
</span></span></code></pre></div><p>출력은 다음과 같다.</p><pre tabindex=0><code>Name:                     example-service
Namespace:                default
Labels:                   app=example
Annotations:              &lt;none&gt;
Selector:                 app=example
Type:                     LoadBalancer
IP Families:              &lt;none&gt;
IP:                       10.3.22.96
IPs:                      10.3.22.96
LoadBalancer Ingress:     192.0.2.89
Port:                     &lt;unset&gt;  8765/TCP
TargetPort:               9376/TCP
NodePort:                 &lt;unset&gt;  30593/TCP
Endpoints:                172.17.0.3:9376
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   &lt;none&gt;
</code></pre><p>로드 밸런서의 IP 주소는 <code>LoadBalancer Ingress</code> 옆에 나타난다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>만약 서비스가 Minikube에서 실행되고 있다면, 아래의 명령을 통해 할당된 IP 주소와 포트를 찾을 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>minikube service example-service --url
</span></span></code></pre></div></div><h2 id=preserving-the-client-source-ip>클라이언트 소스 IP 보존하기</h2><p>기본적으로 대상 컨테이너에 보이는 소스 IP는 클라이언트의 <em>원래 소스 IP가 아니다.</em>
클라이언트의 IP를 보존할 수 있도록 하려면,
아래의 서비스 <code>.spec</code> 필드 구성을 따른다.</p><ul><li><code>.spec.externalTrafficPolicy</code> - 이 서비스가 외부 트래픽을 노드-로컬 또는
클러스터-전체 엔드포인트로 라우팅할지 여부를 나타낸다.
두 가지 옵션이 있다. <code>Cluster</code> (기본) 그리고 <code>Local</code>.
<code>Cluster</code> 는 클라이언트 소스 IP를 가리고 다른 노드에 대한
두 번째 홉(hop)을 발생시킬 수 있지만,
전체적인 부하 분산에서 이점이 있다.
<code>Local</code> 은 클라이언트 소스 IP를 보존하고
<code>LoadBalancer</code>와 <code>NodePort</code> 타입의 서비스에서 두 번째 홉(hop) 발생을 피할 수 있지만,
트래픽 분산이 불균형적인 잠재적인 위험이 있다.</li><li><code>.spec.healthCheckNodePort</code> - 서비스를 위한 헬스 체크 노드 포트(정수 포트 번호)를 지정한다.
<code>healthCheckNodePort</code>를 지정하지 않으면,
서비스 컨트롤러가 클러스터의 노트 포트 범위에서 포트를 할당한다.
API 서버 명령줄 플래그 <code>--service-node-port-range</code>를 설정하여 해당 범위를 구성할 수 있다.
서비스 <code>type</code>이 <code>LoadBalancer</code>이고 <code>externalTrafficPolicy</code>를 <code>Local</code>로 설정한 경우,
서비스는 <code>healthCheckNodePort</code>가 지정되었다면,
사용자가 지정한 설정을 이용한다.</li></ul><p>서비스 매니페스트에서 <code>externalTrafficPolicy</code>를 <code>Local</code>로 설정하면 이 기능이 작동한다.
예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8765</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalTrafficPolicy</span>:<span style=color:#bbb> </span>Local<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=caveats-and-limitations-when-preserving-source-ips>소스 IP를 보존할 때 주의사항 및 제한 사항</h3><p>일부 클라우드 제공자의 로드 밸런싱 서비스에서는 대상별로 다른 가중치를 구성할 수 없다.</p><p>각 대상의 가중치는 노드로 전송하는 트래픽을 측면에서 균등하게 부여하기 때문에
외부 트래픽은 서로 다른 파드 간에 로드 밸런싱되지 않는다.
외부 로드 밸런서는 각 노드에서 대상으로 사용되는 파드의 개수를 인식하지 못한다.</p><p><code>서비스파드개수 &lt;&lt; 노드개수</code> 이거나 <code>서비스파드개수 >> 노드개수</code> 인 경우에선
가중치 없이도 거의 균등한 분포를 볼 수 있다.</p><p>내부 파드 간 트래픽은 <code>ClusterIP</code> 서비스에서와 비슷하게 모든 파드에서 동일한 확률로 IP 서비스를 제공한다.</p><h2 id=garbage-collecting-load-balancers>가비지(Garbage) 수집 로드 밸런서</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.17 [stable]</code></div><p>일반적으로 클라우드 제공자와 관련 있는 로드밸런서 리소스는 <code>type</code>이 <code>LoadBalancer</code>인
서비스가 삭제된 후 즉시 정리되어야 한다.
그러나 관련 서비스가 삭제된 후 클라우드 리소스가 고아가 되는 코너 케이스가 다양한 것으로 알려져 있다.
이러한 문제를 예방하기 위해 서비스 로드밸런서를 위한 <code>Finalizer Protection</code>이 도입되었다.
<code>Finalizer</code>를 사용하면, 서비스 리소스는 로드밸런서 관련 리소스가 삭제될 때까지 삭제되지 않는다.</p><p>특히 서비스에 <code>type</code>이 <code>LoadBalancer</code>인 경우
서비스 컨트롤러는 <code>service.kubernetes.io/load-balancer-cleanup</code>
이라는 이름의 <code>finalizer</code>를 붙인다.
<code>finalizer</code>는 (클라우드) 로드 밸런서 리소스를 정리한 후에만 제거된다.
이렇게 하면 서비스 컨트롤러 충돌(crash)과 같은 코너 케이스에서도
로드 밸런서 리소스가 고아가 되는 것을 방지할 수 있다.</p><h2 id=external-load-balancer-providers>외부 로드 밸런서 제공자</h2><p>중요한 점은 이 기능을 위한 데이터 경로는 쿠버네티스 클러스터 외부의 로드 밸런서에서 제공한다는 것이다.</p><p>서비스의 <code>type</code>이 <code>LoadBalancer</code>로 설정된 경우,
쿠버네티스는 <code>type</code>이 <code>ClusterIP</code>인 경우처럼 동등한 기능을 클러스터 내의 파드에 제공하고
관련 쿠버네티스 파드를 호스팅하는 노드에 대한 항목으로 (쿠버네티스 외부) 로드 밸런서를 프로그래밍을 통해 확장한다.
쿠버네티스 컨트롤 플레인은 외부 로드 밸런서, (필요한 경우) 헬스 체크 및 (필요한 경우) 패킷 필터링 규칙의 생성을 자동화한다.
클라우드 공급자가 로드 밸런서에 대한 IP 주소를 할당하면 컨트롤 플레인이 해당 외부 IP 주소를 찾아 서비스 오브젝트를 갱신한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/services-networking/service/>서비스</a>에 대해 알아보기</li><li><a href=/ko/docs/concepts/services-networking/ingress/>인그레스</a>에 대해 알아보기</li><li><a href=/ko/docs/concepts/services-networking/connect-applications-service/>서비스와 애플리케이션 연결하기</a> 알아보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1839d8468a083839ed1cc8d18fe1142e>8 - NGINX 인그레스(Ingress) 컨트롤러로 Minikube에서 인그레스 설정하기</h1><p><a href=/ko/docs/concepts/services-networking/ingress/>인그레스</a>는 클러스터의 서비스에 대한 외부 액세스를 허용하는 규칙을 정의하는
API 객체이다. <a href=/ko/docs/concepts/services-networking/ingress-controllers/>인그레스 컨트롤러</a>는 인그레스에 설정된 규칙을 이행한다.</p><p>이 페이지에서는 HTTP URI에 따라 요청을 Service web 또는 web2로 라우팅하는 간단한 인그레스를 설정하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: 1.19.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.
만약 이보다 더 이전 버전의 쿠버네티스를 사용하고 있다면,
해당 쿠버네티스 버전의 문서를 참고한다.</p><h3 id=minikube-클러스터-생성하기>Minikube 클러스터 생성하기</h3><dl><dt>Katacoda 활용하기</dt><dd><script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button></dd><dt>로컬에서 생성하기</dt><dd>이미 로컬에 <a href=/ko/docs/tasks/tools/#minikube>Minikube를 설치</a>했다면,
<code>minikube start</code>를 실행하여 클러스터를 생성한다.</dd></dl><h2 id=인그레스-컨트롤러-활성화>인그레스 컨트롤러 활성화</h2><ol><li><p>NGINX 인그레스 컨트롤러를 활성화하기 위해 다음 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> ingress
</span></span></code></pre></div></li><li><p>NGINX 인그레스 컨트롤러가 실행 중인지 확인한다.</p><ul class="nav nav-tabs" id=tab-with-md role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-with-md-0 role=tab aria-controls=tab-with-md-0 aria-selected=true>minikube v1.19 or later</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-md-1 role=tab aria-controls=tab-with-md-1>minikube v1.18.1 or earlier</a></li></ul><div class=tab-content id=tab-with-md><div id=tab-with-md-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-with-md-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -n ingress-nginx
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드가 정상적으로 실행되기까지 1분 정도 소요될 수 있다.</div><p>결과는 다음과 같다.</p><pre tabindex=0><code>NAME                                        READY   STATUS      RESTARTS    AGE
ingress-nginx-admission-create-g9g49        0/1     Completed   0          11m
ingress-nginx-admission-patch-rqp78         0/1     Completed   1          11m
ingress-nginx-controller-59b45fb494-26npt   1/1     Running     0          11m
</code></pre></div><div id=tab-with-md-1 class=tab-pane role=tabpanel aria-labelledby=tab-with-md-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -n kube-system
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드가 정상적으로 실행되기까지 1분 정도 소요될 수 있다.</div><p>결과는 다음과 같다.</p><pre tabindex=0><code>NAME                                        READY     STATUS    RESTARTS   AGE
default-http-backend-59868b7dd6-xb8tq       1/1       Running   0          1m
kube-addon-manager-minikube                 1/1       Running   0          3m
kube-dns-6dcb57bcc8-n4xd4                   3/3       Running   0          2m
kubernetes-dashboard-5498ccf677-b8p5h       1/1       Running   0          2m
nginx-ingress-controller-5984b97644-rnkrg   1/1       Running   0          1m
storage-provisioner                         1/1       Running   0          2m
</code></pre><p><code>nginx-ingress-controller-</code>로 시작하는 파드가 있는지 확인한다.</p></div></div></li></ol><h2 id=hello-world-앱-배포하기>hello, world 앱 배포하기</h2><ol><li><p>다음 명령을 사용하여 디플로이먼트(Deployment)를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment web --image<span style=color:#666>=</span>gcr.io/google-samples/hello-app:1.0
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>deployment.apps/web created
</code></pre></li><li><p>디플로이먼트를 노출시킨다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment web --type<span style=color:#666>=</span>NodePort --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>service/web exposed
</code></pre></li><li><p>서비스(Service)가 생성되고 노드 포트에서 사용할 수 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get service web
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>NAME      TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
web       NodePort   10.104.133.249   &lt;none&gt;        8080:31637/TCP   12m
</code></pre></li><li><p>노드포트(NodePort)를 통해 서비스에 접속한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube service web --url
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>http://172.17.0.15:31637
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> Katacoda 환경만 해당: 터미널 패널 상단에서 더하기 기호를 클릭한 다음 <strong>Select port to view on Host 1</strong>을 클릭한다. 노드포트(이 경우 '31637')를 입력한 다음 <strong>Display Port</strong>를 클릭한다.</div><p>결과는 다음과 같다.</p><pre tabindex=0><code>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre><p>이제 Minikube IP 주소와 노드포트를 통해 샘플 앱에 액세스할 수 있다. 다음 단계에서는
인그레스 리소스를 사용하여 앱에 액세스할 수 있다.</p></li></ol><h2 id=인그레스-생성하기>인그레스 생성하기</h2><p>다음 매니페스트는 hello-world.info를 통해 서비스로 트래픽을 보내는 인그레스를 정의한다.</p><ol><li>다음 파일을 통해 <code>example-ingress.yaml</code>을 만든다.</li></ol><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/networking/example-ingress.yaml download=service/networking/example-ingress.yaml><code>service/networking/example-ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-example-ingress-yaml")' title="Copy service/networking/example-ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-example-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-ingress<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/$1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>hello-world.info<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span></span></span></code></pre></div></div></div><ol><li><p>다음 명령어를 실행하여 인그레스 오브젝트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/networking/example-ingress.yaml
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>ingress.networking.k8s.io/example-ingress created
</code></pre></li><li><p>IP 주소가 설정되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 작업은 몇 분 정도 소요될 수 있다.</div></li></ol><p>다음 예시와 같이, ADDRESS 열에서 IPv4 주소를 확인할 수 있다.</p><pre tabindex=0><code>NAME              CLASS    HOSTS              ADDRESS        PORTS   AGE
example-ingress   &lt;none&gt;   hello-world.info   172.17.0.15    80      38s
</code></pre><ol><li><p>호스트 컴퓨터의 <code>/etc/hosts</code> 파일 맨 아래에
다음 행을 추가한다 (관리자 권한 필요).</p><pre tabindex=0><code>172.17.0.15 hello-world.info
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> Minikube를 로컬에서 실행하는 경우 'minikube ip'를 사용하여 외부 IP를 가져온다. 인그레스 목록에 표시되는 IP 주소는 내부 IP가 된다.</div><p>이렇게 하면, 웹 브라우저가
hello-world.info URL에 대한 요청을 Minikube로 전송한다.</p></li><li><p>인그레스 컨트롤러가 트래픽을 전달하는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl hello-world.info
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> Minikube를 로컬에서 실행하는 경우 브라우저에서 hello-world.info에 접속할 수 있다.</div></li></ol><h2 id=두-번째-디플로이먼트-생성하기>두 번째 디플로이먼트 생성하기</h2><ol><li><p>다음 명령을 사용하여 두 번째 디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment web2 --image<span style=color:#666>=</span>gcr.io/google-samples/hello-app:2.0
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>deployment.apps/web2 created
</code></pre></li><li><p>두 번째 디플로이먼트를 노출시킨다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment web2 --port<span style=color:#666>=</span><span style=color:#666>8080</span> --type<span style=color:#666>=</span>NodePort
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>service/web2 exposed
</code></pre></li></ol><h2 id=edit-ingress>기존 인그레스 수정하기</h2><ol><li><p>기존 <code>example-ingress.yaml</code> 매니페스트를 편집하고,
하단에 다음 줄을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/v2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p>변경 사항을 적용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f example-ingress.yaml
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>ingress.networking/example-ingress configured
</code></pre></li></ol><h2 id=인그레스-테스트하기>인그레스 테스트하기</h2><ol><li><p>Hello World 앱의 첫 번째 버전에 액세스한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl hello-world.info
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></li><li><p>Hello World 앱의 두 번째 버전에 액세스한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl hello-world.info/v2
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>Hello, world!
Version: 2.0.0
Hostname: web2-75cd47646f-t8cjk
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> Minikube를 로컬에서 실행하는 경우 브라우저에서 hello-world.info 및 hello-world.info/v2에 접속할 수 있다.</div></li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/services-networking/ingress/>인그레스</a>에 대해 더 보기.</li><li><a href=/ko/docs/concepts/services-networking/ingress-controllers/>인그레스 컨트롤러</a>에 대해 더 보기.</li><li><a href=/ko/docs/concepts/services-networking/service/>서비스</a>에 대해 더 보기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-48e8f306f919c5b81265e265a2b76ab4>9 - 클러스터 내 모든 컨테이너 이미지 목록 보기</h1><p>이 문서는 kubectl을 이용하여 클러스터 내 모든 컨테이너 이미지 목록을
조회하는 방법에 관해 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><p>이 작업에서는 kubectl을 사용하여 클러스터 내 모든 파드의 정보를
조회하고, 결과값의 서식을 변경하여 각 파드에 대한 컨테이너 이미지 목록으로
재구성할 것이다.</p><h2 id=모든-네임스페이스의-모든-컨테이너-이미지-가져오기>모든 네임스페이스의 모든 컨테이너 이미지 가져오기</h2><ul><li><code>kubectl get pods --all-namespaces</code> 를 사용하여 모든 네임스페이스의 모든 파드 정보를 가져온다.</li><li>컨테이너 이미지 이름만 출력하기 위해 <code>-o jsonpath={.items[*].spec.containers[*].image}</code> 를 사용한다.
이 명령어는 결과값으로 받은 json을 반복적으로 파싱하여,
<code>image</code> 필드만을 출력한다.<ul><li>jsonpath를 사용하는 방법에 대해 더 많은 정보를 얻고 싶다면
<a href=/ko/docs/reference/kubectl/jsonpath/>Jsonpath 지원</a>을 확인한다.</li></ul></li><li>다음의 표준 툴을 이용해서 결과값을 처리한다. <code>tr</code>, <code>sort</code>, <code>uniq</code><ul><li><code>tr</code> 을 사용하여 공백을 줄 바꾸기로 대체한다.</li><li><code>sort</code> 를 사용하여 결과값을 정렬한다.</li><li><code>uniq</code> 를 사용하여 이미지 개수를 합산한다.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>tr -s <span style=color:#b44>&#39;[[:space:]]&#39;</span> <span style=color:#b44>&#39;\n&#39;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>sort |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>uniq -c
</span></span></code></pre></div><p>이 커맨드는 결과값으로 나온 모든 아이템 중에 <code>image</code> 라고 명명된 필드를
모두 출력한다.</p><p>이와 다른 방법으로 파드 이미지 필드 값의 절대 경로를 사용할 수 있다.
이것은 필드명이 반복될 때에도
정확한 값을 출력하도록 보장한다.
예) 결과값 중에 많은 필드들이 <code>name</code>으로 명명되었을 경우,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</span></span></code></pre></div><p>이 jsonpath는 다음과 같이 해석할 수 있다.</p><ul><li><code>.items[*]</code>: 각 결과값에 대하여</li><li><code>.spec</code>: spec 값을 가져온다.</li><li><code>.containers[*]</code>: 각 컨테이너에 대하여</li><li><code>.image</code>: image 값을 가져온다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 명령어로 하나의 파드를 가져올 때, 예를 들어 <code>kubectl get pod nginx</code> 라면,
jsonpath에서 <code>.items[*]</code> 부분은 생략해야 하는데, 이는 명령어가 아이템 목록이 아닌
단 한 개의 아이템(여기선 파드)으로 결과값을 주기 때문이다.</div><h2 id=각-파드의-컨테이너-이미지-보기>각 파드의 컨테이너 이미지 보기</h2><p><code>range</code> 연산을 사용하여 명령어의 결과값에서 각각의 요소들을
반복하여 출력할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{&#34;\n&#34;}{.metadata.name}{&#34;:\t&#34;}{range .spec.containers[*]}{.image}{&#34;, &#34;}{end}{end}&#39;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>sort
</span></span></code></pre></div><h2 id=파드-레이블로-필터링된-컨테이너-이미지-목록-보기>파드 레이블로 필터링된 컨테이너 이미지 목록 보기</h2><p>특정 레이블에 맞는 파드를 지정하기 위해서 -l 플래그를 사용한다. 아래의
명령어 결과값은 <code>app=nginx</code> 레이블에 일치하는 파드만 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span> -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><h2 id=파드-네임스페이스로-필터링된-컨테이너-이미지-목록-보기>파드 네임스페이스로 필터링된 컨테이너 이미지 목록 보기</h2><p>특정 네임스페이스의 파드를 지정하려면, 네임스페이스 플래그를 사용한다.
아래의 명령어 결과값은 <code>kube-system</code> 네임스페이스에 있는 파드만 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --namespace kube-system -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</span></span></code></pre></div><h2 id=jsonpath-대신-go-템플릿을-사용하여-컨테이너-이미지-목록-보기>jsonpath 대신 Go 템플릿을 사용하여 컨테이너 이미지 목록 보기</h2><p>jsonpath의 대안으로 Kubectl은 <a href=https://golang.org/pkg/text/template/>Go 템플릿</a>을 지원한다.
다음과 같이 결과값의 서식을 지정할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#34;{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}&#34;</span>
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=참조>참조</h3><ul><li><a href=/ko/docs/reference/kubectl/jsonpath/>Jsonpath</a> 참조</li><li><a href=https://golang.org/pkg/text/template/>Go 템플릿</a> 참조</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7c319a9981586e5fbcfa21b392720650>10 - 공유 볼륨을 이용하여 동일한 파드의 컨테이너 간에 통신하기</h1><p>이 페이지에서는 동일한 파드에서 실행 중인 두 개의 컨테이너 간에 통신할 때에,
어떻게 볼륨을 이용하는지 살펴본다. 컨테이너 간에
<a href=/docs/tasks/configure-pod-container/share-process-namespace/>프로세스 네임스페이스 공유하기</a>를
통해 통신할 수 있는 방법을 참고하자.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=두-개의-컨테이너를-실행하는-파드-생성>두 개의 컨테이너를 실행하는 파드 생성</h2><p>이 실습에서 두 개의 컨테이너를 실행하는 파드를 생성한다. 이 컨테이너들은
통신에 사용할 수 있는 볼륨을 공유한다.
아래는 이 파드의 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/two-container-pod.yaml download=pods/two-container-pod.yaml><code>pods/two-container-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-two-container-pod-yaml")' title="Copy pods/two-container-pod.yaml to clipboard"></img></div><div class=includecode id=pods-two-container-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>two-containers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>debian-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/pod-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo debian 컨테이너에서 안녕하세요 &gt; /pod-data/index.html&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이 구성 파일에는 파드가 <code>shared-data</code>로 명명한 볼륨을 가진 것을
알 수 있다.</p><p>첫 번째 컨테이너에는 nginx 웹 서버를 실행하는 구성 파일이 나열되어 있다.
공유 볼륨의 마운트 경로는 <code>/usr/share/nginx/html</code>이다.
두 번째 컨테이너는 debian 이미지 기반이고, 마운트 경로는 <code>/pod-data</code>이다.
두 번째 컨테이너는 다음 명령어를 실행한 후에 종료한다.</p><pre><code>echo debian 컨테이너에서 안녕하세요 &gt; /pod-data/index.html
</code></pre><p>두 번째 컨테이너는 <code>index.html</code> 파일을
nginx 웹 서버에서 호스팅하는 문서의 루트 디렉터리(<code>/usr/share/nginx/html/</code>)에 저장한다.</p><p>이제, 파드와 두 개의 컨테이너를 생성한다.</p><pre><code>kubectl apply -f https://k8s.io/examples/pods/two-container-pod.yaml
</code></pre><p>파드와 컨테이너의 정보를 확인한다.</p><pre><code>kubectl get pod two-containers --output=yaml
</code></pre><p>출력의 일부는 다음과 같다.</p><pre><code>apiVersion: v1
kind: Pod
metadata:
  ...
  name: two-containers
  namespace: default
  ...
spec:
  ...
  containerStatuses:

  - containerID: docker://c1d8abd1 ...
    image: debian
    ...
    lastState:
      terminated:
        ...
    name: debian-container
    ...

  - containerID: docker://96c1ff2c5bb ...
    image: nginx
    ...
    name: nginx-container
    ...
    state:
      running:
    ...
</code></pre><p>Debian 컨테이너가 종료되었음을 알 수 있고, nginx 컨테이너는
아직 실행 중이다.</p><p>nginx 컨테이너의 쉘(shell)을 실행한다.</p><pre><code>kubectl exec -it two-containers -c nginx-container -- /bin/bash
</code></pre><p>쉘에서 nginx 웹 서버가 실행 중인지 확인한다.</p><pre><code>root@two-containers:/# apt-get update
root@two-containers:/# apt-get install curl procps
root@two-containers:/# ps aux
</code></pre><p>출력은 아래와 유사하다.</p><pre><code>USER       PID  ...  STAT START   TIME COMMAND
root         1  ...  Ss   21:12   0:00 nginx: master process nginx -g daemon off;
</code></pre><p>Debian 컨테이너에서 nginx 웹 서버가 호스팅하는 문서의 루트 디렉터리에 <code>index.html</code> 파일을 생성했었음을 상기하자.
<code>curl</code>을 이용하여 nginx 웹 서버에 HTTP GET 요청을 보낸다.</p><pre tabindex=0><code>root@two-containers:/# curl localhost
</code></pre><p>출력을 보면, nginx 웹 서버에서 debian 컨테이너에서 쓰여진 웹 페이지를 제공하는 것을 알 수 있다.</p><pre tabindex=0><code>debian 컨테이너에서 안녕하세요
</code></pre><h2 id=토의>토의</h2><p>파드가 여러 컨테이너를 가질 수 있는 주요 이유는 기본 애플리케이션을 보조할
도우미(helper) 애플리케이션을 제공하기 위해서이다. 도우미 애플리케이션의 일반적인 예로는
데이터를 가지고 오는 경우(data puller)나 데이터를 보내주는 경우(data pusher)이거나 프록시가 있다.
도우미와 기본 애플리케이션은 종종 서로 간에 통신을 해야 할 수 있다.
일반적으로 이는 이번 예제에서 살펴본 것 같이, 공유 파일 시스템을 통하거나,
루프백 네트워크 인터페이스 곧 로컬 호스트(localhost)를 통해서 이뤄진다. 이 패턴의 한가지 예는
웹 서버가 도우미 프로그램과 함께 Git 저장소에서 새 업데이트를 받아오는 경우이다.</p><p>이 예제에서 볼륨은 파드의 생명 주기 동안 컨테이너를 위한 통신 방법으로 이용했다.
파드가 삭제되고 재생성되면, 공유 볼륨에 저장된 데이터는 잃어버린다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><p><a href=/blog/2015/06/the-distributed-system-toolkit-patterns>합성 컨테이너(composite container) 패턴</a>에 관하여 더 공부한다.</p></li><li><p><a href=https://www.slideshare.net/Docker/slideshare-burns>모듈 구조를 위한 합성 컨테이너 구조</a>에 관하여 더 공부한다.</p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/configure-volume-storage/>파드에서 저장소로 볼룸을 사용하도록 구성하기</a>에 관하여 확인한다.</p></li><li><p><a href=/docs/tasks/configure-pod-container/share-process-namespace/>파드에서 컨테이너 간에 프로세스 네임스페이스를 공유하는 파드 구성하는 방법</a>을 참고한다.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#volume-v1-core>볼륨</a>을 확인한다.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>파드</a>을 확인한다.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-322786b38586b210fab68f785259c5f6>11 - 클러스터의 DNS 구성하기</h1><p>쿠버네티스는 지원하는 모든 환경에서 기본으로 활성화된 DNS 클러스터 애드온을 제공한다. 쿠버네티스 1.11과 이후 버전에서는, CoreDNS가 권장되고 기본적으로 kubeadm과 함께 설치 된다.</p><p>쿠버네티스 클러스터의 CoreDNS 설정에 대한 더 많은 정보는, <a href=/ko/docs/tasks/administer-cluster/dns-custom-nameservers/>DNS 서비스 사용자화 하기</a>을 본다. kube-dns와 함께 쿠버네티스 DNS를 사용하는 방법을 보여주는 예시는 <a href=https://github.com/kubernetes/examples/tree/master/staging/cluster-dns>쿠버네티스 DNS 샘플 플러그인</a>을 본다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-43591bb11cc02c39e278cf07f6546810>12 - 클러스터에서 실행되는 서비스에 접근</h1><p>이 페이지는 쿠버네티스 클러스터에서 실행되는 서비스에 연결하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=클러스터에서-실행되는-서비스에-접근>클러스터에서 실행되는 서비스에 접근</h2><p>쿠버네티스에서, <a href=/ko/docs/concepts/architecture/nodes/>노드</a>,
<a href=/ko/docs/concepts/workloads/pods/>파드</a> 및 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>는 모두
고유한 IP를 가진다. 당신의 데스크탑 PC와 같은 클러스터 외부 장비에서는
클러스터 상의 노드 IP, 파드 IP, 서비스 IP로 라우팅되지 않아서
접근할 수 없을 것이다.</p><h3 id=연결하는-방법>연결하는 방법</h3><p>클러스터 외부에서 노드, 파드 및 서비스에 접속하기 위한 몇 가지 옵션이 있다.</p><ul><li>퍼블릭 IP를 통해 서비스에 접근한다.<ul><li>클러스터 외부에서 접근할 수 있도록 <code>NodePort</code> 또는 <code>LoadBalancer</code> 타입의
서비스를 사용한다. <a href=/ko/docs/concepts/services-networking/service/>서비스</a>와
<a href=/docs/reference/generated/kubectl/kubectl-commands/#expose>kubectl expose</a> 문서를 참고한다.</li><li>클러스터 환경에 따라, 서비스는 회사 네트워크에만 노출되기도 하며,
인터넷에 노출되는 경우도 있다. 이 경우 노출되는 서비스의 보안 여부를 고려해야 한다.
해당 서비스는 자체적으로 인증을 수행하는가?</li><li>파드는 서비스 뒤에 위치시킨다. 디버깅과 같은 목적으로 레플리카 집합에서 특정 파드에 접근하려면,
파드에 고유한 레이블을 배치하고 이 레이블을 선택하는 새 서비스를 생성한다.</li><li>대부분의 경우, 애플리케이션 개발자가 nodeIP를 통해 노드에 직접
접근할 필요는 없다.</li></ul></li><li>프록시 작업(Proxy Verb)을 사용하여 서비스, 노드 또는 파드에 접근한다.<ul><li>원격 서비스에 접근하기 전에 apiserver 인증과 권한 부여를 수행한다.
서비스가 인터넷에 노출되거나, 노드 IP의 포트에 접근하거나, 디버깅하기에
충분히 안전하지 않은 경우 사용한다.</li><li>프록시는 일부 웹 애플리케이션에 문제를 일으킬 수 있다.</li><li>HTTP/HTTPS에서만 작동한다.</li><li><a href=#apiserver-%ED%94%84%EB%A1%9D%EC%8B%9C-url-%EC%88%98%EB%8F%99-%EA%B5%AC%EC%84%B1>여기</a>에 설명되어 있다.</li></ul></li><li>클러스터의 노드 또는 파드에서 접근한다.<ul><li>파드를 실행한 다음, <a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>를 사용하여 셸에 연결한다.
해당 셸에서 다른 노드, 파드 및 서비스에 연결한다.</li><li>일부 클러스터는 클러스터의 노드로 ssh를 통해 접근하는 것을 허용한다. 거기에서 클러스터 서비스에
접근할 수 있다. 이것은 비표준 방법이며, 일부 클러스터에서는 작동하지만 다른 클러스터에서는
작동하지 않는다. 브라우저 및 기타 도구가 설치되거나 설치되지 않을 수 있다. 클러스터 DNS가 작동하지 않을 수도 있다.</li></ul></li></ul><h3 id=빌트인-서비스-검색>빌트인 서비스 검색</h3><p>일반적으로 kube-system에 의해 클러스터에 실행되는 몇 가지 서비스가 있다.
<code>kubectl cluster-info</code> 커맨드로 이 서비스의 리스트를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><p>출력은 다음과 비슷하다.</p><pre tabindex=0><code>Kubernetes master is running at https://192.0.2.1
elasticsearch-logging is running at https://192.0.2.1/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy
kibana-logging is running at https://192.0.2.1/api/v1/namespaces/kube-system/services/kibana-logging/proxy
kube-dns is running at https://192.0.2.1/api/v1/namespaces/kube-system/services/kube-dns/proxy
grafana is running at https://192.0.2.1/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
heapster is running at https://192.0.2.1/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
</code></pre><p>각 서비스에 접근하기 위한 프록시-작업 URL이 표시된다.
예를 들어, 이 클러스터에는 <code>https://192.0.2.1/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code> 로
접근할 수 있는 (Elasticsearch를 사용한) 클러스터 수준 로깅이 활성화되어 있다. 적합한 자격 증명이 전달되는 경우나 kubectl proxy를 통해 도달할 수 있다. 예를 들어 다음의 URL에서 확인할 수 있다.
<code>http://localhost:8080/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code>.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 자격 증명을 전달하거나 kubectl proxy를 사용하는 방법은 <a href=/ko/docs/tasks/administer-cluster/access-cluster-api/>쿠버네티스 API를 사용하여 클러스터에 접근하기</a>를 참고한다.</div><h4 id=apiserver-프록시-url-수동-구성>apiserver 프록시 URL 수동 구성</h4><p>위에서 언급한 것처럼, <code>kubectl cluster-info</code> 명령을 사용하여 서비스의 프록시 URL을 검색한다. 서비스 엔드포인트, 접미사 및 매개 변수를 포함하는 프록시 URL을 작성하려면, 서비스의 프록시 URL에 추가하면 된다.
<code>http://</code><em><code>kubernetes_master_address</code></em><code>/api/v1/namespaces/</code><em><code>namespace_name</code></em><code>/services/</code><em><code>[https:]service_name[:port_name]</code></em><code>/proxy</code></p><p>포트에 대한 이름을 지정하지 않은 경우, URL에 <em>port_name</em> 을 지정할 필요가 없다. 또한, 이름이 지정된 포트와 지정되지 않은 포트 모두에 대해, <em>port_name</em> 자리에 포트 번호를 기재할 수도 있다.</p><p>기본적으로, API 서버는 서비스로의 프록시를 HTTP로 제공한다. HTTPS를 사용하려면, 서비스 이름 앞에 <code>https:</code>를 추가한다.
<code>http://&lt;쿠버네티스_컨트롤_플레인_주소>/api/v1/namespaces/&lt;네임스페이스_이름>/services/&lt;서비스_이름>/proxy</code></p><p>URL에서 <code>&lt;서비스_이름></code>이 지원하는 형식은 다음과 같다.</p><ul><li><code>&lt;서비스_이름></code> - 기본 포트 또는 이름이 지정되지 않은 포트로 http를 사용하여 프록시</li><li><code>&lt;서비스_이름>:&lt;포트_이름></code> - 기재된 포트 이름 또는 포트 번호로 http를 사용하여 프록시</li><li><code>https:&lt;서비스_이름>:</code> - 기본 포트 또는 이름이 지정되지 않은 포트로 https를 사용하여 프록시(맨 끝의 콜론에 유의)</li><li><code>https:&lt;서비스_이름>:&lt;포트_이름></code> - 기재된 포트 이름 또는 포트 번호로 https를 사용하여 프록시</li></ul><h5 id=예제>예제</h5><ul><li><p>Elasticsearch 서비스 엔드포인트 <code>_search?q=user:kimchy</code> 에 접근하려면, 다음을 사용한다.</p><pre tabindex=0><code>http://192.0.2.1/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_search?q=user:kimchy
</code></pre></li><li><p>Elasticsearch 클러스터 상태 정보 <code>_cluster/health?pretty=true</code> 에 접근하려면, 다음을 사용한다.</p><pre tabindex=0><code>https://192.0.2.1/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_cluster/health?pretty=true
</code></pre><p>상태 정보는 다음과 비슷하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cluster_name&#34;</span> : <span style=color:#b44>&#34;kubernetes_logging&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span> : <span style=color:#b44>&#34;yellow&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;timed_out&#34;</span> : <span style=color:#a2f;font-weight:700>false</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;number_of_nodes&#34;</span> : <span style=color:#666>1</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;number_of_data_nodes&#34;</span> : <span style=color:#666>1</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;active_primary_shards&#34;</span> : <span style=color:#666>5</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;active_shards&#34;</span> : <span style=color:#666>5</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;relocating_shards&#34;</span> : <span style=color:#666>0</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;initializing_shards&#34;</span> : <span style=color:#666>0</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;unassigned_shards&#34;</span> : <span style=color:#666>5</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><em>https</em> Elasticsearch 서비스 상태 정보 <code>_cluster/health?pretty=true</code> 에 접근하려면, 다음을 사용한다.</p><pre tabindex=0><code>https://192.0.2.1/api/v1/namespaces/kube-system/services/https:elasticsearch-logging/proxy/_cluster/health?pretty=true
</code></pre></li></ul><h4 id=웹-브라우저를-사용하여-클러스터에서-실행되는-서비스에-접근>웹 브라우저를 사용하여 클러스터에서 실행되는 서비스에 접근</h4><p>브라우저의 주소 표시줄에 apiserver 프록시 URL을 넣을 수 있다. 그러나,</p><ul><li>웹 브라우저는 일반적으로 토큰을 전달할 수 없으므로, 기본 (비밀번호) 인증을 사용해야 할 수도 있다. Apiserver는 기본 인증을 수락하도록 구성할 수 있지만,
클러스터는 기본 인증을 수락하도록 구성되지 않을 수 있다.</li><li>일부 웹 앱, 특히 프록시 경로 접두사를 인식하지 못하는 방식으로 URL을 구성하는 클라이언트 측 자바스크립트가 있는
웹 앱이 작동하지 않을 수 있다.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>