<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/tasks/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/tasks/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/><link rel=alternate hreflang=hi href=https://kubernetes.io/hi/docs/tasks/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/tasks/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/tasks/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>태스크 | Kubernetes</title><meta property="og:title" content="태스크"><meta property="og:description" content="운영 수준의 컨테이너 오케스트레이션"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/tasks/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="태스크"><meta itemprop=description content="운영 수준의 컨테이너 오케스트레이션"><meta name=twitter:card content="summary"><meta name=twitter:title content="태스크"><meta name=twitter:description content="운영 수준의 컨테이너 오케스트레이션"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="쿠버네티스 문서에서 이 섹션은 개별의 태스크를 수행하는 방법을 보여준다. 한 태스크 페이지는 일반적으로 여러 단계로 이루어진 짧은 시퀀스를 제공함으로써, 하나의 일을 수행하는 방법을 보여준다.
만약 태스크 페이지를 작성하고 싶다면, 문서 풀 리퀘스트(Pull Request) 생성하기를 참조한다."><meta property="og:description" content="쿠버네티스 문서에서 이 섹션은 개별의 태스크를 수행하는 방법을 보여준다. 한 태스크 페이지는 일반적으로 여러 단계로 이루어진 짧은 시퀀스를 제공함으로써, 하나의 일을 수행하는 방법을 보여준다.
만약 태스크 페이지를 작성하고 싶다면, 문서 풀 리퀘스트(Pull Request) 생성하기를 참조한다."><meta name=twitter:description content="쿠버네티스 문서에서 이 섹션은 개별의 태스크를 수행하는 방법을 보여준다. 한 태스크 페이지는 일반적으로 여러 단계로 이루어진 짧은 시퀀스를 제공함으로써, 하나의 일을 수행하는 방법을 보여준다.
만약 태스크 페이지를 작성하고 싶다면, 문서 풀 리퀘스트(Pull Request) 생성하기를 참조한다."><meta property="og:url" content="https://kubernetes.io/ko/docs/tasks/"><meta property="og:title" content="태스크"><meta name=twitter:title content="태스크"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/tasks/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/tasks/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/tasks/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/tasks/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/tasks/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tasks/>English</a>
<a class=dropdown-item href=/zh-cn/docs/tasks/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/tasks/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/tasks/>Français (French)</a>
<a class=dropdown-item href=/de/docs/tasks/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/tasks/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/tasks/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/tasks/>Bahasa Indonesia</a>
<a class=dropdown-item href=/hi/docs/tasks/>हिन्दी (Hindi)</a>
<a class=dropdown-item href=/pl/docs/tasks/>Polski (Polish)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/tasks/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>태스크</h1><ul><li>1: <a href=#pg-57bf66f59d9a642b82eebeabbc66470b>도구 설치</a></li><ul><li>1.1: <a href=#pg-961fc70b732cb8df4fd11a3463b6545c>macOS에 kubectl 설치 및 설정</a></li><li>1.2: <a href=#pg-37b6179f23c8ad977cb9daa6d2da748a>리눅스에 kubectl 설치 및 설정</a></li><li>1.3: <a href=#pg-2cc93d3011d707aeb6564bab02048f7a>윈도우에 kubectl 설치 및 설정</a></li><li>1.4: <a href=#pg-91639f08dfa86a6c88cf0099b2e097bc>포함된 도구들</a></li><ul><li>1.4.1: <a href=#pg-643b1104b7b31ae10b173acfb447843a>fish auto-completion</a></li><li>1.4.2: <a href=#pg-b2d43b2ae3e8f26eefa83de2db4ba782>kubectl 설치 검증하기</a></li><li>1.4.3: <a href=#pg-d4ebbbe0a2ddce15850a36dfede9ba52>kubectl-convert 개요</a></li><li>1.4.4: <a href=#pg-68808b3ec5807517ed64fd8ae32a7d1b>macOS에서 bash 자동 완성 사용하기</a></li><li>1.4.5: <a href=#pg-730f5a835775a8e94bd1c481d3f1a349>PowerShell 자동 완성</a></li><li>1.4.6: <a href=#pg-9ab27577326839cb4793fd670a916364>zsh 자동 완성</a></li><li>1.4.7: <a href=#pg-99d563e9521796074ba3ca7f15a613ce>다음 단계는 무엇인가?</a></li><li>1.4.8: <a href=#pg-2d600cc8ec4dec69673b5f9577b6da22>리눅스에서 bash 자동 완성 사용하기</a></li></ul></ul><li>2: <a href=#pg-61e6bd39c782b924943d60fc8387afe4>모니터링, 로깅, 및 디버깅</a></li><ul><li>2.1: <a href=#pg-4a26f4e7f9ffe4b86dea8b77906d3d5c>애플리케이션 트러블슈팅하기</a></li><ul><li>2.1.1: <a href=#pg-abb72792fa997869a6d241ca28ea225e>파드 디버깅하기</a></li><li>2.1.2: <a href=#pg-089001d4003f033e21602adcb11cd277>스테이트풀셋 디버깅하기</a></li><li>2.1.3: <a href=#pg-43445f3208669d4078e87dbdbeed8473>초기화 컨테이너(Init Containers) 디버그하기</a></li><li>2.1.4: <a href=#pg-132acc7efbd72bd677945eda3b6c6d38>동작 중인 파드 디버그</a></li><li>2.1.5: <a href=#pg-09530217eead8a801ead3ef165c2f591>동작중인 컨테이너의 셸에 접근하기</a></li><li>2.1.6: <a href=#pg-655b47c523b6f1b52d25e520625abccb>파드 실패의 원인 검증하기</a></li></ul><li>2.2: <a href=#pg-ce321f5c35198a1d9b64d52a98ba705c>클러스터 트러블슈팅</a></li><ul><li>2.2.1: <a href=#pg-5ff0cdcf7701f887e45d629f5cfe0424>리소스 메트릭 파이프라인</a></li><li>2.2.2: <a href=#pg-cb9e28c208c6cfbabdb15ba2e42e9ef0>리소스 모니터링 도구</a></li><li>2.2.3: <a href=#pg-20165c8269bed123bfb94fb6e7f85643>노드 헬스 모니터링하기</a></li><li>2.2.4: <a href=#pg-6ca4f22ef4d1713577ada4815f0a3b5a>crictl로 쿠버네티스 노드 디버깅하기</a></li><li>2.2.5: <a href=#pg-38387ad04dd284933cb502944ea3515b>감사(auditing)</a></li><li>2.2.6: <a href=#pg-60dca0ec8d41f0045e7d73e1d6bd7bce>로컬에서 텔레프레즌스를 이용한 서비스 개발 및 디버깅</a></li><li>2.2.7: <a href=#pg-34f51c9306a166418b33355c09e672be>윈도우 디버깅 팁</a></li></ul></ul><li>3: <a href=#pg-34a810f1516ad9d99b2697e36e9b0d0f>클러스터 운영</a></li><ul><li>3.1: <a href=#pg-8e16d69617b175d61e2e7a6e1642c9d6>kubeadm으로 관리하기</a></li><ul><li>3.1.1: <a href=#pg-f62fba1de4084f3be070785757c8079c>kubeadm을 사용한 인증서 관리</a></li><li>3.1.2: <a href=#pg-2e173356df5179cab9eec90a606f0aa4>kubeadm 클러스터 업그레이드</a></li><li>3.1.3: <a href=#pg-e805c7d8d4ad6195cb82dbbc843bfc29>윈도우 노드 업그레이드</a></li></ul><li>3.2: <a href=#pg-adb6c52e773f4d890595e14a9251f59b>도커심으로부터 마이그레이션</a></li><ul><li>3.2.1: <a href=#pg-d81ef0973a7bb4813e1797a452864742>도커 엔진 노드를 도커심에서 cri-dockerd로 마이그레이션하기</a></li></ul><li>3.3: <a href=#pg-47be5dd51f686017f1766e6ec7aa6f41>메모리, CPU 와 API 리소스 관리</a></li><ul><li>3.3.1: <a href=#pg-337620c76587e4aeb32009cb23be46de>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></li><li>3.3.2: <a href=#pg-320af95e480962c538ebef7ae205845c>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></li><li>3.3.3: <a href=#pg-adb489b1ab985c9215657b0d4c6ae92b>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></li><li>3.3.4: <a href=#pg-a87cbd1f9379dac7a48ae320da68a9ad>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></li><li>3.3.5: <a href=#pg-fe3283559a3df299aae3ee00ecea2fad>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></li><li>3.3.6: <a href=#pg-40e30a9209e0c9f4153707e43243e9d7>네임스페이스에 대한 파드 쿼터 구성</a></li></ul><li>3.4: <a href=#pg-7743f043c43f7b12e8654e2227dbc658>인증서</a></li><li>3.5: <a href=#pg-8c31aafd38fad5b0de0bd191758d6f93>네트워크 폴리시 제공자(Network Policy Provider) 설치</a></li><ul><li>3.5.1: <a href=#pg-1239a77618c6278373832a142cd85519>네트워크 폴리시로 캘리코(Calico) 사용하기</a></li><li>3.5.2: <a href=#pg-95039241255a31df196beaa405b68eba>네트워크 폴리시로 실리움(Cilium) 사용하기</a></li><li>3.5.3: <a href=#pg-505a0a6a7e6eff361bbb3be81c84b2e0>네트워크 폴리시로 큐브 라우터(Kube-router) 사용하기</a></li><li>3.5.4: <a href=#pg-2842eac98aa0e229a5c6755c4c83d2a7>네트워크 폴리시로 로마나(Romana)</a></li><li>3.5.5: <a href=#pg-ac075c3fdfd0d41aa753cc70e42be064>네트워크 폴리시로 위브넷(Weave Net) 사용하기</a></li></ul><li>3.6: <a href=#pg-3d0cd7d2f13d4759094f281504cf57b8>DNS 서비스 사용자 정의하기</a></li><li>3.7: <a href=#pg-2bffd7f3571cdd609bd97fb2e1bdb2fe>기본 스토리지클래스(StorageClass) 변경하기</a></li><li>3.8: <a href=#pg-1e966f5d0540bbee0876f9d0d08d54dc>네임스페이스를 사용해 클러스터 공유하기</a></li><li>3.9: <a href=#pg-a3790dfb57271d13517e549dffa805b9>네트워크 폴리시(Network Policy) 선언하기</a></li><li>3.10: <a href=#pg-a8f6511197efcd7d0db80ade49620f9d>노드에 대한 확장 리소스 알리기</a></li><li>3.11: <a href=#pg-e1afcdac8d5e8458274b3c481c5ebcda>서비스 디스커버리를 위해 CoreDNS 사용하기</a></li><li>3.12: <a href=#pg-a02f35804917d7a269c38d7e2c475005>스토리지 사용량 제한</a></li><li>3.13: <a href=#pg-4a02bcca41439e16655f43fa37c81da4>중요한 애드온 파드 스케줄링 보장하기</a></li><li>3.14: <a href=#pg-09cc2cf3e0f23a3996e6cb31dc4d867c>쿠버네티스 API 활성화 혹은 비활성화하기</a></li><li>3.15: <a href=#pg-e77685d5b88d2db5c7631a27b9472eea>쿠버네티스 API를 사용하여 클러스터에 접근하기</a></li><li>3.16: <a href=#pg-fe5ad73163d38596340536ec03a205f0>쿠버네티스 클러스터에서 sysctl 사용하기</a></li><li>3.17: <a href=#pg-fe6b50655c29ab0b7c1ee549ff64c138>클러스터 업그레이드</a></li><li>3.18: <a href=#pg-4e9de5bc3973e5d2bb8f09ff940c3319>클러스터에서 캐스케이딩 삭제 사용</a></li><li>3.19: <a href=#pg-fbc9136f53eccd6eb8c80f4bbea3b8f4>퍼시스턴트볼륨 반환 정책 변경하기</a></li></ul><li>4: <a href=#pg-f5da33b976758a9183018c421eb83f58>파드와 컨테이너 설정</a></li><ul><li>4.1: <a href=#pg-e6dd9300cf3a955f7cdfe77fb5d15292>컨테이너 및 파드 메모리 리소스 할당</a></li><li>4.2: <a href=#pg-f5da7517bee8a8807431d9fc65263b39>윈도우 파드 및 컨테이너에서 RunAsUserName 구성</a></li><li>4.3: <a href=#pg-aa522472483f900008124a2809f2114b>윈도우 파드와 컨테이너용 GMSA 구성</a></li><li>4.4: <a href=#pg-904cea8c8efd5c0d33adbfe579ec2dd2>파드에 대한 서비스 품질(QoS) 구성</a></li><li>4.5: <a href=#pg-484833fb880d1e179cc2965d15f84da5>스토리지의 볼륨을 사용하는 파드 구성</a></li><li>4.6: <a href=#pg-528d2422215cb9632b7b45e886b023b5>스토리지로 퍼시스턴트볼륨(PersistentVolume)을 사용하도록 파드 설정하기</a></li><li>4.7: <a href=#pg-4621938ba53c04a77f51b5938a583439>파드의 스토리지에 프로젝티드 볼륨(Projected Volume)을 사용하도록 구성</a></li><li>4.8: <a href=#pg-d385b86a7cb496d3b1c3b2a47280ca70>프라이빗 레지스트리에서 이미지 받아오기</a></li><li>4.9: <a href=#pg-fc3f4777ae8ea685d2b54e175277ac01>노드 어피니티를 사용해 노드에 파드 할당</a></li><li>4.10: <a href=#pg-bbc17480da6d051c696489654c64064a>노드에 파드 할당</a></li><li>4.11: <a href=#pg-1e7baac1825631a5af5d2aebcf059249>초기화 컨테이너에 대한 구성</a></li><li>4.12: <a href=#pg-18935633a984586fbb68b727f3f339bb>파드에 유저 네임스페이스 사용하기</a></li><li>4.13: <a href=#pg-42a59b878d4c58e5c6f4bb87483dda93>스태틱(static) 파드 생성하기</a></li></ul><li>5: <a href=#pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>쿠버네티스 오브젝트 관리</a></li><ul><li>5.1: <a href=#pg-df206392be6f4d19bd8da41cee7170fa>구성 파일을 이용한 쿠버네티스 오브젝트의 선언형 관리</a></li><li>5.2: <a href=#pg-11aa6950fcb203094823c8e2cbdd517f>Kustomize를 이용한 쿠버네티스 오브젝트의 선언형 관리</a></li><li>5.3: <a href=#pg-80c83fe9b80d0fef2681c8d59c0aa197>명령형 커맨드를 이용한 쿠버네티스 오브젝트 관리하기</a></li><li>5.4: <a href=#pg-b18886277c410fc6f32ce068e2160537>구성 파일을 이용한 명령형 쿠버네티스 오브젝트 관리</a></li></ul><li>6: <a href=#pg-94f49ece137035764368f22a98942872>시크릿(Secret) 관리</a></li><ul><li>6.1: <a href=#pg-0ed63ce3c9665aed7ff5a560ff1da843>kubectl을 사용한 시크릿 관리</a></li><li>6.2: <a href=#pg-e841cf91fd3566db1e86143ed7a9e13c>환경 설정 파일을 사용하여 시크릿을 관리</a></li><li>6.3: <a href=#pg-a0ff2e3ba8af5670d5dc3d94c4bd0a68>kustomize를 사용하여 시크릿 관리</a></li></ul><li>7: <a href=#pg-866924fa095f897ede8dfdcab9e97942>애플리케이션에 데이터 주입하기</a></li><ul><li>7.1: <a href=#pg-c9af1e81bb6e109f6c41febe44f0931b>컨테이너를 위한 커맨드와 인자 정의하기</a></li><li>7.2: <a href=#pg-eff97c25c917cdb414eda016df0e2bca>종속 환경 변수 정의하기</a></li><li>7.3: <a href=#pg-82c93897176489678232542102daea40>컨테이너를 위한 환경 변수 정의하기</a></li><li>7.4: <a href=#pg-66c0456fdbef5e5116dd606d1e6f73cc>환경 변수로 컨테이너에 파드 정보 노출하기</a></li><li>7.5: <a href=#pg-bcf93d1cd019501fd0b7649e9fbcaf60>파일로 컨테이너에 파드 정보 노출하기</a></li><li>7.6: <a href=#pg-7f9454a1e775548c23ee5b300a9218a3>시크릿(Secret)을 사용하여 안전하게 자격증명 배포하기</a></li></ul><li>8: <a href=#pg-a78a5e7e765fd8c49c8f7c0d72499f72>애플리케이션 실행</a></li><ul><li>8.1: <a href=#pg-790ea02857492b3a822e981e93e3a98b>디플로이먼트(Deployment)로 스테이트리스 애플리케이션 실행하기</a></li><li>8.2: <a href=#pg-43398a6f5dc7ce19df59f5f4c2e7922d>단일 인스턴스 스테이트풀 애플리케이션 실행하기</a></li><li>8.3: <a href=#pg-7a9b5779e228083ba3fdeaf414fe704e>스테이트풀셋(StatefulSet) 확장하기</a></li><li>8.4: <a href=#pg-c43537b0ee1da992ecb7488f87e6c934>스테이트풀셋(StatefulSet) 삭제하기</a></li><li>8.5: <a href=#pg-f5f2f7a74377a9d45325c5253353fa8f>스테이트풀셋(StatefulSet) 파드 강제 삭제하기</a></li><li>8.6: <a href=#pg-0c0bb1bd76d2a9069e50e2cec6d20c2a>Horizontal Pod Autoscaling</a></li><li>8.7: <a href=#pg-8138226ce9660ac8e3e82ff86fff8ad2>HorizontalPodAutoscaler 연습</a></li><li>8.8: <a href=#pg-52cd10ee3fc7c74a6c31043a2d489878>파드 내에서 쿠버네티스 API에 접근</a></li></ul><li>9: <a href=#pg-ca3bc4e31dfe46d5044a3b93eb804ee9>잡(Job) 실행</a></li><ul><li>9.1: <a href=#pg-964bdff888520740e5e221695245678d>크론잡(CronJob)으로 자동화된 작업 실행</a></li><li>9.2: <a href=#pg-1058efa4d70f13c015e6a2094ff85068>작업 대기열을 사용한 거친 병렬 처리</a></li><li>9.3: <a href=#pg-457c9dd93aed2b05615ed28dc38075d3>작업 대기열을 사용한 정밀 병렬 처리</a></li><li>9.4: <a href=#pg-9e63850014876afaebd1561f70bb8f6b>정적 작업 할당을 통한 병렬 처리를 위한 색인된 잡</a></li><li>9.5: <a href=#pg-da7c2b067953d239eb4457e8978ad8f6>확장을 사용한 병렬 처리</a></li></ul><li>10: <a href=#pg-b74b959f5a531003dd0653dfbfc2e88b>클러스터 내 어플리케이션 접근</a></li><ul><li>10.1: <a href=#pg-777447042cd4e81df3fa5beb3357a485>쿠버네티스 대시보드를 배포하고 접속하기</a></li><li>10.2: <a href=#pg-6a8d9e9e05f2b6825afbb8889c957370>클러스터 접근</a></li><li>10.3: <a href=#pg-5a233e14205d77fe1294917d2da6f876>다중 클러스터 접근 구성</a></li><li>10.4: <a href=#pg-72d3dddbc0c166c9a364e753d2b31ff0>포트 포워딩을 사용해서 클러스터 내 애플리케이션에 접근하기</a></li><li>10.5: <a href=#pg-312f29f850826b74618634cd877aa065>클러스터 내 애플리케이션에 접근하기 위해 서비스 사용하기</a></li><li>10.6: <a href=#pg-f3dac629bea950fc026d920306f09fb4>서비스를 사용하여 프론트엔드를 백엔드에 연결</a></li><li>10.7: <a href=#pg-21cd8f87563675fb0278d3694ba9ecb0>외부 로드 밸런서 생성하기</a></li><li>10.8: <a href=#pg-1839d8468a083839ed1cc8d18fe1142e>NGINX 인그레스(Ingress) 컨트롤러로 Minikube에서 인그레스 설정하기</a></li><li>10.9: <a href=#pg-48e8f306f919c5b81265e265a2b76ab4>클러스터 내 모든 컨테이너 이미지 목록 보기</a></li><li>10.10: <a href=#pg-7c319a9981586e5fbcfa21b392720650>공유 볼륨을 이용하여 동일한 파드의 컨테이너 간에 통신하기</a></li><li>10.11: <a href=#pg-322786b38586b210fab68f785259c5f6>클러스터의 DNS 구성하기</a></li><li>10.12: <a href=#pg-43591bb11cc02c39e278cf07f6546810>클러스터에서 실행되는 서비스에 접근</a></li></ul><li>11: <a href=#pg-11a6d16334428909c99e7208ab8fa5e9>쿠버네티스 확장</a></li><ul><li>11.1: <a href=#pg-c4798e42eaccc051e396542befb3c57b>확장 API 서버 설정</a></li><li>11.2: <a href=#pg-c00a2767fac9dbfafce583cf489cc423>다중 스케줄러 설정</a></li><li>11.3: <a href=#pg-1707517970dd390995f760308c2e2de6>HTTP 프록시를 사용하여 쿠버네티스 API에 접근</a></li><li>11.4: <a href=#pg-46417c7cdd2da2c530aaeddca1861e5c>SOCKS5 프록시를 사용하여 쿠버네티스 API에 접근</a></li><li>11.5: <a href=#pg-61cf1f2f0fbe98e7635fce65f04a775f>Konnectivity 서비스 설정</a></li></ul><li>12: <a href=#pg-d3c88a8663f58e9ec0bed73faff5b670>TLS</a></li><ul><li>12.1: <a href=#pg-1272b18ac0c008f6ffc2c62a29fa929f>Kubelet의 인증서 갱신 구성</a></li><li>12.2: <a href=#pg-9a87de8ee8332cb487f34a05debb1125>클러스터에서 TLS 인증서 관리</a></li></ul><li>13: <a href=#pg-ba58efa15c6d46f10e34d799be220965>클러스터 데몬 관리</a></li><ul><li>13.1: <a href=#pg-bcfd795e4b59420f7db275a0482af37c>데몬셋(DaemonSet)에서 롤링 업데이트 수행</a></li><li>13.2: <a href=#pg-f1bf7e426f482a85e1a417d1fd9ea7b7>데몬셋(DaemonSet)에서 롤백 수행</a></li></ul><li>14: <a href=#pg-a701e71f3b32dae474c63ae4c596c856>네트워킹</a></li><ul><li>14.1: <a href=#pg-2edb5b02ea1e646c333c9fe4d5f02ff1>HostAliases로 파드의 /etc/hosts 항목 추가하기</a></li><li>14.2: <a href=#pg-eebac062766222247063d6513f95c7b2>IPv4/IPv6 이중 스택 검증</a></li></ul><li>15: <a href=#pg-5ab7bc7f14942c5c4b29d19f4a87271c>GPU 스케줄링</a></li><li>16: <a href=#pg-fdfb2a2cba62a1e624897eaebac0168e>HugePages 관리</a></li><li>17: <a href=#pg-0c4484d31ad3902880897e694bbd306f>kubelet 이미지 자격 증명 공급자 구성하기</a></li><li>18: <a href=#pg-f34d6e348a8e677d6c6eb155cd1a99aa>플러그인으로 kubectl 확장</a></li></ul><div class=content><p>쿠버네티스 문서에서 이 섹션은 개별의 태스크를 수행하는 방법을
보여준다. 한 태스크 페이지는 일반적으로 여러 단계로 이루어진 짧은
시퀀스를 제공함으로써, 하나의 일을 수행하는 방법을 보여준다.</p><p>만약 태스크 페이지를 작성하고 싶다면,
<a href=/ko/docs/contribute/new-content/open-a-pr/>문서 풀 리퀘스트(Pull Request) 생성하기</a>를 참조한다.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-57bf66f59d9a642b82eebeabbc66470b>1 - 도구 설치</h1><div class=lead>컴퓨터에서 쿠버네티스 도구를 설정한다.</div><h2 id=kubectl>kubectl</h2><p>쿠버네티스 커맨드 라인 도구인 <a href=/ko/docs/reference/kubectl/kubectl/><code>kubectl</code></a>을 사용하면
쿠버네티스 클러스터에 대해 명령을 실행할 수 있다.
<code>kubectl</code> 을 사용하여 애플리케이션을 배포하고, 클러스터 리소스를 검사 및 관리하고,
로그를 볼 수 있다. kubectl 전체 명령어를 포함한 추가 정보는
<a href=/ko/docs/reference/kubectl/><code>kubectl</code> 레퍼런스 문서</a>에서 확인할 수 있다.</p><p><code>kubectl</code> 은 다양한 리눅스 플랫폼, macOS, 그리고 윈도우에 설치할 수 있다.
각각에 대한 설치 가이드는 다음과 같다.</p><ul><li><a href=/ko/docs/tasks/tools/install-kubectl-linux/>리눅스에 <code>kubectl</code> 설치하기</a></li><li><a href=/ko/docs/tasks/tools/install-kubectl-macos/>macOS에 <code>kubectl</code> 설치하기</a></li><li><a href=/ko/docs/tasks/tools/install-kubectl-windows/>윈도우에 <code>kubectl</code> 설치하기</a></li></ul><h2 id=kind>kind</h2><p><a href=https://kind.sigs.k8s.io/docs/>kind</a>를 사용하면 로컬 컴퓨터에서
쿠버네티스를 실행할 수 있다. 이 도구를 사용하려면
<a href=https://docs.docker.com/get-docker/>도커</a>를 설치하고 구성해야 한다.</p><p>kind <a href=https://kind.sigs.k8s.io/docs/user/quick-start/>퀵 스타트</a> 페이지는
kind를 시작하고 실행하기 위해 수행해야 하는 작업을 보여준다.</p><p><a class="btn btn-primary" href=https://kind.sigs.k8s.io/docs/user/quick-start/ role=button aria-label="kind 시작하기 가이드 보기">kind 시작하기 가이드 보기</a></p><h2 id=minikube>minikube</h2><p><code>kind</code> 와 마찬가지로, <a href=https://minikube.sigs.k8s.io/><code>minikube</code></a>는 쿠버네티스를 로컬에서 실행할 수 있는
도구이다. <code>minikube</code> 는 개인용 컴퓨터(윈도우, macOS 및 리눅스 PC 포함)에서
단일 노드 쿠버네티스 클러스터를 실행하여 쿠버네티스를 사용해보거나 일상적인 개발 작업을
수행할 수 있다.</p><p>도구 설치에 중점을 두고 있다면 공식 사이트에서의
<a href=https://minikube.sigs.k8s.io/docs/start/>시작하기!</a>
가이드를 따라 해볼 수 있다.</p><p><a class="btn btn-primary" href=https://minikube.sigs.k8s.io/docs/start/ role=button aria-label="minikube 시작하기! 가이드 보기">minikube 시작하기! 가이드 보기</a></p><p><code>minikube</code> 가 작동하면, 이를 사용하여
<a href=/ko/docs/tutorials/hello-minikube/>샘플 애플리케이션을 실행</a>해볼 수 있다.</p><h2 id=kubeadm>kubeadm</h2><p><a class=glossary-tooltip title='쿠버네티스를 빠르게 설치하고 안전한(secure) 클러스터를 설정하는 도구' data-toggle=tooltip data-placement=top href=/docs/admin/kubeadm/ target=_blank aria-label=kubeadm>kubeadm</a> 도구를 사용하여 쿠버네티스 클러스터를 만들고 관리할 수 있다.
사용자 친화적인 방식으로 최소한의 실행 가능하고 안전한 클러스터를 설정하고 실행하는 데 필요한 작업을 수행한다.</p><p><a href=/ko/docs/setup/production-environment/tools/kubeadm/install-kubeadm/>kubeadm 설치</a> 페이지는 kubeadm 설치하는 방법을 보여준다.
설치가 끝나면, <a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>클러스터 생성</a>이 가능하다.</p><p><a class="btn btn-primary" href=/ko/docs/setup/production-environment/tools/kubeadm/install-kubeadm/ role=button aria-label="kubeadm 설치 가이드 보기">kubeadm 설치 가이드 보기</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-961fc70b732cb8df4fd11a3463b6545c>1.1 - macOS에 kubectl 설치 및 설정</h1><h2 id=시작하기-전에>시작하기 전에</h2><p>클러스터의 마이너(minor) 버전 차이 내에 있는 kubectl 버전을 사용해야 한다. 예를 들어, v1.25 클라이언트는 v1.24, v1.25, v1.26의 컨트롤 플레인과 연동될 수 있다.
호환되는 최신 버전의 kubectl을 사용하면 예기치 않은 문제를 피할 수 있다.</p><h2 id=macos에-kubectl-설치>macOS에 kubectl 설치</h2><p>다음과 같은 방법으로 macOS에 kubectl을 설치할 수 있다.</p><ul><li><a href=#install-kubectl-binary-with-curl-on-macos>macOS에서 curl을 사용하여 kubectl 바이너리 설치</a></li><li><a href=#install-with-homebrew-on-macos>macOS에서 Homebrew를 사용하여 설치</a></li><li><a href=#install-with-macports-on-macos>macOS에서 Macports를 사용하여 설치</a></li></ul><h3 id=install-kubectl-binary-with-curl-on-macos>macOS에서 curl을 사용하여 kubectl 바이너리 설치</h3><ol><li><p>최신 릴리스를 다운로드한다.</p><ul class="nav nav-tabs" id=download-binary-macos role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#download-binary-macos-0 role=tab aria-controls=download-binary-macos-0 aria-selected=true>Intel</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#download-binary-macos-1 role=tab aria-controls=download-binary-macos-1>Apple Silicon</a></li></ul><div class=tab-content id=download-binary-macos><div id=download-binary-macos-0 class="tab-pane show active" role=tabpanel aria-labelledby=download-binary-macos-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/amd64/kubectl&#34;</span>
</span></span><span style=display:flex><span>   </span></span></code></pre></div></div><div id=download-binary-macos-1 class=tab-pane role=tabpanel aria-labelledby=download-binary-macos-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/arm64/kubectl&#34;</span>
</span></span><span style=display:flex><span>   </span></span></code></pre></div></div></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>특정 버전을 다운로드하려면, <code>$(curl -L -s https://dl.k8s.io/release/stable.txt)</code> 명령 부분을 특정 버전으로 바꾼다.</p><p>예를 들어, Intel macOS에 버전 v1.25.0을 다운로드하려면, 다음을 입력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/v1.25.0/bin/darwin/amd64/kubectl&#34;</span>
</span></span></code></pre></div><p>Apple Silicon의 macOS라면, 다음을 입력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/v1.25.0/bin/darwin/arm64/kubectl&#34;</span>
</span></span></code></pre></div></div></li><li><p>바이너리를 검증한다. (선택 사항)</p><p>kubectl 체크섬 파일을 다운로드한다.</p><ul class="nav nav-tabs" id=download-checksum-macos role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#download-checksum-macos-0 role=tab aria-controls=download-checksum-macos-0 aria-selected=true>Intel</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#download-checksum-macos-1 role=tab aria-controls=download-checksum-macos-1>Apple Silicon</a></li></ul><div class=tab-content id=download-checksum-macos><div id=download-checksum-macos-0 class="tab-pane show active" role=tabpanel aria-labelledby=download-checksum-macos-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/amd64/kubectl.sha256&#34;</span>
</span></span><span style=display:flex><span>   </span></span></code></pre></div></div><div id=download-checksum-macos-1 class=tab-pane role=tabpanel aria-labelledby=download-checksum-macos-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/arm64/kubectl.sha256&#34;</span>
</span></span><span style=display:flex><span>   </span></span></code></pre></div></div></div><p>kubectl 바이너리를 체크섬 파일을 통해 검증한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>cat kubectl.sha256<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>  kubectl&#34;</span> | shasum -a <span style=color:#666>256</span> --check
</span></span></code></pre></div><p>검증이 성공한다면, 출력은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl: OK
</span></span></code></pre></div><p>검증이 실패한다면, <code>shasum</code>이 0이 아닌 상태로 종료되며 다음과 유사한 결과를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl: FAILED
</span></span><span style=display:flex><span>shasum: WARNING: <span style=color:#666>1</span> computed checksum did NOT match
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 동일한 버전의 바이너리와 체크섬을 다운로드한다.</div></li><li><p>kubectl 바이너리를 실행 가능하게 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chmod +x ./kubectl
</span></span></code></pre></div></li><li><p>kubectl 바이너리를 시스템 <code>PATH</code> 의 파일 위치로 옮긴다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo mv ./kubectl /usr/local/bin/kubectl
</span></span><span style=display:flex><span>sudo chown root: /usr/local/bin/kubectl
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>PATH</code> 환경 변수 안에 <code>/usr/local/bin</code> 이 있는지 확인한다.</div></li><li><p>설치한 버전이 최신 버전인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div><p>또는 다음을 실행하여 버전에 대한 더 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>kubectl version --client --output=yaml    
</span></span></code></pre></div></li></ol><h3 id=install-with-homebrew-on-macos>macOS에서 Homebrew를 사용하여 설치</h3><p>macOS에서 <a href=https://brew.sh/>Homebrew</a> 패키지 관리자를 사용하는 경우, Homebrew로 kubectl을 설치할 수 있다.</p><ol><li><p>설치 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>brew install kubectl
</span></span></code></pre></div><p>또는</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>brew install kubernetes-cli
</span></span></code></pre></div></li><li><p>설치한 버전이 최신 버전인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div></li></ol><h3 id=install-with-macports-on-macos>macOS에서 Macports를 사용하여 설치</h3><p>macOS에서 <a href=https://macports.org/>Macports</a> 패키지 관리자를 사용하는 경우, Macports로 kubectl을 설치할 수 있다.</p><ol><li><p>설치 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo port selfupdate
</span></span><span style=display:flex><span>sudo port install kubectl
</span></span></code></pre></div></li><li><p>설치한 버전이 최신 버전인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div></li></ol><h2 id=kubectl-구성-확인>kubectl 구성 확인</h2><p>kubectl이 쿠버네티스 클러스터를 찾아 접근하려면,
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a>를
사용하여 클러스터를 생성하거나 Minikube 클러스터를 성공적으로 배포할 때 자동으로 생성되는
<a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>이
필요하다.
기본적으로, kubectl 구성은 <code>~/.kube/config</code> 에 있다.</p><p>클러스터 상태를 가져와서 kubectl이 올바르게 구성되어 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><p>URL 응답이 표시되면, kubectl이 클러스터에 접근하도록 올바르게 구성된 것이다.</p><p>다음과 비슷한 메시지가 표시되면, kubectl이 올바르게 구성되지 않았거나 쿠버네티스 클러스터에 연결할 수 없다.</p><pre tabindex=0><code>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
</code></pre><p>예를 들어, 랩톱에서 로컬로 쿠버네티스 클러스터를 실행하려면, Minikube와 같은 도구를 먼저 설치한 다음 위에서 언급한 명령을 다시 실행해야 한다.</p><p>kubectl cluster-info가 URL 응답을 반환하지만 클러스터에 접근할 수 없는 경우, 올바르게 구성되었는지 확인하려면 다음을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info dump
</span></span></code></pre></div><h2 id=선택적-kubectl-구성-및-플러그인>선택적 kubectl 구성 및 플러그인</h2><h3 id=셸-자동-완성-활성화>셸 자동 완성 활성화</h3><p>kubectl은 Bash, Zsh, Fish, 및 PowerShell에 대한 자동 완성 지원을 제공하므로 입력을 위한 타이핑을 많이 절약할 수 있다.</p><p>다음은 Bash, Fish, 및 Zsh에 대한 자동 완성을 설정하는 절차이다.</p><ul class="nav nav-tabs" id=kubectl-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-autocompletion-0 role=tab aria-controls=kubectl-autocompletion-0 aria-selected=true>Bash</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-1 role=tab aria-controls=kubectl-autocompletion-1>Fish</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-2 role=tab aria-controls=kubectl-autocompletion-2>Zsh</a></li></ul><div class=tab-content id=kubectl-autocompletion><div id=kubectl-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-autocompletion-0><p><h3 id=소개>소개</h3><p>Bash의 kubectl 자동 완성 스크립트는 <code>kubectl completion bash</code> 로 생성할 수 있다. 이 스크립트를 셸에 소싱하면 kubectl 자동 완성이 가능하다.</p><p>그러나 kubectl 자동 완성 스크립트는 미리 <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>을 설치해야 동작한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> bash-completion에는 v1과 v2 두 가지 버전이 있다. v1은 Bash 3.2(macOS의 기본 설치 버전) 버전용이고, v2는 Bash 4.1 이상 버전용이다. kubectl 자동 완성 스크립트는 bash-completion v1과 Bash 3.2 버전에서는 <strong>작동하지 않는다</strong>. <strong>bash-completion v2</strong> 와 <strong>Bash 4.1 이상 버전</strong> 이 필요하다. 따라서, macOS에서 kubectl 자동 완성 기능을 올바르게 사용하려면, Bash 4.1 이상을 설치하고 사용해야 한다(<a href=https://itnext.io/upgrading-bash-on-macos-7138bd1066ba><em>지침</em></a>). 다음의 내용에서는 Bash 4.1 이상(즉, 모든 Bash 버전 4.1 이상)을 사용한다고 가정한다.</div><h3 id=bash-업그레이드>Bash 업그레이드</h3><p>여기의 지침에서는 Bash 4.1 이상을 사용한다고 가정한다. 다음을 실행하여 Bash 버전을 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span>
</span></span></code></pre></div><p>너무 오래된 버전인 경우, Homebrew를 사용하여 설치/업그레이드할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>brew install bash
</span></span></code></pre></div><p>셸을 다시 로드하고 원하는 버전을 사용 중인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span> <span style=color:#b8860b>$SHELL</span>
</span></span></code></pre></div><p>Homebrew는 보통 <code>/usr/local/bin/bash</code> 에 설치한다.</p><h3 id=bash-completion-설치>bash-completion 설치</h3><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 언급한 바와 같이, 이 지침에서는 Bash 4.1 이상을 사용한다고 가정한다. 이는 bash-completion v2를 설치한다는 것을 의미한다(Bash 3.2 및 bash-completion v1의 경우, kubectl 자동 완성이 작동하지 않음).</div><p>bash-completion v2가 이미 설치되어 있는지 <code>type_init_completion</code> 으로 확인할 수 있다. 그렇지 않은 경우, Homebrew로 설치할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>brew install bash-completion@2
</span></span></code></pre></div><p>이 명령의 출력에 명시된 바와 같이, <code>~/.bash_profile</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>BASH_COMPLETION_COMPAT_DIR</span><span style=color:#666>=</span><span style=color:#b44>&#34;/usr/local/etc/bash_completion.d&#34;</span>
</span></span><span style=display:flex><span><span style=color:#666>[[</span> -r <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span> <span style=color:#666>]]</span> <span style=color:#666>&amp;&amp;</span> . <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span>
</span></span></code></pre></div><p>셸을 다시 로드하고 bash-completion v2가 올바르게 설치되었는지 <code>type _init_completion</code> 으로 확인한다.</p><h3 id=kubectl-자동-완성-활성화>kubectl 자동 완성 활성화</h3><p>이제 kubectl 자동 완성 스크립트가 모든 셸 세션에서 제공되도록 해야 한다. 이를 수행하는 방법에는 여러 가지가 있다.</p><ul><li><p>자동 완성 스크립트를 <code>~/.bash_profile</code> 파일에서 소싱한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bash_profile
</span></span></code></pre></div></li><li><p>자동 완성 스크립트를 <code>/usr/local/etc/bash_completion.d</code> 디렉터리에 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl completion bash &gt;/usr/local/etc/bash_completion.d/kubectl
</span></span></code></pre></div></li><li><p>kubectl에 대한 앨리어스가 있는 경우, 해당 앨리어스로 작업하기 위해 셸 자동 완성을 확장할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bash_profile
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -o default -F __start_kubectl k&#39;</span> &gt;&gt;~/.bash_profile
</span></span></code></pre></div></li><li><p>Homebrew로 kubectl을 설치한 경우(<a href=/ko/docs/tasks/tools/install-kubectl-macos/#install-with-homebrew-on-macos>여기</a>의 설명을 참고), kubectl 자동 완성 스크립트가 이미 <code>/usr/local/etc/bash_completion.d/kubectl</code> 에 있을 것이다. 이 경우, 아무 것도 할 필요가 없다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> bash-completion v2의 Homebrew 설치는 <code>BASH_COMPLETION_COMPAT_DIR</code> 디렉터리의 모든 파일을 소싱하므로, 후자의 두 가지 방법이 적용된다.</div></li></ul><p>어떤 경우든, 셸을 다시 로드하면, kubectl 자동 완성 기능이 작동할 것이다.</p></div><div id=kubectl-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-1><p><p>Fish용 kubectl 자동 완성 스크립트는 <code>kubectl completion fish</code> 명령으로 생성할 수 있다. 셸에서 자동 완성 스크립트를 소싱하면 kubectl 자동 완성 기능이 활성화된다.</p><p>모든 셸 세션에서 사용하려면, <code>~/.config/fish/config.fish</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl completion fish | <span style=color:#a2f>source</span>
</span></span></code></pre></div><p>셸을 다시 로드하면, kubectl 자동 완성 기능이 작동할 것이다.</p></div><div id=kubectl-autocompletion-2 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-2><p><p>Zsh용 kubectl 자동 완성 스크립트는 <code>kubectl completion zsh</code> 명령으로 생성할 수 있다. 셸에서 자동 완성 스크립트를 소싱하면 kubectl 자동 완성 기능이 활성화된다.</p><p>모든 셸 세션에서 사용하려면, <code>~/.zshrc</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>
</span></span></code></pre></div><p>kubectl에 대한 앨리어스가 있는 경우, kubectl 자동완성이 자동으로 동작할 것이다.</p><p>셸을 다시 로드하면, kubectl 자동 완성 기능이 작동할 것이다.</p><p><code>2: command not found: compdef</code> 와 같은 오류가 발생하면, <code>~/.zshrc</code> 파일의 시작 부분에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>autoload -Uz compinit
</span></span><span style=display:flex><span>compinit
</span></span></code></pre></div></div></div><h3 id=kubectl-convert-플러그인-설치><code>kubectl convert</code> 플러그인 설치</h3><p>이것은 쿠버네티스 커맨드 라인 도구인 <code>kubectl</code>의 플러그인으로서, 특정 버전의 쿠버네티스 API로 작성된 매니페스트를 다른 버전으로
변환할 수 있도록 한다. 이것은 매니페스트를 최신 쿠버네티스 릴리스의 사용 중단되지 않은 API로 마이그레이션하는 데 특히 유용하다.
더 많은 정보는 다음의 <a href=/docs/reference/using-api/deprecation-guide/#migrate-to-non-deprecated-apis>사용 중단되지 않은 API로 마이그레이션</a>을 참고한다.</p><ol><li><p>다음 명령으로 최신 릴리스를 다운로드한다.</p><ul class="nav nav-tabs" id=download-convert-binary-macos role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#download-convert-binary-macos-0 role=tab aria-controls=download-convert-binary-macos-0 aria-selected=true>Intel</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#download-convert-binary-macos-1 role=tab aria-controls=download-convert-binary-macos-1>Apple Silicon</a></li></ul><div class=tab-content id=download-convert-binary-macos><div id=download-convert-binary-macos-0 class="tab-pane show active" role=tabpanel aria-labelledby=download-convert-binary-macos-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/amd64/kubectl-convert&#34;</span>
</span></span><span style=display:flex><span>   </span></span></code></pre></div></div><div id=download-convert-binary-macos-1 class=tab-pane role=tabpanel aria-labelledby=download-convert-binary-macos-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/arm64/kubectl-convert&#34;</span>
</span></span><span style=display:flex><span>   </span></span></code></pre></div></div></div></li><li><p>바이너리를 검증한다. (선택 사항)</p><p>kubectl-convert 체크섬(checksum) 파일을 다운로드한다.</p><ul class="nav nav-tabs" id=download-convert-checksum-macos role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#download-convert-checksum-macos-0 role=tab aria-controls=download-convert-checksum-macos-0 aria-selected=true>Intel</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#download-convert-checksum-macos-1 role=tab aria-controls=download-convert-checksum-macos-1>Apple Silicon</a></li></ul><div class=tab-content id=download-convert-checksum-macos><div id=download-convert-checksum-macos-0 class="tab-pane show active" role=tabpanel aria-labelledby=download-convert-checksum-macos-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/amd64/kubectl-convert.sha256&#34;</span>
</span></span><span style=display:flex><span>   </span></span></code></pre></div></div><div id=download-convert-checksum-macos-1 class=tab-pane role=tabpanel aria-labelledby=download-convert-checksum-macos-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>   curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/arm64/kubectl-convert.sha256&#34;</span>
</span></span><span style=display:flex><span>   </span></span></code></pre></div></div></div><p>kubectl-convert 바이너리를 체크섬 파일을 통해 검증한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>cat kubectl-convert.sha256<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>  kubectl-convert&#34;</span> | shasum -a <span style=color:#666>256</span> --check
</span></span></code></pre></div><p>검증이 성공한다면, 출력은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl-convert: OK
</span></span></span></code></pre></div><p>검증이 실패한다면, <code>shasum</code>이 0이 아닌 상태로 종료되며 다음과 유사한 결과를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl-convert: FAILED
</span></span><span style=display:flex><span>shasum: WARNING: <span style=color:#666>1</span> computed checksum did NOT match
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 동일한 버전의 바이너리와 체크섬을 다운로드한다.</div></li><li><p>kubectl-convert 바이너리를 실행 가능하게 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chmod +x ./kubectl-convert
</span></span></code></pre></div></li><li><p>kubectl-convert 바이너리를 시스템 <code>PATH</code> 의 파일 위치로 옮긴다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo mv ./kubectl-convert /usr/local/bin/kubectl-convert
</span></span><span style=display:flex><span>sudo chown root: /usr/local/bin/kubectl-convert
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>PATH</code> 환경 변수 안에 <code>/usr/local/bin</code> 이 있는지 확인한다.</div></li><li><p>플러그인이 정상적으로 설치되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl convert --help
</span></span></code></pre></div><p>에러가 출력되지 않는다면, 플러그인이 정상적으로 설치된 것이다.</p></li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><a href=https://minikube.sigs.k8s.io/docs/start/>Minikube 설치</a></li><li>클러스터 생성에 대한 자세한 내용은 <a href=/ko/docs/setup/>시작하기</a>를 참고한다.</li><li><a href=/ko/docs/tasks/access-application-cluster/service-access-application-cluster/>애플리케이션을 시작하고 노출하는 방법에 대해 배운다.</a></li><li>직접 생성하지 않은 클러스터에 접근해야 하는 경우,
<a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>클러스터 접근 공유 문서</a>를 참고한다.</li><li><a href=/ko/docs/reference/kubectl/kubectl/>kubectl 레퍼런스 문서</a> 읽기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-37b6179f23c8ad977cb9daa6d2da748a>1.2 - 리눅스에 kubectl 설치 및 설정</h1><h2 id=시작하기-전에>시작하기 전에</h2><p>클러스터의 마이너(minor) 버전 차이 내에 있는 kubectl 버전을 사용해야 한다. 예를 들어, v1.25 클라이언트는 v1.24, v1.25, v1.26의 컨트롤 플레인과 연동될 수 있다.
호환되는 최신 버전의 kubectl을 사용하면 예기치 않은 문제를 피할 수 있다.</p><h2 id=리눅스에-kubectl-설치>리눅스에 kubectl 설치</h2><p>다음과 같은 방법으로 리눅스에 kubectl을 설치할 수 있다.</p><ul><li><a href=#install-kubectl-binary-with-curl-on-linux>리눅스에 curl을 사용하여 kubectl 바이너리 설치</a></li><li><a href=#install-using-native-package-management>기본 패키지 관리 도구를 사용하여 설치</a></li><li><a href=#install-using-other-package-management>다른 패키지 관리 도구를 사용하여 설치</a></li></ul><h3 id=install-kubectl-binary-with-curl-on-linux>리눅스에서 curl을 사용하여 kubectl 바이너리 설치</h3><ol><li><p>다음 명령으로 최신 릴리스를 다운로드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/linux/amd64/kubectl&#34;</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>특정 버전을 다운로드하려면, <code>$(curl -L -s https://dl.k8s.io/release/stable.txt)</code> 명령 부분을 특정 버전으로 바꾼다.</p><p>예를 들어, 리눅스에서 버전 v1.25.0을 다운로드하려면, 다음을 입력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -LO https://dl.k8s.io/release/v1.25.0/bin/linux/amd64/kubectl
</span></span></code></pre></div></div></li><li><p>바이너리를 검증한다. (선택 사항)</p><p>kubectl 체크섬(checksum) 파일을 다운로드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/linux/amd64/kubectl.sha256&#34;</span>
</span></span></code></pre></div><p>kubectl 바이너리를 체크섬 파일을 통해 검증한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>cat kubectl.sha256<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>  kubectl&#34;</span> | sha256sum --check
</span></span></code></pre></div><p>검증이 성공한다면, 출력은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl: OK
</span></span></code></pre></div><p>검증이 실패한다면, <code>shasum</code>이 0이 아닌 상태로 종료되며 다음과 유사한 결과를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl: FAILED
</span></span><span style=display:flex><span>sha256sum: WARNING: <span style=color:#666>1</span> computed checksum did NOT match
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 동일한 버전의 바이너리와 체크섬을 다운로드한다.</div></li><li><p>kubectl 설치</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo install -o root -g root -m <span style=color:#666>0755</span> kubectl /usr/local/bin/kubectl
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>대상 시스템에 root 접근 권한을 가지고 있지 않더라도, <code>~/.local/bin</code> 디렉터리에 kubectl을 설치할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chmod +x kubectl
</span></span><span style=display:flex><span>mkdir -p ~/.local/bin
</span></span><span style=display:flex><span>mv ./kubectl ~/.local/bin/kubectl
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 그리고 ~/.local/bin 을 $PATH의 앞부분 또는 뒷부분에 추가</span>
</span></span></code></pre></div></div></li><li><p>설치한 버전이 최신인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div><p>또는 다음을 실행하여 버전에 대한 더 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>kubectl version --client --output=yaml    
</span></span></code></pre></div></li></ol><h3 id=install-using-native-package-management>기본 패키지 관리 도구를 사용하여 설치</h3><ul class="nav nav-tabs" id=kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-install-0 role=tab aria-controls=kubectl-install-0 aria-selected=true>데비안 기반의 배포판</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-install-1 role=tab aria-controls=kubectl-install-1>레드햇 기반의 배포판</a></li></ul><div class=tab-content id=kubectl-install><div id=kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-install-0><p><ol><li><p><code>apt</code> 패키지 색인을 업데이트하고 쿠버네티스 <code>apt</code> 리포지터리를 사용하는 데 필요한 패키지들을 설치한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y apt-transport-https ca-certificates curl
</span></span></code></pre></div><p>Debian 9(stretch) 또는 그 이전 버전을 사용하는 경우 <code>apt-transport-https</code>도 설치해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get install -y apt-transport-https
</span></span></code></pre></div></li><li><p>구글 클라우드 공개 사이닝 키를 다운로드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
</span></span></code></pre></div></li><li><p>쿠버네티스 <code>apt</code> 리포지터리를 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&#34;</span> | sudo tee /etc/apt/sources.list.d/kubernetes.list
</span></span></code></pre></div></li><li><p>새 리포지터리의 <code>apt</code> 패키지 색인을 업데이트하고 kubectl을 설치한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y kubectl
</span></span></code></pre></div></li></ol></div><div id=kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-install-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
</span></span></span><span style=display:flex><span><span style=color:#b44>[kubernetes]
</span></span></span><span style=display:flex><span><span style=color:#b44>name=Kubernetes
</span></span></span><span style=display:flex><span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch
</span></span></span><span style=display:flex><span><span style=color:#b44>enabled=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>sudo yum install -y kubectl
</span></span></code></pre></div></div></div><h3 id=install-using-other-package-management>다른 패키지 관리 도구를 사용하여 설치</h3><ul class="nav nav-tabs" id=other-kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#other-kubectl-install-0 role=tab aria-controls=other-kubectl-install-0 aria-selected=true>Snap</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#other-kubectl-install-1 role=tab aria-controls=other-kubectl-install-1>Homebrew</a></li></ul><div class=tab-content id=other-kubectl-install><div id=other-kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=other-kubectl-install-0><p><p><a href=https://snapcraft.io/docs/core/install>snap</a> 패키지 관리자를 지원하는 Ubuntu 또는 다른 리눅스 배포판을 사용하는 경우, kubectl을 <a href=https://snapcraft.io/>snap</a> 애플리케이션으로 설치할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>snap install kubectl --classic
</span></span><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div></div><div id=other-kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=other-kubectl-install-1><p><p>리눅스 상에서 <a href=https://docs.brew.sh/Homebrew-on-Linux>Homebrew</a> 패키지 관리자를 사용한다면, <a href=https://docs.brew.sh/Homebrew-on-Linux#install>설치</a>를 통해 kubectl을 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew install kubectl
</span></span><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div></div></div><h2 id=kubectl-구성-확인>kubectl 구성 확인</h2><p>kubectl이 쿠버네티스 클러스터를 찾아 접근하려면,
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a>를
사용하여 클러스터를 생성하거나 Minikube 클러스터를 성공적으로 배포할 때 자동으로 생성되는
<a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>이
필요하다.
기본적으로, kubectl 구성은 <code>~/.kube/config</code> 에 있다.</p><p>클러스터 상태를 가져와서 kubectl이 올바르게 구성되어 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><p>URL 응답이 표시되면, kubectl이 클러스터에 접근하도록 올바르게 구성된 것이다.</p><p>다음과 비슷한 메시지가 표시되면, kubectl이 올바르게 구성되지 않았거나 쿠버네티스 클러스터에 연결할 수 없다.</p><pre tabindex=0><code>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
</code></pre><p>예를 들어, 랩톱에서 로컬로 쿠버네티스 클러스터를 실행하려면, Minikube와 같은 도구를 먼저 설치한 다음 위에서 언급한 명령을 다시 실행해야 한다.</p><p>kubectl cluster-info가 URL 응답을 반환하지만 클러스터에 접근할 수 없는 경우, 올바르게 구성되었는지 확인하려면 다음을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info dump
</span></span></code></pre></div><h2 id=선택적-kubectl-구성-및-플러그인>선택적 kubectl 구성 및 플러그인</h2><h3 id=셸-자동-완성-활성화>셸 자동 완성 활성화</h3><p>kubectl은 Bash, Zsh, Fish, 및 PowerShell에 대한 자동 완성 지원을 제공하므로 입력을 위한 타이핑을 많이 절약할 수 있다.</p><p>다음은 Bash, Fish, 및 Zsh에 대한 자동 완성을 설정하는 절차이다.</p><ul class="nav nav-tabs" id=kubectl-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-autocompletion-0 role=tab aria-controls=kubectl-autocompletion-0 aria-selected=true>Bash</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-1 role=tab aria-controls=kubectl-autocompletion-1>Fish</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-2 role=tab aria-controls=kubectl-autocompletion-2>Zsh</a></li></ul><div class=tab-content id=kubectl-autocompletion><div id=kubectl-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-autocompletion-0><p><h3 id=소개>소개</h3><p>Bash의 kubectl 자동 완성 스크립트는 <code>kubectl completion bash</code> 명령으로 생성할 수 있다. 셸에서 자동 완성 스크립트를 소싱(sourcing)하면 kubectl 자동 완성 기능이 활성화된다.</p><p>그러나, 자동 완성 스크립트는 <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>에 의존하고 있으며, 이 소프트웨어를 먼저 설치해야 한다(<code>type _init_completion</code> 을 실행하여 bash-completion이 이미 설치되어 있는지 확인할 수 있음).</p><h3 id=bash-completion-설치>bash-completion 설치</h3><p>bash-completion은 많은 패키지 관리자에 의해 제공된다(<a href=https://github.com/scop/bash-completion#installation>여기</a> 참고). <code>apt-get install bash-completion</code> 또는 <code>yum install bash-completion</code> 등으로 설치할 수 있다.</p><p>위의 명령은 bash-completion의 기본 스크립트인 <code>/usr/share/bash-completion/bash_completion</code> 을 생성한다. 패키지 관리자에 따라, <code>~/.bashrc</code> 파일에서 이 파일을 수동으로 소스(source)해야 한다.</p><p>확인하려면, 셸을 다시 로드하고 <code>type _init_completion</code> 을 실행한다. 명령이 성공하면, 이미 설정된 상태이고, 그렇지 않으면 <code>~/.bashrc</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> /usr/share/bash-completion/bash_completion
</span></span></code></pre></div><p>셸을 다시 로드하고 <code>type _init_completion</code> 을 입력하여 bash-completion이 올바르게 설치되었는지 확인한다.</p><h3 id=kubectl-자동-완성-활성화>kubectl 자동 완성 활성화</h3><h4 id=bash>Bash</h4><p>이제 kubectl 자동 완성 스크립트가 모든 셸 세션에서 제공되도록 해야 한다. 이를 수행할 수 있는 두 가지 방법이 있다.</p><ul class="nav nav-tabs" id=kubectl-bash-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-bash-autocompletion-0 role=tab aria-controls=kubectl-bash-autocompletion-0 aria-selected=true>현재 사용자에만 적용</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-bash-autocompletion-1 role=tab aria-controls=kubectl-bash-autocompletion-1>시스템 전체에 적용</a></li></ul><div class=tab-content id=kubectl-bash-autocompletion><div id=kubectl-bash-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-bash-autocompletion-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div></div><div id=kubectl-bash-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-bash-autocompletion-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl &gt; /dev/null
</span></span></code></pre></div></div></div><p>kubectl에 대한 앨리어스(alias)가 있는 경우, 해당 앨리어스로 작업하도록 셸 자동 완성을 확장할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bashrc
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -o default -F __start_kubectl k&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> bash-completion은 <code>/etc/bash_completion.d</code> 에 있는 모든 자동 완성 스크립트를 소싱한다.</div><p>두 방법 모두 동일하다. 셸을 다시 로드하면, kubectl 자동 완성 기능이 작동할 것이다.
셸의 현재 세션에서 bash 자동 완성을 활성화하려면 <code>exec bash</code>를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>exec</span> bash
</span></span></code></pre></div></div><div id=kubectl-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-1><p><p>Fish용 kubectl 자동 완성 스크립트는 <code>kubectl completion fish</code> 명령으로 생성할 수 있다. 셸에서 자동 완성 스크립트를 소싱하면 kubectl 자동 완성 기능이 활성화된다.</p><p>모든 셸 세션에서 사용하려면, <code>~/.config/fish/config.fish</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl completion fish | <span style=color:#a2f>source</span>
</span></span></code></pre></div><p>셸을 다시 로드하면, kubectl 자동 완성 기능이 작동할 것이다.</p></div><div id=kubectl-autocompletion-2 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-2><p><p>Zsh용 kubectl 자동 완성 스크립트는 <code>kubectl completion zsh</code> 명령으로 생성할 수 있다. 셸에서 자동 완성 스크립트를 소싱하면 kubectl 자동 완성 기능이 활성화된다.</p><p>모든 셸 세션에서 사용하려면, <code>~/.zshrc</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>
</span></span></code></pre></div><p>kubectl에 대한 앨리어스가 있는 경우, kubectl 자동완성이 자동으로 동작할 것이다.</p><p>셸을 다시 로드하면, kubectl 자동 완성 기능이 작동할 것이다.</p><p><code>2: command not found: compdef</code> 와 같은 오류가 발생하면, <code>~/.zshrc</code> 파일의 시작 부분에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>autoload -Uz compinit
</span></span><span style=display:flex><span>compinit
</span></span></code></pre></div></div></div><h3 id=kubectl-convert-플러그인-설치><code>kubectl convert</code> 플러그인 설치</h3><p>이것은 쿠버네티스 커맨드 라인 도구인 <code>kubectl</code>의 플러그인으로서, 특정 버전의 쿠버네티스 API로 작성된 매니페스트를 다른 버전으로
변환할 수 있도록 한다. 이것은 매니페스트를 최신 쿠버네티스 릴리스의 사용 중단되지 않은 API로 마이그레이션하는 데 특히 유용하다.
더 많은 정보는 다음의 <a href=/docs/reference/using-api/deprecation-guide/#migrate-to-non-deprecated-apis>사용 중단되지 않은 API로 마이그레이션</a>을 참고한다.</p><ol><li><p>다음 명령으로 최신 릴리스를 다운로드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/linux/amd64/kubectl-convert&#34;</span>
</span></span></code></pre></div></li><li><p>바이너리를 검증한다. (선택 사항)</p><p>kubectl-convert 체크섬(checksum) 파일을 다운로드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -LO <span style=color:#b44>&#34;https://dl.k8s.io/</span><span style=color:#a2f;font-weight:700>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/linux/amd64/kubectl-convert.sha256&#34;</span>
</span></span></code></pre></div><p>kubectl-convert 바이너리를 체크섬 파일을 통해 검증한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>cat kubectl-convert.sha256<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44> kubectl-convert&#34;</span> | sha256sum --check
</span></span></code></pre></div><p>검증이 성공한다면, 출력은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl-convert: OK
</span></span></span></code></pre></div><p>검증이 실패한다면, <code>sha256</code>이 0이 아닌 상태로 종료되며 다음과 유사한 결과를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl-convert: FAILED
</span></span><span style=display:flex><span>sha256sum: WARNING: <span style=color:#666>1</span> computed checksum did NOT match
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 동일한 버전의 바이너리와 체크섬을 다운로드한다.</div></li><li><p>kubectl-convert 설치</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo install -o root -g root -m <span style=color:#666>0755</span> kubectl-convert /usr/local/bin/kubectl-convert
</span></span></code></pre></div></li><li><p>플러그인이 정상적으로 설치되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl convert --help
</span></span></code></pre></div><p>에러가 출력되지 않는다면, 플러그인이 정상적으로 설치된 것이다.</p></li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><a href=https://minikube.sigs.k8s.io/docs/start/>Minikube 설치</a></li><li>클러스터 생성에 대한 자세한 내용은 <a href=/ko/docs/setup/>시작하기</a>를 참고한다.</li><li><a href=/ko/docs/tasks/access-application-cluster/service-access-application-cluster/>애플리케이션을 시작하고 노출하는 방법에 대해 배운다.</a></li><li>직접 생성하지 않은 클러스터에 접근해야 하는 경우,
<a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>클러스터 접근 공유 문서</a>를 참고한다.</li><li><a href=/ko/docs/reference/kubectl/kubectl/>kubectl 레퍼런스 문서</a> 읽기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2cc93d3011d707aeb6564bab02048f7a>1.3 - 윈도우에 kubectl 설치 및 설정</h1><h2 id=시작하기-전에>시작하기 전에</h2><p>클러스터의 마이너(minor) 버전 차이 내에 있는 kubectl 버전을 사용해야 한다. 예를 들어, v1.25 클라이언트는 v1.24, v1.25, v1.26의 컨트롤 플레인과 연동될 수 있다.
호환되는 최신 버전의 kubectl을 사용하면 예기치 않은 문제를 피할 수 있다.</p><h2 id=윈도우에-kubectl-설치>윈도우에 kubectl 설치</h2><p>다음과 같은 방법으로 윈도우에 kubectl을 설치할 수 있다.</p><ul><li><a href=#install-kubectl-binary-with-curl-on-windows>윈도우에서 curl을 사용하여 kubectl 바이너리 설치</a></li><li><a href=#install-on-windows-using-chocolatey-or-scoop>Chocolatey 또는 Scoop을 사용하여 윈도우에 설치</a></li></ul><h3 id=install-kubectl-binary-with-curl-on-windows>윈도우에서 curl을 사용하여 kubectl 바이너리 설치</h3><ol><li><p><a href=https://dl.k8s.io/release/v1.25.0/bin/windows/amd64/kubectl.exe>최신 릴리스 v1.25.0</a>를 다운로드한다.</p><p>또는 <code>curl</code> 을 설치한 경우, 다음 명령을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>curl </span>-LO <span style=color:#b44>&#34;https://dl.k8s.io/release/v1.25.0/bin/windows/amd64/kubectl.exe&#34;</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 최신의 안정 버전(예: 스크립팅을 위한)을 찾으려면, <a href=https://dl.k8s.io/release/stable.txt>https://dl.k8s.io/release/stable.txt</a>를 참고한다.</div></li><li><p>바이너리를 검증한다. (선택 사항)</p><p><code>kubectl</code> 체크섬 파일을 다운로드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>curl </span>-LO <span style=color:#b44>&#34;https://dl.k8s.io/v1.25.0/bin/windows/amd64/kubectl.exe.sha256&#34;</span>
</span></span></code></pre></div><p><code>kubectl</code> 바이너리를 체크섬 파일을 통해 검증한다.</p><ul><li><p>커맨드 프롬프트를 사용하는 경우, <code>CertUtil</code> 의 출력과 다운로드한 체크섬 파일을 수동으로 비교한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>CertUtil -hashfile kubectl.exe SHA256
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> kubectl.exe.sha256
</span></span></code></pre></div></li><li><p>PowerShell을 사용하는 경우, <code>-eq</code> 연산자를 통해 <code>True</code> 또는 <code>False</code> 결과가 출력되는 자동 검증을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$($(CertUtil -hashfile .\kubectl.exe SHA256)[<span style=color:#666>1</span>] <span style=color:#666>-replace</span> <span style=color:#b44>&#34; &#34;</span>, <span style=color:#b44>&#34;&#34;</span>) <span style=color:#666>-eq</span> $(<span style=color:#a2f>type </span>.\kubectl.exe.sha256)
</span></span></code></pre></div></li></ul></li><li><p><code>kubectl</code> 바이너리가 있는 폴더를 <code>PATH</code> 환경 변수의 앞부분 또는 뒷부분에 추가</p></li><li><p><code>kubectl</code> 의 버전이 다운로드한 버전과 같은지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div><p>또는 다음을 실행하여 버전에 대한 더 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>kubectl version --client --output=yaml    
</span></span></code></pre></div></li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <a href=https://docs.docker.com/docker-for-windows/#kubernetes>윈도우용 도커 데스크톱</a>은 자체 버전의 <code>kubectl</code> 을 <code>PATH</code> 에 추가한다.
도커 데스크톱을 이전에 설치한 경우, 도커 데스크톱 설치 프로그램에서 추가한 <code>PATH</code> 항목 앞에 <code>PATH</code> 항목을 배치하거나 도커 데스크톱의 <code>kubectl</code> 을 제거해야 할 수도 있다.</div><h3 id=install-on-windows-using-chocolatey-or-scoop>Chocolatey 또는 Scoop을 사용하여 윈도우에 설치</h3><ol><li><p>윈도우에 kubectl을 설치하기 위해서 <a href=https://chocolatey.org>Chocolatey</a> 패키지 관리자나 <a href=https://scoop.sh>Scoop</a> 커맨드 라인 설치 프로그램을 사용할 수 있다.</p><ul class="nav nav-tabs" id=kubectl-win-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-win-install-0 role=tab aria-controls=kubectl-win-install-0 aria-selected=true>choco</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-win-install-1 role=tab aria-controls=kubectl-win-install-1>scoop</a></li></ul><div class=tab-content id=kubectl-win-install><div id=kubectl-win-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-win-install-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span> choco install <span style=color:#a2f>kubernetes-cli</span>
</span></span></code></pre></div></div><div id=kubectl-win-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-win-install-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span> scoop install kubectl
</span></span></code></pre></div></div></div></li><li><p>설치한 버전이 최신 버전인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div></li><li><p>홈 디렉터리로 이동한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#080;font-style:italic># cmd.exe를 사용한다면, 다음을 실행한다. cd %USERPROFILE%</span>
</span></span><span style=display:flex><span><span style=color:#a2f>cd </span>~
</span></span></code></pre></div></li><li><p><code>.kube</code> 디렉터리를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>mkdir .kube
</span></span></code></pre></div></li><li><p>금방 생성한 <code>.kube</code> 디렉터리로 이동한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>cd </span>.kube
</span></span></code></pre></div></li><li><p>원격 쿠버네티스 클러스터를 사용하도록 kubectl을 구성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>New-Item</span> config -type file
</span></span></code></pre></div></li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 메모장과 같은 텍스트 편집기를 선택하여 구성 파일을 편집한다.</div><h2 id=kubectl-구성-확인>kubectl 구성 확인</h2><p>kubectl이 쿠버네티스 클러스터를 찾아 접근하려면,
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a>를
사용하여 클러스터를 생성하거나 Minikube 클러스터를 성공적으로 배포할 때 자동으로 생성되는
<a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>이
필요하다.
기본적으로, kubectl 구성은 <code>~/.kube/config</code> 에 있다.</p><p>클러스터 상태를 가져와서 kubectl이 올바르게 구성되어 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><p>URL 응답이 표시되면, kubectl이 클러스터에 접근하도록 올바르게 구성된 것이다.</p><p>다음과 비슷한 메시지가 표시되면, kubectl이 올바르게 구성되지 않았거나 쿠버네티스 클러스터에 연결할 수 없다.</p><pre tabindex=0><code>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
</code></pre><p>예를 들어, 랩톱에서 로컬로 쿠버네티스 클러스터를 실행하려면, Minikube와 같은 도구를 먼저 설치한 다음 위에서 언급한 명령을 다시 실행해야 한다.</p><p>kubectl cluster-info가 URL 응답을 반환하지만 클러스터에 접근할 수 없는 경우, 올바르게 구성되었는지 확인하려면 다음을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info dump
</span></span></code></pre></div><h2 id=선택적-kubectl-구성-및-플러그인>선택적 kubectl 구성 및 플러그인</h2><h3 id=셸-자동-완성-활성화>셸 자동 완성 활성화</h3><p>kubectl은 Bash, Zsh, Fish, 및 PowerShell에 대한 자동 완성 지원을 제공하므로 입력을 위한 타이핑을 많이 절약할 수 있다.</p><p>다음은 PowerShell에 대한 자동 완성을 설정하는 절차이다.</p><p>PowerShell용 kubectl 자동 완성 스크립트는 <code>kubectl completion powershell</code> 명령으로 생성할 수 있다.</p><p>모든 셸 세션에서 사용하려면, <code>$PROFILE</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>kubectl completion powershell | <span style=color:#a2f>Out-String</span> | <span style=color:#a2f>Invoke-Expression</span>
</span></span></code></pre></div><p>이 명령은 PowerShell을 실행할 때마다 자동 완성 스크립트를 재생성한다. 아니면, 생성된 스크립트를 <code>$PROFILE</code> 파일에 직접 추가할 수도 있다.</p><p>생성된 스크립트를 <code>$PROFILE</code> 파일에 직접 추가하려면, PowerShell 프롬프트에서 다음 명령줄을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>kubectl completion powershell &gt;&gt; <span style=color:#b8860b>$PROFILE</span>
</span></span></code></pre></div><p>셸을 다시 불러오면, kubectl 자동 완성이 동작할 것이다.</p><h3 id=kubectl-convert-플러그인-설치><code>kubectl convert</code> 플러그인 설치</h3><p>이것은 쿠버네티스 커맨드 라인 도구인 <code>kubectl</code>의 플러그인으로서, 특정 버전의 쿠버네티스 API로 작성된 매니페스트를 다른 버전으로
변환할 수 있도록 한다. 이것은 매니페스트를 최신 쿠버네티스 릴리스의 사용 중단되지 않은 API로 마이그레이션하는 데 특히 유용하다.
더 많은 정보는 다음의 <a href=/docs/reference/using-api/deprecation-guide/#migrate-to-non-deprecated-apis>사용 중단되지 않은 API로 마이그레이션</a>을 참고한다.</p><ol><li><p>다음 명령으로 최신 릴리스를 다운로드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>curl </span>-LO <span style=color:#b44>&#34;https://dl.k8s.io/release/v1.25.0/bin/windows/amd64/kubectl-convert.exe&#34;</span>
</span></span></code></pre></div></li><li><p>바이너리를 검증한다. (선택 사항)</p><p><code>kubectl-convert</code> 체크섬(checksum) 파일을 다운로드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>curl </span>-LO <span style=color:#b44>&#34;https://dl.k8s.io/v1.25.0/bin/windows/amd64/kubectl-convert.exe.sha256&#34;</span>
</span></span></code></pre></div><p><code>kubectl-convert</code> 바이너리를 체크섬 파일을 통해 검증한다.</p><ul><li><p>커맨드 프롬프트를 사용하는 경우, <code>CertUtil</code> 의 출력과 다운로드한 체크섬 파일을 수동으로 비교한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>CertUtil -hashfile kubectl-convert.exe SHA256
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> kubectl-convert.exe.sha256
</span></span></code></pre></div></li><li><p>PowerShell을 사용하는 경우, <code>-eq</code> 연산자를 통해 <code>True</code> 또는 <code>False</code> 결과가 출력되는 자동 검증을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>$($(CertUtil -hashfile .\<span style=color:#a2f>kubectl-convert</span>.exe SHA256)[<span style=color:#666>1</span>] <span style=color:#666>-replace</span> <span style=color:#b44>&#34; &#34;</span>, <span style=color:#b44>&#34;&#34;</span>) <span style=color:#666>-eq</span> $(<span style=color:#a2f>type </span>.\<span style=color:#a2f>kubectl-convert</span>.exe.sha256)
</span></span></code></pre></div></li></ul></li><li><p><code>kubectl-convert</code> 바이너리가 있는 폴더를 <code>PATH</code> 환경 변수의 앞부분 또는 뒷부분에 추가</p></li><li><p>플러그인이 정상적으로 설치되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl convert --help
</span></span></code></pre></div><p>에러가 출력되지 않는다면, 플러그인이 정상적으로 설치된 것이다.</p></li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><a href=https://minikube.sigs.k8s.io/docs/start/>Minikube 설치</a></li><li>클러스터 생성에 대한 자세한 내용은 <a href=/ko/docs/setup/>시작하기</a>를 참고한다.</li><li><a href=/ko/docs/tasks/access-application-cluster/service-access-application-cluster/>애플리케이션을 시작하고 노출하는 방법에 대해 배운다.</a></li><li>직접 생성하지 않은 클러스터에 접근해야 하는 경우,
<a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>클러스터 접근 공유 문서</a>를 참고한다.</li><li><a href=/ko/docs/reference/kubectl/kubectl/>kubectl 레퍼런스 문서</a> 읽기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-91639f08dfa86a6c88cf0099b2e097bc>1.4 - 포함된 도구들</h1><div class=lead>메인 kubectl-installs-*.md 페이지에 포함될 스니펫.</div></div><div class=td-content><h1 id=pg-643b1104b7b31ae10b173acfb447843a>1.4.1 - fish auto-completion</h1><div class=lead>fish 자동 완성을 활성화하기 위한 선택적 구성</div><p>Fish용 kubectl 자동 완성 스크립트는 <code>kubectl completion fish</code> 명령으로 생성할 수 있다. 셸에서 자동 완성 스크립트를 소싱하면 kubectl 자동 완성 기능이 활성화된다.</p><p>모든 셸 세션에서 사용하려면, <code>~/.config/fish/config.fish</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl completion fish | <span style=color:#a2f>source</span>
</span></span></code></pre></div><p>셸을 다시 로드하면, kubectl 자동 완성 기능이 작동할 것이다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b2d43b2ae3e8f26eefa83de2db4ba782>1.4.2 - kubectl 설치 검증하기</h1><div class=lead>kubectl을 검증하는 방법에 대해 설명한다.</div><p>kubectl이 쿠버네티스 클러스터를 찾아 접근하려면,
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a>를
사용하여 클러스터를 생성하거나 Minikube 클러스터를 성공적으로 배포할 때 자동으로 생성되는
<a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>이
필요하다.
기본적으로, kubectl 구성은 <code>~/.kube/config</code> 에 있다.</p><p>클러스터 상태를 가져와서 kubectl이 올바르게 구성되어 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><p>URL 응답이 표시되면, kubectl이 클러스터에 접근하도록 올바르게 구성된 것이다.</p><p>다음과 비슷한 메시지가 표시되면, kubectl이 올바르게 구성되지 않았거나 쿠버네티스 클러스터에 연결할 수 없다.</p><pre tabindex=0><code>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
</code></pre><p>예를 들어, 랩톱에서 로컬로 쿠버네티스 클러스터를 실행하려면, Minikube와 같은 도구를 먼저 설치한 다음 위에서 언급한 명령을 다시 실행해야 한다.</p><p>kubectl cluster-info가 URL 응답을 반환하지만 클러스터에 접근할 수 없는 경우, 올바르게 구성되었는지 확인하려면 다음을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info dump
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-d4ebbbe0a2ddce15850a36dfede9ba52>1.4.3 - kubectl-convert 개요</h1><div class=lead>특정 버전의 쿠버네티스 API로 작성된 매니페스트를 다른 버전으로 변환하는 kubectl 플러그인.</div><p>이것은 쿠버네티스 커맨드 라인 도구인 <code>kubectl</code>의 플러그인으로서, 특정 버전의 쿠버네티스 API로 작성된 매니페스트를 다른 버전으로
변환할 수 있도록 한다. 이것은 매니페스트를 최신 쿠버네티스 릴리스의 사용 중단되지 않은 API로 마이그레이션하는 데 특히 유용하다.
더 많은 정보는 다음의 <a href=/docs/reference/using-api/deprecation-guide/#migrate-to-non-deprecated-apis>사용 중단되지 않은 API로 마이그레이션</a>을 참고한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-68808b3ec5807517ed64fd8ae32a7d1b>1.4.4 - macOS에서 bash 자동 완성 사용하기</h1><div class=lead>macOS에서 bash 자동 완성을 위한 몇 가지 선택적 구성에 대해 설명한다.</div><h3 id=소개>소개</h3><p>Bash의 kubectl 자동 완성 스크립트는 <code>kubectl completion bash</code> 로 생성할 수 있다. 이 스크립트를 셸에 소싱하면 kubectl 자동 완성이 가능하다.</p><p>그러나 kubectl 자동 완성 스크립트는 미리 <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>을 설치해야 동작한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> bash-completion에는 v1과 v2 두 가지 버전이 있다. v1은 Bash 3.2(macOS의 기본 설치 버전) 버전용이고, v2는 Bash 4.1 이상 버전용이다. kubectl 자동 완성 스크립트는 bash-completion v1과 Bash 3.2 버전에서는 <strong>작동하지 않는다</strong>. <strong>bash-completion v2</strong> 와 <strong>Bash 4.1 이상 버전</strong> 이 필요하다. 따라서, macOS에서 kubectl 자동 완성 기능을 올바르게 사용하려면, Bash 4.1 이상을 설치하고 사용해야 한다(<a href=https://itnext.io/upgrading-bash-on-macos-7138bd1066ba><em>지침</em></a>). 다음의 내용에서는 Bash 4.1 이상(즉, 모든 Bash 버전 4.1 이상)을 사용한다고 가정한다.</div><h3 id=bash-업그레이드>Bash 업그레이드</h3><p>여기의 지침에서는 Bash 4.1 이상을 사용한다고 가정한다. 다음을 실행하여 Bash 버전을 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span>
</span></span></code></pre></div><p>너무 오래된 버전인 경우, Homebrew를 사용하여 설치/업그레이드할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>brew install bash
</span></span></code></pre></div><p>셸을 다시 로드하고 원하는 버전을 사용 중인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span> <span style=color:#b8860b>$SHELL</span>
</span></span></code></pre></div><p>Homebrew는 보통 <code>/usr/local/bin/bash</code> 에 설치한다.</p><h3 id=bash-completion-설치>bash-completion 설치</h3><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 언급한 바와 같이, 이 지침에서는 Bash 4.1 이상을 사용한다고 가정한다. 이는 bash-completion v2를 설치한다는 것을 의미한다(Bash 3.2 및 bash-completion v1의 경우, kubectl 자동 완성이 작동하지 않음).</div><p>bash-completion v2가 이미 설치되어 있는지 <code>type_init_completion</code> 으로 확인할 수 있다. 그렇지 않은 경우, Homebrew로 설치할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>brew install bash-completion@2
</span></span></code></pre></div><p>이 명령의 출력에 명시된 바와 같이, <code>~/.bash_profile</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>BASH_COMPLETION_COMPAT_DIR</span><span style=color:#666>=</span><span style=color:#b44>&#34;/usr/local/etc/bash_completion.d&#34;</span>
</span></span><span style=display:flex><span><span style=color:#666>[[</span> -r <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span> <span style=color:#666>]]</span> <span style=color:#666>&amp;&amp;</span> . <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span>
</span></span></code></pre></div><p>셸을 다시 로드하고 bash-completion v2가 올바르게 설치되었는지 <code>type _init_completion</code> 으로 확인한다.</p><h3 id=kubectl-자동-완성-활성화>kubectl 자동 완성 활성화</h3><p>이제 kubectl 자동 완성 스크립트가 모든 셸 세션에서 제공되도록 해야 한다. 이를 수행하는 방법에는 여러 가지가 있다.</p><ul><li><p>자동 완성 스크립트를 <code>~/.bash_profile</code> 파일에서 소싱한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bash_profile
</span></span></code></pre></div></li><li><p>자동 완성 스크립트를 <code>/usr/local/etc/bash_completion.d</code> 디렉터리에 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl completion bash &gt;/usr/local/etc/bash_completion.d/kubectl
</span></span></code></pre></div></li><li><p>kubectl에 대한 앨리어스가 있는 경우, 해당 앨리어스로 작업하기 위해 셸 자동 완성을 확장할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bash_profile
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -o default -F __start_kubectl k&#39;</span> &gt;&gt;~/.bash_profile
</span></span></code></pre></div></li><li><p>Homebrew로 kubectl을 설치한 경우(<a href=/ko/docs/tasks/tools/install-kubectl-macos/#install-with-homebrew-on-macos>여기</a>의 설명을 참고), kubectl 자동 완성 스크립트가 이미 <code>/usr/local/etc/bash_completion.d/kubectl</code> 에 있을 것이다. 이 경우, 아무 것도 할 필요가 없다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> bash-completion v2의 Homebrew 설치는 <code>BASH_COMPLETION_COMPAT_DIR</code> 디렉터리의 모든 파일을 소싱하므로, 후자의 두 가지 방법이 적용된다.</div></li></ul><p>어떤 경우든, 셸을 다시 로드하면, kubectl 자동 완성 기능이 작동할 것이다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-730f5a835775a8e94bd1c481d3f1a349>1.4.5 - PowerShell 자동 완성</h1><div class=lead>PowerShell 자동 완성을 위한 몇 가지 선택적 구성에 대해 설명한다.</div><p>PowerShell용 kubectl 자동 완성 스크립트는 <code>kubectl completion powershell</code> 명령으로 생성할 수 있다.</p><p>모든 셸 세션에서 사용하려면, <code>$PROFILE</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>kubectl completion powershell | <span style=color:#a2f>Out-String</span> | <span style=color:#a2f>Invoke-Expression</span>
</span></span></code></pre></div><p>이 명령은 PowerShell을 실행할 때마다 자동 완성 스크립트를 재생성한다. 아니면, 생성된 스크립트를 <code>$PROFILE</code> 파일에 직접 추가할 수도 있다.</p><p>생성된 스크립트를 <code>$PROFILE</code> 파일에 직접 추가하려면, PowerShell 프롬프트에서 다음 명령줄을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>kubectl completion powershell &gt;&gt; <span style=color:#b8860b>$PROFILE</span>
</span></span></code></pre></div><p>셸을 다시 불러오면, kubectl 자동 완성이 동작할 것이다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9ab27577326839cb4793fd670a916364>1.4.6 - zsh 자동 완성</h1><div class=lead>zsh 자동 완성을 위한 몇 가지 선택적 구성에 대해 설명한다.</div><p>Zsh용 kubectl 자동 완성 스크립트는 <code>kubectl completion zsh</code> 명령으로 생성할 수 있다. 셸에서 자동 완성 스크립트를 소싱하면 kubectl 자동 완성 기능이 활성화된다.</p><p>모든 셸 세션에서 사용하려면, <code>~/.zshrc</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>
</span></span></code></pre></div><p>kubectl에 대한 앨리어스가 있는 경우, kubectl 자동완성이 자동으로 동작할 것이다.</p><p>셸을 다시 로드하면, kubectl 자동 완성 기능이 작동할 것이다.</p><p><code>2: command not found: compdef</code> 와 같은 오류가 발생하면, <code>~/.zshrc</code> 파일의 시작 부분에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>autoload -Uz compinit
</span></span><span style=display:flex><span>compinit
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-99d563e9521796074ba3ca7f15a613ce>1.4.7 - 다음 단계는 무엇인가?</h1><div class=lead>kubectl을 설치한 다음 해야 하는 것에 대해 설명한다.</div><ul><li><a href=https://minikube.sigs.k8s.io/docs/start/>Minikube 설치</a></li><li>클러스터 생성에 대한 자세한 내용은 <a href=/ko/docs/setup/>시작하기</a>를 참고한다.</li><li><a href=/ko/docs/tasks/access-application-cluster/service-access-application-cluster/>애플리케이션을 시작하고 노출하는 방법에 대해 배운다.</a></li><li>직접 생성하지 않은 클러스터에 접근해야 하는 경우,
<a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>클러스터 접근 공유 문서</a>를 참고한다.</li><li><a href=/ko/docs/reference/kubectl/kubectl/>kubectl 레퍼런스 문서</a> 읽기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2d600cc8ec4dec69673b5f9577b6da22>1.4.8 - 리눅스에서 bash 자동 완성 사용하기</h1><div class=lead>리눅스에서 bash 자동 완성을 위한 몇 가지 선택적 구성에 대해 설명한다.</div><h3 id=소개>소개</h3><p>Bash의 kubectl 자동 완성 스크립트는 <code>kubectl completion bash</code> 명령으로 생성할 수 있다. 셸에서 자동 완성 스크립트를 소싱(sourcing)하면 kubectl 자동 완성 기능이 활성화된다.</p><p>그러나, 자동 완성 스크립트는 <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>에 의존하고 있으며, 이 소프트웨어를 먼저 설치해야 한다(<code>type _init_completion</code> 을 실행하여 bash-completion이 이미 설치되어 있는지 확인할 수 있음).</p><h3 id=bash-completion-설치>bash-completion 설치</h3><p>bash-completion은 많은 패키지 관리자에 의해 제공된다(<a href=https://github.com/scop/bash-completion#installation>여기</a> 참고). <code>apt-get install bash-completion</code> 또는 <code>yum install bash-completion</code> 등으로 설치할 수 있다.</p><p>위의 명령은 bash-completion의 기본 스크립트인 <code>/usr/share/bash-completion/bash_completion</code> 을 생성한다. 패키지 관리자에 따라, <code>~/.bashrc</code> 파일에서 이 파일을 수동으로 소스(source)해야 한다.</p><p>확인하려면, 셸을 다시 로드하고 <code>type _init_completion</code> 을 실행한다. 명령이 성공하면, 이미 설정된 상태이고, 그렇지 않으면 <code>~/.bashrc</code> 파일에 다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> /usr/share/bash-completion/bash_completion
</span></span></code></pre></div><p>셸을 다시 로드하고 <code>type _init_completion</code> 을 입력하여 bash-completion이 올바르게 설치되었는지 확인한다.</p><h3 id=kubectl-자동-완성-활성화>kubectl 자동 완성 활성화</h3><h4 id=bash>Bash</h4><p>이제 kubectl 자동 완성 스크립트가 모든 셸 세션에서 제공되도록 해야 한다. 이를 수행할 수 있는 두 가지 방법이 있다.</p><ul class="nav nav-tabs" id=kubectl-bash-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-bash-autocompletion-0 role=tab aria-controls=kubectl-bash-autocompletion-0 aria-selected=true>현재 사용자에만 적용</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-bash-autocompletion-1 role=tab aria-controls=kubectl-bash-autocompletion-1>시스템 전체에 적용</a></li></ul><div class=tab-content id=kubectl-bash-autocompletion><div id=kubectl-bash-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-bash-autocompletion-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div></div><div id=kubectl-bash-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-bash-autocompletion-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl &gt; /dev/null
</span></span></code></pre></div></div></div><p>kubectl에 대한 앨리어스(alias)가 있는 경우, 해당 앨리어스로 작업하도록 셸 자동 완성을 확장할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bashrc
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -o default -F __start_kubectl k&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> bash-completion은 <code>/etc/bash_completion.d</code> 에 있는 모든 자동 완성 스크립트를 소싱한다.</div><p>두 방법 모두 동일하다. 셸을 다시 로드하면, kubectl 자동 완성 기능이 작동할 것이다.
셸의 현재 세션에서 bash 자동 완성을 활성화하려면 <code>exec bash</code>를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>exec</span> bash
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-61e6bd39c782b924943d60fc8387afe4>2 - 모니터링, 로깅, 및 디버깅</h1><div class=lead>클러스터를 트러블슈팅할 수 있도록 모니터링과 로깅을 설정하거나, 컨테이너화된 애플리케이션을 디버깅한다.</div><p>때때로 문제가 발생할 수 있다. 이 가이드는 이러한 상황을 해결하기 위해 작성되었다. 문제 해결에는
다음 두 가지를 참고해 볼 수 있다.</p><ul><li><a href=/ko/docs/tasks/debug/debug-application/>애플리케이션 디버깅하기</a> - 쿠버네티스에
코드를 배포하였지만 제대로 동작하지 않는 사용자들에게 유용한 가이드이다.</li><li><a href=/ko/docs/tasks/debug/debug-cluster/>클러스터 디버깅하기</a> - 쿠버네티스 클러스터에
문제를 겪고 있는 클러스터 관리자 혹은 기분이 나쁜 사람들에게 유용한 가이드이다.</li></ul><p>여러분이 현재 사용중인 릴리스에 대한 알려진 이슈들을 다음의 <a href=https://github.com/kubernetes/kubernetes/releases>릴리스</a>
페이지에서 확인해 볼 수도 있다.</p><h2 id=도움-받기>도움 받기</h2><p>여러분의 문제가 위에 소개된 어떠한 가이드로도 해결할 수 없다면,
쿠버네티스 커뮤니티로부터 도움을 받을 수 있는 다양한 방법들을 시도해 볼 수 있다.</p><h3 id=질문>질문</h3><p>이 사이트의 문서들은 다양한 질문들에 대한 답변을 제공할 수 있도록 구성되어 있다.
<a href=/ko/docs/concepts/>개념</a>은 쿠버네티스의 아키텍처와 각 컴포넌트들이 어떻게 동작하는지에 대해 설명하고,
<a href=/ko/docs/setup/>시작하기</a>는 쿠버네티스를 시작하는 데 유용한 지침들을 제공한다.
<a href=/ko/docs/tasks/>태스크</a>는 흔히 사용되는 작업들을 수행하는 방법에 대해 소개하고,
<a href=/ko/docs/tutorials/>튜토리얼</a>은 실무, 산업 특화 혹은 종단간 개발에 특화된 시나리오를 통해 차근차근 설명한다.
<a href=/ko/docs/reference/>레퍼런스</a> 섹션에서는
<a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 API</a>와
<a href=/ko/docs/reference/kubectl/><code>kubectl</code></a>과 같은 커맨드 라인 인터페이스(CLI)에 대한
상세한 설명을 다룬다.</p><h2 id=도와주세요-내-질문이-다뤄지지-않았어요-도움이-필요해요>도와주세요! 내 질문이 다뤄지지 않았어요! 도움이 필요해요!</h2><h3 id=스택-오버플로우>스택 오버플로우</h3><p>여러분들이 겪고 있는 문제와 동일한 문제에 대한 도움을 위해 커뮤니티의 다른 사람들이 이미
질문을 올렸을 수 있다. 쿠버네티스 팀은
<a href=https://stackoverflow.com/questions/tagged/kubernetes>쿠버네티스 태그가 등록된 글</a>들을 모니터링하고 있다.
발생한 문제에 도움이 되는 기존 질문이 없다면,
<strong><a href=https://stackoverflow.com/help/on-topic>해당 질문이 스택 오버플로우에 적합한지</a>와 <a href=https://stackoverflow.com/help/how-to-ask>새로운 질문을 올리는 방법</a>에 대한 가이드를 읽은 뒤에</strong>
<a href="https://stackoverflow.com/questions/ask?tags=kubernetes">새로운 질문</a>을 올리자!</p><h3 id=슬랙>슬랙</h3><p>쿠버네티스 슬랙의 <code>#kubernetes-users</code> 채널을 통해 쿠버네티스 커뮤니티의 여러 사람들을 접할 수도 있다.
쿠버네티스 슬랙을 사용하기 위해서는 등록이 필요한데, 다음을 통해 <a href=https://slack.kubernetes.io>채널 초대 요청</a>을 할 수 있다.
(누구나 가입할 수 있다). 슬랙 채널은 여러분이 어떠한 질문을 할 수 있도록 언제나 열려있다.
가입하고 나면 여러분의 웹 브라우저나 슬랙 앱을 통해 <a href=https://kubernetes.slack.com>쿠버네티스 슬랙</a>
에 참여할 수 있다.</p><p>쿠버네티스 슬랙에 참여하게 된다면, 다양한 주제의 흥미와 관련된 여러 채널들에 대해
살펴본다. 가령, 쿠버네티스를 처음 접하는 사람이라면
<a href=https://kubernetes.slack.com/messages/kubernetes-novice><code>#kubernetes-novice</code></a> 채널에 가입할 수 있다. 혹은, 만약 당신이 개발자라면
<a href=https://kubernetes.slack.com/messages/kubernetes-dev><code>#kubernetes-dev</code></a> 채널에 가입할 수 있다.</p><p>또한 각 국가 및 사용 언어별 채널들이 여럿 존재한다. 사용하는 언어로 도움을 받거나 정보를
얻기 위해서는 다음의 채널에 참가한다.</p><table><caption style=display:none>국가 / 언어별 슬랙 채널</caption><thead><tr><th style=text-align:left>국가</th><th style=text-align:left>채널</th></tr></thead><tbody><tr><td style=text-align:left>China(중국)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/cn-users><code>#cn-users</code></a>, <a href=https://kubernetes.slack.com/messages/cn-events><code>#cn-events</code></a></td></tr><tr><td style=text-align:left>Finland(핀란드)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/fi-users><code>#fi-users</code></a></td></tr><tr><td style=text-align:left>France(프랑스)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/fr-users><code>#fr-users</code></a>, <a href=https://kubernetes.slack.com/messages/fr-events><code>#fr-events</code></a></td></tr><tr><td style=text-align:left>Germany(독일)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/de-users><code>#de-users</code></a>, <a href=https://kubernetes.slack.com/messages/de-events><code>#de-events</code></a></td></tr><tr><td style=text-align:left>India(인도)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/in-users><code>#in-users</code></a>, <a href=https://kubernetes.slack.com/messages/in-events><code>#in-events</code></a></td></tr><tr><td style=text-align:left>Italy(이탈리아)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/it-users><code>#it-users</code></a>, <a href=https://kubernetes.slack.com/messages/it-events><code>#it-events</code></a></td></tr><tr><td style=text-align:left>Japan(일본)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/jp-users><code>#jp-users</code></a>, <a href=https://kubernetes.slack.com/messages/jp-events><code>#jp-events</code></a></td></tr><tr><td style=text-align:left>Korea(한국)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/kr-users><code>#kr-users</code></a></td></tr><tr><td style=text-align:left>Netherlands(네덜란드)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/nl-users><code>#nl-users</code></a></td></tr><tr><td style=text-align:left>Norway(노르웨이)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/norw-users><code>#norw-users</code></a></td></tr><tr><td style=text-align:left>Poland(폴란드)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/pl-users><code>#pl-users</code></a></td></tr><tr><td style=text-align:left>Russia(러시아)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/ru-users><code>#ru-users</code></a></td></tr><tr><td style=text-align:left>Spain(스페인)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/es-users><code>#es-users</code></a></td></tr><tr><td style=text-align:left>Sweden(스웨덴)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/se-users><code>#se-users</code></a></td></tr><tr><td style=text-align:left>Turkey(터키)</td><td style=text-align:left><a href=https://kubernetes.slack.com/messages/tr-users><code>#tr-users</code></a>, <a href=https://kubernetes.slack.com/messages/tr-events><code>#tr-events</code></a></td></tr></tbody></table><h3 id=포럼>포럼</h3><p>공식 쿠버네티스 포럼에 참여하는 것도 추천되는 방법이다. <a href=https://discuss.kubernetes.io>discuss.kubernetes.io</a>.</p><h3 id=버그와-기능-추가-요청>버그와 기능 추가 요청</h3><p>만약 여러분이 버그처럼 보이는 것을 발견했거나, 기능 추가 요청을 하기 위해서는
<a href=https://github.com/kubernetes/kubernetes/issues>GitHub 이슈 트래킹 시스템</a>을 사용한다.</p><p>이슈를 작성하기 전에는, 여러분의 이슈가 기존 이슈에서 이미
다뤄졌는지 검색해 본다.</p><p>버그를 보고하는 경우에는, 해당 문제를 어떻게 재현할 수 있는지에 관련된 상세한 정보를 포함한다.
포함되어야 하는 정보들은 다음과 같다.</p><ul><li>쿠버네티스 버전: <code>kubectl version</code></li><li>클라우드 프로바이더, OS 배포판, 네트워크 구성, 및 도커 버전</li><li>문제를 재현하기 위한 절차</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4a26f4e7f9ffe4b86dea8b77906d3d5c>2.1 - 애플리케이션 트러블슈팅하기</h1><div class=lead>일반적인 컨테이너화된 애플리케이션 이슈를 디버깅한다.</div><p>이 문서는 컨테이너화된 애플리케이션의 이슈를 해결하기 위한 자원을 담고 있다. 쿠버네티스 리소스(예: 파드, 서비스, 스테이트풀셋)의 일반적 이슈, 컨테이너 종료 메시지 이해에 대한 조언, 실행 중인 컨테이너를 디버그하는 방법 등을 다룬다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-abb72792fa997869a6d241ca28ea225e>2.1.1 - 파드 디버깅하기</h1><p>이 가이드는 쿠버네티스에 배포되었지만 제대로 동작하지 않는 애플리케이션을 디버깅하는 방법을 소개한다.
이 가이드는 클러스터 디버깅에 대한 것은 아니다.
클러스터 디버깅에 대해서는 <a href=/ko/docs/tasks/debug/debug-cluster/>이 가이드</a>를 참고한다.</p><h2 id=문제-진단하기>문제 진단하기</h2><p>트러블슈팅의 첫 단계는 문제를 파악하는 것이다.
무엇이 문제인가? 파드인가, 레플리케이션 컨트롤러인가, 서비스인가?</p><ul><li><a href=#debugging-pods>파드 디버깅하기</a></li><li><a href=#debugging-replication-controllers>레플리케이션컨트롤러 디버깅하기</a></li><li><a href=#debugging-services>서비스 디버깅하기</a></li></ul><h3 id=debugging-pods>파드 디버깅하기</h3><p>파드 디버깅의 첫 번째 단계는 파드를 살펴 보는 것이다. 다음의 명령어를 사용하여 파드의 현재 상태와 최근 이벤트를 점검한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pods <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span>
</span></span></code></pre></div><p>파드 내부 컨테이너의 상태를 확인한다. 모두 <code>Running</code> 상태인가? 최근에 재시작 되었는가?</p><p>파드의 상태에 따라 디버깅을 계속한다.</p><h4 id=파드가-계속-pending-상태인-경우>파드가 계속 pending 상태인 경우</h4><p>파드가 <code>Pending</code> 상태로 멈춰 있는 경우는, 노드에 스케줄 될 수 없음을 의미한다.
일반적으로 이것은 어떤 유형의 리소스가 부족하거나 스케줄링을 방해하는 다른 요인 때문이다.
상단의 <code>kubectl describe ...</code> 명령의 결과를 확인하자.
파드를 스케줄 할 수 없는 사유에 대한 스케줄러의 메세지가 있을 것이다. 다음과 같은 사유가 있을 수 있다.</p><ul><li><p><strong>리소스가 부족한 경우</strong>: 사용자 클러스터의 CPU 나 메모리가 고갈되었을 수 있다.
이러한 경우, 파드를 삭제하거나, 리소스 요청을 조정하거나, 클러스터에 노드를 추가해야 한다.
<a href=/ko/docs/concepts/configuration/manage-resources-containers/>컴퓨트 자원 문서</a>에서 더 많은 정보를 확인한다.</p></li><li><p><strong><code>hostPort</code>를 사용하고 있는 경우</strong>: 파드를 <code>hostPort</code>에 바인딩할 때, 파드가 스케줄링될 수 있는 장소 수 제한이 존재한다.
대부분의 경우 <code>hostPort</code>는 불필요하므로, 파드를 노출하기 위해서는 서비스(Service) 오브젝트 사용을 고려해 본다.
<code>hostPort</code>가 꼭 필요하다면 클러스터의 노드 수 만큼만 파드를 스케줄링할 수 있다.</p></li></ul><h4 id=파드가-계속-waiting-상태인-경우>파드가 계속 waiting 상태인 경우</h4><p>파드가 <code>Waiting</code> 상태에서 멈춘 경우는, 파드가 워커 노드에 스케줄링되었지만 해당 노드에서 실행될 수 없음을 의미한다.
다시 말하지만, <code>kubectl describe ...</code> 명령은 유용한 정보를 제공한다. 파드가 <code>Waiting</code> 상태에서 멈추는 가장 흔한 원인은 이미지 풀링(pulling)에 실패했기 때문이다. 다음의 3가지 사항을 확인한다.</p><ul><li>이미지 이름이 올바른지 확인한다.</li><li>해당 이미지를 저장소에 푸시하였는가?</li><li>이미지가 풀 될 수 있는지 확인하기 위해 수동으로 이미지를 풀 해본다.
예를 들어, PC에서 도커를 사용하는 경우, <code>docker pull &lt;image></code> 명령을 실행한다.</li></ul><h4 id=파드가-손상-crashing-되었거나-양호하지-않을-unhealthy-경우>파드가 손상(crashing)되었거나 양호하지 않을(unhealthy) 경우</h4><p>일단 사용자의 파드가 스케줄 되면, <a href=/ko/docs/tasks/debug/debug-application/debug-running-pod/>구동중인 파드 디버그하기</a>에
있는 방법을 사용하여 디버깅을 할 수 있다.</p><h4 id=파드가-running-상태이지만-해야-할-일을-하고-있지-않은-경우>파드가 running 상태이지만 해야 할 일을 하고 있지 않은 경우</h4><p>파드가 예상과 다르게 동작 중이라면, 파드 상세(예: 로컬 머신에 있는 <code>mypod.yaml</code> 파일)에 에러가 있었는데
파드 생성 시에 에러가 조용히 지나쳐진 경우일 수 있다.
종종 파드 상세의 들여쓰기가 잘못되었거나,
키 이름에 오타가 있어서 해당 키가 무시되는 일이 있을 수 있다.
예를 들어, <code>command</code>를 <code>commnd</code>로 잘못 기재했다면
해당 파드는 생성은 되지만 명시한 명령줄을 실행하지 않을 것이다.</p><p>가장 먼저 해야 할 일은 파드를 삭제한 다음, <code>--validate</code> 옵션을 사용하여 다시 만들어 보는 것이다.
예를 들어, <code>kubectl apply --validate -f mypod.yaml</code> 를 실행한다.
<code>command</code>를 <code>commnd</code>로 잘못 기재했다면 다음과 같은 에러가 발생할 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>I0805 10:43:25.129850   <span style=color:#666>46757</span> schema.go:126<span style=color:#666>]</span> unknown field: commnd
</span></span><span style=display:flex><span>I0805 10:43:25.129973   <span style=color:#666>46757</span> schema.go:129<span style=color:#666>]</span> this may be a <span style=color:#a2f>false</span> alarm, see https://github.com/kubernetes/kubernetes/issues/6842
</span></span><span style=display:flex><span>pods/mypod
</span></span></code></pre></div><p>다음으로 확인할 것은 apiserver를 통해 확인한 파드 상세가
사용자가 의도한 파드 상세(예: 로컬 머신에 있는 yaml 파일)와 일치하는지 여부이다.
예를 들어, <code>kubectl get pods/mypod -o yaml > mypod-on-apiserver.yaml</code> 를 실행한 다음,
원본 파드 상세(<code>mypod.yaml</code>)와 apiserver를 통해 확인한 파드 상세(<code>mypod-on-apiserver.yaml</code>)를 수동으로 비교한다.
보통 원본 버전에는 없지만 "apiserver" 버전에는 있는 줄들이 존재한다.
이는 예상대로이다.
하지만, 원본 버전에는 있지만 "apiserver" 버전에는 없는 줄들이 있다면,
이는 원본 파드 상세에 문제가 있을 수도 있음을 의미한다.</p><h2 id=debugging-replication-controllers>레플리케이션컨트롤러 디버깅하기</h2><p>레플리케이션컨트롤러의 경우에는 매우 직관적이다. 파드 생성이 가능하거나 또는 불가능한 경우 둘 뿐이다.
레플리케이션컨트롤러가 파드를 생성할 수 없다면, <a href=#debugging-pods>위의 지침</a>을 참고하여 파드를 디버깅한다.</p><p>사용자는 <code>kubectl describe rc ${CONTROLLER_NAME}</code> 을 사용하여
레플리케이션 컨트롤러와 관련된 이벤트를 검사할 수도 있다.</p><h3 id=debugging-services>서비스 디버깅하기</h3><p>서비스는 파드 집합에 대한 로드 밸런싱 기능을 제공한다. 일반적인 몇몇 문제들 때문에 서비스가 제대로 동작하지 않을 수 있다.
다음 지침을 이용하여 서비스 문제를 디버깅할 수 있다.</p><p>먼저, 서비스를 위한 엔드포인트가 존재하는지 확인한다. 모든 서비스 오브젝트에 대해, apiserver는 <code>endpoints</code> 리소스를 생성하고 사용 가능한(available) 상태로 만든다.</p><p>다음 명령을 사용하여 이 리소스를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get endpoints <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICE_NAME</span><span style=color:#b68;font-weight:700>}</span>
</span></span></code></pre></div><p>엔드포인트의 수가 해당 서비스에 속하는 파드의 수와 일치하는지 확인한다.
예를 들어, 서비스가 레플리카 3개인 nginx 컨테이너를 위한 것이라면,
서비스의 엔드포인트 항목에서 서로 다른 3개의 IP 주소가 확인되어야 한다.</p><h4 id=서비스에-엔드포인트가-없는-경우>서비스에 엔드포인트가 없는 경우</h4><p>엔드포인트가 없는 상태라면, 서비스가 사용 중인 레이블을 이용하여 파드 목록을 조회해 본다.
다음과 같은 레이블을 갖는 서비스를 가정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span></code></pre></div><p>다음의 명령을 사용하여,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>name</span><span style=color:#666>=</span>nginx,type<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>이 셀렉터에 매치되는 파드 목록을 조회할 수 있다. 서비스에 속할 것으로 예상하는 파드가 모두 조회 결과에 있는지 확인한다.
파드의 <code>containerPort</code>가 서비스의 <code>targetPort</code>와 일치하는지 확인한다.</p><h4 id=네트워크-트래픽이-포워드되지-않는-경우>네트워크 트래픽이 포워드되지 않는 경우</h4><p><a href=/docs/tasks/debug/debug-application/debug-service/>서비스 디버깅하기</a>에서 더 많은 정보를 확인한다.</p><h2 id=다음-내용>다음 내용</h2><p>위의 방법 중 어떤 것으로도 문제가 해결되지 않는다면,
<a href=/docs/tasks/debug/debug-application/debug-service/>서비스 디버깅하기 문서</a>를 참조하여
<code>서비스</code>가 실행 중인지, 서비스에 <code>엔드포인트</code>가 있는지, <code>파드</code>가 실제로 서빙 중인지 확인한다.
예를 들어, DNS가 실행 중이고, iptables 규칙이 설정되어 있고, kube-proxy가 정상적으로 동작하는 것으로 보이는 상황이라면,
위와 같은 사항을 확인해 볼 수 있다.</p><p><a href=/ko/docs/tasks/debug/>트러블슈팅 문서</a>에서 더 많은 정보를 볼 수도 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-089001d4003f033e21602adcb11cd277>2.1.2 - 스테이트풀셋 디버깅하기</h1><p>이 문서에서는 스테이트풀셋을 디버깅 방법에 대해 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li>쿠버네티스 클러스터가 준비되어 있어야 하고, kubectl 커맨드 라인 도구가 클러스터와 통신할 수 있게 사전에 설정되어 있어야 한다.</li><li>조사하고자 하는 스테이트풀셋이 사전에 준비되어 있어야 한다.</li></ul><h2 id=스테이트풀셋-디버깅하기>스테이트풀셋 디버깅하기</h2><p>레이블이 <code>app.kubernetes.io/name=MyApp</code>으로 지정된 스테이트풀셋 파드를 전부 나열하기 위해서는
다음의 명령을 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l app.kubernetes.io/name<span style=color:#666>=</span>MyApp
</span></span></code></pre></div><p>만약 오랜 시간동안 <code>Unknown</code>이나 <code>Terminating</code> 상태에 있는
파드들을 발견하였다면, 이러한 파드들을 어떻게 다루는지 알아보기 위해
<a href=/ko/docs/tasks/run-application/delete-stateful-set/>스테이트풀셋 파드 삭제하기</a>를 참고하길 바란다.
스테이트풀셋에 포함된 개별 파드들을 디버깅하기 위해서는
<a href=/ko/docs/tasks/debug/debug-application/debug-pods/>파드 디버그하기</a> 가이드를 참고하길 바란다.</p><h2 id=다음-내용>다음 내용</h2><p><a href=/ko/docs/tasks/debug/debug-application/debug-init-containers/>초기화 컨테이너(Init container) 디버그하기</a>를 참고하길 바란다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-43445f3208669d4078e87dbdbeed8473>2.1.3 - 초기화 컨테이너(Init Containers) 디버그하기</h1><p>이 페이지는 초기화 컨테이너의 실행과 관련된 문제를
조사하는 방법에 대해 보여준다. 아래 예제의 커맨드 라인은 파드(Pod)를 <code>&lt;pod-name></code> 으로,
초기화 컨테이너를 <code>&lt;init-container-1></code> 과
<code>&lt;init-container-2></code> 로 표시한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><ul><li>사용자는 <a href=/ko/docs/concepts/workloads/pods/init-containers/>초기화 컨테이너</a>의
기본 사항에 익숙해야 한다.</li><li>사용자는 <a href=/ko/docs/tasks/configure-pod-container/configure-pod-initialization/#%EC%B4%88%EA%B8%B0%ED%99%94-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%A5%BC-%EA%B0%96%EB%8A%94-%ED%8C%8C%EB%93%9C-%EC%83%9D%EC%84%B1>초기화 컨테이너를 구성</a>해야 한다.</li></ul><h2 id=초기화-컨테이너의-상태-체크하기>초기화 컨테이너의 상태 체크하기</h2><p>사용자 파드의 상태를 표시한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod &lt;pod-name&gt;
</span></span></code></pre></div><p>예를 들어, <code>Init:1/2</code> 상태는 두 개의 초기화 컨테이너 중
하나가 성공적으로 완료되었음을 나타낸다.</p><pre tabindex=0><code>NAME         READY     STATUS     RESTARTS   AGE
&lt;pod-name&gt;   0/1       Init:1/2   0          7s
</code></pre><p>상태값과 그 의미에 대한 추가 예제는
<a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%83%81%ED%83%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0>파드 상태 이해하기</a>를 참조한다.</p><h2 id=초기화-컨테이너에-대한-상세-정보-조회하기>초기화 컨테이너에 대한 상세 정보 조회하기</h2><p>초기화 컨테이너의 실행에 대한 상세 정보를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod &lt;pod-name&gt;
</span></span></code></pre></div><p>예를 들어, 2개의 초기화 컨테이너가 있는 파드는 다음과 같이 표시될 수 있다.</p><pre tabindex=0><code>Init Containers:
  &lt;init-container-1&gt;:
    Container ID:    ...
    ...
    State:           Terminated
      Reason:        Completed
      Exit Code:     0
      Started:       ...
      Finished:      ...
    Ready:           True
    Restart Count:   0
    ...
  &lt;init-container-2&gt;:
    Container ID:    ...
    ...
    State:           Waiting
      Reason:        CrashLoopBackOff
    Last State:      Terminated
      Reason:        Error
      Exit Code:     1
      Started:       ...
      Finished:      ...
    Ready:           False
    Restart Count:   3
    ...
</code></pre><p>파드 스펙의 <code>status.initContainerStatuses</code> 필드를 읽어서
프로그래밍 방식으로 초기화 컨테이너의 상태를 조회할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod nginx --template <span style=color:#b44>&#39;{{.status.initContainerStatuses}}&#39;</span>
</span></span></code></pre></div><p>이 명령은 원시 JSON 방식으로 위와 동일한 정보를 반환한다.</p><h2 id=초기화-컨테이너의-로그-조회하기>초기화 컨테이너의 로그 조회하기</h2><p>초기화 컨테이너의 로그를 확인하기 위해
파드의 이름과 초기화 컨테이너의 이름을 같이 전달한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs &lt;pod-name&gt; -c &lt;init-container-2&gt;
</span></span></code></pre></div><p>셸 스크립트를 실행하는 초기화 컨테이너는, 초기화 컨테이너가
실행될 때 명령어를 출력한다. 예를 들어, 스크립트의 시작 부분에
<code>set -x</code> 를 추가하고 실행하여 Bash에서 명령어를 출력할 수 있도록 수행할 수 있다.</p><h2 id=파드의-상태-이해하기>파드의 상태 이해하기</h2><p><code>Init:</code> 으로 시작하는 파드 상태는 초기화 컨테이너의
실행 상태를 요약한다. 아래 표는 초기화 컨테이너를 디버깅하는
동안 사용자가 확인할 수 있는 몇 가지 상태값의 예이다.</p><table><thead><tr><th>상태</th><th>의미</th></tr></thead><tbody><tr><td><code>Init:N/M</code></td><td>파드가 <code>M</code> 개의 초기화 컨테이너를 갖고 있으며, 현재까지 <code>N</code> 개가 완료.</td></tr><tr><td><code>Init:Error</code></td><td>초기화 컨테이너 실행 실패.</td></tr><tr><td><code>Init:CrashLoopBackOff</code></td><td>초기화 컨테이너가 반복적으로 실행 실패.</td></tr><tr><td><code>Pending</code></td><td>파드가 아직 초기화 컨테이너를 실행하지 않음.</td></tr><tr><td><code>PodInitializing</code> or <code>Running</code></td><td>파드가 이미 초기화 컨테이너 실행을 완료.</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-132acc7efbd72bd677945eda3b6c6d38>2.1.4 - 동작 중인 파드 디버그</h1><p>이 페이지는 노드에서 동작 중인(혹은 크래시된) 파드를 디버그하는 방법에 대해 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li>여러분의 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>는 이미 스케줄링 되어
동작하고 있을 것이다. 만약 파드가 아직 동작중이지 않다면, <a href=/ko/docs/tasks/debug/debug-application/>애플리케이션
트러블슈팅</a>을 참고한다.</li><li>일부 고급 디버깅 과정에서는 해당 파드가 어떤 노드에서 동작하고 있는지
알아야 하고, 해당 노드에서 쉘 명령어를 실행시킬 수 있어야 한다.
<code>kubectl</code>을 사용하는 일반적인 디버깅 과정에서는 이러한 접근 권한이 필요하지 않다.</li></ul><h2 id=kubectl-describe-pod-명령으로-파드-상세사항-가져오기><code>kubectl describe pod</code> 명령으로 파드 상세사항 가져오기</h2><p>이 예제에서는 앞의 예제와 비슷하게 두 개의 파드를 생성하기 위해 디플로이먼트를 사용할 것이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/nginx-with-request.yaml download=application/nginx-with-request.yaml><code>application/nginx-with-request.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-nginx-with-request-yaml")' title="Copy application/nginx-with-request.yaml to clipboard"></img></div><div class=includecode id=application-nginx-with-request-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>다음 명령을 실행하여 디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx-with-request.yaml
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>deployment.apps/nginx-deployment created
</code></pre><p>다음 명령을 실행하여 파드 상태를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-67d4bdd6f5-cx2nz   1/1     Running   0          13s
nginx-deployment-67d4bdd6f5-w6kd7   1/1     Running   0          13s
</code></pre><p>다음과 같이 <code>kubectl describe pod</code> 명령을 사용하여 각 파드에 대한 더 많은 정보를 가져올 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod nginx-deployment-67d4bdd6f5-w6kd7
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Name:         nginx-deployment-67d4bdd6f5-w6kd7
Namespace:    default
Priority:     0
Node:         kube-worker-1/192.168.0.113
Start Time:   Thu, 17 Feb 2022 16:51:01 -0500
Labels:       app=nginx
              pod-template-hash=67d4bdd6f5
Annotations:  &lt;none&gt;
Status:       Running
IP:           10.88.0.3
IPs:
  IP:           10.88.0.3
  IP:           2001:db8::1
Controlled By:  ReplicaSet/nginx-deployment-67d4bdd6f5
Containers:
  nginx:
    Container ID:   containerd://5403af59a2b46ee5a23fb0ae4b1e077f7ca5c5fb7af16e1ab21c00e0e616462a
    Image:          nginx
    Image ID:       docker.io/library/nginx@sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Thu, 17 Feb 2022 16:51:05 -0500
    Ready:          True
    Restart Count:  0
    Limits:
      cpu:     500m
      memory:  128Mi
    Requests:
      cpu:        500m
      memory:     128Mi
    Environment:  &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-bgsgp (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  kube-api-access-bgsgp:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       &lt;nil&gt;
    DownwardAPI:             true
QoS Class:                   Guaranteed
Node-Selectors:              &lt;none&gt;
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  34s   default-scheduler  Successfully assigned default/nginx-deployment-67d4bdd6f5-w6kd7 to kube-worker-1
  Normal  Pulling    31s   kubelet            Pulling image &#34;nginx&#34;
  Normal  Pulled     30s   kubelet            Successfully pulled image &#34;nginx&#34; in 1.146417389s
  Normal  Created    30s   kubelet            Created container nginx
  Normal  Started    30s   kubelet            Started container nginx
</code></pre><p>위 예시에서 컨테이너와 파드에 대한 구성 정보(레이블, 리소스 요구사항 등) 및 상태 정보(상태(state), 준비성(readiness), 재시작 횟수, 이벤트 등)를 볼 수 있다.</p><p>컨테이너의 상태(state)값은 Waiting, Running, 또는 Terminated 중 하나이다. 각 상태에 따라, 추가 정보가 제공될 것이다. 위 예시에서 Running 상태의 컨테이너에 대해서는 컨테이너의 시작 시각을 시스템이 표시해 주는 것을 볼 수 있다.</p><p>Ready 값은 컨테이너의 마지막 준비성 프로브(readiness probe) 통과 여부를 알려 준다. (위 예시에서는 컨테이너에 준비성 프로브가 설정되어 있지 않다. 컨테이너에 준비성 프로브가 설정되어 있지 않으면, 컨테이너는 준비(ready) 상태로 간주된다.)</p><p>'재시작 카운트'는 컨테이너가 재시작된 횟수를 보여 준다. 이 정보는 재시작 정책이 'always'로 설정된 컨테이너의 반복적인 강제 종료를 알아차리는 데에 유용하다.</p><p>위 예시에서 파드와 연관된 유일한 컨디션(Condition)은 True 또는 False 값을 갖는 Ready 컨디션이며, 이 값이 True라는 것은 파드가 요청을 처리할 수 있으며 모든 동일한 서비스를 묶는 로드 밸런싱 풀에 추가되어야 함을 의미한다.</p><p>마지막으로, 파드와 관련된 최근 이벤트 로그가 표시된다. 시스템은 동일한 여러 이벤트를 처음/마지막 발생 시간 및 발생 횟수만 압축적으로 표시한다. "From"은 이벤트 로그를 발생하는 구성 요소를 가리키고, "SubobjectPath"는 참조되는 개체(예: 파드 내 컨테이너)를 나타내며, "Reason" 및 "Message"는 발생한 상황을 알려 준다.</p><h2 id=예시-pending-상태의-파드-디버깅하기>예시: Pending 상태의 파드 디버깅하기</h2><p>이벤트를 사용하여 감지할 수 있는 일반적인 시나리오는 노드에 할당될 수 없는 파드를 생성하는 경우이다. 예를 들어 파드가 노드에 사용 가능한 리소스보다 더 많은 리소스를 요청하거나, 또는 어떤 노드에도 해당되지 않는 레이블 셀렉터를 명시했을 수 있다. 예를 들어 4개 노드로 구성되며 각 (가상) 머신에 1 CPU가 있는 클러스터가 있는 상황에서, 위 예시 대신 2 레플리카가 아니라 5 레플리카를, 500 밀리코어가 아니라 600 밀리코어를 요청하는 디플로이먼트를 배포했다고 해 보자. 이러한 경우 5개의 파드 중 하나는 스케줄링될 수 없을 것이다. (각 노드에는 fluentd, skydns 등의 클러스터 애드온도 실행되고 있으므로, 만약 1000 밀리코어를 요청했다면 파드가 하나도 스케줄될 수 없었을 것이다.)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1006230814-6winp   1/1       Running   0          7m
nginx-deployment-1006230814-fmgu3   1/1       Running   0          7m
nginx-deployment-1370807587-6ekbw   1/1       Running   0          1m
nginx-deployment-1370807587-fg172   0/1       Pending   0          1m
nginx-deployment-1370807587-fz9sd   0/1       Pending   0          1m
</code></pre><p>nginx-deployment-1370807587-fz9sd 파드가 왜 실행되지 않는지를 알아 보려면, pending 상태의 파드에 대해 <code>kubectl describe pod</code> 명령을 실행하고 이벤트(event) 항목을 확인해 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod nginx-deployment-1370807587-fz9sd
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>  Name:		nginx-deployment-1370807587-fz9sd
  Namespace:	default
  Node:		/
  Labels:		app=nginx,pod-template-hash=1370807587
  Status:		Pending
  IP:
  Controllers:	ReplicaSet/nginx-deployment-1370807587
  Containers:
    nginx:
      Image:	nginx
      Port:	80/TCP
      QoS Tier:
        memory:	Guaranteed
        cpu:	Guaranteed
      Limits:
        cpu:	1
        memory:	128Mi
      Requests:
        cpu:	1
        memory:	128Mi
      Environment Variables:
  Volumes:
    default-token-4bcbi:
      Type:	Secret (a volume populated by a Secret)
      SecretName:	default-token-4bcbi
  Events:
    FirstSeen	LastSeen	Count	From			        SubobjectPath	Type		Reason			    Message
    ---------	--------	-----	----			        -------------	--------	------			    -------
    1m		    48s		    7	    {default-scheduler }			        Warning		FailedScheduling	pod (nginx-deployment-1370807587-fz9sd) failed to fit in any node
  fit failure on node (kubernetes-node-6ta5): Node didn&#39;t have enough resource: CPU, requested: 1000, used: 1420, capacity: 2000
  fit failure on node (kubernetes-node-wul5): Node didn&#39;t have enough resource: CPU, requested: 1000, used: 1100, capacity: 2000
</code></pre><p>여기서 스케줄러가 기록한 이벤트를 통해, 파드가 <code>FailedScheduling</code> 사유로 인해 스케줄링되지 않았음을 알 수 있다(다른 이유도 있을 수 있음). 이 메시지를 통해 어떤 노드에도 이 파드를 실행하기 위한 충분한 리소스가 없었음을 알 수 있다.</p><p>이 상황을 바로잡으려면, <code>kubectl scale</code> 명령으로 디플로이먼트의 레플리카를 4 이하로 줄일 수 있다. (또는 한 파드를 pending 상태로 두어도 되며, 이렇게 해도 문제는 없다.)</p><p><code>kubectl describe pod</code> 출력의 마지막에 있는 것과 같은 이벤트는 etcd에 기록되어 보존되며 클러스터에 어떤 일이 일어나고 있는지에 대한 높은 차원의 정보를 제공한다. 모든 이벤트의 목록을 보려면 다음 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>그런데 이벤트는 네임스페이스 스코프 객체라는 것을 기억해야 한다. 즉 네임스페이스 스코프 객체에 대한 이벤트(예: <code>my-namespace</code> 네임스페이스의 파드에 어떤 일이 발생했는지)가 궁금하다면, 다음과 같이 커맨드에 네임스페이스를 명시해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events --namespace<span style=color:#666>=</span>my-namespace
</span></span></code></pre></div><p>모든 네임스페이스에 대한 이벤트를 보려면, <code>--all-namespaces</code> 인자를 사용할 수 있다.</p><p><code>kubectl describe pod</code> 명령 외에도, <code>kubectl get pod</code> 이상의 정보를 얻는 다른 방법은 <code>kubectl get pod</code> 명령에 출력 형식 플래그 <code>-o yaml</code> 인자를 추가하는 것이다. 이렇게 하면 <code>kubectl describe pod</code> 명령보다 더 많은 정보, 원천적으로는 시스템이 파드에 대해 알고 있는 모든 정보를 YAML 형식으로 볼 수 있다. 여기서 어노테이션(레이블 제한이 없는 키-밸류 메타데이터이며, 쿠버네티스 시스템 구성 요소가 내부적으로 사용함), 재시작 정책, 포트, 볼륨과 같은 정보를 볼 수 있을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod nginx-deployment-1006230814-6winp -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T21:51:01Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>generateName</span>:<span style=color:#bbb> </span>nginx-deployment-67d4bdd6f5-<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-template-hash</span>:<span style=color:#bbb> </span>67d4bdd6f5<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment-67d4bdd6f5-w6kd7<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ownerReferences</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>blockOwnerDeletion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment-67d4bdd6f5<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>7d41dfd4-84c0-4be4-88ab-cedbe626ad82<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1364&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>a6501da1-0447-4262-98eb-c03d4002222e<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>128Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>128Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span>/dev/termination-log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePolicy</span>:<span style=color:#bbb> </span>File<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/run/secrets/kubernetes.io/serviceaccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-api-access-bgsgp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirst<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>enableServiceLinks</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>kube-worker-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>preemptionPolicy</span>:<span style=color:#bbb> </span>PreemptLowerPriority<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>default-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoExecute<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node.kubernetes.io/not-ready<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>300</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoExecute<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node.kubernetes.io/unreachable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>300</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-api-access-bgsgp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>420</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3607</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-root-ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T21:51:01Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Initialized<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T21:51:06Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T21:51:06Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ContainersReady<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T21:51:01Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>PodScheduled<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>containerd://5403af59a2b46ee5a23fb0ae4b1e077f7ca5c5fb7af16e1ab21c00e0e616462a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>docker.io/library/nginx:latest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageID</span>:<span style=color:#bbb> </span>docker.io/library/nginx@sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastState</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>restartCount</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>started</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>state</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>running</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>startedAt</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T21:51:05Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostIP</span>:<span style=color:#bbb> </span><span style=color:#666>192.168.0.113</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>phase</span>:<span style=color:#bbb> </span>Running<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.88.0.3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podIPs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>10.88.0.3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>2001</span>:db8::1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Guaranteed<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>startTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T21:51:01Z&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=examine-pod-logs>파드의 로그 확인하기</h2><p>먼저, 확인하고자 하는 컨테이너의 로그를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span>
</span></span></code></pre></div><p>만약 컨테이너가 이전에 크래시 되었다면, 다음의 명령을 통해 컨테이너의 크래시 로그를 살펴볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs --previous <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span>
</span></span></code></pre></div><h2 id=container-exec>exec를 통해 컨테이너 디버깅하기</h2><p>만약 <a class=glossary-tooltip title='컨테이너의 저장된 인스턴스이며, 애플리케이션 구동에 필요한 소프트웨어 집합을 가지고 있다.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='컨테이너 이미지'>컨테이너 이미지</a>에
디버깅 도구가 포함되어 있다면, <code>kubectl exec</code>을 통해 특정 컨테이너에서 해당 명령들을
실행할 수 있다. (리눅스나 윈도우 OS를 기반으로 만들어진 이미지에는 대부분 디버깅 도구를 포함하고
있다.)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span> -c <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTAINER_NAME</span><span style=color:#b68;font-weight:700>}</span> -- <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CMD</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARG1</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARG2</span><span style=color:#b68;font-weight:700>}</span> ... <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARGN</span><span style=color:#b68;font-weight:700>}</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>-c ${CONTAINER_NAME}</code> 인자는 선택적이다. 만약 하나의 컨테이너만 포함된 파드라면 해당 옵션을 생략할 수 있다.</div><p>예를 들어, 동작 중인 카산드라 파드의 로그를 살펴보기 위해서는 다음과 같은 명령을 실행할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> cassandra -- cat /var/log/cassandra/system.log
</span></span></code></pre></div><p><code>kubectl exec</code>에 <code>-i</code>와 <code>-t</code> 옵션을 사용해서 터미널에서 접근할 수 있는 쉘을 실행시킬 수도 있다.
예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it cassandra -- sh
</span></span></code></pre></div><p>더욱 상세한 내용은
<a href=/ko/docs/tasks/debug/debug-application/get-shell-running-container/>동작중인 컨테이너의 쉘에 접근하기</a>를 참고한다.</p><h2 id=ephemeral-container>임시(ephemeral) 디버그 컨테이너를 사용해서 디버깅하기</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><p>컨테이너가 크래시 됐거나
<a href=https://github.com/GoogleContainerTools/distroless>distroless 이미지</a>처럼
컨테이너 이미지에 디버깅 도구를 포함하고 있지 않아 <code>kubectl exec</code>로는 충분하지 않은 경우에는
<a class=glossary-tooltip title='파드 내에 임시적으로 실행할 수 있는 컨테이너 타입' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ephemeral-containers/ target=_blank aria-label='임시(Ephemeral) 컨테이너'>임시(Ephemeral) 컨테이너</a>를 사용하는 것이
인터랙티브한 트러블슈팅에 유용하다.</p><h3 id=ephemeral-container-example>임시 컨테이너를 사용한 디버깅 예시</h3><p><code>kubectl debug</code> 명령어를 사용해서 동작 중인 파드에 임시 컨테이너를 추가할 수 있다.
먼저, 다음과 같이 파드를 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run ephemeral-demo --image<span style=color:#666>=</span>registry.k8s.io/pause:3.1 --restart<span style=color:#666>=</span>Never
</span></span></code></pre></div><p>이 섹션의 예시에서는 디버깅 도구가 포함되지 않은 이미지의 사례를 보여드리기 위해
<code>pause</code> 컨테이너 이미지를 사용했는데, 이 대신 어떠한 이미지를 사용해도
될 것이다.</p><p>만약 <code>kubectl exec</code>을 통해 쉘을 생성하려 한다면 다음과 같은 에러를
확인할 수 있을 텐데, 그 이유는 이 이미지에 쉘이 존재하지 않기 때문이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it ephemeral-demo -- sh
</span></span></code></pre></div><pre tabindex=0><code>OCI runtime exec failed: exec failed: container_linux.go:346: starting container process caused &#34;exec: \&#34;sh\&#34;: executable file not found in $PATH&#34;: unknown
</code></pre><p>이 명령어 대신 <code>kubectl debug</code>을 사용해서 디버깅 컨테이너를 생성할 수 있다.
만약 <code>-i</code>/<code>--interactive</code> 인자를 사용한다면, <code>kubectl</code>은 임시
컨테이너의 콘솔에 자동으로 연결할 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl debug -it ephemeral-demo --image<span style=color:#666>=</span>busybox --target<span style=color:#666>=</span>ephemeral-demo
</span></span></code></pre></div><pre tabindex=0><code>Defaulting debug container name to debugger-8xzrl.
If you don&#39;t see a command prompt, try pressing enter.
/ #
</code></pre><p>이 명령어는 새로운 busybox 컨테이너를 추가하고 해당 컨테이너로 연결한다. <code>--target</code>
파라미터를 사용하면 다른 컨테이너의 프로세스 네임스페이스를 대상으로 하게 된다. 여기서는
이 옵션이 꼭 필요한데, <code>kubectl run</code>이 생성하는 파드에 대해
<a href=/docs/tasks/configure-pod-container/share-process-namespace/>프로세스 네임스페이스 공유</a>를
활성화하지 않기 때문이다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>--target</code> 파라미터는 사용 중인
<a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>에서
지원해야지만 사용할 수 있다. 만일 지원되지 않는다면,
임시 컨테이너가 시작되지 않을 수 있거나 독립적인 프로세스
네임스페이스를 가지고 시작될 수 있다.</div><p><code>kubectl describe</code> 명령을 사용하면 새롭게 생성된 임시 컨테이너의 상태를 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod ephemeral-demo
</span></span></code></pre></div><pre tabindex=0><code>...
Ephemeral Containers:
  debugger-8xzrl:
    Container ID:   docker://b888f9adfd15bd5739fefaa39e1df4dd3c617b9902082b1cfdc29c4028ffb2eb
    Image:          busybox
    Image ID:       docker-pullable://busybox@sha256:1828edd60c5efd34b2bf5dd3282ec0cc04d47b2ff9caa0b6d4f07a21d1c08084
    Port:           &lt;none&gt;
    Host Port:      &lt;none&gt;
    State:          Running
      Started:      Wed, 12 Feb 2020 14:25:42 +0100
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre><p>디버깅이 다 끝나면 <code>kubectl delete</code>을 통해 파드를 제거할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod ephemeral-demo
</span></span></code></pre></div><h2 id=파드의-복제본을-이용해서-디버깅하기>파드의 복제본을 이용해서 디버깅하기</h2><p>때때로 파드의 설정 옵션에 따라 특정 상황에서 트러블슈팅을 하기가 어려울 수 있다.
예를 들어, 만일 여러분의 컨테이너 이미지가 쉘을 포함하고 있지 않거나, 여러분의
애플리케이션이 컨테이너 시작에서 크래시가 발생한다면 <code>kubectl exec</code>을 이용해서
컨테이너를 트러블슈팅할 수 없을 수 있다. 이러한 상황에서는 <code>kubectl debug</code>을 사용해서
파드의 복제본을 디버깅을 위한 추가적인 설정 옵션과 함께 생성할 수 있다.</p><h3 id=새-컨테이너와-함께-파드의-복제본-생성하기>새 컨테이너와 함께 파드의 복제본 생성하기</h3><p>만일 여러분의 애플리케이션이 동작은 하고 있지만 예상과는 다르게 동작하는 경우,
파드의 복제본에 새로운 컨테이너를 추가함으로써 추가적인 트러블슈팅 도구들을
파드에 함께 추가할 수 있다.</p><p>가령, 여러분의 애플리케이션 컨테이너 이미지는 <code>busybox</code>를 기반으로 하고 있는데
여러분은 <code>busybox</code>에는 없는 디버깅 도구를 필요로 한다고 가정해 보자. 이러한
시나리오는 <code>kubectl run</code> 명령을 통해 시뮬레이션 해볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run myapp --image<span style=color:#666>=</span>busybox --restart<span style=color:#666>=</span>Never -- sleep 1d
</span></span></code></pre></div><p>다음의 명령을 실행시켜 디버깅을 위한 새로운 우분투 컨테이너와 함께 <code>myapp-debug</code>이란
이름의 <code>myapp</code> 컨테이너 복제본을 생성할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl debug myapp -it --image<span style=color:#666>=</span>ubuntu --share-processes --copy-to<span style=color:#666>=</span>myapp-debug
</span></span></code></pre></div><pre tabindex=0><code>Defaulting debug container name to debugger-w7xmf.
If you don&#39;t see a command prompt, try pressing enter.
root@myapp-debug:/#
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong><ul><li>만일 여러분이 새로 생성되는 컨테이너의 이름을 <code>--container</code> 플래그와 함께 지정하지 않는다면,
<code>kubectl debug</code>는 자동으로 새로운 컨테이너 이름을 생성한다.</li><li><code>-i</code> 플래그를 사용하면 <code>kubectl debug</code> 명령이 새로운 컨테이너에 기본적으로 연결되게 된다.
이러한 동작은 <code>--attach=false</code>을 지정하여 방지할 수 있다. 만일 여러분의 세션이
연결이 끊어진다면 <code>kubectl attach</code>를 사용해서 다시 연결할 수 있다.</li><li><code>--share-processes</code> 옵션은 이 파드에 있는 컨테이너가 해당 파드에 속한 다른 컨테이너의
프로세스를 볼 수 있도록 한다. 이 옵션이 어떻게 동작하는지에 대해 더 알아보기 위해서는
다음의 <a href=/docs/tasks/configure-pod-container/share-process-namespace/>파드의 컨테이너 간 프로세스 네임스페이스 공유</a>를 참고하라.</li></ul></div><p>사용이 모두 끝나면, 디버깅에 사용된 파드를 잊지 말고 정리한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod myapp myapp-debug
</span></span></code></pre></div><h3 id=명령어를-변경하며-파드의-복제본-생성하기>명령어를 변경하며 파드의 복제본 생성하기</h3><p>때때로 컨테이너의 명령어를 변경하는 것이 유용한 경우가 있는데, 예를 들면 디버그 플래그를 추가하기
위해서나 애플리케이션이 크래시 되는 경우이다.</p><p>다음의 <code>kubectl run</code> 명령을 통해 즉각적으로 크래시가 발생하는 애플리케이션의
사례를 시뮬레이션해 볼 수 있다.</p><pre tabindex=0><code>kubectl run --image=busybox myapp -- false
</code></pre><p><code>kubectl describe pod myapp</code> 명령을 통해 이 컨테이너에 크래시가 발생하고 있음을 확인할 수 있다.</p><pre tabindex=0><code>Containers:
  myapp:
    Image:         busybox
    ...
    Args:
      false
    State:          Waiting
      Reason:       CrashLoopBackOff
    Last State:     Terminated
      Reason:       Error
      Exit Code:    1
</code></pre><p>이러한 경우에 <code>kubectl debug</code>을 통해 명령어를 지정함으로써 해당 파드의
복제본을 인터랙티브 쉘로 생성할 수 있다.</p><pre tabindex=0><code>kubectl debug myapp -it --copy-to=myapp-debug --container=myapp -- sh
</code></pre><pre tabindex=0><code>If you don&#39;t see a command prompt, try pressing enter.
/ #
</code></pre><p>이제 인터랙티브 쉘에 접근할 수 있으니 파일 시스템 경로를 확인하거나
동작 중인 컨테이너의 명령어를 직접 확인하는 등의 작업이 가능하다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><ul><li>특정 컨테이너의 명령어를 변경하기 위해서는 <code>--container</code> 옵션을 통해 해당 컨테이너의
이름을 지정해야만 한다. 이름을 지정하지 않는다면 <code>kubectl debug</code>은 이전에 지정한 명령어를
그대로 사용해서 컨테이너를 생성할 것이다.</li><li>기본적으로 <code>-i</code> 플래그는 <code>kubectl debug</code> 명령이 컨테이너에 바로 연결되도록 한다.
이러한 동작을 방지하기 위해서는 <code>--attach=false</code> 옵션을 지정할 수 있다. 만약 여러분이 세션이
종료된다면 <code>kubectl attach</code> 명령을 통해 다시 연결할 수 있다.</li></ul></div><p>사용이 모두 끝나면, 디버깅에 사용된 파드들을 잊지 말고 정리한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod myapp myapp-debug
</span></span></code></pre></div><h3 id=컨테이너-이미지를-변경하며-파드의-복제본-생성하기>컨테이너 이미지를 변경하며 파드의 복제본 생성하기</h3><p>특정한 경우에 여러분은 제대로 동작하지 않는 파드의 이미지를
기존 프로덕션 컨테이너 이미지에서 디버깅 빌드나 추가적인 도구를 포함한
이미지로 변경하고 싶을 수 있다.</p><p>이 사례를 보여주기 위해 <code>kubectl run</code> 명령을 통해 파드를 생성하였다.</p><pre tabindex=0><code>kubectl run myapp --image=busybox --restart=Never -- sleep 1d
</code></pre><p>여기서는 <code>kubectl debug</code> 명령을 통해 해당 컨테이너 이미지를 <code>ubuntu</code>로 변경하며
복제본을 생성하였다.</p><pre tabindex=0><code>kubectl debug myapp --copy-to=myapp-debug --set-image=*=ubuntu
</code></pre><p><code>--set-image</code>의 문법은 <code>kubectl set image</code>와 동일하게 <code>container_name=image</code>
형식의 문법을 사용한다. <code>*=ubuntu</code>라는 의미는 모든 컨테이너의 이미지를 <code>ubuntu</code>로
변경하겠다는 의미이다.</p><p>사용이 모두 끝나면, 디버깅에 사용된 파드를 잊지 말고 정리한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod myapp myapp-debug
</span></span></code></pre></div><h2 id=node-shell-session>노드의 쉘을 사용해서 디버깅하기</h2><p>만약 위의 어떠한 방법도 사용할 수 없다면, 파드가 현재 동작 중인 노드를 찾아
해당 노드에서 실행되는 파드를 생성할 수 있다.
다음 <code>kubectl debug</code> 명령을 통해 해당 노드에서 인터랙티브한 쉘을 생성할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl debug node/mynode -it --image<span style=color:#666>=</span>ubuntu
</span></span></code></pre></div><pre tabindex=0><code>Creating debugging pod node-debugger-mynode-pdx84 with container debugger on node mynode.
If you don&#39;t see a command prompt, try pressing enter.
root@ek8s:/#
</code></pre><p>노드에서 디버깅 세션을 생성할 때 유의해야 할 점은 다음과 같다.</p><ul><li><code>kubectl debug</code>는 노드의 이름에 기반해 새로운 파드의 이름을
자동으로 생성한다.</li><li>노드의 루트 파일시스템은 <code>/host</code>에 마운트된다.</li><li>파드가 특권을 가지고 있지 않더라도, 컨테이너는 호스트 네임스페이스(IPC, 네트워크, PID 네임스페이스)에서 동작한다. 따라서 몇몇 프로세스 정보를 읽어오거나, <code>chroot /host</code> 등의 작업은 수행될 수 없다.</li><li>특권을 가진 파드가 필요한 경우에는 직접 생성한다.</li></ul><p>사용이 모두 끝나면, 디버깅에 사용된 파드를 잊지 말고 정리한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod node-debugger-mynode-pdx84
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-09530217eead8a801ead3ef165c2f591>2.1.5 - 동작중인 컨테이너의 셸에 접근하기</h1><p>이 페이지는 동작중인 컨테이너에 접근하기 위해 <code>kubectl exec</code>을 사용하는
방법에 대해 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=컨테이너의-셸에-접근하기>컨테이너의 셸에 접근하기</h2><p>이 예시에서는 하나의 컨테이너를 가진 파드를 생성할 것이다. 이 컨테이너는
nginx 이미지를 실행한다. 해당 파드에 대한 설정 파일은 다음과 같다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/shell-demo.yaml download=application/shell-demo.yaml><code>application/shell-demo.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-shell-demo-yaml")' title="Copy application/shell-demo.yaml to clipboard"></img></div><div class=includecode id=application-shell-demo-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>Default<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/shell-demo.yaml
</span></span></code></pre></div><p>다음을 통해 컨테이너가 동작하고 있는지 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod shell-demo
</span></span></code></pre></div><p>동작중인 컨테이너의 셸에 접근한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> --stdin --tty shell-demo -- /bin/bash
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> kubectl 명령어 인자와 사용하고자 하는 명령어의 인자를 구분하기 위해서는 이중 대시(<code>--</code>)를 사용할 수 있다.</div><p>셸에 접근해서 다음처럼 루트 디렉토리를 확인해 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Run this inside the container</span>
</span></span><span style=display:flex><span>ls /
</span></span></code></pre></div><p>접근한 셸에서 다른 명령어도 한번 실행해 보아라. 다음은 실행해 볼
명령의 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># You can run these example commands inside the container</span>
</span></span><span style=display:flex><span>ls /
</span></span><span style=display:flex><span>cat /proc/mounts
</span></span><span style=display:flex><span>cat /proc/1/maps
</span></span><span style=display:flex><span>apt-get update
</span></span><span style=display:flex><span>apt-get install -y tcpdump
</span></span><span style=display:flex><span>tcpdump
</span></span><span style=display:flex><span>apt-get install -y lsof
</span></span><span style=display:flex><span>lsof
</span></span><span style=display:flex><span>apt-get install -y procps
</span></span><span style=display:flex><span>ps aux
</span></span><span style=display:flex><span>ps aux | grep nginx
</span></span></code></pre></div><h2 id=nginx의-최상단-페이지-작성하기>nginx의 최상단 페이지 작성하기</h2><p>앞에서 생성한 파드에 대한 설정을 살펴보아라. 파드에는
<code>emptyDir</code> 볼륨이 사용되었고, 이 컨테이너는 해당 볼륨을
<code>/usr/share/nginx/html</code> 경로에 마운트하였다.</p><p>접근한 셸 환경에서 <code>/usr/share/nginx/html</code> 디렉터리에 <code>index.html</code> 파일을
생성해 보아라.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Run this inside the container</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;Hello shell demo&#39;</span> &gt; /usr/share/nginx/html/index.html
</span></span></code></pre></div><p>셸 환경에서 nginx 서버에 GET 요청을 시도해보면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Run this in the shell inside your container</span>
</span></span><span style=display:flex><span>apt-get update
</span></span><span style=display:flex><span>apt-get install curl
</span></span><span style=display:flex><span>curl http://localhost/
</span></span></code></pre></div><p>출력 결과는 여러분이 <code>index.html</code> 파일에 작성한 텍스트를 출력할 것이다.</p><pre tabindex=0><code>Hello shell demo
</code></pre><p>셸 사용이 모두 끝났다면 <code>exit</code>을 입력해 종료하라.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>exit</span> <span style=color:#080;font-style:italic># To quit the shell in the container</span>
</span></span></code></pre></div><h2 id=컨테이너에서-개별-명령어-실행하기>컨테이너에서 개별 명령어 실행하기</h2><p>셸이 아닌 일반적인 커맨드 환경에서 다음처럼 동작중인 컨테이너의
환경 변수를 출력할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo env
</span></span></code></pre></div><p>다른 명령어도 한번 실행해 보아라. 다음은 실행해 볼 명령의 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo -- ps aux
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo -- ls /
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo -- cat /proc/1/mounts
</span></span></code></pre></div><h2 id=파드에-한-개-이상의-컨테이너가-있을-경우-셸에-접근하기>파드에 한 개 이상의 컨테이너가 있을 경우 셸에 접근하기</h2><p>만일 파드에 한 개 이상의 컨테이너가 있을 경우, <code>kubectl exec</code> 명령어에
<code>--container</code> 혹은 <code>-c</code> 옵션을 사용해서 컨테이너를 지정하라. 예를 들어,
여러분이 my-pod라는 이름의 파드가 있다고 가정해 보자. 이 파드에는 <em>main-app</em> 과
<em>helper-app</em> 이라는 이름의 두 컨테이너가 있다. 다음 명령어는 <em>main-app</em>
컨테이너에 대한 셸에 접근할 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t my-pod --container main-app -- /bin/bash
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 축약형 옵션인 <code>-i</code> 와 <code>-t</code> 는 각각 <code>--stdin</code> 와 <code>--tty</code> 옵션에 대응된다.</div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>를 참고한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-655b47c523b6f1b52d25e520625abccb>2.1.6 - 파드 실패의 원인 검증하기</h1><p>이 페이지는 컨테이너 종료 메시지를 읽고 쓰는
방법을 보여준다.</p><p>종료 메시지는 컨테이너가 치명적인 이벤트에 대한 정보를,
대시보드나 모니터링 소프트웨어 도구와 같이
쉽게 조회 및 표시할 수 있는 위치에
기록하는 방법을 제공한다.
대부분의 경우에 종료 메시지에 넣는 정보는
일반
<a href=/ko/docs/concepts/cluster-administration/logging/>쿠버네티스 로그</a>에도 쓰여져야 한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=종료-메시지-읽기-및-쓰기>종료 메시지 읽기 및 쓰기</h2><p>이 예제에서는, 하나의 컨테이너를 실행하는 파드를 생성한다.
하단의 설정 파일은 컨테이너가 시작될 때 수행하는
명령어를 지정한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/debug/termination.yaml download=debug/termination.yaml><code>debug/termination.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("debug-termination-yaml")' title="Copy debug/termination.yaml to clipboard"></img></div><div class=includecode id=debug-termination-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep 10 &amp;&amp; echo Sleep expired &gt; /dev/termination-log&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>다음의 YAML 설정 파일에 기반한 파드를 생성한다.</p><pre><code> kubectl apply -f https://k8s.io/examples/debug/termination.yaml

YAML 파일에 있는 `command` 와 `args` 필드에서 컨테이너가 10초 간 잠든 뒤에
&quot;Sleep expired&quot; 문자열을 `/dev/termination-log` 파일에 기록하는
것을 확인할 수 있다. 컨테이너는 &quot;Sleep expired&quot; 메시지를
기록한 후에 종료된다.
</code></pre></li><li><p>파드와 관련된 정보를 출력한다.</p><pre><code> kubectl get pod termination-demo

파드가 더 이상 실행되지 않을 때까지 앞선 명령어를 반복한다.
</code></pre></li><li><p>파드에 관한 상세 정보를 출력한다.</p><pre><code> kubectl get pod termination-demo --output=yaml

결과는 &quot;Sleep expired&quot; 메시지를 포함한다.

 apiVersion: v1
 kind: Pod
 ...
     lastState:
       terminated:
         containerID: ...
         exitCode: 0
         finishedAt: ...
         message: |
           Sleep expired
         ...
</code></pre></li><li><p>종료 메시지만을 포함하는 출력 결과를 보기
위해서는 Go 템플릿을 사용한다.</p><pre><code> kubectl get pod termination-demo -o go-template=&quot;{{range .status.containerStatuses}}{{.lastState.terminated.message}}{{end}}&quot;
</code></pre></li></ol><p>여러 컨테이너를 포함하는 파드의 경우, Go 템플릿을 사용하여 컨테이너 이름도 출력할 수 있다. 이렇게 하여, 어떤 컨테이너가 실패하는지 찾을 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod multi-container-pod -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .status.containerStatuses}}{{printf &#34;%s:\n%s\n\n&#34; .name .lastState.terminated.message}}{{end}}&#39;</span>
</span></span></code></pre></div><h2 id=종료-메시지-사용자-정의하기>종료 메시지 사용자 정의하기</h2><p>쿠버네티스는 컨테이너의 <code>terminationMessagePath</code> 필드에 지정된
종료 메시지 파일에서 종료 메시지를 검색하며, 이 필드의 기본값은
<code>/dev/termination-log</code> 이다. 이 필드를 사용자 정의 함으로써
쿠버네티스가 종료 메시지를 검색할 때 다른 파일을 사용하도록 조정할 수 있다.
쿠버네티스는 지정된 파일의 내용을 사용하여 컨테이너의 성공 및 실패에 대한 상태 메시지를 채운다.</p><p>종료 메시지는 assertion failure 메세지처럼 간결한 최종 상태로 생성된다.
kubelet은 4096 바이트보다 긴 메시지를 자른다.</p><p>모든 컨테이너의 총 메시지 길이는 12KiB로 제한되며, 각 컨테이너에 균등하게 분할된다.
예를 들어, 12개의 컨테이너(<code>initContainers</code> 또는 <code>containers</code>)가 있는 경우 각 컨테이너에는 1024 바이트의 사용 가능한 종료 메시지 공간이 있다.</p><p>기본 종료 메시지 경로는 <code>/dev/termination-log</code>이다.
파드가 시작된 후에는 종료 메시지 경로를 설정할 수 없다.</p><p>다음의 예제에서 컨테이너는, 쿠버네티스가 조회할 수 있도록
<code>/tmp/my-log</code> 파일에 종료 메시지를 기록한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp/my-log&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>또한 사용자는 추가적인 사용자 정의를 위해 컨테이너의 <code>terminationMessagePolicy</code>
필드를 설정할 수 있다. 이 필드의 기본 값은 <code>File</code> 이며,
이는 오직 종료 메시지 파일에서만 종료 메시지가 조회되는 것을 의미한다.
<code>terminationMessagePolicy</code> 필드의 값을 "<code>FallbackToLogsOnError</code> 으로
설정함으로써, 종료 메시지 파일이 비어 있고 컨테이너가 오류와 함께 종료 되었을 경우
쿠버네티스가 컨테이너 로그 출력의 마지막 청크를 사용하도록 지시할 수 있다.
로그 출력은 2048 바이트나 80 행 중 더 작은 값으로 제한된다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>컨테이너</a>
에 있는 <code>terminationMessagePath</code> 에 대해 읽어보기.</li><li><a href=/ko/docs/concepts/cluster-administration/logging/>로그 검색</a>에 대해 배워보기.</li><li><a href=https://golang.org/pkg/text/template/>Go 템플릿</a>에 대해 배워보기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ce321f5c35198a1d9b64d52a98ba705c>2.2 - 클러스터 트러블슈팅</h1><div class=lead>일반적인 클러스터 이슈를 디버깅한다.</div><p>이 문서는 클러스터 트러블슈팅에 대해 설명한다. 사용자가 겪고 있는 문제의 근본 원인으로서 사용자의 애플리케이션을
이미 배제했다고 가정한다.
애플리케이션 디버깅에 대한 팁은 <a href=/ko/docs/tasks/debug/debug-application/>애플리케이션 트러블슈팅 가이드</a>를 참조한다.
자세한 내용은 <a href=/ko/docs/tasks/debug/>트러블슈팅 문서</a>를 참조한다.</p><h2 id=클러스터-나열하기>클러스터 나열하기</h2><p>클러스터에서 가장 먼저 디버그해야 할 것은 노드가 모두 올바르게 등록되었는지 여부이다.</p><p>다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><p>그리고 보일 것으로 예상되는 모든 노드가 존재하고 모두 <code>Ready</code> 상태인지 확인한다.</p><p>클러스터의 전반적인 상태에 대한 자세한 정보를 얻으려면 다음을 실행할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info dump
</span></span></code></pre></div><h3 id=예제-다운-down-상태이거나-통신이-닿지-않는-unreachable-노드-디버깅하기>예제: 다운(down) 상태이거나 통신이 닿지 않는(unreachable) 노드 디버깅하기</h3><p>때때로 디버깅할 때 노드의 상태를 확인하는 것이 유용할 수 있다(예를 들어, 어떤 노드에서 실행되는 파드가 이상하게 행동하는 것을 발견했거나, 특정 노드에 파드가 스케줄링되지 않는 이유를 알아보기 위해). 파드의 경우와 마찬가지로, <code>kubectl describe node</code> 및 <code>kubectl get node -o yaml</code> 명령을 사용하여 노드에 대한 상세 정보를 볼 수 있다. 예를 들어, 노드가 다운 상태(네트워크 연결이 끊어졌거나, kubelet이 종료된 후 재시작되지 못했거나 등)라면 아래와 같은 출력이 나올 것이다. 노드가 NotReady 상태라는 것을 나타내는 이벤트(event)와, 더 이상 실행 중이 아닌 파드(NotReady 상태 이후 5분 뒤에 축출되었음)에 주목한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                     STATUS       ROLES     AGE     VERSION
kube-worker-1            NotReady     &lt;none&gt;    1h      v1.23.3
kubernetes-node-bols     Ready        &lt;none&gt;    1h      v1.23.3
kubernetes-node-st6x     Ready        &lt;none&gt;    1h      v1.23.3
kubernetes-node-unaj     Ready        &lt;none&gt;    1h      v1.23.3
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node kube-worker-1
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Name:               kube-worker-1
Roles:              &lt;none&gt;
Labels:             beta.kubernetes.io/arch=amd64
                    beta.kubernetes.io/os=linux
                    kubernetes.io/arch=amd64
                    kubernetes.io/hostname=kube-worker-1
                    kubernetes.io/os=linux
Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: /run/containerd/containerd.sock
                    node.alpha.kubernetes.io/ttl: 0
                    volumes.kubernetes.io/controller-managed-attach-detach: true
CreationTimestamp:  Thu, 17 Feb 2022 16:46:30 -0500
Taints:             node.kubernetes.io/unreachable:NoExecute
                    node.kubernetes.io/unreachable:NoSchedule
Unschedulable:      false
Lease:
  HolderIdentity:  kube-worker-1
  AcquireTime:     &lt;unset&gt;
  RenewTime:       Thu, 17 Feb 2022 17:13:09 -0500
Conditions:
  Type                 Status    LastHeartbeatTime                 LastTransitionTime                Reason              Message
  ----                 ------    -----------------                 ------------------                ------              -------
  NetworkUnavailable   False     Thu, 17 Feb 2022 17:09:13 -0500   Thu, 17 Feb 2022 17:09:13 -0500   WeaveIsUp           Weave pod has set this
  MemoryPressure       Unknown   Thu, 17 Feb 2022 17:12:40 -0500   Thu, 17 Feb 2022 17:13:52 -0500   NodeStatusUnknown   Kubelet stopped posting node status.
  DiskPressure         Unknown   Thu, 17 Feb 2022 17:12:40 -0500   Thu, 17 Feb 2022 17:13:52 -0500   NodeStatusUnknown   Kubelet stopped posting node status.
  PIDPressure          Unknown   Thu, 17 Feb 2022 17:12:40 -0500   Thu, 17 Feb 2022 17:13:52 -0500   NodeStatusUnknown   Kubelet stopped posting node status.
  Ready                Unknown   Thu, 17 Feb 2022 17:12:40 -0500   Thu, 17 Feb 2022 17:13:52 -0500   NodeStatusUnknown   Kubelet stopped posting node status.
Addresses:
  InternalIP:  192.168.0.113
  Hostname:    kube-worker-1
Capacity:
  cpu:                2
  ephemeral-storage:  15372232Ki
  hugepages-2Mi:      0
  memory:             2025188Ki
  pods:               110
Allocatable:
  cpu:                2
  ephemeral-storage:  14167048988
  hugepages-2Mi:      0
  memory:             1922788Ki
  pods:               110
System Info:
  Machine ID:                 9384e2927f544209b5d7b67474bbf92b
  System UUID:                aa829ca9-73d7-064d-9019-df07404ad448
  Boot ID:                    5a295a03-aaca-4340-af20-1327fa5dab5c
  Kernel Version:             5.13.0-28-generic
  OS Image:                   Ubuntu 21.10
  Operating System:           linux
  Architecture:               amd64
  Container Runtime Version:  containerd://1.5.9
  Kubelet Version:            v1.23.3
  Kube-Proxy Version:         v1.23.3
Non-terminated Pods:          (4 in total)
  Namespace                   Name                                 CPU Requests  CPU Limits  Memory Requests  Memory Limits  Age
  ---------                   ----                                 ------------  ----------  ---------------  -------------  ---
  default                     nginx-deployment-67d4bdd6f5-cx2nz    500m (25%)    500m (25%)  128Mi (6%)       128Mi (6%)     23m
  default                     nginx-deployment-67d4bdd6f5-w6kd7    500m (25%)    500m (25%)  128Mi (6%)       128Mi (6%)     23m
  kube-system                 kube-proxy-dnxbz                     0 (0%)        0 (0%)      0 (0%)           0 (0%)         28m
  kube-system                 weave-net-gjxxp                      100m (5%)     0 (0%)      200Mi (10%)      0 (0%)         28m
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  Resource           Requests     Limits
  --------           --------     ------
  cpu                1100m (55%)  1 (50%)
  memory             456Mi (24%)  256Mi (13%)
  ephemeral-storage  0 (0%)       0 (0%)
  hugepages-2Mi      0 (0%)       0 (0%)
Events:
...
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get node kube-worker-1 -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Node<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeadm.alpha.kubernetes.io/cri-socket</span>:<span style=color:#bbb> </span>/run/containerd/containerd.sock<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>node.alpha.kubernetes.io/ttl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumes.kubernetes.io/controller-managed-attach-detach</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T21:46:30Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>beta.kubernetes.io/arch</span>:<span style=color:#bbb> </span>amd64<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>beta.kubernetes.io/os</span>:<span style=color:#bbb> </span>linux<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/arch</span>:<span style=color:#bbb> </span>amd64<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>kube-worker-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>linux<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-worker-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4026&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>98efe7cb-2978-4a0b-842a-1a7bf12c05f8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>address</span>:<span style=color:#bbb> </span><span style=color:#666>192.168.0.113</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>InternalIP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>address</span>:<span style=color:#bbb> </span>kube-worker-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Hostname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allocatable</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;14167048988&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hugepages-2Mi</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1922788Ki<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;110&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span>15372232Ki<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hugepages-2Mi</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>2025188Ki<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;110&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastHeartbeatTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T22:20:32Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T22:20:32Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>Weave pod has set this<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>WeaveIsUp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NetworkUnavailable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastHeartbeatTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T22:20:15Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T22:13:25Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>kubelet has sufficient memory available<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>KubeletHasSufficientMemory<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>MemoryPressure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastHeartbeatTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T22:20:15Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T22:13:25Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>kubelet has no disk pressure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>KubeletHasNoDiskPressure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DiskPressure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastHeartbeatTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T22:20:15Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T22:13:25Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>kubelet has sufficient PID available<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>KubeletHasSufficientPID<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>PIDPressure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastHeartbeatTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T22:20:15Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-02-17T22:15:15Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>kubelet is posting ready status. AppArmor enabled<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>KubeletReady<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>daemonEndpoints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeletEndpoint</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>Port</span>:<span style=color:#bbb> </span><span style=color:#666>10250</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeInfo</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>architecture</span>:<span style=color:#bbb> </span>amd64<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>bootID</span>:<span style=color:#bbb> </span><span style=color:#666>22333234</span>-7a6b-44d4-9ce1-67e31dc7e369<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containerRuntimeVersion</span>:<span style=color:#bbb> </span>containerd://1.5.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kernelVersion</span>:<span style=color:#bbb> </span><span style=color:#666>5.13.0-28</span>-generic<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeProxyVersion</span>:<span style=color:#bbb> </span>v1.23.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeletVersion</span>:<span style=color:#bbb> </span>v1.23.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>machineID</span>:<span style=color:#bbb> </span>9384e2927f544209b5d7b67474bbf92b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operatingSystem</span>:<span style=color:#bbb> </span>linux<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>osImage</span>:<span style=color:#bbb> </span>Ubuntu 21.10<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>systemUUID</span>:<span style=color:#bbb> </span>aa829ca9-73d7-064d-9019-df07404ad448<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=로그-보기>로그 보기</h2><p>현재로서는 클러스터를 더 깊이 파고들려면 관련 머신에서 로그 확인이 필요하다. 관련 로그 파일
위치는 다음과 같다. (systemd 기반 시스템에서는 <code>journalctl</code>을 대신 사용해야 할 수도 있다.)</p><h3 id=컨트롤-플레인-노드>컨트롤 플레인 노드</h3><ul><li><code>/var/log/kube-apiserver.log</code> - API 서버, API 제공을 담당</li><li><code>/var/log/kube-scheduler.log</code> - 스케줄러, 스케줄 결정을 담당</li><li><code>/var/log/kube-controller-manager.log</code> - 레플리케이션 컨트롤러를 담당하는 컨트롤러</li></ul><h3 id=워커-노드>워커 노드</h3><ul><li><code>/var/log/kubelet.log</code> - Kubelet, 노드에서 컨테이너 실행을 담당</li><li><code>/var/log/kube-proxy.log</code> - Kube Proxy, 서비스 로드밸런싱을 담당</li></ul><h2 id=클러스터-장애-모드>클러스터 장애 모드</h2><p>아래에 일부 오류 상황 예시 및 문제를 완화하기 위해 클러스터 설정을 조정하는 방법을 나열한다.</p><h3 id=근본-원인>근본 원인</h3><ul><li>VM(들) 종료</li><li>클러스터 내 또는 클러스터와 사용자 간의 네트워크 분할</li><li>쿠버네티스 소프트웨어의 충돌</li><li>데이터 손실 또는 퍼시스턴트 스토리지 사용 불가 (e.g. GCE PD 또는 AWS EBS 볼륨)</li><li>운영자 오류, 예를 들면 잘못 구성된 쿠버네티스 소프트웨어 또는 애플리케이션 소프트웨어</li></ul><h3 id=특정-시나리오>특정 시나리오</h3><ul><li>API 서버 VM 종료 또는 API 서버 충돌<ul><li>다음의 현상을 유발함<ul><li>새로운 파드, 서비스, 레플리케이션 컨트롤러를 중지, 업데이트 또는 시작할 수 없다.</li><li>쿠버네티스 API에 의존하지 않는 기존 파드 및 서비스는 계속 정상적으로 작동할 것이다.</li></ul></li></ul></li><li>API 서버 백업 스토리지 손실<ul><li>다음의 현상을 유발함<ul><li>API 서버가 구동되지 않을 것이다.</li><li>kubelet에 도달할 수 없게 되지만, kubelet이 여전히 동일한 파드를 계속 실행하고 동일한 서비스 프록시를 제공할 것이다.</li><li>API 서버를 재시작하기 전에, 수동으로 복구하거나 API서버 상태를 재생성해야 한다.</li></ul></li></ul></li><li>지원 서비스 (노드 컨트롤러, 레플리케이션 컨트롤러 매니저, 스케쥴러 등) VM 종료 또는 충돌<ul><li>현재 그것들은 API 서버와 같은 위치에 있기 때문에 API 서버와 비슷한 상황을 겪을 것이다.</li><li>미래에는 이들도 복제본을 가질 것이며 API서버와 별도로 배치될 수도 있다.</li><li>지원 서비스들은 상태(persistent state)를 자체적으로 유지하지는 않는다.</li></ul></li><li>개별 노드 (VM 또는 물리적 머신) 종료<ul><li>다음의 현상을 유발함<ul><li>해당 노드의 파드가 실행을 중지</li></ul></li></ul></li><li>네트워크 분할<ul><li>다음의 현상을 유발함<ul><li>파티션 A는 파티션 B의 노드가 다운되었다고 생각한다. 파티션 B는 API 서버가 다운되었다고 생각한다. (마스터 VM이 파티션 A에 있다고 가정)</li></ul></li></ul></li><li>Kubelet 소프트웨어 오류<ul><li>다음의 현상을 유발함<ul><li>충돌한 kubelet은 노드에서 새 파드를 시작할 수 없다.</li><li>kubelet이 파드를 삭제할 수도 있고 삭제하지 않을 수도 있다.</li><li>노드는 비정상으로 표시된다.</li><li>레플리케이션 컨트롤러는 다른 곳에서 새 파드를 시작한다.</li></ul></li></ul></li><li>클러스터 운영자 오류<ul><li>다음의 현상을 유발함<ul><li>파드, 서비스 등의 손실</li><li>API 서버 백업 저장소 분실</li><li>API를 읽을 수 없는 사용자</li><li>기타</li></ul></li></ul></li></ul><h3 id=완화>완화</h3><ul><li><p>조치: IaaS VM을 위한 IaaS 공급자의 자동 VM 다시 시작 기능을 사용한다.</p><ul><li>다음을 완화할 수 있음: API 서버 VM 종료 또는 API 서버 충돌</li><li>다음을 완화할 수 있음: 지원 서비스 VM 종료 또는 충돌</li></ul></li><li><p>조치: API 서버+etcd가 있는 VM에 IaaS 제공자의 안정적인 스토리지(예: GCE PD 또는 AWS EBS 볼륨)를 사용한다.</p><ul><li>다음을 완화할 수 있음: API 서버 백업 스토리지 손실</li></ul></li><li><p>조치: <a href=/docs/setup/production-environment/tools/kubeadm/high-availability/>고가용성</a> 구성을 사용한다.</p><ul><li>다음을 완화할 수 있음: 컨트롤 플레인 노드 종료 또는 컨트롤 플레인 구성 요소(스케줄러, API 서버, 컨트롤러 매니저) 충돌<ul><li>동시에 발생하는 하나 이상의 노드 또는 구성 요소 오류를 허용한다.</li></ul></li><li>다음을 완화할 수 있음: API 서버 백업 스토리지(i.e., etcd의 데이터 디렉터리) 손실<ul><li>고가용성 etcd 구성을 사용하고 있다고 가정</li></ul></li></ul></li><li><p>조치: API 서버 PD/EBS 볼륨의 주기적인 스냅샷</p><ul><li>다음을 완화할 수 있음: API 서버 백업 스토리지 손실</li><li>다음을 완화할 수 있음: 일부 운영자 오류 사례</li><li>다음을 완화할 수 있음: 일부 쿠버네티스 소프트웨어 오류 사례</li></ul></li><li><p>조치: 파드 앞에 레플리케이션 컨트롤러와 서비스 사용</p><ul><li>다음을 완화할 수 있음: 노드 종료</li><li>다음을 완화할 수 있음: Kubelet 소프트웨어 오류</li></ul></li><li><p>조치: 예기치 않은 재시작을 허용하도록 설계된 애플리케이션(컨테이너)</p><ul><li>다음을 완화할 수 있음: 노드 종료</li><li>다음을 완화할 수 있음: Kubelet 소프트웨어 오류</li></ul></li></ul><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/>리소스 메트릭 파이프라인</a>에서 사용할 수 있는 메트릭에 대해 알아 본다.</li><li><a href=/ko/docs/tasks/debug/debug-cluster/resource-usage-monitoring/>리소스 사용량 모니터링</a>을 위한 추가 도구에 대해 알아 본다.</li><li>Node Problem Detector를 사용하여 <a href=/ko/docs/tasks/debug/debug-cluster/monitor-node-health/>노드 헬스(health)를 모니터링</a>한다.</li><li><code>crictl</code>을 사용하여 <a href=/ko/docs/tasks/debug/debug-cluster/crictl/>쿠버네티스 노드를 디버깅</a>한다.</li><li><a href=/ko/docs/tasks/debug/debug-cluster/audit/>쿠버네티스 감사(auditing)</a>에 대한 더 자세한 정보를 본다.</li><li><code>telepresence</code>를 사용하여 <a href=/ko/docs/tasks/debug/debug-cluster/local-debugging/>서비스를 로컬에서 개발 및 디버깅</a>한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5ff0cdcf7701f887e45d629f5cfe0424>2.2.1 - 리소스 메트릭 파이프라인</h1><p>쿠버네티스에서, <em>메트릭 API(Metrics API)</em> 는 자동 스케일링 및 비슷한 사용 사례를 지원하기 위한 기본적인 메트릭 집합을 제공한다.
이 API는 노드와 파드의 리소스 사용량 정보를 제공하며,
여기에는 CPU 및 메모리 메트릭이 포함된다.
메트릭 API를 클러스터에 배포하면, 쿠버네티스 API의 클라이언트는 이 정보에 대해 질의할 수 있으며,
질의 권한을 관리하기 위해 쿠버네티스의 접근 제어 메커니즘을 이용할 수 있다.</p><p><a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/>HorizontalPodAutoscaler</a>(HPA) 및
<a href=https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler#readme>VerticalPodAutoscaler</a>(VPA)는
사용자의 요구 사항을 만족할 수 있도록 워크로드 레플리카와 리소스를 조정하는 데에 메트릭 API의 데이터를 이용한다.</p><p><a href=/docs/reference/generated/kubectl/kubectl-commands#top><code>kubectl top</code></a>
명령을 이용하여
리소스 메트릭을 볼 수도 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 메트릭 API 및 이것이 제공하는 메트릭 파이프라인은
HPA / VPA 에 의한 자동 스케일링이 동작하는 데 필요한
최소한의 CPU 및 메모리 메트릭만을 제공한다.
더 많은 메트릭 집합을 제공하려면, <em>커스텀 메트릭 API</em> 를 사용하는
추가 <a href=/ko/docs/tasks/debug/debug-cluster/resource-usage-monitoring/#full-metrics-pipeline>메트릭 파이프라인</a>을 배포하여
기본 메트릭 API를 보충할 수 있다.</div><p>그림 1은 리소스 메트릭 파이프라인의 아키텍처를 나타낸다.</p><figure><div class=mermaid>flowchart RL
subgraph cluster[클러스터]
direction RL
S[<br><br>]
A[Metrics-<br>Server]
subgraph B[노드]
direction TB
D[cAdvisor] --> C[kubelet]
E[컨테이너<br>런타임] --> D
E1[컨테이너<br>런타임] --> D
P[파드 데이터] -.- C
end
L[API<br>서버]
W[HPA]
C ---->|요약<br>API| A -->|메트릭<br>API| L --> W
end
L ---> K[kubectl<br>top]
classDef box fill:#fff,stroke:#000,stroke-width:1px,color:#000;
class W,B,P,K,cluster,D,E,E1 box
classDef spacewhite fill:#ffffff,stroke:#fff,stroke-width:0px,color:#000
class S spacewhite
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:1px,color:#fff;
class A,L,C k8s</div></figure><noscript><div class="alert alert-secondary callout" role=alert><em class=javascript-required>이 컨텐츠를 보려면 자바스크립트가 <a href=https://www.enable-javascript.com/>활성화</a>되어 있어야 합니다.</em></div></noscript><p>그림 1. 리소스 메트릭 파이프라인</p><p>그림의 오른쪽에서 왼쪽 순으로, 아키텍처 구성 요소는 다음과 같다.</p><ul><li><p><a href=https://github.com/google/cadvisor>cAdvisor</a>: kubelet에 포함된 컨테이너 메트릭을
수집, 집계, 노출하는 데몬</p></li><li><p><a href=/ko/docs/concepts/overview/components/#kubelet>kubelet</a>: 컨테이너 리소스 관리를 위한 노드 에이전트.
리소스 메트릭은 kubelet API 엔드포인트 <code>/metrics/resource</code> 및
<code>/stats</code> 를 사용하여 접근 가능하다.</p></li><li><p><a href=#summary-api-source>요약 API</a>: <code>/stats</code> 엔드포인트를 통해 사용할 수 있는
노드 별 요약된 정보를 탐색 및 수집할 수 있도록 kubelet이 제공하는 API</p></li><li><p><a href=#metrics-server>metrics-server</a>: 각 kubelet으로부터 수집한 리소스 메트릭을 수집 및 집계하는 클러스터 애드온 구성 요소.
API 서버는 HPA, VPA 및 <code>kubectl top</code> 명령어가 사용할 수 있도록 메트릭 API를 제공한다.
metrics-server는 메트릭 API에 대한 기준 구현(reference implementation) 중 하나이다.</p></li><li><p><a href=#metrics-api>메트릭 API</a>: 워크로드 오토스케일링에 사용되는 CPU 및 메모리 정보로의 접근을 지원하는 쿠버네티스 API.
이를 클러스터에서 사용하려면,
메트릭 API를 제공하는 API 확장(extension) 서버가 필요하다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> cAdvisor는 cgroups으로부터 메트릭을 가져오는 것을 지원하며, 리눅스의 일반적인 컨테이너 런타임은 이를 지원한다.
만약 다른 리소스 격리 메커니즘(예: 가상화)을 사용하는 컨테이너 런타임을 사용한다면,
kubelet이 메트릭을 사용할 수 있기 위해서는
해당 컨테이너 런타임이
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/cri-container-stats.md>CRI 컨테이너 메트릭</a>을 지원해야 한다.</div></li></ul><h2 id=metrics-api>메트릭 API</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes 1.8 [beta]</code></div><p>metrics-server는 메트릭 API에 대한 구현이다.
이 API는 클러스터 내 노드와 파드의 CPU 및 메모리 사용 정보에 접근할 수 있게 해 준다.
이것의 주 역할은 리소스 사용 메트릭을 쿠버네티스 오토스케일러 구성 요소에 제공하는 것이다.</p><p>다음은 <code>minikube</code> 노드에 대한 메트릭 API 요청 예시이며
가독성 향상을 위해 <code>jq</code>를 활용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --raw <span style=color:#b44>&#34;/apis/metrics.k8s.io/v1beta1/nodes/minikube&#34;</span> | jq <span style=color:#b44>&#39;.&#39;</span>
</span></span></code></pre></div><p>다음은 <code>curl</code>을 이용하여 동일한 API 호출을 하는 명령어다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://localhost:8080/apis/metrics.k8s.io/v1beta1/nodes/minikube
</span></span></code></pre></div><p>응답 예시는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;NodeMetrics&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;metrics.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;minikube&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>: <span style=color:#b44>&#34;/apis/metrics.k8s.io/v1beta1/nodes/minikube&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2022-01-27T18:48:43Z&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;timestamp&#34;</span>: <span style=color:#b44>&#34;2022-01-27T18:48:33Z&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;window&#34;</span>: <span style=color:#b44>&#34;30s&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;usage&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;cpu&#34;</span>: <span style=color:#b44>&#34;487558164n&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;memory&#34;</span>: <span style=color:#b44>&#34;732212Ki&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>다음은 <code>kube-system</code> 네임스페이스 내의 <code>kube-scheduler-minikube</code> 파드에 대한
메트릭 API 요청 예시이며 가독성 향상을 위해 <code>jq</code>를 활용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --raw <span style=color:#b44>&#34;/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/kube-scheduler-minikube&#34;</span> | jq <span style=color:#b44>&#39;.&#39;</span>
</span></span></code></pre></div><p>다음은 <code>curl</code>을 이용하여 동일한 API 호출을 하는 명령어다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://localhost:8080/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/kube-scheduler-minikube
</span></span></code></pre></div><p>응답 예시는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;PodMetrics&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;metrics.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;kube-scheduler-minikube&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;kube-system&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>: <span style=color:#b44>&#34;/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/kube-scheduler-minikube&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2022-01-27T19:25:00Z&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;timestamp&#34;</span>: <span style=color:#b44>&#34;2022-01-27T19:24:31Z&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;window&#34;</span>: <span style=color:#b44>&#34;30s&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;containers&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;kube-scheduler&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;usage&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;cpu&#34;</span>: <span style=color:#b44>&#34;9559630n&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;memory&#34;</span>: <span style=color:#b44>&#34;22244Ki&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>메트릭 API는 <a href=https://github.com/kubernetes/metrics>k8s.io/metrics</a> 저장소에 정의되어 있다.
<code>metrics.k8s.io</code> API를 사용하기 위해서는
<a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>API 집계(aggregation) 계층</a>을 활성화하고
<a href=/docs/reference/kubernetes-api/cluster-resources/api-service-v1/>APIService</a>를 등록해야 한다.</p><p>메트릭 API에 대해 더 알아보려면, <a href=https://git.k8s.io/design-proposals-archive/instrumentation/resource-metrics-api.md>리소스 메트릭 API 디자인</a>,
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server 저장소</a> 및
<a href=https://github.com/kubernetes/metrics#resource-metrics-api>리소스 메트릭 API</a>를 참고한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 메트릭 API에 접근하려면 먼저 메트릭 API를 제공하는
metrics-server 또는 대체 어댑터를 배포해야 한다.</div><h2 id=measuring-resource-usage>리소스 사용량 측정</h2><h3 id=cpu>CPU</h3><p>CPU는 <code>cpu</code> 단위로 측정된 평균 코어 사용량 형태로 보고된다. 쿠버네티스에서 1 cpu는
클라우드 제공자의 경우 1 vCPU/코어에 해당하고, 베어메탈 인텔 프로세서의 경우 1 하이퍼-스레드에 해당한다.</p><p>이 값은 커널(Linux 및 Windows 커널 모두)에서 제공하는 누적 CPU 카운터에 대한
비율을 취하여 얻어진다.
CPU 값 계산에 사용된 타임 윈도우는 메트릭 API의 <code>window</code> 필드에 표시된다.</p><p>쿠버네티스가 어떻게 CPU 리소스를 할당하고 측정하는지 더 알아보려면,
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu>CPU의 의미</a>를 참고한다.</p><h3 id=메모리>메모리</h3><p>메모리는 메트릭을 수집하는 순간에 바이트 단위로 측정된 워킹 셋(working set) 형태로 보고된다.</p><p>이상적인 환경에서, "워킹 셋"은 메모리가 부족한 상태더라도 해제할 수 없는 사용 중인 메모리의 양이다.
그러나 워킹 셋의 계산 방법은 호스트 OS에 따라 다르며
일반적으로 추정치를 추출하기 위해 휴리스틱을 많이 사용한다.</p><p>컨테이너의 워킹 셋에 대한 쿠버네티스 모델은 컨테이너 런타임이 해당 컨테이너와 연결된 익명(anonymous) 메모리를 계산할 것으로 예상한다.
호스트 OS가 항상 페이지를 회수할 수는 없기 때문에,
워킹 셋 메트릭에는 일반적으로 일부 캐시된 (파일 기반) 메모리도 포함된다.</p><p>쿠버네티스가 어떻게 메모리 리소스를 할당하고 측정하는지 더 알아보려면,
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory>메모리의 의미</a>를 참고한다.</p><h2 id=metrics-server>metrics-server</h2><p>metrics-server는 kubelet으로부터 리소스 메트릭을 수집하고,
이를 HPA(Horizontal Pod Autoscaler) 및 VPA(Vertical Pod Autoscaler)가 활용할 수 있도록 쿠버네티스 API 서버 내에서 메트릭 API(Metrics API)를 통해 노출한다.
<code>kubectl top</code> 명령을 사용하여 이 메트릭을 확인해볼 수도 있다.</p><p>metrics-server는 쿠버네티스 API를 사용하여 클러스터의 노드와 파드를 추적한다.
metrics-server는 각 노드에 HTTP를 통해 질의하여 메트릭을 수집한다.
metrics-server는 또한 파드 메타데이터의 내부적 뷰를 작성하고, 파드 헬스(health)에 대한 캐시를 유지한다.
이렇게 캐시된 파드 헬스 정보는 metrics-server가 제공하는 확장 API(extension API)를 통해 이용할 수 있다.</p><p>HPA 질의에 대한 예시에서, 예를 들어 HPA 질의에 대한 경우,
metrics-server는 디플로이먼트의 어떤 파드가 레이블 셀렉터 조건을 만족하는지 판별해야 한다.</p><p>metrics-server는 각 노드로부터 메트릭을 수집하기 위해 <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> API를 호출한다.
사용 중인 metrics-server 버전에 따라, 다음의 엔드포인트를 사용한다.</p><ul><li>v0.6.0 이상: 메트릭 리소스 엔드포인트 <code>/metrics/resource</code></li><li>이전 버전: 요약 API 엔드포인트 <code>/stats/summary</code></li></ul><p>metrics-server에 대한 더 많은 정보는
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server 저장소</a>를 확인한다.</p><p>또한 다음을 참고할 수도 있다.</p><ul><li><a href=https://git.k8s.io/design-proposals-archive/instrumentation/metrics-server.md>metrics-server 디자인</a></li><li><a href=https://github.com/kubernetes-sigs/metrics-server/blob/master/FAQ.md>metrics-server 자주 묻는 질문</a></li><li><a href=https://github.com/kubernetes-sigs/metrics-server/blob/master/KNOWN_ISSUES.md>metrics-server 알려진 이슈</a></li><li><a href=https://github.com/kubernetes-sigs/metrics-server/releases>metrics-server 릴리스</a></li><li><a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscaling</a></li></ul><h3 id=summary-api-source>요약 API(Summary API) 소스</h3><p><a href=/docs/reference/command-line-tools-reference/kubelet/>Kubelet</a>은
노드, 볼륨, 파드, 컨테이너 수준의 통계를 수집하며,
소비자(consumer)가 읽을 수 있도록 이 통계를
<a href=https://github.com/kubernetes/kubernetes/blob/7d309e0104fedb57280b261e5677d919cb2a0e2d/staging/src/k8s.io/kubelet/pkg/apis/stats/v1alpha1/types.go>요약 API</a>에 기록한다.</p><p>다음은 <code>minikube</code> 노드에 대한 요약 API 요청 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --raw <span style=color:#b44>&#34;/api/v1/nodes/minikube/proxy/stats/summary&#34;</span>
</span></span></code></pre></div><p>다음은 <code>curl</code>을 이용하여 동일한 API 호출을 하는 명령어다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://localhost:8080/api/v1/nodes/minikube/proxy/stats/summary
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> metrics-server 0.6.x 버전부터,
요약 API <code>/stats/summary</code> 엔드포인트가 <code>/metrics/resource</code> 엔드포인트로 대체될 것이다.</div></div><div class=td-content style=page-break-before:always><h1 id=pg-cb9e28c208c6cfbabdb15ba2e42e9ef0>2.2.2 - 리소스 모니터링 도구</h1><p>애플리케이션을 스케일하여 신뢰할 수 있는 서비스를 제공하려면,
애플리케이션이 배포되었을 때 애플리케이션이 어떻게 동작하는지를 이해해야 한다.
컨테이너, <a href=/ko/docs/concepts/workloads/pods/>파드</a>,
<a href=/ko/docs/concepts/services-networking/service>서비스</a>,
그리고 전체 클러스터의 특성을 검사하여
쿠버네티스 클러스터 내의 애플리케이션 성능을 검사할 수 있다. 쿠버네티스는 각 레벨에서
애플리케이션의 리소스 사용량에 대한 상세 정보를 제공한다.
이 정보는 애플리케이션의 성능을 평가하고
병목 현상을 제거하여 전체 성능을 향상할 수 있게 해준다.</p><p>쿠버네티스에서 애플리케이션 모니터링은 단일 모니터링 솔루션에 의존하지 않는다.
신규 클러스터에서는, <a href=#%EB%A6%AC%EC%86%8C%EC%8A%A4-%EB%A9%94%ED%8A%B8%EB%A6%AD-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8>리소스 메트릭</a> 또는
<a href=#%EC%99%84%EC%A0%84%ED%95%9C-%EB%A9%94%ED%8A%B8%EB%A6%AD-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8>완전한 메트릭</a> 파이프라인으로 모니터링 통계를 수집할 수 있다.</p><h2 id=리소스-메트릭-파이프라인>리소스 메트릭 파이프라인</h2><p>리소스 메트릭 파이프라인은
<a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale>Horizontal Pod Autoscaler</a>
컨트롤러와 같은 클러스터 구성요소나
<code>kubectl top</code> 유틸리티에 관련되어 있는
메트릭들로 제한된 집합을 제공한다. 이 메트릭은 경량의 단기 인메모리 저장소인
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a>에
의해서 수집되며 <code>metrics.k8s.io</code> API를 통해 노출된다.</p><p>metrics-server는 클러스터 상의 모든 노드를 발견하고
각 노드의 <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>에
CPU와 메모리 사용량을 질의한다.
Kubelet은 쿠버네티스 마스터와 노드 간의 다리 역할을 하면서
머신에서 구동되는 파드와 컨테이너를 관리한다.
Kubelet은 각각의 파드를 해당하는 컨테이너에 매치시키고
컨테이너 런타임 인터페이스를 통해
컨테이너 런타임에서 개별 컨테이너의 사용량 통계를 가져온다.
컨테이너를 구현하기 위해 리눅스 cgroup 및 네임스페이스를 활용하는 컨테이너 런타임을 사용하며,
해당 컨테이너 런타임이 사용 통계치를 퍼블리싱 하지 않는 경우,
kubelet은 해당 통계치를 (<a href=https://github.com/google/cadvisor>cAdvisor</a>의 코드 사용하여) 직접 조회 할 수 있다.
이런 통계가 어떻게 도착하든 kubelet은 취합된 파드 리소스 사용량 통계를
metric-server 리소스 메트릭 API를 통해 노출한다.
이 API는 kubelet의 인증이 필요한 읽기 전용 포트 상의
<code>/metrics/resource/v1beta1</code>에서 제공된다.</p><h2 id=완전한-메트릭-파이프라인>완전한 메트릭 파이프라인</h2><p>완전한 메트릭 파이프라인은 보다 풍부한 메트릭에 접근할 수 있도록 해준다.
쿠버네티스는 Horizontal Pod Autoscaler와 같은 메커니즘을 활용해서 이런 메트릭에
대한 반응으로 클러스터의 현재 상태를 기반으로 자동으로 스케일링하거나 클러스터를
조정할 수 있다. 모니터링 파이프라인은 kubelet에서 메트릭을 가져와서 쿠버네티스에
<code>custom.metrics.k8s.io</code>와 <code>external.metrics.k8s.io</code> API를 구현한 어댑터를 통해
노출한다.</p><p>CNCF 프로젝트인 <a href=https://prometheus.io>프로메테우스</a>는 기본적으로 쿠버네티스, 노드, 프로메테우스 자체를 모니터링할 수 있다.
CNCF 프로젝트가 아닌 완전한 메트릭 파이프라인 프로젝트는 쿠버네티스 문서의 범위가 아니다.</p><h2 id=다음-내용>다음 내용</h2><p>다음과 같은 추가 디버깅 도구에 대해 더 알아본다.</p><ul><li><a href=/ko/docs/concepts/cluster-administration/logging/>로깅</a></li><li><a href=/ko/docs/tasks/debug/debug-cluster/resource-usage-monitoring/>모니터링</a></li><li><a href=/ko/docs/tasks/debug/debug-application/get-shell-running-container/><code>exec</code>를 통해 컨테이너에 접속하기</a></li><li><a href=/ko/docs/tasks/extend-kubernetes/http-proxy-access-api/>프록시를 통해 컨테이너에 연결하기</a></li><li><a href=/ko/docs/tasks/access-application-cluster/port-forward-access-application-cluster/>포트 포워딩을 사용해서 클러스터 내 애플리케이션에 접근하기</a></li><li><a href=/ko/docs/tasks/debug/debug-cluster/crictl/>crictl을 사용하여 쿠버네티스 노드 조사하기</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-20165c8269bed123bfb94fb6e7f85643>2.2.3 - 노드 헬스 모니터링하기</h1><p><em>노드 문제 감지기(Node Problem Detector)</em> 는 노드의 헬스에 대해 모니터링 및 보고하는 데몬이다.
노드 문제 감지기를 <code>데몬셋(DaemonSet)</code> 혹은 스탠드얼론 데몬(standalone daemon)으로 실행할 수 있다.
노드 문제 감지기는 다양한 데몬으로부터 노드의 문제에 관한 정보를 다양한 데몬으로부터 수집하고,
이러한 컨디션들을 <a href=/docs/concepts/architecture/nodes/#condition>노드컨디션(NodeCondition)</a> 및
<a href=/docs/reference/generated/kubernetes-api/v1.25/#event-v1-core>이벤트(Event)</a>형태로 API 서버에 보고한다.</p><p>노드 문제 감지기 설치 및 사용 방법을 보려면,
<a href=https://github.com/kubernetes/node-problem-detector>노드 문제 감지기 프로젝트 문서</a>를 참조하자.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=제약-사항>제약 사항</h2><ul><li><p>노드 문제 감지기는 파일 기반의 커널 로그만 지원한다.
<code>journald</code> 와 같은 로그 도구는 지원하지 않는다.</p></li><li><p>노드 문제 감지기는 커널 로그 형식을 사용하여 커널 이슈를 보고한다.
커널 로그 형식을 확장하는 방법을 배우려면 <a href=#support-other-log-format>기타 로그 형식 지원 추가</a>를 살펴보자.</p></li></ul><h2 id=노드-문제-감지기-활성화하기>노드 문제 감지기 활성화하기</h2><p>일부 클라우드 사업자는 노드 문제 감지기를 <a class=glossary-tooltip title='쿠버네티스의 기능을 확장하는 리소스.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/cluster-administration/addons/ target=_blank aria-label=애드온>애드온</a> 으로서 제공한다.
또한, <code>kubectl</code>을 이용하거나 애드온 파드를 생성하여 노드 문제 감지기를 활성화할 수도 있다.</p><h3 id=using-kubectl>kubectl를 이용하여 노드 문제 감지기 활성화하기</h3><p><code>kubectl</code>은 노드 문제 감지기를 관리하는 가장 유연한 방법이다.
현재 환경에 맞게 조정하거나 사용자 정의 노드 문제를 탐지하기 위해
기본 설정값을 덮어쓸 수 있다. 예를 들면 아래와 같다.</p><ol><li><p><code>node-problem-detector.yaml</code>와 유사하게 노드 문제 감지기 구성을 생성한다:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/debug/node-problem-detector.yaml download=debug/node-problem-detector.yaml><code>debug/node-problem-detector.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("debug-node-problem-detector-yaml")' title="Copy debug/node-problem-detector.yaml to clipboard"></img></div><div class=includecode id=debug-node-problem-detector-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>node-problem-detector-v0.1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector  <span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/node-problem-detector:v0.1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200m&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20m&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20Mi&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/log<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/</span></span></code></pre></div></div></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 현재 운영 체제 배포판의 시스템 로그 디렉토리와 일치하도록 기재했는지 확인해야 한다.</div></li><li><p><code>kubectl</code>을 이용하여 노드 문제 감지기를 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/debug/node-problem-detector.yaml
</span></span></code></pre></div></li></ol><h3 id=using-addon-pod>애드온 파드를 이용하여 노드 문제 감지기 활성화하기</h3><p>만약 커스텀 클러스터 부트스트랩 솔루션을 사용중이고
기본 설정값을 덮어쓸 필요가 없다면,
디플로이먼트를 추가로 자동화하기 위해 애드온 파드를 활용할 수 있다.</p><p><code>node-problem-detector.yaml</code>를 생성하고,
컨트롤 플레인 노드의 애드온 파드의 디렉토리 <code>/etc/kubernetes/addons/node-problem-detector</code>에 설정을 저장한다.</p><h2 id=설정-덮어쓰기>설정 덮어쓰기</h2><p>노드 문제 감지기를 빌드할 때,
<a href=https://github.com/kubernetes/node-problem-detector/tree/v0.1/config>기본 설정</a>이 포함되어 있다.</p><p>하지만 <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/><code>컨피그맵(ConfigMap)</code></a>을 이용해
설정을 덮어쓸 수 있다.</p><ol><li><p><code>config/</code> 내의 설정 파일을 변경한다.</p></li><li><p><code>node-problem-detector-config</code> <code>컨피그맵(ConfigMap)</code>을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap node-problem-detector-config --from-file<span style=color:#666>=</span>config/
</span></span></code></pre></div></li><li><p><code>컨피그맵(ConfigMap)</code>을 사용하도록 <code>node-problem-detector.yaml</code>을 변경한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/debug/node-problem-detector-configmap.yaml download=debug/node-problem-detector-configmap.yaml><code>debug/node-problem-detector-configmap.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("debug-node-problem-detector-configmap-yaml")' title="Copy debug/node-problem-detector-configmap.yaml to clipboard"></img></div><div class=includecode id=debug-node-problem-detector-configmap-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>node-problem-detector-v0.1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector  <span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v0.1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>node-problem-detector<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/node-problem-detector:v0.1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200m&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20m&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20Mi&#34;</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/log<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb> </span><span style=color:#080;font-style:italic># config/ 디렉토리를 컨피그맵 볼륨(ConfigMap volume)으로 덮어쓴다</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/config<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 컨피그맵 볼륨(ConfigMap volume)을 정의한다</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>node-problem-detector-config</span></span></code></pre></div></div></div></li><li><p>새로운 설정 파일을 사용하여 노드 문제 감지기를 재생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 만약 노드 문제 감지기가 동작하고 있다면, 재생성 전 삭제한다</span>
</span></span><span style=display:flex><span>kubectl delete -f https://k8s.io/examples/debug/node-problem-detector.yaml
</span></span><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/debug/node-problem-detector-configmap.yaml
</span></span></code></pre></div></li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 접근법은 노드 문제 감지기를 <code>kubectl</code>로 시작했을 때에만 적용된다.</div><p>만약 노드 문제 감지기가 클러스터 애드온으로 실행된 경우, 설정 덮어쓰기가 지원되지 않는다.
애드온 매니저는 <code>컨피그맵(ConfigMap)</code>을 지원하지 않는다.</p><h2 id=커널-모니터>커널 모니터</h2><p><em>커널 모니터</em>는 노드 문제 감지기에서 지원하는 시스템 로그 모니터링 데몬이다.
커널 모니터는 커널 로그를 감시하며, 미리 설정된 규칙에 따라 알려진 커널 이슈를 감지한다.</p><p>커널 모니터는 <a href=https://github.com/kubernetes/node-problem-detector/blob/v0.1/config/kernel-monitor.json><code>config/kernel-monitor.json</code></a>에
미리 설정된 규칙 모음과 커널 이슈를 매칭한다.
규칙 리스트는 확장 가능하다. 설정을 덮어쓰기 해 규칙 리스트를 확장할 수 있다.</p><h3 id=신규-노드컨디션-nodeconditions-추가하기>신규 노드컨디션(NodeConditions) 추가하기</h3><p>신규 <code>NodeCondition</code>를 지원하려면, <code>config/kernel-monitor.json</code>의 <code>conditions</code>필드 내 조건 정의를 생성해야한다.
예를 들면 아래와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;NodeConditionType&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;CamelCaseDefaultNodeConditionReason&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;arbitrary default node condition message&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=신규-문제-감지하기>신규 문제 감지하기</h3><p>신규 문제를 감지하려면 <code>config/kernel-monitor.json</code>의 <code>rules</code>필드를
신규 규칙 정의로 확장하면 된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;temporary/permanent&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;condition&#34;</span>: <span style=color:#b44>&#34;NodeConditionOfPermanentIssue&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;CamelCaseShortReason&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;regexp matching the issue in the kernel log&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=kernel-log-device-path>커널 로그 장치를 위한 경로 설정하기</h3><p>운영 체제 (OS) 배포판의 커널 로그 경로를 확인한다.
리눅스 커널 <a href=https://www.kernel.org/doc/Documentation/ABI/testing/dev-kmsg>로그 장치(log device)</a>는 보통 <code>/dev/kmsg</code>와 같이 표시된다. 하지만, 로그 경로 장소는 OS 배포판마다 상이하다.
<code>config/kernel-monitor.json</code> 의 <code>log</code> 필드는 컨테이너 내부의 로그 경로를 나타낸다.
<code>log</code> 필드를 노드 문제 감지기가 감시하는 장치 경로와 일치하도록 구성하면 된다.</p><h3 id=support-other-log-format>기타 로그 포맷 지원 추가하기</h3><p>커널 모니터는 커널 로그의 내부 데이터 구조를 해석하기 위해
<a href=https://github.com/kubernetes/node-problem-detector/blob/v0.1/pkg/kernelmonitor/translator/translator.go><code>Translator</code></a> 플러그인을 사용한다.
신규 로그 포맷을 사용하기 위해 신규 해석기를 구현할 수 있다.</p><h2 id=권장-사항-및-제약-사항>권장 사항 및 제약 사항</h2><p>노드 헬스를 모니터링하기 위해 클러스터에 노드 문제 탐지기를 실행할 것을 권장한다.
노드 문제 감지기를 실행할 때, 각 노드에 추가 리소스 오버헤드가 발생할 수 있다.
다음과 같은 이유 때문에 일반적으로는 문제가 없다.</p><ul><li>커널 로그는 비교적 천천히 늘어난다.</li><li>노드 문제 감지기에는 리소스 제한이 설정되어 있다.</li><li>높은 부하가 걸리더라도, 리소스 사용량은 허용 가능한 수준이다. 추가 정보를 위해 노드 문제 감지기의
<a href=https://github.com/kubernetes/node-problem-detector/issues/2#issuecomment-220255629>벤치마크 결과</a>를 살펴보자.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6ca4f22ef4d1713577ada4815f0a3b5a>2.2.4 - crictl로 쿠버네티스 노드 디버깅하기</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.11 [stable]</code></div><p><code>crictl</code>은 CRI-호환 컨테이너 런타임에 사용할 수 있는 커맨드라인 인터페이스이다.
쿠버네티스 노드에서 컨테이너 런타임과 애플리케이션을 검사하고
디버그하는 데 사용할 수 있다.
<code>crictl</code>과 그 소스는 <a href=https://github.com/kubernetes-sigs/cri-tools>cri-tools</a> 저장소에서 호스팅한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><code>crictl</code>은 CRI 런타임이 있는 리눅스 운영체제를 필요로 한다.</p><h2 id=crictl-설치하기>crictl 설치하기</h2><p>cri-tools <a href=https://github.com/kubernetes-sigs/cri-tools/releases>릴리스 페이지</a>에서
다양한 아키텍처 별로 압축된 <code>crictl</code> 아카이브(archive)를 다운로드할 수 있다.
설치된 쿠버네티스 버전에 해당하는 버전을 다운로드한다.
<code>/usr/local/bin/</code>와 같은 시스템 경로의 위치에
압축을 푼다.</p><h2 id=일반적인-사용법>일반적인 사용법</h2><p><code>crictl</code> 커맨드에는 여러 하위 커맨드와 런타임 플래그가 있다.
자세한 내용은 <code>crictl help</code> 또는 <code>crictl &lt;subcommand> help</code>를 참조한다.</p><p>아래 내용 중 하나를 통해 <code>crictl</code>의 엔드포인트를 설정할 수 있다.</p><ul><li><code>--runtime-endpoint</code>와 <code>--image-endpoint</code> 플래그 설정.</li><li><code>CONTAINER_RUNTIME_ENDPOINT</code>와 <code>IMAGE_SERVICE_ENDPOINT</code> 환경 변수
설정.</li><li>구성 파일 <code>/etc/crictl.yaml</code>에 엔드포인트 설정.
다른 파일을 지정하기 위해서는 <code>crictl</code>을 실행할 때 <code>--config=PATH_TO_FILE</code> 플래그를 사용한다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 엔드포인트를 설정하지 않으면,
<code>crictl</code>이 알려진 엔드포인트 목록에 연결을 시도하므로 성능에 영향을 줄 수 있다.</div><p>서버에 연결할 때 구성 파일에서 <code>timeout</code> 또는 <code>debug</code> 값을 명시하거나,
<code>--timeout</code> 그리고 <code>--debug</code> 커맨드라인 플래그를 사용하여
타임아웃 값을 지정하고 디버깅을 활성화하거나 비활성화할 수 있다.</p><p>현재 구성을 보거나 편집하려면 <code>/etc/crictl.yaml</code>의 내용을 보거나 편집한다.
예를 들어,
<code>containerd</code> 컨테이너 런타임 사용 시 구성은 아래와 유사하다.</p><pre tabindex=0><code>runtime-endpoint: unix:///var/run/containerd/containerd.sock
image-endpoint: unix:///var/run/containerd/containerd.sock
timeout: 10
debug: true
</code></pre><p><code>crictl</code>에 대해 자세히 알고 싶다면,
<a href=https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md><code>crictl</code> 문서</a>를 참조한다.</p><h2 id=crictl-커맨드-예시>crictl 커맨드 예시</h2><p>아래 예시를 통해 <code>crictl</code> 커맨드와 출력을 확인해보자.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 구동 중인 쿠버네티스 클러스터에서 <code>crictl</code>을 사용하여 파드 샌드박스(sandbox)나 컨테이너를 만들게 되면,
결국에는 kubelet이 그것들을 삭제하게 된다.
<code>crictl</code>은 일반적인 워크플로우 툴이 아니라 디버깅에 유용한 툴임을 명심해야 한다.</div><h3 id=파드-목록-조회>파드 목록 조회</h3><p>모든 파드의 목록 조회</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl pods
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>POD ID              CREATED              STATE               NAME                         NAMESPACE           ATTEMPT
926f1b5a1d33a       About a minute ago   Ready               sh-84d7dcf559-4r2gq          default             0
4dccb216c4adb       About a minute ago   Ready               nginx-65899c769f-wv2gp       default             0
a86316e96fa89       17 hours ago         Ready               kube-proxy-gblk4             kube-system         0
919630b8f81f1       17 hours ago         Ready               nvidia-device-plugin-zgbbv   kube-system         0
</code></pre><p>이름으로 파드의 목록 조회</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl pods --name nginx-65899c769f-wv2gp
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>POD ID              CREATED             STATE               NAME                     NAMESPACE           ATTEMPT
4dccb216c4adb       2 minutes ago       Ready               nginx-65899c769f-wv2gp   default             0
</code></pre><p>레이블로 파드의 목록 조회</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl pods --label <span style=color:#b8860b>run</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>POD ID              CREATED             STATE               NAME                     NAMESPACE           ATTEMPT
4dccb216c4adb       2 minutes ago       Ready               nginx-65899c769f-wv2gp   default             0
</code></pre><h3 id=이미지-목록-조회>이미지 목록 조회</h3><p>모든 이미지의 목록 조회</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl images
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>IMAGE                                     TAG                 IMAGE ID            SIZE
busybox                                   latest              8c811b4aec35f       1.15MB
k8s-gcrio.azureedge.net/hyperkube-amd64   v1.10.3             e179bbfe5d238       665MB
k8s-gcrio.azureedge.net/pause-amd64       3.1                 da86e6ba6ca19       742kB
nginx                                     latest              cd5239a0906a6       109MB
</code></pre><p>저장소로 이미지 목록 조회</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl images nginx
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>IMAGE               TAG                 IMAGE ID            SIZE
nginx               latest              cd5239a0906a6       109MB
</code></pre><p>이미지의 IDs 목록만 조회</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl images -q
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>sha256:8c811b4aec35f259572d0f79207bc0678df4c736eeec50bc9fec37ed936a472a
sha256:e179bbfe5d238de6069f3b03fccbecc3fb4f2019af741bfff1233c4d7b2970c5
sha256:da86e6ba6ca197bf6bc5e9d900febd906b133eaa4750e6bed647b0fbe50ed43e
sha256:cd5239a0906a6ccf0562354852fae04bc5b52d72a2aff9a871ddb6bd57553569
</code></pre><h3 id=컨테이너-목록-조회>컨테이너 목록 조회</h3><p>모든 컨테이너 목록 조회</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl ps -a
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>CONTAINER ID        IMAGE                                                                                                             CREATED             STATE               NAME                       ATTEMPT
1f73f2d81bf98       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   7 minutes ago       Running             sh                         1
9c5951df22c78       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   8 minutes ago       Exited              sh                         0
87d3992f84f74       nginx@sha256:d0a8828cccb73397acb0073bf34f4d7d8aa315263f1e7806bf8c55d8ac139d5f                                     8 minutes ago       Running             nginx                      0
1941fb4da154f       k8s-gcrio.azureedge.net/hyperkube-amd64@sha256:00d814b1f7763f4ab5be80c58e98140dfc69df107f253d7fdd714b30a714260a   18 hours ago        Running             kube-proxy                 0
</code></pre><p>실행 중인 컨테이너 목록 조회</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl ps
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>CONTAINER ID        IMAGE                                                                                                             CREATED             STATE               NAME                       ATTEMPT
1f73f2d81bf98       busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47                                   6 minutes ago       Running             sh                         1
87d3992f84f74       nginx@sha256:d0a8828cccb73397acb0073bf34f4d7d8aa315263f1e7806bf8c55d8ac139d5f                                     7 minutes ago       Running             nginx                      0
1941fb4da154f       k8s-gcrio.azureedge.net/hyperkube-amd64@sha256:00d814b1f7763f4ab5be80c58e98140dfc69df107f253d7fdd714b30a714260a   17 hours ago        Running             kube-proxy                 0
</code></pre><h3 id=실행-중인-컨테이너-안에서-명령-실행>실행 중인 컨테이너 안에서 명령 실행</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl <span style=color:#a2f>exec</span> -i -t 1f73f2d81bf98 ls
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>bin   dev   etc   home  proc  root  sys   tmp   usr   var
</code></pre><h3 id=컨테이너의-로그-조회>컨테이너의 로그 조회</h3><p>모든 컨테이너의 로그 조회</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl logs 87d3992f84f74
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>10.240.0.96 - - [06/Jun/2018:02:45:49 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.47.0&#34; &#34;-&#34;
10.240.0.96 - - [06/Jun/2018:02:45:50 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.47.0&#34; &#34;-&#34;
10.240.0.96 - - [06/Jun/2018:02:45:51 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.47.0&#34; &#34;-&#34;
</code></pre><p>최신 <code>N</code>개 줄의 로그만 조회</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl logs --tail<span style=color:#666>=</span><span style=color:#666>1</span> 87d3992f84f74
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>10.240.0.96 - - [06/Jun/2018:02:45:51 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.47.0&#34; &#34;-&#34;
</code></pre><h3 id=파드-샌드박스-실행>파드 샌드박스 실행</h3><p><code>crictl</code>을 사용하여 파드 샌드박스를 실행하는 것은 컨테이너 런타임 디버깅에 유용하다.
구동 중인 쿠버네티스 클러스터에서
이러한 샌드박스는 kubelet에 의해서 결국 중지 및 삭제된다.</p><ol><li><p>다음과 같은 JSON 파일 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-sandbox&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;attempt&#34;</span>: <span style=color:#666>1</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;hdishd83djaidwnduwk28bcsb&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;log_directory&#34;</span>: <span style=color:#b44>&#34;/tmp&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>crictl runp</code> 커맨드를 사용하여 JSON을 적용하고 샌드박스를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl runp pod-config.json
</span></span></code></pre></div><p>결과로 샌드박스의 ID가 반환될 것이다.</p></li></ol><h3 id=컨테이너-생성>컨테이너 생성</h3><p><code>crictl</code>을 사용하여 컨테이너를 만드는 것은 컨테이너 런타임 디버깅에 유용하다.
구동 중인 쿠버네티스 클러스터에서
이러한 샌드박스는 kubelet에 의해서 결국 중지 및 삭제된다.</p><ol><li><p>busybox 이미지 가져오기</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl pull busybox
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Image is up to date for busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47
</code></pre></li><li><p>파드와 컨테이너 구성(config) 생성</p><p><strong>파드 구성</strong>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;busybox-sandbox&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;attempt&#34;</span>: <span style=color:#666>1</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;aewi4aeThua7ooShohbo1phoj&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;log_directory&#34;</span>: <span style=color:#b44>&#34;/tmp&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>컨테이너 구성</strong>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;image&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;top&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;log_path&#34;</span>:<span style=color:#b44>&#34;busybox.log&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;linux&#34;</span>: {
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>이전에 생성한 파드의 ID 및 컨테이너 구성 파일과 파드 구성 파일을 커맨드 인자로 전달하여,
컨테이너를 생성한다.
결과로 컨테이너의 ID가 반환될 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl create f84dd361f8dc51518ed291fbadd6db537b0496536c1d2d6c05ff943ce8c9a54f container-config.json pod-config.json
</span></span></code></pre></div></li><li><p>모든 컨테이너의 목록을 조회하여
새로 생성된 컨테이너의 상태가 <code>Created</code>임을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl ps -a
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>CONTAINER ID        IMAGE               CREATED             STATE               NAME                ATTEMPT
3e025dd50a72d       busybox             32 seconds ago      Created             busybox             0
</code></pre></li></ol><h3 id=컨테이너-시작하기>컨테이너 시작하기</h3><p>컨테이너를 시작하기 위해서 컨테이너 ID를 <code>crictl start</code>에 인자로 전달한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl start 3e025dd50a72d956c4f14881fbb5b1080c9275674e95fb67f965f6478a957d60
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>3e025dd50a72d956c4f14881fbb5b1080c9275674e95fb67f965f6478a957d60
</code></pre><p>컨테이너의 상태가 <code>Running</code>임을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>crictl ps
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>CONTAINER ID   IMAGE    CREATED              STATE    NAME     ATTEMPT
3e025dd50a72d  busybox  About a minute ago   Running  busybox  0
</code></pre><h2 id=다음-내용>다음 내용</h2><ul><li><a href=https://github.com/kubernetes-sigs/cri-tools><code>crictl</code> 더 알아보기</a>.</li><li><a href=/docs/reference/tools/map-crictl-dockercli/><code>docker</code> CLI 커맨드를 <code>crictl</code>로 매핑하기</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-38387ad04dd284933cb502944ea3515b>2.2.5 - 감사(auditing)</h1><p>쿠버네티스 <em>감사(auditing)</em> 는 클러스터의 작업 순서를 문서화하는 보안 관련 시간별 레코드 세트를 제공한다.
클러스터는 사용자, 쿠버네티스 API를 사용하는 애플리케이션 및
컨트롤 플레인 자체에서 생성된 활동을 감사한다.</p><p>감사를 통해 클러스터 관리자는 다음 질문에 답할 수 있다.</p><ul><li>무슨 일이 일어났는지?</li><li>언제 일어난 일인지?</li><li>누가 시작했는지?</li><li>어떤 일이 있었는지?</li><li>어디서 관찰되었는지?</li><li>어디서부터 시작되었는지?</li><li>그래서 어디까지 갔는지?</li></ul><p>감사 기록은 <a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a>
컴포넌트 내에서 수명주기를 시작한다.
실행의 각 단계에서 각 요청은 감사 이벤트를 생성하고,
감사 이벤트는 특정 정책에 따라 사전 처리되고 백엔드에 기록된다.
정책은 기록된 내용을 결정하고 백엔드는 기록을 유지한다.
현재 백엔드 구현에는 로그 파일 및
웹훅이 포함된다.</p><p>각 요청들은 연관된 <em>단계(stage)</em> 와 함께 기록될 수 있다. 정의된 단계는 다음과 같다.</p><ul><li><code>RequestReceived</code> - 감사 핸들러가 요청을 수신한 직후,
그리고 핸들러 체인으로 위임되기 전에
생성되는 이벤트에 대한 단계이다.</li><li><code>ResponseStarted</code> - 응답 헤더는 전송되었지만,
응답 본문(body)은 전송되기 전인 단계이다.
이 단계는 오래 실행되는 요청(예: watch)에 대해서만 생성된다.</li><li><code>ResponseComplete</code> - 응답 내용이 완료되었으며,
더 이상 바이트가 전송되지 않을 때의 단계이다.</li><li><code>Panic</code> - 패닉이 발생했을 때 생성되는 이벤트이다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <a href=/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event>Audit Event configuration</a>
의 구성은
<a href=/docs/reference/generated/kubernetes-api/v1.25/#event-v1-core>Event</a>
API 오브젝트와는
다르다.</div><p>감사 로깅 기능은 감사에 필요한 일부 컨텍스트가 요청마다
저장되기 때문에 API 서버의 메모리 사용량을 증가시킨다.
메모리 소비량은 감사 로깅 구성에 따라 다르다.</p><h2 id=감사-정책>감사 정책</h2><p>감사 정책은 기록해야 하는 이벤트와 포함해야 하는
데이터에 대한 규칙을 정의한다. 감사 정책 오브젝트 구조는
<a href=/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy><code>audit.k8s.io</code> API 그룹</a>에 정의되어 있다.
이벤트가 처리되면 규칙 목록과 순서대로 비교된다.
첫번째 일치 규칙은 이벤트의 <em>감사 수준(audit level)</em> 을 설정한다.
정의된 감사 수준은 다음과 같다.</p><ul><li><code>None</code> - 이 규칙에 해당되는 이벤트는 로깅하지 않는다.</li><li><code>Metadata</code> - 요청 메타데이터(요청하는 사용자, 타임스탬프, 리소스, 동사(verb) 등)는 로깅하지만
요청/응답 본문은 로깅하지 않는다.</li><li><code>Request</code> - 이벤트 메타데이터 및 요청 본문을 로깅하지만 응답 본문은 로깅하지 않는다.
리소스 외의 요청에는 적용되지 않는다.</li><li><code>RequestResponse</code> - 이벤트 메타데이터 및 요청/응답 본문을 로깅한다.
리소스 외의 요청에는 적용되지 않는다.</li></ul><p><code>--audit-policy-file</code> 플래그를 사용하여 정책이 포함된 파일을
<code>kube-apiserver</code>에 전달할 수 있다. 플래그를 생략하면 이벤트가 기록되지 않는다.
감사 정책 파일에 <code>rules</code> 필드 <strong>반드시</strong> 가 제공되어야 한다.
규칙이 없는(0개인) 정책은 적절하지 않은(illegal) 것으로 간주된다.</p><p>다음은 감사 정책 파일의 예이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/audit/audit-policy.yaml download=audit/audit-policy.yaml><code>audit/audit-policy.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("audit-audit-policy-yaml")' title="Copy audit/audit-policy.yaml to clipboard"></img></div><div class=includecode id=audit-audit-policy-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>audit.k8s.io/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 필수사항임.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Policy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Request Received 단계의 모든 요청에 대해 감사 이벤트를 생성하지 않음.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>omitStages</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;RequestReceived&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RequestResponse 수준에서 파드 변경 사항 기록</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>RequestResponse<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 리소스 &#34;파드&#34; 가 RBAC 정책과 부합하는 파드의 하위 리소스에 대한</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 요청과 일치하지 않음.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 메타데이터 수준에서 &#34;pods/log&#34;, &#34;pods/status&#34;를 기록함.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods/log&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods/status&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;controller-leader&#34; 라는 컨피그맵에 요청을 기록하지 않음.&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;controller-leader&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 엔드포인트 또는 서비스의 &#34;system:kube-proxy&#34;에 의한 감시 요청 기록하지 않음.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;system:kube-proxy&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 핵심 API 그룹</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;endpoints&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;services&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 인증된 요청을 특정 리소스가 아닌 URL 경로에 기록하지 않음.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>userGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;system:authenticated&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/api*&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 와일드카드 매칭(wildcard matching).</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/version&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># kube-system에 컨피그맵 변경 사항의 요청 본문을 기록함.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Request<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 핵심 API 그룹</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 정책은 &#34;kube-system&#34; 네임스페이스의 리소스에만 적용됨.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 빈 문자열 &#34;&#34; 은 네임스페이스가 없는 리소스를 선택하는데 사용할 수 있음.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespaces</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;kube-system&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 메타데이터 수준에서 다른 모든 네임스페이스의 컨피그맵과 시크릿 변경 사항을 기록함.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 핵심 API 그룹</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;secrets&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 요청 수준에서 코어 및 확장에 있는 다른 모든 리소스를 기록함.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Request<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 핵심 API 그룹</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 그룹의 버전을 기재하면 안 된다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 메타데이터 수준에서 다른 모든 요청을 기록하기 위한 모든 수집 정책.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 정책에 해당하는 감시자와 같은 장기 실행 요청은</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># RequestReceived에서 감사 이벤트를 생성하지 않음.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>omitStages</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;RequestReceived&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>최소 감사 정책 파일을 사용하여 <code>Metadata</code> 수준에서 모든 요청을 기록할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># Log all requests at the Metadata level.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>audit.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Policy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span>Metadata<span style=color:#bbb>
</span></span></span></code></pre></div><p>자체 감사 프로필을 만드는 경우 Google Container-Optimized OS에 대한 감사 프로필을 시작점으로 사용할 수 있다.
감사 정책 파일을 생성하는 <a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh>configure-helper.sh</a>
스크립트를 확인하면 된다. 스크립트로 대부분의 감사 정책 파일을 볼 수 있다.</p><p>정의된 필드에 대한 자세한 내용은 <a href=/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy><code>Policy</code> configuration reference</a>를
참조할 수도 있다.</p><h2 id=감사-백엔드>감사 백엔드</h2><p>감사 백엔드는 감사 이벤트를 외부 저장소에 유지한다.
기본적으로 kube-apiserver는 두 가지 백엔드를 제공한다.</p><ul><li>이벤트를 파일 시스템에 기록하는 로그 백엔드</li><li>이벤트를 외부 HTTP API로 보내는 Webhook 백엔드</li></ul><p>모든 경우에 감사 이벤트는 쿠버네티스 API의
<a href=/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event><code>audit.k8s.io</code> API 그룹</a>에서 정의한 구조를 따른다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>패치의 경우 요청 내용은 적절한 쿠버네티스 API 오브젝트를 포함하는 JSON 오브젝트가 아니라
패치 작업을 포함하는 JSON 배열이다. 예를 들어 다음 요청 내용은
<code>/apis/batch/v1/namespaces/some-namespace/jobs/some-job-name</code>에 대한 유효한 패치 요청이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;op&#34;</span>: <span style=color:#b44>&#34;replace&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;path&#34;</span>: <span style=color:#b44>&#34;/spec/parallelism&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;value&#34;</span>: <span style=color:#666>0</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;op&#34;</span>: <span style=color:#b44>&#34;remove&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;path&#34;</span>: <span style=color:#b44>&#34;/spec/template/spec/containers/0/terminationMessagePolicy&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div></div><h3 id=로그-백엔드>로그 백엔드</h3><p>로그 백엔드는 감사이벤트를 <a href=https://jsonlines.org/>JSONlines</a> 형식으로 파일에 기록한다.
다음의 <code>kube-apiserver</code> 플래그를 사용하여 로그 감사 백엔드를 구성할 수 있다.</p><ul><li><code>--audit-log-path</code> 는 로그 백엔드가 감사 이벤트를 쓰는 데 사용하는 로그 파일 경로를 지정한다.
이 플래그를 지정하지 않으면 로그 백엔드가 비활성화된다. <code>-</code> 는 표준 출력을 의미한다.</li><li><code>--audit-log-maxage</code> 는 오래된 감사 로그 파일을 보관할 최대 일수를 정의한다.</li><li><code>--audit-log-maxbackup</code> 은 보관할 감사 로그 파일의 최대 수를 정의한다.</li><li><code>--audit-log-maxsize</code> 는 감사 로그 파일이 로테이트 되기 전의 최대 크기(MB)를 정의한다.</li></ul><p>클러스터의 컨트롤 플레인이 kube-apiserver를 파드로 실행하는 경우 감사 레코드가 지속되도록
정책 파일 및 로그 파일의 위치에 <code>hostPath</code> 를 마운트 해야한다. 예를 들면</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>    --audit-policy-file<span style=color:#666>=</span>/etc/kubernetes/audit-policy.yaml <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --audit-log-path<span style=color:#666>=</span>/var/log/kubernetes/audit/audit.log
</span></span></code></pre></div><p>그런 다음 볼륨을 마운트 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/audit-policy.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log/kubernetes/audit/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit-log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>그리고 마지막으로 <code>hostPath</code> 를 구성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/audit-policy.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>File<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>audit-log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/kubernetes/audit/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=웹훅-백엔드>웹훅 백엔드</h3><p>웹훅 감사 백엔드는 원격 웹 API로 감사 이벤트를 전송하는데, 이는 인증 수단을 포함하여
쿠버네티스 API의 한 형태로 간주된다.
다음 kube-apiserver 플래그를 사용하여 웹훅 감사 백엔드를 구성할 수 있다.</p><ul><li><code>--audit-webhook-config-file</code> 은 웹훅 구성이 있는 파일의 경로를 지정한다.
웹훅 구성은 효과적으로 전문화된
<a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a>이다.</li><li><code>--audit-webhook-initial-backoff</code> 는 첫 번째 실패한 요청 후 다시 시도하기 전에 대기할 시간을 지정한다.
이후 요청은 지수의 백오프로 재시도 된다.</li></ul><p>웹훅 구성 파일은 kubeconfig 형식을 사용하여
서비스의 원격 주소와 서비스에 연결하는 데 사용되는 자격 증명을 지정한다.</p><h2 id=배치>이벤트 배치</h2><p>로그 및 웹 훅 백엔드는 모두 배치를 지원한다. 웹훅 사용을 예로 들면, 다음은 사용 가능한 플래그 목록이다.
로그 백엔드에 대해 동일한 플래그를 가져오려면 플래그 이름에 있는 <code>webhook</code> 을 <code>log</code> 로 바꾼다.
기본적으로 배치 기능은 <code>webhook</code> 에서 활성화되고 <code>log</code> 에서 비활성화된다. 마찬가지로, 기본적으로
쓰로틀링은 <code>webhook</code> 에서는 활성화되고 <code>log</code> 에서는 비활성화된다.</p><ul><li><code>--audit-webhook-mode</code> 은 버퍼링 전략을 정의한다. 다음 중 하나이다.<ul><li><code>batch</code> - 이벤트를 버퍼링하고 비동기식으로 배치한다. 이것이 기본값이다.</li><li><code>blocking</code> - 각 개별 이벤트를 처리할 때 API 서버 응답을 차단한다.</li><li><code>blocking-strict</code> - <code>blocking</code>과 동일하지만, RequestReceived 단계에서 감사 로깅 중에 오류가 발생하면
kube-apiserver에 대한 전체 요청이 실패한다.</li></ul></li></ul><p>다음 플래그는 <code>batch</code> 모드에서만 사용된다.</p><ul><li><code>--audit-webhook-batch-buffer-size</code> 는 배치하기 전에 버퍼링할 이벤트 수를 정의한다.
들어오는 이벤트의 비율이 버퍼를 초과하면 이벤트가 삭제된다.</li><li><code>--audit-webhook-batch-max-size</code> 는 한 배치의 최대 이벤트 수를 정의한다.</li><li><code>--audit-webhook-batch-max-wait</code> 는 대기열에서 이벤트를 무조건 배치하기 전에
대기할 최대 시간을 정의한다.</li><li><code>--audit-webhook-batch-throttle-qps</code> 는 초당 생성되는 최대 평균 배치 수를
정의한다.</li><li><code>--audit-webhook-batch-throttle-burst</code> 는 허용된 QPS가 이전에 충분히 활용되지 않은 경우
동시에 생성되는 최대 배치 수를 정의한다.</li></ul><h2 id=파라미터-튜닝>파라미터 튜닝</h2><p>파라미터는 API 서버의 로드를 수용할 수 있도록 설정해야 한다.</p><p>예를 들어 kube-apiserver가 초당 100건의 요청을 수신하고 각 요청이
<code>ResponseStarted</code> 와 <code>ResponseComplete</code> 단계에서만 감사되는 경우 초당 생성되는 ≅200건의 감사 이벤트를 고려해야 한다.
일괄적으로 최대 100개의 이벤트가 있다고 가정할 때
초당 최소 2개의 쿼리 조절 수준을 설정해야 한다.
백엔드가 이벤트를 쓰는 데 최대 5초가 걸릴 수 있다고 가정하면 버퍼크기를 최대 5초의 이벤트를 보유하도록 설정해야 한다.
즉, 10개의 배치 또는 100개의 이벤트이다.</p><p>그러나 대부분의 경우 기본 매개 변수만 있으면 충분하며 수동으로 설정할 필요가 없다.
kube-apiserver에서 노출된 다음과 같은 프로메테우스 메트릭과 로그에서
감사 하위 시스템의 상태를 모니터링할 수 있다.</p><ul><li><code>apiserver_audit_event_total</code> 의 메트릭에는 내보낸 감사 이벤트의 총 수가 포함된다.</li><li><code>apiserver_audit_error_total</code> 의 메트릭에는 내보내기 중 오류로 인해 삭제된 총 이벤트
수가 포함된다.</li></ul><h3 id=truncate>로그 항목 자르기</h3><p>로그 및 웹훅 백엔드는 모두 로깅되는 이벤트의 크기 제한을 지원한다.
예를 들어 로그 백엔드에 사용할 수 있는 플래그 목록은 다음과 같다.</p><ul><li><code>audit-log-truncate-enabled</code> 는 이벤트 및 자르기 배치가 활성화 되었는지 여부를 나타낸다.</li><li><code>audit-log-truncate-max-batch-size</code> 는 기본 백엔드로 전송되는 배치의 바이트 단위의 최대 크기이다.</li><li><code>audit-log-truncate-max-event-size</code> 는 기본 백엔드로 전송된 감사 이벤트의 바이트 단위의 최대 크기이다.</li></ul><p>기본적으로 <code>webhook</code> 과 <code>log</code> 모두에서 자르기 기능이 비활성화되어 있으므로 이 기능을 활성화 하기 위해
클러스터 관리자는 <code>audit-log-truncate-enabled</code> 또는 <code>audit-webhook-truncate-enabled</code> 를 설정해야 한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#mutating-webhook-auditing-annotations>Mutating webhook auditing annotations</a> 에 대해 알아보기.</li><li><a href=/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event><code>Event</code></a> 에 대해 알아보고
감사 구성 참조를 읽고 <a href=/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy><code>Policy</code></a>
리소스 유형 확인하기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-60dca0ec8d41f0045e7d73e1d6bd7bce>2.2.6 - 로컬에서 텔레프레즌스를 이용한 서비스 개발 및 디버깅</h1><div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div><p>쿠버네티스 애플리케이션은 일반적으로 각각 자체 컨테이너에서 실행되는 여러 개의 개별 서비스로 구성된다. 원격 쿠버네티스 클러스터 상에서 이러한 서비스를 개발하고 디버깅하려면 디버깅 도구를 실행하기 위해 <a href=/ko/docs/tasks/debug/debug-application/get-shell-running-container/>동작 중인 컨테이너의 셸(shell)에 접근</a>해야 하기 때문에 번거로울 수 있다.</p><p><code>텔레프레즌스(telepresence)</code>는 원격 쿠버네티스 클러스터로 서비스를 프록시하면서 로컬에서 서비스를 개발 및 디버깅하는 과정을 용이하게 하는 도구이다. <code>텔레프레즌스</code>를 사용하면 로컬 서비스에 디버거 및 IDE와 같은 사용자 지정 도구를 사용할 수 있고 원격 클러스터에서 실행되는 컨피그맵(ConfigMap), 시크릿(Secret) 및 서비스(Service)에 대한 전체 접근 권한을 서비스에 제공할 수 있다.</p><p>이 문서는 <code>텔레프레즌스</code>를 사용하여 원격 클러스터에서 실행 중인 서비스를 로컬로 개발하고 디버그하는 방법을 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li>쿠버네티스 클러스터가 설치되어 있어야 한다.</li><li><code>kubectl</code>은 클러스터와 통신하도록 구성되어 있어야 한다.</li><li><a href=https://www.telepresence.io/reference/install>텔레프레즌스</a>가 설치되어 있어야 한다.</li></ul><h2 id=로컬-머신을-원격-쿠버네티스-클러스터에-연결>로컬 머신을 원격 쿠버네티스 클러스터에 연결</h2><p><code>텔레프레즌스</code>를 설치한 후 <code>텔레프레즌스 커넥트(telepresence connect)</code>를 실행하여 데몬을 실행하고 로컬 워크스테이션을 클러스터에 연결한다.</p><pre tabindex=0><code>$ telepresence connect
 
Launching Telepresence Daemon
...
Connected to context default (https://&lt;cluster public IP&gt;)
</code></pre><p>쿠버네티스 구문을 사용하여 서비스에 curl이 가능하다. 예, <code>curl -ik https://kubernetes.default</code></p><h2 id=기존-서비스-개발-또는-디버깅>기존 서비스 개발 또는 디버깅</h2><p>쿠버네티스에서 애플리케이션을 개발할 때 일반적으로 단일 서비스를 프로그래밍하거나 디버그한다. 서비스를 테스트 및 디버깅하기 위해 다른 서비스에 접근이 필요할 수 있다. 지속적 배포(continuous deployment) 파이프라인을 사용하는 것도 한 가지 옵션이지만, 가장 빠른 배포 파이프라인이라도 프로그래밍 또는 디버그 주기에 지연이 발생할 수 있다.</p><p><code>telepresence intercept $SERVICE_NAME --port $LOCAL_PORT:$REMOTE_PORT</code> 명령을 사용하여 원격 서비스 트래픽을 다시 라우팅하기 위한 "인터셉트(intercept)"를 생성한다.</p><p>아래의 각 항목에 대한 설명을 참고한다.</p><ul><li><code>$SERVICE_NAME</code>은 로컬 서비스의 이름이다.</li><li><code>$LOCAL_PORT</code>는 서비스가 로컬 워크스테이션에서 실행 중인 포트이다.</li><li><code>$REMOTE_PORT</code>는 서비스가 클러스터에서 수신하는 포트이다.</li></ul><p>이 명령을 실행하면 원격 쿠버네티스 클러스터의 서비스 대신 로컬 서비스에 원격 트래픽을 보내도록 텔레프레즌스에 지시한다. 서비스 소스 코드를 로컬에서 편집하고 저장하여 원격 애플리케이션에 접근할 때 해당 변경 사항이 즉시 적용되는지 확인한다. 디버거 또는 기타 로컬 개발 도구를 사용하여 로컬 서비스를 실행할 수도 있다.</p><h2 id=텔레프레즌스는-어떻게-작동하는가>텔레프레즌스는 어떻게 작동하는가?</h2><p>Telepresence는 원격 클러스터에서 실행 중인 기존 애플리케이션의 컨테이너 옆에 트래픽 에이전트 사이드카(sidecar)를 설치한다. 그런 다음 파드로 들어오는 모든 트래픽 요청을 캡처하고, 이를 원격 클러스터의 애플리케이션에 전달하는 대신, 모든 트래픽(<a href=https://www.getambassador.io/docs/telepresence/latest/concepts/intercepts/#global-intercept>글로벌 인터셉트</a>를 생성하는 경우) 또는 일부 트래픽(<a href=https://www.getambassador.io/docs/telepresence/latest/concepts/intercepts/#personal-intercept>개인 인터셉트</a>를 생성하는 경우)을 로컬 개발 환경으로 라우팅한다.</p><h2 id=다음-내용>다음 내용</h2><p>핸즈온 튜토리얼에 관심이 있다면 구글 쿠버네티스 엔진 상의 방명록 애플리케이션을 로컬로 개발하는 과정을 안내하는 <a href=https://cloud.google.com/community/tutorials/developing-services-with-k8s>이 튜토리얼</a>을 확인한다.</p><p>자세한 내용은 <a href=https://www.telepresence.io>텔레프레즌스 웹사이트</a>를 참조한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-34f51c9306a166418b33355c09e672be>2.2.7 - 윈도우 디버깅 팁</h1><h2 id=troubleshooting-node>노드-수준 트러블슈팅</h2><ol><li><p>내 파드가 "Container Creating"에서 멈췄거나 계속해서 다시 시작된다.</p><p>퍼즈(pause) 이미지가 OS 버전과 호환되는지 확인한다.
<a href=/ko/docs/concepts/windows/intro/#%ED%8D%BC%EC%A6%88-pause-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88>퍼즈 컨테이너</a>에서
최신 / 추천 퍼즈 이미지 및 추가 정보를 확인한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 컨테이너 런타임으로 containerd를 사용하고 있다면, 퍼즈 이미지는
<code>config.toml</code> 환경 설정 파일의 <code>plugins.plugins.cri.sandbox_image</code> 필드에 명시되어 있다.</div></li><li><p>내 파드의 상태가 <code>ErrImgPull</code> 또는 <code>ImagePullBackOff</code>이다.</p><p>파드가
<a href=https://docs.microsoft.com/virtualization/windowscontainers/deploy-containers/version-compatibility>호환되는</a> 윈도우 노드에
스케줄링되었는지 확인한다.</p><p>각 파드와 호환되는 노드를 찾는 방법에 대한 추가 정보는
<a href=/ko/docs/concepts/windows/user-guide/#%ED%8A%B9%EC%A0%95-OS-%EC%9B%8C%ED%81%AC%EB%A1%9C%EB%93%9C%EB%A5%BC-%EC%A0%81%EC%A0%88%ED%95%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8F%84%EB%A1%9D-%EB%B3%B4%EC%9E%A5%ED%95%98%EA%B8%B0>이 가이드</a>를 참고한다.</p></li></ol><h2 id=troubleshooting-network>네트워크 트러블슈팅</h2><ol><li><p>내 윈도우 파드에 네트워크 연결이 없다.</p><p>가상 머신을 사용하는 경우,
모든 VM 네트워크 어댑터에 MAC 스푸핑이 <strong>활성화</strong>되어 있는지 확인한다.</p></li><li><p>내 윈도우 파드가 외부 리소스를 ping 할 수 없다.</p><p>윈도우 파드에는 현재 ICMP 프로토콜용으로 프로그래밍된 아웃바운드 규칙이 없다.
그러나 TCP/UDP는 지원된다.
클러스터 외부 리소스에 대한 연결을 시연하려는 경우,
<code>ping &lt;IP></code>를 대응되는 <code>curl &lt;IP></code>명령으로 대체한다.</p><p>여전히 문제가 발생하는 경우,
<a href=https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf>cni.conf</a>의 네트워크 구성에 특별히 추가 확인이 필요하다.
언제든지 이 정적 파일을 편집할 수 있다.
구성 업데이트는 새로 생성된 모든 쿠버네티스 리소스에 적용된다.</p><p>쿠버네티스 네트워킹 요구
사항(<a href=/ko/docs/concepts/cluster-administration/networking/>쿠버네티스 모델</a> 참조)
중 하나는
클러스터 통신이 NAT 없이 내부적으로 발생해야 한다는 것이다.
이 요구 사항을 준수하기 위해
아웃바운드 NAT가 발생하지 않도록 하는
모든 통신에 대한 <a href=https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf#L20>ExceptionList</a>가 있다.
그러나 이것은 쿼리하려는 외부 IP를 <code>ExceptionList</code>에서 제외해야 함도 의미한다.
그래야만 윈도우 파드에서 발생하는 트래픽이 제대로 SNAT 되어 외부에서 응답을 받는다.
이와 관련하여 <code>cni.conf</code>의 <code>ExceptionList</code>는 다음과 같아야 한다.</p><pre tabindex=0><code class=language-conf data-lang=conf>&#34;ExceptionList&#34;: [
                &#34;10.244.0.0/16&#34;,  # 클러스터 서브넷
                &#34;10.96.0.0/12&#34;,   # 서비스 서브넷
                &#34;10.127.130.0/24&#34; # 관리(호스트) 서브넷
            ]
</code></pre></li><li><p>내 윈도우 노드가 <code>NodePort</code> 서비스에 접근할 수 없다.</p><p>노드 자체에서는 로컬 NodePort 접근이 실패한다. 이것은 알려진 제약사항이다.
NodePort 접근은 다른 노드 또는 외부 클라이언트에서는 가능하다.</p></li><li><p>컨테이너의 vNIC 및 HNS 엔드포인트가 삭제된다.</p><p>이 문제는 <code>hostname-override</code> 파라미터가
<a href=/ko/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>에 전달되지 않은 경우 발생할 수 있다.
이를 해결하려면 사용자는 다음과 같이 hostname을 kube-proxy에 전달해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>C:\k\<span style=color:#a2f>kube-proxy</span>.exe --hostname-override=$(hostname)
</span></span></code></pre></div></li><li><p>내 윈도우 노드가 서비스 IP를 사용하여 내 서비스에 접근할 수 없다.</p><p>이는 윈도우에서 현재 네트워킹 스택의 알려진 제약 사항이다. 그러나 윈도우 파드는 서비스 IP에 접근할 수 있다.</p></li><li><p>kubelet을 시작할 때 네트워크 어댑터를 찾을 수 없다.</p><p>윈도우 네트워킹 스택에는 쿠버네티스 네트워킹이 작동하기 위한 가상 어댑터가 필요하다.
(어드민 셸에서) 다음 명령이 결과를 반환하지 않으면,
Kubelet이 작동하는 데 필요한 필수 구성 요소인 가상 네트워크 생성이 실패한 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>Get-HnsNetwork</span> | ? Name <span style=color:#666>-ieq</span> <span style=color:#b44>&#34;cbr0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>Get-NetAdapter</span> | ? Name <span style=color:#666>-Like</span> <span style=color:#b44>&#34;vEthernet (Ethernet*&#34;</span>
</span></span></code></pre></div><p>호스트 네트워크 어댑터가 "Ethernet"이 아닌 경우, 종종 <code>start.ps1</code> 스크립트의
<a href=https://github.com/microsoft/SDN/blob/master/Kubernetes/flannel/start.ps1#L7>InterfaceName</a> 파라미터를 수정하는 것이 좋다.
그렇지 않으면 <code>start-kubelet.ps1</code> 스크립트의 출력을 참조하여 가상 네트워크 생성 중에 오류가 있는지 확인한다.</p></li><li><p>DNS 해석(resolution)이 제대로 작동하지 않는다.</p><p>이 <a href=/ko/docs/concepts/services-networking/dns-pod-service/#dns-windows>섹션</a>에서 윈도우에서의 DNS 제한을 확인한다.</p></li><li><p><code>kubectl port-forward</code>가 "unable to do port forwarding: wincat not found" 에러와 함께 실패한다.</p><p>이 기능은 퍼즈 인프라 컨테이너 <code>mcr.microsoft.com/oss/kubernetes/pause:3.6</code>에
<code>wincat.exe</code>를 포함시킴으로써 쿠버네티스 1.15에서 구현되었다.
지원되는 쿠버네티스 버전을 사용하고 있는지 확인한다.
퍼즈 인프라 컨테이너를 직접 빌드하려면
<a href=https://github.com/kubernetes/kubernetes/tree/master/build/pause/windows/wincat>wincat</a>을 포함시켜야 한다.</p></li><li><p>내 윈도우 서버 노드가 프록시 뒤에 있기 때문에 쿠버네티스 설치에 실패한다.</p><p>프록시 뒤에 있는 경우, 다음 PowerShell 환경 변수를 정의해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=display:flex><span>[<span style=color:#800>Environment</span>]::SetEnvironmentVariable(<span style=color:#b44>&#34;HTTP_PROXY&#34;</span>, <span style=color:#b44>&#34;http://proxy.example.com:80/&#34;</span>, [<span style=color:#800>EnvironmentVariableTarget</span>]::Machine)
</span></span><span style=display:flex><span>[<span style=color:#800>Environment</span>]::SetEnvironmentVariable(<span style=color:#b44>&#34;HTTPS_PROXY&#34;</span>, <span style=color:#b44>&#34;http://proxy.example.com:443/&#34;</span>, [<span style=color:#800>EnvironmentVariableTarget</span>]::Machine)
</span></span></code></pre></div></li></ol><h3 id=플란넬-트러블슈팅>플란넬 트러블슈팅</h3><ol><li><p>플란넬(flannel)을 사용하면 클러스터에 다시 조인(join)한 후 노드에 이슈가 발생한다.</p><p>이전에 삭제된 노드가 클러스터에 다시 조인될 때마다,
flannelD는 새 파드 서브넷을 노드에 할당하려고 한다.
사용자는 다음 경로에서 이전 파드 서브넷 구성 파일을 제거해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>Remove-Item</span> C:\k\SourceVip.json
</span></span><span style=display:flex><span><span style=color:#a2f>Remove-Item</span> C:\k\SourceVipRequest.json
</span></span></code></pre></div></li><li><p>flanneld가 "Waiting for the Network to be created" 상태에서 멈춘다.</p><p>이 <a href=https://github.com/coreos/flannel/issues/1066>이슈</a>에 대한 수많은 보고가 있다.
플란넬 네트워크의 관리 IP가 설정될 때의 타이밍 이슈일 가능성이 높다.
해결 방법은 start.ps1을 다시 시작하거나 다음과 같이 수동으로 다시 시작하는 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>[<span style=color:#800>Environment</span>]::SetEnvironmentVariable(<span style=color:#b44>&#34;NODE_NAME&#34;</span>, <span style=color:#b44>&#34;&lt;Windows_Worker_Hostname&gt;&#34;</span>)
</span></span><span style=display:flex><span>C:\flannel\flanneld.exe --kubeconfig<span style=color:#666>-file</span>=c:\k\config --iface=&lt;Windows_Worker_Node_IP&gt; --ip-masq=<span style=color:#666>1</span> --kube-subnet-mgr=<span style=color:#666>1</span>
</span></span></code></pre></div></li><li><p><code>/run/flannel/subnet.env</code> 누락으로 인해 윈도우 파드를 시작할 수 없다.</p><p>이것은 플란넬이 제대로 실행되지 않았음을 나타낸다.
<code>flanneld.exe</code>를 다시 시작하거나
쿠버네티스 마스터의 <code>/run/flannel/subnet.env</code>에서 윈도우 워커 노드의 <code>C:\run\flannel\subnet.env</code>로 파일을 수동으로 복사할 수 있고,
<code>FLANNEL_SUBNET</code> 행을 다른 숫자로 수정한다.
예를 들어, 노드 서브넷 10.244.4.1/24가 필요한 경우 다음과 같이 설정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-env data-lang=env><span style=display:flex><span><span style=color:#b8860b>FLANNEL_NETWORK</span><span style=color:#666>=</span>10.244.0.0/16
</span></span><span style=display:flex><span><span style=color:#b8860b>FLANNEL_SUBNET</span><span style=color:#666>=</span>10.244.4.1/24
</span></span><span style=display:flex><span><span style=color:#b8860b>FLANNEL_MTU</span><span style=color:#666>=</span><span style=color:#666>1500</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>FLANNEL_IPMASQ</span><span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span></code></pre></div></li></ol><h3 id=추가-조사>추가 조사</h3><p>이러한 단계로 문제가 해결되지 않으면, 다음을 통해 쿠버네티스의 윈도우 노드에서 윈도우 컨테이너를 실행하는 데 도움을 받을 수 있다.</p><ul><li>스택오버플로우 <a href=https://stackoverflow.com/questions/tagged/windows-server-container>윈도우 서버 컨테이너</a> 주제</li><li>쿠버네티스 공식 포럼 <a href=https://discuss.kubernetes.io/>discuss.kubernetes.io</a></li><li>쿠버네티스 슬랙 <a href=https://kubernetes.slack.com/messages/sig-windows>#SIG-Windows Channel</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-34a810f1516ad9d99b2697e36e9b0d0f>3 - 클러스터 운영</h1><div class=lead>클러스터를 운영하기 위한 공통 태스크를 배운다.</div></div><div class=td-content><h1 id=pg-8e16d69617b175d61e2e7a6e1642c9d6>3.1 - kubeadm으로 관리하기</h1></div><div class=td-content><h1 id=pg-f62fba1de4084f3be070785757c8079c>3.1.1 - kubeadm을 사용한 인증서 관리</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.15 [stable]</code></div><p><a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a>으로 생성된 클라이언트 인증서는 1년 후에 만료된다.
이 페이지는 kubeadm으로 인증서 갱신을 관리하는 방법을 설명하며,
kubeadm 인증서 관리와 관련된 다른 작업에 대해서도 다룬다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><a href=/ko/docs/setup/best-practices/certificates/>쿠버네티스의 PKI 인증서와 요구 조건</a>에 익숙해야 한다.</p><h2 id=custom-certificates>사용자 정의 인증서 사용</h2><p>기본적으로, kubeadm은 클러스터를 실행하는 데 필요한 모든 인증서를 생성한다.
사용자는 자체 인증서를 제공하여 이 동작을 무시할 수 있다.</p><p>이렇게 하려면, <code>--cert-dir</code> 플래그 또는 kubeadm <code>ClusterConfiguration</code> 의
<code>certificatesDir</code> 필드에 지정된 디렉터리에 배치해야 한다.
기본적으로 <code>/etc/kubernetes/pki</code> 이다.</p><p><code>kubeadm init</code> 을 실행하기 전에 지정된 인증서와 개인 키(private key) 쌍이 존재하면,
kubeadm은 이를 덮어 쓰지 않는다. 이는 예를 들어, 기존 CA를
<code>/etc/kubernetes/pki/ca.crt</code> 와 <code>/etc/kubernetes/pki/ca.key</code> 에
복사할 수 있고, kubeadm은 이 CA를 사용하여 나머지 인증서에 서명한다는 걸 의미한다.</p><h2 id=external-ca-mode>외부 CA 모드</h2><p><code>ca.key</code> 파일이 아닌 <code>ca.crt</code> 파일만 제공할
수도 있다(이는 다른 인증서 쌍이 아닌 루트 CA 파일에만 사용 가능함).
다른 모든 인증서와 kubeconfig 파일이 있으면, kubeadm은 이 조건을
인식하고 "외부 CA" 모드를 활성화한다. kubeadm은 디스크에
CA 키없이 진행한다.</p><p>대신, <code>--controllers=csrsigner</code> 사용하여 controller-manager를
독립적으로 실행하고 CA 인증서와 키를 가리킨다.</p><p><a href=/ko/docs/setup/best-practices/certificates/>PKI 인증서와 요구 조건</a>은 외부 CA를
사용하도록 클러스터 설정에 대한 지침을 포함한다.</p><h2 id=인증서-만료-확인>인증서 만료 확인</h2><p><code>check-expiration</code> 하위 명령을 사용하여 인증서가 만료되는 시기를 확인할 수 있다.</p><pre tabindex=0><code>kubeadm certs check-expiration
</code></pre><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED
admin.conf                 Dec 30, 2020 23:36 UTC   364d                                    no
apiserver                  Dec 30, 2020 23:36 UTC   364d            ca                      no
apiserver-etcd-client      Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
apiserver-kubelet-client   Dec 30, 2020 23:36 UTC   364d            ca                      no
controller-manager.conf    Dec 30, 2020 23:36 UTC   364d                                    no
etcd-healthcheck-client    Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
etcd-peer                  Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
etcd-server                Dec 30, 2020 23:36 UTC   364d            etcd-ca                 no
front-proxy-client         Dec 30, 2020 23:36 UTC   364d            front-proxy-ca          no
scheduler.conf             Dec 30, 2020 23:36 UTC   364d                                    no

CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED
ca                      Dec 28, 2029 23:36 UTC   9y              no
etcd-ca                 Dec 28, 2029 23:36 UTC   9y              no
front-proxy-ca          Dec 28, 2029 23:36 UTC   9y              no
</code></pre><p>이 명령은 <code>/etc/kubernetes/pki</code> 폴더의 클라이언트 인증서와 kubeadm이 사용하는 KUBECONFIG 파일(<code>admin.conf</code>, <code>controller-manager.conf</code> 및 <code>scheduler.conf</code>)에 포함된 클라이언트 인증서의 만료/잔여 기간을 표시한다.</p><p>또한, kubeadm은 인증서가 외부에서 관리되는지를 사용자에게 알린다. 이 경우 사용자는 수동으로 또는 다른 도구를 사용해서 인증서 갱신 관리를 해야 한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> <code>kubeadm</code> 은 외부 CA가 서명한 인증서를 관리할 수 없다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubelet.conf</code> 는 위 목록에 포함되어 있지 않은데, 이는
kubeadm이 <a href=/ko/docs/tasks/tls/certificate-rotation/>자동 인증서 갱신</a>을 위해
<code>/var/lib/kubelet/pki</code>에 있는 갱신 가능한 인증서를 이용하여 kubelet을 구성하기 때문이다.
만료된 kubelet 클라이언트 인증서를 갱신하려면
<a href=/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#kubelet-client-cert>kubelet 클라이언트 갱신 실패</a> 섹션을 확인한다.</div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong><p>kubeadm 1.17 이전의 버전에서 <code>kubeadm init</code> 으로 작성된 노드에는
<code>kubelet.conf</code> 의 내용을 수동으로 수정해야 하는 <a href=https://github.com/kubernetes/kubeadm/issues/1753>버그</a>가 있다. <code>kubeadm init</code> 수행 완료 후, <code>client-certificate-data</code> 및 <code>client-key-data</code> 를 다음과 같이 교체하여,
로테이트된 kubelet 클라이언트 인증서를 가리키도록 <code>kubelet.conf</code> 를 업데이트해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/var/lib/kubelet/pki/kubelet-client-current.pem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/var/lib/kubelet/pki/kubelet-client-current.pem<span style=color:#bbb>
</span></span></span></code></pre></div></div><h2 id=자동-인증서-갱신>자동 인증서 갱신</h2><p>kubeadm은 컨트롤 플레인 <a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>업그레이드</a> 동안 모든 인증서를 갱신한다.</p><p>이 기능은 가장 간단한 유스케이스를 해결하기 위해 설계되었다.
인증서 갱신에 대해 특별한 요구 사항이 없고 쿠버네티스 버전 업그레이드를 정기적으로(매 1년 이내 업그레이드 수행) 수행하는 경우, kubeadm은 클러스터를 최신 상태로 유지하고 합리적으로 보안을 유지한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 보안을 유지하려면 클러스터를 자주 업그레이드하는 것이 가장 좋다.</div><p>인증서 갱신에 대해 보다 복잡한 요구 사항이 있는 경우, <code>--certificate-renewal=false</code> 를 <code>kubeadm upgrade apply</code> 또는 <code>kubeadm upgrade node</code> 와 함께 사용하여 기본 동작이 수행되지 않도록 할 수 있다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> kubeadm 1.17 이전 버전에는 <code>kubeadm upgrade node</code> 명령에서
<code>--certificate-renewal</code> 의 기본값이 <code>false</code> 인 <a href=https://github.com/kubernetes/kubeadm/issues/1818>버그</a>가
있다. 이 경우 <code>--certificate-renewal=true</code> 를 명시적으로 설정해야 한다.</div><h2 id=수동-인증서-갱신>수동 인증서 갱신</h2><p><code>kubeadm certs renew</code> 명령을 사용하여 언제든지 인증서를 수동으로 갱신할 수 있다.</p><p>이 명령은 <code>/etc/kubernetes/pki</code> 에 저장된 CA(또는 프론트 프록시 CA) 인증서와 키를 사용하여 갱신을 수행한다.</p><p>명령을 실행한 후에는 컨트롤 플레인 파드를 재시작해야 한다.
이는 현재 일부 구성 요소 및 인증서에 대해 인증서를 동적으로 다시 로드하는 것이 지원되지 않기 때문이다.
<a href=/ko/docs/tasks/configure-pod-container/static-pod/>스태틱(static) 파드</a>는 API 서버가 아닌 로컬 kubelet에서 관리되므로
kubectl을 사용하여 삭제 및 재시작할 수 없다.
스태틱 파드를 다시 시작하려면 <code>/etc/kubernetes/manifests/</code>에서 매니페스트 파일을 일시적으로 제거하고
20초를 기다리면 된다 (<a href=/docs/reference/config-api/kubelet-config.v1beta1/>KubeletConfiguration struct</a>의 <code>fileCheckFrequency</code> 값을 참고한다).
파드가 매니페스트 디렉터리에 더 이상 없는 경우 kubelet은 파드를 종료한다.
그런 다음 파일을 다시 이동할 수 있으며 또 다른 <code>fileCheckFrequency</code> 기간이 지나면,
kubelet은 파드를 생성하고 구성 요소에 대한 인증서 갱신을 완료할 수 있다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> HA 클러스터를 실행 중인 경우, 모든 컨트롤 플레인 노드에서 이 명령을 실행해야 한다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>certs renew</code> 는 기존 인증서를 kubeadm-config 컨피그맵(ConfigMap) 대신 속성(공통 이름, 조직, SAN 등)의 신뢰할 수 있는 소스로 사용한다. 둘 다 동기화 상태를 유지하는 것을 강력히 권장한다.</div><p><code>kubeadm certs renew</code> 는 다음의 옵션을 제공한다.</p><p>쿠버네티스 인증서는 일반적으로 1년 후 만료일에 도달한다.</p><ul><li><p><code>--csr-only</code> 는 실제로 인증서를 갱신하지 않고 인증서 서명 요청을 생성하여 외부 CA로 인증서를 갱신하는 데 사용할 수 있다. 자세한 내용은 다음 단락을 참고한다.</p></li><li><p>모든 인증서 대신 단일 인증서를 갱신할 수도 있다.</p></li></ul><h2 id=쿠버네티스-인증서-api를-사용하여-인증서-갱신>쿠버네티스 인증서 API를 사용하여 인증서 갱신</h2><p>이 섹션에서는 쿠버네티스 인증서 API를 사용하여 수동 인증서 갱신을 실행하는 방법에 대한 자세한 정보를 제공한다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 조직의 인증서 인프라를 kubeadm으로 생성된 클러스터에 통합해야 하는 사용자를 위한 고급 주제이다. 기본 kubeadm 구성이 요구 사항을 충족하면 kubeadm이 인증서를 대신 관리하도록 해야 한다.</div><h3 id=서명자-설정>서명자 설정</h3><p>쿠버네티스 인증 기관(Certificate Authority)은 기본적으로 작동하지 않는다.
<a href=https://cert-manager.io/docs/configuration/ca/>cert-manager</a>와 같은 외부 서명자를 설정하거나, 빌트인 서명자를 사용할 수 있다.</p><p>빌트인 서명자는 <a href=/docs/reference/command-line-tools-reference/kube-controller-manager/><code>kube-controller-manager</code></a>의 일부이다.</p><p>빌트인 서명자를 활성화하려면, <code>--cluster-signing-cert-file</code> 와 <code>--cluster-signing-key-file</code> 플래그를 전달해야 한다.</p><p>새 클러스터를 생성하는 경우, kubeadm <a href=https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta3>구성 파일</a>을 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>controllerManager</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster-signing-cert-file</span>:<span style=color:#bbb> </span>/etc/kubernetes/pki/ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster-signing-key-file</span>:<span style=color:#bbb> </span>/etc/kubernetes/pki/ca.key<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=인증서-서명-요청-csr-생성>인증서 서명 요청(CSR) 생성</h3><p>쿠버네티스 API로 CSR을 작성하려면 <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#create-certificatesigningrequest>CertificateSigningRequest 생성</a>을 본다.</p><h2 id=외부-ca로-인증서-갱신>외부 CA로 인증서 갱신</h2><p>이 섹션에서는 외부 CA를 사용하여 수동 인증서 갱신을 실행하는 방법에 대한 자세한 정보를 제공한다.</p><p>외부 CA와 보다 효과적으로 통합하기 위해 kubeadm은 인증서 서명 요청(CSR)을 생성할 수도 있다.
CSR은 클라이언트의 서명된 인증서에 대한 CA 요청을 나타낸다.
kubeadm 관점에서, 일반적으로 온-디스크(on-disk) CA에 의해 서명되는 모든 인증서는 CSR로 생성될 수 있다. 그러나 CA는 CSR로 생성될 수 없다.</p><h3 id=인증서-서명-요청-csr-생성-1>인증서 서명 요청(CSR) 생성</h3><p><code>kubeadm certs renew --csr-only</code> 로 인증서 서명 요청을 만들 수 있다.</p><p>CSR과 함께 제공되는 개인 키가 모두 출력된다.
<code>--csr-dir</code> 로 사용할 디텍터리를 전달하여 지정된 위치로 CSR을 출력할 수 있다.
<code>--csr-dir</code> 을 지정하지 않으면, 기본 인증서 디렉터리(<code>/etc/kubernetes/pki</code>)가 사용된다.</p><p><code>kubeadm certs renew --csr-only</code> 로 인증서를 갱신할 수 있다.
<code>kubeadm init</code> 과 마찬가지로 출력 디렉터리를 <code>--csr-dir</code> 플래그로 지정할 수 있다.</p><p>CSR에는 인증서 이름, 도메인 및 IP가 포함되지만, 용도를 지정하지는 않는다.
인증서를 발행할 때 <a href=/ko/docs/setup/best-practices/certificates/#%EB%AA%A8%EB%93%A0-%EC%9D%B8%EC%A6%9D%EC%84%9C>올바른 인증서 용도</a>를
지정하는 것은 CA의 책임이다.</p><ul><li><code>openssl</code> 의 경우
<a href=https://superuser.com/questions/738612/openssl-ca-keyusage-extension><code>openssl ca</code> 명령</a>으로 수행한다.</li><li><code>cfssl</code> 의 경우
<a href=https://github.com/cloudflare/cfssl/blob/master/doc/cmd/cfssl.txt#L170>설정 파일에 용도</a>를 지정한다.</li></ul><p>선호하는 방법으로 인증서에 서명한 후, 인증서와 개인 키를 PKI 디렉터리(기본적으로 <code>/etc/kubernetes/pki</code>)에 복사해야 한다.</p><h2 id=certificate-authority-rotation>인증 기관(CA) 순환(rotation)</h2><p>Kubeadm은 CA 인증서의 순환이나 교체 기능을 기본적으로 지원하지 않는다.</p><p>CA의 수동 순환이나 교체에 대한 보다 상세한 정보는 <a href=/docs/tasks/tls/manual-rotation-of-ca-certificates/>CA 인증서 수동 순환</a> 문서를 참조한다.</p><h2 id=kubelet-serving-certs>서명된 kubelet 인증서 활성화하기</h2><p>기본적으로 kubeadm에 의해서 배포된 kubelet 인증서는 자가 서명된(self-signed) 것이다.
이것은 <a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a>와
같은 외부 서비스의 kubelet에 대한 연결은
TLS로 보안되지 않음을 의미한다.</p><p>제대로 서명된 인증서를 얻기 위해서 신규 kubeadm 클러스터의 kubelet을 구성하려면
다음의 최소 구성을 <code>kubeadm init</code> 에 전달해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>serverTLSBootstrap</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>만약 이미 클러스터를 생성했다면 다음을 따라 이를 조정해야 한다.</p><ul><li><code>kube-system</code> 네임스페이스에서 <code>kubelet-config-1.25</code> 컨피그맵을 찾아서 수정한다.
해당 컨피그맵에는 <code>kubelet</code> 키가
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a>
문서를 값으로 가진다. <code>serverTLSBootstrap: true</code> 가 되도록 KubeletConfiguration 문서를 수정한다.</li><li>각 노드에서, <code>serverTLSBootstrap: true</code> 필드를 <code>/var/lib/kubelet/config.yaml</code> 에 추가한다.
그리고 <code>systemctl restart kubelet</code> 로 kubelet을 재시작한다.</li></ul><p><code>serverTLSBootstrap: true</code> 필드는 kubelet 인증서를 이용한 부트스트랩을
<code>certificates.k8s.io</code> API에 요청함으로써 활성화할 것이다. 한 가지 알려진 제약은
이 인증서들에 대한 CSR(인증서 서명 요청)들이 kube-controller-manager -
<a href=/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers><code>kubernetes.io/kubelet-serving</code></a>의
기본 서명자(default signer)에 의해서 자동으로 승인될 수 없다는 점이다.
이것은 사용자나 제 3의 컨트롤러의 액션을 필요로 할 것이다.</p><p>이 CSR들은 다음을 통해 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span><span style=display:flex><span>NAME        AGE     SIGNERNAME                        REQUESTOR                      CONDITION
</span></span><span style=display:flex><span>csr-9wvgt   112s    kubernetes.io/kubelet-serving     system:node:worker-1           Pending
</span></span><span style=display:flex><span>csr-lz97v   1m58s   kubernetes.io/kubelet-serving     system:node:control-plane-1    Pending
</span></span></code></pre></div><p>이를 승인하기 위해서는 다음을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl certificate approve &lt;CSR-name&gt;
</span></span></code></pre></div><p>기본적으로, 이 인증서는 1년 후에 만기될 것이다. Kubeadm은
<code>KubeletConfiguration</code> 필드의 <code>rotateCertificates</code> 를 <code>true</code> 로 설정한다. 이것은 만기가
다가오면 인증서를 위한 신규 CSR 세트가 생성되는 것을 의미하며,
해당 순환(rotation)을 완료하기 위해서는 승인이 되어야 한다는 것을 의미한다. 더 상세한 이해를 위해서는
<a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/#certificate-rotation>인증서 순환</a>를 확인한다.</p><p>만약 이 CSR들의 자동 승인을 위한 솔루션을 찾고 있다면 클라우드 제공자와
연락하여 대역 외 메커니즘(out of band mechanism)을 통해 노드의 신분을 검증할 수 있는
CSR 서명자를 가지고 있는지 문의하는 것을 추천한다.</p><div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div><p>써드파티 커스텀 컨트롤러도 사용될 수 있다.</p><ul><li><a href=https://github.com/postfinance/kubelet-csr-approver>kubelet-csr-approver</a></li></ul><p>이러한 컨트롤러는 CSR의 CommonName과 요청된 IPs 및 도메인 네임을
모두 검증하지 않는 한, 보안이 되는 메커니즘이 아니다. 이것을 통해 악의적 행위자가
kubelet 인증서(클라이언트 인증)를 사용하여 아무 IP나 도메인 네임에 대해 인증서를
요청하는 CSR의 생성을 방지할 수 있을 것이다.</p><h2 id=kubeconfig-additional-users>추가 사용자를 위한 kubeconfig 파일 생성하기</h2><p>클러스터 생성 과정에서, kubeadm은
<code>Subject: O = system:masters, CN = kubernetes-admin</code> 값이 설정되도록 <code>admin.conf</code>의 인증서에 서명한다.
<a href=/docs/reference/access-authn-authz/rbac/#user-facing-roles><code>system:masters</code></a>는
인증 계층(예: RBAC)을 우회하는 획기적인 슈퍼유저 그룹이다.
<code>admin.conf</code>를 추가 사용자와 공유하는 것은 <strong>권장하지 않는다</strong>!</p><p>대신, <a href=/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig><code>kubeadm kubeconfig user</code></a>
명령어를 사용하여 추가 사용자를 위한 kubeconfig 파일을 생성할 수 있다.
이 명령어는 명령줄 플래그와
<a href=/docs/reference/config-api/kubeadm-config.v1beta3/>kubeadm 환경 설정</a> 옵션을 모두 인식한다.
생성된 kubeconfig는 stdout으로 출력되며,
<code>kubeadm kubeconfig user ... > somefile.conf</code> 명령어를 사용하여 파일에 기록될 수 있다.</p><p>다음은 <code>--config</code> 플래그와 함께 사용될 수 있는 환경 설정 파일 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># example.yaml</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfig에서 타겟 &#34;cluster&#34;로 사용될 것이다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusterName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfig에서 클러스터의 &#34;server&#34;(IP 또는 DNS 이름)로 사용될 것이다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>controlPlaneEndpoint</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;some-dns-address:6443&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 클러스터 CA 키 및 인증서가 이 로컬 디렉토리에서 로드될 것이다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>certificatesDir</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/pki&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이러한 항목들이 사용하고자 하는 클러스터의 상세 사항과 일치하는지 확인한다.
기존 클러스터의 환경 설정을 보려면 다음 명령을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get cm kubeadm-config -n kube-system -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.data.ClusterConfiguration}&#34;</span>
</span></span></code></pre></div><p>다음 예시는 <code>appdevs</code> 그룹의 새 사용자 <code>johndoe</code>를 위해
24시간동안 유효한 인증서와 함께 kubeconfig 파일을 생성할 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm kubeconfig user --config example.yaml --org appdevs --client-name johndoe --validity-period 24h
</span></span></code></pre></div><p>다음 예시는 1주일간 유효한 관리자 크리덴셜을 갖는 kubeconfig 파일을 생성할 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm kubeconfig user --config example.yaml --client-name admin --validity-period 168h
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-2e173356df5179cab9eec90a606f0aa4>3.1.2 - kubeadm 클러스터 업그레이드</h1><p>이 페이지는 kubeadm으로 생성된 쿠버네티스 클러스터를 1.24.x 버전에서 1.25.x 버전으로,
1.25.x 버전에서 1.25.y(여기서 <code>y > x</code>) 버전으로 업그레이드하는 방법을 설명한다.
업그레이드가 지원되지 않는 경우 마이너 버전을 건너뛴다.
더 자세한 정보는 <a href=/ko/releases/version-skew-policy/>버전 차이(skew) 정책</a>을 참고한다.</p><p>이전 버전의 kubeadm을 사용하여 생성된 클러스터 업그레이드에 대한 정보를 보려면,
이 페이지 대신 다음의 페이지들을 참고한다.</p><ul><li><a href=https://v1-24.docs.kubernetes.io/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadm 클러스터를 1.23에서 1.24로 업그레이드</a></li><li><a href=https://v1-23.docs.kubernetes.io/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadm 클러스터를 1.22에서 1.23로 업그레이드</a></li><li><a href=https://v1-22.docs.kubernetes.io/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadm 클러스터를 1.21에서 1.22로 업그레이드</a></li><li><a href=https://v1-21.docs.kubernetes.io/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadm 클러스터를 1.20에서 1.21으로 업그레이드</a></li></ul><p>추상적인 업그레이드 작업 절차는 다음과 같다.</p><ol><li>기본 컨트롤 플레인 노드를 업그레이드한다.</li><li>추가 컨트롤 플레인 노드를 업그레이드한다.</li><li>워커(worker) 노드를 업그레이드한다.</li></ol><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><a href=https://git.k8s.io/kubernetes/CHANGELOG>릴리스 노트</a>를 주의 깊게 읽어야 한다.</li><li>클러스터는 정적 컨트롤 플레인 및 etcd 파드 또는 외부 etcd를 사용해야 한다.</li><li>데이터베이스에 저장된 앱-레벨 상태와 같은 중요한 컴포넌트를 반드시 백업한다.
<code>kubeadm upgrade</code> 는 워크로드에 영향을 미치지 않고, 쿠버네티스 내부의 컴포넌트만 다루지만, 백업은 항상 모범 사례일 정도로 중요하다.</li><li><a href=https://serverfault.com/questions/684771/best-way-to-disable-swap-in-linux>스왑을 비활성화해야 한다</a>.</li></ul><h3 id=추가-정보>추가 정보</h3><ul><li>아래의 지침은 업그레이드 과정 중 언제 각 노드를 드레인해야 하는지를 제시한다.
kubelet에 대해 <strong>마이너</strong> 버전 업그레이드를 하는 경우,
먼저 업그레이드할 노드(들)을 드레인<strong>해야 한다</strong>.
컨트롤 플레인 노드의 경우, CoreDNS 파드 또는 다른 중요한 워크로드를 실행 중일 수 있다.
더 많은 정보는 <a href=/docs/tasks/administer-cluster/safely-drain-node/>노드 드레인하기</a>를 참조한다.</li><li>컨테이너 사양 해시 값이 변경되므로, 업그레이드 후 모든 컨테이너가 다시 시작된다.</li><li>kubelet이 업그레이드된 이후 kubelet 서비스가 성공적으로 재시작되었는지 확인하려면,
<code>systemctl status kubelet</code> 명령을 실행하거나, <code>journalctl -xeu kubelet</code> 명령을 실행하여 서비스 로그를 확인할 수 있다.</li><li>클러스터를 재구성하기 위해 <code>kubeadm upgrade</code> 시에
<a href=/docs/reference/config-api/kubeadm-config.v1beta3>kubeadm 구성 API 종류</a>를 명시하여
<code>--config</code> 플래그를 사용하는 것은 추천하지 않으며 예상치 못한 결과를 초래할 수 있다.
대신 <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-reconfigure>kubeadm 클러스터 재구성하기</a>를 참조한다.</li></ul><h2 id=업그레이드할-버전-결정>업그레이드할 버전 결정</h2><p>OS 패키지 관리자를 사용하여 쿠버네티스의 최신 패치 릴리스 버전(1.25)을 찾는다.</p><ul class="nav nav-tabs" id=k8s-install-versions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-versions-0 role=tab aria-controls=k8s-install-versions-0 aria-selected=true>Ubuntu, Debian 또는 HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-versions-1 role=tab aria-controls=k8s-install-versions-1>CentOS, RHEL 또는 Fedora</a></li></ul><div class=tab-content id=k8s-install-versions><div id=k8s-install-versions-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-versions-0><p><pre><code>apt update
apt-cache madison kubeadm
# 목록에서 최신 버전(1.25)을 찾는다
# 1.25.x-00과 같아야 한다. 여기서 x는 최신 패치이다.
</code></pre></div><div id=k8s-install-versions-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-versions-1><p><pre><code>yum list --showduplicates kubeadm --disableexcludes=kubernetes
# 목록에서 최신 버전(1.25)을 찾는다
# 1.25.x-0과 같아야 한다. 여기서 x는 최신 패치이다.
</code></pre></div></div><h2 id=컨트롤-플레인-노드-업그레이드>컨트롤 플레인 노드 업그레이드</h2><p>컨트롤 플레인 노드의 업그레이드 절차는 한 번에 한 노드씩 실행해야 한다.
먼저 업그레이드할 컨트롤 플레인 노드를 선택한다. <code>/etc/kubernetes/admin.conf</code> 파일이 있어야 한다.</p><h3 id=kubeadm-upgrade-호출>"kubeadm upgrade" 호출</h3><p><strong>첫 번째 컨트롤 플레인 노드의 경우</strong></p><ul><li><p>kubeadm 업그레이드</p><p><ul class="nav nav-tabs" id=k8s-install-kubeadm-first-cp role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-kubeadm-first-cp-0 role=tab aria-controls=k8s-install-kubeadm-first-cp-0 aria-selected=true>Ubuntu, Debian 또는 HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-kubeadm-first-cp-1 role=tab aria-controls=k8s-install-kubeadm-first-cp-1>CentOS, RHEL 또는 Fedora</a></li></ul><div class=tab-content id=k8s-install-kubeadm-first-cp><div id=k8s-install-kubeadm-first-cp-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-kubeadm-first-cp-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> <span style=color:#080;font-style:italic># 1.25.x-00에서 x를 최신 패치 버전으로 바꾼다.</span>
</span></span><span style=display:flex><span> apt-mark unhold kubeadm <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b8860b>kubeadm</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> apt-mark hold kubeadm
</span></span></code></pre></div></div><div id=k8s-install-kubeadm-first-cp-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-kubeadm-first-cp-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-0에서 x를 최신 패치 버전으로 바꾼다.</span>
</span></span><span style=display:flex><span>yum install -y kubeadm-1.25.x-0 --disableexcludes<span style=color:#666>=</span>kubernetes
</span></span></code></pre></div></div></div><br></p></li><li><p>다운로드하려는 버전이 잘 받아졌는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm version
</span></span></code></pre></div></li><li><p>업그레이드 계획을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm upgrade plan
</span></span></code></pre></div><p>이 명령은 클러스터를 업그레이드할 수 있는지를 확인하고, 업그레이드할 수 있는 버전을 가져온다.
또한 컴포넌트 구성 버전 상태가 있는 표를 보여준다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 또한 <code>kubeadm upgrade</code> 는 이 노드에서 관리하는 인증서를 자동으로 갱신한다.
인증서 갱신을 하지 않으려면 <code>--certificate-renewal=false</code> 플래그를 사용할 수 있다.
자세한 내용은 <a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-certs>인증서 관리 가이드</a>를 참고한다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubeadm upgrade plan</code> 이 수동 업그레이드가 필요한 컴포넌트 구성을 표시하는 경우, 사용자는
<code>--config</code> 커맨드 라인 플래그를 통해 대체 구성이 포함된 구성 파일을 <code>kubeadm upgrade apply</code> 에 제공해야 한다.
그렇게 하지 않으면 <code>kubeadm upgrade apply</code> 가 오류와 함께 종료되고 업그레이드를 수행하지 않는다.</div></li><li><p>업그레이드할 버전을 선택하고, 적절한 명령을 실행한다. 예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 이 업그레이드를 위해 선택한 패치 버전으로 x를 바꾼다.</span>
</span></span><span style=display:flex><span>sudo kubeadm upgrade apply v1.25.x
</span></span></code></pre></div><p>명령이 완료되면 다음을 확인해야 한다.</p><pre tabindex=0><code>[upgrade/successful] SUCCESS! Your cluster was upgraded to &#34;v1.25.x&#34;. Enjoy!

[upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets if you haven&#39;t already done so.
</code></pre></li><li><p>CNI 제공자 플러그인을 수동으로 업그레이드한다.</p><p>CNI(컨테이너 네트워크 인터페이스) 제공자는 자체 업그레이드 지침을 따를 수 있다.
<a href=/ko/docs/concepts/cluster-administration/addons/>애드온</a> 페이지에서
사용하는 CNI 제공자를 찾고 추가 업그레이드 단계가 필요한지 여부를 확인한다.</p><p>CNI 제공자가 데몬셋(DaemonSet)으로 실행되는 경우 추가 컨트롤 플레인 노드에는 이 단계가 필요하지 않다.</p></li></ul><p><strong>다른 컨트롤 플레인 노드의 경우</strong></p><p>첫 번째 컨트롤 플레인 노드와 동일하지만 다음을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm upgrade node
</span></span></code></pre></div><p>아래 명령 대신 위의 명령을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm upgrade apply
</span></span></code></pre></div><p><code>kubeadm upgrade plan</code> 을 호출하고 CNI 공급자 플러그인을 업그레이드할 필요가 없다.</p><h3 id=노드-드레인>노드 드레인</h3><ul><li><p>스케줄 불가능(unschedulable)으로 표시하고 워크로드를 축출하여 유지 보수할 노드를 준비한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 드레인하는 노드의 이름으로 바꾼다.</span>
</span></span><span style=display:flex><span>kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</span></span></code></pre></div></li></ul><h3 id=kubelet과-kubectl-업그레이드>kubelet과 kubectl 업그레이드</h3><ul><li><p>모든 컨트롤 플레인 노드에서 kubelet 및 kubectl을 업그레이드한다.</p><p><ul class="nav nav-tabs" id=k8s-install-kubelet role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-kubelet-0 role=tab aria-controls=k8s-install-kubelet-0 aria-selected=true>Ubuntu, Debian 또는 HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-kubelet-1 role=tab aria-controls=k8s-install-kubelet-1>CentOS, RHEL 또는 Fedora</a></li></ul><div class=tab-content id=k8s-install-kubelet><div id=k8s-install-kubelet-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-kubelet-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># replace x in 1.25.x-00의 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>apt-mark unhold kubelet kubectl <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b8860b>kubelet</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#b8860b>kubectl</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-mark hold kubelet kubectl
</span></span></code></pre></div></div><div id=k8s-install-kubelet-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-kubelet-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-0에서 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>yum install -y kubelet-1.25.x-0 kubectl-1.25.x-0 --disableexcludes<span style=color:#666>=</span>kubernetes
</span></span></code></pre></div></div></div><br></p></li><li><p>kubelet을 다시 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart kubelet
</span></span></code></pre></div></li></ul><h3 id=노드-uncordon>노드 uncordon</h3><ul><li><p>노드를 스케줄 가능(schedulable)으로 표시하여 노드를 다시 온라인 상태로 전환한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 드레인하려는 노드의 이름으로 바꾼다.</span>
</span></span><span style=display:flex><span>kubectl uncordon &lt;node-to-drain&gt;
</span></span></code></pre></div></li></ul><h2 id=워커-노드-업그레이드>워커 노드 업그레이드</h2><p>워커 노드의 업그레이드 절차는 워크로드를 실행하는 데 필요한 최소 용량을 보장하면서,
한 번에 하나의 노드 또는 한 번에 몇 개의 노드로 실행해야 한다.</p><h3 id=kubeadm-업그레이드>kubeadm 업그레이드</h3><ul><li><p>모든 워커 노드에서 kubeadm을 업그레이드한다.</p><ul class="nav nav-tabs" id=k8s-install-kubeadm-worker-nodes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-kubeadm-worker-nodes-0 role=tab aria-controls=k8s-install-kubeadm-worker-nodes-0 aria-selected=true>Ubuntu, Debian 또는 HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-kubeadm-worker-nodes-1 role=tab aria-controls=k8s-install-kubeadm-worker-nodes-1>CentOS, RHEL 또는 Fedora</a></li></ul><div class=tab-content id=k8s-install-kubeadm-worker-nodes><div id=k8s-install-kubeadm-worker-nodes-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-kubeadm-worker-nodes-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-00의 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>apt-mark unhold kubeadm <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b8860b>kubeadm</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-mark hold kubeadm
</span></span></code></pre></div></div><div id=k8s-install-kubeadm-worker-nodes-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-kubeadm-worker-nodes-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-0에서 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>yum install -y kubeadm-1.25.x-0 --disableexcludes<span style=color:#666>=</span>kubernetes
</span></span></code></pre></div></div></div></li></ul><h3 id=kubeadm-upgrade-호출-1>"kubeadm upgrade" 호출</h3><ul><li><p>워커 노드의 경우 로컬 kubelet 구성을 업그레이드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm upgrade node
</span></span></code></pre></div></li></ul><h3 id=노드-드레인-1>노드 드레인</h3><ul><li><p>스케줄 불가능(unschedulable)으로 표시하고 워크로드를 축출하여 유지 보수할 노드를 준비한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 드레인하려는 노드 이름으로 바꾼다.</span>
</span></span><span style=display:flex><span>kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</span></span></code></pre></div></li></ul><h3 id=kubelet과-kubectl-업그레이드-1>kubelet과 kubectl 업그레이드</h3><ul><li><p>kubelet 및 kubectl을 업그레이드한다.</p><p><ul class="nav nav-tabs" id=k8s-kubelet-and-kubectl role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-kubelet-and-kubectl-0 role=tab aria-controls=k8s-kubelet-and-kubectl-0 aria-selected=true>Ubuntu, Debian 또는 HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-kubelet-and-kubectl-1 role=tab aria-controls=k8s-kubelet-and-kubectl-1>CentOS, RHEL 또는 Fedora</a></li></ul><div class=tab-content id=k8s-kubelet-and-kubectl><div id=k8s-kubelet-and-kubectl-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-kubelet-and-kubectl-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-00의 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>apt-mark unhold kubelet kubectl <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b8860b>kubelet</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#b8860b>kubectl</span><span style=color:#666>=</span>1.25.x-00 <span style=color:#666>&amp;&amp;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>apt-mark hold kubelet kubectl
</span></span></code></pre></div></div><div id=k8s-kubelet-and-kubectl-1 class=tab-pane role=tabpanel aria-labelledby=k8s-kubelet-and-kubectl-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 1.25.x-0에서 x를 최신 패치 버전으로 바꾼다</span>
</span></span><span style=display:flex><span>yum install -y kubelet-1.25.x-0 kubectl-1.25.x-0 --disableexcludes<span style=color:#666>=</span>kubernetes
</span></span></code></pre></div></div></div><br></p></li><li><p>kubelet을 다시 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart kubelet
</span></span></code></pre></div></li></ul><h3 id=노드에-적용된-cordon-해제>노드에 적용된 cordon 해제</h3><ul><li>스케줄 가능(schedulable)으로 표시하여 노드를 다시 온라인 상태로 만든다.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 노드의 이름으로 바꾼다.</span>
</span></span><span style=display:flex><span>kubectl uncordon &lt;node-to-drain&gt;
</span></span></code></pre></div><h2 id=클러스터-상태-확인>클러스터 상태 확인</h2><p>모든 노드에서 kubelet을 업그레이드한 후 kubectl이 클러스터에 접근할 수 있는 곳에서 다음의 명령을 실행하여
모든 노드를 다시 사용할 수 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><p>모든 노드에 대해 <code>STATUS</code> 열에 <code>Ready</code> 가 표시되어야 하고, 버전 번호가 업데이트되어 있어야 한다.</p><h2 id=장애-상태에서의-복구>장애 상태에서의 복구</h2><p>예를 들어 <code>kubeadm upgrade</code> 를 실행하는 중에 예기치 못한 종료로 인해 업그레이드가 실패하고 롤백하지 않는다면, <code>kubeadm upgrade</code> 를 다시 실행할 수 있다.
이 명령은 멱등성을 보장하며 결국 실제 상태가 선언한 의도한 상태인지 확인한다.</p><p>잘못된 상태에서 복구하기 위해, 클러스터가 실행 중인 버전을 변경하지 않고 <code>kubeadm upgrade apply --force</code> 를 실행할 수도 있다.</p><p>업그레이드하는 동안 kubeadm은 <code>/etc/kubernetes/tmp</code> 아래에 다음과 같은 백업 폴더를 작성한다.</p><ul><li><code>kubeadm-backup-etcd-&lt;date>-&lt;time></code></li><li><code>kubeadm-backup-manifests-&lt;date>-&lt;time></code></li></ul><p><code>kubeadm-backup-etcd</code> 는 컨트롤 플레인 노드에 대한 로컬 etcd 멤버 데이터의 백업을 포함한다.
etcd 업그레이드가 실패하고 자동 롤백이 작동하지 않으면, 이 폴더의 내용을
<code>/var/lib/etcd</code> 에서 수동으로 복원할 수 있다. 외부 etcd를 사용하는 경우 이 백업 폴더는 비어있다.</p><p><code>kubeadm-backup-manifests</code> 는 컨트롤 플레인 노드에 대한 정적 파드 매니페스트 파일의 백업을 포함한다.
업그레이드가 실패하고 자동 롤백이 작동하지 않으면, 이 폴더의 내용을
<code>/etc/kubernetes/manifests</code> 에서 수동으로 복원할 수 있다. 어떤 이유로 특정 컴포넌트의 업그레이드 전
매니페스트 파일과 업그레이드 후 매니페스트 파일 간에 차이가 없는 경우, 백업 파일은 기록되지 않는다.</p><h2 id=작동-원리>작동 원리</h2><p><code>kubeadm upgrade apply</code> 는 다음을 수행한다.</p><ul><li>클러스터가 업그레이드 가능한 상태인지 확인한다.<ul><li>API 서버에 접근할 수 있다</li><li>모든 노드가 <code>Ready</code> 상태에 있다</li><li>컨트롤 플레인이 정상적으로 동작한다</li></ul></li><li>버전 차이(skew) 정책을 적용한다.</li><li>컨트롤 플레인 이미지가 사용 가능한지 또는 머신으로 가져올 수 있는지 확인한다.</li><li>컴포넌트 구성에 버전 업그레이드가 필요한 경우 대체 구성을 생성하거나 사용자가 제공한 것으로 덮어 쓰기한다.</li><li>컨트롤 플레인 컴포넌트 또는 롤백 중 하나라도 나타나지 않으면 업그레이드한다.</li><li>새로운 <code>CoreDNS</code> 와 <code>kube-proxy</code> 매니페스트를 적용하고 필요한 모든 RBAC 규칙이 생성되도록 한다.</li><li>API 서버의 새 인증서와 키 파일을 작성하고 180일 후에 만료될 경우 이전 파일을 백업한다.</li></ul><p><code>kubeadm upgrade node</code> 는 추가 컨트롤 플레인 노드에서 다음을 수행한다.</p><ul><li>클러스터에서 kubeadm <code>ClusterConfiguration</code> 을 가져온다.</li><li>선택적으로 kube-apiserver 인증서를 백업한다.</li><li>컨트롤 플레인 컴포넌트에 대한 정적 파드 매니페스트를 업그레이드한다.</li><li>이 노드의 kubelet 구성을 업그레이드한다.</li></ul><p><code>kubeadm upgrade node</code> 는 워커 노드에서 다음을 수행한다.</p><ul><li>클러스터에서 kubeadm <code>ClusterConfiguration</code> 을 가져온다.</li><li>이 노드의 kubelet 구성을 업그레이드한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e805c7d8d4ad6195cb82dbbc843bfc29>3.1.3 - 윈도우 노드 업그레이드</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [beta]</code></div><p>이 페이지는 <a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadm으로 생성된</a> 윈도우 노드를 업그레이드하는 방법을 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: 1.17.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><ul><li><a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade>남은 kubeadm 클러스터를 업그레이드하는 프로세스</a>에
익숙해져야 한다. 윈도우 노드를
업그레이드하기 전에 컨트롤 플레인 노드를 업그레이드해야 한다.</li></ul><h2 id=워커-노드-업그레이드>워커 노드 업그레이드</h2><h3 id=kubeadm-업그레이드>kubeadm 업그레이드</h3><ol><li><p>윈도우 노드에서, kubeadm을 업그레이드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#080;font-style:italic># v1.25.0을 사용 중인 쿠버네티스 버전으로 변경한다.</span>
</span></span><span style=display:flex><span>curl.exe -Lo &lt;kubeadm.exe<span>을</span> <span>저장할</span> <span>경로</span>&gt; <span style=color:#b44>&#34;https://dl.k8s.io/v1.25.0/bin/windows/amd64/kubeadm.exe&#34;</span>
</span></span></code></pre></div></li></ol><h3 id=노드-드레인>노드 드레인</h3><ol><li><p>쿠버네티스 API에 접근할 수 있는 머신에서,
스케줄 불가능한 것으로 표시하고 워크로드를 축출하여 유지 보수할 노드를 준비한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 드레이닝하려는 노드 이름으로 바꾼다</span>
</span></span><span style=display:flex><span>kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</span></span></code></pre></div><p>다음과 비슷한 출력이 표시되어야 한다.</p><pre tabindex=0><code>node/ip-172-31-85-18 cordoned
node/ip-172-31-85-18 drained
</code></pre></li></ol><h3 id=kubelet-구성-업그레이드>kubelet 구성 업그레이드</h3><ol><li><p>윈도우 노드에서, 다음의 명령을 호출하여 새 kubelet 구성을 동기화한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>kubeadm upgrade node
</span></span></code></pre></div></li></ol><h3 id=kubelet-및-kube-proxy-업그레이드>kubelet 및 kube-proxy 업그레이드</h3><ol><li><p>윈도우 노드에서, kubelet을 업그레이드하고 다시 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>stop-service</span> kubelet
</span></span><span style=display:flex><span>curl.exe -Lo &lt;kubelet.exe<span>을</span> <span>저장할</span> <span>경로</span>&gt; <span style=color:#b44>&#34;https://dl.k8s.io/v1.25.0/bin/windows/amd64/kubelet.exe&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>restart-service</span> kubelet
</span></span></code></pre></div></li><li><p>윈도우 노드에서, kube-proxy를 업그레이드하고 다시 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>stop-service</span> <span style=color:#a2f>kube-proxy</span>
</span></span><span style=display:flex><span>curl.exe -Lo &lt;<span style=color:#a2f>kube-proxy</span>.exe<span>을</span> <span>저장할</span> <span>경로</span>&gt; <span style=color:#b44>&#34;https://dl.k8s.io/v1.25.0/bin/windows/amd64/kube-proxy.exe&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>restart-service</span> <span style=color:#a2f>kube-proxy</span>
</span></span></code></pre></div></li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 만약 kube-proxy를 윈도우 서비스로 실행중이지 않고 파드 내의 HostProcess 컨테이너에서 실행중이라면, 새로운 버전의 kube-proxy 매니페스트를 적용함으로써 업그레이드할 수 있다.</div><h3 id=노드에-적용된-cordon-해제>노드에 적용된 cordon 해제</h3><ol><li><p>쿠버네티스 API에 접근할 수 있는 머신에서,
스케줄 가능으로 표시하여 노드를 다시 온라인으로 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;을 노드의 이름으로 바꾼다</span>
</span></span><span style=display:flex><span>kubectl uncordon &lt;node-to-drain&gt;
</span></span></code></pre></div></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-adb6c52e773f4d890595e14a9251f59b>3.2 - 도커심으로부터 마이그레이션</h1><p>이 섹션은 도커심에서 다른 컨테이너 런타임으로
마이그레이션할 때에 알아야 할 정보를 제공한다.</p><p>쿠버네티스 1.20에서의 <a href=/blog/2020/12/08/kubernetes-1-20-release-announcement/#dockershim-deprecation>도커심 사용 중단(deprecation)</a> 발표 이후,
이것이 다양한 워크로드와 쿠버네티스 설치에
어떻게 영향을 미칠지에 대한 질문이 많았다. <a href=/blog/2022/02/17/dockershim-faq/>도커심 제거 FAQ</a>는
관련된 문제를 더 잘 이해할 수 있도록 도움을 준다.</p><p>도커심은 쿠버네티스 릴리스 v1.24부터 제거되었다.
컨테이너 런타임으로 도커 엔진을 통한 도커심을 사용하는 상황에서 v1.24로
업그레이드하려는 경우, 다른 런타임으로 마이그레이션하거나 다른 방법을 찾아 도커 엔진 지원을 받는 것이 좋다.
선택 가능한 옵션은 <a href=/ko/docs/setup/production-environment/container-runtimes/>컨테이너 런타임</a> 섹션에서 확인한다.
마이그레이션 중 문제를 마주한다면
<a href=https://github.com/kubernetes/kubernetes/issues>문제를 보고</a>하면 좋다. 이를 통해 문제를 시기적절하게
해결할 수 있으며, 클러스터도 도커심 제거에
대비할 수 있다.</p><p>클러스터는 두 종류 이상의 노드들을 포함할 수 있지만
이는 일반적인 구성은 아니다.</p><p>다음 작업을 통해 마이그레이션을 수행할 수 있다.</p><ul><li><a href=/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-removal-affects-you/>도커심 제거가 당신에게 영향을 미치는지 확인하기</a></li><li><a href=/docs/tasks/administer-cluster/migrating-from-dockershim/migrate-dockershim-dockerd/>도커 엔진 노드를 도커심에서 cri-dockerd로 마이그레이션하기</a></li><li><a href=/docs/tasks/administer-cluster/migrating-from-dockershim/migrating-telemetry-and-security-agents/>도커심으로부터 보안 및 텔레메트리 에이전트 마이그레이션하기</a></li></ul><h2 id=다음-내용>다음 내용</h2><ul><li>컨테이너 런타임에 대한 옵션을 이해하기 위해
<a href=/ko/docs/setup/production-environment/container-runtimes/>컨테이너 런타임</a>을 확인한다.</li></ul><ul><li>도커심의
사용 중단 및 제거에 대한 논의를 추적하는
<a href=https://github.com/kubernetes/kubernetes/issues/106917>깃허브 이슈</a>가 있다.</li><li>도커심에서 마이그레이션하는 것에 관한
결함이나 다른 기술적 문제를 발견한다면,
쿠버네티스 프로젝트에 <a href=https://github.com/kubernetes/kubernetes/issues/new/choose>이슈를 남길 수 있다.</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d81ef0973a7bb4813e1797a452864742>3.2.1 - 도커 엔진 노드를 도커심에서 cri-dockerd로 마이그레이션하기</h1><div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div><p>이 페이지는 도커 엔진 노드가 도커심 대신 <code>cri-dockerd</code>를 사용하도록 마이그레이션하는 방법을 보여 준다.
다음 시나리오에서는 아래 단계를 따라야 한다.</p><ul><li>도커심 사용은 중단하고 싶지만,
쿠버네티스의 컨테이너 실행에는 여전히 도커 엔진을 사용하기를 원하는 경우</li><li>쿠버네티스 버전 v1.25로 업그레이드를 원하고
기존 클러스터가 도커심을 사용하는 경우.
이러한 경우에는 도커심을 다른 것으로 대체해야 하며 <code>cri-dockerd</code>도 선택지 중 하나이다.</li></ul><p>도커심 제거에 관하여 더 배우려면, <a href=/dockershim>FAQ page</a>를 읽어보자.</p><h2 id=what-is-cri-dockerd>cri-dockerd란 무엇인가?</h2><p>쿠버네티스 1.23 이하에서는 <em>도커심</em> 이라는 이름의 쿠버네티스 내장 구성요소를 사용하여
도커 엔진을 쿠버네티스 컨테이너 런타임으로 사용할 수 있었다.
도커심 구성 요소는 쿠버네티스 1.24 릴리스에서 제거되었지만,
대신 서드 파티 대체제 <code>cri-dockerd</code>를 사용할 수 있다.
<code>cri-dockerd</code> 어댑터를 사용하면 <a class=glossary-tooltip title='Kubelet과 컨테이너 런타임을 통합시키기 위한 API' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%9f%b0%ed%83%80%ec%9e%84 target=_blank aria-label='컨테이너 런타임 인터페이스(Container runtime interface, CRI)'>컨테이너 런타임 인터페이스(Container runtime interface, CRI)</a>를 통해 도커 엔진을 사용할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이미 <code>cri-dockerd</code>를 사용한다면, 도커심 제거에 의한 영향은 받지 않는다.
시작하기 전에, <a href=/docs/tasks/administer-cluster/migrating-from-dockershim/find-out-runtime-you-use/>노드가 도커심을 사용하는지 확인</a>하자.</div><p>컨테이너 런타임으로 도커 엔진을 계속 사용할 수 있도록
<code>cri-dockerd</code>로 마이그레이션하려는 경우
영향을 받는 각각의 노드에 아래 내용을 진행해야 한다.</p><ol><li><code>cri-dockerd</code>를 설치한다.</li><li>노드를 통제(cordon)하고 비운다(drain).</li><li><code>cri-dockerd</code>를 사용하도록 kubelet를 설정한다.</li><li>kubelet을 재시작한다.</li><li>노드가 정상(healthy)인지 확인한다.</li></ol><p>중요하지 않은(non-critical) 노드에서 먼저 테스트한다.</p><p><code>cri-dockerd</code>로 마이그레이션하려는 각 노드에 대해
아래 단계를 수행해야 한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><a href=https://github.com/mirantis/cri-dockerd#build-and-install><code>cri-dockerd</code></a>를
각 노드에 설치하고 시작한다.</li><li><a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>네트워크 플러그인</a>.</li></ul><h2 id=노드의-통제-cordon-와-비우기-drain>노드의 통제(Cordon)와 비우기(drain)</h2><ol><li><p>새로운 파드를 노드에 스케줄링하는 것을 막기 위해 노드를 통제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon &lt;NODE_NAME&gt;
</span></span></code></pre></div><p><code>&lt;NODE_NAME></code> 부분에 노드의 이름을 입력한다.</p></li><li><p>실행 중인 파드를 안전하게 축출하기 위해 노드를 비운다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl drain &lt;NODE_NAME&gt; <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --ignore-daemonsets
</span></span></code></pre></div></li></ol><h2 id=cri-dockerd를-사용하도록-kubelet-설정>cri-dockerd를 사용하도록 kubelet 설정</h2><p>아래의 단계는 kubeadm 도구를 사용하여 생성된 클러스터에 적용된다.
다른 도구를 사용했다면, 해당 도구에 대한 환경 설정 방법을 참고하여
kubelet 환경 설정을 수정해야 한다.</p><ol><li>영향 받는 각 노드의 <code>/var/lib/kubelet/kubeadm-flags.env</code>를 연다.</li><li><code>--container-runtime-endpoint</code> 플래그를
<code>unix:///var/run/cri-dockerd.sock</code>로 수정한다.</li></ol><p>kubeadm 도구는 노드의 소켓을 컨트롤 플레인의 <code>Node</code> 오브젝트의 어노테이션으로 저장한다.
영향을 받는 각 노드의 해당 소켓을 수정하려면 다음을 따른다.</p><ol><li><p><code>Node</code> 오브젝트의 YAML 표현식을 편집한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>/path/to/admin.conf kubectl edit no &lt;NODE_NAME&gt;
</span></span></code></pre></div><p>각 인자는 다음과 같이 입력한다.</p><ul><li><code>/path/to/admin.conf</code>:
kubectl 환경 설정 파일(<code>admin.conf</code>)의 경로.</li><li><code>&lt;NODE_NAME></code>: 수정을 원하는 노드의 이름.</li></ul></li><li><p><code>kubeadm.alpha.kubernetes.io/cri-socket</code>의 값
<code>/var/run/dockershim.sock</code>을 <code>unix:///var/run/cri-dockerd.sock</code>로 변경한다.</p></li><li><p>변경을 저장한다. <code>Node</code> 오브젝트는 저장 시 업데이트된다.</p></li></ol><h2 id=kubelet-재시작>kubelet 재시작</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>systemctl restart kubelet
</span></span></code></pre></div><h2 id=노드가-정상-healthy-인지-확인>노드가 정상(healthy)인지 확인</h2><p>노드가 <code>cri-dockerd</code> 엔드포인트를 사용하는지 확인하려면,
<a href=/docs/tasks/administer-cluster/migrating-from-dockershim/find-out-runtime-you-use/>사용 런타임 찾기</a> 지침을 따른다.
kubelet의 <code>--container-runtime-endpoint</code> 플래그는 <code>unix:///var/run/cri-dockerd.sock</code> 이어야 한다.</p><h2 id=노드-통제-해제-uncordon>노드 통제 해제(Uncordon)</h2><p>노드에 파드를 스케줄 하도록 통제를 해제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl uncordon &lt;NODE_NAME&gt;
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/dockershim/>도커심 제거 FAQ</a> 읽기.</li><li><a href=/docs/tasks/administer-cluster/migrating-from-dockershim/change-runtime-containerd/>도커 엔진의 도커심을 containerd로 마이그레이션하는 방법 알아보기</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-47be5dd51f686017f1766e6ec7aa6f41>3.3 - 메모리, CPU 와 API 리소스 관리</h1></div><div class=td-content><h1 id=pg-337620c76587e4aeb32009cb23be46de>3.3.1 - 네임스페이스에 대한 기본 메모리 요청량과 상한 구성</h1><div class=lead>한 네임스페이스에 메모리 리소스 상한의 기본값을 정의하며, 이를 통해 미리 설정한 메모리 리소스 상한이 해당 네임스페이스의 새로운 파드에 설정되도록 한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에 대한
기본 메모리 요청량(request) 및 상한(limit)을 구성하는 방법을 보여준다.</p><p>쿠버네티스 클러스터를 여러 네임스페이스로 나눌 수 있다.
기본 메모리 <a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EC%9A%94%EC%B2%AD-%EB%B0%8F-%EC%A0%9C%ED%95%9C>상한</a>이
설정되어 있는 네임스페이스에 파드를 생성했는데,
해당 파드의 모든 컨테이너에 메모리 상한이 명시되어 있지 않다면,
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>이
해당 컨테이너에
기본 메모리 상한을 할당한다.</p><p>쿠버네티스는 이 문서의 뒷부분에서 설명하는 특정 조건에서 기본 메모리 요청량을 할당한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><p>클러스터의 각 노드에는 최소 2GiB의 메모리가 있어야 한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 연습에서 생성한 리소스가 클러스터의 다른 리소스와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace default-mem-example
</span></span></code></pre></div><h2 id=리밋레인지-limitrange-와-파드-생성>리밋레인지(LimitRange)와 파드 생성</h2><p>다음은 예시 <a class=glossary-tooltip title='네임스페이스 내에 컨테이너나 파드당 리소스 소비를 한정하는 제약 조건을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/limit-range/ target=_blank aria-label=리밋레인지>리밋레인지</a>에 대한 매니페스트이다.
이 매니페스트는 기본 메모리 요청량 및
기본 메모리 상한을 지정한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-defaults.yaml download=admin/resource/memory-defaults.yaml><code>admin/resource/memory-defaults.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-defaults-yaml")' title="Copy admin/resource/memory-defaults.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-defaults-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-limit-range<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>default</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>512Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultRequest</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>256Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>default-mem-example 네임스페이스에 리밋레인지를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults.yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>이제 파드를 <code>default-mem-example</code> 네임스페이스에 생성하고,
해당 파드의 어떤 컨테이너도 자체 메모리 요청량(request)과 상한(limit)을 명시하지 않으면,
컨트롤 플레인이 해당 컨테이너에 메모리 요청량의 기본값(256 MiB)과
상한의 기본값(512 MiB)을 지정한다.</p><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
해당 컨테이너는 메모리 요청량과 상한을 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-defaults-pod.yaml download=admin/resource/memory-defaults-pod.yaml><code>admin/resource/memory-defaults-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-defaults-pod-yaml")' title="Copy admin/resource/memory-defaults-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-defaults-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod.yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod default-mem-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>출력 결과는 파드의 컨테이너에 256MiB의 메모리 요청량과
512MiB의 메모리 상한이 있음을 나타낸다. 이것은 리밋레인지에 의해 지정된 기본값이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>containers:
</span></span><span style=display:flex><span>- image: nginx
</span></span><span style=display:flex><span>  imagePullPolicy: Always
</span></span><span style=display:flex><span>  name: default-mem-demo-ctr
</span></span><span style=display:flex><span>  resources:
</span></span><span style=display:flex><span>    limits:
</span></span><span style=display:flex><span>      memory: 512Mi
</span></span><span style=display:flex><span>    requests:
</span></span><span style=display:flex><span>      memory: 256Mi
</span></span></code></pre></div><p>파드를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod default-mem-demo --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><h2 id=컨테이너-상한은-지정하고-요청량을-지정하지-않으면-어떻게-되나>컨테이너 상한은 지정하고, 요청량을 지정하지 않으면 어떻게 되나?</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
해당 컨테이너는 메모리 상한은 지정하지만, 요청량은 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-defaults-pod-2.yaml download=admin/resource/memory-defaults-pod-2.yaml><code>admin/resource/memory-defaults-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-defaults-pod-2-yaml")' title="Copy admin/resource/memory-defaults-pod-2.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-defaults-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1Gi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod-2.yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod default-mem-demo-2 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>출력 결과는 컨테이너의 메모리 요청량이 메모리 상한과 일치하도록 설정되었음을 보여준다.
참고로 컨테이너에는 기본 메모리 요청량의 값인 256Mi가 할당되지 않았다.</p><pre tabindex=0><code>resources:
  limits:
    memory: 1Gi
  requests:
    memory: 1Gi
</code></pre><h2 id=컨테이너의-요청량은-지정하고-상한을-지정하지-않으면-어떻게-되나>컨테이너의 요청량은 지정하고, 상한을 지정하지 않으면 어떻게 되나?</h2><p>다음은 컨테이너가 하나인 파드의 예시 매니페스트이다.
해당 컨테이너는 메모리 요청량은 지정하지만, 상한은 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-defaults-pod-3.yaml download=admin/resource/memory-defaults-pod-3.yaml><code>admin/resource/memory-defaults-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-defaults-pod-3-yaml")' title="Copy admin/resource/memory-defaults-pod-3.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-defaults-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-mem-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-defaults-pod-3.yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>파드 사양을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod default-mem-demo-3 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-mem-example
</span></span></code></pre></div><p>출력을 보면 컨테이너의 매니페스트에 명시한 값대로 컨테이너의 메모리 요청량이 설정된 것을 알 수 있다.
해당 컨테이너의 메모리 상한은 512 MiB로 설정되며,
이는 네임스페이스의 메모리 상한 기본값과 일치한다.</p><pre tabindex=0><code>resources:
  limits:
    memory: 512Mi
  requests:
    memory: 128Mi
</code></pre><h2 id=기본-메모리-상한-및-요청량에-대한-동기>기본 메모리 상한 및 요청량에 대한 동기</h2><p>네임스페이스에 <a class=glossary-tooltip title='네임스페이스당 전체 리소스 소비를 제한하는 제약을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/resource-quotas/ target=_blank aria-label='리소스 쿼터'>리소스 쿼터</a>가
설정되어 있는 경우,
메모리 상한에 기본값을 설정하는 것이 좋다.
다음은 리소스 쿼터가 네임스페이스에 적용하는 세 가지 제한 사항이다.</p><ul><li>네임스페이스에서 실행되는 모든 파드에 대해, 모든 컨테이너에 메모리 상한이 있어야 한다.
(파드의 모든 컨테이너에 대해 메모리 상한을 지정하면,
쿠버네티스가 파드 내의 컨테이너의 상한을 합산하여 파드-수준 메모리 상한을 추론할 수 있다.)</li><li>메모리 상한은 해당 파드가 스케줄링될 노드에 리소스 예약을 적용한다.
해당 네임스페이스의 모든 파드에 대해 예약된 메모리 총량이 지정된 상한을 초과하지 않아야 한다.</li><li>해당 네임스페이스의 모든 파드가 실제로 사용하고 있는 메모리의 총량 또한 지정된 상한을 초과하지 않아야 한다.</li></ul><p>리밋레인지를 추가할 때에는 다음을 고려해야 한다.</p><p>컨테이너를 갖고 있는 해당 네임스페이스의 파드가 자체 메모리 상한을 지정하지 않았다면,
컨트롤 플레인이 해당 컨테이너에 메모리 상한 기본값을 적용하며,
해당 파드는 메모리 리소스쿼터가 적용된 네임스페이스에서 실행되도록 허용될 수 있다.</p><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace default-mem-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 대한 파드 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너 및 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-320af95e480962c538ebef7ae205845c>3.3.2 - 네임스페이스에 대한 기본 CPU 요청량과 상한 구성</h1><div class=lead>한 네임스페이스에 CPU 리소스 상한의 기본값을 정의하며, 이를 통해 미리 설정한 CPU 리소스 상한이 해당 네임스페이스의 새로운 파드에 설정되도록 한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에 대한
기본 CPU 요청량(request) 및 상한(limit)을 구성하는 방법을 보여준다.</p><p>쿠버네티스 클러스터를 여러 네임스페이스로 나눌 수 있다.
기본 CPU <a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EC%9A%94%EC%B2%AD-%EB%B0%8F-%EC%A0%9C%ED%95%9C>상한</a>이
설정되어 있는 네임스페이스에 파드를 생성했는데,
해당 파드의 모든 컨테이너에 CPU 상한이 명시되어 있지 않다면,
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>이
해당 컨테이너에 기본 CPU 상한을 할당한다.</p><p>쿠버네티스는 기본 CPU
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EC%9A%94%EC%B2%AD-%EB%B0%8F-%EC%A0%9C%ED%95%9C>사용량</a>을 할당하는데,
이는 이 페이지의 이후 부분에서 설명될 특정 조건 하에서만 수행된다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><p>쿠버네티스에서 “1.0 CPU”가 무엇을 의미하는지 익숙하지 않다면,
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#cpu%EC%9D%98-%EC%9D%98%EB%AF%B8>CPU의 의미</a>를 참조한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 연습에서 생성한 리소스가 클러스터의 나머지와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace default-cpu-example
</span></span></code></pre></div><h2 id=리밋레인지-limitrange-와-파드-생성>리밋레인지(LimitRange)와 파드 생성</h2><p>다음은 예시 <a class=glossary-tooltip title='네임스페이스 내에 컨테이너나 파드당 리소스 소비를 한정하는 제약 조건을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/limit-range/ target=_blank aria-label=리밋레인지>리밋레인지</a>에 대한 매니페스트이다.
이 매니페스트는 기본 CPU 요청량 및 기본 CPU 상한을 지정한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-defaults.yaml download=admin/resource/cpu-defaults.yaml><code>admin/resource/cpu-defaults.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-defaults-yaml")' title="Copy admin/resource/cpu-defaults.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-defaults-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-limit-range<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>default</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultRequest</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>0.5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>default-cpu-example 네임스페이스에 리밋레인지를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</span></span></code></pre></div><p>이제 파드를 <code>default-cpu-example</code> 네임스페이스에 생성하고,
해당 파드의 어떤 컨테이너도 자체 CPU 요청량(request)과 상한(limit)을 명시하지 않으면,
컨트롤 플레인이 해당 컨테이너에 CPU 요청량의 기본값(0.5)과
상한의 기본값(1)을 지정한다.</p><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
해당 컨테이너는 CPU 요청량과 상한을 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-defaults-pod.yaml download=admin/resource/cpu-defaults-pod.yaml><code>admin/resource/cpu-defaults-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-defaults-pod-yaml")' title="Copy admin/resource/cpu-defaults-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-defaults-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</span></span></code></pre></div><p>파드의 사양을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod default-cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>default-cpu-example
</span></span></code></pre></div><p>출력을 보면 파드 내 유일한 컨테이너의 CPU 요청량이 500m <code>cpu</code>("500 밀리cpu"로 읽을 수 있음)이고,
CPU 상한이 1 <code>cpu</code>임을 알 수 있다.
이것은 리밋레인지에 의해 지정된 기본값이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>containers:
</span></span><span style=display:flex><span>- image: nginx
</span></span><span style=display:flex><span>  imagePullPolicy: Always
</span></span><span style=display:flex><span>  name: default-cpu-demo-ctr
</span></span><span style=display:flex><span>  resources:
</span></span><span style=display:flex><span>    limits:
</span></span><span style=display:flex><span>      cpu: <span style=color:#b44>&#34;1&#34;</span>
</span></span><span style=display:flex><span>    requests:
</span></span><span style=display:flex><span>      cpu: 500m
</span></span></code></pre></div><h2 id=컨테이너-상한은-지정하고-요청량을-지정하지-않으면-어떻게-되나>컨테이너 상한은 지정하고, 요청량을 지정하지 않으면 어떻게 되나?</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
해당 컨테이너는 CPU 상한은 지정하지만, 요청량은 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-defaults-pod-2.yaml download=admin/resource/cpu-defaults-pod-2.yaml><code>admin/resource/cpu-defaults-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-defaults-pod-2-yaml")' title="Copy admin/resource/cpu-defaults-pod-2.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-defaults-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod-2.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</span></span></code></pre></div><p>생성한 파드의
<a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%AA%85%EC%84%B8-spec-%EC%99%80-%EC%83%81%ED%83%9C-status>명세</a>를 확인한다.</p><pre tabindex=0><code>kubectl get pod default-cpu-demo-2 --output=yaml --namespace=default-cpu-example
</code></pre><p>출력 결과는 컨테이너의 CPU 요청량이 CPU 상한과 일치하도록 설정되었음을 보여준다.
참고로 컨테이너에는 CPU 요청량의 기본값인 0.5 <code>cpu</code>가 할당되지 않았다.</p><pre tabindex=0><code>resources:
  limits:
    cpu: &#34;1&#34;
  requests:
    cpu: &#34;1&#34;
</code></pre><h2 id=컨테이너의-요청량은-지정하고-상한을-지정하지-않으면-어떻게-되나>컨테이너의 요청량은 지정하고, 상한을 지정하지 않으면 어떻게 되나?</h2><p>다음은 컨테이너가 하나인 파드의 예시 매니페스트이다.
해당 컨테이너는 CPU 요청량은 지정하지만, 상한은 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-defaults-pod-3.yaml download=admin/resource/cpu-defaults-pod-3.yaml><code>admin/resource/cpu-defaults-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-defaults-pod-3-yaml")' title="Copy admin/resource/cpu-defaults-pod-3.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-defaults-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-cpu-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0.75&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-defaults-pod-3.yaml --namespace<span style=color:#666>=</span>default-cpu-example
</span></span></code></pre></div><p>생성한 파드의
<a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%AA%85%EC%84%B8-spec-%EC%99%80-%EC%83%81%ED%83%9C-status>명세</a>를 확인한다.</p><pre tabindex=0><code>kubectl get pod default-cpu-demo-3 --output=yaml --namespace=default-cpu-example
</code></pre><p>출력을 보면 파드 생성 시 명시한 값대로
컨테이너의 CPU 요청량이 설정된 것을 알 수 있다(다시 말해, 매니페스트와 일치한다).
그러나, 해당 컨테이너의 CPU 상한은 1 <code>cpu</code>로 설정되며,
이는 네임스페이스의 CPU 상한 기본값이다.</p><pre tabindex=0><code>resources:
  limits:
    cpu: &#34;1&#34;
  requests:
    cpu: 750m
</code></pre><h2 id=cpu-상한-및-요청량의-기본값에-대한-동기>CPU 상한 및 요청량의 기본값에 대한 동기</h2><p>네임스페이스에 <a class=glossary-tooltip title='네임스페이스당 전체 리소스 소비를 제한하는 제약을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/resource-quotas/ target=_blank aria-label='리소스 쿼터'>리소스 쿼터</a>가
설정되어 있는 경우,
CPU 상한에 대해 기본값을 설정하는 것이 좋다.
다음은 CPU 리소스 쿼터가 네임스페이스에 적용하는 두 가지 제한 사항이다.</p><ul><li>네임스페이스에서 실행되는 모든 파드에 대해, 모든 컨테이너에 CPU 상한이 있어야 한다.</li><li>CPU 상한은 해당 파드가 스케줄링될 노드에 리소스 예약을 적용한다.
해당 네임스페이스의 모든 파드에 대해 예약된 CPU 총량이
지정된 상한을 초과하지 않아야 한다.</li></ul><p>리밋레인지를 추가할 때에는 다음을 고려해야 한다.</p><p>컨테이너를 갖고 있는 해당 네임스페이스의 파드가 자체 CPU 상한을 지정하지 않았다면,
컨트롤 플레인이 해당 컨테이너에 CPU 상한 기본값을 적용하며,
해당 파드는 CPU 리소스쿼터가 적용된 네임스페이스에서 실행되도록 허용될 수 있다.</p><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace default-cpu-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 대한 파드 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너 및 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-adb489b1ab985c9215657b0d4c6ae92b>3.3.3 - 네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</h1><div class=lead>한 네임스페이스 내에서 메모리 리소스 제한의 유효한 범위를 정의하며, 이를 통해 해당 네임스페이스의 새로운 파드가 미리 설정한 범위 안에 들어오도록 한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에서
실행되는 컨테이너가 사용하는 메모리의 최솟값과 최댓값을 설정하는 방법을 보여준다.
<a href=/docs/reference/kubernetes-api/policy-resources/limit-range-v1/>리밋레인지(LimitRange)</a>
오브젝트에 최소 및 최대 메모리 값을
지정한다. 파드가 리밋레인지에 의해 부과된 제약 조건을 충족하지 않으면,
네임스페이스에서 생성될 수 없다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><p>클러스터의 각 노드에는 파드가 사용할 수 있는 메모리가 최소 1GiB 이상 있어야 한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 연습에서 생성한 리소스가 클러스터의 나머지와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace constraints-mem-example
</span></span></code></pre></div><h2 id=리밋레인지와-파드-생성>리밋레인지와 파드 생성</h2><p>다음은 리밋레인지의 예시 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-constraints.yaml download=admin/resource/memory-constraints.yaml><code>admin/resource/memory-constraints.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-yaml")' title="Copy admin/resource/memory-constraints.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-min-max-demo-lr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>500Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>리밋레인지를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>리밋레인지에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get limitrange mem-min-max-demo-lr --namespace<span style=color:#666>=</span>constraints-mem-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력 결과는 예상대로 메모리의 최소 및 최대 제약 조건을 보여준다. 그러나
참고로 리밋레인지의 구성 파일에 기본값(default)을
지정하지 않아도 자동으로 생성된다.</p><pre tabindex=0><code>  limits:
  - default:
      memory: 1Gi
    defaultRequest:
      memory: 1Gi
    max:
      memory: 1Gi
    min:
      memory: 500Mi
    type: Container
</code></pre><p>이제 <code>constraints-mem-example</code> 네임스페이스에 파드를 생성할 때마다,
쿠버네티스는 다음 단계를 수행한다.</p><ul><li><p>해당 파드의 어떤 컨테이너도 자체 메모리 요청량(request)과 상한(limit)을 명시하지 않으면,
컨트롤 플레인이 해당 컨테이너에 메모리 요청량과 상한의 기본값(default)을 지정한다.</p></li><li><p>해당 파드의 모든 컨테이너의 메모리 요청량이 최소 500 MiB 이상인지 확인한다.</p></li><li><p>해당 파드의 모든 컨테이너의 메모리 요청량이 1024 MiB(1 GiB)를 넘지 않는지
확인한다.</p></li></ul><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
파드 명세 내에, 파드의 유일한 컨테이너는 600 MiB의 메모리 요청량 및 800 MiB의 메모리 상한을 지정하고 있다.
이는 리밋레인지에 의해 부과된 최소 및 최대 메모리 제약 조건을 충족시킨다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-constraints-pod.yaml download=admin/resource/memory-constraints-pod.yaml><code>admin/resource/memory-constraints-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-yaml")' title="Copy admin/resource/memory-constraints-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;600Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>파드가 실행 중이고 컨테이너의 상태가 정상인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-mem-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>출력을 보면 파드의 컨테이너의 메모리 요청량이 600 MiB이고 메모리 상한이 800 MiB임을 알 수 있다.
이는 리밋레인지에 의해 해당 네임스페이스에 부과된 제약 조건을
만족시킨다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>800Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>600Mi<span style=color:#bbb>
</span></span></span></code></pre></div><p>파드를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><h2 id=최대-메모리-제약-조건을-초과하는-파드-생성-시도>최대 메모리 제약 조건을 초과하는 파드 생성 시도</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
컨테이너는 800MiB의 메모리 요청량과 1.5GiB의 메모리 상한을 지정하고 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-constraints-pod-2.yaml download=admin/resource/memory-constraints-pod-2.yaml><code>admin/resource/memory-constraints-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-2-yaml")' title="Copy admin/resource/memory-constraints-pod-2.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1.5Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드 생성을 시도한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-2.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>결과를 보면 파드가 생성되지 않은 것을 확인할 수 있으며,
이는 해당 파드가 정의하고 있는 컨테이너가 허용된 것보다 더 많은 메모리를 요청하고 있기 때문이다.</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/memory-constraints-pod-2.yaml&#34;:
pods &#34;constraints-mem-demo-2&#34; is forbidden: maximum memory usage per Container is 1Gi, but limit is 1536Mi.
</code></pre><h2 id=최소-메모리-요청량을-충족하지-않는-파드-생성-시도>최소 메모리 요청량을 충족하지 않는 파드 생성 시도</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
컨테이너는 100MiB의 메모리 요청량과 800MiB의 메모리 상한을 지정하고 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-constraints-pod-3.yaml download=admin/resource/memory-constraints-pod-3.yaml><code>admin/resource/memory-constraints-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-3-yaml")' title="Copy admin/resource/memory-constraints-pod-3.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드 생성을 시도한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-3.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>결과를 보면 파드가 생성되지 않은 것을 확인할 수 있으며,
이는 해당 파드가 정의하고 있는 컨테이너가 지정된 최저 메모리 요청량보다도 낮은 메모리 요청량을 지정하고 있기 때문이다.</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/memory-constraints-pod-3.yaml&#34;:
pods &#34;constraints-mem-demo-3&#34; is forbidden: minimum memory usage per Container is 500Mi, but request is 100Mi.
</code></pre><h2 id=메모리-요청량-또는-상한을-지정하지-않은-파드-생성>메모리 요청량 또는 상한을 지정하지 않은 파드 생성</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다.
해당 컨테이너는 메모리 요청량과 상한을 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/memory-constraints-pod-4.yaml download=admin/resource/memory-constraints-pod-4.yaml><code>admin/resource/memory-constraints-pod-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-4-yaml")' title="Copy admin/resource/memory-constraints-pod-4.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-4.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-mem-demo-4 --namespace<span style=color:#666>=</span>constraints-mem-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력을 보면 파드의 유일한 컨테이너에 대한 메모리 요청량이 1 GiB이고 메모리 상한도 1 GiB이다.
이 컨테이너는 어떻게 이런 값을 얻었을까?</p><pre tabindex=0><code>resources:
  limits:
    memory: 1Gi
  requests:
    memory: 1Gi
</code></pre><p>파드가 해당 컨테이너에 대해 메모리 요청량과 상한을 지정하지 않았으므로,
클러스터가 리밋레인지로부터
<a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>메모리의 요청량과 상한 기본값</a>을
적용하였다.</p><p>이는 곧 파드 정의에서 이 값들을 볼 수 있음을 의미한다.
<code>kubectl describe</code> 명령을 사용하여 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 출력에서 &#34;Requests:&#34; 섹션을 확인한다</span>
</span></span><span style=display:flex><span>kubectl describe pod constraints-mem-demo-4 --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>이 시점에서, 파드는 실행 중일 수도 있고 아닐 수도 있다. 이 태스크의 전제 조건은
노드에 최소 1GiB의 메모리가 있어야 한다는 것이다. 각 노드에
1GiB의 메모리만 있는 경우, 노드에 할당할 수 있는 메모리가 1GiB의 메모리 요청량을 수용하기에 충분하지
않을 수 있다. 메모리가 2GiB인 노드를 사용하는 경우에는, 메모리가
1GiB 요청량을 수용하기에 충분할 것이다.</p><p>파드를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod constraints-mem-demo-4 --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><h2 id=메모리의-최소-및-최대-제약-조건-적용>메모리의 최소 및 최대 제약 조건 적용</h2><p>리밋레인지에 의해 네임스페이스에 부과된 메모리의 최대 및 최소 제약 조건은
파드를 생성하거나 업데이트할 때만 적용된다. 리밋레인지를 변경해도, 이전에 생성된
파드에는 영향을 미치지 않는다.</p><h2 id=메모리의-최소-및-최대-제약-조건에-대한-동기>메모리의 최소 및 최대 제약 조건에 대한 동기</h2><p>클러스터 관리자는 파드가 사용할 수 있는 메모리 양에 제한을 둘 수 있다.
예를 들면 다음과 같다.</p><ul><li><p>클러스터의 각 노드에는 2GiB의 메모리가 있다. 클러스터의 어떤 노드도 2GiB 이상의 요청량을
지원할 수 없으므로, 2GiB 이상의 메모리를 요청하는 파드를 수락하지 않으려고 한다.</p></li><li><p>클러스터는 운영 부서와 개발 부서에서 공유한다.
프로덕션 워크로드가 최대 8GiB의 메모리를 소비하도록 하려면,
개발 워크로드를 512MiB로 제한해야 한다. 프로덕션 및 개발을 위해
별도의 네임스페이스를 만들고, 각 네임스페이스에 메모리 제약 조건을 적용한다.</p></li></ul><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace constraints-mem-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 대한 파드 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너 및 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a87cbd1f9379dac7a48ae320da68a9ad>3.3.4 - 네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</h1><div class=lead>한 네임스페이스 내에서 CPU 리소스 제한의 유효한 범위를 정의하며, 이를 통해 해당 네임스페이스의 새로운 파드가 미리 설정한 범위 안에 들어오도록 한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에서
컨테이너와 파드가 사용하는 CPU 리소스의 최솟값과 최댓값을 설정하는 방법을 보여준다.
<a href=/docs/reference/kubernetes-api/policy-resources/limit-range-v1/>리밋레인지(LimitRange)</a> 오브젝트에
CPU의 최솟값과 최댓값을 지정한다.
리밋레인지에 의해 부과된 제약 조건을 파드가 충족하지 않으면,
해당 네임스페이스에 생성될 수 없다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><p>클러스터의 각 노드는 파드 실행을 위해 적어도 1.0 CPU 이상이 사용 가능해야 한다.
쿠버네티스에서 “1 CPU”가 무엇을 의미하는지 알아보려면
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#cpu%EC%9D%98-%EC%9D%98%EB%AF%B8>CPU의 의미</a>를 참조한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 연습에서 생성한 리소스가 클러스터의 나머지와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace constraints-cpu-example
</span></span></code></pre></div><h2 id=리밋레인지와-파드-생성>리밋레인지와 파드 생성</h2><p>다음은 <a class=glossary-tooltip title='네임스페이스 내에 컨테이너나 파드당 리소스 소비를 한정하는 제약 조건을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/limit-range/ target=_blank aria-label=리밋레인지>리밋레인지</a> 예제 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-constraints.yaml download=admin/resource/cpu-constraints.yaml><code>admin/resource/cpu-constraints.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-constraints-yaml")' title="Copy admin/resource/cpu-constraints.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-constraints-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-min-max-demo-lr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>리밋레인지를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>리밋레인지에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get limitrange cpu-min-max-demo-lr --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>출력 결과는 예상대로 CPU의 최소와 최대 제약 조건을 보여준다. 그러나
참고로 리밋레인지에 대한 구성 파일에 기본값을
지정하지 않아도 자동으로 생성된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>default</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultRequest</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>200m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></span></span></code></pre></div><p>이제 <code>constraints-cpu-example</code> 네임스페이스에 파드를 생성할 때마다(또는
다른 쿠버네티스 API 클라이언트가 동일한 파드를 생성할 때마다), 쿠버네티스는 다음 단계를 수행한다.</p><ul><li><p>해당 파드의 어떤 컨테이너도 자체 CPU 요청량(request)과 상한(limit)을 명시하지 않으면,
컨트롤 플레인이 해당 컨테이너에 CPU 요청량과 상한의 기본값(default)을 지정한다.</p></li><li><p>해당 파드의 모든 컨테이너가 200 millicpu 이상의 CPU 요청량을 지정하는지 확인한다.</p></li><li><p>해당 파드의 모든 컨테이너가 800 millicpu 이하의 CPU 상한을 지정하는지 확인한다.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>LimitRange</code> 오브젝트를 생성할 때, huge-pages
또는 GPU에도 상한을 지정할 수 있다. 그러나, 이 리소스들에 <code>default</code> 와 <code>defaultRequest</code> 가
모두 지정되어 있으면, 두 값은 같아야 한다.</div><p>다음은 컨테이너가 하나인 파드의 매니페스트이다. 컨테이너 매니페스트는
500 millicpu의 CPU 요청량 및 800 millicpu의 CPU 상한을 지정하고 있다. 이는 이 네임스페이스의 리밋레인지에
의해 부과된 CPU의 최소와 최대 제약 조건을 충족시킨다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-constraints-pod.yaml download=admin/resource/cpu-constraints-pod.yaml><code>admin/resource/cpu-constraints-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-constraints-pod-yaml")' title="Copy admin/resource/cpu-constraints-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-constraints-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>파드가 실행 중이고 컨테이너의 상태가 정상인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-cpu-demo --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>출력 결과는 파드 내 유일한 컨테이너의 CPU 요청량이 500 millicpu이고, CPU 상한이 800 millicpu임을
나타낸다. 이는 리밋레인지에 의해 부과된 제약 조건을 만족시킨다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=파드-삭제>파드 삭제</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod constraints-cpu-demo --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><h2 id=cpu-최대-제약-조건을-초과하는-파드-생성-시도>CPU 최대 제약 조건을 초과하는 파드 생성 시도</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다. 컨테이너는
500 millicpu의 CPU 요청량과 1.5 cpu의 CPU 상한을 지정하고 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-constraints-pod-2.yaml download=admin/resource/cpu-constraints-pod-2.yaml><code>admin/resource/cpu-constraints-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-constraints-pod-2-yaml")' title="Copy admin/resource/cpu-constraints-pod-2.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-constraints-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1.5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드 생성을 시도한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-2.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>결과를 보면 파드가 생성되지 않은 것을 확인할 수 있으며, 이는 해당 파드가 수용 불가능한 컨테이너를 정의하고 있기 때문이다.
해당 컨테이너가 수용 불가능한 이유는 너무 큰 CPU 상한을 지정하고 있기 때문이다.</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/cpu-constraints-pod-2.yaml&#34;:
pods &#34;constraints-cpu-demo-2&#34; is forbidden: maximum cpu usage per Container is 800m, but limit is 1500m.
</code></pre><h2 id=최소-cpu-요청량을-충족하지-않는-파드-생성-시도>최소 CPU 요청량을 충족하지 않는 파드 생성 시도</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다. 컨테이너는
100 millicpu의 CPU 요청량과 800 millicpu의 CPU 상한을 지정하고 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-constraints-pod-3.yaml download=admin/resource/cpu-constraints-pod-3.yaml><code>admin/resource/cpu-constraints-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-constraints-pod-3-yaml")' title="Copy admin/resource/cpu-constraints-pod-3.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-constraints-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드 생성을 시도한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-3.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>결과를 보면 파드가 생성되지 않은 것을 확인할 수 있으며, 이는 해당 파드가 수용 불가능한 컨테이너를 정의하고 있기 때문이다.
해당 컨테이너가 수용 불가능한 이유는
지정된 최저 CPU 요청량보다도 낮은 CPU 요청량을 지정하고 있기 때문이다.</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/cpu-constraints-pod-3.yaml&#34;:
pods &#34;constraints-cpu-demo-3&#34; is forbidden: minimum cpu usage per Container is 200m, but request is 100m.
</code></pre><h2 id=cpu-요청량-또는-상한을-지정하지-않은-파드-생성>CPU 요청량 또는 상한을 지정하지 않은 파드 생성</h2><p>다음은 컨테이너가 하나인 파드의 매니페스트이다. 컨테이너는
CPU 요청량을 지정하지 않았으며, CPU 상한도 지정하지 않았다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/cpu-constraints-pod-4.yaml download=admin/resource/cpu-constraints-pod-4.yaml><code>admin/resource/cpu-constraints-pod-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-cpu-constraints-pod-4-yaml")' title="Copy admin/resource/cpu-constraints-pod-4.yaml to clipboard"></img></div><div class=includecode id=admin-resource-cpu-constraints-pod-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-cpu-demo-4-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/cpu-constraints-pod-4.yaml --namespace<span style=color:#666>=</span>constraints-cpu-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보를 본다.</p><pre tabindex=0><code>kubectl get pod constraints-cpu-demo-4 --namespace=constraints-cpu-example --output=yaml
</code></pre><p>출력을 보면 파드의 유일한 컨테이너에 대한 CPU 요청량이 800 millicpu이고,
CPU 상한이 800 millicpu이다.
이 컨테이너는 어떻게 이런 값을 얻었을까?</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>800m<span style=color:#bbb>
</span></span></span></code></pre></div><p>컨테이너가 자체 CPU 요청량과 상한을 지정하지 않았으므로,
컨테이너가 이 네임스페이스에 대해 리밋레인지로부터
<a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>CPU 요청량과 상한의 기본값</a>을
적용했다.</p><p>이 시점에서, 파드는 실행 중일 수도 있고 아닐 수도 있다. 이 태스크의 전제 조건은
노드에 1 CPU 이상 사용 가능해야 한다는 것이다. 각 노드에 1 CPU만 있는 경우,
노드에 할당할 수 있는 CPU가 800 millicpu의 요청량을 수용하기에 충분하지 않을 수 있다.
2 CPU인 노드를 사용하는 경우에는, CPU가 800 millicpu 요청량을 수용하기에 충분할 것이다.</p><p>파드를 삭제한다.</p><pre tabindex=0><code>kubectl delete pod constraints-cpu-demo-4 --namespace=constraints-cpu-example
</code></pre><h2 id=cpu의-최소-및-최대-제약-조건의-적용>CPU의 최소 및 최대 제약 조건의 적용</h2><p>리밋레인지에 의해 네임스페이스에 부과된 CPU의 최대 및 최소 제약 조건은
파드를 생성하거나 업데이트할 때만 적용된다. 리밋레인지를 변경해도, 이전에 생성된 파드에는
영향을 미치지 않는다.</p><h2 id=cpu의-최소-및-최대-제약-조건에-대한-동기>CPU의 최소 및 최대 제약 조건에 대한 동기</h2><p>클러스터 관리자는 파드가 사용할 수 있는 CPU 리소스에 제한을 둘 수 있다.
예를 들면 다음과 같다.</p><ul><li><p>클러스터의 각 노드에는 2 CPU가 있다. 클러스터의 어떤 노드도 요청량을 지원할 수 없기 때문에,
2 CPU 이상을 요청하는 파드를 수락하지 않으려고 한다.</p></li><li><p>클러스터는 프로덕션과 개발 부서에서 공유한다.
프로덕션 워크로드가 최대 3 CPU를 소비하도록 하고 싶지만, 개발 워크로드는 1 CPU로
제한하려고 한다. 프로덕션과 개발을 위해 별도의 네임스페이스를 생성하고, 각 네임스페이스에 CPU 제약 조건을
적용한다.</p></li></ul><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace constraints-cpu-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 대한 파드 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너와 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fe3283559a3df299aae3ee00ecea2fad>3.3.5 - 네임스페이스에 대한 메모리 및 CPU 쿼터 구성</h1><div class=lead>한 네임스페이스에 대한 총 메모리 및 CPU 자원 상한을 정의한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에서
실행 중인 모든 파드가 사용할 수 있는
총 메모리 및 CPU 양에 대한 쿼터를 설정하는 방법을 보여준다.
<a href=/docs/reference/kubernetes-api/policy-resources/resource-quota-v1/>리소스쿼터(ResourceQuota)</a> 오브젝트에
쿼터를 지정할 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><p>클러스터의 각 노드에는 최소 1GiB의 메모리가 있어야 한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 연습에서 생성한 리소스가 클러스터의 나머지와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace quota-mem-cpu-example
</span></span></code></pre></div><h2 id=리소스쿼터-생성>리소스쿼터 생성</h2><p>다음은 예시 리소스쿼터 오브젝트에 대한 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/quota-mem-cpu.yaml download=admin/resource/quota-mem-cpu.yaml><code>admin/resource/quota-mem-cpu.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-quota-mem-cpu-yaml")' title="Copy admin/resource/quota-mem-cpu.yaml to clipboard"></img></div><div class=includecode id=admin-resource-quota-mem-cpu-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-cpu-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests.cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests.memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limits.cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limits.memory</span>:<span style=color:#bbb> </span>2Gi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>리소스쿼터를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu.yaml --namespace<span style=color:#666>=</span>quota-mem-cpu-example
</span></span></code></pre></div><p>리소스쿼터에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get resourcequota mem-cpu-demo --namespace<span style=color:#666>=</span>quota-mem-cpu-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>리소스쿼터는 이러한 요구 사항을 quota-mem-cpu-example 네임스페이스에 배치한다.</p><ul><li>네임스페이스의 모든 파드에 대해, 각 컨테이너에는 메모리 요청량(request), 메모리 상한(limit), CPU 요청량 및 CPU 상한이 있어야 한다.</li><li>네임스페이스의 모든 파드에 대한 총 메모리 요청량은 1GiB를 초과하지 않아야 한다.</li><li>네임스페이스의 모든 파드에 대한 총 메모리 상한은 2GiB를 초과하지 않아야 한다.</li><li>네임스페이스의 모든 파드에 대한 총 CPU 요청량은 1 cpu를 초과해서는 안된다.</li><li>네임스페이스의 모든 파드에 대한 총 CPU 상한은 2 cpu를 초과해서는 안된다.</li></ul><p>쿠버네티스에서 “1 CPU”가 무엇을 의미하는지 알아보려면
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#cpu%EC%9D%98-%EC%9D%98%EB%AF%B8>CPU의 의미</a>를 참조한다.</p><h2 id=파드-생성>파드 생성</h2><p>다음은 예시 파드에 대한 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/quota-mem-cpu-pod.yaml download=admin/resource/quota-mem-cpu-pod.yaml><code>admin/resource/quota-mem-cpu-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-quota-mem-cpu-pod-yaml")' title="Copy admin/resource/quota-mem-cpu-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-quota-mem-cpu-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;600Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;400m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu-pod.yaml --namespace<span style=color:#666>=</span>quota-mem-cpu-example
</span></span></code></pre></div><p>파드가 실행 중이고 파드의 (유일한) 컨테이너의 상태가 정상인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod quota-mem-cpu-demo --namespace<span style=color:#666>=</span>quota-mem-cpu-example
</span></span></code></pre></div><p>다시 한 번, 리소스쿼터에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get resourcequota mem-cpu-demo --namespace<span style=color:#666>=</span>quota-mem-cpu-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력 결과는 쿼터와 사용된 쿼터를 함께 보여준다.
파드의 메모리와 CPU 요청량 및 상한이 쿼터를 초과하지 않은 것을
볼 수 있다.</p><pre tabindex=0><code>status:
  hard:
    limits.cpu: &#34;2&#34;
    limits.memory: 2Gi
    requests.cpu: &#34;1&#34;
    requests.memory: 1Gi
  used:
    limits.cpu: 800m
    limits.memory: 800Mi
    requests.cpu: 400m
    requests.memory: 600Mi
</code></pre><p><code>jq</code> 도구가 설치되어 있으면, (<a href=/ko/docs/reference/kubectl/jsonpath/>JSONPath</a>를 사용하여) <code>used</code> 값만을 질의 <strong>하고</strong>,
정돈된 상태로 출력할 수 있다. 예시는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get resourcequota mem-cpu-demo --namespace<span style=color:#666>=</span>quota-mem-cpu-example -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{ .status.used }&#39;</span> | jq .
</span></span></code></pre></div><h2 id=두-번째-파드-생성-시도>두 번째 파드 생성 시도</h2><p>다음은 두 번째 파드에 대한 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/quota-mem-cpu-pod-2.yaml download=admin/resource/quota-mem-cpu-pod-2.yaml><code>admin/resource/quota-mem-cpu-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-quota-mem-cpu-pod-2-yaml")' title="Copy admin/resource/quota-mem-cpu-pod-2.yaml to clipboard"></img></div><div class=includecode id=admin-resource-quota-mem-cpu-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>quota-mem-cpu-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;400m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>매니페스트에서, 파드의 메모리 요청량이 700MiB임을 알 수 있다.
사용된 메모리 요청량과 이 새 메모리 요청량의 합계가
메모리 요청량 쿼터를 초과함에 유의한다(600 MiB + 700 MiB > 1 GiB).</p><p>파드 생성을 시도한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/quota-mem-cpu-pod-2.yaml --namespace<span style=color:#666>=</span>quota-mem-cpu-example
</span></span></code></pre></div><p>두 번째 파드는 생성되지 않는다. 출력 결과는 두 번째 파드를 생성하면
메모리 요청량의 총 합계가 메모리 요청량 쿼터를 초과함을 보여준다.</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/quota-mem-cpu-pod-2.yaml&#34;:
pods &#34;quota-mem-cpu-demo-2&#34; is forbidden: exceeded quota: mem-cpu-demo,
requested: requests.memory=700Mi,used: requests.memory=600Mi, limited: requests.memory=1Gi
</code></pre><h2 id=토론>토론</h2><p>이 연습에서 보았듯이, 리소스쿼터를 사용하여
네임스페이스에서 실행 중인 모든 파드에 대한 메모리 요청량의 총 합계를 제한할 수 있다.
메모리 상한, CPU 요청량 및 CPU 상한의 총 합계를 제한할 수도 있다.</p><p>네임스페이스 내의 총 자원을 관리하는 것 대신,
개별 파드 또는 파드 내의 컨테이너별로 제한하고 싶을 수도 있다.
이러한 종류의 제한을 걸려면, <a href=/ko/docs/concepts/policy/limit-range/>리밋레인지(LimitRange)</a>를 사용한다.</p><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace quota-mem-cpu-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 대한 파드 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너 및 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-40e30a9209e0c9f4153707e43243e9d7>3.3.6 - 네임스페이스에 대한 파드 쿼터 구성</h1><div class=lead>한 네임스페이스 내에 만들 수 있는 파드의 수를 제한한다.</div><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에서 실행할 수 있는 총 파드 수에 대한 쿼터를
설정하는 방법을 보여준다.
<a href=/docs/reference/kubernetes-api/policy-resources/resource-quota-v1/>리소스쿼터(ResourceQuota)</a> 오브젝트에
쿼터를 지정할 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터에 네임스페이스를 생성할 수 있는 권한이 있어야 한다.</p><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 실습에서 생성한 리소스가 클러스터의 나머지와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace quota-pod-example
</span></span></code></pre></div><h2 id=리소스쿼터-생성>리소스쿼터 생성</h2><p>다음은 예시 리소스쿼터 오브젝트에 대한 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/quota-pod.yaml download=admin/resource/quota-pod.yaml><code>admin/resource/quota-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-quota-pod-yaml")' title="Copy admin/resource/quota-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-quota-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>리소스쿼터를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/quota-pod.yaml --namespace<span style=color:#666>=</span>quota-pod-example
</span></span></code></pre></div><p>리소스쿼터에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get resourcequota pod-demo --namespace<span style=color:#666>=</span>quota-pod-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력 결과는 네임스페이스에 두 개의 파드 쿼터가 있고, 현재 파드가 없음을
보여준다. 즉, 쿼터 중 어느 것도 사용되지 않았다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>used</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>다음은 <a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a>에 대한 예시 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/resource/quota-pod-deployment.yaml download=admin/resource/quota-pod-deployment.yaml><code>admin/resource/quota-pod-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-quota-pod-deployment-yaml")' title="Copy admin/resource/quota-pod-deployment.yaml to clipboard"></img></div><div class=includecode id=admin-resource-quota-pod-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-quota-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>quota-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>quota-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-quota-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>매니페스트에서, <code>replicas: 3</code> 은 쿠버네티스가 모두 동일한 애플리케이션을 실행하는
세 개의 새로운 파드를 만들도록 지시한다.</p><p>디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/quota-pod-deployment.yaml --namespace<span style=color:#666>=</span>quota-pod-example
</span></span></code></pre></div><p>디플로이먼트에 대한 자세한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment pod-quota-demo --namespace<span style=color:#666>=</span>quota-pod-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력을 보면 디플로이먼트가 3개의 레플리카를 정의하고 있음에도,
앞서 설정한 쿼터로 인해 2개의 파드만 생성되었음을 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>availableReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span>2021-04-02T20:57:05Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message: &#39;unable to create pods</span>:<span style=color:#bbb> </span>pods &#34;pod-quota-demo-1650323038-&#34; is forbidden:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>exceeded quota: pod-demo, requested: pods=1, used: pods=2, limited</span>:<span style=color:#bbb> </span>pods=2&#39;<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=리소스-선택>리소스 선택</h3><p>이 예제에서는 총 파드 수를 제한하는 리소스쿼터를 정의하였다.
하지만, 다른 종류의 오브젝트의 총 수를 제한할 수도 있다.
예를 들어, 한 네임스페이스에 존재할 수 있는
<a class=glossary-tooltip title='정기적인 일정으로 실행되는 반복 작업(잡).' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/cron-jobs/ target=_blank aria-label=크론잡>크론잡</a>의 총 수를 제한할 수 있다.</p><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace quota-pod-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 대한 기본 메모리 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 대한 기본 CPU 요청량과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 대한 쿼터 구성</a></p></li></ul><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너 및 파드 CPU 리소스 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 대한 서비스 품질(QoS) 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7743f043c43f7b12e8654e2227dbc658>3.4 - 인증서</h1><p>클라이언트 인증서로 인증을 사용하는 경우 <code>easyrsa</code>, <code>openssl</code> 또는 <code>cfssl</code>
을 통해 인증서를 수동으로 생성할 수 있다.</p><h3 id=easyrsa>easyrsa</h3><p><strong>easyrsa</strong> 는 클러스터 인증서를 수동으로 생성할 수 있다.</p><ol><li><p><code>easyrsa3</code>의 패치 버전을 다운로드하여 압축을 풀고, 초기화한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
</span></span><span style=display:flex><span>tar xzf easy-rsa.tar.gz
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> easy-rsa-master/easyrsa3
</span></span><span style=display:flex><span>./easyrsa init-pki
</span></span></code></pre></div></li><li><p>새로운 인증 기관(CA)을 생성한다. <code>--batch</code> 는 자동 모드를 설정한다.
<code>--req-cn</code> 는 CA의 새 루트 인증서에 대한 일반 이름(Common Name (CN))을 지정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./easyrsa --batch <span style=color:#b44>&#34;--req-cn=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>@`date +%s`&#34;</span> build-ca nopass
</span></span></code></pre></div></li><li><p>서버 인증서와 키를 생성한다.</p><p><code>--subject-alt-name</code> 인자로 API 서버에 접근이 가능한 IP와 DNS
이름을 설정한다. <code>MASTER_CLUSTER_IP</code> 는 일반적으로 API 서버와
컨트롤러 관리자 컴포넌트에 대해 <code>--service-cluster-ip-range</code> 인자로
지정된 서비스 CIDR의 첫 번째 IP이다. <code>--days</code> 인자는 인증서가 만료되는
일 수를 설정하는 데 사용된다.
또한, 아래 샘플에서는 <code>cluster.local</code> 을 기본 DNS 도메인
이름으로 사용하고 있다고 가정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./easyrsa --subject-alt-name<span style=color:#666>=</span><span style=color:#b44>&#34;IP:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;IP:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_CLUSTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default.svc,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default.svc.cluster,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default.svc.cluster.local&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--days<span style=color:#666>=</span><span style=color:#666>10000</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>build-server-full server nopass
</span></span></code></pre></div></li><li><p><code>pki/ca.crt</code>, <code>pki/issued/server.crt</code> 그리고 <code>pki/private/server.key</code> 를 디렉터리에 복사한다.</p></li><li><p>API 서버를 시작하는 파라미터에 다음과 같이 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--client-ca-file<span style=color:#666>=</span>/yourdirectory/ca.crt
</span></span><span style=display:flex><span>--tls-cert-file<span style=color:#666>=</span>/yourdirectory/server.crt
</span></span><span style=display:flex><span>--tls-private-key-file<span style=color:#666>=</span>/yourdirectory/server.key
</span></span></code></pre></div></li></ol><h3 id=openssl>openssl</h3><p><strong>openssl</strong> 은 클러스터 인증서를 수동으로 생성할 수 있다.</p><ol><li><p>ca.key를 2048bit로 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl genrsa -out ca.key <span style=color:#666>2048</span>
</span></span></code></pre></div></li><li><p>ca.key에 따라 ca.crt를 생성한다(인증서 유효 기간을 사용하려면 <code>-days</code>를 사용한다).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -x509 -new -nodes -key ca.key -subj <span style=color:#b44>&#34;/CN=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span> -days <span style=color:#666>10000</span> -out ca.crt
</span></span></code></pre></div></li><li><p>server.key를 2048bit로 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl genrsa -out server.key <span style=color:#666>2048</span>
</span></span></code></pre></div></li><li><p>인증서 서명 요청(Certificate Signing Request (CSR))을 생성하기 위한 설정 파일을 생성한다.</p><p>파일에 저장하기 전에 꺾쇠 괄호(예: <code>&lt;MASTER_IP></code>)로
표시된 값을 실제 값으로 대체한다(예: <code>csr.conf</code>).
<code>MASTER_CLUSTER_IP</code> 의 값은 이전 하위 섹션에서
설명한 대로 API 서버의 서비스 클러스터 IP이다.
또한, 아래 샘플에서는 <code>cluster.local</code> 을 기본 DNS 도메인
이름으로 사용하고 있다고 가정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ req ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>default_bits</span> <span style=color:#666>=</span> <span style=color:#b44>2048</span>
</span></span><span style=display:flex><span><span style=color:#b44>prompt</span> <span style=color:#666>=</span> <span style=color:#b44>no</span>
</span></span><span style=display:flex><span><span style=color:#b44>default_md</span> <span style=color:#666>=</span> <span style=color:#b44>sha256</span>
</span></span><span style=display:flex><span><span style=color:#b44>req_extensions</span> <span style=color:#666>=</span> <span style=color:#b44>req_ext</span>
</span></span><span style=display:flex><span><span style=color:#b44>distinguished_name</span> <span style=color:#666>=</span> <span style=color:#b44>dn</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ dn ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>C</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;국가(country)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>ST</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;도(state)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>L</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;시(city)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>O</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;조직(organization)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>OU</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;조직 단위(organization unit)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>CN</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;MASTER_IP&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ req_ext ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>subjectAltName</span> <span style=color:#666>=</span> <span style=color:#b44>@alt_names</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ alt_names ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.1</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.2</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.3</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default.svc</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.4</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default.svc.cluster</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.5</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default.svc.cluster.local</span>
</span></span><span style=display:flex><span><span style=color:#b44>IP.1</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;MASTER_IP&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>IP.2</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;MASTER_CLUSTER_IP&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ v3_ext ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>authorityKeyIdentifier</span><span style=color:#666>=</span><span style=color:#b44>keyid,issuer:always</span>
</span></span><span style=display:flex><span><span style=color:#b44>basicConstraints</span><span style=color:#666>=</span><span style=color:#b44>CA:FALSE</span>
</span></span><span style=display:flex><span><span style=color:#b44>keyUsage</span><span style=color:#666>=</span><span style=color:#b44>keyEncipherment,dataEncipherment</span>
</span></span><span style=display:flex><span><span style=color:#b44>extendedKeyUsage</span><span style=color:#666>=</span><span style=color:#b44>serverAuth,clientAuth</span>
</span></span><span style=display:flex><span><span style=color:#b44>subjectAltName</span><span style=color:#666>=</span><span style=color:#b44>@alt_names</span>
</span></span></code></pre></div></li><li><p>설정 파일을 기반으로 인증서 서명 요청을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -new -key server.key -out server.csr -config csr.conf
</span></span></code></pre></div></li><li><p>ca.key, ca.crt 그리고 server.csr을 사용해서 서버 인증서를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -CAcreateserial -out server.crt -days <span style=color:#666>10000</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -extensions v3_ext -extfile csr.conf
</span></span></code></pre></div></li><li><p>인증서 서명 요청을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req  -noout -text -in ./server.csr
</span></span></code></pre></div></li><li><p>인증서를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl x509  -noout -text -in ./server.crt
</span></span></code></pre></div></li></ol><p>마지막으로, API 서버 시작 파라미터에 동일한 파라미터를 추가한다.</p><h3 id=cfssl>cfssl</h3><p><strong>cfssl</strong> 은 인증서 생성을 위한 또 다른 도구이다.</p><ol><li><p>아래에 표시된 대로 커맨드 라인 도구를 다운로드하여 압축을 풀고 준비한다.</p><p>사용 중인 하드웨어 아키텍처 및 cfssl 버전에 따라 샘플
명령을 조정해야 할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl_1.5.0_linux_amd64 -o cfssl
</span></span><span style=display:flex><span>chmod +x cfssl
</span></span><span style=display:flex><span>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssljson_1.5.0_linux_amd64 -o cfssljson
</span></span><span style=display:flex><span>chmod +x cfssljson
</span></span><span style=display:flex><span>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl-certinfo_1.5.0_linux_amd64 -o cfssl-certinfo
</span></span><span style=display:flex><span>chmod +x cfssl-certinfo
</span></span></code></pre></div></li><li><p>아티팩트(artifact)를 보유할 디렉터리를 생성하고 cfssl을 초기화한다.</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir cert
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> cert
</span></span><span style=display:flex><span>../cfssl print-defaults config &gt; config.json
</span></span><span style=display:flex><span>../cfssl print-defaults csr &gt; csr.json
</span></span></code></pre></div><ol><li><p>CA 파일을 생성하기 위한 JSON 설정 파일을 <code>ca-config.json</code> 예시와 같이 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;signing&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;default&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;expiry&#34;</span>: <span style=color:#b44>&#34;8760h&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;profiles&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;usages&#34;</span>: [
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;signing&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;key encipherment&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;server auth&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;client auth&#34;</span>
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;expiry&#34;</span>: <span style=color:#b44>&#34;8760h&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>CA 인증서 서명 요청(CSR)을 위한 JSON 설정 파일을
<code>ca-csr.json</code> 예시와 같이 생성한다. 꺾쇠 괄호로 표시된
값을 사용하려는 실제 값으로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;CN&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;key&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;algo&#34;</span>: <span style=color:#b44>&#34;rsa&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;size&#34;</span>: <span style=color:#666>2048</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;names&#34;</span>:[{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;C&#34;</span>: <span style=color:#b44>&#34;국가&lt;country&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ST&#34;</span>: <span style=color:#b44>&#34;도&lt;state&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;L&#34;</span>: <span style=color:#b44>&#34;시&lt;city&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;O&#34;</span>: <span style=color:#b44>&#34;조직&lt;organization&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;OU&#34;</span>: <span style=color:#b44>&#34;조직 단위&lt;organization unit&gt;&#34;</span>
</span></span><span style=display:flex><span>  }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>CA 키(<code>ca-key.pem</code>)와 인증서(<code>ca.pem</code>)을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca
</span></span></code></pre></div></li><li><p>API 서버의 키와 인증서를 생성하기 위한 JSON 구성파일을
<code>server-csr.json</code> 예시와 같이 생성한다. 꺾쇠 괄호 안의 값을
사용하려는 실제 값으로 변경한다. <code>MASTER_CLUSTER_IP</code> 는
이전 하위 섹션에서 설명한 API 서버의 클러스터 IP이다.
아래 샘플은 기본 DNS 도메인 이름으로 <code>cluster.local</code> 을
사용한다고 가정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;CN&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;hosts&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;&lt;MASTER_IP&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;&lt;MASTER_CLUSTER_IP&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default.svc&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default.svc.cluster&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default.svc.cluster.local&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;key&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;algo&#34;</span>: <span style=color:#b44>&#34;rsa&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;size&#34;</span>: <span style=color:#666>2048</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;names&#34;</span>: [{
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;C&#34;</span>: <span style=color:#b44>&#34;&lt;국가(country)&gt;&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;ST&#34;</span>: <span style=color:#b44>&#34;&lt;도(state)&gt;&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;L&#34;</span>: <span style=color:#b44>&#34;&lt;시(city)&gt;&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;O&#34;</span>: <span style=color:#b44>&#34;&lt;조직(organization)&gt;&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;OU&#34;</span>: <span style=color:#b44>&#34;&lt;조직 단위(organization unit)&gt;&#34;</span>
</span></span><span style=display:flex><span>  }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>API 서버 키와 인증서를 생성하면, 기본적으로
<code>server-key.pem</code> 과 <code>server.pem</code> 파일에 각각 저장된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>../cfssl gencert -ca<span style=color:#666>=</span>ca.pem -ca-key<span style=color:#666>=</span>ca-key.pem <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>     --config<span style=color:#666>=</span>ca-config.json -profile<span style=color:#666>=</span>kubernetes <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>     server-csr.json | ../cfssljson -bare server
</span></span></code></pre></div></li></ol><h2 id=자체-서명된-ca-인증서의-배포>자체 서명된 CA 인증서의 배포</h2><p>클라이언트 노드는 자체 서명된 CA 인증서를 유효한 것으로 인식하지 않을 수 있다.
비-프로덕션 디플로이먼트 또는 회사 방화벽 뒤에서 실행되는
디플로이먼트의 경우, 자체 서명된 CA 인증서를 모든 클라이언트에
배포하고 유효한 인증서의 로컬 목록을 새로 고칠 수 있다.</p><p>각 클라이언트에서, 다음 작업을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt
</span></span><span style=display:flex><span>sudo update-ca-certificates
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....
done.
</code></pre><h2 id=인증서-api>인증서 API</h2><p><code>certificates.k8s.io</code> API를 사용하여
<a href=/ko/docs/tasks/tls/managing-tls-in-a-cluster/>클러스터에서 TLS 인증서 관리</a>에
설명된 대로 인증에 사용할 x509 인증서를 프로비전 할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-8c31aafd38fad5b0de0bd191758d6f93>3.5 - 네트워크 폴리시 제공자(Network Policy Provider) 설치</h1></div><div class=td-content><h1 id=pg-1239a77618c6278373832a142cd85519>3.5.1 - 네트워크 폴리시로 캘리코(Calico) 사용하기</h1><p>이 페이지는 쿠버네티스에서 캘리코(Calico) 클러스터를 생성하는 몇 가지 빠른 방법을 살펴본다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><a href=#creating-a-calico-cluster-with-google-kubernetes-engine-gke>클라우드</a>나 <a href=#creating-a-local-calico-cluster-with-kubeadm>지역</a> 클러스터 중에 어디에 배포할지 결정한다.</p><h2 id=creating-a-calico-cluster-with-google-kubernetes-engine-gke>구글 쿠버네티스 엔진(GKE)에 캘리코 클러스터 생성하기</h2><p><strong>사전요구사항</strong>: <a href=https://cloud.google.com/sdk/docs/quickstarts>gcloud</a>.</p><ol><li><p>캘리코로 GKE 클러스터를 시작하려면, <code>--enable-network-policy</code> 플래그를 추가한다.</p><p><strong>문법</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud container clusters create <span style=color:#666>[</span>클러스터_이름<span style=color:#666>]</span> --enable-network-policy
</span></span></code></pre></div><p><strong>예시</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud container clusters create my-calico-cluster --enable-network-policy
</span></span></code></pre></div></li><li><p>배포를 확인하기 위해, 다음 커맨드를 이용하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div><p>캘리코 파드는 <code>calico</code>로 시작한다. 각각의 상태가 <code>Running</code>임을 확인하자.</p></li></ol><h2 id=creating-a-local-calico-cluster-with-kubeadm>kubeadm으로 지역 캘리코 클러스터 생성하기</h2><p>Kubeadm을 이용해서 15분 이내에 지역 단일 호스트 캘리코 클러스터를 생성하려면,
<a href=https://docs.projectcalico.org/latest/getting-started/kubernetes/>캘리코 빠른 시작</a>을 참고한다.</p><h2 id=다음-내용>다음 내용</h2><p>클러스터가 동작하면, 쿠버네티스 네트워크 폴리시(NetworkPolicy)를 시도하기 위해
<a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 폴리시 선언하기</a>를 따라 할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-95039241255a31df196beaa405b68eba>3.5.2 - 네트워크 폴리시로 실리움(Cilium) 사용하기</h1><p>이 페이지는 어떻게 네트워크 폴리시(NetworkPolicy)로 실리움(Cilium)를 사용하는지 살펴본다.</p><p>실리움의 배경에 대해서는 <a href=https://docs.cilium.io/en/stable/intro>실리움 소개</a>를 읽어보자.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=기본-시험을-위해-실리움을-minikube에-배포하기>기본 시험을 위해 실리움을 Minikube에 배포하기</h2><p>실리움에 쉽게 친숙해지기 위해
Minikube에 실리움을 기본적인 데몬셋으로 설치를 수행하는
<a href=https://docs.cilium.io/en/stable/gettingstarted/k8s-install-default/>실리움 쿠버네티스 시작하기 안내</a>를 따라 해볼 수 있다.</p><p>Minikube를 시작하려면 최소 버전으로 >= v1.5.2 이 필요하고,
다음의 실행 파라미터로 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube version
</span></span></code></pre></div><pre tabindex=0><code>minikube version: v1.5.2
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start --network-plugin<span style=color:#666>=</span>cni
</span></span></code></pre></div><p>minikube의 경우 CLI 도구를 사용하여 실리움을 설치할 수 있다.
실리움은 클러스터 구성을 자동으로 감지하고
성공적인 설치를 위해 적절한 구성 요소를 설치한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz
</span></span><span style=display:flex><span>sudo tar xzvfC cilium-linux-amd64.tar.gz /usr/local/bin
</span></span><span style=display:flex><span>rm cilium-linux-amd64.tar.gz
</span></span><span style=display:flex><span>cilium install
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>🔮 Auto-detected Kubernetes kind: minikube
</span></span><span style=display:flex><span>✨ Running <span style=color:#b44>&#34;minikube&#34;</span> validation checks
</span></span><span style=display:flex><span>✅ Detected minikube version <span style=color:#b44>&#34;1.20.0&#34;</span>
</span></span><span style=display:flex><span>ℹ️  Cilium version not set, using default version <span style=color:#b44>&#34;v1.10.0&#34;</span>
</span></span><span style=display:flex><span>🔮 Auto-detected cluster name: minikube
</span></span><span style=display:flex><span>🔮 Auto-detected IPAM mode: cluster-pool
</span></span><span style=display:flex><span>🔮 Auto-detected datapath mode: tunnel
</span></span><span style=display:flex><span>🔑 Generating CA...
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> generate received request
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> received CSR
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> generating key: ecdsa-256
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> encoded CSR
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> signed certificate with serial number <span style=color:#666>48713764918856674401136471229482703021230538642</span>
</span></span><span style=display:flex><span>🔑 Generating certificates <span style=color:#a2f;font-weight:700>for</span> Hubble...
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> generate received request
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> received CSR
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> generating key: ecdsa-256
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> encoded CSR
</span></span><span style=display:flex><span>2021/05/27 02:54:44 <span style=color:#666>[</span>INFO<span style=color:#666>]</span> signed certificate with serial number <span style=color:#666>3514109734025784310086389188421560613333279574</span>
</span></span><span style=display:flex><span>🚀 Creating Service accounts...
</span></span><span style=display:flex><span>🚀 Creating Cluster roles...
</span></span><span style=display:flex><span>🚀 Creating ConfigMap...
</span></span><span style=display:flex><span>🚀 Creating Agent DaemonSet...
</span></span><span style=display:flex><span>🚀 Creating Operator Deployment...
</span></span><span style=display:flex><span>⌛ Waiting <span style=color:#a2f;font-weight:700>for</span> Cilium to be installed...
</span></span></code></pre></div><p>시작하기 안내서의 나머지 부분은 예제 애플리케이션을 이용하여
L3/L4(예, IP 주소 + 포트) 모두의 보안 정책뿐만 아니라 L7(예, HTTP)의 보안 정책을
적용하는 방법을 설명한다.</p><h2 id=실리움을-실-서비스-용도로-배포하기>실리움을 실 서비스 용도로 배포하기</h2><p>실리움을 실 서비스 용도의 배포에 관련한 자세한 방법은
<a href=https://docs.cilium.io/en/stable/concepts/kubernetes/intro/>실리움 쿠버네티스 설치 안내</a>를 살펴본다.
이 문서는 자세한 요구사항, 방법과
실제 데몬셋 예시를 포함한다.</p><h2 id=실리움-구성요소-이해하기>실리움 구성요소 이해하기</h2><p>실리움으로 클러스터를 배포하면 파드가 <code>kube-system</code> 네임스페이스에 추가된다.
파드의 목록을 보려면 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>kube-system -l k8s-app<span style=color:#666>=</span>cilium
</span></span></code></pre></div><p>다음과 유사한 파드의 목록을 볼 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>NAME           READY   STATUS    RESTARTS   AGE
</span></span></span><span style=display:flex><span><span style=color:#888>cilium-kkdhz   1/1     Running   0          3m23s
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span></code></pre></div><p><code>cilium</code> 파드는 클러스터 각 노드에서 실행되며, 리눅스 BPF를 사용해서
해당 노드의 파드에 대한 트래픽 네트워크 폴리시를 적용한다.</p><h2 id=다음-내용>다음 내용</h2><p>클러스터가 동작하면,
실리움으로 쿠버네티스 네트워크 폴리시를 시도하기 위해
<a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 폴리시 선언하기</a>를 따라 할 수 있다.
재미있게 즐기고, 질문이 있다면
<a href=https://cilium.herokuapp.com/>실리움 슬랙 채널</a>을 이용하여 연락한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-505a0a6a7e6eff361bbb3be81c84b2e0>3.5.3 - 네트워크 폴리시로 큐브 라우터(Kube-router) 사용하기</h1><p>이 페이지는 네트워크 폴리시(NetworkPolicy)로 <a href=https://github.com/cloudnativelabs/kube-router>큐브 라우터(Kube-router)</a>를 사용하는 방법을 살펴본다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>운영 중인 쿠버네티스 클러스터가 필요하다. 클러스터가 없다면, Kops, Bootkube, Kubeadm 등을 이용해서 클러스터를 생성할 수 있다.</p><h2 id=큐브-라우터-애드온-설치하기>큐브 라우터 애드온 설치하기</h2><p>큐브 라우터 애드온은 갱신된 모든 네트워크 폴리시 및 파드에 대해 쿠버네티스 API 서버를 감시하고, 정책에 따라 트래픽을 허용하거나 차단하도록 iptables 규칙와 ipset을 구성하는 네트워크 폴리시 컨트롤러와 함께 제공된다. 큐브 라우터 애드온을 설치하는 <a href=https://www.kube-router.io/docs/user-guide/#try-kube-router-with-cluster-installers>큐브 라우터를 클러스터 인스톨러와 함께 사용하기</a> 안내서를 따라해 봅니다.</p><h2 id=다음-내용>다음 내용</h2><p>큐브 라우터 애드온을 설치한 후에는, 쿠버네티스 네트워크 폴리시를 시도하기 위해 <a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 폴리시 선언하기</a>를 따라 할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2842eac98aa0e229a5c6755c4c83d2a7>3.5.4 - 네트워크 폴리시로 로마나(Romana)</h1><p>이 페이지는 네트워크 폴리시(NetworkPolicy)로 로마나(Romana)를 사용하는 방법을 살펴본다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm 시작하기</a>의 1, 2, 3 단계를 완료하자.</p><h2 id=kubeadm으로-로마나-설치하기>kubeadm으로 로마나 설치하기</h2><p>Kubeadm을 위한 <a href=https://github.com/romana/romana/tree/master/containerize>컨테이너화된 설치 안내서</a>를 따른다.</p><h2 id=네트워크-폴리시-적용하기>네트워크 폴리시 적용하기</h2><p>네트워크 폴리시를 적용하기 위해 다음 중에 하나를 사용하자.</p><ul><li><a href=https://github.com/romana/romana/wiki/Romana-policies>Romana 네트워크 폴리시</a>.<ul><li><a href=https://github.com/romana/core/blob/master/doc/policy.md>Romana 네트워크 폴리시의 예</a>.</li></ul></li><li>네트워크 폴리시 API.</li></ul><h2 id=다음-내용>다음 내용</h2><p>로마나를 설치한 후에는, 쿠버네티스 네트워크 폴리시를 시도하기 위해
<a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 폴리시 선언하기</a>를
따라 할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ac075c3fdfd0d41aa753cc70e42be064>3.5.5 - 네트워크 폴리시로 위브넷(Weave Net) 사용하기</h1><p>이 페이지는 네트워크 폴리시(NetworkPolicy)로 위브넷(Weave Net)를 사용하는 방법을 살펴본다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하다. 맨 땅에서부터 시작하기를 위해서
<a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm 시작하기 안내서</a>를 따른다.</p><h2 id=weave-net-애드온을-설치한다>Weave Net 애드온을 설치한다</h2><p><a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/>애드온을 통한 쿠버네티스 통합하기</a> 가이드를 따른다.</p><p>쿠버네티스의 위브넷 애드온은 쿠버네티스의 모든 네임스페이스의
네크워크 정책 어노테이션을 자동으로 모니터링하며,
정책에 따라 트래픽을 허용하고 차단하는 <code>iptables</code> 규칙을 구성하는
<a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/#npc>네트워크 폴리시 컨트롤러</a>와 함께 제공된다.</p><h2 id=설치-시험>설치 시험</h2><p>위브넷이 동작하는지 확인한다.</p><p>다음 커맨드를 입력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -n kube-system -o wide
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>NAME                                    READY     STATUS    RESTARTS   AGE       IP              NODE
weave-net-1t1qg                         2/2       Running   0          9d        192.168.2.10    worknode3
weave-net-231d7                         2/2       Running   1          7d        10.2.0.17       worknodegpu
weave-net-7nmwt                         2/2       Running   3          9d        192.168.2.131   masternode
weave-net-pmw8w                         2/2       Running   0          9d        192.168.2.216   worknode2
</code></pre><p>위브넷 파드를 가진 각 노드와 모든 파드는 <code>Running</code>이고 <code>2/2 READY</code>이다(<code>2/2</code>는 각 파드가 <code>weave</code>와 <code>weave-npc</code>를 가지고 있음을 뜻한다).</p><h2 id=다음-내용>다음 내용</h2><p>위브넷 애드온을 설치하고 나서, 쿠버네티스 네트워크 폴리시를 시도하기 위해
<a href=/ko/docs/tasks/administer-cluster/declare-network-policy/>네트워크 폴리시 선언하기</a>를
따라 할 수 있다. 질문이 있으면
<a href=https://github.com/weaveworks/weave#getting-help>슬랙 #weave-community 이나 Weave 유저그룹</a>에 연락한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3d0cd7d2f13d4759094f281504cf57b8>3.6 - DNS 서비스 사용자 정의하기</h1><p>이 페이지는 클러스터 안에서 사용자의
DNS <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드(Pod)>파드(Pod)</a> 를 설정하고
DNS 변환(DNS resolution) 절차를 사용자 정의하는 방법을 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터는 CoreDNS 애드온을 구동하고 있어야 한다.
<a href=/ko/docs/tasks/administer-cluster/coredns/#coredns%EB%A1%9C-%EC%9D%B4%EA%B4%80%ED%95%98%EA%B8%B0>CoreDNS로 이관하기</a>
는 <code>kubeadm</code> 을 이용하여 <code>kube-dns</code> 로부터 이관하는 방법을 설명한다.</p><p>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.12.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=소개>소개</h2><p>DNS는 <em>애드온 관리자</em> 인 <a href=https://releases.k8s.io/master/cluster/addons/README.md>클러스터 애드온</a>을
사용하여 자동으로 시작되는 쿠버네티스
내장 서비스이다.</p><p>쿠버네티스 v1.12 부터, CoreDNS는 kube-dns를 대체하여 권장되는 DNS 서버이다. 만약 사용자의 클러스터가 원래 kube-dns를 사용하였을 경우,
CoreDNS 대신 <code>kube-dns</code> 를 계속 사용할 수도 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> CoreDNS 서비스는 <code>metadata.name</code> 필드에 <code>kube-dns</code> 로 이름이 지정된다.
이를 통해, 기존의 <code>kube-dns</code> 서비스 이름을 사용하여 클러스터 내부의 주소를 확인하는 워크로드에 대한 상호 운용성이 증가된다. <code>kube-dns</code> 로 서비스 이름을 사용하면, 해당 DNS 공급자가 어떤 공통 이름으로 실행되고 있는지에 대한 구현 세부 정보를 추상화한다.</div><p>CoreDNS를 디플로이먼트(Deployment)로 실행하고 있을 경우, 일반적으로 고정 IP 주소를 갖는 쿠버네티스 서비스로 노출된다.
Kubelet 은 <code>--cluster-dns=&lt;dns-service-ip></code> 플래그를 사용하여 DNS 확인자 정보를 각 컨테이너에 전달한다.</p><p>DNS 이름에도 도메인이 필요하다. 사용자는 kubelet 에 있는 <code>--cluster-domain=&lt;default-local-domain></code> 플래그를
통하여 로컬 도메인을 설정할 수 있다.</p><p>DNS 서버는 정방향 조회(A 및 AAAA 레코드), 포트 조회(SRV 레코드), 역방향 IP 주소 조회(PTR 레코드) 등을 지원한다.
더 자세한 내용은 <a href=/ko/docs/concepts/services-networking/dns-pod-service/>서비스 및 파드용 DNS</a>를 참고한다.</p><p>만약 파드의 <code>dnsPolicy</code> 가 <code>default</code> 로 지정되어 있는 경우,
파드는 자신이 실행되는 노드의 이름 변환(name resolution) 구성을 상속한다.
파드의 DNS 변환도 노드와 동일하게 작동해야 한다.
그 외에는 <a href=/docs/tasks/administer-cluster/dns-debugging-resolution/#known-issues>알려진 이슈</a>를 참고한다.</p><p>만약 위와 같은 방식을 원하지 않거나, 파드를 위해 다른 DNS 설정이 필요한 경우,
사용자는 kubelet 의 <code>--resolv-conf</code> 플래그를 사용할 수 있다.
파드가 DNS를 상속받지 못하도록 하기 위해 이 플래그를 ""로 설정한다.
DNS 상속을 위해 <code>/etc/resolv.conf</code> 이외의 파일을 지정할 경우 유효한 파일 경로를 설정한다.</p><h2 id=coredns>CoreDNS</h2><p>CoreDNS는 <a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>dns 명세</a>를 준수하며 클러스터 DNS 역할을 할 수 있는, 범용적인 권한을 갖는 DNS 서버이다.</p><h3 id=coredns-컨피그맵-configmap-옵션>CoreDNS 컨피그맵(ConfigMap) 옵션</h3><p>CoreDNS는 모듈형이자 플러그인이 가능한 DNS 서버이며, 각 플러그인들은 CoreDNS에 새로운 기능을 부가한다.
이는 CoreDNS 구성 파일인 <a href=https://coredns.io/2017/07/23/corefile-explained/>Corefile</a>을 관리하여 구성할 수 있다.
클러스터 관리자는 CoreDNS Corefile에 대한 <a class=glossary-tooltip title='키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>을 수정하여
해당 클러스터에 대한 DNS 서비스 검색 동작을
변경할 수 있다.</p><p>쿠버네티스에서 CoreDNS는 아래의 기본 Corefile 구성으로 설치된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>coredns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>Corefile</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    .:53 {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        errors
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        health {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            lameduck 5s
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        ready
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            pods insecure
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            fallthrough in-addr.arpa ip6.arpa
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            ttl 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        prometheus :9153
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        forward . /etc/resolv.conf
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        cache 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loop
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        reload
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loadbalance
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    }</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>Corefile의 구성은 CoreDNS의 아래 <a href=https://coredns.io/plugins>플러그인</a>을 포함한다.</p><ul><li><a href=https://coredns.io/plugins/errors/>errors</a>: 오류가 표준 출력(stdout)에 기록된다.</li><li><a href=https://coredns.io/plugins/health/>health</a>: CoreDNS의 상태(healthy)가 <code>http://localhost:8080/health</code> 에 기록된다. 이 확장 구문에서 <code>lameduck</code> 은 프로세스를 비정상 상태(unhealthy)로 만들고, 프로세스가 종료되기 전에 5초 동안 기다린다.</li><li><a href=https://coredns.io/plugins/ready/>ready</a>: 8181 포트의 HTTP 엔드포인트가, 모든 플러그인이 준비되었다는 신호를 보내면 200 OK 를 반환한다.</li><li><a href=https://coredns.io/plugins/kubernetes/>kubernetes</a>: CoreDNS가 쿠버네티스의 서비스 및 파드의 IP를 기반으로 DNS 쿼리에 대해 응답한다. 해당 플러그인에 대한 <a href=https://coredns.io/plugins/kubernetes/>세부 사항</a>은 CoreDNS 웹사이트에서 확인할 수 있다. <code>ttl</code> 을 사용하면 응답에 대한 사용자 정의 TTL 을 지정할 수 있으며, 기본값은 5초이다. 허용되는 최소 TTL은 0초이며, 최대값은 3600초이다. 레코드가 캐싱되지 않도록 할 경우, TTL을 0으로 설정한다.
<code>pods insecure</code> 옵션은 <em>kube-dns</em> 와의 하위 호환성을 위해 제공된다. <code>pods verified</code> 옵션을 사용하여, 일치하는 IP의 동일 네임스페이스(Namespace)에 파드가 존재하는 경우에만 A 레코드를 반환하게 할 수 있다. <code>pods disabled</code> 옵션은 파드 레코드를 사용하지 않을 경우 사용된다.</li><li><a href=https://coredns.io/plugins/metrics/>prometheus</a>: CoreDNS의 메트릭은 <a href=https://prometheus.io/>프로메테우스</a> 형식(OpenMetrics 라고도 알려진)의 <code>http://localhost:9153/metrics</code> 에서 사용 가능하다.</li><li><a href=https://coredns.io/plugins/forward/>forward</a>: 쿠버네티스 클러스터 도메인에 없는 쿼리들은 모두 사전에 정의된 리졸버(/etc/resolv.conf)로 전달된다.</li><li><a href=https://coredns.io/plugins/cache/>cache</a>: 프론트 엔드 캐시를 활성화한다.</li><li><a href=https://coredns.io/plugins/loop/>loop</a>: 간단한 전달 루프(loop)를 감지하고, 루프가 발견되면 CoreDNS 프로세스를 중단(halt)한다.</li><li><a href=https://coredns.io/plugins/reload>reload</a>: 변경된 Corefile을 자동으로 다시 로드하도록 한다. 컨피그맵 설정을 변경한 후에 변경 사항이 적용되기 위하여 약 2분정도 소요된다.</li><li><a href=https://coredns.io/plugins/loadbalance>loadbalance</a>: 응답에 대하여 A, AAAA, MX 레코드의 순서를 무작위로 선정하는 라운드-로빈 DNS 로드밸런서이다.</li></ul><p>사용자는 컨피그맵을 변경하여 기본 CoreDNS 동작을 변경할 수 있다.</p><h3 id=coredns를-사용하는-스텁-도메인-stub-domain-과-업스트림-네임서버-nameserver-의-설정>CoreDNS를 사용하는 스텁 도메인(Stub-domain)과 업스트림 네임서버(nameserver)의 설정</h3><p>CoreDNS는 <a href=https://coredns.io/plugins/forward/>포워드 플러그인</a>을 사용하여 스텁 도메인 및 업스트림 네임서버를 구성할 수 있다.</p><h4 id=예시>예시</h4><p>만약 클러스터 운영자가 10.150.0.1 에 위치한 <a href=https://www.consul.io/>Consul</a> 도메인 서버를 가지고 있고, 모든 Consul 이름의 접미사가 .consul.local 인 경우, CoreDNS에서 이를 구성하기 위해 클러스터 관리자는 CoreDNS 컨피그맵에서 다음 구문을 생성한다.</p><pre tabindex=0><code>consul.local:53 {
        errors
        cache 30
        forward . 10.150.0.1
    }
</code></pre><p>모든 비 클러스터의 DNS 조회가 172.16.0.1 의 특정 네임서버를 통과하도록 할 경우, <code>/etc/resolv.conf</code> 대신 <code>forward</code> 를 네임서버로 지정한다.</p><pre tabindex=0><code>forward .  172.16.0.1
</code></pre><p>기본 <code>Corefile</code> 구성에 따른 최종 컨피그맵은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>coredns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>Corefile</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    .:53 {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        errors
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        health
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>           pods insecure
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>           fallthrough in-addr.arpa ip6.arpa
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        prometheus :9153
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        forward . 172.16.0.1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        cache 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loop
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        reload
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loadbalance
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    consul.local:53 {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        errors
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        cache 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        forward . 10.150.0.1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    }</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p><code>Kubeadm</code> 툴은 kube-dns 컨피그맵에서 동일한 설정의 CoreDNS 컨피그맵으로의
자동 변환을 지원한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> kube-dns는 스텁 도메인 및 네임서버(예: ns.foo.com)에 대한 FQDN을 허용하지만 CoreDNS에서는 이 기능을 지원하지 않는다.
변환 과정에서, 모든 FQDN 네임서버는 CoreDNS 설정에서 생략된다.</div><h2 id=kube-dns에-대응되는-coredns-설정>kube-dns에 대응되는 CoreDNS 설정</h2><p>CoreDNS는 kube-dns 이상의 기능을 지원한다.
<code>StubDomains</code> 과 <code>upstreamNameservers</code> 를 지원하도록 생성된 kube-dns의 컨피그맵은 CoreDNS의 <code>forward</code> 플러그인으로 변환된다.</p><h3 id=예시-1>예시</h3><p>kube-dns에 대한 이 컨피그맵 예제는 stubDomains 및 upstreamNameservers를 지정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>stubDomains</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>{<span style=color:#b44>&#34;abc.com&#34;</span><span style=color:#bbb> </span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;1.2.3.4&#34;</span>],<span style=color:#bbb> </span><span style=color:#b44>&#34;my.cluster.local&#34;</span><span style=color:#bbb> </span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;2.3.4.5&#34;</span>]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>upstreamNameservers</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>[<span style=color:#b44>&#34;8.8.8.8&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;8.8.4.4&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span></code></pre></div><p>CoreDNS에서는 동등한 설정으로 Corefile을 생성한다.</p><ul><li>stubDomains 에 대응하는 설정:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>abc.com:53 {<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>errors<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>cache 30<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>forward . 1.2.3.4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>my.cluster.local:53 {<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>errors<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>cache 30<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>forward . 2.3.4.5<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>기본 플러그인으로 구성된 완전한 Corefile.</p><pre tabindex=0><code>.:53 {
    errors
    health
    kubernetes cluster.local in-addr.arpa ip6.arpa {
        pods insecure
        fallthrough in-addr.arpa ip6.arpa
    }
    federation cluster.local {
        foo foo.feddomain.com
    }
    prometheus :9153
    forward . 8.8.8.8 8.8.4.4
    cache 30
}
abc.com:53 {
    errors
    cache 30
    forward . 1.2.3.4
}
my.cluster.local:53 {
    errors
    cache 30
    forward . 2.3.4.5
}
</code></pre><h2 id=coredns로의-이관>CoreDNS로의 이관</h2><p>kube-dns에서 CoreDNS로 이관하기 위하여,
kube-dns를 CoreDNS로 교체하여 적용하는 방법에 대한 상세 정보는
<a href=https://coredns.io/2018/05/21/migration-from-kube-dns-to-coredns/>블로그 기사</a>를 참고한다.</p><p>또한 공식적인 CoreDNS <a href=https://github.com/coredns/deployment/blob/master/kubernetes/deploy.sh>배포 스크립트</a>를
사용하여 이관할 수도 있다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/tasks/administer-cluster/dns-debugging-resolution/>DNS 변환 디버깅하기</a> 읽기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2bffd7f3571cdd609bd97fb2e1bdb2fe>3.7 - 기본 스토리지클래스(StorageClass) 변경하기</h1><p>이 페이지는 특별한 요구사항이 없는 퍼시스턴트볼륨클레임(PersistentVolumeClaim)의 볼륨을 프로비저닝
하는데 사용되는 기본 스토리지 클래스를 변경하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=왜-기본-스토리지-클래스를-변경하는가>왜 기본 스토리지 클래스를 변경하는가?</h2><p>설치 방법에 따라, 사용자의 쿠버네티스 클러스터는 기본으로 표시된 기존
스토리지클래스와 함께 배포될 수 있다. 이 기본 스토리지클래스는 특정
스토리지 클래스가 필요하지 않은 퍼시스턴트볼륨클레임에 대해 스토리지를
동적으로 프로비저닝 하기 위해 사용된다.
더 자세한 내용은 <a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8%ED%81%B4%EB%A0%88%EC%9E%84>퍼시스턴트볼륨클레임 문서</a>를
보자.</p><p>미리 설치된 기본 스토리지클래스가 사용자의 예상되는 워크로드에 적합하지
않을수도 있다. 예를 들어, 너무 가격이 높은 스토리지를 프로비저닝 해야할
수도 있다. 이런 경우에, 기본 스토리지 클래스를 변경하거나 완전히 비활성화
하여 스토리지의 동적 프로비저닝을 방지할 수 있다.</p><p>기본 스토리지클래스를 삭제하는 경우, 사용자의 클러스터에서 구동 중인
애드온 매니저에 의해 자동으로 다시 생성될 수 있으므로 정상적으로 삭제가 되지 않을 수도 있다. 애드온 관리자
및 개별 애드온을 비활성화 하는 방법에 대한 자세한 내용은 설치 문서를 참조하자.</p><h2 id=기본-스토리지클래스-변경하기>기본 스토리지클래스 변경하기</h2><ol><li><p>사용자의 클러스터에 있는 스토리지클래스 목록을 조회한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get storageclass
</span></span></code></pre></div><p>결과는 아래와 유사하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>NAME                 PROVISIONER               AGE
</span></span><span style=display:flex><span>standard <span style=color:#666>(</span>default<span style=color:#666>)</span>   kubernetes.io/gce-pd      1d
</span></span><span style=display:flex><span>gold                 kubernetes.io/gce-pd      1d
</span></span></code></pre></div><p>기본 스토리지클래스는 <code>(default)</code> 로 표시되어 있다.</p></li><li><p>기본 스토리지클래스를 기본값이 아닌 것으로 표시한다.</p><p>기본 스토리지클래스에는
<code>storageclass.kubernetes.io/is-default-class</code> 의 값이 <code>true</code> 로 설정되어 있다.
다른 값이거나 어노테이션이 없을 경우 <code>false</code> 로 처리된다.</p><p>스토리지클래스를 기본값이 아닌 것으로 표시하려면, 그 값을 <code>false</code> 로 변경해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl patch storageclass standard -p <span style=color:#b44>&#39;{&#34;metadata&#34;: {&#34;annotations&#34;:{&#34;storageclass.kubernetes.io/is-default-class&#34;:&#34;false&#34;}}}&#39;</span>
</span></span></code></pre></div><p>여기서 <code>standard</code> 는 사용자가 선택한 스토리지클래스의 이름이다.</p></li><li><p>스토리지클래스를 기본값으로 표시한다.</p><p>이전 과정과 유사하게, 어노테이션을 추가/설정해야 한다.
<code>storageclass.kubernetes.io/is-default-class=true</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl patch storageclass gold -p <span style=color:#b44>&#39;{&#34;metadata&#34;: {&#34;annotations&#34;:{&#34;storageclass.kubernetes.io/is-default-class&#34;:&#34;true&#34;}}}&#39;</span>
</span></span></code></pre></div><p>최대 1개의 스토리지클래스를 기본값으로 표시할 수 있다는 것을 알아두자. 만약
2개 이상이 기본값으로 표시되면, 명시적으로 <code>storageClassName</code> 가 지정되지 않은 <code>PersistentVolumeClaim</code> 은 생성될 수 없다.</p></li><li><p>사용자가 선택한 스토리지클래스가 기본값으로 되어 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get storageclass
</span></span></code></pre></div><p>결과는 아래와 유사하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>NAME             PROVISIONER               AGE
</span></span><span style=display:flex><span>standard         kubernetes.io/gce-pd      1d
</span></span><span style=display:flex><span>gold <span style=color:#666>(</span>default<span style=color:#666>)</span>   kubernetes.io/gce-pd      1d
</span></span></code></pre></div></li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트볼륨(PersistentVolume)</a>에 대해 더 보기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1e966f5d0540bbee0876f9d0d08d54dc>3.8 - 네임스페이스를 사용해 클러스터 공유하기</h1><p>이 페이지는 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>를 살펴보고, 작업하고, 삭제하는 방법에 대해 다룬다. 또한 쿠버네티스 네임스페이스를 사용해 클러스터를 세분화하는 방법에 대해서도 다룬다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><a href=/ko/docs/setup/>기존 쿠버네티스 클러스터</a>가 있다.</li><li>쿠버네티스 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>, <a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>, 그리고 <a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>에 대해 이해하고 있다.</li></ul><h2 id=네임스페이스-보기>네임스페이스 보기</h2><ol><li>아래 명령어를 사용해 클러스터의 현재 네임스페이스를 나열한다.</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE
default       Active    11d
kube-system   Active    11d
kube-public   Active    11d
</code></pre><p>쿠버네티스를 시작하면 세 개의 초기 네임스페이스가 있다.</p><ul><li><code>default</code> 다른 네임스페이스가 없는 오브젝트를 위한 기본 네임스페이스</li><li><code>kube-system</code> 쿠버네티스 시스템에서 생성된 오브젝트의 네임스페이스</li><li><code>kube-public</code> 이 네임스페이스는 자동으로 생성되며 모든 사용자(미인증 사용자를 포함)가 읽을 수 있다. 이 네임스페이스는 일부 리소스를 공개적으로 보고 읽을 수 있어야 하는 경우에 대비하여 대부분이 클러스터 사용을 위해 예약돼 있다. 그러나 이 네임스페이스의 공개적인 성격은 관례일 뿐 요구 사항은 아니다.</li></ul><p>아래 명령을 실행해 특정 네임스페이스에 대한 요약 정보를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces &lt;name&gt;
</span></span></code></pre></div><p>자세한 정보를 보는 것도 가능하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe namespaces &lt;name&gt;
</span></span></code></pre></div><pre tabindex=0><code>Name:           default
Labels:         &lt;none&gt;
Annotations:    &lt;none&gt;
Status:         Active

No resource quota.

Resource Limits
 Type       Resource    Min Max Default
 ----               --------    --- --- ---
 Container          cpu         -   -   100m
</code></pre><p>이러한 세부 정보에는 리소스 한도(limit) 범위 뿐만 아니라 리소스 쿼터(만약 있다면)까지 모두 표시된다.</p><p>리소스 쿼터는 <em>네임스페이스</em> 내 리소스의 집계 사용량을 추적하며,
<em>네임스페이스</em>에서 사용할 수 있는 <em>하드(Hard)</em> 리소스 사용 제한을 클러스터 운영자가 정의할 수 있도록 해준다.</p><p>제한 범위는 하나의 엔티티(entity)가 하나의 <em>네임스페이스</em>에서 사용할 수 있는
리소스 양에 대한 최대/최소 제약 조건을 정의한다.</p><p><a href=https://git.k8s.io/design-proposals-archive/resource-management/admission_control_limit_range.md>어드미션 컨트롤: 리밋 레인지(Limit Range)</a>를 참조하자.</p><p>네임스페이스는 다음 두 상태 중 하나에 있을 수 있다.</p><ul><li><code>Active</code> 네임스페이스가 사용 중이다.</li><li><code>Terminating</code> 네임스페이스가 삭제 중이므로 새 오브젝트에 사용할 수 없다.</li></ul><p>자세한 내용은 API 레퍼런스의 <a href=/docs/reference/kubernetes-api/cluster-resources/namespace-v1/>네임스페이스</a>를
참조한다.</p><h2 id=새-네임스페이스-생성하기>새 네임스페이스 생성하기</h2><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kube-</code> 접두사는 쿠버네티스 시스템 네임스페이스로 예약돼 있으므로 이를 사용해 네임스페이스를 생성하지 않도록 한다.</div><ol><li><p><code>my-namespace.yaml</code>이라는 YAML 파일을 생성하고 아래 내용을 작성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;insert-namespace-name-here&gt;<span style=color:#bbb>
</span></span></span></code></pre></div><p>다음 명령을 실행한다.</p><pre tabindex=0><code>kubectl create -f ./my-namespace.yaml
</code></pre></li><li><p>아래 명령으로 네임스페이스를 생성할 수도 있다.</p><pre tabindex=0><code>kubectl create namespace &lt;insert-namespace-name-here&gt;
</code></pre></li></ol><p>네임스페이스의 이름은
유효한 <a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-label-names>DNS 레이블</a>이어야 한다.</p><p>옵션 필드인 <code>finalizer</code>는 네임스페이스가 삭제 될 때 관찰자가 리소스를 제거할 수 있도록 한다. 존재하지 않는 파이널라이저(finalizer)를 명시한 경우 네임스페이스는 생성되지만 사용자가 삭제하려 하면 <code>Terminating</code> 상태가 된다.</p><p>파이널라이저에 대한 자세한 내용은 네임스페이스 <a href=https://git.k8s.io/design-proposals-archive/architecture/namespaces.md#finalizers>디자인 문서</a>에서 확인할 수 있다.</p><h2 id=네임스페이스-삭제하기>네임스페이스 삭제하기</h2><p>다음 명령을 실행해 네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespaces &lt;insert-some-namespace-name&gt;
</span></span></code></pre></div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 이렇게 하면 네임스페이스의 <em>모든 것</em> 이 삭제된다!</div><p>삭제는 비동기적이므로 삭제 후 한동안은 네임스페이스의 상태가 <code>Terminating</code>으로 보일 것이다.</p><h2 id=쿠버네티스-네임스페이스를-사용해-클러스터-세분화하기>쿠버네티스 네임스페이스를 사용해 클러스터 세분화하기</h2><ol><li><p>기본 네임스페이스 이해하기</p><p>기본적으로 쿠버네티스 클러스터는 클러스터에서 사용할 기본 파드, 서비스, 그리고 디플로이먼트(Deployment) 집합을 가지도록
클러스터를 프로비저닝 할 때 기본 네임스페이스를 인스턴스화한다.</p><p>새 클러스터가 있다고 가정하고 아래 명령을 수행하면 사용 가능한 네임스페이스를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces
</span></span></code></pre></div><pre tabindex=0><code>NAME      STATUS    AGE
default   Active    13m
</code></pre></li><li><p>새 네임스페이스 생성하기</p><p>이 예제에서는 내용을 저장할 쿠버네티스 네임스페이스를 추가로 두 개 생성할 것이다.</p><p>개발과 프로덕션 유스케이스에서 공유 쿠버네티스 클러스터를 사용하는 조직이 있다고 가정하자.</p><p>개발 팀은 애플리케이션을 구축하고 실행하는데 사용하는 파드, 서비스, 디플로이먼트의 목록을 볼 수 있는 공간을 클러스터에 유지하려 한다.
이 공간에서는 쿠버네티스 리소스가 자유롭게 추가 및 제거되고,
누가 리소스를 수정할 수 있는지 없는지에 대한 제약이 완화돼 빠른 개발이 가능해진다.</p><p>운영 팀은 운영 사이트를 실행하는 파드, 서비스, 디플로이먼트 집합을 조작할 수 있는 사람과
그렇지 않은 사람들에 대해 엄격한 절차를 적용할 수 있는 공간을 클러스터에 유지하려 한다.</p><p>이 조직이 따를 수 있는 한 가지 패턴은 쿠버네티스 클러스터를 <code>development(개발)</code>와 <code>production(운영)</code>이라는 두 개의 네임스페이스로 분할하는 것이다.</p><p>우리의 작업을 보존하기 위해 새로운 네임스페이스 두 개를 만들자.</p><p>kubectl을 사용해 <code>development</code> 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/admin/namespace-dev.json
</span></span></code></pre></div><p>그런 다음 kubectl을 사용해 <code>production</code> 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/admin/namespace-prod.json
</span></span></code></pre></div><p>제대로 생성이 되었는지 확인하기 위해 클러스터 내의 모든 네임스페이스를 나열한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces --show-labels
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE       LABELS
default       Active    32m       &lt;none&gt;
development   Active    29s       name=development
production    Active    23s       name=production
</code></pre></li><li><p>네임스페이스마다 파드 생성</p><p>쿠버네티스 네임스페이스는 클러스터의 파드, 서비스 그리고 디플로이먼트의 범위를 제공한다.</p><p>하나의 네임스페이스와 상호 작용하는 사용자는 다른 네임스페이스의 내용을 볼 수 없다.</p><p>이를 보여주기 위해 <code>development</code> 네임스페이스에 간단한 디플로이먼트와 파드를 생성하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment snowflake --image<span style=color:#666>=</span>registry.k8s.io/serve_hostname  -n<span style=color:#666>=</span>development --replicas<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>단순히 호스트명을 제공해주는 <code>snowflake</code>라는 파드의 개수를 2개로 유지하는 디플로이먼트를 생성하였다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment -n<span style=color:#666>=</span>development
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
snowflake    2/2     2            2           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>snowflake -n<span style=color:#666>=</span>development
</span></span></code></pre></div><pre tabindex=0><code>NAME                         READY     STATUS    RESTARTS   AGE
snowflake-3968820950-9dgr8   1/1       Running   0          2m
snowflake-3968820950-vgc4n   1/1       Running   0          2m
</code></pre><p>개발자들은 <code>production</code> 네임스페이스의 내용에 영향을 끼칠 걱정 없이 하고 싶은 것을 할 수 있으니 대단하지 않은가.</p><p>이제 <code>production</code> 네임스페이스로 전환해 한 네임스페이스의 리소스가 다른 네임스페이스에서는 어떻게 숨겨지는지 보자.</p><p><code>production</code> 네임스페이스는 비어있어야 하며 아래 명령은 아무 것도 반환하지 않아야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment -n<span style=color:#666>=</span>production
</span></span><span style=display:flex><span>kubectl get pods -n<span style=color:#666>=</span>production
</span></span></code></pre></div><p>프로덕션이 가축 키우는 것을 좋아하듯이, 우리도 <code>production</code> 네임스페이스에 cattle(가축)이라는 이름의 파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment cattle --image<span style=color:#666>=</span>registry.k8s.io/serve_hostname -n<span style=color:#666>=</span>production
</span></span><span style=display:flex><span>kubectl scale deployment cattle --replicas<span style=color:#666>=</span><span style=color:#666>5</span> -n<span style=color:#666>=</span>production
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl get deployment -n<span style=color:#666>=</span>production
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
cattle       5/5     5            5           10s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>cattle -n<span style=color:#666>=</span>production
</span></span></code></pre></div><pre tabindex=0><code>NAME                      READY     STATUS    RESTARTS   AGE
cattle-2263376956-41xy6   1/1       Running   0          34s
cattle-2263376956-kw466   1/1       Running   0          34s
cattle-2263376956-n4v97   1/1       Running   0          34s
cattle-2263376956-p5p3i   1/1       Running   0          34s
cattle-2263376956-sxpth   1/1       Running   0          34s
</code></pre></li></ol><p>지금 쯤이면 사용자가 한 네임스페이스에 생성한 리소스는 다른 네임스페이스에서 숨겨져 있어야 한다는 것을 잘 알고 있을 것이다.</p><p>쿠버네티스 정책 지원이 발전함에 따라, 이 시나리오를 확장해 각 네임스페이스에
서로 다른 인증 규칙을 제공하는 방법을 보이도록 하겠다.</p><h2 id=네임스페이스의-사용-동기-이해하기>네임스페이스의 사용 동기 이해하기</h2><p>단일 클러스터는 여러 사용자 및 사용자 그룹(이하 '사용자 커뮤니티')의 요구를 충족시킬 수 있어야 한다.</p><p>쿠버네티스 <em>네임스페이스</em> 는 여러 프로젝트, 팀 또는 고객이 쿠버네티스 클러스터를 공유할 수 있도록 지원한다.</p><p>이를 위해 다음을 제공한다.</p><ol><li><a href=/ko/docs/concepts/overview/working-with-objects/names/>이름</a>에 대한 범위</li><li>인증과 정책을 클러스터의 하위 섹션에 연결하는 메커니즘</li></ol><p>여러 개의 네임스페이스를 사용하는 것은 선택 사항이다.</p><p>각 사용자 커뮤니티는 다른 커뮤니티와 격리된 상태로 작업할 수 있기를 원한다.</p><p>각 사용자 커뮤니티는 다음을 가진다.</p><ol><li>리소스 (파드, 서비스, 레플리케이션 컨트롤러(replication controller) 등</li><li>정책 (커뮤니티에서 조치를 수행할 수 있거나 없는 사람)</li><li>제약 조건 (해당 커뮤니티에서는 어느 정도의 쿼터가 허용되는지 등)</li></ol><p>클러스터 운영자는 각 사용자 커뮤니티 마다 네임스페이스를 생성할 수 있다.</p><p>네임스페이스는 다음을 위한 고유한 범위를 제공한다.</p><ol><li>(기본 명명 충돌을 방지하기 위해) 명명된 리소스</li><li>신뢰할 수 있는 사용자에게 관리 권한 위임</li><li>커뮤니티 리소스 소비를 제한하는 기능</li></ol><p>유스케이스는 다음을 포함한다.</p><ol><li>클러스터 운영자로서 단일 클러스터에서 여러 사용자 커뮤니티를 지원하려 한다.</li><li>클러스터 운영자로서 클러스터 분할에 대한 권한을
해당 커뮤니티의 신뢰할 수 있는 사용자에게 위임하려 한다.</li><li>클러스터 운영자로서 클러스터를 사용하는 다른 커뮤니티에 미치는 영향을 제한하기 위해
각 커뮤니티가 사용할 수 있는 리소스의 양을 제한하고자 한다.</li><li>클러스터 사용자로서 다른 사용자 커뮤니티가 클러스터에서 수행하는 작업과는 별도로
사용자 커뮤니티와 관련된 리소스와 상호 작용하고 싶다.</li></ol><h2 id=네임스페이스와-dns-이해하기>네임스페이스와 DNS 이해하기</h2><p><a href=/ko/docs/concepts/services-networking/service/>서비스</a>를 생성하면 상응하는 <a href=/ko/docs/concepts/services-networking/dns-pod-service/>DNS 엔트리(entry)</a>가 생성된다.
이 엔트리는 <code>&lt;서비스-이름>&lt;네임스페이스=이름>.svc.cluster.local</code> 형식을 갖는데,
컨테이너가 <code>&lt;서비스-이름></code>만 갖는 경우에는 네임스페이스에 국한된 서비스로 연결된다.
이 기능은 개발, 스테이징 및 프로덕션과 같이
여러 네임스페이스 내에서 동일한 설정을 사용할 때 유용하다.
네임스페이스를 넘어서 접근하려면 전체 주소 도메인 이름(FQDN)을 사용해야 한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/overview/working-with-objects/namespaces/#%EC%84%A0%ED%98%B8%ED%95%98%EB%8A%94-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0>네임스페이스 선호(preference)</a>에 대해 자세히 알아보기.</li><li><a href=/ko/docs/concepts/overview/working-with-objects/namespaces/#%EC%9A%94%EC%B2%AD%EC%97%90-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0>요청(request)에 대한 네임스페이스 설정</a>에 대해 자세히 알아보기.</li><li><a href=https://git.k8s.io/design-proposals-archive/architecture/namespaces.md>네임스페이스 설계</a> 참조하기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a3790dfb57271d13517e549dffa805b9>3.9 - 네트워크 폴리시(Network Policy) 선언하기</h1><p>이 문서는 사용자가 쿠버네티스 <a href=/ko/docs/concepts/services-networking/network-policies/>네트워크폴리시 API</a>를 사용하여 파드(Pod)가 서로 통신하는 방법을 제어하는 네트워크 폴리시를 선언하는데 도움을 준다.</p><div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.8.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><p>네트워크 폴리시를 지원하는 네트워크 제공자를 구성하였는지 확인해야 한다. 다음과 같이 네트워크폴리시를 지원하는 많은 네트워크 제공자들이 있다.</p><ul><li><a href=/docs/tasks/administer-cluster/network-policy-provider/antrea-network-policy/>Antrea</a></li><li><a href=/ko/docs/tasks/administer-cluster/network-policy-provider/calico-network-policy/>캘리코(Calico)</a></li><li><a href=/ko/docs/tasks/administer-cluster/network-policy-provider/cilium-network-policy/>실리움(Cilium)</a></li><li><a href=/ko/docs/tasks/administer-cluster/network-policy-provider/kube-router-network-policy/>Kube-router</a></li><li><a href=/ko/docs/tasks/administer-cluster/network-policy-provider/romana-network-policy/>로마나(Romana)</a></li><li><a href=/ko/docs/tasks/administer-cluster/network-policy-provider/weave-network-policy/>위브넷(Weave Net)</a></li></ul><h2 id=nginx-디플로이먼트-deployment-를-생성하고-서비스-service-를-통해-노출하기><code>nginx</code> 디플로이먼트(Deployment)를 생성하고 서비스(Service)를 통해 노출하기</h2><p>쿠버네티스 네트워크 폴리시가 어떻게 동작하는지 확인하기 위해서, <code>nginx</code> 디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl create deployment nginx --image=nginx
</span></span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>deployment.apps/nginx created
</code></pre><p><code>nginx</code> 라는 이름의 서비스를 통해 디플로이먼트를 노출한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl expose deployment nginx --port=80
</span></span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>service/nginx exposed
</code></pre><p>위 명령어들은 nginx 파드에 대한 디플로이먼트를 생성하고, <code>nginx</code> 라는 이름의 서비스를 통해 디플로이먼트를 노출한다. <code>nginx</code> 파드와 디플로이먼트는 <code>default</code> 네임스페이스(namespace)에 존재한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl get svc,pod
</span></span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE
service/kubernetes          10.100.0.1    &lt;none&gt;        443/TCP    46m
service/nginx               10.100.0.16   &lt;none&gt;        80/TCP     33s

NAME                        READY         STATUS        RESTARTS   AGE
pod/nginx-701339712-e0qfq   1/1           Running       0          35s
</code></pre><h2 id=다른-파드에서-접근하여-서비스-테스트하기>다른 파드에서 접근하여 서비스 테스트하기</h2><p>사용자는 다른 파드에서 새 <code>nginx</code> 서비스에 접근할 수 있어야 한다. <code>default</code> 네임스페이스에 있는 다른 파드에서 <code>nginx</code> 서비스에 접근하기 위하여, busybox 컨테이너를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl run busybox --rm -ti --image=busybox:1.28 -- /bin/sh
</span></span></span></code></pre></div><p>사용자 쉘에서, 다음의 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre><h2 id=nginx-서비스에-대해-접근-제한하기><code>nginx</code> 서비스에 대해 접근 제한하기</h2><p><code>access: true</code> 레이블을 가지고 있는 파드만 <code>nginx</code> 서비스에 접근할 수 있도록 하기 위하여, 다음과 같은 네트워크폴리시 오브젝트를 생성한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/networking/nginx-policy.yaml download=service/networking/nginx-policy.yaml><code>service/networking/nginx-policy.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-nginx-policy-yaml")' title="Copy service/networking/nginx-policy.yaml to clipboard"></img></div><div class=includecode id=service-networking-nginx-policy-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>access-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>access</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>네트워크폴리시 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 네트워크폴리시는 정책이 적용되는 파드의 그룹을 선택하는 <code>podSelector</code> 를 포함한다. 사용자는 이 정책이 <code>app=nginx</code> 레이블을 갖는 파드를 선택하는 것을 볼 수 있다. 레이블은 <code>nginx</code> 디플로이먼트에 있는 파드에 자동으로 추가된다. 빈 <code>podSelector</code> 는 네임스페이스의 모든 파드를 선택한다.</div><h2 id=서비스에-정책-할당하기>서비스에 정책 할당하기</h2><p>kubectl을 사용하여 위 <code>nginx-policy.yaml</code> 파일로부터 네트워크폴리시를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl apply -f https://k8s.io/examples/service/networking/nginx-policy.yaml
</span></span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>networkpolicy.networking.k8s.io/access-nginx created
</code></pre><h2 id=access-레이블이-정의되지-않은-서비스에-접근-테스트>access 레이블이 정의되지 않은 서비스에 접근 테스트</h2><p>올바른 레이블이 없는 파드에서 <code>nginx</code> 서비스에 접근하려 할 경우, 요청 타임 아웃이 발생한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl run busybox --rm -ti --image=busybox:1.28 -- /bin/sh
</span></span></span></code></pre></div><p>사용자 쉘에서, 다음의 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
wget: download timed out
</code></pre><h2 id=접근-레이블을-정의하고-다시-테스트>접근 레이블을 정의하고 다시 테스트</h2><p>사용자는 요청이 허용되도록 하기 위하여 올바른 레이블을 갖는 파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl run busybox --rm -ti --labels=&#34;access=true&#34; --image=busybox:1.28 -- /bin/sh
</span></span></span></code></pre></div><p>사용자 쉘에서, 다음의 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-a8f6511197efcd7d0db80ade49620f9d>3.10 - 노드에 대한 확장 리소스 알리기</h1><p>이 페이지는 노드의 확장 리소스를 지정하는 방법을 보여준다.
확장 리소스를 통해 클러스터 관리자는 쿠버네티스에게
알려지지 않은 노드-레벨 리소스를 알릴 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=노드의-이름을-확인한다>노드의 이름을 확인한다</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><p>이 연습에 사용할 노드 중 하나를 선택한다.</p><h2 id=노드-중-하나에-새로운-확장-리소스를-알린다>노드 중 하나에 새로운 확장 리소스를 알린다</h2><p>노드에서 새로운 확장 리소스를 알리려면, 쿠버네티스 API 서버에
HTTP PATCH 요청을 보낸다. 예를 들어, 노드 중 하나에 4개의 동글(dongle)이 있다고
가정한다. 다음은 노드에 4개의 동글 리소스를 알리는 PATCH 요청의
예이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1
</span></span><span style=display:flex><span>Accept: application/json
</span></span><span style=display:flex><span>Content-Type: application/json-patch+json
</span></span><span style=display:flex><span>Host: k8s-master:8080
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#666>[</span>
</span></span><span style=display:flex><span>  <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;op&#34;</span>: <span style=color:#b44>&#34;add&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;path&#34;</span>: <span style=color:#b44>&#34;/status/capacity/example.com~1dongle&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;value&#34;</span>: <span style=color:#b44>&#34;4&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>]</span>
</span></span></code></pre></div><p>참고로 쿠버네티스는 동글이 무엇인지 또는 동글이 무엇을 위한 것인지 알 필요가 없다.
위의 PATCH 요청은 노드에 동글이라고 하는 네 가지 항목이 있음을
쿠버네티스에 알려준다.</p><p>쿠버네티스 API 서버에 요청을 쉽게 보낼 수 있도록 프록시를 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy
</span></span></code></pre></div><p>다른 명령 창에서 HTTP PATCH 요청을 보낸다.
<code>&lt;your-node-name></code> 을 노드의 이름으로 바꾼다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;, &#34;value&#34;: &#34;4&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이전 요청에서 <code>~1</code> 은 패치 경로의 / 문자에 대한
인코딩이다. JSON-Patch의 작업 경로값은 JSON-Pointer로
해석된다. 자세한 내용은 <a href=https://tools.ietf.org/html/rfc6901>IETF RFC 6901</a>의
섹션 3을 참고한다.</div><p>출력은 노드가 4개의 동글 용량을 가졌음을 나타낸다.</p><pre tabindex=0><code>&#34;capacity&#34;: {
  &#34;cpu&#34;: &#34;2&#34;,
  &#34;memory&#34;: &#34;2049008Ki&#34;,
  &#34;example.com/dongle&#34;: &#34;4&#34;,
</code></pre><p>노드의 정보를 확인한다.</p><pre tabindex=0><code>kubectl describe node &lt;your-node-name&gt;
</code></pre><p>다시 한 번, 출력에 동글 리소스가 표시된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb>  </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb>  </span>2049008Ki<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb>  </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이제, 애플리케이션 개발자는 특정 개수의 동글을 요청하는 파드를
만들 수 있다. <a href=/docs/tasks/configure-pod-container/extended-resource/>컨테이너에 확장 리소스 할당하기</a>를
참고한다.</p><h2 id=토론>토론</h2><p>확장 리소스는 메모리 및 CPU 리소스와 비슷하다. 예를 들어,
노드에서 실행 중인 모든 컴포넌트가 공유할 특정 양의 메모리와 CPU가
노드에 있는 것처럼, 노드에서 실행 중인 모든 컴포넌트가
특정 동글을 공유할 수 있다. 또한 애플리케이션 개발자가
특정 양의 메모리와 CPU를 요청하는 파드를 생성할 수 있는 것처럼, 특정
동글을 요청하는 파드를 생성할 수 있다.</p><p>확장 리소스는 쿠버네티스에게 불투명하다. 쿠버네티스는 그것들이
무엇인지 전혀 모른다. 쿠버네티스는 노드에 특정 개수의 노드만
있다는 것을 알고 있다. 확장 리소스는 정수로 알려야
한다. 예를 들어, 노드는 4.5개의 동글이 아닌, 4개의 동글을 알릴 수 있다.</p><h3 id=스토리지-예제>스토리지 예제</h3><p>노드에 800GiB의 특별한 종류의 디스크 스토리지가 있다고 가정한다.
example.com/special-storage와 같은 특별한 스토리지의 이름을 생성할 수 있다.
그런 다음 특정 크기, 100GiB의 청크로 알릴 수 있다. 이 경우,
노드에는 example.com/special-storage 유형의 8가지 리소스가 있다고
알린다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/special-storage</span>:<span style=color:#bbb> </span><span style=color:#666>8</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이 특별한 스토리지에 대한 임의 요청을 허용하려면,
1바이트 크기의 청크로 특별한 스토리지를 알릴 수 있다. 이 경우, example.com/special-storage 유형의
800Gi 리소스를 알린다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/special-storage</span>:<span style=color:#bbb>  </span>800Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>그런 다음 컨테이너는 최대 800Gi의 임의 바이트 수의 특별한 스토리지를 요청할 수 있다.</p><h2 id=정리>정리</h2><p>다음은 노드에서 동글 알림을 제거하는 PATCH 요청이다.</p><pre tabindex=0><code>PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1
Accept: application/json
Content-Type: application/json-patch+json
Host: k8s-master:8080

[
  {
    &#34;op&#34;: &#34;remove&#34;,
    &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;,
  }
]
</code></pre><p>쿠버네티스 API 서버에 요청을 쉽게 보낼 수 있도록 프록시를 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy
</span></span></code></pre></div><p>다른 명령 창에서 HTTP PATCH 요청을 보낸다.
<code>&lt;your-node-name></code>을 노드의 이름으로 바꾼다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status
</span></span></code></pre></div><p>동글 알림이 제거되었는지 확인한다.</p><pre tabindex=0><code>kubectl describe node &lt;your-node-name&gt; | grep dongle
</code></pre><p>(출력이 보이지 않아야 함)</p><h2 id=다음-내용>다음 내용</h2><h3 id=애플리케이션-개발자를-위한-문서>애플리케이션 개발자를 위한 문서</h3><ul><li><a href=/docs/tasks/configure-pod-container/extended-resource/>컨테이너에 확장 리소스 할당하기</a></li></ul><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 제약 조건 구성</a></li><li><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e1afcdac8d5e8458274b3c481c5ebcda>3.11 - 서비스 디스커버리를 위해 CoreDNS 사용하기</h1><p>이 페이지는 CoreDNS 업그레이드 프로세스와 kube-dns 대신 CoreDNS를 설치하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.9.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=coredns-소개>CoreDNS 소개</h2><p><a href=https://coredns.io>CoreDNS</a>는 쿠버네티스 클러스터의 DNS 역할을 수행할 수 있는,
유연하고 확장 가능한 DNS 서버이다.
쿠버네티스와 동일하게, CoreDNS 프로젝트도
<a class=glossary-tooltip title='클라우드 네이티브 컴퓨팅 재단' data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a>가 관리한다.</p><p>사용자는 기존 디플로이먼트인 kube-dns를 교체하거나,
클러스터를 배포하고 업그레이드하는 kubeadm과 같은 툴을 사용하여
클러스터 안의 kube-dns 대신 CoreDNS를 사용할 수 있다.</p><h2 id=coredns-설치>CoreDNS 설치</h2><p>Kube-dns의 배포나 교체에 관한 매뉴얼은 <a href=https://github.com/coredns/deployment/tree/master/kubernetes>CoreDNS GitHub 프로젝트</a>에
있는 문서를 확인하자.</p><h2 id=coredns로-이관하기>CoreDNS로 이관하기</h2><h3 id=kubeadm을-사용해-기존-클러스터-업그레이드하기>Kubeadm을 사용해 기존 클러스터 업그레이드하기</h3><p>쿠버네티스 버전 1.21에서, kubeadm은 DNS 애플리케이션으로서의 <code>kube-dns</code> 지원을 제거했다.
<code>kubeadm</code> v1.25 버전에서는,
DNS 애플리케이션으로 CoreDNS만이 지원된다.</p><p><code>kube-dns</code>를 사용 중인 클러스터를 업그레이드하기 위하여
<code>kubeadm</code> 을 사용할 때 CoreDNS로 전환할 수 있다.
이 경우, <code>kubeadm</code> 은 <code>kube-dns</code> 컨피그맵(ConfigMap)을 기반으로
스텁 도메인(stub domain), 업스트림 네임 서버의 설정을 유지하며 CoreDNS 설정("Corefile")을 생성한다.</p><h2 id=coredns-업그레이드하기>CoreDNS 업그레이드하기</h2><p><a href=https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md>쿠버네티스에서의 CoreDNS 버전</a> 페이지에서,
쿠버네티스 각 버전에 대해 kubeadm이 설치하는
CoreDNS의 버전을 확인할 수 있다.</p><p>CoreDNS만 업그레이드하고 싶거나 커스텀 이미지를 사용하고 싶은 경우,
CoreDNS를 수동으로 업그레이드할 수 있다.
<a href=https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md>가이드라인 및 따라해보기</a>를 참고하여
부드러운 업그레이드를 수행할 수 있다.
클러스터를 업그레이드할 때
기존 CoreDNS 환경 설정("Corefile")을 보존했는지 확인한다.</p><p><code>kubeadm</code> 도구를 사용하여 클러스터를 업그레이드하는 경우,
<code>kubeadm</code>이 자동으로 기존 CoreDNS 환경 설정을 보존한다.</p><h2 id=coredns-튜닝하기>CoreDNS 튜닝하기</h2><p>리소스 활용이 중요한 경우,
CoreDNS 구성을 조정하는 것이 유용할 수 있다.
더 자세한 내용은 <a href=https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md>CoreDNS 스케일링에 대한 설명서</a>를 확인한다.</p><h2 id=다음-내용>다음 내용</h2><p>CoreDNS 환경 설정("Corefile")을 수정하여
kube-dns보다 더 많은 유스케이스를 지원하도록 <a href=https://coredns.io>CoreDNS</a>를 구성할 수 있다.
더 많은 정보는 CoreDNS의 <code>kubernetes</code> 플러그인
<a href=https://coredns.io/plugins/kubernetes/>문서</a>를 참고하거나,
CoreDNS 블로그의
<a href=https://coredns.io/2017/05/08/custom-dns-entries-for-kubernetes/>쿠버네티스를 위한 커스텀 DNS 엔트리</a>를 확인한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a02f35804917d7a269c38d7e2c475005>3.12 - 스토리지 사용량 제한</h1><p>이 예제는 네임스페이스(namespace)에서 사용되는 스토리지의 용량을 제한하는 방법을 보여준다.</p><p>예제에서는 다음과 같은 리소스가 사용된다. <a href=/ko/docs/concepts/policy/resource-quotas/>리소스쿼터(ResourceQuota)</a>,
<a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>리밋레인지(LimitRange)</a>,
그리고 <a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트볼륨클레임(PersistentVolumeClaim)</a>.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</li></ul><h2 id=시나리오-스토리지-사용량-제한하기>시나리오: 스토리지 사용량 제한하기</h2><p>클러스터 관리자는 사용자를 대표하여 클러스터를 운영하고
, 비용을 제어하기 위해 단일 네임스페이스에서 사용할 수 있는 스토리지의 크기를 제어하려고 한다.</p><p>관리자는 다음을 제한하려고 한다.</p><ol><li>네임스페이스에 있는 퍼시스턴트볼륨클레임의 수</li><li>각 클레임(claim)이 요청할 수 있는 스토리지의 용량</li><li>네임스페이스가 가질 수 있는 누적 스토리지 용량</li></ol><h2 id=스토리지-요청을-제한하기-위한-리밋레인지-limitrange>스토리지 요청을 제한하기 위한 리밋레인지(LimitRange)</h2><p>네임스페이스에 <code>리밋레인지(LimitRange)</code>을 추가하면 스토리지 요청 크기가 최소 및 최대값으로 설정된다.
스토리지는 퍼시스턴트 볼륨 클레임(Persistent Volume Claim)을 통해 요청하게 된다.
제한 범위를 적용하는 어드미션 컨트롤러(Admission Controller)는 관리자가 설정한 값보다 높거나 낮은 PVC를 거부한다.</p><p>이 예제에서, 10Gi의 스토리지를 요청하는 PVC는 2Gi인 최대값을 초과하기 때문에 거부된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>storagelimits<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>2Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>스토리지 요청에 대한 최솟값은 해당 스토리지의 제공자가 최소값을 특정하여 요구하는 경우 사용한다.
예를 들어, AWS EBS 볼륨을 사용할 때는 최소 1Gi를 요청해야 한다.</p><h2 id=pvc-수와-누적-스토리지-용량을-제한하는-스토리지쿼터-storagequota>PVC 수와 누적 스토리지 용량을 제한하는 스토리지쿼터(StorageQuota)</h2><p>관리자는 네임스페이스의 PVC 수와 해당 PVC의 누적 용량을 제한할 수 있다.
최대값을 초과하는 새 PVC는 거부된다.</p><p>이 예제에서 네임스페이스의 6번째 PVC는 최대 카운트 5를 초과하기 때문에 거부된다. 또한,
위의 2Gi 최대 한계(max limit)와 결합된 5Gi 최대 할당량(maximum quota)은 각각 2Gi를 갖는 3개의 PVC를 가질 수 없다.
그것은 5Gi로 한도가 정해진 네임스페이스에 대해 6Gi의 요청이 될 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>storagequota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>persistentvolumeclaims</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests.storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5Gi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=요약>요약</h2><p>리밋레인지(LimitRange)을 지정하면 요청된 스토리지 양을 제한할 수 있으며
리소스쿼터(ResourceQuota)는 네임스페이스에 클레임(claim)수와 누적 스토리지 용량을 효과적으로 제한할 수 있다.
클러스터 관리자는 어느 프로젝트도 할당량을 초과하는 위험이 없도록 클러스터의 스토리지 예산을 계획할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4a02bcca41439e16655f43fa37c81da4>3.13 - 중요한 애드온 파드 스케줄링 보장하기</h1><p>API 서버, 스케줄러 및 컨트롤러 매니저와 같은 쿠버네티스 주요 컴포넌트들은 컨트롤 플레인 노드에서 동작한다. 반면, 애드온들은 일반 클러스터 노드에서 동작한다.
이러한 애드온들 중 일부(예: 메트릭 서버, DNS, UI)는 클러스터 전부가 정상적으로 동작하는 데 필수적일 수 있다.
만약, 필수 애드온이 축출되고(수동 축출, 혹은 업그레이드와 같은 동작으로 인한 의도하지 않은 축출)
pending 상태가 된다면, 클러스터가 더 이상 제대로 동작하지 않을 수 있다. (사용률이 매우 높은 클러스터에서 해당 애드온이
축출되자마자 다른 대기중인 파드가 스케줄링되거나 다른 이유로 노드에서 사용할 수 있는 자원량이 줄어들어 pending 상태가 발생할 수 있다)</p><p>유의할 점은, 파드를 중요(critical)로 표시하는 것은 축출을 완전히 방지하기 위함이 아니다. 이것은 단지 파드가 영구적으로 사용할 수 없게 되는 것만을 방지하기 위함이다.
중요로 표시한 스태틱(static) 파드는 축출될 수 없다. 반면, 중요로 표시한 일반적인(non-static) 파드의 경우 항상 다시 스케줄링된다.</p><h3 id=파드를-중요-critical-로-표시하기>파드를 중요(critical)로 표시하기</h3><p>파드를 중요로 표시하기 위해서는, 해당 파드에 대해 priorityClassName을 <code>system-cluster-critical</code>이나 <code>system-node-critical</code>로 설정한다. <code>system-node-critical</code>은 가장 높은 우선 순위를 가지며, 심지어 <code>system-cluster-critical</code>보다도 우선 순위가 높다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-09cc2cf3e0f23a3996e6cb31dc4d867c>3.14 - 쿠버네티스 API 활성화 혹은 비활성화하기</h1><p>이 페이지는 클러스터 <a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>의
특정한 API 버전을 활성화하거나 비활성화하는 방법에 대해 설명한다.</p><p>API 서버에 <code>--runtime-config=api/&lt;version></code> 커맨드 라인 인자를 사용함으로서 특정한 API 버전을
활성화하거나 비활성화할 수 있다. 이 인자에 대한 값으로는 콤마로 구분된 API 버전의 목록을 사용한다.
뒤쪽에 위치한 값은 앞쪽의 값보다 우선적으로 사용된다.</p><p>이 <code>runtime-config</code> 커맨드 라인 인자에는 다음의 두 개의 특수 키를 사용할 수도 있다.</p><ul><li><code>api/all</code>: 사용할 수 있는 모든 API를 선택한다.</li><li><code>api/legacy</code>: 레거시 API만을 선택한다. 여기서 레거시 API란 명시적으로
<a href=/docs/reference/using-api/deprecation-policy/>사용이 중단된</a> 모든 API를 가리킨다.</li></ul><p>예를 들어서, v1을 제외한 모든 API 버전을 비활성화하기 위해서는 <code>kube-apiserver</code>에
<code>--runtime-config=api/all=false,api/v1=true</code> 인자를 사용한다.</p><h2 id=다음-내용>다음 내용</h2><p><code>kube-apiserver</code> 컴포넌트에 대한 더 자세한 내용은 다음의 <a href=/docs/reference/command-line-tools-reference/kube-apiserver/>문서</a>
를 참고한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e77685d5b88d2db5c7631a27b9472eea>3.15 - 쿠버네티스 API를 사용하여 클러스터에 접근하기</h1><p>이 페이지는 쿠버네티스 API를 사용하여 클러스터에 접근하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=쿠버네티스-api에-접근>쿠버네티스 API에 접근</h2><h3 id=kubectl을-사용하여-처음으로-접근>kubectl을 사용하여 처음으로 접근</h3><p>쿠버네티스 API에 처음 접근하는 경우, 쿠버네티스
커맨드 라인 도구인 <code>kubectl</code> 을 사용한다.</p><p>클러스터에 접근하려면, 클러스터 위치를 알고 접근할 수 있는 자격 증명이
있어야 한다. 일반적으로, <a href=/ko/docs/setup/>시작하기 가이드</a>를
통해 작업하거나,
다른 사람이 클러스터를 설정하고 자격 증명과 위치를 제공할 때 자동으로 설정된다.</p><p>다음의 명령으로 kubectl이 알고 있는 위치와 자격 증명을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>많은 <a href=https://github.com/kubernetes/examples/tree/master/>예제</a>는 kubectl 사용에 대한 소개를
제공한다. 전체 문서는 <a href=/ko/docs/reference/kubectl/>kubectl 매뉴얼</a>에 있다.</p><h3 id=rest-api에-직접-접근>REST API에 직접 접근</h3><p>kubectl은 API 서버 찾기와 인증을 처리한다. <code>curl</code> 이나 <code>wget</code> 과 같은 http 클라이언트 또는 브라우저를 사용하여 REST API에
직접 접근하려는 경우, API 서버를 찾고 인증할 수 있는 여러 가지 방법이 있다.</p><ol><li>프록시 모드에서 kubectl을 실행한다(권장). 이 방법은 저장된 API 서버 위치를 사용하고 자체 서명된 인증서를 사용하여 API 서버의 ID를 확인하므로 권장한다. 이 방법을 사용하면 중간자(man-in-the-middle, MITM) 공격이 불가능하다.</li><li>또는, 위치와 자격 증명을 http 클라이언트에 직접 제공할 수 있다. 이 방법은 프록시를 혼란스럽게 하는 클라이언트 코드와 동작한다. 중간자 공격으로부터 보호하려면, 브라우저로 루트 인증서를 가져와야 한다.</li></ol><p>Go 또는 Python 클라이언트 라이브러리를 사용하면 프록시 모드에서 kubectl에 접근할 수 있다.</p><h4 id=kubectl-프록시-사용>kubectl 프록시 사용</h4><p>다음 명령은 kubectl을 리버스 프록시로 작동하는 모드에서 실행한다. API
서버 찾기와 인증을 처리한다.</p><p>다음과 같이 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span> &amp;
</span></span></code></pre></div><p>자세한 내용은 <a href=/docs/reference/generated/kubectl/kubectl-commands/#proxy>kubectl 프록시</a>를 참고한다.</p><p>그런 다음 curl, wget 또는 브라우저를 사용하여 API를 탐색할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://localhost:8080/api/
</span></span></code></pre></div><p>출력은 다음과 비슷하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=kubectl-프록시-없이-접근>kubectl 프록시 없이 접근</h4><p>다음과 같이 인증 토큰을 API 서버에 직접 전달하여 kubectl 프록시
사용을 피할 수 있다.</p><p><code>grep/cut</code> 방식을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># .KUBECONFIG에 여러 콘텍스트가 있을 수 있으므로, 가능한 모든 클러스터를 확인한다.</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{&#34;Cluster name\tServer\n&#34;}{range .clusters[*]}{.name}{&#34;\t&#34;}{.cluster.server}{&#34;\n&#34;}{end}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 위의 출력에서 상호 작용하려는 클러스터의 이름을 선택한다.</span>
</span></span><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>CLUSTER_NAME</span><span style=color:#666>=</span><span style=color:#b44>&#34;some_server_name&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 클러스터 이름을 참조하는 API 서버를 가리킨다.</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.clusters[?(@.name==\&#34;</span><span style=color:#b8860b>$CLUSTER_NAME</span><span style=color:#b44>\&#34;)].cluster.server}&#34;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 기본 서비스 어카운트용 토큰을 보관할 시크릿을 생성한다.</span>
</span></span><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: default-token
</span></span></span><span style=display:flex><span><span style=color:#b44>  annotations:
</span></span></span><span style=display:flex><span><span style=color:#b44>    kubernetes.io/service-account.name: default
</span></span></span><span style=display:flex><span><span style=color:#b44>type: kubernetes.io/service-account-token
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 토큰 컨트롤러가 해당 시크릿에 토큰을 기록할 때까지 기다린다.</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>while</span> ! kubectl describe secret default-token | grep -E <span style=color:#b44>&#39;^token&#39;</span> &gt;/dev/null; <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;waiting for token...&#34;</span> &gt;&amp;<span style=color:#666>2</span>
</span></span><span style=display:flex><span>  sleep <span style=color:#666>1</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 토큰 값을 얻는다</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get secret default-token -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.token}&#39;</span> | base64 --decode<span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># TOKEN으로 API 탐색</span>
</span></span><span style=display:flex><span>curl -X GET <span style=color:#b8860b>$APISERVER</span>/api --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b8860b>$TOKEN</span><span style=color:#b44>&#34;</span> --insecure
</span></span></code></pre></div><p>출력은 다음과 비슷하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위의 예는 <code>--insecure</code> 플래그를 사용한다. 이로 인해 MITM 공격이
발생할 수 있다. kubectl이 클러스터에 접근하면 저장된 루트 인증서와
클라이언트 인증서를 사용하여 서버에 접근한다. (<code>~/.kube</code> 디렉터리에
설치된다.) 클러스터 인증서는 일반적으로 자체 서명되므로,
http 클라이언트가 루트 인증서를 사용하도록 하려면 특별한 구성이
필요할 수 있다.</p><p>일부 클러스터에서, API 서버는 인증이 필요하지 않다. 로컬 호스트에서 제공되거나,
방화벽으로 보호될 수 있다. 이에 대한 표준은 없다.
<a href=/ko/docs/concepts/security/controlling-access>쿠버네티스 API에 대한 접근 제어</a>는 클러스터
관리자로서 이를 구성하는 방법에 대해 설명한다. 이러한 접근 방식은 향후 고 가용성 지원과 충돌할 수 있다.</p><h3 id=api에-프로그래밍-방식으로-접근>API에 프로그래밍 방식으로 접근</h3><p>쿠버네티스는 공식적으로 <a href=#go-client>Go</a>, <a href=#python-client>Python</a>, <a href=#java-client>Java</a>, <a href=#dotnet-client>dotnet</a>, <a href=#javascript-client>JavaScript</a> 및 <a href=#haskell-client>Haskell</a> 용 클라이언트 라이브러리를 지원한다. 쿠버네티스 팀이 아닌 작성자가 제공하고 유지 관리하는 다른 클라이언트 라이브러리가 있다. 다른 언어에서 API에 접근하고 인증하는 방법에 대해서는 <a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리</a>를 참고한다.</p><h4 id=go-client>Go 클라이언트</h4><ul><li>라이브러리를 얻으려면, 다음 명령을 실행한다. <code>go get k8s.io/client-go@kubernetes-&lt;kubernetes-version-number></code> 어떤 버전이 지원되는지를 확인하려면 <a href=https://github.com/kubernetes/client-go/releases>https://github.com/kubernetes/client-go/releases</a>를 참고한다.</li><li>client-go 클라이언트 위에 애플리케이션을 작성한다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> client-go는 자체 API 오브젝트를 정의하므로, 필요한 경우, 기본 리포지터리가 아닌 client-go에서 API 정의를 가져온다. 예를 들어, <code>import "k8s.io/client-go/kubernetes"</code> 가 맞다.</div><p>Go 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a2f;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> (
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;context&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;k8s.io/apimachinery/pkg/apis/meta/v1&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;k8s.io/client-go/kubernetes&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;k8s.io/client-go/tools/clientcmd&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// kubeconfig에서 현재 콘텍스트를 사용한다
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#080;font-style:italic>// path-to-kubeconfig -- 예를 들어, /root/.kube/config
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  config, _ <span style=color:#666>:=</span> clientcmd.<span style=color:#00a000>BuildConfigFromFlags</span>(<span style=color:#b44>&#34;&#34;</span>, <span style=color:#b44>&#34;&lt;path-to-kubeconfig&gt;&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// clientset을 생성한다
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  clientset, _ <span style=color:#666>:=</span> kubernetes.<span style=color:#00a000>NewForConfig</span>(config)
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 파드를 나열하기 위해 API에 접근한다
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  pods, _ <span style=color:#666>:=</span> clientset.<span style=color:#00a000>CoreV1</span>().<span style=color:#00a000>Pods</span>(<span style=color:#b44>&#34;&#34;</span>).<span style=color:#00a000>List</span>(context.<span style=color:#00a000>TODO</span>(), v1.ListOptions{})
</span></span><span style=display:flex><span>  fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;There are %d pods in the cluster\n&#34;</span>, <span style=color:#a2f>len</span>(pods.Items))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>애플리케이션이 클러스터 내의 파드로 배치된 경우, <a href=/ko/docs/tasks/access-application-cluster/access-cluster/#%ED%8C%8C%EB%93%9C%EC%97%90%EC%84%9C-api-%EC%A0%91%EA%B7%BC>파드 내에서 API 접근</a>을 참고한다.</p><h4 id=python-client>Python 클라이언트</h4><p><a href=https://github.com/kubernetes-client/python>Python 클라이언트</a>를 사용하려면, 다음 명령을 실행한다. <code>pip install kubernetes</code> 추가 설치 옵션은 <a href=https://github.com/kubernetes-client/python>Python Client Library 페이지</a>를 참고한다.</p><p>Python 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://github.com/kubernetes-client/python/blob/master/examples/out_of_cluster_config.py>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a2f;font-weight:700>from</span> <span style=color:#00f;font-weight:700>kubernetes</span> <span style=color:#a2f;font-weight:700>import</span> client, config
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>config<span style=color:#666>.</span>load_kube_config()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>v1<span style=color:#666>=</span>client<span style=color:#666>.</span>CoreV1Api()
</span></span><span style=display:flex><span><span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Listing pods with their IPs:&#34;</span>)
</span></span><span style=display:flex><span>ret <span style=color:#666>=</span> v1<span style=color:#666>.</span>list_pod_for_all_namespaces(watch<span style=color:#666>=</span><span style=color:#a2f;font-weight:700>False</span>)
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i <span style=color:#a2f;font-weight:700>in</span> ret<span style=color:#666>.</span>items:
</span></span><span style=display:flex><span>    <span style=color:#a2f>print</span>(<span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>%s</span><span style=color:#b62;font-weight:700>\t</span><span style=color:#b68;font-weight:700>%s</span><span style=color:#b62;font-weight:700>\t</span><span style=color:#b68;font-weight:700>%s</span><span style=color:#b44>&#34;</span> <span style=color:#666>%</span> (i<span style=color:#666>.</span>status<span style=color:#666>.</span>pod_ip, i<span style=color:#666>.</span>metadata<span style=color:#666>.</span>namespace, i<span style=color:#666>.</span>metadata<span style=color:#666>.</span>name))
</span></span></code></pre></div><h4 id=java-client>Java 클라이언트</h4><p><a href=https://github.com/kubernetes-client/java>Java 클라이언트</a>를 설치하려면, 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># java 라이브러리를 클론한다</span>
</span></span><span style=display:flex><span>git clone --recursive https://github.com/kubernetes-client/java
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 프로젝트 아티팩트, POM 등을 설치한다</span>
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> java
</span></span><span style=display:flex><span>mvn install
</span></span></code></pre></div><p>어떤 버전이 지원되는지를 확인하려면 <a href=https://github.com/kubernetes-client/java/releases>https://github.com/kubernetes-client/java/releases</a>를 참고한다.</p><p>Java 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://github.com/kubernetes-client/java/blob/master/examples/src/main/java/io/kubernetes/client/examples/KubeConfigFileClientExample.java>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>package</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.examples</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.ApiClient</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.ApiException</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.Configuration</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.apis.CoreV1Api</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.models.V1Pod</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.models.V1PodList</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.util.ClientBuilder</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>io.kubernetes.client.util.KubeConfig</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>java.io.FileReader</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>java.io.IOException</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> * 쿠버네티스 클러스터 외부의 애플리케이션에서 Java API를 사용하는 방법에 대한 간단한 예
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> * &lt;p&gt;이것을 실행하는 가장 쉬운 방법: mvn exec:java
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> * -Dexec.mainClass=&#34;io.kubernetes.client.examples.KubeConfigFileClientExample&#34;
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>class</span> <span style=color:#00f>KubeConfigFileClientExample</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>main</span><span style=color:#666>(</span>String<span style=color:#666>[]</span> args<span style=color:#666>)</span> <span style=color:#a2f;font-weight:700>throws</span> IOException<span style=color:#666>,</span> ApiException <span style=color:#666>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// KubeConfig의 파일 경로
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    String kubeConfigPath <span style=color:#666>=</span> <span style=color:#b44>&#34;~/.kube/config&#34;</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 파일시스템에서 클러스터 외부 구성인 kubeconfig 로드
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    ApiClient client <span style=color:#666>=</span>
</span></span><span style=display:flex><span>        ClientBuilder<span style=color:#666>.</span><span style=color:#b44>kubeconfig</span><span style=color:#666>(</span>KubeConfig<span style=color:#666>.</span><span style=color:#b44>loadKubeConfig</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>new</span> FileReader<span style=color:#666>(</span>kubeConfigPath<span style=color:#666>))).</span><span style=color:#b44>build</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 전역 디폴트 api-client를 위에서 정의한 클러스터 내 클라이언트로 설정
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    Configuration<span style=color:#666>.</span><span style=color:#b44>setDefaultApiClient</span><span style=color:#666>(</span>client<span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// CoreV1Api는 전역 구성에서 디폴트 api-client를 로드
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    CoreV1Api api <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> CoreV1Api<span style=color:#666>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// CoreV1Api 클라이언트를 호출한다
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    V1PodList list <span style=color:#666>=</span> api<span style=color:#666>.</span><span style=color:#b44>listPodForAllNamespaces</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;Listing all pods: &#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> <span style=color:#666>(</span>V1Pod item <span style=color:#666>:</span> list<span style=color:#666>.</span><span style=color:#b44>getItems</span><span style=color:#666>())</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>      System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span>item<span style=color:#666>.</span><span style=color:#b44>getMetadata</span><span style=color:#666>().</span><span style=color:#b44>getName</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h4 id=dotnet-client>dotnet 클라이언트</h4><p><a href=https://github.com/kubernetes-client/csharp>dotnet 클라이언트</a>를 사용하려면, 다음 명령을 실행한다. <code>dotnet add package KubernetesClient --version 1.6.1</code> 추가 설치 옵션은 <a href=https://github.com/kubernetes-client/csharp>dotnet Client Library 페이지</a>를 참고한다. 어떤 버전이 지원되는지를 확인하려면 <a href=https://github.com/kubernetes-client/csharp/releases>https://github.com/kubernetes-client/csharp/releases</a>를 참고한다.</p><p>dotnet 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://github.com/kubernetes-client/csharp/blob/master/examples/simple/PodList.cs>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a2f;font-weight:700>using</span> <span style=color:#00f;font-weight:700>System</span>;
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>using</span> <span style=color:#00f;font-weight:700>k8s</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>namespace</span> <span style=color:#00f;font-weight:700>simple</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>internal</span> <span style=color:#a2f;font-weight:700>class</span> <span style=color:#00f>PodList</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>private</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#a2f;font-weight:700>void</span> Main(<span style=color:#0b0;font-weight:700>string</span>[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#0b0;font-weight:700>var</span> config = KubernetesClientConfiguration.BuildDefaultConfig();
</span></span><span style=display:flex><span>            IKubernetes client = <span style=color:#a2f;font-weight:700>new</span> Kubernetes(config);
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#b44>&#34;Starting Request!&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#0b0;font-weight:700>var</span> list = client.ListNamespacedPod(<span style=color:#b44>&#34;default&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>foreach</span> (<span style=color:#0b0;font-weight:700>var</span> item <span style=color:#a2f;font-weight:700>in</span> list.Items)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(item.Metadata.Name);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> (list.Items.Count == <span style=color:#666>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#b44>&#34;Empty!&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=javascript-client>JavaScript 클라이언트</h4><p><a href=https://github.com/kubernetes-client/javascript>JavaScript 클라이언트</a>를 설치하려면, 다음 명령을 실행한다. <code>npm install @kubernetes/client-node</code> 어떤 버전이 지원되는지를 확인하려면 <a href=https://github.com/kubernetes-client/javascript/releases>https://github.com/kubernetes-client/javascript/releases</a>를 참고한다.</p><p>JavaScript 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://github.com/kubernetes-client/javascript/blob/master/examples/example.js>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> k8s <span style=color:#666>=</span> require(<span style=color:#b44>&#39;@kubernetes/client-node&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> kc <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> k8s.KubeConfig();
</span></span><span style=display:flex><span>kc.loadFromDefault();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> k8sApi <span style=color:#666>=</span> kc.makeApiClient(k8s.CoreV1Api);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>k8sApi.listNamespacedPod(<span style=color:#b44>&#39;default&#39;</span>).then((res) =&gt; {
</span></span><span style=display:flex><span>    console.log(res.body);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h4 id=haskell-client>Haskell 클라이언트</h4><p>어떤 버전이 지원되는지를 확인하려면 <a href=https://github.com/kubernetes-client/haskell/releases>https://github.com/kubernetes-client/haskell/releases</a>를 참고한다.</p><p>Haskell 클라이언트는 kubectl CLI가 API 서버를 찾아 인증하기 위해 사용하는 것과 동일한 <a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig 파일</a>을
사용할 수 있다. 이 <a href=https://github.com/kubernetes-client/haskell/blob/master/kubernetes-client/example/App.hs>예제</a>를 참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#00a000>exampleWithKubeConfig</span> <span style=color:#a2f;font-weight:700>::</span> <span style=color:#0b0;font-weight:700>IO</span> <span style=color:#a2f>()</span>
</span></span><span style=display:flex><span><span style=color:#00a000>exampleWithKubeConfig</span> <span style=color:#a2f;font-weight:700>=</span> <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>    oidcCache <span style=color:#a2f;font-weight:700>&lt;-</span> atomically <span style=color:#666>$</span> newTVar <span style=color:#666>$</span> <span style=color:#0b0;font-weight:700>Map</span><span style=color:#666>.</span>fromList <span style=color:#0b0;font-weight:700>[]</span>
</span></span><span style=display:flex><span>    (mgr, kcfg) <span style=color:#a2f;font-weight:700>&lt;-</span> mkKubeClientConfig oidcCache <span style=color:#666>$</span> <span style=color:#0b0;font-weight:700>KubeConfigFile</span> <span style=color:#b44>&#34;/path/to/kubeconfig&#34;</span>
</span></span><span style=display:flex><span>    dispatchMime
</span></span><span style=display:flex><span>            mgr
</span></span><span style=display:flex><span>            kcfg
</span></span><span style=display:flex><span>            (<span style=color:#0b0;font-weight:700>CoreV1</span><span style=color:#666>.</span>listPodForAllNamespaces (<span style=color:#0b0;font-weight:700>Accept</span> <span style=color:#0b0;font-weight:700>MimeJSON</span>))
</span></span><span style=display:flex><span>        <span style=color:#666>&gt;&gt;=</span> print
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/run-application/access-api-from-pod/>파드 내에서 쿠버네티스 API에 접근</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fe5ad73163d38596340536ec03a205f0>3.16 - 쿠버네티스 클러스터에서 sysctl 사용하기</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [stable]</code></div><p>이 문서는 쿠버네티스 클러스터에서 <a class=glossary-tooltip title='유닉스 커널 파라미터를 가져오거나 설정하는 데 사용하는 인터페이스' data-toggle=tooltip data-placement=top href=/ko/docs/tasks/administer-cluster/sysctl-cluster/ target=_blank aria-label=sysctl>sysctl</a> 인터페이스를 사용하여
커널 파라미터를 어떻게 구성하고, 사용하는지를
설명한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 쿠버네티스 버전 1.23부터, kubelet은 <code>/</code> 또는 <code>.</code>를
sysctl 이름의 구분자로 사용하는 것을 지원한다.
쿠버네티스 1.25 버전부터, 파드에 대해서도 sysctl을 설정할 때 슬래시 구분자를 지원하기 시작하였다.
예를 들어, 동일한 sysctl 이름을 <code>kernel.shm_rmid_forced</code>와 같이 마침표를 구분자로 사용하여 나타내거나
<code>kernel/shm_rmid_forced</code>와 같이 슬래시를 구분자로 사용하여 나타낼 수 있다.
sysctl 파라미터 변환에 대한 세부 사항은
리눅스 맨페이지 프로젝트의
<a href=https://man7.org/linux/man-pages/man5/sysctl.d.5.html>sysctl.d(5)</a> 페이지를 참고한다.</div><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>일부 단계에서는 실행 중인 클러스터의 kubelet에서
커맨드 라인 옵션을 재구성할 필요가 있다.</p><h2 id=모든-sysctl-파라미터-나열>모든 sysctl 파라미터 나열</h2><p>리눅스에서 sysctl 인터페이스는 관리자들이 런타임에 커널 파라미터를 수정할 수 있도록
허용한다. 파라미터는 <code>/proc/sys</code> 가상 파일 시스템을 통해 이용할 수 있다. 파라미터는
다음과 같은 다양한 서브 시스템을 포함한다.</p><ul><li>커널 (공통 접두사: <code>kernel.</code>)</li><li>네트워크 (공통 접두사: <code>net.</code>)</li><li>가상 메모리 (공통 접두사: <code>vm.</code>)</li><li>MDADM (공통 접두사: <code>dev.</code>)</li><li>더 많은 서브 시스템은 <a href=https://www.kernel.org/doc/Documentation/sysctl/README>커널 문서</a>에 설명되어 있다.</li></ul><p>모든 파라미터 리스트를 가져오려면 다음 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo sysctl -a
</span></span></code></pre></div><h2 id=unsafe-sysctl-활성화하기>unsafe sysctl 활성화하기</h2><p>sysctl은 <em>safe</em> sysctl과 <em>unsafe</em> sysctl로 구성되어 있다. <em>safe</em> sysctl은
적절한 네임스페이스 뿐만 아니라 동일한 노드의 파드 사이에 <em>고립</em> 되어야 한다. 즉, 하나의
파드에 <em>safe</em> sysctl을 설정한다는 것은 다음을 의미한다.</p><ul><li>노드의 다른 파드에 영향을 미치지 않아야 한다</li><li>노드의 상태를 손상시키지 않아야 한다</li><li>CPU 또는 메모리 리소스가 파드의 리소스 제한에 벗어나는 것을
허용하지 않아야 한다</li></ul><p>아직까지 대부분 <em>네임스페이스된</em> sysctl은 <em>safe</em> sysctl로 고려되지 않았다.
다음 sysctl은 <em>safe</em> 명령을 지원한다.</p><ul><li><code>kernel.shm_rmid_forced</code>,</li><li><code>net.ipv4.ip_local_port_range</code>,</li><li><code>net.ipv4.tcp_syncookies</code>,</li><li><code>net.ipv4.ping_group_range</code> (쿠버네티스 1.18 이후),</li><li><code>net.ipv4.ip_unprivileged_port_start</code> (쿠버네티스 1.22 이후).</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>net.ipv4.tcp_syncookies</code> 예시는 리눅스 커널 버전 4.4 또는 이하에서 네임스페이스되지 않는다.</div><p>kubelet이 더 고립된 방법을 지원하면 추후 쿠버네티스 버전에서
확장될 것이다.</p><p>모든 <em>safe</em> sysctl은 기본적으로 활성화된다.</p><p>모든 <em>unsafe</em> sysctl은 기본적으로 비활성화되고, 노드별 기본 클러스터 관리자에
의해 수동으로 메뉴얼로 허용되어야 한다.
unsafe sysctl이 비활성화된 파드는 스케줄링되지만, 시작에 실패한다.</p><p>위의 경고를 염두에 두고 클러스터 관리자는
고성능 또는 실시간 애플리케이션 조정과 같은
매우 특수한 상황에 대해 특정 <em>unsafe</em> sysctl을 허용할 수 있다. <em>unsafe</em> sysctl은
kubelet 플래그를 사용하여 노드별로 활성화된다. 예를 들면, 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubelet --allowed-unsafe-sysctls <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#b44>&#39;kernel.msg*,net.core.somaxconn&#39;</span> ...
</span></span></code></pre></div><p><a class=glossary-tooltip title='로컬에서 쿠버네티스를 실행하기 위한 도구.' data-toggle=tooltip data-placement=top href=/ko/docs/tasks/tools/#minikube target=_blank aria-label=Minikube>Minikube</a>의 경우, <code>extra-config</code> 플래그를 통해 이 작업을 수행할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start --extra-config<span style=color:#666>=</span><span style=color:#b44>&#34;kubelet.allowed-unsafe-sysctls=kernel.msg*,net.core.somaxconn&#34;</span>...
</span></span></code></pre></div><p><em>네임스페이스</em> sysctl만 이 방법을 사용할 수 있다.</p><h2 id=파드에-대한-sysctl-설정>파드에 대한 sysctl 설정</h2><p>수많은 sysctl은 최근 리눅스 커널에서 <em>네임스페이스</em> 되어 있다. 이는 노드의 각 파드에
대해 개별적으로 설정할 수 있다는 것이다. 쿠버네티스의 파드 securityContext를 통해
네임스페이스 sysctl만 구성할 수 있다.</p><p>다음 sysctls는 네임스페이스로 알려져 있다.
이 목록은 이후 버전의 Linux 커널에서 변경될 수 있다.</p><ul><li><code>kernel.shm*</code>,</li><li><code>kernel.msg*</code>,</li><li><code>kernel.sem</code>,</li><li><code>fs.mqueue.*</code>,</li><li><code>net.*</code> 아래의 파라미터는 컨테이너 네트워킹 네임스페이스에서 설정할 수 있다.
그러나 예외가 존재한다. (예, <code>net.netfilter.nf_conntrack_max</code>와 <code>net.netfilter.nf_conntrack_expect_max</code>는
컨테이너 네트워킹 네임스페이스에서 설정되지만,
네임스페이스가 없다.)</li></ul><p>네임스페이스가 없는 sysctl은 <em>node-level</em> sysctl이라고 부른다.
이를 설정해야 한다면, 각 노드의 OS에서 수동으로 구성하거나
특권있는 컨테이너의 데몬셋을 사용하여야 한다.</p><p>네임스페이스 sysctl을 구성하기 위해서 파드 securityContext를 사용한다.
securityContext는 동일한 파드의 모든 컨테이너에 적용된다.</p><p>이 예시는 safe sysctl <code>kernel.shm_rmid_forced</code>와 두 개의 unsafe sysctl인
<code>net.core.somaxconn</code> 과 <code>kernel.msgmax</code> 를 설정하기 위해 파드 securityContext를 사용한다.
스펙에 따르면 <em>safe</em> sysctl과 <em>unsafe</em> sysctl 간
차이는 없다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 파라미터의 영향을 파악한 후에만 운영체제가
불안정해지지 않도록 sysctl 파라미터를 수정한다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sysctl-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>sysctls</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kernel.shm_rmid_forced<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>net.core.somaxconn<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1024&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kernel.msgmax<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;65536&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> _unsafe_의 특성으로 인해 _unsafe_sysctl는 위험 부담이 있으며
컨테이너의 잘못된 동작, 리소스 부족 혹은 노드 완전 파손과 같은
심각한 문제를 초래할 수 있다.</div><p>특별한 sysctl 설정이 있는 노드를 클러스터 내에서 _tainted_로 간주하고
sysctl 설정이 필요한 노드에만 파드를 예약하는 것이 좋다.
이를 구현하려면 쿠버네티스 <a href=/docs/reference/generated/kubectl/kubectl-commands/#taint><em>테인트(taint)와 톨러레이션(toleration)</em> 기능</a> 을
사용하는 것이 좋다.</p><p>두 <em>unsafe</em> sysctl을 명시적으로 활성화하지 않은 노드에서 <em>unsafe</em> sysctl을 사용하는
파드가 시작되지 않는다. <em>node-level</em> sysctl과 마찬가지로
<a href=/docs/reference/generated/kubectl/kubectl-commands/#taint><em>테인트와 톨러레이션</em> 특징</a> 또는
<a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>노드 테인트</a>를
사용하여 해당 파드를 오른쪽 노드에
스케줄하는 것을 추천한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-fe6b50655c29ab0b7c1ee549ff64c138>3.17 - 클러스터 업그레이드</h1><p>이 페이지는 쿠버네티스 클러스터를 업그레이드하기 위해 따라야 할 단계에 대한
개요를 제공한다.</p><p>클러스터를 업그레이드하는 방법은 초기 배포 방법에 의존적이며,
배포 이후 관련된 변경 사항에도 의존적일 수 있다.</p><p>고수준으로 살펴 본, 수행 단계</p><ul><li><a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a> 업그레이드하기</li><li>클러스터 내부의 노드를 업그레이드하기</li><li><a class=glossary-tooltip title='쿠버네티스 클러스터와 통신하기 위한 커맨드라인 툴.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>과 같은 클라이언트 업그레이드하기</li><li>새로운 쿠버네티스 버전에 동반되는 API 변화에 기반하여, 매니페스트 또는
다른 리소스를 조정하기</li></ul><h2 id=시작하기-전에>시작하기 전에</h2><p>기존 클러스터가 존재해야 한다. 이 페이지는 쿠버네티스 1.24에서
쿠버네티스 1.25로 업그레이드하는 것에 관해 다룬다.
클러스터에서 쿠버네티스 1.24을 실행하지 않는 경우
업그레이드하려는 쿠버네티스 버전에 대한 설명서를 참고한다.</p><h2 id=업그레이드-방법>업그레이드 방법</h2><h3 id=upgrade-kubeadm>kubeadm</h3><p>클러스터가 <code>kubeadm</code> 도구를 사용하여 배포된 경우
클러스터 업그레이드 방법에 대한 자세한 내용은
<a href=/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadm 클러스터 업그레이드</a>를 참조한다.</p><p>클러스터를 업그레이드한 후에는
<a href=/ko/docs/tasks/tools/><code>kubectl</code> 최신 버전을 설치</a>해야 한다.</p><h3 id=수동-배포>수동 배포</h3><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 이 단계는 네트워크 및 스토리지 플러그인과 같은
타사 확장을 고려하지 않는다.</div><p>다음 순서에 따라 컨트롤 플레인을 수동으로 업데이트해야 한다.</p><ul><li>etcd (모든 인스턴스)</li><li>kube-apiserver (모든 컨트롤 플레인 호스트)</li><li>kube-controller-manager</li><li>kube-scheduler</li><li>cloud controller manager (사용하는 경우)</li></ul><p>이 때 <a href=/ko/docs/tasks/tools/><code>kubectl</code> 최신 버전을 설치</a>
해야 한다.</p><p>클러스터의 각 노드에 대해 해당 노드를 <a href=/docs/tasks/administer-cluster/safely-drain-node/>드레인(drain)</a>
한 다음 1.25 kubelet을 사용하는 새 노드로 바꾸거나
해당 노드의 kubelet을 업그레이드하고 노드를 다시 가동한다.</p><h3 id=upgrade-other>다른 방식의 배포</h3><p>사용한 클러스터 배포 도구에 따라 해당 배포 도구가
제공하는 문서를 통하여, 유지 관리를 위해 권장되는 설정 단계를 확인한다.</p><h2 id=업그레이드-후-작업>업그레이드 후 작업</h2><h3 id=클러스터의-스토리지-api-버전-전환>클러스터의 스토리지 API 버전 전환</h3><p>클러스터에서 활성화된 쿠버네티스 리소스를
클러스터 내부적으로 표현(representation)하기 위해서 etcd로 직렬화된 객체는
특정 버전의 API를 사용하여 작성된다.</p><p>지원되는 API가 변경되면 이러한 개체를 새 API에서 다시 작성해야 할 수 있다.
이렇게 하지 않으면 결국 더 이상 디코딩할 수 없거나
쿠버네티스 API 서버에서 사용할 수 없는 리소스가 된다.</p><p>영향을 받는 각 객체를 지원되는 최신 API를 사용하여
가져온(fetch) 다음, 해당 API를 사용하여 다시 쓴다.</p><h3 id=매니페스트-업그레이드>매니페스트 업그레이드</h3><p>새로운 쿠버네티스 버전으로 업그레이드하면 새로운 API를 제공할 수 있다.</p><p><code>kubectl convert</code> 명령을 사용하여 서로 다른 API 버전 간에 매니페스트를 변환할 수 있다.
예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl convert -f pod.yaml --output-version v1
</span></span></code></pre></div><p><code>kubectl</code> 도구는 <code>pod.yaml</code>의 내용을 <code>kind</code>를 파드(변경되지 않음, unchanged)로 설정하는 매니페스트로 대체하고, 수정된 <code>apiVersion</code>으로 대체한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4e9de5bc3973e5d2bb8f09ff940c3319>3.18 - 클러스터에서 캐스케이딩 삭제 사용</h1><p>이 페이지에서는 <a class=glossary-tooltip title='쿠버네티스가 클러스터 자원을 정리하기 위해 사용하는 다양한 방법을 종합한 용어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/garbage-collection/ target=_blank aria-label='가비지 수집'>가비지 수집</a> 중
클러스터에서 사용할 <a href=/ko/docs/concepts/architecture/garbage-collection/#cascading-deletion>캐스케이딩 삭제</a>
타입을 지정하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>또한 다양한 타입들의 캐스케이딩 삭제를 실험하려면
<a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/#nginx-%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B3%A0-%ED%83%90%EC%83%89%ED%95%98%EA%B8%B0>샘플 디플로이먼트를 생성</a>할 필요가 있다. 각 타입에 대해 디플로이먼트를
다시 생성해야 할 수도 있다.</p><h2 id=파드에서-소유자-참조-확인>파드에서 소유자 참조 확인</h2><p>파드에서 <code>ownerReferences</code> 필드가 존재하는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력은 다음과 같이 <code>ownerReferences</code> 필드를 가진다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ownerReferences</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>blockOwnerDeletion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment-6b474476c4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>4fdcd81c-bd5d-41f7-97af-3a3b759af9a7<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=use-foreground-cascading-deletion>포그라운드(foreground) 캐스케이딩 삭제 사용</h2><p>기본적으로 쿠버네티스는 종속 오브젝트를 삭제하기 위해서
<a href=/ko/docs/concepts/architecture/garbage-collection/#background-deletion>백그라운드 캐스케이딩 삭제</a>를 사용한다. 클러스터를 실행하는 쿠버네티스 버전에 따라
<code>kubectl</code> 또는 쿠버네티스 API를 사용해
포그라운드 캐스케이딩 삭제로 전환할 수 있다.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><ul class="nav nav-tabs" id=foreground-deletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#foreground-deletion-0 role=tab aria-controls=foreground-deletion-0 aria-selected=true>쿠버네티스 1.20.x 이후 버전</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#foreground-deletion-1 role=tab aria-controls=foreground-deletion-1>쿠버네티스 1.20.x 전 버전</a></li></ul><div class=tab-content id=foreground-deletion><div id=foreground-deletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=foreground-deletion-0><p><p><code>kubectl</code> 또는 쿠버네티스 API를 사용해
포그라운드 캐스케이딩 삭제로 오브젝트들을 삭제할 수 있다.</p><p><strong>kubectl 사용</strong></p><p>다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>foreground
</span></span></code></pre></div><p><strong>쿠버네티스 API 사용</strong></p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력에는 다음과 같이
<code>foregroundDeletion</code> <a class=glossary-tooltip title='쿠버네티스가 오브젝트를 완전히 삭제하기 이전, 삭제 표시를 위해 특정 조건이 충족될 때까지 대기하도록 알려주기 위한 네임스페이스에 속한 키(namespaced key)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=파이널라이저(finalizer)>파이널라이저(finalizer)</a>가 포함되어 있다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Deployment&#34;,
&#34;apiVersion&#34;: &#34;apps/v1&#34;,
&#34;metadata&#34;: {
    &#34;name&#34;: &#34;nginx-deployment&#34;,
    &#34;namespace&#34;: &#34;default&#34;,
    &#34;uid&#34;: &#34;d1ce1b02-cae8-4288-8a53-30e84d8fa505&#34;,
    &#34;resourceVersion&#34;: &#34;1363097&#34;,
    &#34;creationTimestamp&#34;: &#34;2021-07-08T20:24:37Z&#34;,
    &#34;deletionTimestamp&#34;: &#34;2021-07-08T20:27:39Z&#34;,
    &#34;finalizers&#34;: [
      &#34;foregroundDeletion&#34;
    ]
    ...
</code></pre></li></ol></div><div id=foreground-deletion-1 class=tab-pane role=tabpanel aria-labelledby=foreground-deletion-1><p><p>쿠버네티스 API를 사용해
포그라운드 캐스케이딩 삭제로 오브젝트들을 삭제할 수 있다.</p><p>상세한 내용은 <a href=/ko/docs/home/supported-doc-versions/>쿠버네티스 버전에 따른 문서</a>를 참고한다.</p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력에는 다음과 같이
<code>foregroundDeletion</code> <a class=glossary-tooltip title='쿠버네티스가 오브젝트를 완전히 삭제하기 이전, 삭제 표시를 위해 특정 조건이 충족될 때까지 대기하도록 알려주기 위한 네임스페이스에 속한 키(namespaced key)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=파이널라이저(finalizer)>파이널라이저(finalizer)</a>가 포함되어 있다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Deployment&#34;,
&#34;apiVersion&#34;: &#34;apps/v1&#34;,
&#34;metadata&#34;: {
    &#34;name&#34;: &#34;nginx-deployment&#34;,
    &#34;namespace&#34;: &#34;default&#34;,
    &#34;uid&#34;: &#34;d1ce1b02-cae8-4288-8a53-30e84d8fa505&#34;,
    &#34;resourceVersion&#34;: &#34;1363097&#34;,
    &#34;creationTimestamp&#34;: &#34;2021-07-08T20:24:37Z&#34;,
    &#34;deletionTimestamp&#34;: &#34;2021-07-08T20:27:39Z&#34;,
    &#34;finalizers&#34;: [
      &#34;foregroundDeletion&#34;
    ]
    ...
</code></pre></li></ol></div></div><h2 id=use-background-cascading-deletion>백그라운드 캐스케이딩 삭제 사용</h2><ol><li><a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/#nginx-%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B3%A0-%ED%83%90%EC%83%89%ED%95%98%EA%B8%B0>샘플 디플로이먼트를 생성한다</a>.</li><li>클러스터를 실행하는 쿠버네티스 버전에 따라
디플로이먼트를 삭제하기 위해 <code>kubectl</code> 또는 쿠버네티스 API를 사용한다.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</li></ol><ul class="nav nav-tabs" id=background-deletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#background-deletion-0 role=tab aria-controls=background-deletion-0 aria-selected=true>쿠버네티스 1.20.x 이후 버전</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#background-deletion-1 role=tab aria-controls=background-deletion-1>쿠버네티스 1.20.x 전 버전</a></li></ul><div class=tab-content id=background-deletion><div id=background-deletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=background-deletion-0><p><p><code>kubectl</code> 또는 쿠버네티스 API를 사용해
백그라운드 캐스케이딩 삭제로 오브젝트들을 삭제할 수 있다.</p><p>쿠버네티스는 기본적으로 백그라운드 캐스케이딩 삭제를 사용하므로, <code>--cascade</code> 플래그
또는 <code>propagationPolicy</code> 인수 없이
다음 명령을 실행해도 같은 작업을 수행한다.</p><p><strong>kubectl 사용</strong></p><p>다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>background
</span></span></code></pre></div><p><strong>쿠버네티스 API 사용</strong></p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Background&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Status&#34;,
&#34;apiVersion&#34;: &#34;v1&#34;,
...
&#34;status&#34;: &#34;Success&#34;,
&#34;details&#34;: {
    &#34;name&#34;: &#34;nginx-deployment&#34;,
    &#34;group&#34;: &#34;apps&#34;,
    &#34;kind&#34;: &#34;deployments&#34;,
    &#34;uid&#34;: &#34;cc9eefb9-2d49-4445-b1c1-d261c9396456&#34;
}
</code></pre></li></ol></div><div id=background-deletion-1 class=tab-pane role=tabpanel aria-labelledby=background-deletion-1><p><p>쿠버네티스는 기본적으로 백그라운드 캐스케이딩 삭제를 사용하므로, <code>--cascade</code> 플래그
또는 <code>propagationPolicy: Background</code> 인수 없이
다음 명령을 실행해도 같은 작업을 수행한다.</p><p>상세한 내용은 <a href=/ko/docs/home/supported-doc-versions/>쿠버네티스 버전에 따른 문서</a>를 참고한다.</p><p><strong>kubectl 사용</strong></p><p>다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span></code></pre></div><p><strong>쿠버네티스 API 사용</strong></p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Background&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Status&#34;,
&#34;apiVersion&#34;: &#34;v1&#34;,
...
&#34;status&#34;: &#34;Success&#34;,
&#34;details&#34;: {
    &#34;name&#34;: &#34;nginx-deployment&#34;,
    &#34;group&#34;: &#34;apps&#34;,
    &#34;kind&#34;: &#34;deployments&#34;,
    &#34;uid&#34;: &#34;cc9eefb9-2d49-4445-b1c1-d261c9396456&#34;
}
</code></pre></li></ol></div></div><h2 id=set-orphan-deletion-policy>소유자 오브젝트 및 종속된 고아(orphan) 오브젝트 삭제</h2><p>기본적으로, 쿠버네티스에 오브젝트를 삭제하도록 지시하면
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는
종속 오브젝트들도 제거한다. 클러스터를 실행하는
쿠버네티스 버전에 따라 <code>kubectl</code> 또는 쿠버네티스 API를 사용해
종속 오브젝트를 쿠버네티스 <em>고아</em>로 만들 수 있다.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><ul class="nav nav-tabs" id=orphan-objects role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#orphan-objects-0 role=tab aria-controls=orphan-objects-0 aria-selected=true>쿠버네티스 1.20.x 이후 버전</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#orphan-objects-1 role=tab aria-controls=orphan-objects-1>쿠버네티스 1.20.x 전 버전</a></li></ul><div class=tab-content id=orphan-objects><div id=orphan-objects-0 class="tab-pane show active" role=tabpanel aria-labelledby=orphan-objects-0><p><p><strong>kubectl 사용</strong></p><p>다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>orphan
</span></span></code></pre></div><p><strong>쿠버네티스 API 사용</strong></p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력에는 다음과 같이 <code>finalizers</code> 필드에 <code>orphan</code>이 포함되어 있다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Deployment&#34;,
&#34;apiVersion&#34;: &#34;apps/v1&#34;,
&#34;namespace&#34;: &#34;default&#34;,
&#34;uid&#34;: &#34;6f577034-42a0-479d-be21-78018c466f1f&#34;,
&#34;creationTimestamp&#34;: &#34;2021-07-09T16:46:37Z&#34;,
&#34;deletionTimestamp&#34;: &#34;2021-07-09T16:47:08Z&#34;,
&#34;deletionGracePeriodSeconds&#34;: 0,
&#34;finalizers&#34;: [
  &#34;orphan&#34;
],
...
</code></pre></li></ol></div><div id=orphan-objects-1 class=tab-pane role=tabpanel aria-labelledby=orphan-objects-1><p><p>상세한 내용은 <a href=/ko/docs/home/supported-doc-versions/>쿠버네티스 버전에 따른 문서</a>를 참고한다.</p><p><strong>kubectl 사용</strong></p><p>다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-deployment --cascade<span style=color:#666>=</span>orphan
</span></span></code></pre></div><p><strong>쿠버네티스 API 사용</strong></p><ol><li><p>로컬 프록시 세션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div></li><li><p>삭제를 작동시키기 위해 <code>curl</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/deployments/nginx-deployment <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>출력에는 다음과 같이 <code>finalizers</code> 필드에 <code>orphan</code>이 포함되어 있다.</p><pre tabindex=0><code>&#34;kind&#34;: &#34;Deployment&#34;,
&#34;apiVersion&#34;: &#34;apps/v1&#34;,
&#34;namespace&#34;: &#34;default&#34;,
&#34;uid&#34;: &#34;6f577034-42a0-479d-be21-78018c466f1f&#34;,
&#34;creationTimestamp&#34;: &#34;2021-07-09T16:46:37Z&#34;,
&#34;deletionTimestamp&#34;: &#34;2021-07-09T16:47:08Z&#34;,
&#34;deletionGracePeriodSeconds&#34;: 0,
&#34;finalizers&#34;: [
  &#34;orphan&#34;
],
...
</code></pre></li></ol></div></div><p>디플로이먼트가 관리하는 파드들이 계속 실행 중인지 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li>쿠버네티스의 <a href=/docs/concepts/overview/working-with-objects/owners-dependents/>소유자와 종속 오브젝트</a>에 대해 알아보자.</li><li>쿠버네티스 <a href=/ko/docs/concepts/overview/working-with-objects/finalizers/>파이널라이저(finalizers)</a>에 대해 알아보자.</li><li><a href=/ko/docs/concepts/architecture/garbage-collection/>가비지(garbage) 수집</a>에 대해 알아보자.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fbc9136f53eccd6eb8c80f4bbea3b8f4>3.19 - 퍼시스턴트볼륨 반환 정책 변경하기</h1><p>이 페이지는 쿠버네티스 퍼시트턴트볼륨(PersistentVolume)의 반환 정책을
변경하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=왜-퍼시스턴트볼륨-반환-정책을-변경하는가>왜 퍼시스턴트볼륨 반환 정책을 변경하는가?</h2><p>퍼시스턴트볼륨은 "Retain(보존)", "Recycle(재활용)", "Delete(삭제)" 를 포함한
다양한 반환 정책을 갖는다. 동적으로 프로비저닝 된 퍼시스턴트볼륨의 경우
기본 반환 정책은 "Delete" 이다. 이는 사용자가 해당 <code>PersistentVolumeClaim</code> 을 삭제하면,
동적으로 프로비저닝 된 볼륨이 자동적으로 삭제됨을 의미한다.
볼륨에 중요한 데이터가 포함된 경우, 이러한 자동 삭제는 부적절 할 수 있다.
이 경우에는, "Retain" 정책을 사용하는 것이 더 적합하다.
"Retain" 정책에서, 사용자가 퍼시스턴트볼륨클레임을 삭제할 경우 해당하는
퍼시스턴트볼륨은 삭제되지 않는다.
대신, <code>Released</code> 단계로 이동되어, 모든 데이터를 수동으로 복구할 수 있다.</p><h2 id=퍼시스턴트볼륨-반환-정책-변경하기>퍼시스턴트볼륨 반환 정책 변경하기</h2><ol><li><p>사용자의 클러스터에서 퍼시스턴트볼륨을 조회한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pv
</span></span></code></pre></div><p>결과는 아래와 같다.</p><pre tabindex=0><code class=language-none data-lang=none>NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM             STORAGECLASS     REASON    AGE
pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1    manual                     10s
pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2    manual                     6s
pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim3    manual                     3s
</code></pre><p>이 목록은 동적으로 프로비저닝 된 볼륨을 쉽게 식별할 수 있도록
각 볼륨에 바인딩 되어 있는 퍼시스턴트볼륨클레임(PersistentVolumeClaim)의 이름도 포함한다.</p></li><li><p>사용자의 퍼시스턴트볼륨 중 하나를 선택한 후에 반환 정책을 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch pv &lt;your-pv-name&gt; -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;persistentVolumeReclaimPolicy&#34;:&#34;Retain&#34;}}&#39;</span>
</span></span></code></pre></div><p>여기서 <code>&lt;your-pv-name></code> 는 사용자가 선택한 퍼시스턴트볼륨의 이름이다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>윈도우에서는, 공백이 포함된 모든 JSONPath 템플릿에 <em>겹</em> 따옴표를 사용해야 한다.
(bash에 대해 위에서 표시된 홑 따옴표가 아니다.)
따라서 템플릿의 모든 표현식에서 홑 따옴표를 쓰거나, 이스케이프 처리된 겹 따옴표를 써야 한다. 예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>kubectl patch pv &lt;your-pv-name&gt; -p <span style=color:#b44>&#34;{\&#34;</span>spec\<span style=color:#b44>&#34;:{\&#34;</span>persistentVolumeReclaimPolicy\<span style=color:#b44>&#34;:\&#34;</span>Retain\<span style=color:#b44>&#34;}}&#34;</span>
</span></span></code></pre></div></div></li><li><p>선택한 PersistentVolume이 올바른 정책을 갖는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pv
</span></span></code></pre></div><p>결과는 아래와 같다.</p><pre tabindex=0><code class=language-none data-lang=none>NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM             STORAGECLASS     REASON    AGE
pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1    manual                     40s
pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2    manual                     36s
pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Retain          Bound     default/claim3    manual                     33s
</code></pre><p>위 결과에서, <code>default/claim3</code> 클레임과 바인딩 되어 있는 볼륨이 <code>Retain</code> 반환 정책을
갖는 것을 볼 수 있다. 사용자가 <code>default/claim3</code> 클레임을 삭제할 경우,
볼륨은 자동으로 삭제 되지 않는다.</p></li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트볼륨</a>에 대해 더 배워 보기.</li><li><a href=/ko/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>퍼시스턴트볼륨클레임</a>에 대해 더 배워 보기.</li></ul><h3 id=reference>레퍼런스</h3><ul><li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/>PersistentVolume</a><ul><li>퍼시스턴트볼륨의 <code>.spec.persistentVolumeReclaimPolicy</code>
<a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/#PersistentVolumeSpec>필드</a>에
주의한다.</li></ul></li><li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/>PersistentVolumeClaim</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f5da33b976758a9183018c421eb83f58>4 - 파드와 컨테이너 설정</h1><div class=lead>파드와 컨테이너에 대한 공통 구성 태스크들을 수행한다.</div></div><div class=td-content><h1 id=pg-e6dd9300cf3a955f7cdfe77fb5d15292>4.1 - 컨테이너 및 파드 메모리 리소스 할당</h1><p>이 페이지는 메모리 <em>요청량</em> 과 메모리 <em>상한</em> 을 컨테이너에 어떻게 지정하는지 보여준다.
컨테이너는 요청량 만큼의 메모리 확보가 보장되나
상한보다 더 많은 메모리는 사용할 수 없다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><p>클러스터의 각 노드에 최소 300 MiB 메모리가 있어야 한다.</p><p>이 페이지의 몇 가지 단계를 수행하기 위해서는 클러스터 내
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a>
서비스 실행이 필요하다. 이미 실행 중인 metrics-server가 있다면
다음 단계를 건너뛸 수 있다.</p><p>Minikube를 사용 중이라면, 다음 명령어를 실행해 metric-server를
활성화할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> metrics-server
</span></span></code></pre></div><p>metric-server가 실행 중인지 확인하거나 다른 제공자의 리소스 메트릭 API (<code>metrics.k8s.io</code>)를 확인하기 위해
다음의 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get apiservices
</span></span></code></pre></div><p>리소스 메트릭 API를 사용할 수 있다면 출력에
<code>metrics.k8s.io</code>에 대한 참조가 포함되어 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      
</span></span><span style=display:flex><span>v1beta1.metrics.k8s.io
</span></span></code></pre></div><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 예제에서 생성할 자원과 클러스터 내 나머지를 분리하기 위해
네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace mem-example
</span></span></code></pre></div><h2 id=메모리-요청량-및-상한을-지정>메모리 요청량 및 상한을 지정</h2><p>컨테이너에 메모리 요청량을 지정하기 위해서는 컨테이너의 리소스 매니페스트에
<code>resources:requests</code> 필드를 포함한다. 리소스 상한을 지정하기 위해서는
<code>resources:limits</code> 필드를 포함한다.</p><p>이 예제에서 하나의 컨테이너를 가진 파드를 생성한다. 생성된 컨테이너는
100 MiB 메모리 요청량과 200 MiB 메모리 상한을 갖는다. 이 것이 파드 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/resource/memory-request-limit.yaml download=pods/resource/memory-request-limit.yaml><code>pods/resource/memory-request-limit.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-yaml")' title="Copy pods/resource/memory-request-limit.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>구성 파일 내 <code>args</code> 섹션은 컨테이너가 시작될 때 아규먼트를 제공한다.
<code>"--vm-bytes", "150M"</code> 아규먼트는 컨테이너가 150 MiB 할당을 시도 하도록 한다.</p><p>파드 생성:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>파드 컨테이너가 실행 중인지 확인:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보 보기:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>출력은 파드 내 하나의 컨테이너에 100MiB 메모리 요청량과
200 MiB 메모리 상한이 있는 것을 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>kubectl top</code>을 실행하여 파드 메트릭 가져오기:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl top pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>출력은 파드가 약 150 MiB 해당하는 약 162,900,000 바이트 메모리를 사용하는 것을 보여준다.
이는 파드의 100 MiB 요청 보다 많으나
파드의 200 MiB 상한보다는 적다.</p><pre tabindex=0><code>NAME                        CPU(cores)   MEMORY(bytes)
memory-demo                 &lt;something&gt;  162856960
</code></pre><p>파드 삭제:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=컨테이너의-메모리-상한을-초과>컨테이너의 메모리 상한을 초과</h2><p>노드 내 메모리가 충분하다면 컨테이너는 지정한 요청량보다 많은 메모리를 사용 할 수 있다. 그러나
컨테이너는 지정한 메모리 상한보다 많은 메모리를 사용할 수 없다. 만약 컨테이너가 지정한 메모리 상한보다
많은 메모리를 할당하면 해당 컨테이너는 종료 대상 후보가 된다. 만약 컨테이너가 지속적으로
지정된 상한보다 많은 메모리를 사용한다면, 해당 컨테이너는 종료된다. 만약 종료된 컨테이너가
재실행 가능하다면 다른 런타임 실패와 마찬가지로 kubelet에 의해 재실행된다.</p><p>이 예제에서는 상한보다 많은 메모리를 할당하려는 파드를 생성한다.
이 것은 50 MiB 메모리 요청량과 100 MiB 메모리 상한을 갖는
하나의 컨테이너를 갖는 파드의 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/resource/memory-request-limit-2.yaml download=pods/resource/memory-request-limit-2.yaml><code>pods/resource/memory-request-limit-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-2-yaml")' title="Copy pods/resource/memory-request-limit-2.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;250M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>구성 파일의 <code>args</code> 섹션에서 컨테이너가
100 MiB 상한을 훨씬 초과하는 250 MiB의 메모리를 할당하려는 것을 볼 수 있다.</p><p>파드 생성:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-2.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>파드에 대한 자세한 정보 보기:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>이 시점에 컨테이너가 실행되거나 종료되었을 수 있다. 컨테이너가 종료될 때까지 이전의 명령을 반복한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME            READY     STATUS      RESTARTS   AGE
</span></span><span style=display:flex><span>memory-demo-2   0/1       OOMKilled   <span style=color:#666>1</span>          24s
</span></span></code></pre></div><p>컨테이너 상태의 상세 상태 보기:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>컨테이너가 메모리 부족 (OOM) 으로 종료되었음이 출력된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>lastState</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>terminated</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>65183c1877aaec2e8427bc95609cc52677a454b56fcb24340dbd22917c23b10f<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>exitCode</span>:<span style=color:#bbb> </span><span style=color:#666>137</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>finishedAt</span>:<span style=color:#bbb> </span>2017-06-20T20:52:19Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>OOMKilled<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>startedAt</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이 예제에서 컨테이너는 재실행 가능하여 kubelet에 의해 재실행된다.
컨테이너가 종료되었다 재실행되는 것을 보기 위해 다음 명령을 몇 번 반복한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>출력은 컨테이너의 종료, 재실행, 재종료, 재실행 등을 보여준다.</p><pre tabindex=0><code>kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   1          37s
</code></pre><pre tabindex=0><code>
kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-2   1/1       Running   2          40s
</code></pre><p>파드 내역에 대한 상세 정보 보기:</p><pre tabindex=0><code>kubectl describe pod memory-demo-2 --namespace=mem-example
</code></pre><p>컨테이너가 반복적으로 시작하고 실패 하는 출력을 보여준다.</p><pre tabindex=0><code>... Normal  Created   Created container with id 66a3a20aa7980e61be4922780bf9d24d1a1d8b7395c09861225b0eba1b1f8511
... Warning BackOff   Back-off restarting failed container
</code></pre><p>클러스터 노드에 대한 자세한 정보 보기:</p><pre tabindex=0><code>kubectl describe nodes
</code></pre><p>출력에는 컨테이너가 메모리 부족으로 종료된 기록이 포함된다.</p><pre tabindex=0><code>Warning OOMKilling Memory cgroup out of memory: Kill process 4481 (stress) score 1994 or sacrifice child
</code></pre><p>파드 삭제:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=노드에-비해-너무-큰-메모리-요청량의-지정>노드에 비해 너무 큰 메모리 요청량의 지정</h2><p>메모리 요청량과 상한은 컨테이너와 관련있지만, 파드가 가지는
메모리 요청량과 상한으로 이해하면 유용하다. 파드의 메모리 요청량은
파드 내 모든 컨테이너의 메모리 요청량의 합이다. 마찬가지로
파드의 메모리 상한은 파드 내 모든 컨테이너의 메모리 상한의 합이다.</p><p>파드는 요청량을 기반하여 스케줄링된다. 노드에 파드의 메모리 요청량을 충족하기에 충분한 메모리가 있는
경우에만 파드가 노드에서 스케줄링된다.</p><p>이 예제에서는 메모리 요청량이 너무 커 클러스터 내 모든 노드의 용량을 초과하는 파드를 생성한다.
다음은 클러스터 내 모든 노드의 용량을 초과할 수 있는 1000 GiB 메모리 요청을 포함하는
컨테이너를 갖는
파드의 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/resource/memory-request-limit-3.yaml download=pods/resource/memory-request-limit-3.yaml><code>pods/resource/memory-request-limit-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-3-yaml")' title="Copy pods/resource/memory-request-limit-3.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드 생성:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-3.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>파드 상태 보기:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>파드 상태가 PENDING 상태임이 출력된다. 즉 파드는 어떤 노드에서도 실행되도록 스케줄 되지 않고 PENDING가 계속 지속된다.</p><pre tabindex=0><code>kubectl get pod memory-demo-3 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-3   0/1       Pending   0          25s
</code></pre><p>이벤트를 포함한 파드 상세 정보 보기:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>출력은 노드 내 메모리가 부족하여 파드가 스케줄링될 수 없음을 보여준다.</p><pre tabindex=0><code>Events:
  ...  Reason            Message
       ------            -------
  ...  FailedScheduling  No nodes are available that match all of the following predicates:: Insufficient memory (3).
</code></pre><h2 id=메모리-단위>메모리 단위</h2><p>메모리 리소스는 byte 단위로 측정된다. 다음 접미사 중 하나로 정수 또는 고정 소수점으로
메모리를 표시할 수 있다. E, P, T, G, M, K, Ei, Pi, Ti, Gi, Mi, Ki.
예를 들어 다음은 거의 유사한 값을 나타낸다.</p><pre tabindex=0><code>128974848, 129e6, 129M, 123Mi
</code></pre><p>파드 삭제:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=메모리-상한을-지정하지-않으면>메모리 상한을 지정하지 않으면</h2><p>컨테이너에 메모리 상한을 지정하지 않으면 다음 중 하나가 적용된다.</p><ul><li><p>컨테이너가 사용할 수 있는 메모리 상한은 없다. 컨테이너가
실행 중인 노드에서 사용 가능한 모든 메모리를 사용하여 OOM Killer가 실행될 수 있다. 또한 메모리 부족으로 인한 종료 시 메모리 상한이 없는 컨테이너가 종료될 가능성이 크다.</p></li><li><p>기본 메모리 상한을 갖는 네임스페이스 내에서 실행중인 컨테이너는
자동으로 기본 메모리 상한이 할당된다. 클러스터 관리자들은
<a href=/docs/reference/generated/kubernetes-api/v1.25/#limitrange-v1-core>LimitRange</a>를
사용해 메모리 상한의 기본 값을 지정 가능하다.</p></li></ul><h2 id=메모리-요청량과-상한-동기부여>메모리 요청량과 상한 동기부여</h2><p>클러스터에서 실행되는 컨테이너에 메모리 요청량과 상한을 구성하여
클러스터 내 노드들의 메모리 리소스를 효율적으로 사용할 수 있게 할 수 있다.
파드의 메모리 요청량을 적게 유지하여 파드가 높은 확률로 스케줄링 될 수 있도록 한다.
메모리 상한이 메모리 요청량보다 크면 다음 두 가지가 수행된다.</p><ul><li>가용한 메모리가 있는 경우 파드가 이를 사용할 수 있는 버스트(burst) 활동을 할 수 있다.</li><li>파드가 버스트 중 사용 가능한 메모리 양이 적절히 제한된다.</li></ul><h2 id=정리>정리</h2><p>네임스페이스를 지운다. 이 작업을 통해 네임스페이스 내 생성했던 모든 파드들은 삭제된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace mem-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=앱-개발자들을-위한>앱 개발자들을 위한</h3><ul><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>CPU 리소스를 컨테이너와 파드에 할당</a></p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/quality-service-pod/>파드에 서비스 품질 설정</a></p></li></ul><h3 id=클러스터-관리자들을-위한>클러스터 관리자들을 위한</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 기본 메모리 요청량 및 상한을 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 기본 CPU 요청량 및 상한을 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 최소 및 최대 메모리 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 최소 및 최대 CPU 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 메모리 및 CPU 할당량 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 파드 할당량 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트에 할당량 구성</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f5da7517bee8a8807431d9fc65263b39>4.2 - 윈도우 파드 및 컨테이너에서 RunAsUserName 구성</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [stable]</code></div><p>이 페이지에서는 윈도우 노드에서 실행될 파드 및 컨테이너에 <code>runAsUserName</code> 설정을 사용하는 방법을 소개한다. 이는 리눅스 관련 <code>runAsUser</code> 설정과 거의 동일하여, 컨테이너의 기본값과 다른 username으로 애플리케이션을 실행할 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 있어야 하며 클러스터와 통신하도록 kubectl 명령줄 도구를 구성해야 한다. 클러스터에는 윈도우 워커 노드가 있어야 하고, 해당 노드에서 윈도우 워크로드를 실행하는 컨테이너의 파드가 스케쥴 된다.</p><h2 id=파드의-username-설정>파드의 username 설정</h2><p>파드의 컨테이너 프로세스를 실행할 username을 지정하려면 파드 명세에 <code>securityContext</code> 필드 (<a href=/docs/reference/generated/kubernetes-api/v1.25/#podsecuritycontext-v1-core>PodSecurityContext</a>) 를 포함시키고, 그 안에 <code>runAsUserName</code> 필드를 포함하는 <code>windowsOptions</code> (<a href=/docs/reference/generated/kubernetes-api/v1.25/#windowssecuritycontextoptions-v1-core>WindowsSecurityContextOptions</a>) 필드를 추가한다.</p><p>파드에 지정하는 윈도우 보안 컨텍스트 옵션은 파드의 모든 컨테이너 및 초기화 컨테이너에 적용된다.</p><p>다음은 <code>runAsUserName</code> 필드가 설정된 윈도우 파드의 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/windows/run-as-username-pod.yaml download=windows/run-as-username-pod.yaml><code>windows/run-as-username-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("windows-run-as-username-pod-yaml")' title="Copy windows/run-as-username-pod.yaml to clipboard"></img></div><div class=includecode id=windows-run-as-username-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-pod-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerUser&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ping&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-t&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;localhost&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/windows/run-as-username-pod.yaml
</span></span></code></pre></div><p>파드의 컨테이너가 실행 중인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod run-as-username-pod-demo
</span></span></code></pre></div><p>실행 중인 컨테이너의 셸에 접근한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it run-as-username-pod-demo -- powershell
</span></span></code></pre></div><p>셸이 올바른 username인 사용자로 실행 중인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>echo </span><span style=color:#b8860b>$env:USERNAME</span>
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>ContainerUser
</code></pre><h2 id=컨테이너의-username-설정>컨테이너의 username 설정</h2><p>컨테이너의 프로세스를 실행할 username을 지정하려면, 컨테이너 매니페스트에 <code>securityContext</code> 필드 (<a href=/docs/reference/generated/kubernetes-api/v1.25/#securitycontext-v1-core>SecurityContext</a>) 를 포함시키고 그 안에 <code>runAsUserName</code> 필드를 포함하는 <code>windowsOptions</code> (<a href=/docs/reference/generated/kubernetes-api/v1.25/#windowssecuritycontextoptions-v1-core>WindowsSecurityContextOptions</a>) 필드를 추가한다.</p><p>컨테이너에 지정하는 윈도우 보안 컨텍스트 옵션은 해당 개별 컨테이너에만 적용되며 파드 수준에서 지정한 설정을 재정의한다.</p><p>다음은 한 개의 컨테이너에 <code>runAsUserName</code> 필드가 파드 수준 및 컨테이너 수준에서 설정되는 파드의 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/windows/run-as-username-container.yaml download=windows/run-as-username-container.yaml><code>windows/run-as-username-container.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("windows-run-as-username-container-yaml")' title="Copy windows/run-as-username-container.yaml to clipboard"></img></div><div class=includecode id=windows-run-as-username-container-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-container-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerUser&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ping&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-t&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;localhost&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerAdministrator&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/windows/run-as-username-container.yaml
</span></span></code></pre></div><p>파드의 컨테이너가 실행 중인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod run-as-username-container-demo
</span></span></code></pre></div><p>실행 중인 컨테이너의 셸에 접근한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it run-as-username-container-demo -- powershell
</span></span></code></pre></div><p>셸이 사용자에게 올바른 username(컨테이너 수준에서 설정된 사용자)을 실행 중인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>echo </span><span style=color:#b8860b>$env:USERNAME</span>
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>ContainerAdministrator
</code></pre><h2 id=윈도우-username-제약사항>윈도우 username 제약사항</h2><p>이 기능을 사용하려면 <code>runAsUserName</code> 필드에 설정된 값이 유효한 username이어야 한다. 형식은 <code>DOMAIN\USER</code> 여야하고, 여기서 <code>DOMAIN\</code>은 선택 사항이다. 윈도우 username은 대소문자를 구분하지 않는다. 또한 <code>DOMAIN</code> 및 <code>USER</code> 와 관련된 몇 가지 제약사항이 있다.</p><ul><li><code>runAsUserName</code> 필드는 비워 둘 수 없으며 제어 문자를 포함할 수 없다. (ASCII 값: <code>0x00-0x1F</code>, <code>0x7F</code>)</li><li><code>DOMAIN</code>은 NetBios 이름 또는 DNS 이름이어야 하며 각각 고유한 제한이 있다.<ul><li>NetBios 이름: 최대 15 자, <code>.</code>(마침표)으로 시작할 수 없으며 다음 문자를 포함할 수 없다. <code>\ / : * ? " &lt; > |</code></li><li>DNS 이름: 최대 255 자로 영숫자, 마침표(<code>.</code>), 대시(<code>-</code>)로만 구성되며, 마침표 또는 대시로 시작하거나 끝날 수 없다.</li></ul></li><li><code>USER</code>는 최대 20자이며, <em>오직</em> 마침표나 공백들로는 구성할 수 없고, 다음 문자는 포함할 수 없다. <code>" / \ [ ] : ; | = , + * ? &lt; > @</code>.</li></ul><p><code>runAsUserName</code> 필드에 허용되는 값의 예 : <code>ContainerAdministrator</code>,<code>ContainerUser</code>, <code>NT AUTHORITY\NETWORK SERVICE</code>, <code>NT AUTHORITY\LOCAL SERVICE</code>.</p><p>이러한 제약사항에 대한 자세한 내용은 <a href=https://support.microsoft.com/en-us/help/909264/naming-conventions-in-active-directory-for-computers-domains-sites-and>여기</a> 와 <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.localaccounts/new-localuser?view=powershell-5.1">여기</a>를 확인한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/windows/user-guide/>쿠버네티스에서 윈도우 컨테이너 스케줄링을 위한 가이드</a></li><li><a href=/ko/docs/concepts/windows/user-guide/#%EA%B7%B8%EB%A3%B9-%EB%A7%A4%EB%8B%88%EC%A7%80%EB%93%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%96%B4%EC%B9%B4%EC%9A%B4%ED%8A%B8%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%9B%8C%ED%81%AC%EB%A1%9C%EB%93%9C-%EC%8B%A0%EC%9B%90-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0>그룹 매니지드 서비스 어카운트를 이용하여 워크로드 신원 관리하기</a></li><li><a href=/ko/docs/tasks/configure-pod-container/configure-gmsa/>윈도우 파드와 컨테이너의 GMSA 구성</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-aa522472483f900008124a2809f2114b>4.3 - 윈도우 파드와 컨테이너용 GMSA 구성</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [stable]</code></div><p>이 페이지는 윈도우 노드에서 실행되는 파드와 컨테이너용으로 <a href=https://docs.microsoft.com/ko-kr/windows-server/security/group-managed-service-accounts/group-managed-service-accounts-overview>그룹 관리 서비스 어카운트(Group Managed Service Accounts,</a> GMSA)를 구성하는 방법을 소개한다. 그룹 관리 서비스 어카운트는 자동 암호 관리, 단순화된 서비스 사용자 이름(service principal name, SPN) 관리, 여러 서버에 걸쳐 다른 관리자에게 관리를 위임하는 기능을 제공하는 특정한 유형의 액티브 디렉터리(Active Directory) 계정이다.</p><p>쿠버네티스에서 GMSA 자격 증명 사양은 쿠버네티스 클러스터 전체 범위에서 사용자 정의 리소스(Custom Resources)로 구성된다. 윈도우 파드 및 파드 내의 개별 컨테이너들은 다른 윈도우 서비스와 상호 작용할 때 도메인 기반 기능(예: Kerberos 인증)에 GMSA를 사용하도록 구성할 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 있어야 하며 클러스터와 통신하도록 <code>kubectl</code> 커맨드라인 툴을 구성해야 한다. 클러스터에는 윈도우 워커 노드가 있어야 한다. 이 섹션에서는 각 클러스터에 대해 한 번씩 필요한 일련의 초기 단계를 다룬다.</p><h3 id=gmsacredentialspec-crd-설치>GMSACredentialSpec CRD 설치</h3><p>GMSA 자격 증명 사양 리소스에 대한 <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>커스텀리소스데피니션(CustomResourceDefinition,</a> CRD)을 클러스터에서 구성하여 사용자 정의 리소스 유형 <code>GMSACredentialSpec</code>을 정의해야 한다. GMSA CRD <a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/gmsa-crd.yml>YAML</a>을 다운로드하고 gmsa-crd.yaml로 저장한다.
다음, <code>kubectl apply -f gmsa-crd.yaml</code> 로 CRD를 설치한다.</p><h3 id=gmsa-사용자를-검증하기-위해-웹훅-설치>GMSA 사용자를 검증하기 위해 웹훅 설치</h3><p>쿠버네티스 클러스터에서 두 개의 웹훅을 구성하여 파드 또는 컨테이너 수준에서 GMSA 자격 증명 사양 참조를 채우고 검증한다.</p><ol><li><p>변형(mutating) 웹훅은 (파드 사양의 이름별로) GMSA에 대한 참조를 파드 사양 내 JSON 형식의 전체 자격 증명 사양으로 확장한다.</p></li><li><p>검증(validating) 웹훅은 GMSA에 대한 모든 참조가 파드 서비스 어카운트에서 사용하도록 승인되었는지 확인한다.</p></li></ol><p>위의 웹훅 및 관련 오브젝트를 설치하려면 다음 단계가 필요하다.</p><ol><li><p>인증서 키 쌍 생성 (웹훅 컨테이너가 클러스터와 통신할 수 있도록 하는데 사용됨)</p></li><li><p>위의 인증서로 시크릿을 설치</p></li><li><p>핵심 웹훅 로직에 대한 디플로이먼트(deployment)를 생성</p></li><li><p>디플로이먼트를 참조하여 검증 및 변경 웹훅 구성을 생성</p></li></ol><p><a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/deploy-gmsa-webhook.sh>스크립트</a>를 사용하여 GMSA 웹훅과 위에서 언급한 관련 오브젝트를 배포 및 구성할 수 있다. 스크립트는 <code>--dry-run=server</code> 옵션으로 실행되어 클러스터에 대한 변경 사항을 검토할 수 있다.</p><p>스크립트에서 사용하는 <a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/gmsa-webhook.yml.tpl>YAML 템플릿</a>을 사용하여 웹훅 및 (파라미터를 적절히 대체하여) 관련 오브젝트를 수동으로 배포할 수도 있다.</p><h2 id=액티브-디렉터리에서-gmsa-및-윈도우-노드-구성>액티브 디렉터리에서 GMSA 및 윈도우 노드 구성</h2><p>쿠버네티스의 파드가 GMSA를 사용하도록 구성되기 전에 <a href=https://docs.microsoft.com/ko-kr/windows-server/security/group-managed-service-accounts/getting-started-with-group-managed-service-accounts#BKMK_Step1>윈도우 GMSA 문서</a>에 설명된 대로 액티브 디렉터리에서 원하는 GMSA를 프로비저닝해야 한다. <a href=https://docs.microsoft.com/ko-kr/windows-server/security/group-managed-service-accounts/getting-started-with-group-managed-service-accounts#to-add-member-hosts-using-the-set-adserviceaccount-cmdlet>윈도우 GMSA 문서</a>에 설명된 대로 원하는 GMSA와 연결된 시크릿 자격 증명에 접근하려면 (쿠버네티스 클러스터의 일부인) 윈도우 워커 노드를 액티브 디렉터리에서 구성해야 한다.</p><h2 id=gmsa-자격-증명-사양-리소스-생성>GMSA 자격 증명 사양 리소스 생성</h2><p>(앞에서 설명한 대로) GMSACredentialSpec CRD를 설치하면 GMSA 자격 증명 사양이 포함된 사용자 정의 리소스를 구성할 수 있다. GMSA 자격 증명 사양에는 시크릿 또는 민감한 데이터가 포함되어 있지 않다. 이것은 컨테이너 런타임이 원하는 윈도우 컨테이너 GMSA를 설명하는 데 사용할 수 있는 정보이다. GMSA 자격 증명 사양은 <a href=https://github.com/kubernetes-sigs/windows-gmsa/tree/master/scripts/GenerateCredentialSpecResource.ps1>PowerShell 스크립트</a> 유틸리티를 사용하여 YAML 형식으로 생성할 수 있다.</p><p>다음은 JSON 형식으로 GMSA 자격 증명 사양 YAML을 수동으로 생성한 다음 변환하는 단계이다.</p><ol><li><p>CredentialSpec <a href=https://github.com/MicrosoftDocs/Virtualization-Documentation/blob/live/windows-server-container-tools/ServiceAccounts/CredentialSpec.psm1>모듈</a> 가져오기(import): <code>ipmo CredentialSpec.psm1</code></p></li><li><p><code>New-CredentialSpec</code>을 사용하여 JSON 형식의 자격 증명 사양을 만든다. WebApp1이라는 GMSA 자격 증명 사양을 만들려면 <code>New-CredentialSpec -Name WebApp1 -AccountName WebApp1 -Domain $(Get-ADDomain -Current LocalComputer)</code>를 호출한다.</p></li><li><p><code>Get-CredentialSpec</code>을 사용하여 JSON 파일의 경로를 표시한다.</p></li><li><p>credspec 파일을 JSON에서 YAML 형식으로 변환하고 필요한 헤더 필드 <code>apiVersion</code>, <code>kind</code>, <code>metadata</code>, <code>credspec</code>을 적용하여 쿠버네티스에서 구성할 수 있는 GMSACredentialSpec 사용자 정의 리소스로 만든다.</p></li></ol><p>다음 YAML 구성은 <code>gmsa-WebApp1</code>이라는 GMSA 자격 증명 사양을 설명한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>windows.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>GMSACredentialSpec<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gmsa-WebApp1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic>#임의의 이름이지만 참조로 사용된다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>credspec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ActiveDirectoryConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>GroupManagedServiceAccounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>Name</span>:<span style=color:#bbb> </span>WebApp1  <span style=color:#bbb> </span><span style=color:#080;font-style:italic>#GMSA 계정의 사용자 이름</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>Scope</span>:<span style=color:#bbb> </span>CONTOSO <span style=color:#bbb> </span><span style=color:#080;font-style:italic>#NETBIOS 도메인 명</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>Name</span>:<span style=color:#bbb> </span>WebApp1  <span style=color:#bbb> </span><span style=color:#080;font-style:italic>#GMSA 계정의 사용자 이름</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>Scope</span>:<span style=color:#bbb> </span>contoso.com<span style=color:#bbb> </span><span style=color:#080;font-style:italic>#DNS 도메인 명</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>CmsPlugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ActiveDirectory<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>DomainJoinConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>DnsName</span>:<span style=color:#bbb> </span>contoso.com <span style=color:#bbb> </span><span style=color:#080;font-style:italic>#DNS 도메인 명</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>DnsTreeName</span>:<span style=color:#bbb> </span>contoso.com<span style=color:#bbb> </span><span style=color:#080;font-style:italic>#DNS 도메인 명 루트</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>Guid</span>:<span style=color:#bbb> </span>244818ae-87ac-4fcd-92ec-e79e5252348a <span style=color:#bbb> </span><span style=color:#080;font-style:italic>#GUID</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>MachineAccountName</span>:<span style=color:#bbb> </span>WebApp1<span style=color:#bbb> </span><span style=color:#080;font-style:italic>#GMSA 계정의 사용자 이름</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>NetBiosName</span>:<span style=color:#bbb> </span>CONTOSO <span style=color:#bbb> </span><span style=color:#080;font-style:italic>#NETBIOS 도메인 명</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>Sid</span>:<span style=color:#bbb> </span>S-1-5-21-2126449477-2524075714-3094792973<span style=color:#bbb> </span><span style=color:#080;font-style:italic>#SID of GMSA</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>위의 자격 증명 사양 리소스는 <code>gmsa-Webapp1-credspec.yaml</code>로 저장되고 <code>kubectl apply -f gmsa-Webapp1-credspec.yml</code>을 사용하여 클러스터에 적용될 수 있다.</p><h2 id=특정-gmsa-자격-증명-사양에서-rbac를-활성화하도록-cluster-role-구성>특정 GMSA 자격 증명 사양에서 RBAC를 활성화하도록 cluster role 구성</h2><p>각 GMSA 자격 증명 사양 리소스에 대해 cluster role을 정의해야 한다. 이것은 일반적으로 서비스 어카운트인 주체에 의해 특정 GMSA 리소스에 대한 <code>use</code> 동사를 승인한다. 다음 예는 위에서 <code>gmsa-WebApp1</code> 자격 증명 사양의 사용을 승인하는 클러스터 롤(cluster role)을 보여준다. 파일을 gmsa-webapp1-role.yaml로 저장하고 <code>kubectl apply -f gmsa-webapp1-role.yaml</code>을 사용하여 적용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic>#credspec을 읽을 Role 생성</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webapp1-role<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;windows.k8s.io&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;gmsacredentialspecs&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;use&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;gmsa-WebApp1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=특정-gmsa-credspecs를-사용하도록-서비스-어카운트에-롤-할당>특정 GMSA credspecs를 사용하도록 서비스 어카운트에 롤 할당</h2><p>(파드가 사용하게 되는) 서비스 어카운트는 위에서 생성한 클러스터 롤에 바인딩되어야 한다. 이렇게 하면 서비스 어카운트가 원하는 GMSA 자격 증명 사양 리소스를 사용할 수 있다. 다음은 위에서 생성한 <code>gmsa-WebApp1</code> 자격 증명 사양 리소스를 사용하기 위해 <code>webapp1-role</code> 클러스터 롤에 바인딩되는 기본(default) 서비스 어카운트이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-default-svc-account-read-on-gmsa-WebApp1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webapp1-role<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=파드-사양에서-gmsa-자격-증명-사양-참조-구성>파드 사양에서 GMSA 자격 증명 사양 참조 구성</h2><p>파드 사양 필드 <code>securityContext.windowsOptions.gmsaCredentialSpecName</code>은 파드 사양에서 원하는 GMSA 자격 증명 사양 사용자 정의 리소스에 대한 참조를 지정하는 데 사용된다. 이렇게 하면 지정된 GMSA를 사용하도록 파드 사양의 모든 컨테이너가 구성된다. 다음은 <code>gmsa-WebApp1</code>을 참조하도록 채워진 어노테이션이 있는 샘플 파드 사양이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>gmsaCredentialSpecName</span>:<span style=color:#bbb> </span>gmsa-webapp1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span></code></pre></div><p>파드 사양의 개별 컨테이너는 컨테이너별 <code>securityContext.windowsOptions.gmsaCredentialSpecName</code> 필드를 사용하여 원하는 GMSA credspec을 지정할 수도 있다. 다음은 예이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>gmsaCredentialSpecName</span>:<span style=color:#bbb> </span>gmsa-Webapp1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span></code></pre></div><p>(위에서 설명한 대로) GMSA 필드가 채워진 파드 사양이 클러스터에 적용되면 다음과 같은 일련의 이벤트가 발생한다.</p><ol><li><p>변형 웹훅은 GMSA 자격 증명 사양 리소스에 대한 모든 참조를 확인하고 GMSA 자격 증명 사양의 내용으로 확장한다.</p></li><li><p>검증 웹훅은 파드와 연결된 서비스 어카운트가 지정된 GMSA 자격 증명 사양의 <code>use</code> 동사에 대해 승인되었는지 확인한다.</p></li><li><p>컨테이너 런타임은 컨테이너가 액티브 디렉터리에서 GMSA의 ID를 가정하고 해당 ID를 사용하여 도메인의 서비스에 접근할 수 있도록 지정된 GMSA 자격 증명 사양으로 각 윈도우 컨테이너를 구성한다.</p></li></ol><h2 id=호스트네임-또는-fqdn을-사용하는-경우에-네트워크-공유에-인증하기>호스트네임 또는 FQDN을 사용하는 경우에 네트워크 공유에 인증하기</h2><p>파드에서 호스트네임 또는 FQDN을 사용하여 SMB 공유에 연결할 때 문제를 겪고 있으나, IPv4 주소로는 해당 공유에 접속이 가능한 상황이라면, 윈도우 노드에 다음 레지스트리 키를 등록했는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>reg add <span style=color:#b44>&#34;HKLM\SYSTEM\CurrentControlSet\Services\hns\State&#34;</span> /v EnableCompartmentNamespace /t REG_DWORD /d 1
</span></span></code></pre></div><p>그런 다음 동작 변경 사항을 적용하려면 실행 중인 파드를 다시 생성해야 한다.
이 레지스트리 키가 어떻게 사용되는지에 대한 자세한 정보는
<a href=https://github.com/microsoft/hcsshim/blob/885f896c5a8548ca36c88c4b87fd2208c8d16543/internal/uvm/create.go#L74-L83>여기</a>에서 볼 수 있다.</p><h2 id=문제-해결>문제 해결</h2><p>GMSA가 사용자 환경에서 작동하도록 하는 데 어려움이 있는 경우 취할 수 있는 몇 가지 문제 해결 단계가 있다.</p><p>먼저 credspec이 파드에 전달되었는지 확인한다. 이렇게 하려면 파드 중 하나에서 <code>exec</code>를 실행하고 <code>nltest.exe /parentdomain</code> 명령의 출력을 확인해야 한다.</p><p>아래 예에서 파드는 credspec을 올바르게 가져오지 못했다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=display:flex><span>kubectl exec -it <span style=color:#a2f>iis-auth</span>-<span style=color:#666>7776966999</span>-n5nzr powershell.exe
</span></span></code></pre></div><p><code>nltest.exe /parentdomain</code> 는 다음과 같은 오류를 발생시킨다.</p><pre tabindex=0><code class=language-output data-lang=output>Getting parent domain failed: Status = 1722 0x6ba RPC_S_SERVER_UNAVAILABLE
</code></pre><p>파드가 credspec을 올바르게 가져오면 다음으로 도메인과의 통신을 확인한다. 먼저 파드 내부에서 nslookup을 빠르게 수행하여 도메인의 루트를 찾는다.</p><p>이것은 다음의 세 가지를 의미한다.</p><ol><li>파드는 DC에 도달할 수 있다.</li><li>DC는 파드에 도달할 수 있다.</li><li>DNS가 올바르게 작동하고 있다.</li></ol><p>DNS 및 통신 테스트를 통과하면 다음으로 파드가 도메인과 보안 채널 통신을 설정했는지 확인해야 한다. 이렇게 하려면 파드에서 다시 <code>exec</code>를 실행하고 <code>nltest.exe /query</code> 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=display:flex><span>nltest.exe /query
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code class=language-output data-lang=output>I_NetLogonControl failed: Status = 1722 0x6ba RPC_S_SERVER_UNAVAILABLE
</code></pre><p>이것은 어떤 이유로 파드가 credspec에 지정된 계정을 사용하여 도메인에 로그온할 수 없음을 알려준다. 다음을 실행하여 보안 채널 복구를 시도할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=display:flex><span>nltest /sc_reset<span>:</span>domain.example
</span></span></code></pre></div><p>명령이 성공하면 다음과 유사한 출력이 표시된다.</p><pre tabindex=0><code class=language-output data-lang=output>Flags: 30 HAS_IP  HAS_TIMESERV
Trusted DC Name \\dc10.domain.example
Trusted DC Connection Status Status = 0 0x0 NERR_Success
The command completed successfully
</code></pre><p>위의 방법으로 오류가 수정되면 다음 수명 주기 훅(hook)을 파드 사양에 추가하여 단계를 자동화할 수 있다. 오류가 수정되지 않은 경우 credspec을 다시 검사하여 정확하고 완전한지 확인해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.domain.example/iis-auth:1809v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>postStart</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;powershell.exe&#34;</span>,<span style=color:#b44>&#34;-command&#34;</span>,<span style=color:#b44>&#34;do { Restart-Service -Name netlogon } while ( $($Result = (nltest.exe /query); if ($Result -like &#39;*0x0 NERR_Success*&#39;) {return $true} else {return $false}) -eq $false)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span></code></pre></div><p>위의 <code>lifecycle</code> 섹션을 파드 사양에 추가하면, 파드는 <code>nltest.exe /query</code> 명령이 오류 없이 종료될 때까지 나열된 명령을 실행하여 <code>netlogon</code> 서비스를 다시 시작한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-904cea8c8efd5c0d33adbfe579ec2dd2>4.4 - 파드에 대한 서비스 품질(QoS) 구성</h1><p>이 페이지는 특정 서비스 품질(QoS) 클래스를 할당하기 위해 어떻게 파드를
구성해야 하는지 보여준다. 쿠버네티스는 QoS 클래스를 사용하여 파드
스케줄링과 축출을 결정한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=qos-클래스>QoS 클래스</h2><p>쿠버네티스가 파드를 생성할 때, 파드에 다음의 QoS 클래스 중 하나를 할당한다.</p><ul><li>Guaranteed</li><li>Burstable</li><li>BestEffort</li></ul><h2 id=네임스페이스-생성>네임스페이스 생성</h2><p>이 연습에서 생성한 리소스가 클러스터의 나머지와
격리되도록 네임스페이스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace qos-example
</span></span></code></pre></div><h2 id=guaranteed-qos-클래스가-할당되는-파드-생성>Guaranteed QoS 클래스가 할당되는 파드 생성</h2><p>파드에 Guaranteed QoS 클래스 할당을 위한 전제 조건은 다음과 같다.</p><ul><li>파드 내 모든 컨테이너는 메모리 상한과 메모리 요청량을 가지고 있어야 한다.</li><li>파드 내 모든 컨테이너의 메모리 상한이 메모리 요청량과 일치해야 한다.</li><li>파드 내 모든 컨테이너는 CPU 상한과 CPU 요청량을 가지고 있어야 한다.</li><li>파드 내 모든 컨테이너의 CPU 상한이 CPU 요청량과 일치해야 한다.</li></ul><p>이러한 제약은 초기화 컨테이너와 앱 컨테이너 모두에 동일하게 적용된다.</p><p>다음은 하나의 컨테이너를 갖는 파드의 구성 파일이다. 해당 컨테이너는 메모리 상한과
메모리 요청량을 갖고 있고, 200MiB로 동일하다. 해당 컨테이너는 CPU 상한과 CPU 요청량을 가지며, 700 milliCPU로 동일하다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/qos/qos-pod.yaml download=pods/qos/qos-pod.yaml><code>pods/qos/qos-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-yaml")' title="Copy pods/qos/qos-pod.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>파드의 상세 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력 결과는 쿠버네티스가 파드에 Guaranteed QoS 클래스를 부여했음을 보여준다. 또한
파드의 컨테이너가 메모리 요청량과 일치하는 메모리 상한을 가지며,
CPU 요청량과 일치하는 CPU 상한을 갖고 있음을 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Guaranteed<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 컨테이너가 자신의 메모리 상한을 지정하지만, 메모리 요청량을 지정하지 않는 경우,
쿠버네티스는 상한과 일치하는 메모리 요청량을 자동으로 할당한다. 이와 유사하게, 만약 컨테이너가 자신의
CPU 상한을 지정하지만, CPU 요청량을 지정하지 않은 경우, 쿠버네티스는 상한과 일치하는 CPU 요청량을 자동으로
할당한다.</div><p>파드를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=burstable-qos-클래스가-할당되는-파드-생성>Burstable QoS 클래스가 할당되는 파드 생성</h2><p>다음의 경우 파드에 Burstable QoS 클래스가 부여된다.</p><ul><li>파드가 Guaranteed QoS 클래스 기준을 만족하지 않는다.</li><li>파드 내에서 최소한 하나의 컨테이너가 메모리 또는 CPU 요청량/상한을 가진다.</li></ul><p>컨테이너가 하나인 파드의 구성 파일은 다음과 같다. 컨테이너는
200MiB의 메모리 상한과 100MiB의 메모리 요청량을 가진다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/qos/qos-pod-2.yaml download=pods/qos/qos-pod-2.yaml><code>pods/qos/qos-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-2-yaml")' title="Copy pods/qos/qos-pod-2.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-2.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>파드의 상세 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력 결과는 쿠버네티스가 파드에 Burstable QoS 클래스를 부여했음을 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></span></span></code></pre></div><p>파드를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=besteffort-qos-클래스가-할당되는-파드-생성>BestEffort QoS 클래스가 할당되는 파드 생성</h2><p>파드에 QoS 클래스 BestEffort를 제공하려면, 파드의 컨테이너에
메모리 또는 CPU의 상한이나 요청량이 없어야 한다.</p><p>컨테이너가 하나인 파드의 구성 파일이다. 해당 컨테이너는 메모리 또는 CPU의
상한이나 요청량을 갖지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/qos/qos-pod-3.yaml download=pods/qos/qos-pod-3.yaml><code>pods/qos/qos-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-3-yaml")' title="Copy pods/qos/qos-pod-3.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-3.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>파드의 상세 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력 결과는 쿠버네티스가 파드에 BestEffort QoS 클래스를 부여했음을 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>BestEffort<span style=color:#bbb>
</span></span></span></code></pre></div><p>파드를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=컨테이너가-두-개인-파드-생성>컨테이너가 두 개인 파드 생성</h2><p>컨테이너가 두 개인 파드의 구성 파일이다. 한 컨테이너는 200MiB의 메모리
요청량을 지정한다. 다른 컨테이너는 어떤 요청량이나 상한을 지정하지 않는다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/qos/qos-pod-4.yaml download=pods/qos/qos-pod-4.yaml><code>pods/qos/qos-pod-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-4-yaml")' title="Copy pods/qos/qos-pod-4.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>참고로 이 파드는 Burstable QoS 클래스의 기준을 충족한다. 즉, Guaranteed QoS 클래스에 대한
기준을 충족하지 않으며, 해당 컨테이너 중 하나가 메모리 요청량을 갖는다.</p><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-4.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>파드의 상세 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>출력 결과는 쿠버네티스가 파드에 Burstable QoS 클래스를 부여했음을 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></span></span></code></pre></div><p>파드를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=정리>정리</h2><p>네임스페이스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace qos-example
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=앱-개발자를-위한-문서>앱 개발자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너 및 파드 메모리 리소스 할당</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너 및 파드 CPU 리소스 할당</a></p></li></ul><h3 id=클러스터-관리자를-위한-문서>클러스터 관리자를 위한 문서</h3><ul><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>네임스페이스에 대한 기본 메모리 요청과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>네임스페이스에 대한 기본 CPU 요청과 상한 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>네임스페이스에 대한 메모리의 최소 및 최대 메모리 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>네임스페이스에 대한 CPU의 최소 및 최대 제약 조건 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>네임스페이스에 대한 메모리 및 CPU 쿼터 구성</a></p></li><li><p><a href=/ko/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>네임스페이스에 대한 파드 쿼터 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>API 오브젝트 할당량 구성</a></p></li><li><p><a href=/docs/tasks/administer-cluster/topology-manager/>노드의 토폴로지 관리 정책 제어</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-484833fb880d1e179cc2965d15f84da5>4.5 - 스토리지의 볼륨을 사용하는 파드 구성</h1><p>이 페이지는 스토리지의 볼륨을 사용하는 파드를 구성하는 방법을 설명한다.</p><p>컨테이너 파일 시스템은 컨테이너가 살아있는 동안만 존재한다. 따라서
컨테이너가 종료되고 재시작할 때, 파일 시스템 변경사항이 손실된다. 컨테이너와
독립적이며 보다 일관된 스토리지를 위해 사용자는 <a href=/ko/docs/concepts/storage/volumes/>볼륨</a>을
사용할 수 있다. 이것은 레디스(Redis)와 같은 키-값 저장소나
데이터베이스와 같은 스테이트풀 애플리케이션에 매우 중요하다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=파드에-볼륨-구성>파드에 볼륨 구성</h2><p>이 연습에서는 하나의 컨테이너를 실행하는 파드를 생성한다. 이 파드는
컨테이너가
종료되고, 재시작 하더라도 파드의 수명동안 지속되는 <a href=/ko/docs/concepts/storage/volumes/#emptydir>emptyDir</a>
유형의 볼륨이 있다.
파드의 구성 파일은 다음과 같다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/storage/redis.yaml download=pods/storage/redis.yaml><code>pods/storage/redis.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-redis-yaml")' title="Copy pods/storage/redis.yaml to clipboard"></img></div><div class=includecode id=pods-storage-redis-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>파드 생성</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/redis.yaml
</span></span></code></pre></div></li><li><p>파드의 컨테이너가 Running 중인지 확인하고, 파드의 변경사항을
지켜본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod redis --watch
</span></span></code></pre></div><p>출력은 이와 유사하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>redis     1/1       Running   <span style=color:#666>0</span>          13s
</span></span></code></pre></div></li><li><p>다른 터미널에서 실행 중인 컨테이너의 셸을 획득한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</span></span></code></pre></div></li><li><p>셸에서 <code>/data/redis</code> 로 이동하고, 파일을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data# <span style=color:#a2f>cd</span> /data/redis/
</span></span><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>echo</span> Hello &gt; test-file
</span></span></code></pre></div></li><li><p>셸에서 실행 중인 프로세스 목록을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# apt-get update
</span></span><span style=display:flex><span>root@redis:/data/redis# apt-get install procps
</span></span><span style=display:flex><span>root@redis:/data/redis# ps aux
</span></span></code></pre></div><p>출력은 이와 유사하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
</span></span><span style=display:flex><span>redis        <span style=color:#666>1</span>  0.1  0.1  <span style=color:#666>33308</span>  <span style=color:#666>3828</span> ?        Ssl  00:46   0:00 redis-server *:6379
</span></span><span style=display:flex><span>root        <span style=color:#666>12</span>  0.0  0.0  <span style=color:#666>20228</span>  <span style=color:#666>3020</span> ?        Ss   00:47   0:00 /bin/bash
</span></span><span style=display:flex><span>root        <span style=color:#666>15</span>  0.0  0.0  <span style=color:#666>17500</span>  <span style=color:#666>2072</span> ?        R+   00:48   0:00 ps aux
</span></span></code></pre></div></li><li><p>셸에서 Redis 프로세스를 강제종료(kill)한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>kill</span> &lt;pid&gt;
</span></span></code></pre></div><p>여기서 <code>&lt;pid></code>는 Redis 프로세스 ID(PID) 이다.</p></li><li><p>원래 터미널에서, Redis 파드의 변경을 지켜본다. 결국,
다음과 유사한 것을 보게 될 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      READY     STATUS     RESTARTS   AGE
</span></span><span style=display:flex><span>redis     1/1       Running    <span style=color:#666>0</span>          13s
</span></span><span style=display:flex><span>redis     0/1       Completed  <span style=color:#666>0</span>         6m
</span></span><span style=display:flex><span>redis     1/1       Running    <span style=color:#666>1</span>         6m
</span></span></code></pre></div></li></ol><p>이때, 컨테이너는 종료되고 재시작된다. 이는
Redis 파드의
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>restartPolicy</a>는
<code>Always</code> 이기 때문이다.</p><ol><li><p>재시작된 컨테이너의 셸을 획득한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</span></span></code></pre></div></li><li><p>셸에서 <code>/data/redis</code> 로 이동하고, <code>test-file</code> 이 여전히 존재하는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>cd</span> /data/redis/
</span></span><span style=display:flex><span>root@redis:/data/redis# ls
</span></span><span style=display:flex><span>test-file
</span></span></code></pre></div></li><li><p>이 연습을 위해 생성한 파드를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod redis
</span></span></code></pre></div></li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#volume-v1-core>볼륨</a>을 참고한다.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>파드</a>을 참고한다.</p></li><li><p>쿠버네티스는 <code>emptyDir</code> 이 제공하는 로컬 디스크 스토리지뿐만 아니라,
중요한 데이터에 선호하는 GCE의 PD, EC2의 EBS를 포함해서
네트워크 연결 스토리지(NAS) 솔루션을 지원하며,
노드의 디바이스 마운트, 언마운트와 같은 세부사항을 처리한다.
자세한 내용은 <a href=/ko/docs/concepts/storage/volumes/>볼륨</a>을 참고한다.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-528d2422215cb9632b7b45e886b023b5>4.6 - 스토리지로 퍼시스턴트볼륨(PersistentVolume)을 사용하도록 파드 설정하기</h1><p>이 페이지는 스토리지에 대해
<a class=glossary-tooltip title='컨테이너의 볼륨으로 마운트될 수 있도록 퍼시스턴트볼륨(PersistentVolume)에 정의된 스토리지 리소스를 요청한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=퍼시스턴트볼륨클레임(PersistentVolumeClaim)>퍼시스턴트볼륨클레임(PersistentVolumeClaim)</a>을
사용하도록 파드를 설정하는 방법을 보여준다.
과정의 요약은 다음과 같다.</p><ol><li><p>클러스터 관리자로서, 물리적 스토리지와 연결되는 퍼시스턴트볼륨을
생성한다. 볼륨을 특정 파드와 연결하지 않는다.</p></li><li><p>그 다음 개발자 / 클러스터 사용자의 역할로서, 적합한
퍼시스턴트볼륨에 자동으로 바인딩되는 퍼시스턴트볼륨클레임을
생성한다.</p></li><li><p>스토리지에 대해 위의 퍼시스턴트볼륨클레임을 사용하는 파드를 생성한다.</p></li></ol><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><p>사용자는 노드가 단 하나만 있는 쿠버네티스 클러스터가 필요하고,
<a class=glossary-tooltip title='쿠버네티스 클러스터와 통신하기 위한 커맨드라인 툴.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>
커맨드라인 툴이 사용자의 클러스터와 통신할 수 있도록 설정되어 있어야 한다. 만약 사용자가
아직 단일 노드 클러스터를 가지고 있지 않다면, <a href=/ko/docs/tasks/tools/#minikube>Minikube</a>를
사용하여 클러스터 하나를 생성할 수 있다.</p></li><li><p><a href=https://minikube.sigs.k8s.io/docs/>퍼시스턴트 볼륨</a>의
관련 자료에 익숙해지도록 한다.</p></li></ul><h2 id=사용자-노드에-index-html-파일-생성하기>사용자 노드에 index.html 파일 생성하기</h2><p>사용자 클러스터의 단일 노드에 연결되는 셸을 연다. 셸을 여는 방법은
클러스터 설정에 따라 달라진다. 예를 들어 Minikube를 사용하는 경우,
<code>minikube ssh</code> 명령어를 입력하여 노드로 연결되는 셸을 열 수 있다.</p><p>해당 노드의 셸에서 <code>/mnt/data</code> 디렉터리를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 사용자 노드에서 슈퍼유저로 명령을 수행하기 위하여</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;sudo&#34;를 사용한다고 가정한다</span>
</span></span><span style=display:flex><span>sudo mkdir /mnt/data
</span></span></code></pre></div><p><code>/mnt/data</code> 디렉터리에서 <code>index.html</code> 파일을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 이번에도 사용자 노드에서 슈퍼유저로 명령을 수행하기 위하여</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;sudo&#34;를 사용한다고 가정한다</span>
</span></span><span style=display:flex><span>sudo sh -c <span style=color:#b44>&#34;echo &#39;Hello from Kubernetes storage&#39; &gt; /mnt/data/index.html&#34;</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 사용자 노드에서 <code>sudo</code> 이외의 슈퍼유저 접근 툴을 사용하는 경우,
<code>sudo</code> 를 해당 툴의 이름으로 바꾸면, 동일하게 작업을 수행할 수 있다.</div><p><code>index.html</code> 파일이 존재하는지 테스트한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /mnt/data/index.html
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>Hello from Kubernetes storage
</code></pre><p>이제 사용자 노드에서 셸을 종료해도 된다.</p><h2 id=퍼시스턴트볼륨-생성하기>퍼시스턴트볼륨 생성하기</h2><p>이 예제에서, 사용자는 <em>hostPath</em> 퍼시스턴트볼륨을 생성한다. 쿠버네티스는 단일 노드에서의
개발과 테스트를 위해 hostPath를 지원한다. hostPath 퍼시스턴트볼륨은
네트워크로 연결된 스토리지를 모방하기 위해, 노드의 파일이나 디렉터리를 사용한다.</p><p>운영 클러스터에서, 사용자가 hostPath를 사용하지는 않는다. 대신, 클러스터 관리자는
Google Compute Engine 영구 디스크, NFS 공유 또는 Amazone Elastic
Block Store 볼륨과 같은 네트워크 자원을 프로비저닝한다. 클러스터 관리자는
<a href=/docs/reference/generated/kubernetes-api/v1.25/#storageclass-v1-storage>스토리지클래스(StorageClasses)</a>를
사용하여
<a href=/blog/2016/10/dynamic-provisioning-and-storage-in-kubernetes>동적 프로비저닝</a>을 설정할 수도 있다.</p><p>hostPath 퍼시스턴트볼륨의 설정 파일은 아래와 같다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/storage/pv-volume.yaml download=pods/storage/pv-volume.yaml><code>pods/storage/pv-volume.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-pv-volume-yaml")' title="Copy pods/storage/pv-volume.yaml to clipboard"></img></div><div class=includecode id=pods-storage-pv-volume-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>local<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/mnt/data&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>설정 파일에 클러스터 노드의 <code>/mnt/data</code> 에 볼륨이 있다고
지정한다. 또한 설정에서 볼륨 크기를 10 기가바이트로 지정하고 단일 노드가
읽기-쓰기 모드로 볼륨을 마운트할 수 있는 <code>ReadWriteOnce</code> 접근 모드를 지정한다. 여기서는
퍼시스턴트볼륨클레임의 <a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%81%B4%EB%9E%98%EC%8A%A4>스토리지클래스 이름</a>을
<code>manual</code> 로 정의하며, 퍼시스턴트볼륨클레임의 요청을
이 퍼시스턴트볼륨에 바인딩하는 데 사용한다.</p><p>퍼시스턴트볼륨을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/pv-volume.yaml
</span></span></code></pre></div><p>퍼시스턴트볼륨에 대한 정보를 조회한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pv task-pv-volume
</span></span></code></pre></div><p>결과는 퍼시스턴트볼륨의 <code>STATUS</code> 가 <code>Available</code> 임을 보여준다. 이는
아직 퍼시스턴트볼륨클레임이 바인딩되지 않았다는 것을 의미한다.</p><pre><code>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE
task-pv-volume   10Gi       RWO           Retain          Available             manual                   4s
</code></pre><h2 id=퍼시스턴트볼륨클레임-생성하기>퍼시스턴트볼륨클레임 생성하기</h2><p>다음 단계는 퍼시스턴트볼륨클레임을 생성하는 단계이다. 파드는 퍼시스턴트볼륨클레임을
사용하여 물리적인 스토리지를 요청한다. 이 예제에서, 사용자는 적어도
하나 이상의 노드에 대해 읽기-쓰기 접근을 지원하며 최소 3 기가바이트의 볼륨을 요청하는
퍼시스턴트볼륨클레임을 생성한다.</p><p>퍼시스턴트볼륨클레임에 대한 설정 파일은 다음과 같다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/storage/pv-claim.yaml download=pods/storage/pv-claim.yaml><code>pods/storage/pv-claim.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-pv-claim-yaml")' title="Copy pods/storage/pv-claim.yaml to clipboard"></img></div><div class=includecode id=pods-storage-pv-claim-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>3Gi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>퍼시스턴트볼륨클레임을 생성한다.</p><pre><code>kubectl apply -f https://k8s.io/examples/pods/storage/pv-claim.yaml
</code></pre><p>사용자가 퍼시스턴트볼륨클레임을 생성한 후에, 쿠버네티스 컨트롤 플레인은
클레임의 요구사항을 만족하는 퍼시스턴트볼륨을 찾는다. 컨트롤 플레인이
동일한 스토리지클래스를 갖는 적절한 퍼시스턴트볼륨을 찾으면,
볼륨에 클레임을 바인딩한다.</p><p>퍼시스턴트볼륨을 다시 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pv task-pv-volume
</span></span></code></pre></div><p>이제 결과는 <code>STATUS</code> 가 <code>Bound</code> 임을 보여준다.</p><pre><code>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM                   STORAGECLASS   REASON    AGE
task-pv-volume   10Gi       RWO           Retain          Bound     default/task-pv-claim   manual                   2m
</code></pre><p>퍼시스턴트볼륨클레임을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pvc task-pv-claim
</span></span></code></pre></div><p>결과는 퍼시스턴트볼륨클레임이 사용자의 퍼시스턴트볼륨인 <code>task-pv-volume</code> 에
바인딩되어 있음을 보여준다.</p><pre><code>NAME            STATUS    VOLUME           CAPACITY   ACCESSMODES   STORAGECLASS   AGE
task-pv-claim   Bound     task-pv-volume   10Gi       RWO           manual         30s
</code></pre><h2 id=파드-생성하기>파드 생성하기</h2><p>다음 단계는 볼륨으로 퍼시스턴트볼륨클레임을 사용하는 파드를 만드는 단계이다.</p><p>파드에 대한 설정 파일은 다음과 같다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/storage/pv-pod.yaml download=pods/storage/pv-pod.yaml><code>pods/storage/pv-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-pv-pod-yaml")' title="Copy pods/storage/pv-pod.yaml to clipboard"></img></div><div class=includecode id=pods-storage-pv-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http-server&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/usr/share/nginx/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>파드의 설정 파일은 퍼시스턴트볼륨클레임을 지정하지만,
퍼시스턴트볼륨을 지정하지는 않는다는 것을 유념하자. 파드의 관점에서 볼때,
클레임은 볼륨이다.</p><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/pv-pod.yaml
</span></span></code></pre></div><p>파드의 컨테이너가 실행 중임을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod task-pv-pod
</span></span></code></pre></div><p>사용자 파드에서 구동되고 있는 컨테이너에 셸로 접근한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it task-pv-pod -- /bin/bash
</span></span></code></pre></div><p>사용자의 셸에서, nginx가 hostPath 볼륨으로부터 <code>index.html</code> 파일을
제공하는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 이전 단계에서 &#34;kubectl exec&#34; 명령을 실행한 root 셸 안에서 </span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 다음의 3개 명령을 실행해야 한다.</span>
</span></span><span style=display:flex><span>apt update
</span></span><span style=display:flex><span>apt install curl
</span></span><span style=display:flex><span>curl http://localhost/
</span></span></code></pre></div><p>결과는 hostPath 볼륨에 있는 <code>index.html</code> 파일에 사용자가 작성한 텍스트를
보여준다.</p><pre><code>Hello from Kubernetes storage
</code></pre><p>만약 사용자가 위와 같은 메시지를 확인하면, 파드가 퍼시스턴트볼륨클레임의 스토리지를
사용하도록 성공적으로 설정한 것이다.</p><h2 id=정리하기>정리하기</h2><p>파드, 퍼시스턴트볼륨클레임, 퍼시스턴트볼륨을 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod task-pv-pod
</span></span><span style=display:flex><span>kubectl delete pvc task-pv-claim
</span></span><span style=display:flex><span>kubectl delete pv task-pv-volume
</span></span></code></pre></div><p>만약 클러스터의 노드에 대한 셸이 열려져 있지 않은 경우,
이전과 동일한 방식으로 새로운 셸을 연다.</p><p>사용자 노드의 셸에서, 생성한 파일과 디렉터리를 제거한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 사용자 노드에서 슈퍼유저로 명령을 수행하기 위하여</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;sudo&#34;를 사용한다고 가정한다</span>
</span></span><span style=display:flex><span>sudo rm /mnt/data/index.html
</span></span><span style=display:flex><span>sudo rmdir /mnt/data
</span></span></code></pre></div><p>이제 사용자 노드에서 셸을 종료해도 된다.</p><h2 id=하나의-퍼시스턴트볼륨을-두-경로에-마운트하기>하나의 퍼시스턴트볼륨을 두 경로에 마운트하기</h2><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/storage/pv-duplicate.yaml download=pods/storage/pv-duplicate.yaml><code>pods/storage/pv-duplicate.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-pv-duplicate-yaml")' title="Copy pods/storage/pv-duplicate.yaml to clipboard"></img></div><div class=includecode id=pods-storage-pv-duplicate-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># a mount for site-data</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># another mount for nginx config</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/nginx.conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>nginx.conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>test-nfs-claim<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>하나의 퍼시스턴트볼륨을 nginx 컨테이너의 두 경로에 마운트할 수 있다.</p><p><code>/usr/share/nginx/html</code> - 정적 웹사이트 용
<code>/etc/nginx/nginx.conf</code> - 기본 환경 설정 용</p><h2 id=접근-제어>접근 제어</h2><p>그룹 ID(GID)로 설정된 스토리지는 동일한 GID를 사용하는 파드에서만 쓰기
작업을 허용한다. GID가 일치하지 않거나 누락되었을 경우 권한
거부 오류가 발생한다. 사용자와의 조정 필요성을 줄이기 위하여 관리자는
퍼시스턴트 볼륨에 GID로 어노테이션을 달 수 있다. 그 뒤에, 퍼시스턴트볼륨을
사용하는 모든 파드에 대하여 GID가 자동으로 추가된다.</p><p>다음과 같이 <code>pv.beta.kubernetes.io/gid</code> 어노테이션을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pv.beta.kubernetes.io/gid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1234&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>파드가 GID 어노테이션이 있는 퍼시스턴트볼륨을 사용하면, 어노테이션으로
달린 GID가 파드의 보안 컨텍스트에 지정된 GID와 동일한 방식으로
파드의 모든 컨테이너에 적용된다. 파드의 명세 혹은 퍼시스턴트볼륨의
어노테이션으로부터 생성된 모든 GID는, 각 컨테이너에서 실행되는 첫 번째
프로세스에 적용된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드가 퍼시스턴트볼륨을 사용할 때, 퍼시스턴트볼륨과 연관된
GID는 파드 리소스 자체에는 존재하지 않는다.</div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트볼륨</a>에 대해 더 보기.</li><li><a href=https://git.k8s.io/design-proposals-archive/storage/persistent-storage.md>퍼시스턴트 스토리지 디자인 문서</a>에 대해 읽어보기.</li></ul><h3 id=reference>Reference</h3><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolume-v1-core>퍼시스턴트볼륨</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumespec-v1-core>PersistentVolumeSpec</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumeclaim-v1-core>퍼시스턴트볼륨클레임</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumeclaimspec-v1-core>PersistentVolumeClaimSpec</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4621938ba53c04a77f51b5938a583439>4.7 - 파드의 스토리지에 프로젝티드 볼륨(Projected Volume)을 사용하도록 구성</h1><p>이 페이지는 <a href=/ko/docs/concepts/storage/volumes/#projected><code>프로젝티드</code></a> 볼륨을 사용하여 여러 기존 볼륨 소스들을
동일한 디렉터리에 마운트하는 방법을 보여준다. 현재 <code>시크릿(secret)</code>, <code>컨피그맵(configMap)</code>, <code>downwardAPI</code>,
그리고 <code>서비스어카운트토큰(serviceAccountToken)</code> 볼륨이 프로젝티드(projected)될 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>서비스어카운트토큰(serviceAccountToken)</code> 은 볼륨 타입이 아니다.</div><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=파드에-프로젝티드-볼륨을-구성>파드에 프로젝티드 볼륨을 구성</h2><p>이 연습에서는 로컬 파일에 유저네임과 패스워드를 <a class=glossary-tooltip title='비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿>시크릿</a>으로 생성한다. 이후 하나의 컨테이너를 포함한 파드를 생성하는 데, 이 때 시크릿을 동일한 공유 디렉터리에 마운트하기 위해 <a href=/ko/docs/concepts/storage/volumes/#projected><code>프로젝티드</code></a> 볼륨을 사용한다.</p><p>다음은 파드의 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/storage/projected.yaml download=pods/storage/projected.yaml><code>pods/storage/projected.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-yaml")' title="Copy pods/storage/projected.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;86400&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pass<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>시크릿을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 유저네임과 패스워드를 포함한 파일들을 생성한다.</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;admin&#34;</span> &gt; ./username.txt
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;1f2d1e2e67df&#34;</span> &gt; ./password.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 생성한 파일들을 시크릿으로 패키징한다.</span>
</span></span><span style=display:flex><span>kubectl create secret generic user --from-file<span style=color:#666>=</span>./username.txt
</span></span><span style=display:flex><span>kubectl create secret generic pass --from-file<span style=color:#666>=</span>./password.txt
</span></span></code></pre></div></li><li><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/projected.yaml
</span></span></code></pre></div></li><li><p>파드의 컨테이너가 정상적으로 실행되는지 확인한 다음, 파드에 대한 변경 사항을
확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --watch pod test-projected-volume
</span></span></code></pre></div><p>The output looks like this:</p><pre tabindex=0><code>NAME                    READY     STATUS    RESTARTS   AGE
test-projected-volume   1/1       Running   0          14s
</code></pre></li><li><p>다른 터미널을 이용해, 실행 중인 컨테이너에 대한 셸을 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it test-projected-volume -- /bin/sh
</span></span></code></pre></div></li><li><p>셸에서 <code>projected-volume</code> 디렉터리에 프로젝티드 소스들이 포함되어 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /projected-volume/
</span></span></code></pre></div></li></ol><h2 id=정리하기>정리하기</h2><p>파드와 시크릿을 제거한다.</p><pre tabindex=0><code class=language-shellxs data-lang=shellxs>kubectl delete pod test-projected-volume
kubectl delete secret user pass
</code></pre><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/storage/volumes/#projected><code>프로젝티드</code></a> 볼륨에 대해 더 알아보기.</li><li><a href=https://git.k8s.io/design-proposals-archive/node/all-in-one-volume.md>all-in-one 볼륨</a> 디자인 문서를 읽기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d385b86a7cb496d3b1c3b2a47280ca70>4.8 - 프라이빗 레지스트리에서 이미지 받아오기</h1><p>이 페이지는 프라이빗 컨테이너 레지스트리나 리포지터리로부터 이미지를 받아오기 위해
<a class=glossary-tooltip title='비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿(Secret)>시크릿(Secret)</a>을 사용하는
파드를 생성하는 방법을 보여준다.
현재 많은 곳에서 프라이빗 레지스트리가 사용되고 있다.
여기서는 예시 레지스트리로 <a href=https://www.docker.com/products/docker-hub>Docker Hub</a>을 사용한다.</p><div class="alert alert-secondary callout third-party-content" role=alert>&#128711; 이 항목은 쿠버네티스에 속하지 않는 써드파티 프로젝트 또는 제품의 링크로 연결됩니다. <a class=alert-more-info href=#third-party-content-disclaimer>추가 정보</a></div><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul></li><li><p>이 실습을 수행하기 위해, <code>docker</code> 명령줄 도구와
<a href=https://docs.docker.com/docker-id/>도커 ID</a> 및 비밀번호가 필요하다.</p></li><li><p>다른 프라이빗 컨테이너 레지스트리를 사용하는 경우,
해당 레지스트리를 위한 명령줄 도구 및 레지스트리 로그인 정보가 필요하다.</p></li></ul><h2 id=도커-허브-로그인>도커 허브 로그인</h2><p>노트북에 프라이빗 이미지를 받아오기 위하여 레지스트리 인증을 필수로 수행해야 한다.</p><p><code>docker</code> 도구를 사용하여 도커 허브에 로그인한다. 자세한 정보는
<a href=https://docs.docker.com/docker-id/#log-in>도커 ID 계정</a>의 <em>로그 인</em> 섹션을 참조한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker login
</span></span></code></pre></div><p>프롬프트가 나타나면, 도커 ID를 입력한 다음, 사용하려는 자격증명(액세스 토큰,
또는 도커 ID의 비밀번호)을 입력한다.</p><p>로그인 프로세스를 수행하면 권한 토큰 정보를 가지고 있는 <code>config.json</code> 파일이 생성되거나 업데이트된다. <a href=/ko/docs/concepts/containers/images#config-json>쿠버네티스가 이 파일을 어떻게 해석하는지</a> 참고한다.</p><p><code>config.json</code> 파일을 확인하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat ~/.docker/config.json
</span></span></code></pre></div><p>하단과 유사한 결과를 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;https://index.docker.io/v1/&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;c3R...zE2&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 도커 자격 증명 저장소를 사용하는 경우, <code>auth</code> 항목이 아닌, 저장소의 이름을 값으로 사용하는 <code>credsStore</code> 항목을 확인할 수 있다.</div><h2 id=registry-secret-existing-credentials>기존의 자격 증명을 기반으로 시크릿 생성하기</h2><p>쿠버네티스 클러스터는 프라이빗 이미지를 받아올 때, 컨테이너 레지스트리에 인증하기 위하여
<code>kubernetes.io/dockerconfigjson</code> 타입의 시크릿을 사용한다.</p><p>만약 이미 <code>docker login</code> 을 수행하였다면,
이 때 생성된 자격 증명을 쿠버네티스 클러스터로 복사할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic regcred <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --from-file<span style=color:#666>=</span>.dockerconfigjson<span style=color:#666>=</span>&lt;path/to/.docker/config.json&gt; <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --type<span style=color:#666>=</span>kubernetes.io/dockerconfigjson
</span></span></code></pre></div><p>오브젝트에 대한 더 세밀한 제어(새로운 시크릿에 대한 네임스페이스나 레이블을 지정하는 등)가 필요할 경우,
시크릿을 사용자 정의한 후에 저장할 수도 있다.
다음을 확인하자.</p><ul><li>데이터 항목의 이름을 <code>.dockerconfigjson</code> 으로 설정한다</li><li>도커 구성 파일을 base64로 인코딩하고 그 문자열을 <code>data[".dockerconfigjson"]</code>
필드에 자르지 않고 한 줄로 이어서 붙여넣는다</li><li><code>type</code> 을 <code>kubernetes.io/dockerconfigjson</code> 으로 설정한다</li></ul><p>예:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myregistrykey<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>awesomeapps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockerconfigjson<span style=color:#bbb>
</span></span></span></code></pre></div><p>만약 <code>error: no objects passed to create</code> 메세지가 출력될 경우, base64로 인코딩된 문자열이 유효하지 않음을 의미한다.
또한 <code>Secret "myregistrykey" is invalid: data[.dockerconfigjson]: invalid value ...</code> 메세지가 출력될 경우,
base64로 인코딩된 문자열이 정상적으로 디코딩되었으나, <code>.docker/config.json</code> 파일로 파싱되지 못한 것을 의미한다.</p><h2 id=커맨드-라인에서-자격-증명을-통하여-시크릿-생성하기>커맨드 라인에서 자격 증명을 통하여 시크릿 생성하기</h2><p><code>regcred</code> 라는 이름의 시크릿을 생성하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry regcred --docker-server<span style=color:#666>=</span>&lt;your-registry-server&gt; --docker-username<span style=color:#666>=</span>&lt;your-name&gt; --docker-password<span style=color:#666>=</span>&lt;your-pword&gt; --docker-email<span style=color:#666>=</span>&lt;your-email&gt;
</span></span></code></pre></div><p>아래의 각 항목에 대한 설명을 참고한다.</p><ul><li><code>&lt;your-registry-server></code> 은 프라이빗 도커 저장소의 FQDN 주소이다.
도커허브(DockerHub)는 <code>https://index.docker.io/v1/</code> 를 사용한다.</li><li><code>&lt;your-name></code> 은 도커 사용자의 계정이다.</li><li><code>&lt;your-pword></code> 은 도커 사용자의 비밀번호이다.</li><li><code>&lt;your-email></code> 은 도커 사용자의 이메일 주소이다.</li></ul><p>이를 통해 <code>regcred</code> 라는 시크릿으로 클러스터 내에서 도커 자격 증명을 생성했다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 커맨드 라인에서 시크릿을 입력하는 경우, 보호되지 않는 셸 히스토리에 내용이 저장될 수 있으며,
이러한 시크릿들은 <code>kubectl</code> 이 구동 중인 동안 사용자의 PC의 다른 사용자들에게
보일 수도 있다.</div><h2 id=시크릿-regcred-검증하기>시크릿 <code>regcred</code> 검증하기</h2><p>방금 생성한 <code>regcred</code> 시크릿의 내용을 확인하기 위하여, YAML 형식으로 시크릿을 확인하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret regcred --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>결과는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockerconfigjson<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>.dockerconfigjson</code> 필드의 값은 도커 자격 증명의 base64 인코딩 결과이다.</p><p><code>.dockerconfigjson</code> 필드의 값을 확인하기 위하여, 시크릿 데이터를 읽을 수 있는
형식으로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret regcred --output<span style=color:#666>=</span><span style=color:#b44>&#34;jsonpath={.data.\.dockerconfigjson}&#34;</span> | base64 --decode
</span></span></code></pre></div><p>결과는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;auths&#34;</span>:{<span style=color:green;font-weight:700>&#34;your.private.registry.example.com&#34;</span>:{<span style=color:green;font-weight:700>&#34;username&#34;</span>:<span style=color:#b44>&#34;janedoe&#34;</span>,<span style=color:green;font-weight:700>&#34;password&#34;</span>:<span style=color:#b44>&#34;xxxxxxxxxxx&#34;</span>,<span style=color:green;font-weight:700>&#34;email&#34;</span>:<span style=color:#b44>&#34;jdoe@example.com&#34;</span>,<span style=color:green;font-weight:700>&#34;auth&#34;</span>:<span style=color:#b44>&#34;c3R...zE2&#34;</span>}}}
</span></span></code></pre></div><p><code>auth</code> 필드의 값을 확인하기 위하여, base64로 인코딩된 데이터를 읽을 수 있는 형식으로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;c3R...zE2&#34;</span> | base64 --decode
</span></span></code></pre></div><p>결과로, 사용자 이름과 비밀번호가 <code>:</code> 로 연결되어 아래와 같이 표현된다.</p><pre tabindex=0><code class=language-none data-lang=none>janedoe:xxxxxxxxxxx
</code></pre><p>참고로 시크릿 데이터에는 사용자의 로컬에 있는 <code>~/.docker/config.json</code> 파일과 유사한 인증 토큰이 포함되어 있다.</p><p>이를 통해 <code>regcred</code> 라는 시크릿으로 클러스터 내에서 도커 자격 증명을 생성했다.</p><h2 id=시크릿을-사용하는-파드-생성하기>시크릿을 사용하는 파드 생성하기</h2><p>다음은 <code>regcred</code> 에 있는 도커 자격 증명에 접근해야 하는 예제 파드의 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/private-reg-pod.yaml download=pods/private-reg-pod.yaml><code>pods/private-reg-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-private-reg-pod-yaml")' title="Copy pods/private-reg-pod.yaml to clipboard"></img></div><div class=includecode id=pods-private-reg-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>&lt;your-private-image&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imagePullSecrets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>위 파일을 컴퓨터에 다운로드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -L -O my-private-reg-pod.yaml https://k8s.io/examples/pods/private-reg-pod.yaml
</span></span></code></pre></div><p><code>my-private-reg-pod.yaml</code> 파일 안에서, <code>&lt;your-private-image></code> 값을 다음과 같은 프라이빗 저장소 안의 이미지 경로로 변경한다.</p><pre tabindex=0><code class=language-none data-lang=none>your.private.registry.example.com/janedoe/jdoe-private:v1
</code></pre><p>프라이빗 저장소에서 이미지를 받아오기 위하여, 쿠버네티스에서 자격 증명이 필요하다.
구성 파일의 <code>imagePullSecrets</code> 필드를 통해 쿠버네티스가
<code>regcred</code> 라는 시크릿으로부터 자격 증명을 가져올 수 있다.</p><p>시크릿을 사용해서 파드를 생성하고, 파드가 실행되는지 확인하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f my-private-reg-pod.yaml
</span></span><span style=display:flex><span>kubectl get pod private-reg
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/configuration/secret/>시크릿</a>에 대해 더 배워 보기<ul><li>또는
<a href=/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>Secret</a> API 레퍼런스 읽어보기</li></ul></li><li><a href=/ko/docs/concepts/containers/images/#%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B9%97-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%8A%B8%EB%A6%AC-%EC%82%AC%EC%9A%A9>프라이빗 레지스트리 사용</a>에 대해 더 배워 보기.</li><li><a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>서비스 어카운트에 풀 시크릿(pull secret) 추가하기</a>에 대해 더 배워 보기.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/#-em-secret-docker-registry-em->kubectl create secret docker-registry</a>에 대해 읽어보기.</li><li>파드의 <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#containers>컨테이너 정의</a>의 <code>imagePullSecrets</code> 필드에 대해 읽어보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fc3f4777ae8ea685d2b54e175277ac01>4.9 - 노드 어피니티를 사용해 노드에 파드 할당</h1><p>이 문서는 쿠버네티스 클러스터의 특정 노드에 노드 어피니티를 사용해 쿠버네티스 파드를 할당하는
방법을 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.10.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=노드에-레이블-추가>노드에 레이블 추가</h2><ol><li><p>클러스터의 노드를 레이블과 함께 나열하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>결과는 아래와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      STATUS    ROLES    AGE     VERSION        LABELS
</span></span><span style=display:flex><span>worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker0
</span></span><span style=display:flex><span>worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
</span></span><span style=display:flex><span>worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</span></span></code></pre></div></li><li><p>노드 한 개를 선택하고, 레이블을 추가하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</span></span></code></pre></div><p><code>&lt;your-node-name></code> 는 선택한 노드의 이름이다.</p></li><li><p>선택한 노드가 <code>disktype=ssd</code> 레이블을 갖고 있는지 확인하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>결과는 아래와 같다.</p><pre tabindex=0><code>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype=ssd,kubernetes.io/hostname=worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker2
</code></pre><p>위의 결과에서, <code>worker0</code> 노드에 <code>disktype=ssd</code> 레이블이 있는 것을
확인할 수 있다.</p></li></ol><h2 id=필수적인-노드-어피니티를-사용해-파드-스케줄하기>필수적인 노드 어피니티를 사용해 파드 스케줄하기</h2><p>이 매니페스트는 <code>disktype: ssd</code> 라는 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 노드 어피니티를 가진 파드를 설명한다.
파드가 <code>disktype=ssd</code> 레이블이 있는 노드에만 스케줄될 것이라는 것을 의미한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/pod-nginx-required-affinity.yaml download=pods/pod-nginx-required-affinity.yaml><code>pods/pod-nginx-required-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-required-affinity-yaml")' title="Copy pods/pod-nginx-required-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-required-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- ssd            <span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>매니페스트를 적용하여 선택한 노드에 스케줄된 파드를
생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-required-affinity.yaml
</span></span></code></pre></div></li><li><p>파드가 선택한 노드에서 실행 중인지 확인하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><p>결과는 아래와 같다.</p><pre tabindex=0><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li></ol><h2 id=선호하는-노드-어피니티를-사용해-파드-스케줄하기>선호하는 노드 어피니티를 사용해 파드 스케줄하기</h2><p>이 매니페스트는 <code>disktype: ssd</code> 라는 <code>preferredDuringSchedulingIgnoredDuringExecution</code> 노드 어피니티를 가진 파드를 설명한다.
파드가 <code>disktype=ssd</code> 레이블이 있는 노드를 선호한다는 것을 의미한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/pod-nginx-preferred-affinity.yaml download=pods/pod-nginx-preferred-affinity.yaml><code>pods/pod-nginx-preferred-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-preferred-affinity-yaml")' title="Copy pods/pod-nginx-preferred-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-preferred-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- ssd          <span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>매니페스트를 적용하여 선택한 노드에 스케줄된 파드를
생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-preferred-affinity.yaml
</span></span></code></pre></div></li><li><p>파드가 선택한 노드에서 실행 중인지 확인하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><p>결과는 아래와 같다.</p><pre tabindex=0><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li></ol><h2 id=다음-내용>다음 내용</h2><p><a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EB%85%B8%EB%93%9C-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0>노드 어피니티</a>에
대해 더 알아보기.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bbc17480da6d051c696489654c64064a>4.10 - 노드에 파드 할당</h1><p>이 문서는 쿠버네티스 클러스터의 특정 노드에 쿠버네티스 파드를 할당하는
방법을 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=노드에-레이블-추가>노드에 레이블 추가</h2><ol><li><p>클러스터의 <a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>를 레이블과 함께 나열하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>결과는 아래와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      STATUS    ROLES    AGE     VERSION        LABELS
</span></span><span style=display:flex><span>worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker0
</span></span><span style=display:flex><span>worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
</span></span><span style=display:flex><span>worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</span></span></code></pre></div></li><li><p>노드 한 개를 선택하고, 레이블을 추가하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</span></span></code></pre></div><p><code>&lt;your-node-name></code>는 선택한 노드의 이름이다.</p></li><li><p>선택한 노드가 <code>disktype=ssd</code> 레이블을 갖고 있는지 확인하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>결과는 아래와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      STATUS    ROLES    AGE     VERSION        LABELS
</span></span><span style=display:flex><span>worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype<span style=color:#666>=</span>ssd,kubernetes.io/hostname<span style=color:#666>=</span>worker0
</span></span><span style=display:flex><span>worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
</span></span><span style=display:flex><span>worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</span></span></code></pre></div><p>위의 결과에서, <code>worker0</code> 노드에 <code>disktype=ssd</code> 레이블이 있는 것을
확인할 수 있다.</p></li></ol><h2 id=선택한-노드에-스케줄되도록-파드-생성하기>선택한 노드에 스케줄되도록 파드 생성하기</h2><p>이 파드 구성 파일은 <code>disktype: ssd</code>라는 선택하는 노드 셀렉터를 가진 파드를
설명한다.
즉, <code>disktype=ssd</code> 레이블이 있는 노드에 파드가 스케줄될 것이라는
것을 의미한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-yaml")' title="Copy pods/pod-nginx.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>구성 파일을 사용해서 선택한 노드로 스케줄되도록 파드를
생성하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/pod-nginx.yaml
</span></span></code></pre></div></li><li><p>파드가 선택한 노드에서 실행 중인지 확인하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><p>결과는 아래와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
</span></span><span style=display:flex><span>nginx    1/1       Running   <span style=color:#666>0</span>          13s    10.200.0.4   worker0
</span></span></code></pre></div></li></ol><h2 id=특정-노드에-스케줄되도록-파드-생성하기>특정 노드에 스케줄되도록 파드 생성하기</h2><p><code>nodeName</code> 설정을 통해 특정 노드로 파드를 배포할 수 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/pod-nginx-specific-node.yaml download=pods/pod-nginx-specific-node.yaml><code>pods/pod-nginx-specific-node.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-specific-node-yaml")' title="Copy pods/pod-nginx-specific-node.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-specific-node-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>foo-node<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 특정 노드에 파드 스케줄</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>설정 파일을 사용해 <code>foo-node</code> 노드에 파드를 스케줄되도록 만들어 보자.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블과 셀렉터</a>에 대해 배우기.</li><li><a href=/ko/docs/concepts/architecture/nodes/>노드</a>에 대해 배우기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1e7baac1825631a5af5d2aebcf059249>4.11 - 초기화 컨테이너에 대한 구성</h1><p>이 페이지는 애플리케이션 실행 전에 파드를 초기화하기 위해 어떻게 초기화 컨테이너를
구성해야 하는지 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=초기화-컨테이너를-갖는-파드-생성>초기화 컨테이너를 갖는 파드 생성</h2><p>이 연습에서 하나의 애플리케이션 컨테이너와 하나의 초기화 컨테이너를 갖는
파드를 생성한다. 초기화 컨테이너는 애플리케이션 시작
전에 실행을 종료한다.</p><p>아래는 해당 파드의 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/init-containers.yaml download=pods/init-containers.yaml><code>pods/init-containers.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-init-containers-yaml")' title="Copy pods/init-containers.yaml to clipboard"></img></div><div class=includecode id=pods-init-containers-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 이 컨테이너들은 파드 초기화 중에 실행된다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>install<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- wget<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-O&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/work-dir/index.html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- http://info.cern.ch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/work-dir&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>Default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이 구성 파일에서, 파드가 가진 볼륨을 초기화
컨테이너와 애플리케이션 컨테이너가 공유하는 것을 볼 수 있다.</p><p>초기화 컨테이너는 공유된 볼륨을
<code>/work-dir</code> 에 마운트하고, 애플리케이션 컨테이너는 공유된 볼륨을
<code>/usr/share/nginx/html</code> 에 마운트한다. 초기화 컨테이너는 다음 명령을 실행 후
종료한다.</p><pre><code>wget -O /work-dir/index.html http://info.cern.ch
</code></pre><p>초기화 컨테이너는 nginx 서버의 루트 디렉터리 내 <code>index.html</code> 파일을
저장한다.</p><p>파드를 생성한다.</p><pre><code>kubectl apply -f https://k8s.io/examples/pods/init-containers.yaml
</code></pre><p>nginx 컨테이너가 실행 중인지 확인한다.</p><pre><code>kubectl get pod init-demo
</code></pre><p>출력 결과는 nginx 컨테이너가 실행 중임을 보여준다.</p><pre><code>NAME        READY     STATUS    RESTARTS   AGE
init-demo   1/1       Running   0          1m
</code></pre><p>init-demo 파드 내 실행 중인 nginx 컨테이너의 셸을 실행한다.</p><pre><code>kubectl exec -it init-demo -- /bin/bash
</code></pre><p>셸에서 GET 요청을 nginx 서버로 전송한다.</p><pre><code>root@nginx:~# apt-get update
root@nginx:~# apt-get install curl
root@nginx:~# curl localhost
</code></pre><p>출력 결과는 nginx가 초기화 컨테이너에 의해 저장된 웹 페이지를 제공하고 있음을 보여준다.</p><pre><code>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt;
&lt;title&gt;http://info.cern.ch&lt;/title&gt;
&lt;/header&gt;

&lt;h1&gt;http://info.cern.ch - home of the first website&lt;/h1&gt;
  ...
  &lt;li&gt;&lt;a href=&quot;http://info.cern.ch/hypertext/WWW/TheProject.html&quot;&gt;Browse the first website&lt;/a&gt;&lt;/li&gt;
  ...
</code></pre><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/access-application-cluster/communicate-containers-same-pod-shared-volume/>같은 파드 내 실행 중인 컨테이너들간 통신</a>에
대해 배우기.</li><li><a href=/ko/docs/concepts/workloads/pods/init-containers/>초기화 컨테이너</a>에 대해 배우기.</li><li><a href=/ko/docs/concepts/storage/volumes/>볼륨</a>에 대해 배우기.</li><li><a href=/ko/docs/tasks/debug/debug-application/debug-init-containers/>초기화 컨테이너 디버깅</a>에 대해 배우기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-18935633a984586fbb68b727f3f339bb>4.12 - 파드에 유저 네임스페이스 사용하기</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [alpha]</code></div><p>이 페이지는 스테이트리스(stateless) 파드에 유저 네임스페이스를 구성하는 방법을 다룬다. 이를 통해
컨테이너 내부에서 실행 중인 유저를 호스트의 유저로부터 분리할 수
있다.</p><p>컨테이너에서 루트로 실행되는 프로세스는 호스트에서 다른(루트가 아닌) 유저로 실행할 수
있다. 즉, 프로세스는 유저 네임스페이스 내부의 작업에 대한
모든 권한을 갖지만 네임스페이스 외부의 작업에 대해서는
권한이 없다.</p><p>이 기능을 사용하여 손상된 컨테이너가 호스트 또는 동일한 노드의 다른 파드에 미칠
피해를 줄일 수 있다. 유저 네임스페이스를 이용하면,
<strong>HIGH</strong> 또는 <strong>CRITICAL</strong> 로 분류되는 여러 <a href=https://github.com/kubernetes/enhancements/tree/217d790720c5aef09b8bd4d6ca96284a0affe6c2/keps/sig-node/127-user-namespaces#motivation>보안 취약점</a>을
보완할 수 있다. 유저 네임스페이스는 향후 발생할 수 있는 여러 취약점도
완화시킬 것으로 예상된다.</p><p>유저 네임스페이스를 사용하지 않고 루트로 실행하는 컨테이너는
컨테이너 브레이크아웃(breakout)이 발생하면 노드의 루트 권한을 갖는다. 그리고 컨테이너에
어떤 기능이 부여되어 있다면 해당 기능은 호스트에서도 유효하다. 유저 네임스페이스를
이용한다면 전혀 해당되지 않는 내용이다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같아야 함. 버전: v1.25.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><div class="alert alert-secondary callout third-party-content" role=alert>&#128711; 이 항목은 쿠버네티스에 속하지 않는 써드파티 프로젝트 또는 제품의 링크로 연결됩니다. <a class=alert-more-info href=#third-party-content-disclaimer>추가 정보</a></div><ul><li>노드의 운영체제는 리눅스를 사용한다.</li><li>호스트에서 커맨드를 exec 할 수 있어야 한다.</li><li>파드 내부로 exec 할 수 있어야 한다.</li><li>기능 게이트 'UserNamespacesStatelessPodsSupport'를 활성화해야 한다.</li></ul><p>추가적으로, 쿠버네티스 스테이트리스(stateless) 파드에서
이 기능을 사용하려면
<a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>에서 지원이 필요하다.</p><ul><li>CRI-O: v1.25는 유저 네임스페이스를 지원한다.</li></ul><p><strong>컨테이너 런타임이 유저 네임스페이스를 지원하지 않으면,
새 <code>pod.spec</code> 필드는 별다른 경고 없이 무시되고 파드는 유저 네임스페이스 없이 생성된다</strong> 는
사실을 명심한다.</p><h2 id=create-pod>유저 네임스페이스를 사용하는 파드를 동작시키기</h2><p>스테이트리스 파드의 유저 네임스페이스는 <code>.spec</code>의 <code>hostUsers</code> 필드를
<code>false</code>로 설정하여 사용할 수 있다. 다음은 예시이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/user-namespaces-stateless.yaml download=pods/user-namespaces-stateless.yaml><code>pods/user-namespaces-stateless.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-user-namespaces-stateless-yaml")' title="Copy pods/user-namespaces-stateless.yaml to clipboard"></img></div><div class=includecode id=pods-user-namespaces-stateless-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>userns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostUsers</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;infinity&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>클러스터에 파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/user-namespaces-stateless.yaml
</span></span></code></pre></div></li><li><p>컨테이너에 연결하고 <code>readlink /proc/self/ns/user</code>를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it userns bash
</span></span></code></pre></div></li></ol><p>그리고 명령을 실행한다. 결과는 다음과 유사하다.</p><pre tabindex=0><code class=language-none data-lang=none>readlink /proc/self/ns/user
user:[4026531837]
cat /proc/self/uid_map
0          0 4294967295
</code></pre><p>그런 다음 호스트에서 셸을 열고 동일한 명령을 실행한다.</p><p>결과는 분명 다를 것이다. 이는 호스트와 파드가 다른 유저 네임스페이스를 사용하고 있음을
의미한다. 유저 네임스페이스를 따로 만들지 않으면 호스트와 파드는 동일한
유저 네임스페이스를 사용한다.</p><p>유저 네임스페이스 내에서 kubelet을 실행하고 있다면,
파드에서 실행한 명령의 결과와 호스트에서 실행한 결과를 비교한다.</p><pre tabindex=0><code class=language-none data-lang=none>readlink /proc/$pid/ns/user
user:[4026534732]
</code></pre><p><code>$pid</code>은 kubelet의 PID로 대체한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-42a59b878d4c58e5c6f4bb87483dda93>4.13 - 스태틱(static) 파드 생성하기</h1><p><em>스태틱 파드</em> 는 <a class=glossary-tooltip title='쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 서버'>API 서버</a>
없이 특정 노드에 있는 kubelet 데몬에 의해
직접 관리된다.
컨트롤 플레인에 의해 관리되는 파드(예를 들어 <a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a>)와는 달리,
kubelet 이 각각의 스태틱 파드를 감시한다.
(만약 실패할 경우 다시 구동한다.)</p><p>스태틱 파드는 항상 특정 노드에 있는 하나의 <a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>에 매여 있다.</p><p>Kubelet 은 각각의 스태틱 파드에 대하여 쿠버네티스 API 서버에서 <a class=glossary-tooltip title='Kubelet의 스태틱 파드(Static Pod)를 추적하는 API 서버 내부의 오브젝트.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-mirror-pod' target=_blank aria-label='미러 파드(mirror pod)'>미러 파드(mirror pod)</a>를
생성하려고 자동으로 시도한다.
즉, 노드에서 구동되는 파드는 API 서버에 의해서 볼 수 있지만,
API 서버에서 제어될 수는 없다.
파드 이름에는 노드 호스트 이름 앞에 하이픈을 붙여 접미사로 추가된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 만약 클러스터로 구성된 쿠버네티스를 구동하고 있고, 스태틱 파드를 사용하여
모든 노드에서 파드를 구동하고 있다면,
스태틱 파드를 사용하는 대신 <a class=glossary-tooltip title='파드의 복제본을 클러스터 노드 집합에서 동작하게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋(DaemonSet)>데몬셋(DaemonSet)</a>
을 사용하는 것이 바람직하다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 스태틱 파드의 <code>spec</code>은 다른 API 오브젝트(예를 들면,
<a class=glossary-tooltip title='파드에서 실행 중인 프로세스를 위한 신원(identity)을 제공한다.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=서비스어카운트>서비스어카운트</a>,
<a class=glossary-tooltip title='키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>,
<a class=glossary-tooltip title='비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿>시크릿</a>, 등)가 참조할 수 없다.</div><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><p>이 페이지는 파드를 실행하기 위해 <a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>를 사용하며,
노드에서 Fedora 운영 체제를 구동하고 있다고 가정한다.
다른 배포판이나 쿠버네티스 설치 지침과는 다소 상이할 수 있다.</p><h2 id=static-pod-creation>스태틱 파드 생성하기</h2><p><a href=/ko/docs/tasks/configure-pod-container/static-pod/#configuration-files>파일 시스템이 호스팅하는 구성 파일</a>이나 <a href=/ko/docs/tasks/configure-pod-container/static-pod/#pods-created-via-http>웹이 호스팅하는 구성 파일</a>을 사용하여 스태틱 파드를 구성할 수 있다.</p><h3 id=configuration-files>파일시스템이 호스팅 하는 스태틱 파드 매니페스트</h3><p>매니페스트는 특정 디렉터리에 있는 JSON 이나 YAML 형식의 표준 파드 정의이다.
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>kubelet 구성 파일</a>의 <code>staticPodPath: &lt;the directory></code> 필드를 사용하자.
명시한 디렉터리를 정기적으로 스캔하여, 디렉터리 안의 YAML/JSON 파일이 생성되거나 삭제되었을 때 스태틱 파드를 생성하거나 삭제한다.
Kubelet 이 특정 디렉터리를 스캔할 때 점(.)으로 시작하는 단어를 무시한다는 점을 유의하자.</p><p>예를 들어, 다음은 스태틱 파드로 간단한 웹 서버를 구동하는 방법을 보여준다.</p><ol><li><p>스태틱 파드를 실행할 노드를 선택한다. 이 예제에서는 <code>my-model</code> 이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ssh my-node1
</span></span></code></pre></div></li><li><p><code>/etc/kubernetes/manifests</code> 와 같은 디렉터리를 선택하고 웹 서버 파드의 정의를 해당 위치에, 예를 들어 <code>/etc/kubernetes/manifests/static-web.yaml</code> 에 배치한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  <span style=color:#080;font-style:italic># kubelet 이 동작하고 있는 노드에서 이 명령을 수행한다.</span>
</span></span><span style=display:flex><span>mkdir -p /etc/kubernetes/manifests/
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;/etc/kubernetes/manifests/static-web.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: static-web
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    role: myrole
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: web
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>      ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - name: web
</span></span></span><span style=display:flex><span><span style=color:#b44>          containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>          protocol: TCP
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div></li><li><p>노드에서 kubelet 실행 시에 <code>--pod-manifest-path=/etc/kubernetes/manifests/</code> 와 같이 인자를 제공하여 해당 디렉터리를 사용하도록 구성한다. Fedora 의 경우 이 줄을 포함하기 위하여 <code>/etc/kubernetes/kubelet</code> 파일을 다음과 같이 수정한다.</p><pre tabindex=0><code>KUBELET_ARGS=&#34;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --pod-manifest-path=/etc/kubernetes/manifests/&#34;
</code></pre><p>혹은 <a href=/docs/reference/config-api/kubelet-config.v1beta1/>kubelet 구성 파일</a>에
<code>staticPodPath: &lt;the directory></code> 필드를 추가한다.</p></li><li><p>kubelet을 재시작한다. Fedora의 경우 아래와 같이 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># kubelet 이 동작하고 있는 노드에서 이 명령을 수행한다.</span>
</span></span><span style=display:flex><span>systemctl restart kubelet
</span></span></code></pre></div></li></ol><h3 id=pods-created-via-http>웹이 호스팅 하는 스태틱 파드 매니페스트</h3><p>Kubelet은 <code>--manifest-url=&lt;URL></code> 의 인수로 지정된 파일을 주기적으로 다운로드하여
해당 파일을 파드의 정의가 포함된 JSON/YAML 파일로 해석한다.
<a href=#configuration-files>파일시스템이 호스팅 하는 매니페스트</a> 의 작동 방식과
유사하게 kubelet은 스케줄에 맞춰 매니페스트 파일을 다시 가져온다. 스태틱 파드의 목록에
변경된 부분이 있을 경우, kubelet 은 이를 적용한다.</p><p>이 방법을 사용하기 위하여 다음을 수행한다.</p><ol><li><p>kubelet 에게 파일의 URL을 전달하기 위하여 YAML 파일을 생성하고 이를 웹 서버에 저장한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>static-web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>myrole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p>선택한 노드에서 <code>--manifest-url=&lt;manifest-url></code> 을 실행하여 웹 메니페스트를 사용하도록 kubelet을 구성한다. Fedora 의 경우 이 줄을 포함하기 위하여 <code>/etc/kubernetes/kubelet</code> 파일을 수정한다.</p><pre tabindex=0><code>KUBELET_ARGS=&#34;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --manifest-url=&lt;manifest-url&gt;&#34;
</code></pre></li><li><p>Kubelet을 재시작한다. Fedora의 경우 아래와 같이 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># kubelet 이 동작하고 있는 노드에서 이 명령을 수행한다.</span>
</span></span><span style=display:flex><span>systemctl restart kubelet
</span></span></code></pre></div></li></ol><h2 id=behavior-of-static-pods>스태틱 파드 행동 관찰하기</h2><p>Kubelet 을 시작하면, 정의된 모든 스태틱 파드가 자동으로 시작된다.
스태틱 파드를 정의하고, kubelet을 재시작했으므로, 새로운 스태틱
파드가 이미 실행 중이어야 한다.</p><p>(노드에서) 구동되고 있는 (스태틱 파드를 포함한) 컨테이너들을 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># kubelet 이 동작하고 있는 노드에서 이 명령을 수행한다.</span>
</span></span><span style=display:flex><span>crictl ps
</span></span></code></pre></div><p>결과는 다음과 유사하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>CONTAINER       IMAGE                                 CREATED           STATE      NAME    ATTEMPT    POD ID
</span></span></span><span style=display:flex><span><span style=color:#888>129fd7d382018   docker.io/library/nginx@sha256:...    11 minutes ago    Running    web     0          34533c6729106
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>crictl</code>은 이미지 URI와 SHA-256 체크섬을 출력한다. <code>NAME</code>은 다음과 같을 것이다.
<code>docker.io/library/nginx@sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31</code></div><p>API 서버에서 미러 파드를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   STATUS    RESTARTS        AGE
static-web   1/1     Running   0               2m
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> API 서버에서 미러 파드를 생성할 수 있는 권한이 kubelet에게 있는지 미리 확인해야 한다. 그렇지 않을 경우 API 서버에 의해서 생성 요청이 거부된다.</div><p>스태틱 파드에 있는 <a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a> 은
미러 파드로 전파된다. <a class=glossary-tooltip title='사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=셀렉터>셀렉터</a> 등을
통하여 이러한 레이블을 사용할 수 있다.</p><p>만약 API 서버로부터 미러 파드를 지우기 위하여 <code>kubectl</code> 을 사용하려 해도,
kubelet 은 스태틱 파드를 지우지 <em>않는다.</em></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod static-web
</span></span></code></pre></div><pre tabindex=0><code>pod &#34;static-web&#34; deleted
</code></pre><p>파드가 여전히 구동 중인 것을 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   STATUS    RESTARTS   AGE
static-web   1/1     Running   0          4s
</code></pre><p>kubelet 이 구동 중인 노드로 돌아가서 컨테이너를 수동으로 중지할 수 있다.
일정 시간이 지나면, kubelet이 파드를 자동으로 인식하고 다시 시작하는
것을 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># kubelet 이 동작하고 있는 노드에서 이 명령을 수행한다.</span>
</span></span><span style=display:flex><span>crictl stop 129fd7d382018 <span style=color:#080;font-style:italic># 예제를 수행하는 사용자의 컨테이너 ID로 변경한다.</span>
</span></span><span style=display:flex><span>sleep <span style=color:#666>20</span>
</span></span><span style=display:flex><span>crictl ps
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>CONTAINER       IMAGE                                 CREATED           STATE      NAME    ATTEMPT    POD ID
</span></span></span><span style=display:flex><span><span style=color:#888>89db4553e1eeb   docker.io/library/nginx@sha256:...    19 seconds ago    Running    web     1          34533c6729106
</span></span></span></code></pre></div><h2 id=스태틱-파드의-동적-추가-및-제거>스태틱 파드의 동적 추가 및 제거</h2><p>실행 중인 kubelet 은 주기적으로, 설정된 디렉터리(예제에서는 <code>/etc/kubernetes/manifests</code>)에서 변경 사항을 스캔하고, 이 디렉터리에 새로운 파일이 생성되거나 삭제될 경우, 파드를 생성/삭제 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 예제를 수행하는 사용자가 파일시스템이 호스팅하는 스태틱 파드 설정을 사용한다고 가정한다.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># kubelet 이 동작하고 있는 노드에서 이 명령을 수행한다.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#</span>
</span></span><span style=display:flex><span>mv /etc/kubernetes/manifests/static-web.yaml /tmp
</span></span><span style=display:flex><span>sleep <span style=color:#666>20</span>
</span></span><span style=display:flex><span>crictl ps
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 구동 중인 nginx 컨테이너가 없는 것을 확인한다.</span>
</span></span><span style=display:flex><span>mv /tmp/static-web.yaml  /etc/kubernetes/manifests/
</span></span><span style=display:flex><span>sleep <span style=color:#666>20</span>
</span></span><span style=display:flex><span>crictl ps
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>CONTAINER       IMAGE                                 CREATED           STATE      NAME    ATTEMPT    POD ID
</span></span></span><span style=display:flex><span><span style=color:#888>f427638871c35   docker.io/library/nginx@sha256:...    19 seconds ago    Running    web     1          34533c6729106
</span></span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>5 - 쿠버네티스 오브젝트 관리</h1><div class=lead>쿠버네티스 API와 상호 작용하기 위한 선언적이고 명령적인 패러다임</div></div><div class=td-content><h1 id=pg-df206392be6f4d19bd8da41cee7170fa>5.1 - 구성 파일을 이용한 쿠버네티스 오브젝트의 선언형 관리</h1><p>쿠버네티스 오브젝트는 여러 개의 오브젝트 구성 파일을
디렉터리에 저장하고 필요에 따라 <code>kubectl apply</code>를
사용하여 재귀적으로 오브젝트를 생성하고 업데이트함으로써 생성, 업데이트 및 삭제할 수 있다.
이 방식은 변경사항을 되돌려 오브젝트 구성 파일에 병합하지 않고
활성 오브젝트에 가해진 기록을 유지한다. <code>kubectl diff</code>는 또한
<code>apply</code>가 어떠한 변경사항을 이루어질지에 대한 프리뷰를 제공한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><a href=/ko/docs/tasks/tools/><code>kubectl</code></a>를 설치한다.</p><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=트레이드-오프>트레이드 오프</h2><p><code>kubectl</code> 툴은 세 가지 방식의 오브젝트 관리를 지원한다.</p><ul><li>명령형 커맨드</li><li>명령형 오브젝트 구성</li><li>선언형 오브젝트 구성</li></ul><p>오브젝트 관리 방식의 종류별 장단점에 대한 논의는 <a href=/ko/docs/concepts/overview/working-with-objects/object-management/>쿠버네티스 오브젝트 관리</a>를
참고한다.</p><h2 id=개요>개요</h2><p>선언형 오브젝트 구성은 쿠버네티스 오브젝트 정의와
구성에 대한 확실한 이해가 필요하다. 아직 그렇지 못하다면,
먼저 다음 문서를 읽고 이해한다.</p><ul><li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-command/>명령형 커맨드를 사용한 쿠버네티스 오브젝트 관리하기</a></li><li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-config/>구성 파일을 사용한 쿠버네티스 오브젝트 명령형 관리</a></li></ul><p>다음은 이 문서에서 사용되는 용어에 대한 정의이다.</p><ul><li><em>오브젝트 구성 파일 / 구성 파일</em>: 쿠버네티스 오브젝트에 대한
구성을 정의하는 하나의 파일. 이 주제는 어떻게
<code>kubectl apply</code>에 구성 파일을 전달하는지에 대해 보여준다. 구성 파일은 일반적으로 Git과 같은, 소스 컨트롤에 저장된다.</li><li><em>활성 오브젝트 구성 / 활성 구성</em>: 쿠버네티스 클러스터에 의해 관측된
오브젝트에 대한 활성 구성 값. 이것들은 쿠버네티스 클러스터 저장소에 유지된다.
일반적으로 etcd가 사용된다.</li><li><em>선언형 구성 작성자 / 선언형 작성자</em>: 활성 오브젝트를 업데이트해 주는
사람이나 소프트웨어. 이 주제에서 언급하는 활성 작성자는 오브젝트 구성 파일에 변경을 가하고
<code>kubectl apply</code>를 실행하여 변경사항을 기록한다.</li></ul><h2 id=오브젝트-생성-방법>오브젝트 생성 방법</h2><p>기존에 존재하는 것을 제외한, 지정한 디렉터리 내 구성 파일에 의해 정의된 모든 오브젝트를 생성하기 위해 <code>kubectl apply</code>를
사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f &lt;디렉터리&gt;/
</span></span></code></pre></div><p>이것은 각 오브젝트에 대해 <code>kubectl.kubernetes.io/last-applied-configuration: '{...}'</code>
어노테이션을 설정한다. 해당 어노테이션은 오브젝트를 생성하기 위해 사용했던
오브젝트 구성 파일의 내용을 포함한다. </p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 재귀적으로 디렉터리를 처리하기 위해서 <code>-R</code> 플래그를 추가한다.</div><p>다음은 오브젝트 구성 파일에 대한 예시이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/simple_deployment.yaml download=application/simple_deployment.yaml><code>application/simple_deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-simple-deployment-yaml")' title="Copy application/simple_deployment.yaml to clipboard"></img></div><div class=includecode id=application-simple-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>생성될 오브젝트를 출력하려면 <code>kubectl diff</code>를 실행한다. </p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl diff -f https://k8s.io/examples/application/simple_deployment.yaml
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p><code>diff</code>는 <code>kube-apiserver</code>의 활성화가 필요한
<a href=/docs/reference/using-api/api-concepts/#dry-run>서버사이드 dry-run</a>을 사용한다.</p><p><code>diff</code> 는 dry-run 모드에서 서버 측 적용 요청을 수행하므로,
<code>PATCH</code>, <code>CREATE</code>, 그리고 <code>UPDATE</code> 권한을 부여해야 한다.
자세한 것은
<a href=/docs/reference/using-api/api-concepts#dry-run-authorization>Dry-Run 인증</a>을 본다.</p></div><p><code>kubectl apply</code>를 사용하여 오브젝트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/simple_deployment.yaml
</span></span></code></pre></div><p><code>kubectl get</code>을 사용하여 활성 구성을 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml
</span></span></code></pre></div><p>출력은 <code>kubectl.kubernetes.io/last-applied-configuration</code> 어노테이션이
활성 구성에 기록된 것을 보여주며, 그것은 구성 파일과 일치한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This is the json representation of simple_deployment.yaml</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># It was written by kubectl apply when the object was created</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.14.2&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=오브젝트-업데이트-방법>오브젝트 업데이트 방법</h2><p>또한 오브젝트가 기존에 존재하더라도 디렉터리 내 정의된 모든 오브젝트를 업데이트하기 위해 <code>kubectl apply</code>를
사용할 수 있다. 이러한 접근방식은 다음을 수행할 수 있게 해준다.</p><ol><li>활성 구성 내 구성 파일에 나타나는 필드 설정</li><li>활성 구성 내 구성 파일로부터 제거된 필드 정리</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl diff -f &lt;디렉터리&gt;/
</span></span><span style=display:flex><span>kubectl apply -f &lt;디렉터리&gt;/
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 재귀적으로 디렉터리를 처리하기 위해서 <code>-R</code>플래그를 추가한다.</div><p>다음은 구성 파일의 예시이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/simple_deployment.yaml download=application/simple_deployment.yaml><code>application/simple_deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-simple-deployment-yaml")' title="Copy application/simple_deployment.yaml to clipboard"></img></div><div class=includecode id=application-simple-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p><code>kubectl apply</code>를 사용하여 오브젝트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/simple_deployment.yaml
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 설명을 위해, 앞선 명령은 디렉터리 대신
하나의 구성 파일을 참조한다.</div><p><code>kubectl get</code>을 사용하여 활성 구성을 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml
</span></span></code></pre></div><p>출력은 <code>kubectl.kubernetes.io/last-applied-configuration</code> 어노테이션이
활성 구성에 기록된 것을 보여주며, 그것은 구성 파일과 일치한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This is the json representation of simple_deployment.yaml</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># It was written by kubectl apply when the object was created</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.14.2&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>kubectl scale</code>을 사용하여 활성 구성 내 <code>replicas</code> 필드를 직접 업데이트한다.
이는 <code>kubectl apply</code>를 사용하지 않는다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p><code>kubectl get</code>을 사용하여 활성 구성을 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment nginx-deployment -o yaml
</span></span></code></pre></div><p>출력은 <code>replicas</code> 필드가 2로 설정된 것을 보여주며, <code>last-applied-configuration</code>
어노테이션은 <code>replicas</code> 필드를 포함하지 않는다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># note that the annotation does not contain replicas</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># because it was not updated through apply</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.14.2&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># written by scale</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>nginx:1.14.2</code>에서 <code>nginx:1.16.1</code>로 이미지를 변경하기 위해 <code>simple_deployment.yaml</code>
구성 파일을 업데이트 하고, <code>minReadySeconds</code> 필드를 삭제한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/update_deployment.yaml download=application/update_deployment.yaml><code>application/update_deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-update-deployment-yaml")' title="Copy application/update_deployment.yaml to clipboard"></img></div><div class=includecode id=application-update-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># update the image</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>구성 파일에 이루어진 변경사항을 적용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl diff -f https://k8s.io/examples/application/update_deployment.yaml
</span></span><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/update_deployment.yaml
</span></span></code></pre></div><p><code>kubectl get</code>을 사용하여 활성 구성을 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f https://k8s.io/examples/application/update_deployment.yaml -o yaml
</span></span></code></pre></div><p>출력은 활성 구성에 다음의 변경사항을 보여준다.</p><ul><li><code>replicas</code> 필드는 <code>kubectl scale</code>에 의해 설정된 값 2를 유지한다.<br>이는 구성 파일에서 생략되었기 때문에 가능하다.</li><li><code>image</code> 필드는 <code>nginx:1.14.2</code>에서 <code>nginx:1.16.1</code>로 업데이트되었다.</li><li><code>last-applied-configuration</code> 어노테이션은 새로운 이미지로 업데이트되었다.</li><li><code>minReadySeconds</code> 필드는 지워졌다.</li><li><code>last-applied-configuration</code> 어노테이션은 더 이상 <code>minReadySeconds</code> 필드를 포함하지 않는다.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># The annotation contains the updated image to nginx 1.11.9,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># but does not contain the updated replicas to 2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.16.1&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Set by `kubectl scale`.  Ignored by `kubectl apply`.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># minReadySeconds cleared by `kubectl apply`</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Set by `kubectl apply`</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 명령형 오브젝트 구성 커맨드 <code>create</code>와 <code>replace</code>와 함께 <code>kubectl apply</code>를
혼합하는 것은 지원하지 않는다. 이는 <code>kubectl apply</code>가 업데이트 사항을 계산하는데 사용하는
<code>kubectl.kubernetes.io/last-applied-configuration</code>을 <code>create</code>와 <code>replace</code>가
유지하지 하지 않기 때문이다.</div><h2 id=오브젝트-삭제-방법>오브젝트 삭제 방법</h2><p><code>kubectl apply</code>에 의해 관리되는 오브젝트를 삭제하는데 2가지 접근 방법이 있다.</p><h3 id=권장-방법-kubectl-delete-f-파일명>권장 방법: <code>kubectl delete -f &lt;파일명></code></h3><p>명령형 커맨드를 사용하여 오브젝트를 수동으로 삭제하는 것이 권장되는 방식인데,
무엇이 삭제되는지에 대해 더 명확하게 나타내므로 사용자가 의도하지 않게
무언가를 삭제할 가능성이 작아지기 때문이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete -f &lt;파일명&gt;
</span></span></code></pre></div><h3 id=대안-kubectl-apply-f-디렉터리-prune-l-your-레이블>대안: <code>kubectl apply -f &lt;디렉터리/> --prune -l your=레이블</code></h3><p>무엇을 하는지 파악하는 경우에만 이를 사용한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> <code>kubectl apply --prune</code>은 알파 상태이며, 후속 릴리스에서는
하위 호환되지 않는 변경 사항이 도입될 수 있다.</div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 이 명령을 사용할 때는 의도하지 않게 오브젝트를 삭제하지 않도록
주의해야만 한다.</div><p><code>kubectl delete</code>에 대한 대안으로, 디렉터리로부터 구성 파일이 삭제된 후에 삭제될 오브젝트를 식별하기 위해 <code>kubectl apply</code>를 사용할 수 있다.
<code>--prune</code>을 사용하여 적용하면 일련의 레이블의 집합과 일치하는
모든 오브젝트에 대해API 서버에 쿼리하고, 반환된 활성 오브젝트
구성을 오브젝트 구성 파일에 일치시키려고 시도한다.
오브젝트가 쿼리에 일치하고, 해당 디렉터리 내 구성 파일이 없고
<code>last-applied-configuration</code>어노테이션이 있는 경우,
삭제된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f &lt;디렉터리/&gt; --prune -l &lt;레이블&gt;
</span></span></code></pre></div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> prune을 사용하여 적용하는 것은 오브젝트 구성 파일을
포함하는 루트 디렉터리에 대해서만 실행해야 한다.
하위 디렉터리에 대해 실행하게 되면,
<code>-l &lt;레이블></code>로 지정된 레이블 셀렉터에 의해 반환되고 하위 디렉터리에 나타나지 않는 경우,
오브젝트가 의도하지 않게 삭제될 수 있다.</div><h2 id=오브젝트-확인-방법>오브젝트 확인 방법</h2><p>활성 오브젝트의 구성을 확인하기 위해 <code>-o yaml</code>과 함께 <code>kubectl get</code>을 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f &lt;파일명|url&gt; -o yaml
</span></span></code></pre></div><h2 id=어떻게-apply가-차이를-계산하고-변경을-병합하는가>어떻게 apply가 차이를 계산하고 변경을 병합하는가</h2><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> <em>patch</em> 는 전체 오브젝트 대신 오브젝트의 특정 필드 범위의 오퍼레이션을 업데이트한다.
이는 먼저 오브젝트를 읽지 않고도 오브젝트의 특정 필드 집합만을
업데이트할 수 있도록 해준다.</div><p><code>kubectl apply</code>가 하나의 오브젝트에 대한 활성 구성을 업데이트할 때,
API 서버에 패치 요청을 보냄으로써 그것을 수행한다.
그 패치는 활성 오브젝트 구성의 특정 필드에 대한 범위의
업데이트로 한정한다. <code>kubectl apply</code> 커맨드는
구성 파일, 활성 구성, 그리고 활성 구성에 저장된
<code>last-applied-configuration</code>어노테이션을 사용하여 이 패치 요청을 계산한다.</p><h3 id=패치-계산-병합>패치 계산 병합</h3><p><code>kubectl apply</code> 명령은
<code>kubectl.kubernetes.io/last-applied-configuration</code> 어노테이션에 구성 파일의 내용을 기록한다.
이것은 구성 파일로부터 제거되었고 활성 구성으로부터 지워질 필요가 있는
필드를 확인하는 데 사용된다. 다음은 어떤 필드가 삭제 또는 설정돼야 하는지
계산하기 위해 사용되는 단계이다.</p><ol><li>삭제할 필드를 계산한다. 이것은 <code>last-applied-configuration</code> 내 존재하고 구성 파일로부터 유실된 필드이다.</li><li>추가 또는 설정되어야 할 필드를 계산한다. 이것은 활성 구성과 불일치하는 값을 가지는 구성 파일 내 존재하는 필드이다.</li></ol><p>다음은 예시이다. 디플로이먼트 오브젝트에 대한 구성 파일이라고 가정한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/update_deployment.yaml download=application/update_deployment.yaml><code>application/update_deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-update-deployment-yaml")' title="Copy application/update_deployment.yaml to clipboard"></img></div><div class=includecode id=application-update-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># update the image</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>또한, 이것은 동일한 디플로이먼트 오브젝트에 대한 활성 구성이라고 가정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># note that the annotation does not contain replicas</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># because it was not updated through apply</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.14.2&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># written by scale</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>다음은 <code>kubectl apply</code>에 의해 수행될 병합 계산이다.</p><ol><li><code>last-applied-configuration</code>으로부터 값을 읽어
구성 파일의 값과 비교하여 삭제할 필드를
계산한다.
<code>last-applied-configuration</code>에 보이는 것과는 무관하게
로컬의 오브젝트 구성 파일 내 null이라고 명시적으로 설정된 필드를 지운다.
이 예시에서, <code>minReadySeconds</code>은
<code>last-applied-configuration</code> 어노테이션 내 나타나지만, 구성 파일 내에는 보여지지 않는다.
<strong>조치:</strong> 활성 구성으로부터 <code>minReadySeconds</code>을 지운다.</li><li>구성 파일로부터 값을 읽어 활성 구성 내 값과
비교하여 설정할 필드를 계산한다. 이 예시에서,
구성 파일 내 <code>image</code> 값은 활성 구성 내 값과 불일치한다.
<strong>조치:</strong> 활성 구성 내 <code>image</code> 값을 설정한다.</li><li>구성 파일의 값과 일치시키기 위해 <code>last-applied-configuration</code>
어노테이션을 설정한다.</li><li>1, 2, 3으로부터의 결과를 API 서버에 단일 패치 요청으로 병합한다.</li></ol><p>다음은 병합의 결과인 활성 구성이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># The annotation contains the updated image to nginx 1.11.9,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># but does not contain the updated replicas to 2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.16.1&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Set by `kubectl scale`.  Ignored by `kubectl apply`.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># minReadySeconds cleared by `kubectl apply`</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Set by `kubectl apply`</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=어떻게-상이한-필드-타입이-병합되는가>어떻게 상이한 필드 타입이 병합되는가</h3><p>구성 파일 내 특정 필드가 필드의 타입에 따라
어떻게 활성 구성과 함께 병합되는가.
여러 가지 필드 타입이 있다.</p><ul><li><p><em>기본(primitives)</em>: 문자열, 숫자 또는 불리언 타입의 필드.
예를 들어, <code>image</code>와 <code>replicas</code>는 기본 필드다. <strong>조치:</strong> 교체.</p></li><li><p><em>맵</em>, 또한 <em>오브젝트</em> 라 칭함: 맵 타입 또는 서브필드를 포함하는 복합 타입의 필드. 예를 들어, <code>레이블</code>,
<code>어노테이션</code>,<code>스펙</code> 및 <code>메타데이터</code>는 모두 맵이다. <strong>조치:</strong> 구성요소 또는 서브필드 병합.</p></li><li><p><em>리스트</em>: 기본타입 또는 맵이 될 수 있는 아이템의 리스트를 포함하는 필드.
예를 들어, <code>컨테이너</code>, <code>포트</code>, 그리고 <code>args</code>는 리스트다. <strong>조치:</strong> 다양함.</p></li></ul><p><code>kubectl apply</code>가 맵 또는 리스트 필드를 업데이트하는 경우,
일반적으로 전체 필드를 교체하는 대신, 개별 부 구성요소를 업데이트한다,
예를 들어, 디플로이먼트에 대한 <code>spec</code>을 병합할 경우, 전체 <code>spec</code>이
교체되지 않는다. 대신 <code>replicas</code>와 같은 <code>spec</code>의 서브필드가
비교되고 병합된다.</p><h3 id=기본-필드에-대한-변경사항-병합하기>기본 필드에 대한 변경사항 병합하기</h3><p>기본 필드는 교체되거나 지워진다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>-</code> 는 값이 사용되지 않기 때문에 "해당 없음"으로 사용된다.</div><table><thead><tr><th>Field in object configuration file</th><th>Field in live object configuration</th><th>Field in last-applied-configuration</th><th>Action</th></tr></thead><tbody><tr><td>Yes</td><td>Yes</td><td>-</td><td>구성 파일 값 활성으로 설정.</td></tr><tr><td>Yes</td><td>No</td><td>-</td><td>활성을 로컬 구성으로 설정.</td></tr><tr><td>No</td><td>-</td><td>Yes</td><td>활성 구성으로부터 지움.</td></tr><tr><td>No</td><td>-</td><td>No</td><td>아무것도 안함. 활성값 유지.</td></tr></tbody></table><h3 id=맵-필드에-변경사항-병합하기>맵 필드에 변경사항 병합하기</h3><p>맵을 요청하는 필드는 서브필드의 각각 또는 맵의 구성요소를 비교함으로써 병합된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>-</code> 는 값이 사용되지 않기 때문에 "해당 없음"으로 사용된다.</div><table><thead><tr><th>Key in object configuration file</th><th>Key in live object configuration</th><th>Field in last-applied-configuration</th><th>Action</th></tr></thead><tbody><tr><td>Yes</td><td>Yes</td><td>-</td><td>서브필드 값 비교.</td></tr><tr><td>Yes</td><td>No</td><td>-</td><td>활성을 로컬 구성으로 설정.</td></tr><tr><td>No</td><td>-</td><td>Yes</td><td>활성 구성으로부터 삭제.</td></tr><tr><td>No</td><td>-</td><td>No</td><td>아무것도 안함. 활성값 유지.</td></tr></tbody></table><h3 id=타입-리스트의-필드에-대한-변경사항-병합하기>타입 리스트의 필드에 대한 변경사항 병합하기</h3><p>리스트에 대한 변경사항을 병합하는 것은 세 가지 전략 중 하나를 사용한다.</p><ul><li>구성요소가 모두 기본형인 경우 리스트를 교체한다.</li><li>복합 구성요소의 리스트에서 개별 구성요소를 병합한다.</li><li>기초 구성요소의 리스트를 병합한다.</li></ul><p>전략에 대한 선택은 필드별로 이루어진다.</p><h4 id=구성요소가-모두-기본형인-경우-리스트-교체>구성요소가 모두 기본형인 경우 리스트 교체</h4><p>기초 필드와 동일한 리스트로 취급한다. 전체 리스트를 교체 또는 삭제한다.
이것은 순서를 유지한다.</p><p><strong>예시:</strong> 파드 내 컨테이너의 <code>args</code> 필드를 업데이트하기 위해 <code>kubectl apply</code>를 사용한다.
이것은 활성 구성 내 <code>args</code>의 값을 구성 파일 내 값으로 설정한다.
활성 구성에 추가했던 이전의 모든 <code>args</code>구성요소들은 유실된다.
구성 파일 내 정의한 <code>args</code> 구성요소의 순서는
활성 구성 내 유지된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># last-applied-configuration value</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;b&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># configuration file value</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># live configuration</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;b&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;d&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># result after merge</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;c&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p><strong>설명:</strong> 병합은 새로운 리스트 값으로 구성 파일 값을 사용했다.</p><h4 id=복합-구성요소-리스트에-대한-개별-구성요소-병합>복합 구성요소 리스트에 대한 개별 구성요소 병합</h4><p>리스트를 맵으로 취급하고 각 구성요소의 특정 필드를 키로 취급한다.
개별 구성요소를 추가, 삭제, 또는 업데이트 한다. 이것은 순서를 보존하지 않는다.</p><p>이 병합 전략은 각 필드에 <code>patchMergeKey</code>라 칭하는 특별한 태그를 사용한다.
<code>patchMergeKey</code>는 쿠버네티스 소스 코드:
<a href=https://github.com/kubernetes/api/blob/d04500c8c3dda9c980b668c57abc2ca61efcf5c4/core/v1/types.go#L2747>types.go</a>
의 각 필드에 대해 정의한다. 맵 리스트를 병합할 때, 주어진 구성요소에 대한 <code>patchMergeKey</code>로
지정한 필드는 해당 구성요소에 대한 맵키와 같이 사용된다.</p><p><strong>예시:</strong> <code>kubectl apply</code>를 사용하여 PodSpec에 대한 <code>containers</code>필드를 업데이트한다.<br>이렇게 하면 각 구성요소가
<code>name</code>별로 키로 되어 있는 맵인 것처럼 리스트를 병합한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># last-applied-configuration value</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.10<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name: nginx-helper-a # key</span>:<span style=color:#bbb> </span>nginx-helper-a; will be deleted in result<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name: nginx-helper-b # key</span>:<span style=color:#bbb> </span>nginx-helper-b; will be retained<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># configuration file value</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.10<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name: nginx-helper-c # key</span>:<span style=color:#bbb> </span>nginx-helper-c; will be added in result<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># live configuration</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.10<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;run&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Field will be retained</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name: nginx-helper-d # key</span>:<span style=color:#bbb> </span>nginx-helper-d; will be retained<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># result after merge</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.10<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Element nginx-helper-a was deleted</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;run&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Field was retained</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-c<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Element was added</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-d<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Element was ignored</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span></code></pre></div><p><strong>설명:</strong></p><ul><li>구성 파일에 "nginx-helper-a"라는 이름을 가진 컨테이너가 나타나지 않았기 때문에
"nginx-helper-a"라는 컨테이너는 삭제되었다.</li><li>"nginx-helper-b"라는 컨테이너는 활성 구성에 <code>args</code>에<br>대한 변경사항을 유지했다. <code>kubectl apply</code>는<br>필드 값이 다름에도 불구하고(구성 파일에 <code>args</code>가 없음) 활성 구성에<br>"nginx-helper-b"가 구성 파일과 동일한
"nginx-helper-b"임을 식별할 수 있었다. 이것은
<code>patchMergeKey</code> 필드 값(이름)이 둘 다 같았기 때문이다..</li><li>"nginx-helper-c"라는 이름의 컨테이너가 활성 구성에 나타나지
않았지만, 구성 파일에 그 이름을 가진 컨테이너가 나타났기 때문에
추가되었다.</li><li>last-applied-configuration에 그 이름을 가진 구성요소가 없었기 때문에
"nginx-helper-d"라는 이름의 컨테이너는 유지되었다.</li></ul><h4 id=기초-구성요소-리스트-병합>기초 구성요소 리스트 병합</h4><p>쿠버네티스 1.5로부터 기초 구성요소 병합하기는 지원되지 않는다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 주어진 필드에 대해 위 전략 중 어떤 것을 선택할지에 대해서는
<a href=https://github.com/kubernetes/api/blob/d04500c8c3dda9c980b668c57abc2ca61efcf5c4/core/v1/types.go#L2748>types.go</a>의 <code>patchStrategy</code> 태그에 의해 제어된다.
타입 필드에 대해 <code>patchStrategy</code>가 지정되지 않으면,
리스트는 대체된다.</div><h2 id=기본-필드값>기본 필드값</h2><p>오브젝트가 생성될 때 값이 지정되지 않는 경우, API 서버는 활성 구성 내
특정 필드를 기본값으로 설정한다.</p><p>다음은 디플로이먼트에 대한 구성 파일이다. 파일에는 <code>strategy</code>가 지정되지 않았다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/simple_deployment.yaml download=application/simple_deployment.yaml><code>application/simple_deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-simple-deployment-yaml")' title="Copy application/simple_deployment.yaml to clipboard"></img></div><div class=includecode id=application-simple-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p><code>kubectl apply</code>를 사용하여 오브젝트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/simple_deployment.yaml
</span></span></code></pre></div><p><code>kubectl get</code>을 사용하여 활성 구성을 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml
</span></span></code></pre></div><p>출력은 API 서버가 활성 구성 내 여러 필드를 기본값으로 설정한 것을 보여준다.
이 필드들은 구성 파일에 지정되지 않았다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted by apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted by apiserver - derived from strategy.type</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxSurge</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RollingUpdate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted by apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted by apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted by apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted by apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span>/dev/termination-log<span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted by apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirst<span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted by apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted by apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted by apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted by apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>패치 요청에서, 패치 요청의 부분으로서 명시적으로 지워지지 않은 경우
기본 처리된 필드는 다시 기본으로 설정되지 않는다.
이것은 다른 필드에 대한 값에 따라 기본 처리된 필드에 대해
예상하지 못한 동작을 유발할 수 있다. 다른 필드가 나중에 변경되면,
그로부터 기본 처리된 것이 명시적으로 지워지지 않은 한
업데이트되지 않을 것이다.</p><p>이러한 사유로, 의도한 값이 서버의 기본값과 일치하더라도,
서버에 의해 기본 처리된 특정 필드는 구성 파일 내
명시적으로 정의할 것을 권고한다. 이렇게 하면
서버에 의해 다시 기본 처리되지 않게 될 충돌하는 값을 보다 쉽게
인식할 수 있도록 해준다.</p><p><strong>Example:</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># last-applied-configuration</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># configuration file</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># updated value</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># live configuration</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RollingUpdate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted value</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb> </span><span style=color:#080;font-style:italic># defaulted value derived from type</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxSurge </span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># result after merge - ERROR!</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type: Recreate # updated value</span>:<span style=color:#bbb> </span>incompatible with rollingUpdate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate: # defaulted value</span>:<span style=color:#bbb> </span>incompatible with &#34;type: Recreate&#34;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxSurge </span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><strong>설명:</strong></p><ol><li>사용자가 <code>strategy.type</code>을 정의하지 않고 디플로이먼트를 생성한다.</li><li>서버는 <code>strategy.type</code>을 <code>RollingUpdate</code>로 기본 설정하고
<code>strategy.rollingUpdate</code>값을 기본 값으로 처리한다.</li><li>사용자가 <code>strategy.type</code>를 <code>Recreate</code>로 변경한다.
서버에서 해당 값이 삭제될 거라 예상하지만 <code>strategy.rollingUpdate</code>값은 기본값으로 남아 있다.<br><code>strategy.rollingUpdate</code>값이 처음에 구성 파일에서 지정되었다면,
이것을 삭제해야 한다는 것이 더 분명했을 것이다.</li><li><code>strategy.rollingUpdate</code>가 지워지지 않았기 때문에 적용은 실패한다.
<code>strategy.rollingupdate</code> 필드는 <code>Recreate</code>의 <code>strategy.type</code>으로 정의될 수 없다.</li></ol><p>권고: 이들 필드는 오브젝트 구성 파일 내 명시적으로 정의돼야 한다.</p><ul><li>디플로이먼트, 스테이트풀셋, 잡, 데몬셋, 레플리카셋 및 레플리케이션컨트롤러와 같은
워크로드에 대한 셀렉터와 파드템플릿 레이블</li><li>디플로이먼트 롤아웃 전략</li></ul><h3 id=서버-기본-필드-또는-다른-작성자에-의해-설정된-필드-지우는-방법>서버 기본 필드 또는 다른 작성자에 의해 설정된 필드 지우는 방법</h3><p>구성 파일 내 나타나지 않는 필드는 그 값을
<code>null</code>로 설정하고 나서 구성 파일을 적용함으로써 지워질 수 있다.
서버가 기본 값을 할당했던 필드에 대해서, 이는 다시 기본 값을
할당하도록 한다.</p><h2 id=구성-파일과-직접-명령형-작성자-간의-필드-소유권을-변경시키는-방법>구성 파일과 직접 명령형 작성자 간의 필드 소유권을 변경시키는 방법</h2><p>개별 오브젝트 필드를 변경시키는 데 사용해야 하는 유일한 방법은 다음과 같다.</p><ul><li><code>kubectl apply</code>를 사용한다.</li><li>구성 파일을 수정하지 않고 활성 구성을 직접 작성한다.
예를 들어, <code>kubectl scale</code>을 사용한다.</li></ul><h3 id=직접-명령형-작성자에서-구성-파일로-소유자-변경하기>직접 명령형 작성자에서 구성 파일로 소유자 변경하기</h3><p>구성 파일에 필드를 추가한다. 해당 필드의 경우
<code>kubectl apply</code>를 거치지 않는 활성 구성에 대해 직접 업데이트를 적용하지 않는다.</p><h3 id=구성-파일에서-직접-명령형-작성자로-소유자-변경하기>구성 파일에서 직접 명령형 작성자로 소유자 변경하기</h3><p>쿠버네티스 1.5로부터 구성 파일에서 명령형 작성자로 소유권을 변경하는데
수동 단계 필요하다.</p><ul><li>구성 파일에서 필드를 제거한다.</li><li>활성 오브젝트 상의 <code>kubectl.kubernetes.io/last-applied-configuration</code> 어노테이션에서 필드를 제거한다.</li></ul><h2 id=관리-방법-변경하기>관리 방법 변경하기</h2><p>쿠버네티스 오브젝트는 한 번에 오직 하나의 방법을 사용하여 관리돼야 한다.
하나의 방법에서 다른 방법으로 전환하는 것은 가능하나, 수동 프로세스이다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 선언형 관리와 함께 명령형 삭제를 사용하는 것은 괜찮다.</div><h3 id=명령형-커맨드-관리에서-오브젝트-구성으로-이전하기>명령형 커맨드 관리에서 오브젝트 구성으로 이전하기</h3><p>명령형 커맨드 관리에서 오브젝트 구성으로 이전하는 것은
여러 수동 단계를 포함한다.</p><ol><li><p>활성 오브젝트를 로컬 구성 파일로 내보낸다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get &lt;종류&gt;/&lt;이름&gt; -o yaml &gt; &lt;종류&gt;_&lt;이름&gt;.yaml
</span></span></code></pre></div></li><li><p>구성 파일에서 수동으로 <code>status</code> 필드를 제거한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubectl apply</code> 구성 파일에 존재한다고 하더라도 상태 필드가 업데이트되지 않기 때문에,
이 단계는 선택적이다.</div></li><li><p>오브젝트의 <code>kubectl.kubernetes.io/last-applied-configuration</code> 어노테이션을 설정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace --save-config -f &lt;종류&gt;_&lt;이름&gt;.yaml
</span></span></code></pre></div></li><li><p>오직 오브젝트를 관리하기 위해 <code>kubectl apply</code>를 사용하도록 프로세스를 변경한다.</p></li></ol><h3 id=명령형-오브젝트-구성에서-선언형-오브젝트-구성으로-이전하기>명령형 오브젝트 구성에서 선언형 오브젝트 구성으로 이전하기</h3><ol><li><p>오브젝트의 <code>kubectl.kubernetes.io/last-applied-configuration</code> 어노테이션을 설정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace --save-config -f &lt;종류&gt;_&lt;이름&gt;.yaml
</span></span></code></pre></div></li><li><p>오직 오브젝트를 관리하기 위해 <code>kubectl apply</code>를 사용하도록 프로세스를 변경한다.</p></li></ol><h2 id=컨트롤러-셀렉터와-파드템플릿-레이블-정의하기>컨트롤러 셀렉터와 파드템플릿 레이블 정의하기</h2><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 컨트롤러에서 셀렉터를 업데이트하는 것은 추천되지 않는다.</div><p>권고되는 접근 방법은 다른 의미론적 의미를 가지지 않고 컨트롤러에 의해서만 사용되는
단일, 불변의 파드템플릿 레이블을 정의하는 것이다.</p><p><strong>예시:</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;apps/v1/deployment/nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;apps/v1/deployment/nginx&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-command/>명령형 커맨드 사용하여 쿠버네티스 오브젝트 관리하기</a></li><li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-config/>구성 파일 사용하여 쿠버네티스 오브젝트 관리하기</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl 명령어 참조</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 API 참조</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-11aa6950fcb203094823c8e2cbdd517f>5.2 - Kustomize를 이용한 쿠버네티스 오브젝트의 선언형 관리</h1><p><a href=https://github.com/kubernetes-sigs/kustomize>Kustomize</a>는
<a href=https://kubectl.docs.kubernetes.io/references/kustomize/glossary/#kustomization>kustomization 파일</a>을
통해 쿠버네티스 오브젝트를 사용자가 원하는 대로 변경하는(customize) 독립형 도구이다.</p><p>1.14 이후로, kubectl도
kustomization 파일을 사용한 쿠버네티스 오브젝트의 관리를 지원한다.
kustomization 파일을 포함하는 디렉터리 내의 리소스를 보려면 다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl kustomize &lt;kustomization_directory&gt;
</span></span></code></pre></div><p>이 리소스를 적용하려면 <code>kubectl apply</code>를 <code>--kustomize</code> 또는 <code>-k</code> 플래그와 함께 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k &lt;kustomization_directory&gt;
</span></span></code></pre></div><h2 id=시작하기-전에>시작하기 전에</h2><p><a href=/ko/docs/tasks/tools/><code>kubectl</code></a>을 설치한다.</p><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=kustomize-개요>Kustomize 개요</h2><p>Kustomize는 쿠버네티스 구성을 사용자 정의화하는 도구이다. 이는 애플리케이션 구성 파일을 관리하기 위해 다음 기능들을 가진다.</p><ul><li>다른 소스에서 리소스 생성</li><li>리소스에 대한 교차 편집 필드 설정</li><li>리소스 집합을 구성하고 사용자 정의</li></ul><h3 id=리소스-생성>리소스 생성</h3><p>컨피그맵과 시크릿은 파드와 같은 다른 쿠버네티스 오브젝트에서 사용되는 설정이나 민감한 데이터를 가지고 있다. 컨피그맵이나 시크릿의 실질적인 소스는 일반적으로 <code>.properties</code> 파일이나 ssh key 파일과 같은 것들은 클러스터 외부에 있다.
Kustomize는 시크릿과 컨피그맵을 파일이나 문자열에서 생성하는 <code>secretGenerator</code>와 <code>configMapGenerator</code>를 가지고 있다.</p><h4 id=configmapgenerator>configMapGenerator</h4><p>파일에서 컨피그맵을 생성하려면 <code>configMapGenerator</code> 내의 <code>files</code> 리스트에 항목을 추가한다. 다음은 하나의 <code>.properties</code> 파일에서 데이터 항목으로 컨피그맵을 생성하는 예제이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># application.properties 파일을 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;application.properties
</span></span></span><span style=display:flex><span><span style=color:#b44>FOO=Bar
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-configmap-1
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - application.properties
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>생성된 컨피그맵은 다음 명령어로 검사할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl kustomize ./
</span></span></code></pre></div><p>생성된 컨피그맵은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>application.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>FOO=Bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1-8mbdf7882g<span style=color:#bbb>
</span></span></span></code></pre></div><p>env 파일에서 컨피그맵을 생성하려면, <code>configMapGenerator</code>의 <code>envs</code> 리스트에 항목을 추가한다. 다음은 <code>.env</code> 파일의 데이터 항목으로 컨피그맵을 생성하는 예시를 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># .env 파일 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;.env
</span></span></span><span style=display:flex><span><span style=color:#b44>FOO=Bar
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-configmap-1
</span></span></span><span style=display:flex><span><span style=color:#b44>  envs:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - .env
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>생성된 컨피그맵은 다음 명령어로 검사할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl kustomize ./
</span></span></code></pre></div><p>생성된 컨피그맵은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>FOO</span>:<span style=color:#bbb> </span>Bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1-42cfbf598f<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>.env</code> 파일의 각 변수는 생성한 컨피그맵에서 분리된 키가 된다. <code>.properties</code> 라는 이름의 파일을 내장하는 이전 예시(그리고 모든 항목들)는 단일 키를 위한 값이므로 이 예시와는 다르다.</div><p>컨피그맵은 문자로된 키-값 쌍들로도 생성할 수 있다. 문자로된 키-값 쌍에서 컨피그맵을 생성하려면, configMapGenerator 내의 <code>literals</code> 리스트에 항목을 추가한다. 다음은 키-값 쌍을 데이터 항목으로 받는 컨피그맵을 생성하는 예제이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-configmap-2
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - FOO=Bar
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>생성된 컨피그맵은 다음 명령어로 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl kustomize ./
</span></span></code></pre></div><p>생성된 컨피그맵은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>FOO</span>:<span style=color:#bbb> </span>Bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-2-g2hdhfc6tk<span style=color:#bbb>
</span></span></span></code></pre></div><p>디플로이먼트에서 생성된 컨피그맵을 사용하기 위해서는, configMapGenerator의 이름을 참조한다. Kustomize는 자동으로 해당 이름을 생성된 이름으로 교체할 것이다.</p><p>다음은 생성된 컨피그맵을 사용하는 디플로이먼트의 예시다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># application.properties 파일을 생성한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>cat &lt;&lt;EOF &gt;application.properties<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>FOO=Bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>EOF<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>cat &lt;&lt;EOF &gt;deployment.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>EOF<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>cat &lt;&lt;EOF &gt;./kustomization.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- deployment.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>configMapGenerator</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>files</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- application.properties<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>EOF<span style=color:#bbb>
</span></span></span></code></pre></div><p>컨피그맵과 디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl kustomize ./
</span></span></code></pre></div><p>생성된 디플로이먼트는 이름을 통해서 생성된 컨피그맵을 참조한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>application.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>FOO=Bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1-g4hk9g2ff8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1-g4hk9g2ff8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=secretgenerator>secretGenerator</h4><p>파일 또는 문자로된 키-값 쌍들로 시크릿을 생성할 수 있다. 파일에서 시크릿을 생성하려면 <code>secretGenerator</code> 내의 <code>files</code> 리스트에 항목을 추가한다. 다음은 파일을 데이터 항목으로 받는 시크릿을 생성하는 예제이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># password.txt 파일을 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./password.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>username=admin
</span></span></span><span style=display:flex><span><span style=color:#b44>password=secret
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>secretGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-secret-1
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - password.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>생성된 시크릿은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password.txt</span>:<span style=color:#bbb> </span>dXNlcm5hbWU9YWRtaW4KcGFzc3dvcmQ9c2VjcmV0Cg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-secret-1-t2kt65hgtb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><p>문자로된 키-값 쌍으로 시크릿을 생성하려면, <code>secretGenerator</code> 내의 <code>literals</code> 리스트에 항목을 추가한다. 다음은 키-값 쌍을 데이터 항목으로 받는 시크릿을 생성하는 예제이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>secretGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-secret-2
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - username=admin
</span></span></span><span style=display:flex><span><span style=color:#b44>  - password=secret
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>생성된 시크릿은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>c2VjcmV0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-secret-2-t52t6g96d8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><p>컨피그맵과 유사하게, 생성된 시크릿도 secretGenerator의 이름을 참조함으로써 디플로이먼트에서 사용될 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># password.txt 파일을 생성한다.</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./password.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>username=admin
</span></span></span><span style=display:flex><span><span style=color:#b44>password=secret
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-app
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    app: my-app
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      app: my-app
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        app: my-app
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: app
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: my-app
</span></span></span><span style=display:flex><span><span style=color:#b44>        volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - name: password
</span></span></span><span style=display:flex><span><span style=color:#b44>          mountPath: /secrets
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: password
</span></span></span><span style=display:flex><span><span style=color:#b44>        secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>          secretName: example-secret-1
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>secretGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-secret-1
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - password.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><h4 id=generatoroptions>generatorOptions</h4><p>생성된 컨피그맵과 시크릿은 콘텐츠 해시 접미사가 추가된다. 이는 콘텐츠가 변경될 때 새로운 컨피그맵 이나 시크릿이 생성되는 것을 보장한다. 접미사를 추가하는 동작을 비활성화하는 방법으로 <code>generatorOptions</code>를 사용할 수 있다. 그밖에, 생성된 컨피그맵과 시크릿에 교차 편집 옵션들을 지정해주는 것도 가능하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-configmap-3
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - FOO=Bar
</span></span></span><span style=display:flex><span><span style=color:#b44>generatorOptions:
</span></span></span><span style=display:flex><span><span style=color:#b44>  disableNameSuffixHash: true
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    type: generated
</span></span></span><span style=display:flex><span><span style=color:#b44>  annotations:
</span></span></span><span style=display:flex><span><span style=color:#b44>    note: generated
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>생성된 컨피그맵을 보려면 <code>kubectl kustomize ./</code>를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>FOO</span>:<span style=color:#bbb> </span>Bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>note</span>:<span style=color:#bbb> </span>generated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>generated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-3<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=교차-편집-필드-설정>교차 편집 필드 설정</h3><p>프로젝트 내 모든 쿠버네티스 리소스에 교차 편집 필드를 설정하는 것은 꽤나 일반적이다.
교차 편집 필드를 설정하는 몇 가지 사용 사례는 다음과 같다.</p><ul><li>모든 리소스에 동일한 네임스페이스를 설정</li><li>동일한 네임 접두사 또는 접미사를 추가</li><li>동일한 레이블들을 추가</li><li>동일한 어노테이션들을 추가</li></ul><p>다음은 예제이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># deployment.yaml을 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: nginx-deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    app: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      app: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        app: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>namespace: my-namespace
</span></span></span><span style=display:flex><span><span style=color:#b44>namePrefix: dev-
</span></span></span><span style=display:flex><span><span style=color:#b44>nameSuffix: &#34;-001&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>commonLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>  app: bingo
</span></span></span><span style=display:flex><span><span style=color:#b44>commonAnnotations:
</span></span></span><span style=display:flex><span><span style=color:#b44>  oncallPager: 800-555-1212
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>이 필드들이 디플로이먼트 리소스에 모두 설정되었는지 보려면 <code>kubectl kustomize ./</code>를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>oncallPager</span>:<span style=color:#bbb> </span><span style=color:#666>800-555-1212</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>bingo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-nginx-deployment-001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>bingo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>oncallPager</span>:<span style=color:#bbb> </span><span style=color:#666>800-555-1212</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>bingo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=리소스-구성과-사용자-정의>리소스 구성과 사용자 정의</h3><p>프로젝트 내 리소스의 집합을 구성하여 이들을 동일한 파일이나 디렉터리 내에서
관리하는 것은 일반적이다.
Kustomize는 서로 다른 파일들로 리소스를 구성하고 패치나 다른 사용자 정의를 이들에 적용하는 것을 제공한다.</p><h4 id=구성>구성</h4><p>Kustomize는 서로 다른 리소스들의 구성을 지원한다. <code>kustomization.yaml</code> 파일 내 <code>resources</code> 필드는 구성 내에 포함하려는 리소스들의 리스트를 정의한다. <code>resources</code> 리스트 내에 리소스의 구성 파일의 경로를 설정한다.
다음 예제는 디플로이먼트와 서비스로 구성된 NGINX 애플리케이션이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># deployment.yaml 파일 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># service.yaml 파일 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Service
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - port: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>    protocol: TCP
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이들을 구성하는 kustomization.yaml 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>- service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p><code>kubectl kustomize ./</code>의 리소스에는 디플로이먼트와 서비스 오브젝트가 모두 포함되어 있다.</p><h4 id=사용자-정의>사용자 정의</h4><p>패치는 리소스에 다른 사용자 정의를 적용하는 데 사용할 수 있다. Kustomize는
<code>patchesStrategicMerge</code>와 <code>patchesJson6902</code>를 통해 서로 다른 패치 메커니즘을 지원한다. <code>patchesStrategicMerge</code>는 파일 경로들의 리스트이다. 각각의 파일은 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/strategic-merge-patch.md>전략적 병합 패치</a>로 분석될 수 있어야 한다. 패치 내부의 네임은 반드시 이미 읽혀진 리소스 네임과 일치해야 한다. 한 가지 일을 하는 작은 패치가 권장된다. 예를 들기 위해 디플로이먼트 레플리카 숫자를 증가시키는 하나의 패치와 메모리 상한을 설정하는 다른 패치를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># deployment.yaml 파일 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># increase_replicas.yaml 패치 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; increase_replicas.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 3
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 다른 패치로 set_memory.yaml 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; set_memory.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>          limits:
</span></span></span><span style=display:flex><span><span style=color:#b44>            memory: 512Mi
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>patchesStrategicMerge:
</span></span></span><span style=display:flex><span><span style=color:#b44>- increase_replicas.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>- set_memory.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>디플로이먼트를 보려면 <code>kubectl kustomize ./</code>를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>512Mi<span style=color:#bbb>
</span></span></span></code></pre></div><p>모든 리소스 또는 필드가 전략적 병합 패치를 지원하는 것은 아니다. 임의의 리소스 내 임의의 필드의 수정을 지원하기 위해,
Kustomize는 <code>patchesJson6902</code>를 통한 <a href=https://tools.ietf.org/html/rfc6902>JSON 패치</a> 적용을 제공한다.
Json 패치의 정확한 리소스를 찾기 위해, 해당 리소스의 group, version, kind, name이
<code>kustomization.yaml</code> 내에 명시될 필요가 있다. 예를 들면, <code>patchesJson6902</code>를 통해
디플로이먼트 오브젝트의 레플리카 개수를 증가시킬 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># deployment.yaml 파일 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># json 패치 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; patch.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>- op: replace
</span></span></span><span style=display:flex><span><span style=color:#b44>  path: /spec/replicas
</span></span></span><span style=display:flex><span><span style=color:#b44>  value: 3
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># kustomization.yaml 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>
</span></span></span><span style=display:flex><span><span style=color:#b44>patchesJson6902:
</span></span></span><span style=display:flex><span><span style=color:#b44>- target:
</span></span></span><span style=display:flex><span><span style=color:#b44>    group: apps
</span></span></span><span style=display:flex><span><span style=color:#b44>    version: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>    kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  path: patch.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p><code>kubectl kustomize ./</code>를 실행하여 <code>replicas</code> 필드가 갱신되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>패치 기능에 추가로 Kustomize는 패치를 생성하지 않고 컨테이너 이미지를 사용자 정의하거나 다른 오브젝트의 필드 값을 컨테이너에 주입하는
기능도 제공한다. 예를 들어 <code>kustomization.yaml</code>의 <code>images</code> 필드에 신규 이미지를 지정하여 컨테이너에서 사용되는 이미지를 변경할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>images:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  newName: my.image.registry/nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  newTag: 1.4.0
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>사용된 이미지가 갱신되었는지 확인하려면 <code>kubectl kustomize ./</code>를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my.image.registry/nginx:1.4.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>가끔, 파드 내에서 실행되는 애플리케이션이 다른 오브젝트의 설정 값을 사용해야 할 수도 있다. 예를 들어,
디플로이먼트 오브젝트의 파드는 Env 또는 커맨드 인수로 해당 서비스 네임을 읽어야 한다고 하자.
<code>kustomization.yaml</code> 파일에 <code>namePrefix</code> 또는 <code>nameSuffix</code>가 추가되면 서비스 네임이 변경될 수 있다.
커맨드 인수 내에 서비스 네임을 하드 코딩하는 것을 권장하지 않는다. 이 용도에서 Kustomize는 <code>vars</code>를 통해 containers에 서비스 네임을 삽입할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># deployment.yaml 파일 생성(문서 구분 기호를 따옴표로 감쌈)</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;&#39;EOF&#39; &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        command: [&#34;start&#34;, &#34;--host&#34;, &#34;$(MY_SERVICE_NAME)&#34;]
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># service.yaml 파일 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Service
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - port: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>    protocol: TCP
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>namePrefix: dev-
</span></span></span><span style=display:flex><span><span style=color:#b44>nameSuffix: &#34;-001&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>- service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>
</span></span></span><span style=display:flex><span><span style=color:#b44>vars:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: MY_SERVICE_NAME
</span></span></span><span style=display:flex><span><span style=color:#b44>  objref:
</span></span></span><span style=display:flex><span><span style=color:#b44>    kind: Service
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p><code>kubectl kustomize ./</code>를 실행하면 <code>dev-my-nginx-001</code>로 컨테이너에 삽입된 서비스 네임을 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-my-nginx-001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- start<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- --host<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- dev-my-nginx-001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=base와-overlay>Base와 Overlay</h2><p>Kustomize는 <strong>base</strong> 와 <strong>overlay</strong> 의 개념을 가지고 있다. <strong>base</strong> 는 <code>kustomization.yaml</code> 과 함께 사용되는 디렉터리다. 이는
사용자 정의와 관련된 리소스들의 집합을 포함한다. <code>kustomization.yaml</code>의 내부에 표시되는 base는 로컬 디렉터리이거나 원격 리포지터리의 디렉터리가
될 수 있다. <strong>overlay</strong> 는 <code>kustomization.yaml</code>이 있는 디렉터리로
다른 kustomization 디렉터리들을 <code>bases</code>로 참조한다. <strong>base</strong> 는 overlay에 대해서 알지 못하며 여러 overlay들에서 사용될 수 있다.
한 overlay는 다수의 base들을 가질 수 있고, base들에서 모든 리소스를 구성할 수 있으며,
이들의 위에 사용자 정의도 가질 수 있다.</p><p>다음은 base에 대한 예이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># base를 가지는 디렉터리 생성</span>
</span></span><span style=display:flex><span>mkdir base
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># base/deployment.yaml 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; base/deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># base/service.yaml 파일 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; base/service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Service
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - port: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>    protocol: TCP
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># base/kustomization.yaml 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; base/kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>- service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>이 base는 다수의 overlay에서 사용될 수 있다. 다른 <code>namePrefix</code> 또는 다른 교차 편집 필드들을
서로 다른 overlay에 추가할 수 있다. 다음 예제는 동일한 base를 사용하는 두 overlay들이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir dev
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; dev/kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>bases:
</span></span></span><span style=display:flex><span><span style=color:#b44>- ../base
</span></span></span><span style=display:flex><span><span style=color:#b44>namePrefix: dev-
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mkdir prod
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; prod/kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>bases:
</span></span></span><span style=display:flex><span><span style=color:#b44>- ../base
</span></span></span><span style=display:flex><span><span style=color:#b44>namePrefix: prod-
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><h2 id=kustomize를-이용하여-오브젝트를-적용-확인-삭제하는-방법>Kustomize를 이용하여 오브젝트를 적용/확인/삭제하는 방법</h2><p><code>kustomization.yaml</code>에서 관리되는 리소스를 인식하려면 <code>kubectl</code> 명령어에 <code>--kustomize</code> 나 <code>-k</code>를 사용한다.
<code>-k</code>는 다음과 같이 kustomization 디렉터리를 가리키고 있어야 한다는 것을 주의한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k &lt;kustomization directory&gt;/
</span></span></code></pre></div><p>다음 <code>kustomization.yaml</code>이 주어지고,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># deployment.yaml 파일 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># kustomization.yaml 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>namePrefix: dev-
</span></span></span><span style=display:flex><span><span style=color:#b44>commonLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>  app: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>디플로이먼트 오브젝트 <code>dev-my-nginx</code>를 적용하려면 다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; kubectl apply -k ./
</span></span><span style=display:flex><span>deployment.apps/dev-my-nginx created
</span></span></code></pre></div><p>디플로이먼트 오브젝트 <code>dev-my-nginx</code>를 보려면 다음 명령어들 중에 하나를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -k ./
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe -k ./
</span></span></code></pre></div><p>다음 명령을 실행해서 디플로이먼트 오브젝트 <code>dev-my-nginx</code> 를 매니페스트가 적용된 경우의 클러스터 상태와 비교한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl diff -k ./
</span></span></code></pre></div><p>디플로이먼트 오브젝트 <code>dev-my-nginx</code>를 삭제하려면 다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; kubectl delete -k ./
</span></span><span style=display:flex><span>deployment.apps <span style=color:#b44>&#34;dev-my-nginx&#34;</span> deleted
</span></span></code></pre></div><h2 id=kustomize-기능-리스트>Kustomize 기능 리스트</h2><table><thead><tr><th>필드</th><th>유형</th><th>설명</th></tr></thead><tbody><tr><td>namespace</td><td>string</td><td>모든 리소스에 네임스페이스 추가</td></tr><tr><td>namePrefix</td><td>string</td><td>모든 리소스 네임에 이 필드의 값이 접두사로 추가된다</td></tr><tr><td>nameSuffix</td><td>string</td><td>모든 리소스 네임에 이 필드의 값이 접미사로 추가된다</td></tr><tr><td>commonLabels</td><td>map[string]string</td><td>모든 리소스와 셀렉터에 추가될 레이블</td></tr><tr><td>commonAnnotations</td><td>map[string]string</td><td>모든 리소스에 추가될 어노테이션</td></tr><tr><td>resources</td><td>[]string</td><td>이 리스트 내 각각의 항목은 반드시 존재하는 리소스 구성 파일로 해석되어야 한다.</td></tr><tr><td>configMapGenerator</td><td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/configmapargs.go#L7>ConfigMapArgs</a></td><td>이 리스트의 각 항목은 컨피그맵을 생성한다.</td></tr><tr><td>secretGenerator</td><td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/secretargs.go#L7>SecretArgs</a></td><td>이 리스트의 각 항목은 시크릿을 생성한다.</td></tr><tr><td>generatorOptions</td><td><a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/generatoroptions.go#L7>GeneratorOptions</a></td><td>모든 컨피그맵 및 시크릿 생성자(generator)의 동작을 수정한다.</td></tr><tr><td>bases</td><td>[]string</td><td>이 리스트 내 각각의 항목은 kustomization.yaml 파일을 가지는 디렉터리로 해석되어야 한다.</td></tr><tr><td>patchesStrategicMerge</td><td>[]string</td><td>이 리스트 내 각각의 항목은 쿠버네티스 오브젝트의 전략적 병합 패치로 해석되어야 한다.</td></tr><tr><td>patchesJson6902</td><td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/patch.go#L10>Patch</a></td><td>이 리스트 내 각각의 항목은 쿠버네티스 오브젝트와 Json 패치로 해석되어야 한다.</td></tr><tr><td>vars</td><td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/var.go#L19>Var</a></td><td>각각의 항목은 한 리소스의 필드에서 텍스트를 캡쳐한다.</td></tr><tr><td>images</td><td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/image.go#L8>Image</a></td><td>각각의 항목은 패치를 생성하지 않고 하나의 이미지에 대한 name, tags 그리고/또는 digest를 수정한다.</td></tr><tr><td>configurations</td><td>[]string</td><td>이 리스트 내 각각의 항목은 <a href=https://github.com/kubernetes-sigs/kustomize/tree/master/examples/transformerconfigs>Kustomize 변환 설정</a>을 포함하는 파일로 해석되어야 한다.</td></tr><tr><td>crds</td><td>[]string</td><td>이 리스트 내 각각의 항목은 쿠버네티스 타입에 대한 OpenAPI 정의 파일로 해석되어야 한다.</td></tr></tbody></table><h2 id=다음-내용>다음 내용</h2><ul><li><a href=https://github.com/kubernetes-sigs/kustomize>Kustomize</a></li><li><a href=https://kubectl.docs.kubernetes.io>Kubectl 문서</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl 커맨드 참조</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 API 참조</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-80c83fe9b80d0fef2681c8d59c0aa197>5.3 - 명령형 커맨드를 이용한 쿠버네티스 오브젝트 관리하기</h1><p>쿠버네티스 오브젝트는 <code>kubectl</code> 커맨드 라인 툴 속에 내장된 명령형 커맨드를 이용함으로써
바로 신속하게 생성, 업데이트 및 삭제할 수 있다. 이 문서는 어떻게 커맨드가 구성되어 있으며,
이를 사용하여 활성 오브젝트를 어떻게 관리하는 지에 대해 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><a href=/ko/docs/tasks/tools/><code>kubectl</code></a>을 설치한다.</p><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=트레이드-오프>트레이드 오프</h2><p><code>kubectl</code>툴은 3가지 종류의 오브젝트 관리를 지원한다.</p><ul><li>명령형 커맨드</li><li>명령형 오브젝트 구성</li><li>선언형 오브젝트 구성</li></ul><p>각 종류별 오브젝트 관리의 장점과 단점에 대한 논의는 <a href=/ko/docs/concepts/overview/working-with-objects/object-management/>쿠버네티스 오브젝트 관리</a>
를 참고한다.</p><h2 id=오브젝트-생성-방법>오브젝트 생성 방법</h2><p><code>kubectl</code> 툴은 가장 일반적인 오브젝트 타입을 생성하는데 동사 형태 기반의 커맨드를
지원한다. 쿠버네티스 오브젝트 타입에 익숙하지 않은 사용자가 인지할 수 있도록 커맨드
이름이 지어졌다.</p><ul><li><code>run</code>: 컨테이너를 실행할 새로운 파드를 생성한다.</li><li><code>expose</code>: 파드에 걸쳐 트래픽을 로드 밸런스하도록 새로운 서비스 오브젝트를 생성한다.</li><li><code>autoscale</code>: 디플로이먼트와 같이, 하나의 컨트롤러에 대해 자동으로 수평적 스케일이 이루어 지도록 새로운 Autoscaler 오브젝트를 생성한다.</li></ul><p>또한 <code>kubectl</code> 툴은 오브젝트 타입에 의해 구동되는 생성 커맨드를 지원한다.
이러한 커맨드는 더 많은 오브젝트 타입을 지원해주며 그 의도하는 바에 대해
보다 명확하게 해주지만, 사용자가 생성하고자 하는 오브젝트 타입에 대해
알 수 있도록 해야 한다.</p><ul><li><code>create &lt;오브젝트 타입> [&lt;서브 타입>] &lt;인스턴스명></code></li></ul><p>일부 오브젝트 타입은 <code>create</code> 커맨드 내 정의할 수 있는 서브 타입을 가진다.
예를 들어, 서비스 오브젝트는 ClusterIP, LoadBalancer 및 NodePort 등을
포함하는 여러 서브 타입을 가진다, 다음은 NodePort 서브 타입을 통해 서비스를
생성하는 예제이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create service nodeport &lt;사용자 서비스 명칭&gt;
</span></span></code></pre></div><p>이전 예제에서, <code>create service nodeport</code> 커맨드는
<code>create service</code> 커맨드의 서브 커맨드라고 칭한다.</p><p><code>-h</code> 플래그를 사용하여 서브 커맨드에 의해 지원되는 인수 및 플래그를
찾아 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create service nodeport -h
</span></span></code></pre></div><h2 id=오브젝트-업데이트-방법>오브젝트 업데이트 방법</h2><p><code>kubectl</code> 커맨드는 일반적인 몇몇의 업데이트 작업을 위해 동사 형태 기반의 커맨드를 지원한다.
이 커맨드는 쿠버네티스 오브젝트에 익숙하지 않은 사용자가 설정되어야
하는 특정 필드를 모르는 상태에서도 업데이트를 수행할 수 있도록
이름 지어졌다.</p><ul><li><code>scale</code>: 컨트롤러의 레플리카 수를 업데이트 함으로써 파드를 추가 또는 제거하는 컨트롤러를 수평적으로 스케일한다.</li><li><code>annotate</code>: 오브젝트로부터 어노테이션을 추가 또는 제거한다.</li><li><code>label</code>: 오브젝트에서 레이블을 추가 또는 제거한다.</li></ul><p><code>kubectl</code> 커맨드는 또한 오브젝트 측면에서 구동되는 업데이트 커맨드를 지원한다.
이 측면의 설정은 다른 오브젝트 타입에 대한 다른 필드를 설정 할 수도 있다.</p><ul><li><code>set</code> <code>&lt;field></code>: 오브젝트의 측면을 설정한다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 쿠버네티스 1.5 버전에서는 모든 동사 형태 기반의 커맨드가 관련된 측면 중심의 커맨드를 가지는 것은 아니다.</div><p><code>kubectl</code> 툴은 활성 오브젝트를 직접 업데이트하기 위해 추가적인 방법을 지원하지만,
쿠버네티스 오브젝트 스키마에 대한 추가적인 이해를 요구한다.</p><ul><li><code>edit</code>: 편집기에서 구성을 열어 활성 오브젝트에 대한 원래 그대로의 구성을 바로 편집한다.</li><li><code>patch</code>: 패치 문자열를 사용하여 활성 오브젝트를 바로 편집한다.
패치 문자열에 대한 보다 자세한 정보를 보려면
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#patch-operations>API 규정</a>에서 패치 섹션을 참고한다.</li></ul><h2 id=오브젝트-삭제-방법>오브젝트 삭제 방법</h2><p>클러스터에서 오브젝트를 삭제하기 위해 <code>delete</code> 커맨드을 사용할 수 있다.</p><ul><li><code>delete &lt;타입>/&lt;이름></code></li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 명령형 커맨드와 명령형 오브젝트 구성 모두 <code>kubectl delete</code>를 사용할 수
있다. 차이점은 커맨드에 전해지는 인수에 있다. 명령형 커맨드로
<code>kubectl delete</code>을 사용하기 위해, 삭제할 오브젝트를 인수로 전한다.
다음은 nginx라는 디플로이먼트 오브젝트를 전하는 예제이다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment/nginx
</span></span></code></pre></div><h2 id=오브젝트-확인-방법>오브젝트 확인 방법</h2><p>오브젝트에 대한 정보를 출력하는 몇 가지 커맨드가 있다.</p><ul><li><code>get</code>: 일치하는 오브젝트에 대한 기본 정보를 출력한다. 옵션 리스트를 확인하기 위해 <code>get -h</code>를 사용한다.</li><li><code>describe</code>: 일치하는 오브젝트에 대해 수집한 상세한 정보를 출력한다.</li><li><code>logs</code>: 파드에서 실행 중인 컨테이너에 대한 stdout과 stderr를 출력한다.</li></ul><h2 id=생성-전-오브젝트-수정을-위해-set-커맨드-사용하기>생성 전 오브젝트 수정을 위해 <code>set</code> 커맨드 사용하기</h2><p><code>create</code> 커맨드에 사용할 수 있는 플래그가 없는 몇 가지 오브젝트
필드가 있다. 이러한 경우, 오브젝트 생성 전에 필드에 대한 값을
정의하기 위해 <code>set</code>과 <code>create</code>을 조합해서 사용할 수 있다.
이는 <code>set</code> 커맨드에 <code>create</code> 커맨드의 출력을 파이프 함으로써 수행할 수 있다.
다음은 관련 예제이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create service clusterip my-svc --clusterip<span style=color:#666>=</span><span style=color:#b44>&#34;None&#34;</span> -o yaml --dry-run<span style=color:#666>=</span>client | kubectl <span style=color:#a2f>set</span> selector --local -f - <span style=color:#b44>&#39;environment=qa&#39;</span> -o yaml | kubectl create -f -
</span></span></code></pre></div><ol><li><code>kubectl create service -o yaml --dry-run=client</code> 커맨드는 서비스에 대한 구성을 생성하지만, 이를 쿠버네티스 API 서버에 전송하는 대신 YAML 형식으로 stdout에 출력한다.</li><li><code>kubectl set selector --local -f - -o yaml</code> 커맨드는 stdin으로부터 구성을 읽어, YAML 형식으로 stdout에 업데이트된 구성을 기록한다.</li><li><code>kubectl create -f -</code> 커맨드는 stdin을 통해 제공된 구성을 사용하여 오브젝트를 생성한다.</li></ol><h2 id=생성-전-오브젝트-수정을-위해-edit-사용하기>생성 전 오브젝트 수정을 위해 <code>--edit</code> 사용하기</h2><p>생성 전에 오브젝트에 임의의 변경을 가하기 위해 <code>kubectl create --edit</code> 을 사용할 수 있다.
다음은 관련 예제이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create service clusterip my-svc --clusterip<span style=color:#666>=</span><span style=color:#b44>&#34;None&#34;</span> -o yaml --dry-run<span style=color:#666>=</span>client &gt; /tmp/srv.yaml
</span></span><span style=display:flex><span>kubectl create --edit -f /tmp/srv.yaml
</span></span></code></pre></div><ol><li><code>kubectl create service</code> 커맨드는 서비스에 대한 구성을 생성하고 이를 <code>/tmp/srv.yaml</code>에 저장한다.</li><li><code>kubectl create --edit</code> 커맨드는 오브젝트를 생성하기 전에 편집을 위해 구성 파일을 열어준다.</li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-config/>구성 파일을 이용한 명령형 쿠버네티스 오브젝트 관리</a></li><li><a href=/ko/docs/tasks/manage-kubernetes-objects/declarative-config/>구성 파일을 이용한 쿠버네티스 오브젝트의 선언형 관리</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl 커맨드 참조</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 API 참조</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b18886277c410fc6f32ce068e2160537>5.4 - 구성 파일을 이용한 명령형 쿠버네티스 오브젝트 관리</h1><p>쿠버네티스 오브젝트는 YAML 또는 JSON으로 작성된 오프젝트 구성 파일과 함께 <code>kubectl</code>
커맨드 라인 툴을 이용하여 생성, 업데이트 및 삭제할 수 있다.
이 문서는 구성 파일을 이용하여 어떻게 오브젝트를 정의하고 관리할 수 있는지에 대해 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><a href=/ko/docs/tasks/tools/><code>kubectl</code></a>을 설치한다.</p><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=트레이드-오프>트레이드 오프</h2><p><code>kubectl</code> 툴은 3가지 종류의 오브젝트 관리를 지원한다.</p><ul><li>명령형 커맨드</li><li>명령형 오브젝트 구성</li><li>선언형 오브젝트 구성</li></ul><p>각 종류별 오브젝트 관리의 장점과 단점에 대한 논의는
<a href=/ko/docs/concepts/overview/working-with-objects/object-management/>쿠버네티스 오브젝트 관리</a>를 참고한다.</p><h2 id=오브젝트-생성-방법>오브젝트 생성 방법</h2><p>구성 파일로부터 오브젝트를 생성하기 위해 <code>kubectl create -f</code>를 사용할 수 있다.
보다 상세한 정보는 <a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 API 참조</a>를
참조한다.</p><ul><li><code>kubectl create -f &lt;파일명|url></code></li></ul><h2 id=오브젝트-업데이트-방법>오브젝트 업데이트 방법</h2><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> <code>replace</code> 커맨드로 오브젝트를 업데이트 하게되면,
구성 파일에 정의되지 않은 스펙의 모든 부분이 삭제된다. 이는
<code>externalIPs</code>필드가 구성 파일로부터 독립적으로 관리되는
<code>LoadBalancer</code>타입의 서비스와 같이, 클러스터 의해 부분적으로
관리되는 스펙의 오브젝트와 함께 사용되어서는 안된다.
독립적으로 관리되는 필드는 <code>replace</code>로 삭제되는 것을 방지하기 위해
구성 파일에 복사되어져야만 한다.</div><p>구성 파일에 따라 활성 오브젝트를 업데이트하기 위해 <code>kubectl replace -f</code>
를 사용할 수 있다.</p><ul><li><code>kubectl replace -f &lt;파일명|url></code></li></ul><h2 id=오브젝트-삭제-방법>오브젝트 삭제 방법</h2><p>구성 파일에 정의한 오브젝트를 삭제하기 위해 <code>kubectl delete -f</code>를
사용할 수 있다.</p><ul><li><code>kubectl delete -f &lt;파일명|url></code></li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>구성 파일이 <code>metadata</code> 섹션에서 <code>name</code> 필드 대신 <code>generateName</code>
필드를 지정한 경우, <code>kubectl delete -f &lt;filename|url></code> 을 사용하여
오브젝트를 삭제할 수 없다.
오브젝트를 삭제하려면 다른 플래그를 사용해야 한다. 예를 들면, 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete &lt;type&gt; &lt;name&gt;
</span></span><span style=display:flex><span>kubectl delete &lt;type&gt; -l &lt;label&gt;
</span></span></code></pre></div></div><h2 id=오브젝트-확인-방법>오브젝트 확인 방법</h2><p>구성 파일에 정의한 오브젝트에 관한 정보 확인을 위해 <code>kubectl get -f</code>
명령을 사용할 수 있다.</p><ul><li><code>kubectl get -f &lt;파일명|url> -o yaml</code></li></ul><p><code>-o yaml</code> 플래그는 전체 오브젝트 구성이 출력되도록 정의한다. 옵션의 리스트를 확인하기
위해서는 <code>kubectl get -h</code>를 사용한다.</p><h2 id=제약사항>제약사항</h2><p><code>create</code>, <code>replace</code>, 그리고 <code>delete</code> 명령은 각 오브젝트의 구성이
그 구성 파일 내에 완전하게 정의되고 기록되어질 경우 잘 동작한다.
그러나 활성 오브젝트가 업데이트 되고, 구성 파일 안에 병합되지 않으면,
업데이트 내용은 다음번 <code>replace</code>가 실행될 때 삭제될 것이다.
이는 HorizontalPodAutoscaler와 같은 컨트롤러가
활성 오브젝트를 직접적으로 업데이트하도록 할 경우 발생한다.
여기 예시가 있다.</p><ol><li>구성 파일로부터 오브젝트를 생성할 경우</li><li>또 다른 소스가 일부 필드를 변경함으로써 오브젝트가 업데이트 되는 경우</li><li>구성 파일로부터 오브젝트를 대체할 경우. 스텝 2에서의
다른 소스에 의해 이루어진 변경은 유실된다.</li></ol><p>동일 오브젝트에 대해 여러 명의 작성자들로부터의 지원이 필요한 경우, 오브젝트를 관리하기 위해
<code>kubectl apply</code>를 사용할 수 있다.</p><h2 id=구성-저장-없이-url로부터-오브젝트-생성과-편집하기>구성 저장 없이 URL로부터 오브젝트 생성과 편집하기</h2><p>구성 파일에 대한 URL을 가진다고 가정해보자.
<code>kubectl create --edit</code>을 사용하여 오브젝트가 생성되기 전에
구성을 변경할 수 있다. 이는 독자가 수정할 수 있는 구성 파일을
가르키는 튜토리얼과 작업에 특히 유용하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f &lt;url&gt; --edit
</span></span></code></pre></div><h2 id=명령형-커맨드에서-명령형-오브젝트-구성으로-전환하기>명령형 커맨드에서 명령형 오브젝트 구성으로 전환하기</h2><p>령형 커맨드에서 명령형 오브젝트 구성으로 전환하기 위해
몇 가지 수동 단계를 포함한다.</p><ol><li><p>다음과 같이 활성 오브젝트를 로컬 오브젝트 구성 파일로 내보낸다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get &lt;종류&gt;/&lt;이름&gt; -o yaml &gt; &lt;종류&gt;_&lt;이름&gt;.yaml
</span></span></code></pre></div></li><li><p>수동으로 오브젝트 구성 파일에서 상태 필드를 제거한다.</p></li><li><p>이후 오브젝트 관리를 위해, <code>replace</code>만 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace -f &lt;종류&gt;_&lt;이름&gt;.yaml
</span></span></code></pre></div></li></ol><h2 id=컨트롤러-셀렉터와-podtemplate-레이블-삭제하기>컨트롤러 셀렉터와 PodTemplate 레이블 삭제하기</h2><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 컨트롤러에서 셀렉터를 업데이트하지 않도록 강력하게 권고한다.</div><p>권고되는 접근방법은 다른 의미론적 의미가 없는 컨트롤러 셀렉터의 의해서만
사용되는 단일, 불변의 PodTemplate 레이블로 정의하는 것이다.</p><p>레이블 예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;apps/v1/deployment/nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;apps/v1/deployment/nginx&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-command/>명령형 커맨드를 이용한 쿠버네티스 오브젝트 관리하기</a></li><li><a href=/ko/docs/tasks/manage-kubernetes-objects/declarative-config/>구성 파일을 이용한 쿠버네티스 오브젝트의 선언형 관리</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl 커맨드 참조</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 API 참조</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-94f49ece137035764368f22a98942872>6 - 시크릿(Secret) 관리</h1><div class=lead>시크릿을 사용하여 기밀 설정 데이터 관리.</div></div><div class=td-content><h1 id=pg-0ed63ce3c9665aed7ff5a560ff1da843>6.1 - kubectl을 사용한 시크릿 관리</h1><div class=lead>kubectl 커맨드를 사용하여 시크릿 오브젝트를 생성.</div><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=시크릿-생성>시크릿 생성</h2><p><code>시크릿</code>에는 파드가 데이터베이스에 접근하는 데 필요한 사용자 자격 증명이 포함될 수 있다.
예를 들어 데이터베이스 연결 문자열은 사용자 이름과 암호로 구성된다.
사용자 이름은 로컬 컴퓨터의 <code>./username.txt</code> 파일에, 비밀번호는
<code>./password.txt</code> 파일에 저장할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> &gt; ./username.txt
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> &gt; ./password.txt
</span></span></code></pre></div><p>이 명령에서 <code>-n</code> 플래그는 생성된 파일의
텍스트 끝에 추가 개행 문자가 포함되지 않도록 해 준다. 이는 <code>kubectl</code>이 파일을 읽고
내용을 base64 문자열로 인코딩할 때 개행 문자도 함께 인코딩될 수 있기 때문에
중요하다.</p><p><code>kubectl create secret</code> 명령은 이러한 파일들을 시크릿으로 패키징하고
API 서버에 오브젝트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span>./username.txt <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span>./password.txt
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>secret/db-user-pass created
</code></pre><p>기본 키 이름은 파일 이름이다. 선택적으로 <code>--from-file=[key=]source</code>를 사용하여 키 이름을 설정할 수 있다.
예제:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>./username.txt <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>./password.txt
</span></span></code></pre></div><p>파일에 포함하는 암호 문자열에서
특수 문자를 이스케이프하지 않아도 된다.</p><p><code>--from-literal=&lt;key>=&lt;value></code> 태그를 사용하여 시크릿 데이터를 제공할 수도 있다.
이 태그는 여러 키-값 쌍을 제공하기 위해 두 번 이상 지정할 수 있다.
<code>$</code>, <code>\</code>, <code>*</code>, <code>=</code> 및 <code>!</code>와 같은 특수 문자는
<a href=https://en.wikipedia.org/wiki/Shell_(computing)>shell</a>에 해석하고 처리하기 때문에
이스케이프할 필요가 있다.</p><p>대부분의 셸에서 암호를 이스케이프하는 가장 쉬운 방법은 암호를 작은따옴표(<code>'</code>)로 둘러싸는 것이다.
예를 들어, 비밀번호가 <code>S!B\*d$zDsb=</code>인 경우,
다음 커맨드를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</span></span></code></pre></div><h2 id=시크릿-확인>시크릿 확인</h2><p>시크릿이 생성되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>NAME                  TYPE                                  DATA      AGE
db-user-pass          Opaque                                2         51s
</code></pre><p>다음 명령을 실행하여 <code>시크릿</code>에 대한 상세 사항을 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe secrets/db-user-pass
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>Name:            db-user-pass
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password:    12 bytes
username:    5 bytes
</code></pre><p><code>kubectl get</code> 및 <code>kubectl describe</code> 명령은
기본적으로 <code>시크릿</code>의 내용을 표시하지 않는다. 이는 <code>시크릿</code>이 실수로 노출되거나
터미널 로그에 저장되는 것을 방지하기 위한 것이다.</p><p>인코딩된 데이터의 실제 내용을 확인하려면 <a href=#decoding-secret>시크릿 디코딩</a>을 확인하자.</p><h2 id=decoding-secret>시크릿 디코딩</h2><p>생성한 시크릿을 보려면 다음 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret db-user-pass -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data}&#39;</span>
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;password&#34;</span>:<span style=color:#b44>&#34;MWYyZDFlMmU2N2Rm&#34;</span>,<span style=color:green;font-weight:700>&#34;username&#34;</span>:<span style=color:#b44>&#34;YWRtaW4=&#34;</span>}
</span></span></code></pre></div><p>이제 <code>password</code> 데이터를 디코딩할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 이 예시는 문서화를 위한 것이다. </span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 아래와 같은 방법으로 이를 수행했다면, </span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &#39;MWYyZDFlMmU2N2Rm&#39; 데이터가 셸 히스토리에 저장될 수 있다. </span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 당신의 컴퓨터에 접근할 수 있는 사람이 당신 몰래 저장된 명령을 찾아 </span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 시크릿을 base-64 디코드할 수도 있다. </span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 따라서 이 페이지의 아래 부분에 나오는 다른 단계들과 조합하는 것이 좋다.</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;MWYyZDFlMmU2N2Rm&#39;</span> | base64 --decode
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><p>인코딩된 시크릿 값이 셸 히스토리에 저장되는 것을 피하려면,
다음의 명령을 실행할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret db-user-pass -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.password}&#39;</span> | base64 --decode
</span></span></code></pre></div><p>출력은 위의 경우와 유사할 것이다.</p><h2 id=삭제>삭제</h2><p>생성한 시크릿을 삭제하려면 다음 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret db-user-pass
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/configuration/secret/>시크릿 개념</a>에 대해 자세히 알아보기</li><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-config-file/>환경 설정 파일을 사용하여 시크릿을 관리</a>하는 방법 알아보기</li><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomize를 사용하여 시크릿을 관리</a>하는 방법 알아보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e841cf91fd3566db1e86143ed7a9e13c>6.2 - 환경 설정 파일을 사용하여 시크릿을 관리</h1><div class=lead>환경 설정 파일을 사용하여 시크릿 오브젝트를 생성.</div><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=create-the-config-file>시크릿(Secret) 생성</h2><p>먼저 매니페스트에 JSON 이나 YAML 형식으로 <code>시크릿(Secret)</code> 오브젝트를 정의하고,
그 다음 해당 오브젝트를 만든다. 이
<a href=/docs/reference/generated/kubernetes-api/v1.25/#secret-v1-core>시크릿</a>
리소스에는 <code>data</code> 와 <code>stringData</code> 의 두 가지 맵이 포함되어 있다.
<code>data</code> 필드는 base64로 인코딩된 임의의 데이터를 기입하는 데 사용된다.
<code>stringData</code> 필드는 편의를 위해 제공되며, 이를 사용해 같은 데이터를 인코딩되지 않은 문자열로
기입할 수 있다.
<code>data</code> 및 <code>stringData</code>은 영숫자,
<code>-</code>, <code>_</code> 그리고 <code>.</code>로 구성되어야 한다.</p><p>다음 예는 <code>data</code> 필드를 사용하여 시크릿에 두 개의 문자열을 저장한다.</p><ol><li><p>문자열을 base64로 변환한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> | base64
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> | base64
</span></span></code></pre></div></li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 시크릿 데이터의 직렬화된(serialized) JSON 및 YAML 값은 base64 문자열로 인코딩된다. 이러한 문자열에는 개행(newline)을 사용할 수 없으므로 생략해야 한다. Darwin/macOS에서 <code>base64</code> 도구를 사용할 경우, 사용자는 긴 줄을 분할하는 <code>-b</code> 옵션을 사용해서는 안 된다. 반대로, 리눅스 사용자는 <code>-w</code> 옵션을 사용할 수 없는 경우 <code>base64</code> 명령어 또는 <code>base64 | tr -d '\n'</code> 파이프라인에 <code>-w 0</code> 옵션을 <em>추가해야 한다</em>.</div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>YWRtaW4=
MWYyZDFlMmU2N2Rm
</code></pre><ol><li><p>매니페스트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><p>시크릿(Secret) 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p></li><li><p><a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>를 사용하여 시크릿(Secret) 생성하기</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./secret.yaml
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>secret/mysecret created
</code></pre></li></ol><p>시크릿(Secret) 생성과 시크릿(Secret) 데이터 디코딩을 확인하려면,
<a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kubectl/#%EC%8B%9C%ED%81%AC%EB%A6%BF-%ED%99%95%EC%9D%B8>kubectl을 사용한 시크릿 관리</a>을 참조하자.</p><h3 id=시크릿-secret-생성-시-인코딩되지-않은-데이터-명시>시크릿(Secret) 생성 시 인코딩되지 않은 데이터 명시</h3><p>특정 시나리오의 경우 <code>stringData</code> 필드를 대신 사용할 수 있다. 이
필드를 사용하면 base64로 인코딩되지 않은 문자열을 시크릿에 직접 넣을 수 있으며,
시크릿이 생성되거나 업데이트될 때 문자열이 인코딩된다.</p><p>이에 대한 실제적인 예로,
시크릿을 사용하여 구성 파일을 저장하는 애플리케이션을 배포하면서,
배포 프로세스 중에 해당 구성 파일의 일부를 채우려는 경우를 들 수 있다.</p><p>예를 들어 애플리케이션에서 다음 구성 파일을 사용하는 경우:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiUrl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my.api.com/api/v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;user&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;password&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>다음 정의를 사용하여 이를 시크릿에 저장할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    apiUrl: &#34;https://my.api.com/api/v1&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    username: &lt;user&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    password: &lt;password&gt;</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>시크릿(Secret) 데이터를 검색할 때, 검색 명령은 인코딩된 값을 반환하며,
<code>stringData</code>에 기입한 일반 텍스트 값이 아닙니다.</p><p>예를 들어, 다음 명령을 실행한다면</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./secret.yaml
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IHt7dXNlcm5hbWV9fQpwYXNzd29yZDoge3twYXNzd29yZH19<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:40:59Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7225&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>c280ad2e-e916-11e8-98f2-025000000001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=data-와-stringdata-모두-명시><code>data</code>와 <code>stringData</code> 모두 명시</h3><p><code>data</code>와 <code>stringData</code> 모두에 필드를 명시하면, <code>stringData</code>에 명시된 값이 사용된다.</p><p>예를 들어 다음과 같은 시크릿인 경우,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>administrator<span style=color:#bbb>
</span></span></span></code></pre></div><p>다음과 같이 <code>시크릿</code> 오브젝트가 생성됐다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW5pc3RyYXRvcg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:46:46Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7579&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>91460ecb-e917-11e8-98f2-025000000001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>YWRtaW5pc3RyYXRvcg==</code>는 <code>administrator</code>으로 디코딩된다.</p><h2 id=삭제>삭제</h2><p>생성한 시크릿을 삭제하려면 다음 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret mysecret
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/configuration/secret/>시크릿 개념</a>에 대해 자세히 알아보기</li><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kubectl/>kubectl을 사용한 시크릿 관리</a>하는 방법 알아보기</li><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomize를 사용하여 시크릿을 관리</a>하는 방법 알아보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a0ff2e3ba8af5670d5dc3d94c4bd0a68>6.3 - kustomize를 사용하여 시크릿 관리</h1><div class=lead>kustomization.yaml 파일을 사용하여 시크릿 오브젝트 생성.</div><p>쿠버네티스 v1.14부터 <code>kubectl</code>은
<a href=/ko/docs/tasks/manage-kubernetes-objects/kustomization/>Kustomize를 이용한 쿠버네티스 오브젝트의 선언형 관리</a>를 지원한다.
Kustomize는 시크릿 및 컨피그맵을 생성하기 위한 리소스 생성기를 제공한다.
Kustomize 생성기는 디렉토리 내의 <code>kustomization.yaml</code> 파일에 지정되어야 한다.
시크릿 생성 후 <code>kubectl apply</code>를 통해 API
서버에 시크릿을 생성할 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=kustomization-파일-생성>Kustomization 파일 생성</h2><p><code>kustomization.yaml</code> 파일에 다른 기존 파일을 참조하는
<code>secretGenerator</code>를 정의하여 시크릿을 생성할 수 있다.
예를 들어 다음 kustomization 파일은
<code>./username.txt</code> 및 <code>./password.txt</code> 파일을 참조한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>files</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- username.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- password.txt<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>kustomization.yaml</code> 파일에 리터럴을 명시하여 <code>secretGenerator</code>를
정의할 수도 있다.
예를 들어 다음 <code>kustomization.yaml</code> 파일에는
각각 <code>username</code>과 <code>password</code>에 대한 두 개의 리터럴이 포함되어 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>literals</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- username=admin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- password=1f2d1e2e67df<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>kustomization.yaml</code> 파일에 <code>.env</code> 파일을 명시하여
<code>secretGenerator</code>를 정의할 수도 있다.
예를 들어 다음 <code>kustomization.yaml</code> 파일은
<code>.env.secret</code> 파일에서 데이터를 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>envs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- .env.secret<span style=color:#bbb>
</span></span></span></code></pre></div><p>모든 경우에 대해, 값을 base64로 인코딩하지 않아도 된다.</p><h2 id=시크릿-생성>시크릿 생성</h2><p>다음 명령을 실행하여 시크릿을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>secret/db-user-pass-96mffmfh4k created
</code></pre><p>시크릿이 생성되면 시크릿 데이터를 해싱하고
이름에 해시 값을 추가하여 시크릿 이름이 생성된다. 이렇게 함으로써
데이터가 수정될 때마다 시크릿이 새롭게 생성된다.</p><h2 id=생성된-시크릿-확인>생성된 시크릿 확인</h2><p>시크릿이 생성된 것을 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>NAME                             TYPE                                  DATA      AGE
db-user-pass-96mffmfh4k          Opaque                                2         51s
</code></pre><p>다음 명령을 실행하여 시크릿에 대한 상세 사항을 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe secrets/db-user-pass-96mffmfh4k
</span></span></code></pre></div><p>출력은 다음과 유사하다.</p><pre tabindex=0><code>Name:            db-user-pass-96mffmfh4k
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password.txt:    12 bytes
username.txt:    5 bytes
</code></pre><p><code>kubectl get</code> 및 <code>kubectl describe</code> 명령은 기본적으로 <code>시크릿</code>의 내용을 표시하지 않는다.
이는 <code>시크릿</code>이 실수로 구경꾼에게 노출되는 것을 방지하기 위한 것으로,
또는 터미널 로그에 저장되지 않는다.
인코딩된 데이터의 실제 내용을 확인하려면 다음을 참조한다.
<a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret>시크릿 디코딩</a>.</p><h2 id=삭제>삭제</h2><p>생성한 시크릿을 삭제하려면 다음 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret db-user-pass-96mffmfh4k
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/configuration/secret/>시크릿 개념</a>에 대해 자세히 알아보기</li><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kubectl/><code>kubectl</code> 커맨드을 사용하여 시크릿 관리</a> 방법 알아보기</li><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-config-file/>환경 설정 파일을 사용하여 시크릿을 관리</a>하는 방법 알아보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-866924fa095f897ede8dfdcab9e97942>7 - 애플리케이션에 데이터 주입하기</h1><div class=lead>워크로드를 실행하는 파드에 대한 구성과 기타 데이터를 지정한다.</div></div><div class=td-content><h1 id=pg-c9af1e81bb6e109f6c41febe44f0931b>7.1 - 컨테이너를 위한 커맨드와 인자 정의하기</h1><p>본 페이지는 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 안에서 컨테이너를 실행할
때 커맨드와 인자를 정의하는 방법에 대해 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=파드를-생성할-때-커맨드와-인자를-정의하기>파드를 생성할 때 커맨드와 인자를 정의하기</h2><p>파드를 생성할 때, 파드 안에서 동작하는 컨테이너를 위한 커맨드와 인자를
정의할 수 있다. 커맨드를 정의하기 위해서는, 파드 안에서 실행되는 컨테이너에
<code>command</code> 필드를 포함시킨다. 커맨드에 대한 인자를 정의하기 위해서는, 구성
파일에 <code>args</code> 필드를 포함시킨다. 정의한 커맨드와 인자들은 파드가 생성되고
난 이후에는 변경될 수 없다.</p><p>구성 파일 안에서 정의하는 커맨드와 인자들은 컨테이너 이미지가
제공하는 기본 커맨드와 인자들보다 우선시 된다. 만약 인자들을
정의하고 커맨드를 정의하지 않는다면, 기본 커맨드가 새로운 인자와
함께 사용된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>command</code> 필드는 일부 컨테이너 런타임에서 <code>entrypoint</code>에 해당된다.</div><p>이 예제에서는 한 개의 컨테이너를 실행하는 파드를 생성한다. 파드를 위한 구성
파일에서 커맨드와 두 개의 인자를 정의한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/commands.yaml download=pods/commands.yaml><code>pods/commands.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-commands-yaml")' title="Copy pods/commands.yaml to clipboard"></img></div><div class=includecode id=pods-commands-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>command-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>demonstrate-command<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>command-demo-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;printenv&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;HOSTNAME&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;KUBERNETES_PORT&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>YAML 구성 파일을 활용해 파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/commands.yaml
</span></span></code></pre></div></li><li><p>실행 중인 파드들의 목록을 조회한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>command-demo라는 파드 안에서 실행된 컨테이너가 완료되었다고 출력될
것이다.</p></li><li><p>컨테이너 안에서 실행된 커맨드의 출력을 보기 위해, 파드의 로그를
확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs command-demo
</span></span></code></pre></div><p>HOSTNAME과 KUBERNETES_PORT 환경 변수들의 값들이 출력될
것이다.</p><pre tabindex=0><code>command-demo
tcp://10.3.240.1:443
</code></pre></li></ol><h2 id=인자를-정의하기-위해-환경-변수를-사용하기>인자를 정의하기 위해 환경 변수를 사용하기</h2><p>이전 예제에서는, 문자열을 제공하면서 직접 인자를 정의해보았다.
문자열을 직접 제공하는 것에 대한 대안으로, 환경 변수들을 사용하여 인자들을
정의할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MESSAGE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;hello world&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/echo&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;$(MESSAGE)&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>이것은 <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그 맵</a>과
<a href=/ko/docs/concepts/configuration/secret/>시크릿</a>을
포함해, 환경 변수를 정의하는데 활용할 수 있는 모든 방법들을 활용해서 파드를 위한 인자를
정의할
수 있다는 것을 의미한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 환경 변수는 <code>"$(VAR)"</code>와 같이 괄호 안에 나타난다. 이는 변수가 <code>command</code>나 <code>args</code>
필드 안에서 전개되기 위해 필요한 것이다.</div><h2 id=셸-안에서-커맨드-실행하기>셸 안에서 커맨드 실행하기</h2><p>일부 경우들에서는 커맨드를 셸 안에서 실행해야할 필요가 있다. 예를 들어, 실행할 커맨드가
서로 연결되어 있는 여러 개의 커맨드들로 구성되어 있거나, 셸 스크립트일 수도 있다. 셸 안에서
커맨드를 실행하려고 한다면, 이런 방식으로 감싸주면 된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>command: <span style=color:#666>[</span><span style=color:#b44>&#34;/bin/sh&#34;</span><span style=color:#666>]</span>
</span></span><span style=display:flex><span>args: <span style=color:#666>[</span><span style=color:#b44>&#34;-c&#34;</span>, <span style=color:#b44>&#34;while true; do echo hello; sleep 10;done&#34;</span><span style=color:#666>]</span>
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/>파드와 컨테이너를 구성하는 방법</a>에 대해 더 알아본다.</li><li><a href=/ko/docs/tasks/debug/debug-application/get-shell-running-container/>컨테이너 안에서 커맨드를 실행하는 방법</a>에 대해 더 알아본다.</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>컨테이너</a>를 확인한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-eff97c25c917cdb414eda016df0e2bca>7.2 - 종속 환경 변수 정의하기</h1><p>본 페이지는 쿠버네티스 파드의 컨테이너를 위한 종속 환경 변수를
정의하는 방법에 대해 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=컨테이너를-위한-종속-환경-변수-정의하기>컨테이너를 위한 종속 환경 변수 정의하기</h2><p>파드를 생성할 때, 파드 안에서 동작하는 컨테이너를 위한 종속 환경 변수를 설정할 수 있다. 종속 환경 변수를 설정하려면, 구성 파일에서 <code>env</code>의 <code>value</code>에 $(VAR_NAME)을 사용한다.</p><p>이 예제에서는 한 개의 컨테이너를 실행하는 파드를 생성한다.
파드를 위한 구성 파일은 일반적인 방식으로 정의된 종속 환경 변수를 정의한다.
다음은 파드를 위한 구성 매니페스트 예시이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/inject/dependent-envars.yaml download=pods/inject/dependent-envars.yaml><code>pods/inject/dependent-envars.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-dependent-envars-yaml")' title="Copy pods/inject/dependent-envars.yaml to clipboard"></img></div><div class=includecode id=pods-inject-dependent-envars-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dependent-envars-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dependent-envars-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- while true; do echo -en &#39;\n&#39;; printf UNCHANGED_REFERENCE=$UNCHANGED_REFERENCE&#39;\n&#39;; printf SERVICE_ADDRESS=$SERVICE_ADDRESS&#39;\n&#39;;printf ESCAPED_REFERENCE=$ESCAPED_REFERENCE&#39;\n&#39;; sleep 30; done;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SERVICE_PORT<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;80&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SERVICE_IP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;172.17.0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UNCHANGED_REFERENCE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;$(PROTOCOL)://$(SERVICE_IP):$(SERVICE_PORT)&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PROTOCOL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SERVICE_ADDRESS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;$(PROTOCOL)://$(SERVICE_IP):$(SERVICE_PORT)&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ESCAPED_REFERENCE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;$$(PROTOCOL)://$(SERVICE_IP):$(SERVICE_PORT)&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>YAML 구성 파일을 활용해 파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/inject/dependent-envars.yaml
</span></span></code></pre></div><pre tabindex=0><code>pod/dependent-envars-demo created
</code></pre></li><li><p>실행 중인 파드의 목록을 조회한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods dependent-envars-demo
</span></span></code></pre></div><pre tabindex=0><code>NAME                      READY     STATUS    RESTARTS   AGE
dependent-envars-demo     1/1       Running   0          9s
</code></pre></li><li><p>파드 안에서 동작 중인 컨테이너의 로그를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs pod/dependent-envars-demo
</span></span></code></pre></div><pre tabindex=0><code>
UNCHANGED_REFERENCE=$(PROTOCOL)://172.17.0.1:80
SERVICE_ADDRESS=https://172.17.0.1:80
ESCAPED_REFERENCE=$(PROTOCOL)://172.17.0.1:80
</code></pre></li></ol><p>위에서 보듯이, <code>SERVICE_ADDRESS</code>는 올바른 종속성 참조, <code>UNCHANGED_REFERENCE</code>는 잘못된 종속성 참조를 정의했으며 <code>ESCAPED_REFERENCE</code>는 종속성 참조를 건너뛴다.</p><p>미리 정의된 환경 변수를 참조할 때는,
<code>SERVICE_ADDRESS</code>의 경우와 같이 참조를 올바르게 해석할 수 있다.</p><p><code>env</code> 목록 안에서의 순서가 영향을 준다는 것을 주의하자.
목록에서 더 아래쪽에 명시된 환경 변수는, "정의된" 것으로 보지 않는다.
이것이 바로 위의 예시에서 <code>UNCHANGED_REFERENCE</code>가 <code>$(PROTOCOL)</code>을 해석하지 못한 이유이다.</p><p>환경 변수가 정의되지 않았거나 일부 변수만 포함된 경우, 정의되지 않은 환경 변수는 <code>UNCHANGED_REFERENCE</code>의 경우와 같이 일반 문자열로 처리된다. 일반적으로 환경 변수 해석에 실패하더라도 컨테이너의 시작을 막지는 않는다.</p><p><code>$(VAR_NAME)</code> 구문은 이중 $로 이스케이프될 수 있다. (예: <code>$$(VAR_NAME)</code>)
이스케이프된 참조는 참조된 변수가 정의되었는지 여부에 관계없이 해석을 수행하지 않는다.
이는 위의 <code>ESCAPED_REFERENCE</code>를 통해 확인할 수 있다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>환경 변수</a>에 대해 알아본다.</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#envvarsource-v1-core>EnvVarSource</a>를 확인한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-82c93897176489678232542102daea40>7.3 - 컨테이너를 위한 환경 변수 정의하기</h1><p>본 페이지는 쿠버네티스 파드의 컨테이너를 위한 환경 변수를
정의하는 방법에 대해 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=컨테이너를-위한-환경-변수-정의하기>컨테이너를 위한 환경 변수 정의하기</h2><p>파드를 생성할 때, 파드 안에서 동작하는 컨테이너를 위한 환경 변수를 설정할
수 있다. 환경 변수를 설정하려면, 구성 파일에 <code>env</code>나 <code>envFrom</code> 필드를
포함시켜야 한다.</p><p>이 예제에서, 한 개의 컨테이너를 실행하는 파드를 생성한다. 파드를 위한 구성
파일은 <code>DEMO_GREETING</code> 이라는 이름과 <code>"Hello from the environment"</code>이라는
값을 가지는 환경 변수를 정의한다. 다음은 파드를 위한 구성 매니페스트
예시이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/inject/envars.yaml download=pods/inject/envars.yaml><code>pods/inject/envars.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-envars-yaml")' title="Copy pods/inject/envars.yaml to clipboard"></img></div><div class=includecode id=pods-inject-envars-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envar-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>demonstrate-envars<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envar-demo-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DEMO_GREETING<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Hello from the environment&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DEMO_FAREWELL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Such a sweet sorrow&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>YAML 구성 파일을 활용해 파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/inject/envars.yaml
</span></span></code></pre></div></li><li><p>실행 중인 파드들의 목록을 조회한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>purpose</span><span style=color:#666>=</span>demonstrate-envars
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>NAME            READY     STATUS    RESTARTS   AGE
envar-demo      1/1       Running   0          9s
</code></pre></li><li><p>파드의 컨테이너 환경 변수를 나열한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> envar-demo -- printenv
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>NODE_VERSION=4.4.2
EXAMPLE_SERVICE_PORT_8080_TCP_ADDR=10.3.245.237
HOSTNAME=envar-demo
...
DEMO_GREETING=Hello from the environment
DEMO_FAREWELL=Such a sweet sorrow
</code></pre></li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>env</code> 나 <code>envFrom</code> 필드를 이용해 설정된 환경 변수들은 컨테이너 이미지
안에서 명시된 모든 환경 변수들을 오버라이딩한다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 환경 변수는 서로를 참조할 수 있는데, 이 때 순서에 주의해야 한다.
동일한 컨텍스트에서 정의된 다른 변수를 참조하는 변수는 목록의 뒤쪽에 나와야 한다.
또한, 순환 참조는 피해야 한다.</div><h2 id=설정-안에서-환경-변수-사용하기>설정 안에서 환경 변수 사용하기</h2><p>파드의 구성 파일 안에서 정의한 환경 변수는
파드의 컨테이너를 위해 설정하는 커맨드와 인자들과 같이,
구성 파일 안의 다른 곳에서 사용할 수 있다.
아래의 구성 파일 예시에서, <code>GREETING</code>, <code>HONORIFIC</code>, 그리고
<code>NAME</code> 환경 변수들이 각각 <code>Warm greetings to</code>, <code>The Most honorable</code>,
그리고 <code>Kubernetes</code>로 설정되어 있다. 이 환경 변수들은
이후 <code>env-print-demo</code> 컨테이너에 전달되어 CLI 인자에서
사용된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>print-greeting<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-print-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>bash<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>GREETING<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Warm greetings to&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>HONORIFIC<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The Most Honorable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Kubernetes&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;echo&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;$(GREETING) $(HONORIFIC) $(NAME)&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>컨테이너가 생성되면, <code>echo Warm greetings to The Most Honorable Kubernetes</code> 커맨드가 컨테이너에서 실행된다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>환경 변수</a>에 대해 알아본다.</li><li><a href=/ko/docs/concepts/configuration/secret/#%EC%8B%9C%ED%81%AC%EB%A6%BF%EC%9D%84-%ED%99%98%EA%B2%BD-%EB%B3%80%EC%88%98%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>시크릿을 환경 변수로 사용하기</a>에 대해 알아본다.</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#envvarsource-v1-core>EnvVarSource</a>를 확인한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-66c0456fdbef5e5116dd606d1e6f73cc>7.4 - 환경 변수로 컨테이너에 파드 정보 노출하기</h1><p>본 페이지는 파드가 환경 변수를 사용하여 <em>downward API</em> 로 파드 내부의 컨테이너 정보를 노출하는 방법에
대해 설명한다.
환경 변수를 사용하여 파드 필드, 컨테이너 필드 또는 둘 다 노출할 수 있다.</p><p>쿠버네티스에는 실행 중인 컨테이너에 파드 필드 및 컨테이너 필드를 노출하는 두 가지 방법이 있다.</p><ul><li><em>환경 변수</em> (본 태스크에 설명이 있음)</li><li><a href=/ko/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#%EB%8B%A4%EC%9A%B4%EC%9B%8C%EB%93%9C-downward-api>볼륨 파일</a></li></ul><p>파드 및 컨테이너 필드를 노출하는 이 두 가지 방법을 downward API라고 한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=파드-필드를-환경-변수의-값으로-사용하자>파드 필드를 환경 변수의 값으로 사용하자</h2><p>이 연습에서 하나의 컨테이너가 있는 파드와 파드 수준의 필드를 실행 중인 컨테이너의 환경변수로 생성한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/inject/dapi-envars-pod.yaml download=pods/inject/dapi-envars-pod.yaml><code>pods/inject/dapi-envars-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-dapi-envars-pod-yaml")' title="Copy pods/inject/dapi-envars-pod.yaml to clipboard"></img></div><div class=includecode id=pods-inject-dapi-envars-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-envars-fieldref<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>echo -en &#39;\n&#39;;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>printenv MY_NODE_NAME MY_POD_NAME MY_POD_NAMESPACE;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>printenv MY_POD_IP MY_POD_SERVICE_ACCOUNT;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>sleep 10;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_NODE_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>spec.nodeName<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_NAMESPACE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_IP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>status.podIP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_SERVICE_ACCOUNT<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>spec.serviceAccountName<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>매니페스트에서 5개의 환경 변수를 확인할 수 있다. <code>env</code> 필드는
환경 변수 정의의 배열이다. 배열의 첫 번째 요소는 <code>MY_NODE_NAME</code> 환경 변수가 파드의 <code>spec.nodeName</code> 필드에서 값을 가져오도록 지정한다. 마찬가지로 다른 환경 변수도 파드 필드에서 이름을 가져온다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 예제의 필드는 파드에 있는 컨테이너의 필드가 아니라 파드 필드이다.</div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-pod.yaml
</span></span></code></pre></div><p>파드의 컨테이너가 실행중인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 새 파드가 아직 정상 상태가 아니면, 이 명령을 몇 번 다시 실행한다.</span>
</span></span><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>컨테이너의 로그를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs dapi-envars-fieldref
</span></span></code></pre></div><p>출력은 선택된 환경 변수의 값을 보여준다.</p><pre tabindex=0><code>minikube
dapi-envars-fieldref
default
172.17.0.4
default
</code></pre><p>이러한 값이 로그에 출력된 이유를 보려면 구성 파일의 <code>command</code> 및 <code>args</code> 필드를 확인하자.
컨테이너가 시작되면 5개의 환경 변수 값을 stdout에 쓰며 10초마다 이를 반복한다.</p><p>다음으로 파드에서 실행 중인 컨테이너의 셸을 가져오자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it dapi-envars-fieldref -- sh
</span></span></code></pre></div><p>셸에서 환경 변수를 보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 컨테이너 내부의 쉘에서 실행하자.</span>
</span></span><span style=display:flex><span>printenv
</span></span></code></pre></div><p>출력은 특정 환경 변수에 파드 필드 값이 할당되었음을 보여준다.</p><pre tabindex=0><code>MY_POD_SERVICE_ACCOUNT=default
...
MY_POD_NAMESPACE=default
MY_POD_IP=172.17.0.4
...
MY_NODE_NAME=minikube
...
MY_POD_NAME=dapi-envars-fieldref
</code></pre><h2 id=컨테이너-필드를-환경-변수의-값으로-사용하기>컨테이너 필드를 환경 변수의 값으로 사용하기</h2><p>이전 연습에서 파드 수준 필드의 정보를 환경 변수의 값으로 사용했다. 이번 연습에서는 파드 전체가 아닌 특정 <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>컨테이너</a>의 일부 필드만 전달한다. 다음은 하나의 컨테이너가 있는 파드의 구성 파일이다.</p><p>여기, 다시 하나의 컨테이너만 가진 파드를 위한 매니페스트가 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/inject/dapi-envars-container.yaml download=pods/inject/dapi-envars-container.yaml><code>pods/inject/dapi-envars-container.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-dapi-envars-container-yaml")' title="Copy pods/inject/dapi-envars-container.yaml to clipboard"></img></div><div class=includecode id=pods-inject-dapi-envars-container-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-envars-resourcefieldref<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox:1.24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>echo -en &#39;\n&#39;;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>printenv MY_CPU_REQUEST MY_CPU_LIMIT;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>printenv MY_MEM_REQUEST MY_MEM_LIMIT;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>sleep 10;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;32Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;125m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_CPU_REQUEST<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_CPU_LIMIT<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_MEM_REQUEST<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.memory<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_MEM_LIMIT<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.memory<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>매니페스트에서 4개의 환경 변수를 확인할 수 있다. <code>env</code> 필드는
환경 변수 정의의 배열이다. 배열의 첫 번째 요소는 <code>MY_CPU_REQUEST</code> 환경 변수가 <code>test-container</code>라는 컨테이너의
<code>requests.cpu</code> 필드에서 값을 가져오도록 지정한다. 마찬가지로 다른 환경 변수도 특정 컨테이너 필드에서
값을 가져온다.</p><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-container.yaml
</span></span></code></pre></div><p>파드의 컨테이너가 실행중인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 새 파드가 아직 정상 상태가 아니면, 이 명령을 몇 번 다시 실행한다.</span>
</span></span><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>컨테이너의 로그를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs dapi-envars-resourcefieldref
</span></span></code></pre></div><p>출력은 선택된 환경 변수의 값을 보여준다.</p><pre tabindex=0><code>1
1
33554432
67108864
</code></pre><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/inject-data-application/define-environment-variable-container/>컨테이너를 위한 환경 변수 정의하기</a>를 읽어보자.</li><li><a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec><code>spec</code></a>을 읽어보자.
파드에 대한 API 정의다. 여기에는 컨테이너 (파드의 일부)의 정의가 포함되어 있다.</li><li>downward API를 사용하여 노출할 수 있는 <a href=/ko/docs/concepts/workloads/pods/downward-api/#%EC%82%AC%EC%9A%A9-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%95%84%EB%93%9C>이용 가능한 필드</a> 목록을 읽어보자.</li></ul><p>레거시 API 레퍼런스에서 파드, 컨테이너 및 환경 변수에 대해 읽어본다.</p><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>컨테이너</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#envvar-v1-core>EnvVar</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#envvarsource-v1-core>EnvVarSource</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#objectfieldselector-v1-core>ObjectFieldSelector</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#resourcefieldselector-v1-core>ResourceFieldSelector</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bcf93d1cd019501fd0b7649e9fbcaf60>7.5 - 파일로 컨테이너에 파드 정보 노출하기</h1><p>본 페이지는 파드가
<a href=/ko/docs/concepts/storage/volumes/#downwardapi><code>downwardAPI</code> 볼륨</a>을 사용하여
파드에서 실행되는 컨테이너에 자신에 대한 정보를 노출하는 방법에 대해 설명한다.
<code>downwardAPI</code> 볼륨은 파드 필드와 컨테이너 필드를 노출할 수 있다.</p><p>쿠버네티스에는 실행 중인 컨테이너에 파드 필드 및 컨테이너 필드를 노출하는 두 가지 방법이 있다.</p><ul><li><a href=/ko/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>환경 변수</a></li><li>볼륨 파일</li></ul><p>파드 및 컨테이너 필드를 노출하는 이 두 가지 방법을
<em>downward API</em> 라고 한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=파드-필드-저장>파드 필드 저장</h2><p>이 연습에서는 컨테이너가 한 개 있는 파드를 생성하고, 해당 파드의
파드 수준(Pod-level) 필드를 실행 중인 컨테이너에 파일 형태로 생성한다.
다음은 파드를 위한 매니페스트를 보여준다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/inject/dapi-volume.yaml download=pods/inject/dapi-volume.yaml><code>pods/inject/dapi-volume.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-dapi-volume-yaml")' title="Copy pods/inject/dapi-volume.yaml to clipboard"></img></div><div class=includecode id=pods-inject-dapi-volume-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubernetes-downwardapi-volume-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>zone</span>:<span style=color:#bbb> </span>us-est-coast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>test-cluster1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rack</span>:<span style=color:#bbb> </span>rack-22<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>build</span>:<span style=color:#bbb> </span>two<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>builder</span>:<span style=color:#bbb> </span>john-doe<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/labels ]]; then<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>echo -en &#39;\n\n&#39;; cat /etc/podinfo/labels; fi;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/annotations ]]; then<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>echo -en &#39;\n\n&#39;; cat /etc/podinfo/annotations; fi;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>sleep 5;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>podinfo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/podinfo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>podinfo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;labels&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.labels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;annotations&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.annotations<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>매니페스트에서, 파드에 <code>downwardAPI</code> 볼륨이 있고,
컨테이너가 <code>/etc/podinfo</code>에 볼륨을 마운트하는 것을 확인할 수 있다.</p><p><code>downwardAPI</code> 아래의 <code>items</code> 배열을 살펴보자. 배열의 각 요소는
<code>downwardAPI</code> 볼륨을 의미한다.
첫 번째 요소는 파드의 <code>metadata.labels</code> 필드 값이
<code>labels</code>라는 파일에 저장되어야 함을 지정한다.
두 번째 요소는 파드의 <code>annotations</code> 필드 값이
<code>annotations</code>라는 파일에 저장되어야 함을 지정한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 예제의 필드는 파드에 있는 컨테이너의 필드가 아니라
파드 필드이다.</div><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-volume.yaml
</span></span></code></pre></div><p>파드의 컨테이너가 실행 중인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>컨테이너의 로그를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs kubernetes-downwardapi-volume-example
</span></span></code></pre></div><p>출력은 <code>labels</code> 파일과 <code>annotations</code> 파일의 내용을 보여준다.</p><pre tabindex=0><code>cluster=&#34;test-cluster1&#34;
rack=&#34;rack-22&#34;
zone=&#34;us-est-coast&#34;

build=&#34;two&#34;
builder=&#34;john-doe&#34;
</code></pre><p>파드에서 실행 중인 컨테이너의 셸을 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it kubernetes-downwardapi-volume-example -- sh
</span></span></code></pre></div><p>셸에서 <code>labels</code> 파일을 보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/# cat /etc/podinfo/labels
</span></span></code></pre></div><p>출력을 통해 모든 파드의 레이블이
<code>labels</code> 파일에 기록되었음을 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>cluster</span><span style=color:#666>=</span><span style=color:#b44>&#34;test-cluster1&#34;</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>rack</span><span style=color:#666>=</span><span style=color:#b44>&#34;rack-22&#34;</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>zone</span><span style=color:#666>=</span><span style=color:#b44>&#34;us-est-coast&#34;</span>
</span></span></code></pre></div><p>마찬가지로 <code>annotations</code> 파일을 확인하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/# cat /etc/podinfo/annotations
</span></span></code></pre></div><p><code>etc/podinfo</code> 디렉터리에 파일을 확인하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/# ls -laR /etc/podinfo
</span></span></code></pre></div><p>출력에서 <code>labels</code> 및 <code>annotations</code> 파일이
임시 하위 디렉터리에 있음을 알 수 있다. 이 예제에서는
<code>..2982_06_02_21_47_53.299460680</code>이다. <code>/etc/podinfo</code> 디렉터리에서 <code>..data</code>는
임시 하위 디렉토리에 대한 심볼릭 링크이다. <code>/etc/podinfo</code> 디렉토리에서
<code>labels</code>와 <code>annotations</code> 또한 심볼릭 링크이다.</p><pre tabindex=0><code>drwxr-xr-x  ... Feb 6 21:47 ..2982_06_02_21_47_53.299460680
lrwxrwxrwx  ... Feb 6 21:47 ..data -&gt; ..2982_06_02_21_47_53.299460680
lrwxrwxrwx  ... Feb 6 21:47 annotations -&gt; ..data/annotations
lrwxrwxrwx  ... Feb 6 21:47 labels -&gt; ..data/labels

/etc/..2982_06_02_21_47_53.299460680:
total 8
-rw-r--r--  ... Feb  6 21:47 annotations
-rw-r--r--  ... Feb  6 21:47 labels
</code></pre><p>심볼릭 링크를 사용하면 메타데이터의 동적(dynamic) 원자적(atomic) 갱신이 가능하다.
업데이트는 새 임시 디렉터리에 기록되고, <code>..data</code> 심볼릭 링크는
<a href=http://man7.org/linux/man-pages/man2/rename.2.html>rename(2)</a>을 사용하여 원자적(atomic)으로 갱신한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 다운워드 API를 <a href=/ko/docs/concepts/storage/volumes/#using-subpath>subPath</a>
볼륨 마운트로 사용하는 컨테이너는
다운워드 API 업데이트를 수신하지 않는다.</div><p>셸을 종료한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/# <span style=color:#a2f>exit</span>
</span></span></code></pre></div><h2 id=컨테이너-필드-저장>컨테이너 필드 저장</h2><p>이전 연습에서는 downward API를 사용하여 파드 수준 필드에 액세스할 수
있도록 했다.
이번 연습에서는 파드 전체가 아닌 특정
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>컨테이너</a>의
일부 필드만 전달한다. 다음은 기존과 마찬가지로 하나의
컨테이너만 가진 파드의 매니페스트를
보여준다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/inject/dapi-volume-resources.yaml download=pods/inject/dapi-volume-resources.yaml><code>pods/inject/dapi-volume-resources.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-dapi-volume-resources-yaml")' title="Copy pods/inject/dapi-volume-resources.yaml to clipboard"></img></div><div class=includecode id=pods-inject-dapi-volume-resources-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubernetes-downwardapi-volume-example-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox:1.24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>echo -en &#39;\n&#39;;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/cpu_limit ]]; then<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>echo -en &#39;\n&#39;; cat /etc/podinfo/cpu_limit; fi;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/cpu_request ]]; then<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>echo -en &#39;\n&#39;; cat /etc/podinfo/cpu_request; fi;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/mem_limit ]]; then<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>echo -en &#39;\n&#39;; cat /etc/podinfo/mem_limit; fi;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>if [[ -e /etc/podinfo/mem_request ]]; then<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>echo -en &#39;\n&#39;; cat /etc/podinfo/mem_request; fi;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>sleep 5;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;32Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;125m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>podinfo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/podinfo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>podinfo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cpu_limit&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>divisor</span>:<span style=color:#bbb> </span>1m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cpu_request&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>divisor</span>:<span style=color:#bbb> </span>1m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;mem_limit&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.memory<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>divisor</span>:<span style=color:#bbb> </span>1Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;mem_request&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.memory<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>divisor</span>:<span style=color:#bbb> </span>1Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>매니페스트에서 파드에 <a href=/ko/docs/concepts/storage/volumes/#downwardapi><code>downwardAPI</code> 볼륨</a>이 있고
단일 컨테이너는 <code>/etc/podinfo</code>에
볼륨을 마운트하는 것을 확인할 수 있다.</p><p><code>downwardAPI</code> 아래의 <code>items</code> 배열을 살펴보자.
배열의 각 요소는 downward API 볼륨의 파일을 의미한다.</p><p>첫 번째 요소는 <code>client-container</code>라는 컨테이너에서
<code>1m</code>으로 지정된 형식의 <code>limits.cpu</code> 필드 값이
<code>cpu_limit</code>이라는 파일에 배포되어야 함을 지정한다.
<code>divisor</code> 필드는 선택 사항이며, 지정하지 않을 경우 <code>1</code>의 값을 갖는다.
divisor 1은 <code>cpu</code> 리소스를 위한 코어 수를 의미하거나 <code>memory</code> 리소스에 대한 바이트 수를 의미한다.</p><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-volume-resources.yaml
</span></span></code></pre></div><p>파드에서 실행 중인 컨테이너의 셸을 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it kubernetes-downwardapi-volume-example-2 -- sh
</span></span></code></pre></div><p>셸에서 <code>cpu_limit</code> 파일을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 컨테이너 내부의 쉘에서 실행하자.</span>
</span></span><span style=display:flex><span>cat /etc/podinfo/cpu_limit
</span></span></code></pre></div><p>비슷한 명령을 통해 <code>cpu_request</code>, <code>mem_limit</code> 및
<code>mem_request</code> 파일을 확인할 수 있다.</p><h2 id=특정-경로-및-파일-권한에-대한-프로젝트-키>특정 경로 및 파일 권한에 대한 프로젝트 키</h2><p>키(key)를 파드 안의 특정 경로에, 특정 권한으로, 파일 단위로 투영(project)할 수 있다.
자세한 내용은
<a href=/ko/docs/concepts/configuration/secret/>시크릿(Secrets)</a>을 참조한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec><code>spec</code></a>을 읽어보자.
파드에 대한 API 정의다. 여기에는 컨테이너 (파드의 일부)의 정의가 포함되어 있다.</li><li>downward API를 사용하여 노출할 수 있는 <a href=/ko/docs/concepts/workloads/pods/downward-api/#%EC%82%AC%EC%9A%A9-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%95%84%EB%93%9C>이용 가능한 필드</a> 목록을 읽어보자.</li></ul><p>레거시 API 레퍼런스에서 볼륨에 대해 읽어본다.</p><ul><li>컨테이너가 접근할 파드 내의 일반 볼륨을 정의하는
<a href=/docs/reference/generated/kubernetes-api/v1.25/#volume-v1-core><code>Volume</code></a> API 정의를 확인한다.</li><li>다운워드 API 정보를 포함하는 볼륨을 정의하는
<a href=/docs/reference/generated/kubernetes-api/v1.25/#downwardapivolumesource-v1-core><code>DownwardAPIVolumeSource</code></a> API 정의를 확인한다.</li><li>다운워드 API 볼륨 내 파일을 채우기 위한
오브젝트 또는 리소스 필드로의 레퍼런스를 포함하는
<a href=/docs/reference/generated/kubernetes-api/v1.25/#downwardapivolumefile-v1-core><code>DownwardAPIVolumeFile</code></a> API 정의를 확인한다.</li><li>컨테이너 리소스 및 이들의 출력 형식을 지정하는
<a href=/docs/reference/generated/kubernetes-api/v1.25/#resourcefieldselector-v1-core><code>ResourceFieldSelector</code></a> API 정의를 확인한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7f9454a1e775548c23ee5b300a9218a3>7.6 - 시크릿(Secret)을 사용하여 안전하게 자격증명 배포하기</h1><p>본 페이지는 암호 및 암호화 키와 같은 민감한 데이터를 파드에 안전하게
주입하는 방법을 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h3 id=시크릿-데이터를-base-64-표현으로-변환하기>시크릿 데이터를 base-64 표현으로 변환하기</h3><p>사용자 이름 <code>my-app</code>과 비밀번호 <code>39528$vdg7Jb</code>의 두 가지 시크릿 데이터가 필요하다고 가정한다.
먼저 base64 인코딩 도구를 사용하여 사용자 이름과 암호를 base64 표현으로 변환한다. 다음은 일반적으로 사용 가능한 base64 프로그램을 사용하는 예제이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;my-app&#39;</span> | base64
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;39528$vdg7Jb&#39;</span> | base64
</span></span></code></pre></div><p>사용자 이름의 base-64 표현이 <code>bXktYXBw</code>이고 암호의 base-64 표현이 <code>Mzk1MjgkdmRnN0pi</code>임을
출력을 통해 확인할 수 있다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 사용자의 OS가 신뢰하는 로컬 툴을 사용하여 외부 툴의 보안 위험을 줄이자.</div><h2 id=시크릿-생성하기>시크릿 생성하기</h2><p>다음은 사용자 이름과 암호가 들어 있는 시크릿을 생성하는 데 사용할 수 있는
구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/inject/secret.yaml download=pods/inject/secret.yaml><code>pods/inject/secret.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-secret-yaml")' title="Copy pods/inject/secret.yaml to clipboard"></img></div><div class=includecode id=pods-inject-secret-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>bXktYXBw<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>Mzk1MjgkdmRnN0pi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>시크릿을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/inject/secret.yaml
</span></span></code></pre></div></li><li><p>시크릿에 대한 정보를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret test-secret
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>NAME          TYPE      DATA      AGE
test-secret   Opaque    2         1m
</code></pre></li><li><p>시크릿에 대한 자세한 정보를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe secret test-secret
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>Name:       test-secret
Namespace:  default
Labels:     &lt;none&gt;
Annotations:    &lt;none&gt;

Type:   Opaque

Data
====
password:   13 bytes
username:   7 bytes
</code></pre></li></ol><h3 id=kubectl로-직접-시크릿-생성하기>kubectl로 직접 시크릿 생성하기</h3><p>Base64 인코딩 단계를 건너뛰려면 <code>kubectl create secret</code> 명령을 사용하여
동일한 Secret을 생성할 수 있다. 다음은 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-secret --from-literal<span style=color:#666>=</span><span style=color:#b44>&#39;username=my-app&#39;</span> --from-literal<span style=color:#666>=</span><span style=color:#b44>&#39;password=39528$vdg7Jb&#39;</span>
</span></span></code></pre></div><p>이와 같이 더 편리하게 사용할 수 있다. 앞에서 설명한 자세한 접근 방식은 각 단계를
명시적으로 실행하여 현재 상황을 확인할 수 있다.</p><h2 id=볼륨을-통해-시크릿-데이터에-접근할-수-있는-파드-생성하기>볼륨을 통해 시크릿 데이터에 접근할 수 있는 파드 생성하기</h2><p>다음은 파드를 생성하는 데 사용할 수 있는 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/inject/secret-pod.yaml download=pods/inject/secret-pod.yaml><code>pods/inject/secret-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-secret-pod-yaml")' title="Copy pods/inject/secret-pod.yaml to clipboard"></img></div><div class=includecode id=pods-inject-secret-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># name must match the volume name below</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># The secret data is exposed to Containers in the Pod through a Volume.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>test-secret<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/inject/secret-pod.yaml
</span></span></code></pre></div></li><li><p>파드가 실행중인지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod secret-test-pod
</span></span></code></pre></div><p>Output:</p><pre tabindex=0><code>NAME              READY     STATUS    RESTARTS   AGE
secret-test-pod   1/1       Running   0          42m
</code></pre></li><li><p>파드에서 실행 중인 컨테이너의 셸을 가져오자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t secret-test-pod -- /bin/bash
</span></span></code></pre></div></li><li><p>시크릿 데이터는 <code>/etc/secret-volume</code>에 마운트된 볼륨을 통해
컨테이너에 노출된다.</p><p>셸에서 <code>/etc/secret-volume</code> 디렉터리의 파일을 나열한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 컨테이너 내부의 셸에서 실행하자</span>
</span></span><span style=display:flex><span>ls /etc/secret-volume
</span></span></code></pre></div><p>두 개의 파일과 각 파일의 시크릿 데이터 조각을 확인할 수 있다.</p><pre tabindex=0><code>password username
</code></pre></li><li><p>셸에서 <code>username</code> 및 <code>password</code> 파일의 내용을 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 컨테이너 내부의 셸에서 실행하자</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span> cat /etc/secret-volume/username <span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span> cat /etc/secret-volume/password <span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><p>사용자 이름과 비밀번호가 출력된다.</p><pre tabindex=0><code>my-app
39528$vdg7Jb
</code></pre></li></ol><h2 id=시크릿-데이터를-사용하여-컨테이너-환경-변수-정의하기>시크릿 데이터를 사용하여 컨테이너 환경 변수 정의하기</h2><h3 id=단일-시크릿-데이터로-컨테이너-환경-변수-정의하기>단일 시크릿 데이터로 컨테이너 환경 변수 정의하기</h3><ul><li><p>환경 변수를 시크릿의 키-값 쌍으로 정의한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic backend-user --from-literal<span style=color:#666>=</span>backend-username<span style=color:#666>=</span><span style=color:#b44>&#39;backend-admin&#39;</span>
</span></span></code></pre></div></li><li><p>시크릿에 정의된 <code>backend-username</code> 값을 파드 명세의 <code>SECRET_USERNAME</code> 환경 변수에 할당한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/inject/pod-single-secret-env-variable.yaml download=pods/inject/pod-single-secret-env-variable.yaml><code>pods/inject/pod-single-secret-env-variable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-pod-single-secret-env-variable-yaml")' title="Copy pods/inject/pod-single-secret-env-variable.yaml to clipboard"></img></div><div class=includecode id=pods-inject-pod-single-secret-env-variable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-single-secret<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envars-test-container<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>backend-user<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>backend-username<span style=color:#bbb>
   </span></span></span></code></pre></div></div></div></li><li><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/inject/pod-single-secret-env-variable.yaml
</span></span></code></pre></div></li><li><p>셸에서 <code>SECRET_USERNAME</code> 컨테이너 환경 변수의 내용을 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t env-single-secret -- /bin/sh -c <span style=color:#b44>&#39;echo $SECRET_USERNAME&#39;</span>
</span></span></code></pre></div><p>출력은 다음과 같다.</p><pre tabindex=0><code>backend-admin
</code></pre></li></ul><h3 id=여러-시크릿-데이터로-컨테이너-환경-변수-정의하기>여러 시크릿 데이터로 컨테이너 환경 변수 정의하기</h3><ul><li><p>이전 예제와 마찬가지로 시크릿을 먼저 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic backend-user --from-literal<span style=color:#666>=</span>backend-username<span style=color:#666>=</span><span style=color:#b44>&#39;backend-admin&#39;</span>
</span></span><span style=display:flex><span>kubectl create secret generic db-user --from-literal<span style=color:#666>=</span>db-username<span style=color:#666>=</span><span style=color:#b44>&#39;db-admin&#39;</span>
</span></span></code></pre></div></li><li><p>파드 명세에 환경 변수를 정의한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/inject/pod-multiple-secret-env-variable.yaml download=pods/inject/pod-multiple-secret-env-variable.yaml><code>pods/inject/pod-multiple-secret-env-variable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-pod-multiple-secret-env-variable-yaml")' title="Copy pods/inject/pod-multiple-secret-env-variable.yaml to clipboard"></img></div><div class=includecode id=pods-inject-pod-multiple-secret-env-variable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envvars-multiple-secrets<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envars-test-container<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>BACKEND_USERNAME<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>backend-user<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>backend-username<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DB_USERNAME<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>db-username<span style=color:#bbb>
   </span></span></span></code></pre></div></div></div></li><li><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/inject/pod-multiple-secret-env-variable.yaml
</span></span></code></pre></div></li><li><p>셸에서 컨테이너 환경 변수를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t envvars-multiple-secrets -- /bin/sh -c <span style=color:#b44>&#39;env | grep _USERNAME&#39;</span>
</span></span></code></pre></div><p>출력은 다음과 같다.</p><pre tabindex=0><code>DB_USERNAME=db-admin
BACKEND_USERNAME=backend-admin
</code></pre></li></ul><h2 id=시크릿의-모든-키-값-쌍을-컨테이너-환경-변수로-구성하기>시크릿의 모든 키-값 쌍을 컨테이너 환경 변수로 구성하기</h2><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 기능은 쿠버네티스 v1.6 이상에서 사용할 수 있다.</div><ul><li><p>여러 키-값 쌍을 포함하는 시크릿을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span><span style=color:#b44>&#39;my-app&#39;</span> --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;39528$vdg7Jb&#39;</span>
</span></span></code></pre></div></li><li><p>envFrom을 사용하여 시크릿의 모든 데이터를 컨테이너 환경 변수로 정의한다. 시크릿의 키는 파드에서 환경 변수의 이름이 된다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/inject/pod-secret-envFrom.yaml download=pods/inject/pod-secret-envFrom.yaml><code>pods/inject/pod-secret-envFrom.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-pod-secret-envfrom-yaml")' title="Copy pods/inject/pod-secret-envFrom.yaml to clipboard"></img></div><div class=includecode id=pods-inject-pod-secret-envfrom-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envfrom-secret<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envars-test-container<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-secret<span style=color:#bbb>
    </span></span></span></code></pre></div></div></div></li><li><p>파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/inject/pod-secret-envFrom.yaml
</span></span></code></pre></div></li><li><p><code>username</code> 및 <code>password</code> 컨테이너 환경 변수를 셸에서 출력한다.</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t envfrom-secret -- /bin/sh -c <span style=color:#b44>&#39;echo &#34;username: $username\npassword: $password\n&#34;&#39;</span>
</span></span></code></pre></div><p>출력은 다음과 같다.</p><pre tabindex=0><code>username: my-app
password: 39528$vdg7Jb
</code></pre><h3 id=참고>참고</h3><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#secret-v1-core>시크릿</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#volume-v1-core>볼륨</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>파드</a></li></ul><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/configuration/secret/>시크릿</a>에 대해 더 배워 보기.</li><li><a href=/ko/docs/concepts/storage/volumes/>볼륨</a>에 대해 더 배워 보기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a78a5e7e765fd8c49c8f7c0d72499f72>8 - 애플리케이션 실행</h1><div class=lead>스테이트리스와 스테이트풀 애플리케이션 모두를 실행하고 관리한다.</div></div><div class=td-content><h1 id=pg-790ea02857492b3a822e981e93e3a98b>8.1 - 디플로이먼트(Deployment)로 스테이트리스 애플리케이션 실행하기</h1><p>이 페이지에서는 쿠버네티스 디플로이먼트 오브젝트를 사용하여 애플리케이션을 실행하는 방법을 설명한다.</p><h2 id=목적>목적</h2><ul><li>nginx 디플로이먼트 생성하기</li><li>kubectl을 사용하여 디플로이먼트 정보 나열하기</li><li>디플로이먼트 업데이트하기</li></ul><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.9.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=nginx-디플로이먼트-생성하고-탐색하기>nginx 디플로이먼트 생성하고 탐색하기</h2><p>쿠버네티스 디플로이먼트 오브젝트를 생성하여 애플리케이션을 실행할 수 있으며,
디플로이먼트에 대한 명세를 YAML 파일에 기술할 수 있다. 예를 들어 이 YAML 파일은
nginx:1.14.2 도커 이미지를 실행하는 디플로이먼트에 대한 명세를 담고 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>YAML 파일을 기반으로 디플로이먼트를 생성한다.</p><pre><code> kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</code></pre></li><li><p>디플로이먼트에 대한 정보를 살펴본다.</p><pre><code> kubectl describe deployment nginx-deployment
</code></pre><p>출력은 다음과 유사하다.</p><pre><code> Name:     nginx-deployment
 Namespace:    default
 CreationTimestamp:  Tue, 30 Aug 2016 18:11:37 -0700
 Labels:     app=nginx
 Annotations:    deployment.kubernetes.io/revision=1
 Selector:   app=nginx
 Replicas:   2 desired | 2 updated | 2 total | 2 available | 0 unavailable
 StrategyType:   RollingUpdate
 MinReadySeconds:  0
 RollingUpdateStrategy:  1 max unavailable, 1 max surge
 Pod Template:
   Labels:       app=nginx
   Containers:
    nginx:
     Image:              nginx:1.14.2
     Port:               80/TCP
     Environment:        &lt;none&gt;
     Mounts:             &lt;none&gt;
   Volumes:              &lt;none&gt;
 Conditions:
   Type          Status  Reason
   ----          ------  ------
   Available     True    MinimumReplicasAvailable
   Progressing   True    NewReplicaSetAvailable
 OldReplicaSets:   &lt;none&gt;
 NewReplicaSet:    nginx-deployment-1771418926 (2/2 replicas created)
 No events.
</code></pre></li><li><p>디플로이먼트에 의해 생성된 파드를 나열한다.</p><pre><code> kubectl get pods -l app=nginx
</code></pre><p>출력은 다음과 유사하다.</p><pre><code> NAME                                READY     STATUS    RESTARTS   AGE
 nginx-deployment-1771418926-7o5ns   1/1       Running   0          16h
 nginx-deployment-1771418926-r18az   1/1       Running   0          16h
</code></pre></li><li><p>파드에 대한 정보를 살펴본다.</p><pre><code> kubectl describe pod &lt;pod-name&gt;
</code></pre><p><code>&lt;pod-name></code>은 파드 중 하나의 이름이다.</p></li></ol><h2 id=디플로이먼트-업데이트하기>디플로이먼트 업데이트하기</h2><p>새 YAML 파일을 적용하여 디플로이먼트를 업데이트할 수 있다. 이 YAML 파일은
nginx 1.16.1을 사용하도록 디플로이먼트를 업데이트해야 함을 명시하고 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/deployment-update.yaml download=application/deployment-update.yaml><code>application/deployment-update.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-update-yaml")' title="Copy application/deployment-update.yaml to clipboard"></img></div><div class=includecode id=application-deployment-update-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Update the version of nginx from 1.14.2 to 1.16.1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>새 YAML 파일을 적용한다.</p><pre><code>  kubectl apply -f https://k8s.io/examples/application/deployment-update.yaml
</code></pre></li><li><p>디플로이먼트가 새 이름으로 파드를 생성하고 이전 파드를 삭제하는 것을 확인한다.</p><pre><code>  kubectl get pods -l app=nginx
</code></pre></li></ol><h2 id=레플리카-수를-늘려-애플리케이션-확장하기>레플리카 수를 늘려 애플리케이션 확장하기</h2><p>새 YAML 파일을 적용하여 디플로이먼트의 파드 수를 늘릴 수 있다.
이 YAML 파일은 <code>replicas</code>를 4로 설정하여 디플로이먼트에
4개의 파드가 있어야 함을 명시하고 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/deployment-scale.yaml download=application/deployment-scale.yaml><code>application/deployment-scale.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-scale-yaml")' title="Copy application/deployment-scale.yaml to clipboard"></img></div><div class=includecode id=application-deployment-scale-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Update the replicas from 2 to 4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>새 YAML 파일을 적용한다.</p><pre><code> kubectl apply -f https://k8s.io/examples/application/deployment-scale.yaml
</code></pre></li><li><p>디플로이먼트에 4개의 파드가 있는지 확인한다.</p><pre><code> kubectl get pods -l app=nginx
</code></pre><p>출력은 다음과 유사하다.</p><pre><code> NAME                               READY     STATUS    RESTARTS   AGE
 nginx-deployment-148880595-4zdqq   1/1       Running   0          25s
 nginx-deployment-148880595-6zgi1   1/1       Running   0          25s
 nginx-deployment-148880595-fxcez   1/1       Running   0          2m
 nginx-deployment-148880595-rwovn   1/1       Running   0          2m
</code></pre></li></ol><h2 id=디플로이먼트-삭제하기>디플로이먼트 삭제하기</h2><p>이름으로 디플로이먼트를 삭제한다.</p><pre><code>kubectl delete deployment nginx-deployment
</code></pre><h2 id=replicationcontrollers-예전-방식>ReplicationControllers -- 예전 방식</h2><p>애플리케이션을 복제하여 생성하는 기본적인 방법은 내부적으로 레플리카셋(ReplicaSet)을 활용하는 디플로이먼트를
사용하는 것이다. 쿠버네티스에 디플로이먼트 및 레플리카셋이 도입되기 전에는
<a href=/ko/docs/concepts/workloads/controllers/replicationcontroller/>레플리케이션컨트롤러(ReplicationController)</a>를 사용하여 복제 애플리케이션을
구성했었다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트 오브젝트</a>에 대해 더 배워보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-43398a6f5dc7ce19df59f5f4c2e7922d>8.2 - 단일 인스턴스 스테이트풀 애플리케이션 실행하기</h1><p>이 페이지에서는 쿠버네티스 클러스터에서 퍼시스턴트볼륨(PersistentVolume)과 디플로이먼트(Deployment)를
사용하여, 단일 인스턴스 스테이트풀 애플리케이션을 실행하는 방법을 보인다.
해당 애플리케이션은 MySQL이다.</p><h2 id=목적>목적</h2><ul><li>사용자 환경의 디스크를 참조하는 퍼시스턴트볼륨 생성하기</li><li>MySQL 디플로이먼트 생성하기</li><li>알려진 DNS 이름으로 클러스터의 다른 파드에 MySQL 서비스 노출하기</li></ul><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p></li><li><p>여기에서 사용된 <a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8%ED%81%B4%EB%A0%88%EC%9E%84>퍼시스턴트볼륨클레임</a>을 만족하기 위하여,
기본 <a href=/ko/docs/concepts/storage/storage-classes/>스토리지클래스</a>가 설정되어 있는 상태의
<a href=/ko/docs/concepts/storage/dynamic-provisioning/>동적 퍼시스턴트볼륨 프로비저너</a>, 또는
<a href=/ko/docs/concepts/storage/persistent-volumes/#%EC%A0%95%EC%A0%81-%ED%94%84%EB%A1%9C%EB%B9%84%EC%A0%80%EB%8B%9D>정적으로(statically) 프로비저닝된 퍼시스턴트볼륨</a>이
필요하다.</p></li></ul><h2 id=mysql-배포하기>MySQL 배포하기</h2><p>쿠버네티스 디플로이먼트를 생성하고 퍼시스턴트볼륨클레임(PersistentVolumeClaim)을
사용하는 기존 퍼시스턴트볼륨에 연결하여 스테이트풀
애플리케이션을 실행할 수 있다. 예를 들어, 다음 YAML 파일은
MySQL을 실행하고 퍼시스턴트볼륨클레임을 참조하는 디플로이먼트를 기술한다.
이 파일은 /var/lib/mysql에 대한 볼륨 마운트를 정의한 후에,
20G의 볼륨을 요청하는 퍼시트턴트볼륨클레임을 생성한다.
이 클레임은 요구 사항에 적합한 기존 볼륨이나
동적 프로비저너에 의해서 충족된다.</p><p>참고: config yaml 파일에 정의된 비밀번호는 안전하지 않다. 더 안전한 해결방법을 위해
<a href=/ko/docs/concepts/configuration/secret/>쿠버네티스 시크릿</a>
을 보자</p><p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/mysql/mysql-deployment.yaml download=application/mysql/mysql-deployment.yaml><code>application/mysql/mysql-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-mysql-mysql-deployment-yaml")' title="Copy application/mysql/mysql-deployment.yaml to clipboard"></img></div><div class=includecode id=application-mysql-mysql-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># Use secret in real usage</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/mysql/mysql-pv.yaml download=application/mysql/mysql-pv.yaml><code>application/mysql/mysql-pv.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-mysql-mysql-pv-yaml")' title="Copy application/mysql/mysql-pv.yaml to clipboard"></img></div><div class=includecode id=application-mysql-mysql-pv-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pv-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>local<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/mnt/data&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div></p><ol><li><p>YAML 파일의 PV와 PVC를 배포한다.</p><pre><code> kubectl apply -f https://k8s.io/examples/application/mysql/mysql-pv.yaml
</code></pre></li><li><p>YAML 파일의 다른 오브젝트들을 배포한다.</p><pre><code> kubectl apply -f https://k8s.io/examples/application/mysql/mysql-deployment.yaml
</code></pre></li><li><p>디플로이먼트에 관한 정보를 확인한다.</p><pre><code> kubectl describe deployment mysql
</code></pre><p>출력은 다음과 유사하다.</p><pre><code> Name:                 mysql
 Namespace:            default
 CreationTimestamp:    Tue, 01 Nov 2016 11:18:45 -0700
 Labels:               app=mysql
 Annotations:          deployment.kubernetes.io/revision=1
 Selector:             app=mysql
 Replicas:             1 desired | 1 updated | 1 total | 0 available | 1 unavailable
 StrategyType:         Recreate
 MinReadySeconds:      0
 Pod Template:
   Labels:       app=mysql
   Containers:
    mysql:
     Image:      mysql:5.6
     Port:       3306/TCP
     Environment:
       MYSQL_ROOT_PASSWORD:      password
     Mounts:
       /var/lib/mysql from mysql-persistent-storage (rw)
   Volumes:
    mysql-persistent-storage:
     Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)
     ClaimName:  mysql-pv-claim
     ReadOnly:   false
 Conditions:
   Type          Status  Reason
   ----          ------  ------
   Available     False   MinimumReplicasUnavailable
   Progressing   True    ReplicaSetUpdated
 OldReplicaSets:       &lt;none&gt;
 NewReplicaSet:        mysql-63082529 (1/1 replicas created)
 Events:
   FirstSeen    LastSeen    Count    From                SubobjectPath    Type        Reason            Message
   ---------    --------    -----    ----                -------------    --------    ------            -------
   33s          33s         1        {deployment-controller }             Normal      ScalingReplicaSet Scaled up replica set mysql-63082529 to 1
</code></pre></li><li><p>디플로이먼트로 생성된 파드를 나열한다.</p><pre><code> kubectl get pods -l app=mysql
</code></pre><p>출력은 다음과 유사하다.</p><pre><code> NAME                   READY     STATUS    RESTARTS   AGE
 mysql-63082529-2z3ki   1/1       Running   0          3m
</code></pre></li><li><p>퍼시스턴트볼륨클레임을 살펴본다.</p><pre><code> kubectl describe pvc mysql-pv-claim
</code></pre><p>출력은 다음과 유사하다.</p><pre><code> Name:         mysql-pv-claim
 Namespace:    default
 StorageClass:
 Status:       Bound
 Volume:       mysql-pv-volume
 Labels:       &lt;none&gt;
 Annotations:    pv.kubernetes.io/bind-completed=yes
                 pv.kubernetes.io/bound-by-controller=yes
 Capacity:     20Gi
 Access Modes: RWO
 Events:       &lt;none&gt;
</code></pre></li></ol><h2 id=mysql-인스턴스-접근하기>MySQL 인스턴스 접근하기</h2><p>이전의 YAML 파일은 클러스터의 다른 파드가 데이터베이스에
접근할 수 있는 서비스를 생성한다. <code>clusterIP: None</code>
서비스 옵션을 사용하면 서비스의 DNS 이름을 직접 파드의 IP 주소로
해석하도록 처리한다. 이 방법은 서비스에서 연결되는 파드가 오직 하나 뿐이고,
파드의 수를 더 늘릴 필요가 없는 경우에 가장 적합하다.</p><p>서버에 접속하기 위하여 MySQL 클라이언트를 실행한다.</p><pre tabindex=0><code>kubectl run -it --rm --image=mysql:5.6 --restart=Never mysql-client -- mysql -h mysql -ppassword
</code></pre><p>이 명령어는 MySQL 클라이언트를 실행하는 파드를 클러스터에 생성하고,
서비스를 통하여 서버에 연결한다. 연결된다면, 스테이트풀
MySQL 데이터베이스가 실행 중임을 알 수 있다.</p><pre tabindex=0><code>Waiting for pod default/mysql-client-274442439-zyp6i to be running, status is Pending, pod ready: false
If you don&#39;t see a command prompt, try pressing enter.

mysql&gt;
</code></pre><h2 id=업데이트하기>업데이트하기</h2><p><code>kubectl apply</code> 명령을 사용하여 기존과 동일한 방식으로 디플로이먼트의
이미지나 다른 부분을 변경할 수 있다. 스테이트풀 애플리케이션과 관련하여 몇 가지
주의 사항이 있다.</p><ul><li>애플리케이션을 스케일링하지 않는다. 이 설정은 단일 인스턴스 애플리케이션 전용이다.
기본적인 퍼시스턴트볼륨은 하나의 파드에서만 마운트할 수 있다.
클러스터 형태의 스테이트풀 애플리케이션에 대해서는
<a href=/ko/docs/concepts/workloads/controllers/statefulset/>스테이트풀셋</a>을 보자.</li><li>디플로이먼트 구성 YAML 파일에서 <code>strategy:</code>
<code>type: Recreate</code> 를 사용한다. 이는 쿠버네티스가
롤링 업데이트를 사용하지 <em>않도록</em> 지시한다. 동시에 두 개 이상의 파드를 생성할
수 없으므로, 롤링 업데이트는 일어나지 않게 된다. <code>Recreate</code> 전략을 사용하면
변경된 구성으로 새로운 파드를 생성하기에 앞서 기존의 파드를 중단한다.</li></ul><h2 id=디플로이먼트-삭제하기>디플로이먼트 삭제하기</h2><p>이름으로 배포된 오브젝트를 삭제한다.</p><pre tabindex=0><code>kubectl delete deployment,svc mysql
kubectl delete pvc mysql-pv-claim
kubectl delete pv mysql-pv-volume
</code></pre><p>퍼시스턴트볼륨을 수동으로 프로비저닝한 경우라면,
동일하게 수동으로 삭제하고 기본 리소스도 해제해야 한다.
동적 프로비저너를 사용한 경우, 퍼시스턴트볼륨클레임이
삭제되었을 때에 퍼시스턴트볼륨 또한 자동으로 삭제된다.
일부 동적 프로비저너(EBS 와 PD와 같은)는
퍼시스턴트볼륨을 삭제할 때에 기본 리소스도 해제한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><p><a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트 오브젝트</a>에 대해 더 배워 보기</p></li><li><p><a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>애플리케이션 배포하기</a>에 대해 더 배워보기</p></li><li><p><a href=/docs/reference/generated/kubectl/kubectl-commands/#run>kubectl run 문서</a></p></li><li><p><a href=/ko/docs/concepts/storage/volumes/>볼륨</a>과 <a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트 볼륨</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7a9b5779e228083ba3fdeaf414fe704e>8.3 - 스테이트풀셋(StatefulSet) 확장하기</h1><p>이 작업은 스테이트풀셋을 확장하는 방법을 보여준다. 스테이트풀셋 확장은 레플리카 수를 늘리거나 줄이는 것을 의미한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><p>스테이트풀셋은 쿠버네티스 버전 1.5 이상에서만 사용할 수 있다.
쿠버네티스 버전을 확인하려면 <code>kubectl version</code>을 실행한다.</p></li><li><p>모든 스테이트풀 애플리케이션이 제대로 확장되는 것은 아니다. 스테이트풀셋을 확장할지 여부가 확실하지 않은 경우에 자세한 내용은 <a href=/ko/docs/concepts/workloads/controllers/statefulset/>스테이트풀셋</a> 또는 <a href=/ko/docs/tutorials/stateful-application/basic-stateful-set/>스테이트풀셋 튜토리얼</a>을 참조한다.</p></li><li><p>스테이트풀 애플리케이션 클러스터가 완전히 정상이라고 확신할 때만
확장을 수행해야 한다.</p></li></ul><h2 id=스테이트풀셋-확장하기>스테이트풀셋 확장하기</h2><h3 id=kubectl을-사용하여-스테이트풀셋-확장>kubectl을 사용하여 스테이트풀셋 확장</h3><p>먼저 확장하려는 스테이트풀셋을 찾는다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets &lt;stateful-set-name&gt;
</span></span></code></pre></div><p>스테이트풀셋의 레플리카 수를 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale statefulsets &lt;stateful-set-name&gt; --replicas<span style=color:#666>=</span>&lt;new-replicas&gt;
</span></span></code></pre></div><h3 id=스테이트풀셋-인플레이스-in-place-업데이트>스테이트풀셋 인플레이스(in-place) 업데이트</h3><p>대안으로 스테이트풀셋에 <a href=/ko/docs/concepts/cluster-administration/manage-deployment/#in-place-updates-of-resources>인플레이스 업데이트</a>를 수행할 수 있다.</p><p>스테이트풀셋이 처음에 <code>kubectl apply</code>로 생성된 경우,
스테이트풀셋 매니페스트의 <code>.spec.replicas</code>를 업데이트한 다음 <code>kubectl apply</code>를 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f &lt;stateful-set-file-updated&gt;
</span></span></code></pre></div><p>그렇지 않으면 <code>kubectl edit</code>로 해당 필드를 편집한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit statefulsets &lt;stateful-set-name&gt;
</span></span></code></pre></div><p>또는 <code>kubectl patch</code>를 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch statefulsets &lt;stateful-set-name&gt; -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;replicas&#34;:&lt;new-replicas&gt;}}&#39;</span>
</span></span></code></pre></div><h2 id=트러블슈팅>트러블슈팅</h2><h3 id=축소가-제대로-작동하지-않음>축소가 제대로 작동하지 않음</h3><p>스테이트풀셋에서 관리하는 스테이트풀 파드가 비정상인 경우에는 스테이트풀셋을 축소할 수 없다. 축소는
스테이트풀 파드가 실행되고 준비된 후에만 발생한다.</p><p>spec.replicas > 1인 경우 쿠버네티스는 비정상 파드의 원인을 결정할 수 없다. 영구적인 오류 또는 일시적인 오류의 결과일 수 있다. 일시적인 오류는 업그레이드 또는 유지 관리에 필요한 재시작으로 인해 발생할 수 있다.</p><p>영구적인 오류로 인해 파드가 비정상인 경우
오류를 수정하지 않고 확장하면 스테이트풀셋 멤버십이 올바르게 작동하는 데 필요한
특정 최소 레플리카 수 아래로 떨어지는 상태로 이어질 수 있다.
이로 인해 스테이트풀셋을 사용할 수 없게 될 수 있다.</p><p>일시적인 오류로 인해 파드가 비정상 상태이고 파드를 다시 사용할 수 있게 되면
일시적인 오류가 확장 또는 축소 작업을 방해할 수 있다. 일부 분산
데이터베이스에는 노드가 동시에 가입 및 탈퇴할 때 문제가 있다. 이러한 경우
애플리케이션 수준에서 확장 작업에 대해 추론하고 스테이트풀 애플리케이션 클러스터가
완전히 정상이라고 확신할 때만 확장을 수행하는 것이 좋다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/run-application/delete-stateful-set/>스테이트풀셋 삭제하기</a>에 대해 더 배워보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c43537b0ee1da992ecb7488f87e6c934>8.4 - 스테이트풀셋(StatefulSet) 삭제하기</h1><p>이 작업은 <a class=glossary-tooltip title='내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a>을 삭제하는 방법을 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li>이 작업은 클러스터에 스테이트풀셋으로 표시되는 애플리케이션이 있다고 가정한다.</li></ul><h2 id=스테이트풀셋-삭제>스테이트풀셋 삭제</h2><p>쿠버네티스에서 다른 리소스를 삭제하는 것과 같은 방식으로 스테이트풀셋을 삭제할 수 있다. <code>kubectl delete</code> 명령어를 사용하고 파일 또는 이름으로 스테이트풀셋을 지정하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete -f &lt;file.yaml&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete statefulsets &lt;statefulset-name&gt;
</span></span></code></pre></div><p>스테이트풀셋 자체를 삭제한 후 연결된 헤드리스 서비스는 별도로 삭제해야 할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete service &lt;service-name&gt;
</span></span></code></pre></div><p>kubectl을 통해 스테이트풀셋을 삭제하면, 스테이트풀셋의 크기가 0으로 설정되고 이로 인해 스테이트풀셋에 포함된 모든 파드가 삭제된다. 파드가 아닌 스테이트풀셋만 삭제하려면, <code>--cascade=orphan</code> 옵션을 사용한다.
예시는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete -f &lt;file.yaml&gt; --cascade<span style=color:#666>=</span>orphan
</span></span></code></pre></div><p><code>kubectl delete</code> 에 <code>--cascade=orphan</code> 를 사용하면 스테이트풀셋 오브젝트가 삭제된 후에도 스테이트풀셋에 의해 관리된 파드는 남게 된다. 만약 파드가 <code>app.kubernetes.io/name=MyApp</code> 레이블을 갖고 있다면, 다음과 같이 파드를 삭제할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pods -l app.kubernetes.io/name<span style=color:#666>=</span>MyApp
</span></span></code></pre></div><h3 id=퍼시스턴트볼륨-persistentvolume>퍼시스턴트볼륨(PersistentVolume)</h3><p>스테이트풀셋의 파드들을 삭제하는 것이 연결된 볼륨을 삭제하는 것은 아니다. 이것은 볼륨을 삭제하기 전에 볼륨에서 데이터를 복사할 수 있는 기회를 준다. 파드가 종료된 후 PVC를 삭제하면 스토리지 클래스와 반환 정책에 따라 백업 퍼시스턴트볼륨 삭제가 트리거될 수 있다. 클레임 삭제 후 볼륨에 접근할 수 있다고 가정하면 안된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> PVC를 삭제할 때 데이터 손실될 수 있음에 주의하자.</div><h3 id=스테이트풀셋의-완벽한-삭제>스테이트풀셋의 완벽한 삭제</h3><p>연결된 파드를 포함해서 스테이트풀셋의 모든 것을 삭제하기 위해 다음과 같이 일련의 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>grace</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods &lt;stateful-set-pod&gt; --template <span style=color:#b44>&#39;{{.spec.terminationGracePeriodSeconds}}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>kubectl delete statefulset -l app.kubernetes.io/name<span style=color:#666>=</span>MyApp
</span></span><span style=display:flex><span>sleep <span style=color:#b8860b>$grace</span>
</span></span><span style=display:flex><span>kubectl delete pvc -l app.kubernetes.io/name<span style=color:#666>=</span>MyApp
</span></span></code></pre></div><p>위의 예에서 파드에는 <code>app.kubernetes.io/name=MyApp</code> 라는 레이블이 있다. 사용자에게 적절한 레이블로 대체하자.</p><h3 id=스테이트풀셋-파드의-강제-삭제>스테이트풀셋 파드의 강제 삭제</h3><p>스테이트풀셋의 일부 파드가 오랫동안 'Terminating' 또는 'Unknown' 상태에 있는 경우, apiserver에 수동적으로 개입하여 파드를 강제 삭제할 수도 있다. 이것은 잠재적으로 위험한 작업이다. 자세한 설명은 <a href=/ko/docs/tasks/run-application/force-delete-stateful-set-pod/>스테이트풀셋 파드 강제 삭제하기</a>를 참고한다.</p><h2 id=다음-내용>다음 내용</h2><p><a href=/ko/docs/tasks/run-application/force-delete-stateful-set-pod/>스테이트풀셋 파드 강제 삭제하기</a>에 대해 더 알아보기.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f5f2f7a74377a9d45325c5253353fa8f>8.5 - 스테이트풀셋(StatefulSet) 파드 강제 삭제하기</h1><p>이 페이지에서는 <a class=glossary-tooltip title='내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a>의 일부인 파드를 삭제하는 방법을 보여주고
이 과정에서 고려해야 할 사항을 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li>이것은 상당히 고급 태스크이며 스테이트풀셋 고유의 속성 중 일부를 위반할 가능성이 있다.</li><li>계속하기 전에 아래 나열된 고려 사항을 숙지하도록 한다.</li></ul><h2 id=스테이트풀셋-고려-사항>스테이트풀셋 고려 사항</h2><p>정상적인 스테이트풀셋의 작동에서는 스테이트풀셋 파드를 강제로 삭제할 필요가 <strong>절대</strong> 없다. <a href=/ko/docs/concepts/workloads/controllers/statefulset/>스테이트풀셋 컨트롤러</a>는 스테이트풀셋의 멤버 생성, 스케일링, 삭제를 담당한다. 서수 0부터 N-1까지 지정된 수의 파드가 활성 상태이고 준비되었는지 확인한다. 스테이트풀셋은 언제든지 클러스터에서 실행 중인 지정된 신원을 가진 최대 하나의 파드가 있는지 확인한다. 이를 스테이트풀셋에서 제공하는 <em>최대 하나</em> 의미론이라고 한다.</p><p>수동 강제 삭제는 스테이트풀셋 고유의 최대 하나 의미론을 위반할 가능성이 있으므로 주의해서 수행해야 한다. 스테이트풀셋은 안정적인 네트워크 신원과 안정적인 스토리지가 필요한 분산 클러스터 애플리케이션을 실행하는 데 사용할 수 있다. 이러한 애플리케이션은 종종 고정된 신원을 가진 고정된 수의 구성원 앙상블에 의존하는 구성을 가진다. 여러 구성원이 동일한 신원을 갖는 것은 재앙이 될 수 있으며 데이터 손실로 이어질 수 있다(예: 쿼럼 기반 시스템의 스플릿 브레인(split-brain) 시나리오).</p><h2 id=파드-삭제>파드 삭제</h2><p>다음 명령을 사용하여 파드를 단계적으로 삭제할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pods &lt;pod&gt;
</span></span></code></pre></div><p>위의 내용이 단계적인 종료로 이어지려면 파드가
<code>pod.Spec.TerminationGracePeriodSeconds</code>를 0으로 지정하지 <strong>않아야 한다</strong>.
<code>pod.Spec.TerminationGracePeriodSeconds</code>를 0초로 설정하는 관행은 안전하지 않으며
스테이트풀셋 파드에서 강력히 권장하지 않는다. 단계적 삭제는 안전하며 kubelet이 apiserver에서 이름을 삭제하기 전에 파드가
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>정상적으로 종료</a>되도록 한다.</p><p>노드에 연결할 수 없는 경우 파드는 자동으로 삭제되지 않는다.
연결할 수 없는 노드에서 실행 중인 파드는 <a href=/ko/docs/concepts/architecture/nodes/#condition>타임아웃</a> 후에
'Terminating'이나 'Unknown' 상태가 된다.</p><p>사용자가 연결할 수 없는 노드에서 파드를 단계적으로 삭제하려고 하면 파드가 이러한 상태에 들어갈 수도 있다.
이러한 상태의 파드를 apiserver에서 제거할 수 있는 유일한 방법은 다음과 같다.</p><ul><li>노드 오브젝트가 삭제된다(사용자 또는 <a href=/ko/docs/concepts/architecture/nodes/#%EB%85%B8%EB%93%9C-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC>노드 컨트롤러</a>에 의해).</li><li>응답하지 않는 노드의 kubelet이 응답을 시작하고 파드를 종료하여 apiserver에서 항목을 제거한다.</li><li>사용자가 파드를 강제로 삭제한다.</li></ul><p>권장되는 모범 사례는 첫 번째 또는 두 번째 방법을 사용하는 것이다. 노드가 죽은 것으로 확인되면(예: 네트워크에서 영구적으로 연결이 끊기거나 전원이 꺼진 경우 등) 노드 오브젝트를 삭제한다. 노드에 네트워크 파티션이 있는 경우 이를 해결하거나 해결될 때까지 기다린다. 파티션이 복구되면 kubelet은 파드 삭제를 완료하고 apiserver에서 해당 이름을 해제한다.</p><p>일반적으로 시스템은 파드가 노드에서 더 이상 실행되지 않거나 노드가 관리자에 의해 삭제되면 삭제를 완료한다. 파드를 강제로 삭제하여 이를 재정의할 수 있다.</p><h3 id=강제-삭제>강제 삭제</h3><p>강제 삭제는 파드가 종료되었다는 kubelet의 확인을 기다리지 <strong>않는다</strong>. 강제 삭제가 파드를 죽이는 데 성공했는지 여부와 관계없이 즉시 apiserver에서 이름을 해제한다. 이렇게 하면 스테이트풀셋 컨트롤러가 동일한 신원으로 대체 파드를 생성할 수 있다. 이것은 여전히 실행 중인 파드와 중복될 수 있으며, 해당 파드가 여전히 스테이트풀셋의 다른 멤버와 통신할 수 있다면 스테이트풀셋이 보장하도록 설계된 최대 하나 의미론을 위반할 것이다.</p><p>스테이트풀셋 파드를 강제로 삭제하는 것은 문제의 파드가 스테이트풀셋의 다른 파드와 다시는 접촉하지 않으며 대체 생성을 위해 해당 이름을 안전하게 해제할 수 있다고 주장하는 것이다.</p><p>kubectl 버전 >= 1.5를 사용하여 파드를 강제로 삭제하려면, 다음을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span> --force
</span></span></code></pre></div><p>kubectl &lt;= 1.4 버전을 사용하는 경우, <code>--force</code> 옵션을 생략하고 다음을 사용해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span>
</span></span></code></pre></div><p>이러한 명령 후에도 파드가 <code>Unknown</code> 상태에서 멈추면, 다음 명령을 사용하여 클러스터에서 파드를 제거한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch pod &lt;pod&gt; -p <span style=color:#b44>&#39;{&#34;metadata&#34;:{&#34;finalizers&#34;:null}}&#39;</span>
</span></span></code></pre></div><p>항상 관련된 위험에 대해 완전히 이해한 상태에서 주의 깊게 스테이트풀셋 파드의 강제 삭제를 수행한다.</p><h2 id=다음-내용>다음 내용</h2><p><a href=/ko/docs/tasks/debug/debug-application/debug-statefulset/>스테이트풀셋 디버깅하기</a>에 대해 더 알아보기.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0c0bb1bd76d2a9069e50e2cec6d20c2a>8.6 - Horizontal Pod Autoscaling</h1><p>쿠버네티스에서, <em>HorizontalPodAutoscaler</em> 는 워크로드 리소스(예:
<a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a> 또는
<a class=glossary-tooltip title='내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a>)를 자동으로 업데이트하며,
워크로드의 크기를 수요에 맞게 자동으로 스케일링하는 것을 목표로 한다.</p><p>수평 스케일링은 부하 증가에 대해
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 더 배치하는 것을 뜻한다.
이는 <em>수직</em> 스케일링(쿠버네티스에서는,
해당 워크로드를 위해 이미 실행 중인 파드에
더 많은 자원(예: 메모리 또는 CPU)를 할당하는 것)과는 다르다.</p><p>부하량이 줄어들고, 파드의 수가 최소 설정값 이상인 경우,
HorizontalPodAutoscaler는 워크로드 리소스(디플로이먼트, 스테이트풀셋,
또는 다른 비슷한 리소스)에게 스케일 다운을 지시한다.</p><p>Horizontal Pod Autoscaling은 크기 조절이 불가능한 오브젝트(예:
<a class=glossary-tooltip title='파드의 복제본을 클러스터 노드 집합에서 동작하게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋>데몬셋</a>)에는 적용할 수 없다.</p><p>HorizontalPodAutoscaler는 쿠버네티스 API 자원 및
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 형태로 구현되어 있다.
HorizontalPodAutoscaler API 자원은 컨트롤러의 행동을 결정한다.
쿠버네티스 <a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>
내에서 실행되는 HPA 컨트롤러는 평균 CPU 사용률, 평균 메모리 사용률,
또는 다른 커스텀 메트릭 등의 관측된 메트릭을 목표에 맞추기 위해
목표물(예: 디플로이먼트)의 적정 크기를 주기적으로 조정한다.</p><p>Horizontal Pod Autoscaling을 활용하는
<a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>연습 예제</a>가 존재한다.</p><h2 id=horizontalpodautoscaler는-어떻게-작동하는가>HorizontalPodAutoscaler는 어떻게 작동하는가?</h2><figure class=diagram-medium><img src=/images/docs/horizontal-pod-autoscaler.svg alt="HorizontalPodAutoscaler는 디플로이먼트 및 디플로이먼트의 레플리카셋의 크기를 조정한다"><figcaption><p>HorizontalPodAutoscaler는 디플로이먼트 및 디플로이먼트의 레플리카셋의 크기를 조정한다</p></figcaption></figure><p>쿠버네티스는 Horizontal Pod Autoscaling을
간헐적으로(intermittently) 실행되는
컨트롤 루프 형태로 구현했다(지속적인 프로세스가 아니다).
실행 주기는 <a href=/docs/reference/command-line-tools-reference/kube-controller-manager/><code>kube-controller-manager</code></a>의
<code>--horizontal-pod-autoscaler-sync-period</code> 파라미터에 의해 설정된다(기본 주기는 15초이다).</p><p>각 주기마다, 컨트롤러 매니저는 각 HorizontalPodAutoscaler 정의에 지정된 메트릭에 대해 리소스 사용률을 질의한다.
컨트롤러 매니저는 <code>scaleTargetRef</code>에 의해 정의된 타겟 리소스를 찾고 나서,
타겟 리소스의 <code>.spec.selector</code> 레이블을 보고 파드를 선택하며,
리소스 메트릭 API(파드 단위 리소스 메트릭 용) 또는
커스텀 메트릭 API(그 외 모든 메트릭 용)로부터 메트릭을 수집한다.</p><ul><li><p>파드 단위 리소스 메트릭(예 : CPU)의 경우 컨트롤러는 HorizontalPodAutoscaler가
대상으로하는 각 파드에 대한 리소스 메트릭 API에서 메트릭을 가져온다.
그런 다음, 목표 사용률 값이 설정되면, 컨트롤러는 각 파드의
컨테이너에 대한 동등한 <a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EC%9A%94%EC%B2%AD-%EB%B0%8F-%EC%A0%9C%ED%95%9C>자원 요청</a>을
퍼센트 단위로 하여 사용률 값을
계산한다. 대상 원시 값이 설정된 경우 원시 메트릭 값이 직접 사용된다.
그리고, 컨트롤러는 모든 대상 파드에서 사용된 사용률의 평균 또는 원시 값(지정된
대상 유형에 따라 다름)을 가져와서 원하는 레플리카의 개수를 스케일하는데
사용되는 비율을 생성한다.</p><p>파드의 컨테이너 중 일부에 적절한 리소스 요청이 설정되지 않은 경우,
파드의 CPU 사용률은 정의되지 않으며, 따라서 오토스케일러는
해당 메트릭에 대해 아무런 조치도 취하지 않는다. 오토스케일링
알고리즘의 작동 방식에 대한 자세한 내용은 아래 <a href=#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%B8%EB%B6%80-%EC%A0%95%EB%B3%B4>알고리즘 세부 정보</a> 섹션을 참조하기 바란다.</p></li><li><p>파드 단위 사용자 정의 메트릭의 경우, 컨트롤러는 사용률 값이 아닌 원시 값을 사용한다는 점을
제외하고는 파드 단위 리소스 메트릭과 유사하게 작동한다.</p></li><li><p>오브젝트 메트릭 및 외부 메트릭의 경우, 문제의 오브젝트를 표현하는
단일 메트릭을 가져온다. 이 메트릭은 목표 값과
비교되어 위와 같은 비율을 생성한다. <code>autoscaling/v2</code> API
버전에서는, 비교가 이루어지기 전에 해당 값을 파드의 개수로
선택적으로 나눌 수 있다.</p></li></ul><p>HorizontalPodAutoscaler를 사용하는 일반적인 방법은
<a class=glossary-tooltip title='애그리게이션 레이어를 이용하면 사용자가 추가로 쿠버네티스 형식의 API를 클러스터에 설치할 수 있다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/ target=_blank aria-label='집약된 API'>집약된 API</a>(<code>metrics.k8s.io</code>,
<code>custom.metrics.k8s.io</code>, 또는 <code>external.metrics.k8s.io</code>)로부터 메트릭을 가져오도록 설정하는 것이다.
<code>metrics.k8s.io</code> API는 보통 메트릭 서버(Metrics Server)라는 애드온에 의해 제공되며,
Metrics Server는 별도로 실행해야 한다. 자원 메트릭에 대한 추가 정보는
<a href=/ko/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/#metrics-server>Metrics Server</a>를 참고한다.</p><p><a href=#%EB%A9%94%ED%8A%B8%EB%A6%AD-api%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%A7%80%EC%9B%90>메트릭 API를 위한 지원</a>에서 위의 API들에 대한 안정성 보장 및 지원 상태를
확인할 수 있다.</p><p>HorizontalPodAutoscaler 컨트롤러는 스케일링을 지원하는 상응하는
워크로드 리소스(예: 디플로이먼트 및 스테이트풀셋)에 접근한다.
이들 리소스 각각은 <code>scale</code>이라는 하위 리소스를 갖고 있으며,
이 하위 리소스는 레플리카의 수를 동적으로 설정하고 각각의 현재 상태를 확인할 수 있도록 하는 인터페이스이다.
쿠버네티스 API의 하위 리소스에 대한 일반적인 정보는 <a href=/docs/reference/using-api/api-concepts/>쿠버네티스 API 개념</a>에서 확인할 수 있다.</p><h3 id=알고리즘-세부-정보>알고리즘 세부 정보</h3><p>가장 기본적인 관점에서, HorizontalPodAutoscaler 컨트롤러는
원하는(desired) 메트릭 값과 현재(current) 메트릭 값 사이의 비율로
작동한다.</p><pre tabindex=0><code>원하는 레플리카 수 = ceil[현재 레플리카 수 * ( 현재 메트릭 값 / 원하는 메트릭 값 )]
</code></pre><p>예를 들어 현재 메트릭 값이 <code>200m</code>이고 원하는 값이
<code>100m</code>인 경우 <code>200.0 / 100.0 == 2.0</code>이므로 복제본 수가 두 배가
된다. 만약 현재 값이 <code>50m</code> 이면, <code>50.0 / 100.0 == 0.5</code> 이므로
복제본 수를 반으로 줄일 것이다. 컨트롤 플레인은 비율이 1.0(기본값이 0.1인
<code>-horizontal-pod-autoscaler-tolerance</code> 플래그를 사용하여
전역적으로 구성 가능한 허용 오차 내)에 충분히 가깝다면 스케일링을 건너 뛸 것이다.</p><p><code>targetAverageValue</code> 또는 <code>targetAverageUtilization</code>가 지정되면,
<code>currentMetricValue</code>는 HorizontalPodAutoscaler의 스케일 목표
안에 있는 모든 파드에서 주어진 메트릭의 평균을 취하여 계산된다.</p><p>허용치를 확인하고 최종 값을 결정하기 전에,
컨트롤 플레인은 누락된 메트릭이 있는지,
그리고 몇 개의 파드가 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%A1%B0%EA%B1%B4><code>Ready</code></a>인지도 고려한다.
삭제 타임스탬프가 설정된 모든 파드(파드에 삭제 타임스탬프가 있으면
셧다운/삭제 중임을 뜻한다)는 무시되며, 모든 실패한 파드는
버려진다.</p><p>특정 파드에 메트릭이 누락된 경우, 나중을 위해 처리를 미뤄두는데, 이와
같이 누락된 메트릭이 있는 모든 파드는 최종 스케일 량을 조정하는데 사용된다.</p><p>CPU를 스케일할 때, 파드가 아직 Ready되지 않았거나(여전히
초기화중이거나, unhealthy하여서) <em>또는</em> 파드의 최신 메트릭 포인트가 준비되기
전이라면, 마찬가지로 해당 파드는 나중에 처리된다.</p><p>기술적 제약으로 인해, HorizontalPodAutoscaler 컨트롤러는
특정 CPU 메트릭을 나중에 사용할지 말지 결정할 때, 파드가 준비되는
시작 시간을 정확하게 알 수 없다. 대신, 파드가 아직 준비되지
않았고 시작 이후 짧은 시간 내에 파드가 준비되지 않은 상태로
전환된다면, 해당 파드를 "아직 준비되지 않음(not yet ready)"으로 간주한다.
이 값은 <code>--horizontal-pod-autoscaler-initial-readiness-delay</code> 플래그로 설정되며, 기본값은 30초
이다. 일단 파드가 준비되고 시작된 후 구성 가능한 시간 이내이면,
준비를 위한 어떠한 전환이라도 이를 시작 시간으로 간주한다. 이
값은 <code>--horizontal-pod-autoscaler-cpu-initialization-period</code> 플래그로 설정되며
기본값은 5분이다.</p><p><code>현재 메트릭 값 / 원하는 메트릭 값</code> 기본 스케일 비율은 나중에
사용하기로 되어 있거나 위에서 폐기되지 않은 남아있는 파드를 사용하여 계산된다.</p><p>누락된 메트릭이 있는 경우, 컨트롤 플레인은 파드가 스케일 다운의 경우
원하는 값의 100%를 소비하고 스케일 업의 경우 0%를 소비한다고
가정하여 평균을 보다 보수적으로 재계산한다. 이것은 잠재적인
스케일의 크기를 약화시킨다.</p><p>또한, 아직-준비되지-않은 파드가 있고, 누락된 메트릭이나
아직-준비되지-않은 파드가 고려되지 않고 워크로드가 스케일업 된 경우,
컨트롤러는 아직-준비되지-않은 파드가 원하는 메트릭의 0%를 소비한다고
보수적으로 가정하고 스케일 확장의 크기를 약화시킨다.</p><p>아직-준비되지-않은 파드나 누락된 메트릭을 고려한 후에,
컨트롤러가 사용률을 다시 계산한다.
새로 계산한 사용률이 스케일 방향을 바꾸거나, 허용 오차 내에 있으면,
컨트롤러가 스케일링을 건너뛴다.
그렇지 않으면, 새로 계산한 사용률를 이용하여 파드 수 변경 결정을 내린다.</p><p>평균 사용량에 대한 <em>원래</em> 값은 새로운 사용 비율이 사용되는
경우에도 아직-준비되지-않은 파드 또는 누락된 메트릭에 대한
고려없이 HorizontalPodAutoscaler 상태를 통해 다시
보고된다.</p><p>HorizontalPodAutoscaler에 여러 메트릭이 지정된 경우, 이 계산은
각 메트릭에 대해 수행된 다음 원하는 레플리카 수 중 가장
큰 값이 선택된다. 이러한 메트릭 중 어떠한 것도 원하는
레플리카 수로 변환할 수 없는 경우(예 : 메트릭 API에서 메트릭을
가져오는 중 오류 발생) 스케일을 건너뛴다.
이는 하나 이상의 메트릭이
현재 값보다 높은 <code>desiredReplicas</code> 을 제공하는 경우
HPA가 여전히 확장할 수 있음을 의미한다.</p><p>마지막으로, HPA가 목표를 스케일하기 직전에 스케일 권장 사항이
기록된다. 컨트롤러는 구성 가능한 창(window) 내에서 가장 높은 권장
사항을 선택하도록 해당 창 내의 모든 권장 사항을 고려한다. 이 값은 <code>--horizontal-pod-autoscaler-downscale-stabilization</code> 플래그를 사용하여 설정할 수 있고, 기본값은 5분이다.
즉, 스케일 다운이 점진적으로 발생하여 급격히 변동하는 메트릭 값의
영향을 완만하게 한다.</p><h2 id=api-오브젝트>API 오브젝트</h2><p>Horizontal Pod Autoscaler는
쿠버네티스 <code>autoscaling</code> API 그룹의 API 리소스이다.
현재의 안정 버전은 <code>autoscaling/v2</code> API 버전이며,
메모리와 커스텀 메트릭에 대한 스케일링을 지원한다.
<code>autoscaling/v2</code>에서 추가된 새로운 필드는 <code>autoscaling/v1</code>를 이용할 때에는
어노테이션으로 보존된다.</p><p>HorizontalPodAutoscaler API 오브젝트 생성시 지정된 이름이 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>인지 확인해야 한다.
API 오브젝트에 대한 자세한 내용은
<a href=/docs/reference/generated/kubernetes-api/v1.25/#horizontalpodautoscaler-v2-autoscaling>HorizontalPodAutoscaler 오브젝트</a>에서 찾을 수 있다.</p><h2 id=flapping>워크로드 스케일링의 안정성</h2><p>HorizontalPodAutoscaler를 사용하여 레플리카 그룹의 크기를 관리할 때,
측정하는 메트릭의 동적 특성 때문에 레플리카 수가 계속 자주 요동칠 수 있다.
이는 종종 <em>thrashing</em> 또는 <em>flapping</em>이라고 불린다.
이는 사이버네틱스 분야의 <em>이력 현상(hysteresis)</em> 개념과 비슷하다.</p><h2 id=롤링-업데이트-중-오토스케일링>롤링 업데이트 중 오토스케일링</h2><p>쿠버네티스는 디플로이먼트에 대한 롤링 업데이트를 지원한다.
이 경우, 디플로이먼트가 기저 레플리카셋을 알아서 관리한다.
디플로이먼트에 오토스케일링을 설정하려면,
각 디플로이먼트에 대한 HorizontalPodAutoscaler를 생성한다.
HorizontalPodAutoscaler는 디플로이먼트의 <code>replicas</code> 필드를 관리한다.
디플로이먼트 컨트롤러는 기저 레플리카셋에 <code>replicas</code> 값을 적용하여
롤아웃 과정 중/이후에 적절한 숫자까지 늘어나도록 한다.</p><p>오토스케일된 레플리카가 있는 스테이트풀셋의 롤링 업데이트를 수행하면,
스테이트풀셋이 직접 파드의 숫자를 관리한다(즉,
레플리카셋과 같은 중간 리소스가 없다).</p><h2 id=리소스-메트릭-지원>리소스 메트릭 지원</h2><p>모든 HPA 대상은 스케일링 대상에서 파드의 리소스 사용량을 기준으로 스케일링할 수 있다.
파드의 명세를 정의할 때는 <code>cpu</code> 및 <code>memory</code> 와 같은 리소스 요청을
지정해야 한다. 이것은 리소스 사용률을 결정하는 데 사용되며 HPA 컨트롤러에서 대상을
스케일링하거나 축소하는 데 사용한다. 리소스 사용률 기반 스케일링을 사용하려면 다음과 같은 메트릭 소스를
지정해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이 메트릭을 사용하면 HPA 컨트롤러는 스케일링 대상에서 파드의 평균 사용률을
60%로 유지한다. 사용률은 파드의 요청된 리소스에 대한 현재 리소스 사용량 간의
비율이다. 사용률 계산 및 평균 산출 방법에 대한 자세한 내용은 <a href=#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%B8%EB%B6%80-%EC%A0%95%EB%B3%B4>알고리즘</a>을
참조한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 모든 컨테이너의 리소스 사용량이 합산되므로 총 파드 사용량이 개별 컨테이너 리소스 사용량을
정확하게 나타내지 못할 수 있다. 이로 인해 단일 컨테이너가
높은 사용량으로 실행될 수 있고 전체 파드 사용량이 여전히 허용 가능한 한도 내에 있기 때문에 HPA가 스케일링되지 않는
상황이 발생할 수 있다.</div><h3 id=컨테이너-리소스-메트릭>컨테이너 리소스 메트릭</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.20 [alpha]</code></div><p>HorizontalPodAutoscaler API는 대상 리소스를 스케일링하기 위해 HPA가 파드 집합에서 개별 컨테이너의
리소스 사용량을 추적할 수 있는 컨테이너 메트릭 소스도 지원한다.
이를 통해 특정 파드에서 가장 중요한 컨테이너의 스케일링 임계값을 구성할 수 있다.
예를 들어 웹 애플리케이션 프로그램과 로깅 사이드카가 있는 경우 사이드카 컨테이너와 해당 리소스 사용을 무시하고
웹 애플리케이션의 리소스 사용을 기준으로 스케일링할 수 있다.</p><p>대상 리소스를 다른 컨테이너 세트를 사용하여 새 파드 명세를 갖도록 수정하는 경우
새로 추가된 컨테이너도 스케일링에 사용해야 한다면 HPA 사양을 수정해야 한다.
메트릭 소스에 지정된 컨테이너가 없거나 파드의 하위 집합에만 있는 경우
해당 파드는 무시되고 권장 사항이 다시 계산된다. 계산에 대한 자세한 내용은 <a href=#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%B8%EB%B6%80-%EC%A0%95%EB%B3%B4>알고리즘</a>을
을 참조한다. 컨테이너 리소스를 오토스케일링에 사용하려면 다음과 같이
메트릭 소스를 정의한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ContainerResource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>containerResource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>container</span>:<span style=color:#bbb> </span>application<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>위의 예에서 HPA 컨트롤러는 모든 파드의 <code>application</code> 컨테이너에 있는 CPU의 평균 사용률이
60%가 되도록 대상을 조정한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>HorizontalPodAutoscaler가 추적하는 컨테이너의 이름을 변경하는 경우
특정 순서로 변경을 수행하여 변경 사항이 적용되는 동안 스케일링을 계속 사용할 수 있고
효율적으로 유지할 수 있다. 컨테이너를 정의하는 리소스(예: 배포)를
업데이트하기 전에 연결된 HPA를 업데이트하여 새 컨테이너 이름과 이전 컨테이너 이름을
모두 추적해야 한다. 이러한 방식으로 HPA는 업데이트 프로세스 전반에 걸쳐 스케일링 권장 사항을
계산할 수 있다.</p><p>컨테이너 이름 변경을 워크로드 리소스로 롤아웃한 후에는 HPA 사양에서
이전 컨테이너 이름을 제거하여 정리한다.</p></div><h2 id=사용자-정의-메트릭을-이용하는-스케일링>사용자 정의 메트릭을 이용하는 스케일링</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [stable]</code></div><p>(이전에는 <code>autoscaling/v2beta2</code> API 버전이 이 기능을 베타 기능으로 제공했었다.)</p><p><code>autoscaling/v2beta2</code> API 버전을 사용하는 경우,
(쿠버네티스 또는 어느 쿠버네티스 구성 요소에도 포함되어 있지 않은)
커스텀 메트릭을 기반으로 스케일링을 수행하도록 HorizontalPodAutoscaler를 구성할 수 있다.
이 경우 HorizontalPodAutoscaler 컨트롤러가 이러한 커스텀 메트릭을 쿠버네티스 API로부터 조회한다.</p><p>요구 사항에 대한 정보는 <a href=#%EB%A9%94%ED%8A%B8%EB%A6%AD-api%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%A7%80%EC%9B%90>메트릭 API를 위한 지원</a>을 참조한다.</p><h2 id=복수의-메트릭을-이용하는-스케일링>복수의 메트릭을 이용하는 스케일링</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [stable]</code></div><p>(이전에는 <code>autoscaling/v2beta2</code> API 버전이 이 기능을 베타 기능으로 제공했었다.)</p><p><code>autoscaling/v2</code> API 버전을 사용하는 경우,
HorizontalPodAutoscaler는 스케일링에 사용할 복수의 메트릭을 설정할 수 있다.
이 경우 HorizontalPodAutoscaler 컨트롤러가 각 메트릭을 확인하고 해당 단일 메트릭에 대한 새로운 스케일링 크기를 제안한다.
HorizontalPodAutoscaler는 새롭게 제안된 스케일링 크기 중 가장 큰 값을 선택하여 워크로드 사이즈를
조정한다(이 값이 이전에 설정한 '총 최대값(overall maximum)'보다는 크지 않을 때에만).</p><h2 id=메트릭-api를-위한-지원>메트릭 API를 위한 지원</h2><p>기본적으로 HorizontalPodAutoscaler 컨트롤러는 일련의 API에서 메트릭을 검색한다. 이러한
API에 접속하려면 클러스터 관리자는 다음을 확인해야 한다.</p><ul><li><p><a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>API 애그리게이션 레이어</a> 활성화</p></li><li><p>해당 API 등록:</p><ul><li><p>리소스 메트릭의 경우, 일반적으로 이것은 <a href=https://github.com/kubernetes-sigs/metrics-server>메트릭-서버</a>가 제공하는 <code>metrics.k8s.io</code> API이다.
클러스터 애드온으로 실행할 수 있다.</p></li><li><p>사용자 정의 메트릭의 경우, 이것은 <code>custom.metrics.k8s.io</code> API이다. 메트릭 솔루션 공급 업체에서 제공하는 "어댑터" API 서버에서 제공한다.
사용 가능한 쿠버네티스 메트릭 어댑터가 있는지 확인하려면 사용하고자 하는 메트릭 파이프라인을 확인한다.</p></li><li><p>외부 메트릭의 경우, 이것은 <code>external.metrics.k8s.io</code> API이다. 위에 제공된 사용자 정의 메트릭 어댑터에서 제공될 수 있다.</p></li></ul></li></ul><p>이런 다양한 메트릭 경로와 각각의 다른 점에 대한 상세 내용은 관련 디자인 제안서인
<a href=https://git.k8s.io/design-proposals-archive/autoscaling/hpa-v2.md>HPA V2</a>,
<a href=https://git.k8s.io/design-proposals-archive/instrumentation/custom-metrics-api.md>custom.metrics.k8s.io</a>,
<a href=https://git.k8s.io/design-proposals-archive/instrumentation/external-metrics-api.md>external.metrics.k8s.io</a>를 참조한다.</p><p>어떻게 사용하는지에 대한 예시는 <a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%A9%94%ED%8A%B8%EB%A6%AD-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EB%A9%94%ED%8A%B8%EB%A6%AD%EC%9D%84-%EA%B8%B0%EC%B4%88%EB%A1%9C%ED%95%9C-%EC%98%A4%ED%86%A0%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81>커스텀 메트릭 사용하는 작업 과정</a>과
<a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%EC%99%80-%EA%B4%80%EB%A0%A8%EC%9D%B4-%EC%97%86%EB%8A%94-%EB%A9%94%ED%8A%B8%EB%A6%AD%EC%9D%84-%EA%B8%B0%EC%B4%88%EB%A1%9C%ED%95%9C-%EC%98%A4%ED%86%A0%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81>외부 메트릭스 사용하는 작업 과정</a>을 참조한다.</p><h2 id=구성가능한-스케일링-동작>구성가능한 스케일링 동작</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [stable]</code></div><p>(이전에는 <code>autoscaling/v2beta2</code> API 버전이 이 기능을 베타 기능으로 제공했었다.)</p><p><code>v2</code> 버전의 HorizontalPodAutoscaler API를 사용한다면,
<code>behavior</code> 필드(<a href=/docs/reference/kubernetes-api/workload-resources/horizontal-pod-autoscaler-v2/#HorizontalPodAutoscalerSpec>API 레퍼런스</a> 참고)를
사용하여 스케일업 동작과 스케일다운 동작을 별도로 구성할 수 있다.
각 방향에 대한 동작은 <code>behavior</code> 필드 아래의
<code>scaleUp</code> / <code>scaleDown</code>를 설정하여 지정할 수 있다.</p><p><em>안정화 윈도우</em> 를 명시하여 스케일링 목적물의
레플리카 수 <a href=#flapping>흔들림</a>을 방지할 수 있다. 스케일링 정책을 이용하여 스케일링 시
레플리카 수 변화 속도를 조절할 수도 있다.</p><h3 id=스케일링-정책>스케일링 정책</h3><p>스펙의 <code>behavior</code> 섹션에 하나 이상의 스케일링 폴리시를 지정할 수 있다.
폴리시가 여러 개 지정된 경우 가장 많은 양의 변경을
허용하는 정책이 기본적으로 선택된 폴리시이다. 다음 예시는 스케일 다운 중 이
동작을 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>periodSeconds</code> 는 폴리시가 참(true)으로 유지되어야 하는 기간을 나타낸다.
첫 번째 정책은 <em>(파드들)</em> 이 1분 내에 최대 4개의 레플리카를 스케일 다운할 수 있도록 허용한다.
두 번째 정책은 <em>비율</em> 로 현재 레플리카의 최대 10%를 1분 내에 스케일 다운할 수 있도록 허용한다.</p><p>기본적으로 가장 많은 변경을 허용하는 정책이 선택되기에 두 번째 정책은
파드의 레플리카 수가 40개를 초과하는 경우에만 사용된다. 레플리카가 40개 이하인 경우 첫 번째 정책이 적용된다.
예를 들어 80개의 레플리카가 있고 대상을 10개의 레플리카로 축소해야 하는
경우 첫 번째 단계에서 8개의 레플리카가 스케일 다운 된다. 레플리카의 수가 72개일 때
다음 반복에서 파드의 10%는 7.2 이지만, 숫자는 8로 올림된다. 오토스케일러 컨트롤러의
각 루프에서 변경될 파드의 수는 현재 레플리카의 수에 따라 재계산된다. 레플리카의 수가 40
미만으로 떨어지면 첫 번째 폴리시 <em>(파드들)</em> 가 적용되고 한번에
4개의 레플리카가 줄어든다.</p><p>확장 방향에 대해 <code>selectPolicy</code> 필드를 확인하여 폴리시 선택을 변경할 수 있다.
레플리카의 수를 최소로 변경할 수 있는 폴리시를 선택하는 <code>최소(Min)</code>로 값을 설정한다.
값을 <code>Disabled</code> 로 설정하면 해당 방향으로 스케일링이 완전히
비활성화된다.</p><h3 id=안정화-윈도우>안정화 윈도우</h3><p>안정화 윈도우는 스케일링에 사용되는 메트릭이 계속 변동할 때
레플리카 수의 <a href=#flapping>흔들림</a>을 제한하기 위해 사용된다.
오토스케일링 알고리즘은 이전의 목표 상태를 추론하고
워크로드 수의 원치 않는 변화를 방지하기 위해 이 안정화 윈도우를 활용한다.</p><p>예를 들어, 다음 예제 스니펫에서, <code>scaleDown</code>에 대해 안정화 윈도우가 설정되었다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>300</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>메트릭 관측 결과 스케일링 목적물이 스케일 다운 되어야 하는 경우,
알고리즘은 이전에 계산된 목표 상태를 확인하고, 해당 구간에서 계산된 값 중 가장 높은 값을 사용한다.
위의 예시에서, 이전 5분 동안의 모든 목표 상태가 고려 대상이 된다.</p><p>이를 통해 동적 최대값(rolling maximum)을 근사화하여,
스케일링 알고리즘이 빠른 시간 간격으로 파드를 제거하고 바로 다시 동일한 파드를 재생성하는 현상을 방지할 수 있다.</p><h3 id=기본-동작>기본 동작</h3><p>사용자 지정 스케일링을 사용하기 위해서 모든 필드를 지정하지 않아도 된다. 사용자 정의가 필요한 값만
지정할 수 있다. 이러한 사용자 지정 값은 기본값과 병합된다. 기본값은 HPA
알고리즘의 기존 동작과 동일하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>300</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleUp</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Max<span style=color:#bbb>
</span></span></span></code></pre></div><p>안정화 윈도우의 스케일링 다운의 경우 <em>300</em> 초 (또는 제공된
경우<code>--horizontal-pod-autoscaler-downscale-stabilization</code> 플래그의 값)이다. 스케일링 다운에서는 현재
실행 중인 레플리카의 100%를 제거할 수 있는 단일 정책만 있으며, 이는 스케일링
대상을 최소 허용 레플리카로 축소할 수 있음을 의미한다.
스케일링 업에는 안정화 윈도우가 없다. 메트릭이 대상을 스케일 업해야 한다고 표시된다면 대상이 즉시 스케일 업된다.
두 가지 폴리시가 있다. HPA가 정상 상태에 도달 할 때까지 15초 마다
4개의 파드 또는 현재 실행 중인 레플리카의 100% 가 추가된다.</p><h3 id=예시-다운스케일-안정화-윈도우-변경>예시: 다운스케일 안정화 윈도우 변경</h3><p>사용자 지정 다운스케일 안정화 윈도우를 1분 동안 제공하기 위해
다음 동작이 HPA에 추가된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=예시-스케일-다운-속도-제한>예시: 스케일 다운 속도 제한</h3><p>HPA에 의해 파드가 제거되는 속도를 분당 10%로 제한하기 위해
다음 동작이 HPA에 추가된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>분당 제거되는 파드 수가 5를 넘지 않도록 하기 위해, 크기가 5로 고정된 두 번째 축소
정책을 추가하고, <code>selectPolicy</code> 를 최소로 설정하면 된다. <code>selectPolicy</code> 를 <code>Min</code> 으로 설정하면
자동 스케일러가 가장 적은 수의 파드에 영향을 주는 정책을 선택함을 의미한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Min<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=예시-스케일-다운-비활성화>예시: 스케일 다운 비활성화</h3><p><code>selectPolicy</code> 의 <code>Disabled</code> 값은 주어진 방향으로의 스케일링을 끈다.
따라서 다운 스케일링을 방지하기 위해 다음 폴리시가 사용된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Disabled<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=kubectl의-horizontalpodautoscaler-지원>kubectl의 HorizontalPodAutoscaler 지원</h2><p>Horizontal Pod Autoscaler는 모든 API 리소스와 마찬가지로 <code>kubectl</code>에 의해 표준 방식으로 지원된다.
<code>kubectl create</code> 커맨드를 사용하여 새로운 오토스케일러를 만들 수 있다.
<code>kubectl get hpa</code>로 오토스케일러 목록을 조회할 수 있고, <code>kubectl describe hpa</code>로 세부 사항을 확인할 수 있다.
마지막으로 <code>kubectl delete hpa</code>를 사용하여 오토스케일러를 삭제할 수 있다.</p><p>또한 Horizontal Pod Autoscaler를 생성할 수 있는 <code>kubectl autoscale</code>이라는 특별한 명령이 있다.
예를 들어 <code>kubectl autoscale rs foo --min=2 --max=5 --cpu-percent=80</code>을
실행하면 레플리카셋 <em>foo</em> 에 대한 오토스케일러가 생성되고, 목표 CPU 사용률은 <code>80 %</code>,
그리고 2와 5 사이의 레플리카 개수로 설정된다.</p><h2 id=암시적-점검-모드-maintenance-mode-비활성화>암시적 점검 모드(maintenance-mode) 비활성화</h2><p>HPA 구성 자체를 변경할 필요없이 대상에 대한
HPA를 암시적으로 비활성화할 수 있다. 대상의 의도한
레플리카 수가 0으로 설정되고, HPA의 최소 레플리카 수가 0 보다 크면, 대상의
의도한 레플리카 수 또는 HPA의 최소 레플리카 수를 수동으로 조정하여
다시 활성화할 때까지 HPA는 대상 조정을
중지한다(그리고 <code>ScalingActive</code> 조건 자체를 <code>false</code>로 설정).</p><h3 id=디플로이먼트와-스테이트풀셋을-horizontal-autoscaling으로-전환하기>디플로이먼트와 스테이트풀셋을 horizontal autoscaling으로 전환하기</h3><p>HPA가 활성화되어 있으면, 디플로이먼트, 스테이트풀셋 모두 또는 둘 중 하나의
<a class=glossary-tooltip title='하나 이상의 쿠버네티스 API 오브젝트를 직렬화한 명세(specification).' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-manifest' target=_blank aria-label=매니페스트>매니페스트</a>에서
<code>spec.replicas</code>의 값을 삭제하는 것이 바람직하다.
이렇게 적용하지 않으면, (예를 들어 <code>kubectl apply -f deployment.yaml</code> 명령으로)
오브젝트에 변경이 생길 때마다 쿠버네티스가 파드의 수를
<code>spec.replicas</code>에 기재된 값으로 조정할 것이다.
이는 바람직하지 않으며 HPA가 활성화된 경우에 문제가 될 수 있다.</p><p><code>spec.replicas</code> 값을 제거하면 1회성으로 파드 숫자가 줄어들 수 있는데,
이는 이 키의 기본값이 1이기 때문이다(레퍼런스:
<a href=/ko/docs/concepts/workloads/controllers/deployment#%EB%A0%88%ED%94%8C%EB%A6%AC%EC%B9%B4>디플로이먼트 레플리카</a>).
값을 업데이트하면, 파드 1개를 제외하고 나머지 파드가 종료 절차에 들어간다.
이후의 디플로이먼트 애플리케이션은 정상적으로 작동하며 롤링 업데이트 구성도 의도한 대로 동작한다.
이러한 1회성 저하를 방지하는 방법이 존재하며,
디플로이먼트 수정 방법에 따라 다음 중 한 가지 방법을 선택한다.</p><ul class="nav nav-tabs" id=fix-replicas-instructions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#fix-replicas-instructions-0 role=tab aria-controls=fix-replicas-instructions-0 aria-selected=true>클라이언트 쪽에 적용하기 (기본값))</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#fix-replicas-instructions-1 role=tab aria-controls=fix-replicas-instructions-1>서버 쪽에 적용하기</a></li></ul><div class=tab-content id=fix-replicas-instructions><div id=fix-replicas-instructions-0 class="tab-pane show active" role=tabpanel aria-labelledby=fix-replicas-instructions-0><p><ol><li><code>kubectl apply edit-last-applied deployment/&lt;디플로이먼트_이름></code></li><li>에디터에서 <code>spec.replicas</code>를 삭제한다. 저장하고 에디터를 종료하면, <code>kubectl</code>이
업데이트 사항을 적용한다. 이 단계에서 파드 숫자가 변경되지는 않는다.</li><li>이제 매니페스트에서 <code>spec.replicas</code>를 삭제할 수 있다.
소스 코드 관리 도구를 사용하고 있다면, 변경 사항을 추적할 수 있도록
변경 사항을 커밋하고 추가 필요 단계를 수행한다.</li><li>이제 <code>kubectl apply -f deployment.yaml</code>를 실행할 수 있다.</li></ol></div><div id=fix-replicas-instructions-1 class=tab-pane role=tabpanel aria-labelledby=fix-replicas-instructions-1><p><p><a href=/docs/reference/using-api/server-side-apply/>서버 쪽에 적용하기</a>를 수행하려면,
정확히 이러한 사용 사례를 다루고 있는 <a href=/docs/reference/using-api/server-side-apply/#transferring-ownership>소유권 이전하기</a>
가이드라인을 참조한다.</p></div></div><h2 id=다음-내용>다음 내용</h2><p>클러스터에 오토스케일링을 구성한다면, <a href=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler>Cluster Autoscaler</a>와 같은
클러스터 수준의 오토스케일러 사용을 고려해 볼 수 있다.</p><p>HorizontalPodAutoscaler에 대한 더 많은 정보는 아래를 참고한다.</p><ul><li>horizontal pod autoscaling에 대한 <a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>연습 예제</a>를 확인한다.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/#autoscale><code>kubectl autoscale</code></a> 문서를 확인한다.</li><li>커스텀 메트릭 어댑터를 직접 작성하고 싶다면,
<a href=https://github.com/kubernetes-sigs/custom-metrics-apiserver>샘플</a>을 확인한다.</li><li>HorizontalPodAutoscaler <a href=/docs/reference/kubernetes-api/workload-resources/horizontal-pod-autoscaler-v2/>API 레퍼런스</a>를 확인한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8138226ce9660ac8e3e82ff86fff8ad2>8.7 - HorizontalPodAutoscaler 연습</h1><p><a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/>HorizontalPodAutoscaler</a>(약어: HPA)는
워크로드 리소스(예: <a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a> 또는
<a class=glossary-tooltip title='내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a>)를
자동으로 업데이트하며,
워크로드의 크기를 수요에 맞게
자동으로 스케일링하는 것을 목표로 한다.</p><p>수평 스케일링은 부하 증가에 대해
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 더 배치하는 것을 뜻한다.
이는 <em>수직</em> 스케일링(쿠버네티스에서는,
해당 워크로드를 위해 이미 실행 중인 파드에
더 많은 자원(예: 메모리 또는 CPU)를 할당하는 것)과는 다르다.</p><p>부하량이 줄어들고, 파드의 수가 최소 설정값 이상인 경우,
HorizontalPodAutoscaler는 워크로드 리소스(디플로이먼트, 스테이트풀셋,
또는 다른 비슷한 리소스)에게 스케일 다운을 지시한다.</p><p>이 문서는 예제 웹 앱의 크기를 자동으로 조절하도록
HorizontalPodAutoscaler를 설정하는 예시를 다룬다.
이 예시 워크로드는 PHP 코드를 실행하는 아파치 httpd이다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: 1.23.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.
이전 버전의
쿠버네티스를 사용하고 있다면, 해당 버전의 문서를
참고한다(<a href=/ko/docs/home/supported-doc-versions/>사용 가능한 문서의 버전</a> 참고).</p><p>이 예제를 실행하기 위해, 클러스터에 <a href=https://github.com/kubernetes-sigs/metrics-server#readme>Metrics Server</a>가
배포 및 구성되어 있어야 한다. 쿠버네티스 Metrics Server는 클러스터의
<a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>으로부터
리소스 메트릭을 수집하고, 수집한 메트릭을
<a href=/ko/docs/concepts/overview/kubernetes-api/>쿠버네티스 API</a>를 통해 노출시키며,
메트릭 수치를 나타내는 새로운 종류의 리소스를 추가하기 위해
<a href=/ko/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIService</a>를 사용할 수 있다.</p><p>Metrics Server를 실행하는 방법을 보려면
<a href=https://github.com/kubernetes-sigs/metrics-server#deployment>metrics-server 문서</a>를 참고한다.</p><h2 id=php-apache-서버-구동-및-노출>php-apache 서버 구동 및 노출</h2><p>HorizontalPodAutoscaler 시연을 위해, <code>hpa-example</code> 이미지를 사용하여 컨테이너를 실행하는 디플로이먼트를 시작하고,
다음의 매니페스트를 사용하여 디플로이먼트를
<a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>로 노출한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/php-apache.yaml download=application/php-apache.yaml><code>application/php-apache.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-php-apache-yaml")' title="Copy application/php-apache.yaml to clipboard"></img></div><div class=includecode id=application-php-apache-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/hpa-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>200m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이를 위해, 다음의 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/php-apache.yaml
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/php-apache created
service/php-apache created
</code></pre><h2 id=create-horizontal-pod-autoscaler>HorizontalPodAutoscaler 생성</h2><p>이제 서비스가 동작중이므로,
<code>kubectl</code>을 사용하여 오토스케일러를 생성한다. 이를 위해
<a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a> 서브커맨드를 사용할 수 있다.</p><p>아래에서는 첫 번째 단계에서 만든 php-apache
디플로이먼트 파드의 개수를 1부터 10 사이로 유지하는
Horizontal Pod Autoscaler를 생성하는 명령어를 실행할 것이다.</p><p>간단히 이야기하면, HPA <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는
평균 CPU 사용량을 50%로 유지하기 위해 (디플로이먼트를 업데이트하여) 레플리카의 개수를 늘리고 줄인다.
그러면 디플로이먼트는 레플리카셋을 업데이트하며(이는 모든 쿠버네티스 디플로이먼트의 동작 방식 중 일부이다),
레플리카셋은 자신의 <code>.spec</code> 필드의 변경 사항에 따라 파드를 추가하거나 제거한다.</p><p><code>kubectl run</code>으로 각 파드는 200 밀리코어를 요청하므로, 평균 CPU 사용은 100 밀리코어이다.
알고리즘에 대한 세부 사항은
<a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%B8%EB%B6%80-%EC%A0%95%EB%B3%B4>알고리즘 세부 정보</a>를 참고한다.</p><p>HorizontalPodAutoscaler를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment php-apache --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span> --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><pre tabindex=0><code>horizontalpodautoscaler.autoscaling/php-apache autoscaled
</code></pre><p>다음을 실행하여, 새로 만들어진 HorizontalPodAutoscaler의 현재 상태를 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;hpa&#34; 또는 &#34;horizontalpodautoscaler&#34; 둘 다 사용 가능하다.</span>
</span></span><span style=display:flex><span>kubectl get hpa
</span></span></code></pre></div><p>출력은 다음과 같다.</p><pre tabindex=0><code>NAME         REFERENCE                     TARGET    MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%  1         10        1          18s
</code></pre><p>(HorizontalPodAutoscalers 이름이 다르다면, 이미 기존에 존재하고 있었다는 뜻이며,
보통은 문제가 되지 않는다.)</p><p>아직 서버로 요청을 보내는 클라이언트가 없기 때문에, 현재 CPU 사용량이 0%임을 확인할 수 있다.
(<code>TARGET</code> 열은 디플로이먼트에 의해 제어되는 파드들의 평균을 나타낸다)</p><h2 id=increase-load>부하 증가시키기</h2><p>다음으로, 부하가 증가함에 따라 오토스케일러가 어떻게 반응하는지를 살펴볼 것이다.
이를 위해, 클라이언트 역할을 하는 다른 파드를 실행할 것이다.
클라이언트 파드 안의 컨테이너가 php-apache 서비스에 쿼리를 보내는 무한 루프를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 부하 생성을 유지하면서 나머지 스텝을 수행할 수 있도록,</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 다음의 명령을 별도의 터미널에서 실행한다.</span>
</span></span><span style=display:flex><span>kubectl run -i --tty load-generator --rm --image<span style=color:#666>=</span>busybox:1.28 --restart<span style=color:#666>=</span>Never -- /bin/sh -c <span style=color:#b44>&#34;while sleep 0.01; do wget -q -O- http://php-apache; done&#34;</span>
</span></span></code></pre></div><p>이제 아래 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 준비가 되면, 관찰을 마치기 위해 Ctrl+C를 누른다.</span>
</span></span><span style=display:flex><span>kubectl get hpa
</span></span></code></pre></div><p>1분 쯤 지나면, 다음과 같이 CPU 부하가 올라간 것을 볼 수 있다.</p><pre tabindex=0><code>NAME         REFERENCE                     TARGET      MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   305% / 50%  1         10        1          3m
</code></pre><p>그리고 다음과 같이 레플리카의 수가 증가한 것도 볼 수 있다.</p><pre tabindex=0><code>NAME         REFERENCE                     TARGET      MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   305% / 50%  1         10        7          3m
</code></pre><p>CPU 사용률이 305%까지 증가하였다.
결과적으로, 디플로이먼트의 레플리카 개수가 7개까지 증가하였다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment php-apache
</span></span></code></pre></div><p>HorizontalPodAutoscaler를 조회했을 때와 동일한 레플리카 수를 확인할 수 있다.</p><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   7/7      7           7           19m
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 레플리카의 개수를 안정화시키는데 몇 분이 걸릴 수 있다.
부하의 양은 환경에 따라 다르기 때문에,
최종 레플리카의 개수는 본 예제와 다를 수 있다.</div><h2 id=stop-load>부하 발생 중지하기</h2><p>본 예제를 마무리하기 위해 부하를 중단시킨다.</p><p><code>busybox</code> 파드를 띄운 터미널에서,
<code>&lt;Ctrl> + C</code>로 부하 발생을 중단시킨다.</p><p>그런 다음 (몇 분 후에) 결과를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 준비가 되면, 관찰을 마치기 위해 Ctrl+C를 누른다.</span>
</span></span><span style=display:flex><span>kubectl get hpa php-apache --watch
</span></span></code></pre></div><p>출력은 다음과 같다.</p><pre tabindex=0><code>NAME         REFERENCE                     TARGET       MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%     1         10        1          11m
</code></pre><p>디플로이먼트도 스케일 다운 했음을 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment php-apache
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   1/1     1            1           27m
</code></pre><p>CPU 사용량이 0으로 떨어져서, HPA가 자동으로 레플리카의 개수를 1로 줄였다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 레플리카 오토스케일링은 몇 분 정도 소요된다.</div><h2 id=다양한-메트릭-및-사용자-정의-메트릭을-기초로한-오토스케일링>다양한 메트릭 및 사용자 정의 메트릭을 기초로한 오토스케일링</h2><p><code>php-apache</code> 디플로이먼트를 오토스케일링할 때,
<code>autoscaling/v2</code> API 버전을 사용하여 추가적인 메트릭을 제공할 수 있다.</p><p>첫 번째로, <code>autoscaling/v2</code> 형식으로 HorizontalPodAutoscaler YAML 파일을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get hpa php-apache -o yaml &gt; /tmp/hpa-v2.yaml
</span></span></code></pre></div><p>에디터로 <code>/tmp/hpa-v2.yaml</code> 파일을 열면, 다음과 같은 YAML을 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>targetCPUUtilizationPercentage</code> 필드가 <code>metrics</code> 배열로 대체되었다.
CPU 사용량 메트릭은 <em>resource metric</em> 으로 파드 컨테이너 자원의 백분율로 표현된다.
CPU 외에 다른 메트릭을 지정할 수 있는데, 기본적으로 지원되는 다른 메트릭은 메모리뿐이다.
이 자원들은 한 클러스터에서 다른 클러스터로 이름을 변경할 수 없으며,
<code>metrics.k8s.io</code> API가 가용한 경우 언제든지 사용할 수 있어야 한다.</p><p>또한, <code>Utilization</code> 대신 <code>AverageValue</code>의 <code>target</code> 타입을,
그리고 <code>target.averageUtilization</code> 대신 <code>target.averageValue</code>로 설정하여
자원 메트릭을 퍼센트 대신 값으로 명시할 수 있다.</p><p>파드 메트릭과 오브젝트 메트릭 두 가지의 <em>사용자 정의 메트릭</em> 이 있다.
파드 메트릭과 오브젝트 메트릭. 이 메트릭은 클러스터에 특화된 이름을 가지고 있으며,
더 고급화된 클러스터 모니터링 설정이 필요하다.</p><p>이러한 대체 메트릭 타입중 첫 번째는 <em>파드 메트릭</em> 이다.
이 메트릭은 파드들을 설명하고, 파드들 간의 평균을 내며, 대상 값과 비교하여 레플리카 개수를 결정한다.
이것들은 <code>AverageValue</code>의 <code>target</code>만을 지원한다는 것을 제외하면, 자원 메트릭과 매우 유사하게 동작한다.</p><p>파드 메트릭은 이처럼 메트릭 블록을 사용하여 정의된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span></span></span></code></pre></div><p>두 번째 대체 메트릭 타입은 <em>오브젝트 메트릭</em> 이다.
이 메트릭은 파드를 기술하는 대신에 동일한 네임스페이스 내에 다른 오브젝트를 표현한다.
이 메트릭은 반드시 오브젝트로부터 가져올 필요는 없다. 단지 오브젝트를 기술할 뿐이다.
오브젝트 메트릭은 <code>Value</code>과 <code>AverageValue</code>의 <code>target</code> 타입을 지원한다.
<code>Value</code>를 사용할 경우 대상은 API로부터 반환되는 메트릭과 직접 비교된다.
<code>AverageValue</code>를 사용할 경우, 대상 값과 비교되기 이전에 사용자 정의 메트릭 API로부터 반환된 값은 파드의 개수로 나눠진다.
다음은 <code>requests-per-second</code> 메트릭을 YAML로 기술한 예제이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>2k<span style=color:#bbb>
</span></span></span></code></pre></div><p>이러한 메트릭 블록을 여러 개 제공하면, HorizontalPodAutoscaler는 각 메트릭을 차례로 고려한다.
HorizontalPodAutoscaler는 각 메트릭에 대해 제안된 레플리카 개수를 계산하고,
그중 가장 높은 레플리카 개수를 선정한다.</p><p>예를 들어, 네트워크 트래픽 메트릭을 수집하는 모니터링 시스템이 있는 경우,
<code>kubectl edit</code> 명령어를 이용하여 다음과 같이 정의를 업데이트 할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span></span></span></code></pre></div><p>이후, HorizontalPodAutoscaler는 각 파드가 요청 된 약 50%의 CPU 사용률을 소모하는지,
초당 1000 패킷을 처리하는지,
메인-루트 인그레스 뒤의 모든 파드들이 초당 10000 요청을 처리하는지 확인한다.</p><h3 id=보다-구체적인-메트릭을-기초로한-오토스케일링>보다 구체적인 메트릭을 기초로한 오토스케일링</h3><p>많은 메트릭 파이프라인들을 사용하면 이름 또는 <em>labels</em> 이라 불리는 추가적인 식별자로 메트릭을 설명할 수 있다.
그리고, 모든 비 자원 메트릭 타입(파드, 오브젝트 그리고 아래 기술된 외부 타입)에 대해,
메트릭 파이프라인으로 전달되는 추가 레이블 셀렉터를 지정할 수 있다.
예를 들면, <code>verb</code> 레이블로 <code>http_requests</code> 메트릭을 수집하는 경우,
다음과 같이 메트릭 블록을 지정하여 GET 요청에 대해 크기를 조정할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http_requests<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb> </span>{<span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb> </span>{<span style=color:green;font-weight:700>verb</span>:<span style=color:#bbb> </span>GET}}<span style=color:#bbb>
</span></span></span></code></pre></div><p>이 셀렉터는 쿠버네티스의 레이블 셀렉터와 동일한 문법이다.
모니터링 파이프라인은 네임과 셀렉터가 여러 시리즈와 일치하는 경우,
해당 여러 시리즈를 단일 값으로 축소하는 방법을 결정한다.
셀렉터는 부가적인 속성이며,
대상 오브젝트(<code>Pods</code> 타입의 대상 파드, <code>Object</code> 타입으로 기술된 오브젝트)가 아닌 메트릭을 선택할 수 없다.</p><h3 id=쿠버네티스-오브젝트와-관련이-없는-메트릭을-기초로한-오토스케일링>쿠버네티스 오브젝트와 관련이 없는 메트릭을 기초로한 오토스케일링</h3><p>쿠버네티스 위에서 동작하는 애플리케이션은, 쿠버네티스 클러스터의 어떤 오브젝트와도 관련이 없는 메트릭에 기반하여
오토스케일링을 할 수도 있다.
예로, 쿠버네티스 네임스페이스와 관련이 없는 서비스를 기초로한 메트릭을 들 수 있다.
쿠버네티스 버전 1.10 포함 이후 버전에서, <em>외부 메트릭</em> 을 사용하여 이러한 유스케이스를 해결할 수 있다.</p><p>외부 메트릭 사용시, 먼저 모니터링 시스템에 대한 이해가 있어야 한다.
이 설치는 사용자 정의 메트릭과 유사하다.
외부 메트릭을 사용하면 모니터링 시스템의 사용 가능한 메트릭에 기반하여 클러스터를 오토스케일링 할 수 있다.
위의 예제처럼 <code>name</code>과 <code>selector</code>를 갖는 <code>metric</code> 블록을 명시하고,
<code>Object</code> 대신에 <code>External</code> 메트릭 타입을 사용한다.
만일 여러 개의 시계열이 <code>metricSelector</code>와 일치하면, HorizontalPodAutoscaler가 값의 합을 사용한다.
외부 메트릭들은 <code>Value</code>와 <code>AverageValue</code> 대상 타입을 모두 지원하고,
<code>Object</code> 타입을 사용할 때와 똑같이 동작한다.</p><p>예를 들면 애플리케이션이 호스팅 된 대기열 서비스에서 작업을 처리하는 경우,
다음과 같이 HorizontalPodAutoscaler 매니퍼스트에 30개의 미해결 태스크 당 한 개의 워커를 지정하도록 추가할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>External<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>external</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>queue_messages_ready<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>queue</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;worker_tasks&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>가능하다면, 외부 메트릭 대신 사용자 정의 메트릭 대상 타입을 사용하길 권장한다.
왜냐하면, 클러스터 관리자가 사용자 정의 메트릭 API를 보안관점에서 더 쉽게 보호할 수 있기 때문이다.
외부 메트릭 API는 잠재적으로 어떠한 메트릭에도 접근할 수 있기에, 클러스터 관리자는 API를 노출시킬때 신중해야 한다.</p><h2 id=부록-horizontal-pod-autoscaler-상태-조건>부록: Horizontal Pod Autoscaler 상태 조건</h2><p>HorizontalPodAutoscaler의 <code>autoscaling/v2</code> 형식을 사용하면,
HorizontalPodAutoscaler에서 쿠버네티스가 설정한 <em>상태 조건</em> 을 확인할 수 있다.
이 상태 조건들은 HorizontalPodAutoscaler가 스케일을 할 수 있는지,
어떤 방식으로든 제한되어 있는지 여부를 나타낸다.</p><p>이 조건은 <code>status.conditions</code>에 나타난다.
HorizontalPodAutoscaler에 영향을 주는 조건을 보기 위해 <code>kubectl describe hpa</code>를 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe hpa cm-test
</span></span></code></pre></div><pre tabindex=0><code>Name:                           cm-test
Namespace:                      prom
Labels:                         &lt;none&gt;
Annotations:                    &lt;none&gt;
CreationTimestamp:              Fri, 16 Jun 2017 18:09:22 +0000
Reference:                      ReplicationController/cm-test
Metrics:                        ( current / target )
  &#34;http_requests&#34; on pods:      66m / 500m
Min replicas:                   1
Max replicas:                   4
ReplicationController pods:     1 current / 1 desired
Conditions:
  Type                  Status  Reason                  Message
  ----                  ------  ------                  -------
  AbleToScale           True    ReadyForNewScale        the last scale time was sufficiently old as to warrant a new scale
  ScalingActive         True    ValidMetricFound        the HPA was able to successfully calculate a replica count from pods metric http_requests
  ScalingLimited        False   DesiredWithinRange      the desired replica count is within the acceptable range
Events:
</code></pre><p>이 HorizontalPodAutoscaler 경우, 건강 상태의 여러 조건들을 볼 수 있다.
첫 번째 <code>AbleToScale</code>는 HPA가 스케일을 가져오고 업데이트할 수 있는지,
백 오프 관련 조건으로 스케일링이 방지되는지 여부를 나타낸다.
두 번째 <code>ScalingActive</code>는 HPA가 활성화되어 있는지(즉 대상 레플리카 개수가 0이 아닌지),
원하는 스케일을 계산할 수 있는지 여부를 나타낸다. 만약 <code>False</code> 인 경우,
일반적으로 메트릭을 가져오는 데 문제가 있다.
마지막으로, 마지막 조건인 <code>ScalingLimited</code>는
원하는 스케일 한도가 HorizontalPodAutoscaler의 최대/최소값으로 제한돼있음을 나타낸다.
이는 HorizontalPodAutoscaler에서 레플리카의 개수 제한을 최대/최소값으로 올리거나 낮추려는 것이다.</p><h2 id=수량>수량</h2><p>HorizontalPodAutoscaler와 메트릭 API에서 모든 메트릭은
쿠버네티스에서 사용하는
<a class=glossary-tooltip title='SI 접미사를 사용하는 작거나 큰 숫자의 정수(whole-number) 표현.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-quantity' target=_blank aria-label=수량>수량</a> 숫자 표기법을 사용한다.
예를 들면, <code>10500m</code> 수량은 10진법 <code>10.5</code>으로 쓰인다.
메트릭 API들은 가능한 경우 접미사 없이 정수를 반환하며,
일반적으로 수량을 밀리단위로 반환한다.
10진수로 표현했을때, <code>1</code>과 <code>1500m</code> 또는 <code>1</code>과 <code>1.5</code> 로 메트릭 값을 나타낼 수 있다.</p><h2 id=다른-가능한-시나리오>다른 가능한 시나리오</h2><h3 id=명시적으로-오토스케일러-만들기>명시적으로 오토스케일러 만들기</h3><p>HorizontalPodAutoscaler를 생성하기 위해 <code>kubectl autoscale</code> 명령어를 사용하지 않고,
명시적으로 다음 매니페스트를 사용하여 만들 수 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/hpa/php-apache.yaml download=application/hpa/php-apache.yaml><code>application/hpa/php-apache.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-hpa-php-apache-yaml")' title="Copy application/hpa/php-apache.yaml to clipboard"></img></div><div class=includecode id=application-hpa-php-apache-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>다음으로, 아래의 명령어를 실행하여 오토스케일러를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/application/hpa/php-apache.yaml
</span></span></code></pre></div><pre tabindex=0><code>horizontalpodautoscaler.autoscaling/php-apache created
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-52cd10ee3fc7c74a6c31043a2d489878>8.8 - 파드 내에서 쿠버네티스 API에 접근</h1><p>이 페이지는 파드 내에서 쿠버네티스 API에 접근하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=accessing-the-api-from-within-a-pod>파드 내에서 API에 접근</h2><p>파드 내에서 API에 접근할 때, API 서버를 찾아 인증하는 것은
위에서 설명한 외부 클라이언트 사례와 약간 다르다.</p><p>파드에서 쿠버네티스 API를 사용하는 가장 쉬운 방법은
공식 <a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리</a> 중 하나를 사용하는 것이다. 이러한
라이브러리는 API 서버를 자동으로 감지하고 인증할 수 있다.</p><h3 id=공식-클라이언트-라이브러리-사용>공식 클라이언트 라이브러리 사용</h3><p>파드 내에서, 쿠버네티스 API에 연결하는 권장 방법은 다음과 같다.</p><ul><li><p>Go 클라이언트의 경우, 공식 <a href=https://github.com/kubernetes/client-go/>Go 클라이언트 라이브러리</a>를 사용한다.
<code>rest.InClusterConfig()</code> 기능은 API 호스트 검색과 인증을 자동으로 처리한다.
<a href=https://git.k8s.io/client-go/examples/in-cluster-client-configuration/main.go>여기 예제</a>를 참고한다.</p></li><li><p>Python 클라이언트의 경우, 공식 <a href=https://github.com/kubernetes-client/python/>Python 클라이언트 라이브러리</a>를 사용한다.
<code>config.load_incluster_config()</code> 기능은 API 호스트 검색과 인증을 자동으로 처리한다.
<a href=https://github.com/kubernetes-client/python/blob/master/examples/in_cluster_config.py>여기 예제</a>를 참고한다.</p></li><li><p>사용할 수 있는 다른 라이브러리가 많이 있다. <a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리</a> 페이지를 참고한다.</p></li></ul><p>각각의 경우, 파드의 서비스 어카운트 자격 증명은 API 서버와
안전하게 통신하는 데 사용된다.</p><h3 id=rest-api에-직접-접근>REST API에 직접 접근</h3><p>파드에서 실행되는 동안, 쿠버네티스 apiserver는 <code>default</code> 네임스페이스에서 <code>kubernetes</code>라는
서비스를 통해 접근할 수 있다. 따라서, 파드는 <code>kubernetes.default.svc</code>
호스트 이름을 사용하여 API 서버를 쿼리할 수 있다. 공식 클라이언트 라이브러리는
이를 자동으로 수행한다.</p><p>API 서버를 인증하는 권장 방법은
<a href=/docs/tasks/configure-pod-container/configure-service-account/>서비스 어카운트</a> 자격 증명을 사용하는 것이다.
기본적으로, 파드는 서비스 어카운트와 연결되어 있으며,
해당 서비스 어카운트에 대한 자격 증명(토큰)은
해당 파드에 있는 각 컨테이너의 파일시스템 트리의
<code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 에 있다.</p><p>사용 가능한 경우, 인증서 번들은 각 컨테이너의
파일시스템 트리의 <code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</code> 에 배치되며,
API 서버의 제공 인증서를 확인하는 데 사용해야 한다.</p><p>마지막으로, 네임스페이스가 지정된 API 작업에 사용되는 기본 네임스페이스는 각 컨테이너의
<code>/var/run/secrets/kubernetes.io/serviceaccount/namespace</code> 에 있는 파일에 배치된다.</p><h3 id=kubectl-프록시-사용>kubectl 프록시 사용</h3><p>공식 클라이언트 라이브러리 없이 API를 쿼리하려면, 파드에서
새 사이드카 컨테이너의 <a href=/ko/docs/tasks/inject-data-application/define-command-argument-container/>명령</a>으로
<code>kubectl proxy</code> 를 실행할 수 있다. 이런 식으로, <code>kubectl proxy</code> 는
API를 인증하고 이를 파드의 <code>localhost</code> 인터페이스에 노출시켜서, 파드의
다른 컨테이너가 직접 사용할 수 있도록 한다.</p><h3 id=프록시를-사용하지-않고-접근>프록시를 사용하지 않고 접근</h3><p>인증 토큰을 API 서버에 직접 전달하여 kubectl 프록시 사용을
피할 수 있다. 내부 인증서는 연결을 보호한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 내부 API 서버 호스트 이름을 가리킨다</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span>https://kubernetes.default.svc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 서비스어카운트(ServiceAccount) 토큰 경로</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#666>=</span>/var/run/secrets/kubernetes.io/serviceaccount
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이 파드의 네임스페이스를 읽는다</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>NAMESPACE</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>cat <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#b68;font-weight:700>}</span>/namespace<span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 서비스어카운트 베어러 토큰을 읽는다</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>cat <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#b68;font-weight:700>}</span>/token<span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 내부 인증 기관(CA)을 참조한다</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>CACERT</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#b68;font-weight:700>}</span>/ca.crt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># TOKEN으로 API를 탐색한다</span>
</span></span><span style=display:flex><span>curl --cacert <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CACERT</span><span style=color:#b68;font-weight:700>}</span> --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>TOKEN</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span> -X GET <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>APISERVER</span><span style=color:#b68;font-weight:700>}</span>/api
</span></span></code></pre></div><p>출력은 다음과 비슷하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-ca3bc4e31dfe46d5044a3b93eb804ee9>9 - 잡(Job) 실행</h1><div class=lead>병렬 처리를 사용하여 잡을 실행한다.</div></div><div class=td-content><h1 id=pg-964bdff888520740e5e221695245678d>9.1 - 크론잡(CronJob)으로 자동화된 작업 실행</h1><p><a class=glossary-tooltip title='정기적인 일정으로 실행되는 반복 작업(잡).' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/cron-jobs/ target=_blank aria-label=크론잡>크론잡</a>을 이용하여
<a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a>을 시간 기반의 스케줄에 따라 실행할 수 있다.
이러한 자동화된 잡은 리눅스 또는 유닉스 시스템의 <a href=https://ko.wikipedia.org/wiki/Cron>크론</a> 작업처럼 실행된다.</p><p>크론 잡은 백업을 수행하거나 이메일을 보내는 것과 같이 주기적이고 반복적인 작업들을 생성하는 데 유용하다.
크론 잡은 시스템 사용이 적은 시간에 잡을 스케줄하려는 경우처럼 특정 시간에 개별 작업을 스케줄할 수도 있다.</p><p>크론 잡에는 제한 사항과 특이점이 있다.
예를 들어, 특정 상황에서는 하나의 크론 잡이 여러 잡을 생성할 수 있다.
따라서, 잡은 멱등성을 가져야 한다.</p><p>제한 사항에 대한 자세한 내용은 <a href=/ko/docs/concepts/workloads/controllers/cron-jobs/>크론잡</a>을 참고한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul></li></ul><h2 id=creating-a-cron-job>크론잡(CronJob) 생성</h2><p>크론 잡은 구성 파일이 필요하다.
다음은 1분마다 간단한 데모 작업을 실행하는 크론잡 매니페스트다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-cronjob-yaml")' title="Copy application/job/cronjob.yaml to clipboard"></img></div><div class=includecode id=application-job-cronjob-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * *&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>다음 명령을 사용하여 크론잡 예제를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/application/job/cronjob.yaml
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>cronjob.batch/hello created
</code></pre><p>크론 잡을 생성한 후, 다음 명령을 사용하여 상태를 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get cronjob hello
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        &lt;none&gt;          10s
</code></pre><p>명령의 결과에서 알 수 있듯이, 크론 잡은 아직 잡을 스케줄하거나 실행하지 않았다.
약 1분 내로 잡이 생성되는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get <span style=color:#a2f>jobs</span> --watch
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME               COMPLETIONS   DURATION   AGE
hello-4111706356   0/1                      0s
hello-4111706356   0/1           0s         0s
hello-4111706356   1/1           5s         5s
</code></pre><p>이제 "hello" 크론 잡에 의해 스케줄된 실행 중인 작업을 확인했다.
잡 감시를 중지한 뒤에 크론 잡이 다시 스케줄되었는지를 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get cronjob hello
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        50s             75s
</code></pre><p>크론 잡 <code>hello</code> 가 <code>LAST SCHEDULE</code> 열에 명시된 시간에 잡을 성공적으로 스케줄링한 것을 볼 수 있다.
현재는 0개의 활성 잡이 있고, 이는 작업이 완료되었거나 실패했음을 의미한다.</p><p>이제, 마지막으로 스케줄된 잡이 생성한 파드를 찾고 생성된 파드 중 하나의 표준 출력을 확인한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 잡 이름과 파드 이름은 다르다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;hello-4111706356&#34;을 사용자의 시스템에 있는 잡 이름으로 바꾼다</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span>job-name<span style=color:#666>=</span>hello-4111706356 --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items<span style=color:#666>[</span>*<span style=color:#666>]</span>.metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><p>파드의 로그를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>Fri Feb 22 11:02:09 UTC 2019
Hello from the Kubernetes cluster
</code></pre><h2 id=deleting-a-cron-job>크론잡(CronJob) 삭제</h2><p>더 이상 크론 잡이 필요하지 않으면, <code>kubectl delete cronjob &lt;cronjob name></code> 명령을 사용해서 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete cronjob hello
</span></span></code></pre></div><p>크론 잡을 삭제하면 생성된 모든 잡과 파드가 제거되고 추가 잡 생성이 중지된다.
<a href=/ko/docs/concepts/architecture/garbage-collection/>가비지(garbage) 수집</a>에서 잡 제거에 대해 상세한 내용을 읽을 수 있다.</p><h2 id=writing-a-cron-job-spec>크론잡(CronJob) 명세 작성</h2><p>다른 모든 쿠버네티스 오브젝트들과 마찬가지로,
크론잡은 <code>apiVersion</code>, <code>kind</code> 그리고 <code>metadata</code> 필드가 반드시 필요하다.
쿠버네티스 오브젝트 및 그 <a class=glossary-tooltip title='하나 이상의 쿠버네티스 API 오브젝트를 직렬화한 명세(specification).' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-manifest' target=_blank aria-label=매니페스트>매니페스트</a> 다루기에 대한
자세한 내용은 <a href=/ko/docs/concepts/cluster-administration/manage-deployment/>리소스 관리하기</a>와
<a href=/ko/docs/concepts/overview/working-with-objects/object-management/>kubectl을 사용하여 리소스 관리하기</a> 문서를 참고한다.</p><p>크론잡(CronJob)의 각 매니페스트에는 <a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%AA%85%EC%84%B8-spec-%EC%99%80-%EC%83%81%ED%83%9C-status><code>.spec</code></a> 섹션도 필요하다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 크론잡(CronJob)을 수정한 경우, 수정 후 새로 실행하는 작업부터 적용된다.
이미 시작된 작업(및 해당 파드)은 변경 없이 계속 실행된다.
즉, 크론잡(CronJob)은 기존 작업이 계속 실행 중이라면, 작업을 변경하지 <em>않는다.</em></div><h3 id=스케줄>스케줄</h3><p><code>.spec.schedule</code> 은 <code>.spec</code> 의 필수 필드이다.
이 필드는 <code>0 * * * *</code> 또는 <code>@hourly</code>와 같은 <a href=https://ko.wikipedia.org/wiki/Cron>크론</a> 형식의 문자열을 받아,
해당 잡이 생성 및 실행될 스케줄 시간으로 설정한다.</p><p>이 형식은 확장된 "Vixie cron" 스텝(step) 값도 포함한다. 이 내용은
<a href=https://www.freebsd.org/cgi/man.cgi?crontab%285%29>FreeBSD 매뉴얼</a>에 설명되어 있다.</p><blockquote><p>스텝 값은 범위(range)와 함께 사용할 수 있다. 범위 뒤에 <code>/&lt;number></code> 를
지정하여 범위 내에서 숫자만큼의 값을 건너뛴다. 예를 들어,
시간 필드에 <code>0-23/2</code> 를 사용하여 매 2시간마다 명령 실행을
지정할 수 있다(V7 표준의 대안은 <code>0,2,4,6,8,10,12,14,16,18,20,22</code>
이다). 별표(asterisk) 뒤에 붙이는 스텝도 허용되며,
"2시간마다"라고 지정하고 싶으면, 간단히 <code>*/2</code> 를 사용하면 된다.</p></blockquote><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 스케줄에서 물음표(<code>?</code>)는 별표 <code>*</code> 와 동일한 의미를 가지며,
주어진 필드에 대해 사용할 수 있는 모든 값을 나타낸다.</div><h3 id=잡-템플릿>잡 템플릿</h3><p><code>.spec.jobTemplate</code> 은 잡에 대한 템플릿이며, 이것은 필수 필드다.
이것은 중첩되어(nested) 있고 <code>apiVersion</code> 이나 <code>kind</code> 가 없다는 것을 제외하면,
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a>과 정확히 같은 스키마를 가진다.
잡 <code>.spec</code> 을 작성하는 것에 대한 내용은 <a href=/ko/docs/concepts/workloads/controllers/job/#%EC%9E%A1-%EC%82%AC%EC%96%91-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0>잡 명세 작성하기</a>를 참고한다.</p><h3 id=시작-기한>시작 기한</h3><p><code>.spec.startingDeadlineSeconds</code> 필드는 선택 사항이다.
어떤 이유로든 스케줄된 시간을 놓친 경우 잡의 시작 기한을 초 단위로 나타낸다.
기한이 지나면, 크론 잡이 잡을 시작하지 않는다.
이러한 방식으로 기한을 맞추지 못한 잡은 실패한 작업으로 간주된다.
이 필드를 지정하지 않으면, 잡에 기한이 없다.</p><p><code>.spec.startingDeadlineSeconds</code> 필드가 (null이 아닌 값으로) 설정되어 있다면,
크론잡 컨트롤러는 예상 잡 생성 시각과 현재 시각의 차이를 측정하고,
시각 차이가 설정한 값보다 커지면 잡 생성 동작을 스킵한다.</p><p>예를 들어, <code>200</code> 으로 설정되었다면,
예상 잡 생성 시각으로부터 200초까지는 잡이 생성될 수 있다.</p><h3 id=동시성-정책>동시성 정책</h3><p><code>.spec.concurrencyPolicy</code> 필드도 선택 사항이다.
이것은 이 크론 잡에 의해 생성된 잡의 동시 실행을 처리하는 방법을 지정한다.
명세는 다음의 동시성 정책 중 하나만 지정할 수 있다.</p><ul><li><code>Allow</code>(기본값): 크론 잡은 동시에 실행되는 잡을 허용한다.</li><li><code>Forbid</code>: 크론 잡은 동시 실행을 허용하지 않는다.
새로운 잡을 실행할 시간이고 이전 잡 실행이 아직 완료되지 않은 경우, 크론 잡은 새로운 잡 실행을 건너뛴다.</li><li><code>Replace</code>: 새로운 잡을 실행할 시간이고 이전 잡 실행이 아직 완료되지 않은 경우,
크론 잡은 현재 실행 중인 잡 실행을 새로운 잡 실행으로 대체한다.</li></ul><p>참고로 동시성 정책은 동일한 크론 잡에 의해 생성된 잡에만 적용된다.
크론 잡이 여러 개인 경우, 각각의 잡은 항상 동시에 실행될 수 있다.</p><h3 id=일시-정지>일시 정지</h3><p><code>.spec.suspend</code> 필드도 선택 사항이다.
<code>true</code> 로 설정되면, 모든 후속 실행이 일시 정지된다.
이 설정은 이미 시작된 실행에는 적용되지 않는다.
기본값은 false이다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 스케줄된 시간 동안 잡이 일시 정지되어 있다면 누락된 잡으로 간주한다.
<a href=#%EC%8B%9C%EC%9E%91-%EA%B8%B0%ED%95%9C>시작 기한</a> 없이 기존의 크론 잡에 대해 <code>.spec.suspend</code> 가 <code>true</code> 에서 <code>false</code> 로 변경되면,
누락된 잡들이 즉시 스케줄된다.</div><h3 id=잡-히스토리-한도>잡 히스토리 한도</h3><p><code>.spec.successfulJobsHistoryLimit</code> 와 <code>.spec.failedJobsHistoryLimit</code> 필드는 선택 사항이다.
이들 필드는 기록을 보관해야 하는 완료 및 실패한 잡의 개수를 지정한다.
기본적으로, 각각 3과 1로 설정된다.
한도를 <code>0</code> 으로 설정하는 것은 잡 완료 후에 해당 잡 유형의 기록을 보관하지 않는다는 것이다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1058efa4d70f13c015e6a2094ff85068>9.2 - 작업 대기열을 사용한 거친 병렬 처리</h1><p>이 예제에서는, 여러 병렬 워커 프로세스를 활용해 쿠버네티스 잡(Job)을
실행한다.</p><p>이 예제에서는, 각 파드가 생성될 때 작업 대기열에서 하나의 작업 단위를
선택하여, 완료하고, 대기열에서 삭제하고, 종료한다.</p><p>이 예제에서의 단계에 대한 개요는 다음과 같다.</p><ol><li><strong>메시지 대기열 서비스를 시작한다.</strong> 이 예에서는, RabbitMQ를 사용하지만, 다른 메시지 대기열을 이용해도
된다. 실제로 사용할 때는, 한 번 메시지 대기열 서비스를 구축하고서 이를 여러 잡을 위해 재사용하기도 한다.</li><li><strong>대기열을 만들고, 메시지로 채운다.</strong> 각 메시지는 수행할 하나의 작업을 나타낸다.
이 예제에서, 메시지는 긴 계산을 수행할 정수다.</li><li><strong>대기열에서 작업을 수행하는 잡을 시작한다.</strong> 잡은 여러 파드를 시작한다. 각 파드는
메시지 대기열에서 하나의 작업을 가져와서, 처리한 다음, 대기열이 비워질 때까지 반복한다.</li></ol><h2 id=시작하기-전에>시작하기 전에</h2><p>기본적이고, 병렬 작업이 아닌,
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a>의 사용법에 대해 잘 알고 있어야 한다.</p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=메시지-대기열-서비스-시작>메시지 대기열 서비스 시작</h2><p>이 예시에서는 RabbitMQ를 사용하지만, 다른 AMQP 유형의 메시지 서비스를 사용하도록 예시를 조정할 수 있다.</p><p>실제로 사용할 때는, 클러스터에 메시지 대기열 서비스를 한 번
구축하고서, 여러 많은 잡이나 오래 동작하는 서비스에 재사용할 수 있다.</p><p>다음과 같이 RabbitMQ를 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.3/examples/celery-rabbitmq/rabbitmq-service.yaml
</span></span></code></pre></div><pre tabindex=0><code>service &#34;rabbitmq-service&#34; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.3/examples/celery-rabbitmq/rabbitmq-controller.yaml
</span></span></code></pre></div><pre tabindex=0><code>replicationcontroller &#34;rabbitmq-controller&#34; created
</code></pre><p>이 문서에서는 <a href=https://github.com/kubernetes/kubernetes/tree/release-1.3/examples/celery-rabbitmq>celery-rabbitmq 예제</a>에 나오는 정도로만 rabbitmq를 사용한다.</p><h2 id=메시지-대기열-서비스-테스트하기>메시지 대기열 서비스 테스트하기</h2><p>이제, 메시지 대기열을 이용해 실험할 수 있다. 임시
대화형 파드를 만들어 그 위에 도구들을 설치하고,
대기열을 실험해본다.</p><p>먼저 임시 대화형 파드를 만든다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 임시 대화형 컨테이너를 만든다.</span>
</span></span><span style=display:flex><span>kubectl run -i --tty temp --image ubuntu:18.04
</span></span></code></pre></div><pre tabindex=0><code>Waiting for pod default/temp-loe07 to be running, status is Pending, pod ready: false
... [ previous line repeats several times .. hit return when it stops ] ...
</code></pre><p>참고로 파드 이름과 명령 프롬프트는 위와 다를 수 있다.</p><p>다음으로 <code>amqp-tools</code>를 설치하여 메시지 대기열을 활용할 수 있게 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 도구들을 설치한다.</span>
</span></span><span style=display:flex><span>root@temp-loe07:/# apt-get update
</span></span><span style=display:flex><span>.... <span style=color:#666>[</span> lots of output <span style=color:#666>]</span> ....
</span></span><span style=display:flex><span>root@temp-loe07:/# apt-get install -y curl ca-certificates amqp-tools python dnsutils
</span></span><span style=display:flex><span>.... <span style=color:#666>[</span> lots of output <span style=color:#666>]</span> ....
</span></span></code></pre></div><p>후에, 이 패키지들을 포함하는 도커 이미지를 만든다.</p><p>다음으로, rabbitmq 서비스를 발견할 수 있는지 확인한다.</p><pre tabindex=0><code># rabbitmq-service가 쿠버네티스로부터 주어진 DNS 이름을 갖는다.

root@temp-loe07:/# nslookup rabbitmq-service
Server:        10.0.0.10
Address:    10.0.0.10#53

Name:    rabbitmq-service.default.svc.cluster.local
Address: 10.0.147.152

# 주소는 다를 수 있다.
</code></pre><p>만약 Kube-DNS가 적절히 구축되지 않았다면, 전 단계 작업이 작동하지 않을 수 있다.
환경 변수를 통해서도 서비스 IP를 찾을 수 있다.</p><pre tabindex=0><code># env | grep RABBIT | grep HOST
RABBITMQ_SERVICE_SERVICE_HOST=10.0.147.152
# 주소는 다를 수 있다.
</code></pre><p>다음으로 대기열을 생성하고, 메시지를 발행하고 사용할 수 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 다음 줄에서, rabbitmq-service는 rabbitmq-service에 접근할 수 있는 </span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 호스트네임이다. 5672는 rabbitmq의 표준 포트이다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@temp-loe07:/# <span style=color:#a2f>export</span> <span style=color:#b8860b>BROKER_URL</span><span style=color:#666>=</span>amqp://guest:guest@rabbitmq-service:5672
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 만약 전 단계에서 &#34;rabbitmq-service&#34;가 주소로 변환되지 않는다면,</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이 커맨드를 대신 사용하면 된다.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># root@temp-loe07:/# BROKER_URL=amqp://guest:guest@$RABBITMQ_SERVICE_SERVICE_HOST:5672</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이제 대기열을 생성한다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@temp-loe07:/# /usr/bin/amqp-declare-queue --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -q foo -d
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 대기열에 메시지를 하나 발행한다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@temp-loe07:/# /usr/bin/amqp-publish --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -r foo -p -b Hello
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 다시 메시지를 돌려받는다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@temp-loe07:/# /usr/bin/amqp-consume --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -q foo -c <span style=color:#666>1</span> cat <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>echo</span>
</span></span><span style=display:flex><span>Hello
</span></span><span style=display:flex><span>root@temp-loe07:/#
</span></span></code></pre></div><p>마지막 커맨드에서, <code>amqp-consume</code> 도구는 대기열로부터 하나의 메시지를
받고(<code>-c 1</code>), 그 메시지를 임의의 명령 표준입력으로 전달한다. 이 경우에는, <code>cat</code> 프로그램이 표준입력으로부터 받은 값을 출력하고, echo가 캐리지 리턴을 더해주어
출력 결과가 보여진다.</p><h2 id=작업으로-대기열-채우기>작업으로 대기열 채우기</h2><p>이제 몇 가지 "작업"으로 대기열을 채운다. 이 예제에서의 작업은 문자열을
출력하는 것이다.</p><p>실제로 사용할 때는, 메시지의 내용이 다음과 같을 수 있다.</p><ul><li>처리되어야 하는 파일들의 이름</li><li>프로그램의 추가 플래그</li><li>데이터베이스 테이블의 키(key) 범위</li><li>시뮬레이션의 구성 파라미터</li><li>렌더링해야 하는 씬(scene)의 프레임 번호</li></ul><p>실제로는, 잡의 모든 파드에서 읽기-전용 모드로 필요한 큰 데이터가
있다면, 일반적으로 그 데이터를 NFS와 같은 공유 파일시스템에 넣고
모든 파드에 읽기 전용으로 마운트하거나, 파드 안에 있는 프로그램이 기본적으로 HDFS와 같은
클러스터 파일시스템으로부터 데이터를 불러들인다.</p><p>본 예제에서는, 대기열을 만들고 amqp 커맨드라인 도구를 이용해 대기열을 채울 것이다.
실제로는, amqp 라이브러리를 이용해 대기열을 채우는 프로그램을 작성하게 된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/usr/bin/amqp-declare-queue --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -q job1  -d
</span></span><span style=display:flex><span>job1
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> f in apple banana cherry date fig grape lemon melon
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>  /usr/bin/amqp-publish --url<span style=color:#666>=</span><span style=color:#b8860b>$BROKER_URL</span> -r job1 -p -b <span style=color:#b8860b>$f</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><p>8개의 메시지로 대기열을 채웠다.</p><h2 id=이미지-생성>이미지 생성</h2><p>이제 잡으로 실행할 이미지를 만들 준비가 되었다.</p><p><code>amqp-consume</code> 유틸리티를 이용해 대기열로부터 메시지를 읽고,
실제 프로그램을 실행해 볼 것이다.
여기에 아주 간단한 예제 프로그램이 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/rabbitmq/worker.py download=application/job/rabbitmq/worker.py><code>application/job/rabbitmq/worker.py</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-rabbitmq-worker-py")' title="Copy application/job/rabbitmq/worker.py to clipboard"></img></div><div class=includecode id=application-job-rabbitmq-worker-py><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#080;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 표준 출력만 출력하고 10초 동안 대기한다.</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>sys</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>time</span>
</span></span><span style=display:flex><span><span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Processing &#34;</span> <span style=color:#666>+</span> sys<span style=color:#666>.</span>stdin<span style=color:#666>.</span>readlines()[<span style=color:#666>0</span>])
</span></span><span style=display:flex><span>time<span style=color:#666>.</span>sleep(<span style=color:#666>10</span>)
</span></span></code></pre></div></div></div><p>스크립트에 실행 권한을 준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>chmod +x worker.py
</span></span></code></pre></div><p>이제 이미지를 빌드한다. 만약 소스 트리 안에서 작업하고
있다면, <code>examples/job/work-queue-1</code>로 디렉터리를 옮긴다.
아니면, 임시 디렉터리를 만들고, 그 디렉터리로 옮긴다.
<a href=/examples/application/job/rabbitmq/Dockerfile>Dockerfile</a>과
<a href=/examples/application/job/rabbitmq/worker.py>worker.py</a>를 다운로드한다.
위 두 경우 모두, 다음의 명령을 이용해 이미지를 빌드한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker build -t job-wq-1 .
</span></span></code></pre></div><p><a href=https://hub.docker.com/>도커 허브</a>를 이용하기 위해, 앱 이미지를
사용자의 username으로 태깅하고 아래의 명령어를 이용해 허브에 푸시한다.
<code>&lt;username></code>을 사용자의 허브 username으로 대체한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker tag job-wq-1 &lt;username&gt;/job-wq-1
</span></span><span style=display:flex><span>docker push &lt;username&gt;/job-wq-1
</span></span></code></pre></div><p>만약 <a href=https://cloud.google.com/tools/container-registry/>구글 컨테이너
레지스트리</a>를 이용하고 있다면,
앱 이미지를 사용자의 프로젝트 ID를 이용해 태깅하고, GCR에 푸시한다.
<code>&lt;proejct></code> 부분을 사용자의 프로젝트 ID로 대체한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker tag job-wq-1 gcr.io/&lt;project&gt;/job-wq-1
</span></span><span style=display:flex><span>gcloud docker -- push gcr.io/&lt;project&gt;/job-wq-1
</span></span></code></pre></div><h2 id=잡-정의>잡 정의</h2><p>다음은 잡 정의이다. 잡의 사본을 만들고 위에서 정한 이름에 맞게
이미지를 수정하고, 파일 이름을 <code>./job.yaml</code>이라 정한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/rabbitmq/job.yaml download=application/job/rabbitmq/job.yaml><code>application/job/rabbitmq/job.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-rabbitmq-job-yaml")' title="Copy application/job/rabbitmq/job.yaml to clipboard"></img></div><div class=includecode id=application-job-rabbitmq-job-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>8</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/&lt;project&gt;/job-wq-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>BROKER_URL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>amqp://guest:guest@rabbitmq-service:5672<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>QUEUE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>job1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이 예시에서는, 각 파드가 대기열로부터 얻은 하나의 아이템을 수행하고 종료한다.
그래서, 잡의 완료 횟수가 완료된 작업 아이템의 숫자에 대응한다.
예시에서 <code>.spec.completions: 8</code>이라 정한 것도, 대기열에 8개의 아이템을 넣었기 때문이다.</p><h2 id=잡-실행>잡 실행</h2><p>이제 잡을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./job.yaml
</span></span></code></pre></div><p>이제 조금 기다린 다음, 잡을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe jobs/job-wq-1
</span></span></code></pre></div><pre tabindex=0><code>Name:             job-wq-1
Namespace:        default
Selector:         controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
Labels:           controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                  job-name=job-wq-1
Annotations:      &lt;none&gt;
Parallelism:      2
Completions:      8
Start Time:       Wed, 06 Sep 2017 16:42:02 +0800
Pods Statuses:    0 Running / 8 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                job-name=job-wq-1
  Containers:
   c:
    Image:      gcr.io/causal-jigsaw-637/job-wq-1
    Port:
    Environment:
      BROKER_URL:       amqp://guest:guest@rabbitmq-service:5672
      QUEUE:            job1
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Events:
  FirstSeen  LastSeen   Count    From    SubobjectPath    Type      Reason              Message
  ─────────  ────────   ─────    ────    ─────────────    ──────    ──────              ───────
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-hcobb
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-weytj
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-qaam5
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-b67sr
  26s        26s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-xe5hj
  15s        15s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-w2zqe
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-d6ppa
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-p17e0
</code></pre><p>모든 파드가 성공했다. 야호.</p><h2 id=대안>대안</h2><p>이러한 접근은 "워커" 프로그램을 작업 대기열에 맞게 수정하지 않아도
된다는 장점이 있다.</p><p>이 접근을 이용하려면, 메시지 대기열 서비스를 실행해야만 한다.
만약 메시지 대기열 서비스를 실행하는 게 불편하다면,
다른 <a href=/ko/docs/concepts/workloads/controllers/job/#%EC%9E%A1-%ED%8C%A8%ED%84%B4>잡 패턴</a>을 고려해볼 수 있다.</p><p>이 접근은 모든 작업 아이템에 대해 파드를 생성한다. 만약 작업 아이템이 오직 몇 초밖에 걸리지 않는 작업이라면,
매 작업마다 파드를 생성하는 것은 아주 큰 오버헤드를 더할 수 있다. 하나의 파드가
여러 작업 아이템을 수행하는 이 <a href=/ko/docs/tasks/job/fine-parallel-processing-work-queue/>예제</a>를 고려해보자.</p><p>이 예제에서는, <code>amqp-consume</code> 유틸리티를 이용해 대기열로부터 메시지를 읽어
실제 프로그램을 실행했다. 이러면 메시지 대기열을 이용하기 위해 프로그램을 수정하지
않아도 된다는 장점이 있다.
<a href=/ko/docs/tasks/job/fine-parallel-processing-work-queue/>다른 예제</a>는
클라이언트 라이브러리를 이용해 작업 대기열과 소통하는 방법을 보여준다.</p><h2 id=주의-사항>주의 사항</h2><p>만약 작업 완료 수가 대기열에 있는 아이템의 숫자보다 적게 설정되면,
모든 아이템 처리되지 않는다.</p><p>만약 작업 완료 수가 큐에 있는 아이템의 숫자보다 많게 설정되면,
대기열에 있는 아이템이 모두 처리되어도, 잡이 완료됐다고 표시되지
않고, 메시지를 기다리는 과정에서 막히는 파드를
추가적으로 실행시킨다.</p><p>이 패턴에서는 경쟁 상태(race)가 잘 나타나지 않는다. 만약 amqp-consume 명령으로부터
메시지가 인정되는 시간과 컨테이너가 성공적으로 종료되는
시간 사이에 컨테이너가 종료되거나, kubelet이 api-server에게 파드가 성공했음을 알리기 전에
노드가 비정상적으로 종료되면, 대기열의 모든 아이템이 처리되었다 해도,
잡이 완료되었다고 표시되지 않는다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-457c9dd93aed2b05615ed28dc38075d3>9.3 - 작업 대기열을 사용한 정밀 병렬 처리</h1><p>이 예에서는, 지정된 파드에서 여러 병렬 워커 프로세스가 있는
쿠버네티스 잡(Job)을 실행한다.</p><p>이 예에서는, 각 파드가 생성될 때, 작업 대기열에서 하나의 작업 단위를
선택하여, 처리하고, 대기열이 비워질 때까지 반복한다.</p><p>이 예에서의 단계에 대한 개요는 다음과 같다.</p><ol><li><strong>작업 대기열을 보관할 스토리지 서비스를 시작한다.</strong> 이 예에서는, Redis를 사용하여
작업 항목을 저장한다. 이전 예에서는, RabbitMQ를 사용했다. 이 예에서는, AMQP가 길이가
정해져 있는 작업 대기열이 비어있을 때 클라이언트가 이를 감지할 수 있는 좋은 방법을 제공하지
않기 때문에 Redis 및 사용자 지정의 작업 대기열 클라이언트 라이브러리를 사용한다. 실제로는
Redis와 같은 저장소를 한 번 설정하고 여러 작업과 다른 것들의 작업 대기열로 재사용한다.</li><li><strong>대기열을 만들고, 메시지로 채운다.</strong> 각 메시지는 수행할 하나의 작업을 나타낸다. 이
예에서, 메시지는 긴 계산을 수행할 정수다.</li><li><strong>대기열에서 작업을 수행하는 잡을 시작한다.</strong> 잡은 여러 파드를 시작한다. 각 파드는
메시지 대기열에서 하나의 작업을 가져와서, 처리한 다음, 대기열이 비워질 때까지 반복한다.</li></ol><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p><a href=/ko/docs/concepts/workloads/controllers/job/>잡</a>의 기본적이고,
병렬 작업이 아닌, 사용법에 대해 잘 알고 있어야 한다.</p><h2 id=redis-시작>Redis 시작</h2><p>이 문서의 예시에서는, 단순함을 위해, Redis의 단일 인스턴스를 시작한다.
Redis를 확장 가능하고 중복적으로 배포하는 예에 대해서는
<a href=https://github.com/kubernetes/examples/tree/master/guestbook>Redis 예시</a>를 참고한다.</p><p>다음 파일을 직접 다운로드할 수도 있다.</p><ul><li><a href=/examples/application/job/redis/redis-pod.yaml><code>redis-pod.yaml</code></a></li><li><a href=/examples/application/job/redis/redis-service.yaml><code>redis-service.yaml</code></a></li><li><a href=/examples/application/job/redis/Dockerfile><code>Dockerfile</code></a></li><li><a href=/examples/application/job/redis/job.yaml><code>job.yaml</code></a></li><li><a href=/examples/application/job/redis/rediswq.py><code>rediswq.py</code></a></li><li><a href=/examples/application/job/redis/worker.py><code>worker.py</code></a></li></ul><h2 id=작업으로-대기열-채우기>작업으로 대기열 채우기</h2><p>이제 몇 가지 "작업"으로 대기열을 채운다. 이 예제의 작업은 문자열을 출력하는
것이다.</p><p>Redis CLI를 실행하기 위한 임시 대화형 파드를 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run -i --tty temp --image redis --command <span style=color:#b44>&#34;/bin/sh&#34;</span>
</span></span><span style=display:flex><span>Waiting <span style=color:#a2f;font-weight:700>for</span> pod default/redis2-c7h78 to be running, status is Pending, pod ready: <span style=color:#a2f>false</span>
</span></span><span style=display:flex><span>Hit enter <span style=color:#a2f;font-weight:700>for</span> <span style=color:#a2f>command</span> prompt
</span></span></code></pre></div><p>이제 엔터 키를 누르고, redis CLI를 시작하고, 몇몇 작업 항목이 포함된 목록을 생성한다.</p><pre tabindex=0><code># redis-cli -h redis
redis:6379&gt; rpush job2 &#34;apple&#34;
(integer) 1
redis:6379&gt; rpush job2 &#34;banana&#34;
(integer) 2
redis:6379&gt; rpush job2 &#34;cherry&#34;
(integer) 3
redis:6379&gt; rpush job2 &#34;date&#34;
(integer) 4
redis:6379&gt; rpush job2 &#34;fig&#34;
(integer) 5
redis:6379&gt; rpush job2 &#34;grape&#34;
(integer) 6
redis:6379&gt; rpush job2 &#34;lemon&#34;
(integer) 7
redis:6379&gt; rpush job2 &#34;melon&#34;
(integer) 8
redis:6379&gt; rpush job2 &#34;orange&#34;
(integer) 9
redis:6379&gt; lrange job2 0 -1
1) &#34;apple&#34;
2) &#34;banana&#34;
3) &#34;cherry&#34;
4) &#34;date&#34;
5) &#34;fig&#34;
6) &#34;grape&#34;
7) &#34;lemon&#34;
8) &#34;melon&#34;
9) &#34;orange&#34;
</code></pre><p>자, 키 <code>job2</code> 가 있는 목록이 작업 대기열이 된다.</p><p>참고: Kube DNS를 올바르게 설정하지 않은 경우, 위 블록의
첫 번째 단계를 <code>redis-cli -h $REDIS_SERVICE_HOST</code> 로 변경해야 할 수 있다.</p><h2 id=이미지-생성>이미지 생성</h2><p>이제 실행할 이미지를 만들 준비가 되었다.</p><p>redis 클라이언트와 함께 python 워커 프로그램을 사용하여
메시지 큐에서 메시지를 읽는다.</p><p>rediswq.py(<a href=/examples/application/job/redis/rediswq.py>다운로드</a>)라는
간단한 Redis 작업 대기열 클라이언트 라이브러리가 제공된다.</p><p>잡의 각 파드에 있는 "워커" 프로그램은 작업 대기열
클라이언트 라이브러리를 사용하여 작업을 가져온다. 다음은 워커 프로그램이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/redis/worker.py download=application/job/redis/worker.py><code>application/job/redis/worker.py</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-redis-worker-py")' title="Copy application/job/redis/worker.py to clipboard"></img></div><div class=includecode id=application-job-redis-worker-py><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#080;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>time</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>rediswq</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>host<span style=color:#666>=</span><span style=color:#b44>&#34;redis&#34;</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Uncomment next two lines if you do not have Kube-DNS working.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># import os</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># host = os.getenv(&#34;REDIS_SERVICE_HOST&#34;)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>q <span style=color:#666>=</span> rediswq<span style=color:#666>.</span>RedisWQ(name<span style=color:#666>=</span><span style=color:#b44>&#34;job2&#34;</span>, host<span style=color:#666>=</span>host)
</span></span><span style=display:flex><span><span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Worker with sessionID: &#34;</span> <span style=color:#666>+</span>  q<span style=color:#666>.</span>sessionID())
</span></span><span style=display:flex><span><span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Initial queue state: empty=&#34;</span> <span style=color:#666>+</span> <span style=color:#a2f>str</span>(q<span style=color:#666>.</span>empty()))
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>while</span> <span style=color:#a2f;font-weight:700>not</span> q<span style=color:#666>.</span>empty():
</span></span><span style=display:flex><span>  item <span style=color:#666>=</span> q<span style=color:#666>.</span>lease(lease_secs<span style=color:#666>=</span><span style=color:#666>10</span>, block<span style=color:#666>=</span><span style=color:#a2f;font-weight:700>True</span>, timeout<span style=color:#666>=</span><span style=color:#666>2</span>)
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> item <span style=color:#a2f;font-weight:700>is</span> <span style=color:#a2f;font-weight:700>not</span> <span style=color:#a2f;font-weight:700>None</span>:
</span></span><span style=display:flex><span>    itemstr <span style=color:#666>=</span> item<span style=color:#666>.</span>decode(<span style=color:#b44>&#34;utf-8&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Working on &#34;</span> <span style=color:#666>+</span> itemstr)
</span></span><span style=display:flex><span>    time<span style=color:#666>.</span>sleep(<span style=color:#666>10</span>) <span style=color:#080;font-style:italic># Put your actual work here instead of sleep.</span>
</span></span><span style=display:flex><span>    q<span style=color:#666>.</span>complete(item)
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span>:
</span></span><span style=display:flex><span>    <span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Waiting for work&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a2f>print</span>(<span style=color:#b44>&#34;Queue empty, exiting&#34;</span>)
</span></span></code></pre></div></div></div><p><a href=/examples/application/job/redis/worker.py><code>worker.py</code></a>,
<a href=/examples/application/job/redis/rediswq.py><code>rediswq.py</code></a> 및
<a href=/examples/application/job/redis/Dockerfile><code>Dockerfile</code></a> 파일을 다운로드할 수 있고, 그런 다음
이미지를 만들 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker build -t job-wq-2 .
</span></span></code></pre></div><h3 id=이미지-푸시>이미지 푸시</h3><p><a href=https://hub.docker.com/>도커 허브(Docker Hub)</a>를 위해, 아래 명령으로
사용자의 username과 앱 이미지에 태그하고 허브에 푸시한다. <code>&lt;username></code> 을
사용자의 허브 username으로 바꾼다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker tag job-wq-2 &lt;username&gt;/job-wq-2
</span></span><span style=display:flex><span>docker push &lt;username&gt;/job-wq-2
</span></span></code></pre></div><p>공용 저장소로 푸시하거나 <a href=/ko/docs/concepts/containers/images/>개인 저장소에 접근할 수 있도록
클러스터를 구성</a>해야 한다.</p><p><a href=https://cloud.google.com/tools/container-registry/>Google Container
Registry</a>를 사용하는 경우,
사용자의 프로젝트 ID로 앱 이미지에 태그를 지정하고 GCR로 푸시한다. <code>&lt;project></code> 를
사용자의 프로젝트 ID로 바꾼다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker tag job-wq-2 gcr.io/&lt;project&gt;/job-wq-2
</span></span><span style=display:flex><span>gcloud docker -- push gcr.io/&lt;project&gt;/job-wq-2
</span></span></code></pre></div><h2 id=잡-정의>잡 정의</h2><p>다음은 잡 정의이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/redis/job.yaml download=application/job/redis/job.yaml><code>application/job/redis/job.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-redis-job-yaml")' title="Copy application/job/redis/job.yaml to clipboard"></img></div><div class=includecode id=application-job-redis-job-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-wq-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/myproject/job-wq-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>사용자 자신의 경로로 <code>gcr.io/myproject</code> 를
변경하려면 잡 템플릿을 편집해야 한다.</p><p>이 예에서, 각 파드는 대기열의 여러 항목에 대해 작업한 다음 더 이상 항목이 없을 때 종료된다.
워커는 작업 대기열이 비어있을 때를 감지하고 잡 컨트롤러는 작업 대기열에 대해
알지 못하기 때문에, 작업이 완료되면 워커에게 신호를 보낸다.
워커는 성공적으로 종료하여 대기열이 비어 있음을 알린다. 따라서, 워커가 성공적으로
종료하자마자, 컨트롤러는 작업이 완료되었음을 인식하고, 파드가 곧 종료된다.
따라서, 잡 완료 횟수를 1로 설정했다. 잡 컨트롤러는 다른 파드도 완료될 때까지
기다린다.</p><h2 id=잡-실행>잡 실행</h2><p>이제 잡을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./job.yaml
</span></span></code></pre></div><p>이제 조금 기다린 다음, 잡을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe jobs/job-wq-2
</span></span><span style=display:flex><span>Name:             job-wq-2
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Selector:         controller-uid<span style=color:#666>=</span>b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
</span></span><span style=display:flex><span>Labels:           controller-uid<span style=color:#666>=</span>b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
</span></span><span style=display:flex><span>                  job-name<span style=color:#666>=</span>job-wq-2
</span></span><span style=display:flex><span>Annotations:      &lt;none&gt;
</span></span><span style=display:flex><span>Parallelism:      <span style=color:#666>2</span>
</span></span><span style=display:flex><span>Completions:      &lt;unset&gt;
</span></span><span style=display:flex><span>Start Time:       Mon, <span style=color:#666>11</span> Jan <span style=color:#666>2016</span> 17:07:59 -0800
</span></span><span style=display:flex><span>Pods Statuses:    <span style=color:#666>1</span> Running / <span style=color:#666>0</span> Succeeded / <span style=color:#666>0</span> Failed
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:       controller-uid<span style=color:#666>=</span>b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
</span></span><span style=display:flex><span>                job-name<span style=color:#666>=</span>job-wq-2
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   c:
</span></span><span style=display:flex><span>    Image:              gcr.io/exampleproject/job-wq-2
</span></span><span style=display:flex><span>    Port:
</span></span><span style=display:flex><span>    Environment:        &lt;none&gt;
</span></span><span style=display:flex><span>    Mounts:             &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:              &lt;none&gt;
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message
</span></span><span style=display:flex><span>  ---------    --------    -----    ----            -------------    --------    ------            -------
</span></span><span style=display:flex><span>  33s          33s         <span style=color:#666>1</span>        <span style=color:#666>{</span>job-controller <span style=color:#666>}</span>                Normal      SuccessfulCreate  Created pod: job-wq-2-lglf8
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl logs pods/job-wq-2-7r7b2
</span></span><span style=display:flex><span>Worker with sessionID: bbd72d0a-9e5c-4dd6-abf6-416cc267991f
</span></span><span style=display:flex><span>Initial queue state: <span style=color:#b8860b>empty</span><span style=color:#666>=</span>False
</span></span><span style=display:flex><span>Working on banana
</span></span><span style=display:flex><span>Working on date
</span></span><span style=display:flex><span>Working on lemon
</span></span></code></pre></div><p>보시다시피, 사용자의 파드 중 하나가 여러 작업 단위에서 작업했다.</p><h2 id=대안>대안</h2><p>대기열 서비스를 실행하거나 작업 대기열을 사용하도록 컨테이너를 수정하는 것이 불편한 경우, 다른
<a href=/ko/docs/concepts/workloads/controllers/job/#%EC%9E%A1-%ED%8C%A8%ED%84%B4>잡 패턴</a>
중 하나를 고려할 수 있다.</p><p>만약 실행할 백그라운드 처리 작업의 연속 스트림이 있는 경우,
<code>ReplicaSet</code> 이 있는 백그라운드 워커를 실행하는 것과,
<a href=https://github.com/resque/resque>https://github.com/resque/resque</a>와 같은
백그라운드 처리 라이브러리를 실행하는 것이 좋다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9e63850014876afaebd1561f70bb8f6b>9.4 - 정적 작업 할당을 통한 병렬 처리를 위한 색인된 잡</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [stable]</code></div><p>이 예제에서는, 여러 병렬 워커(worker) 프로세스를 활용해 쿠버네티스 잡(Job)을
실행한다.
각 워커는 각 파드에서 실행되는 서로 다른 컨테이너다. 파드에는
컨트롤 플레인이 자동으로 설정한 <em>인덱스 번호</em> 가 부여되며, 이를 통해 각 파드는
전체 태스크 중 어느 부분을 수행해야 할 지 식별할 수 있다.</p><p>파드 인덱스는 10진수 값을 문자열로 표현한 <a class=glossary-tooltip title='임의의 식별되지 않는 메타데이터를 오브젝트에 첨부할 때 이용하는 키-밸류 쌍.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/annotations target=_blank aria-label=어노테이션>어노테이션</a>
<code>batch.kubernetes.io/job-completion-index</code> 를 통해
사용할 수 있다. 컨테이너화된 태스크 프로세스가 이 인덱스 정보를 가져갈 수 있도록,
<a href=/ko/docs/concepts/workloads/pods/downward-api/>다운워드(downward) API</a>
메커니즘을 사용하여 어노테이션의 값을 발행할 수 있다.
편의상, 컨트롤 플레인은 downward API를 자동 설정하여
<code>JOB_COMPLETION_INDEX</code> 환경변수에 인덱스를 노출할 수 있도록 한다.</p><p>이 예제에서의 단계에 대한 개요는 다음과 같다.</p><ol><li><strong>색인된 완료(indexed completion)를 사용하는 잡 매니페스트를 정의한다</strong>.
downward API를 통해 파드 인덱스 어노테이션을
환경변수 또는 파일의 형태로 컨테이너에 전달할 수 있다.</li><li><strong>해당 매니페스트를 바탕으로 색인된(<code>Indexed</code>) 잡을 시작한다</strong>.</li></ol><h2 id=시작하기-전에>시작하기 전에</h2><p>기본적이고, 병렬 작업이 아닌,
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a>의 사용법에 대해 잘 알고 있어야 한다.</p><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.21.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=접근-방법-선택하기>접근 방법 선택하기</h2><p>워커 프로그램에서 작업 항목에 접근하기 위한 몇 가지 선택지가 있다.</p><ol><li><code>JOB_COMPLETION_INDEX</code> 환경변수를 읽는다. 잡
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 는
이 환경변수를 완료 인덱스 정보를 갖고 있는 어노테이션에 자동
연결한다.</li><li>완료 인덱스 정보를 갖고 있는 파일을 읽는다.</li><li>프로그램을 수정할 수 없다면,
위 방법을 통해 인덱스를 읽고 프로그램의
입력값으로 사용 가능한 형태로 변환하는 스크립트로 감싸준다.</li></ol><p>예를 들어, 3번째 방법을 선택했으며
<a href=https://man7.org/linux/man-pages/man1/rev.1.html>rev</a> 유틸리티를 실행한다고 가정하면, 이
프로그램은 파일을 인자로 받아 그 내용을 거꾸로 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>rev data.txt
</span></span></code></pre></div><p><code>rev</code> 툴은
<a href=https://hub.docker.com/_/busybox><code>busybox</code></a> 컨테이너 이미지 내에서 실행할 것이다.</p><p>예제에 불과하므로, 각 파드는 아주 작은 작업(짧은 문자열 거꾸로 뒤집기)만을
수행한다. 실제 워크로드에서는 예를
들어
장면 정보를 바탕으로 60초 길이의 영상을 제작하는 태스크에 해당하는 잡을 생성할 수도 있다.
영상 렌더링 잡의 각 작업 항목은 영상 클립의 특정
프레임을 렌더링하는 것이다. 색인된 완료는 잡에 포함된 각 파드가
클립의 시작 지점부터 프레임 수를 세어 어느 프레임을 렌더링하고 발행해야 할 지
알고 있음을 의미한다.</p><h2 id=색인된-잡-정의하기>색인된 잡 정의하기</h2><p>다음은 색인된(<code>Indexed</code>) 완료 모드를 사용하는 잡 매니페스트의 예이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/indexed-job.yaml download=application/job/indexed-job.yaml><code>application/job/indexed-job.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-indexed-job-yaml")' title="Copy application/job/indexed-job.yaml to clipboard"></img></div><div class=includecode id=application-job-indexed-job-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;indexed-job&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completionMode</span>:<span style=color:#bbb> </span>Indexed<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;input&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/bash&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;bash&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          items=(foo bar baz qux xyz)
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt</span><span style=color:#bbb>          
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;worker&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/busybox&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;rev&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;/input/data.txt&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>위 예제에서, 잡 컨트롤러가 모든 컨테이너에 설정한 <code>JOB_COMPLETION_INDEX</code>
내장 환경 변수를 사용한다. <a href=/ko/docs/concepts/workloads/pods/init-containers/>초기화 컨테이너</a>는
인덱스를 정적 값으로 매핑하고 <a href=/ko/docs/concepts/storage/volumes/#emptydir>emptyDir 볼륨</a>을 통해
워커를 실행중인 컨테이너와 공유하는 파일에 쓴다.
선택적으로 컨테이너에 인덱스를 발행하기 위해 <a href=/ko/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>downward API를 통해
직접 환경 변수를 정의</a>할
수 있다. 또한 <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>환경변수 또는 파일로 된 컨피그맵(ConfigMap)</a>으로부터
값 목록을 불러올 수도 있다.</p><p>혹은 다음 예제와 같이 직접 <a href=/ko/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#%ED%8C%8C%EB%93%9C-%ED%95%84%EB%93%9C-%EC%A0%80%EC%9E%A5>downward API를 사용하여 어노테이션의 값을 볼륨 파일의 형태로 전달</a>할
수도 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/indexed-job-vol.yaml download=application/job/indexed-job-vol.yaml><code>application/job/indexed-job-vol.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-indexed-job-vol-yaml")' title="Copy application/job/indexed-job-vol.yaml to clipboard"></img></div><div class=includecode id=application-job-indexed-job-vol-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;indexed-job&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completionMode</span>:<span style=color:#bbb> </span>Indexed<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;worker&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/busybox&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;rev&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;/input/data.txt&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;data.txt&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.annotations[&#39;batch.kubernetes.io/job-completion-index&#39;]</span></span></code></pre></div></div></div><h2 id=잡-실행하기>잡 실행하기</h2><p>이제 잡을 실행하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 첫 번째 접근 방법을 사용한다. ($JOB_COMPLETION_INDEX 에 의존)</span>
</span></span><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/application/job/indexed-job.yaml
</span></span></code></pre></div><p>이 잡을 생성할 때, 컨트롤 플레인은 명시한 각 인덱스당 하나씩 일련의 파드를 생성한다. <code>.spec.parallelism</code>의 값은 한 번에 실행 가능한 수를 결정하는 반면 <code>.spec.completions</code>는 잡에서 총 생성되는 파드의 수를 결정한다.</p><p><code>.spec.parallelism</code>가 <code>.spec.completions</code>보다 작기 때문에, 컨트롤 플레인은 추가로 파드를 시작하기 전 최초 생성된 파드 중 일부가 완료되기를 기다린다.</p><p>잡을 생성했다면, 잠시 기다린 후 진행 상황을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe jobs/indexed-job
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>Name:              indexed-job
Namespace:         default
Selector:          controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
Labels:            controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
                   job-name=indexed-job
Annotations:       &lt;none&gt;
Parallelism:       3
Completions:       5
Start Time:        Thu, 11 Mar 2021 15:47:34 +0000
Pods Statuses:     2 Running / 3 Succeeded / 0 Failed
Completed Indexes: 0-2
Pod Template:
  Labels:  controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
           job-name=indexed-job
  Init Containers:
   input:
    Image:      docker.io/library/bash
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      bash
      -c
      items=(foo bar baz qux xyz)
      echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt

    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Containers:
   worker:
    Image:      docker.io/library/busybox
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      rev
      /input/data.txt
    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Volumes:
   input:
    Type:       EmptyDir (a temporary directory that shares a pod&#39;s lifetime)
    Medium:
    SizeLimit:  &lt;unset&gt;
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-njkjj
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-9kd4h
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-qjwsz
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-fdhq5
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-ncslj
</code></pre><p>이 예제에서는 각 인덱스에 직접 설정한 값을 갖는 잡을 실행한다. 파드
중 하나의 출력을 검사할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs indexed-job-fdhq5 <span style=color:#080;font-style:italic># 잡에 속한 파드의 이름에 맞춰 변경한다.</span>
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>xuq
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-da7c2b067953d239eb4457e8978ad8f6>9.5 - 확장을 사용한 병렬 처리</h1><p>이 태스크는 공통 템플릿을 기반으로 하는 여러 개의 <a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a>을
실행하는 것을 보여준다. 이 접근 방식을 사용하여 일괄 작업을 병렬로 처리할 수
있다.</p><p>이 예에는 <em>apple</em>, <em>banana</em> 그리고 <em>cherry</em> 세 항목만 있다.
샘플 잡들은 문자열을 출력한 다음 일시 정지하는 각 항목을 처리한다.</p><p>이 패턴이 보다 실질적인 유스케이스에 어떻게 부합하는지 알아 보려면
<a href=#%EC%8B%A4%EC%A0%9C-%EC%9B%8C%ED%81%AC%EB%A1%9C%EB%93%9C%EC%97%90%EC%84%9C-%EC%9E%A1-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>실제 워크로드에서 잡 사용하기</a>를 참고한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>사용자는 기본적인 내용과, 병렬 작업이 아닌
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a> 사용에 대해 익숙해야 한다.</p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>기본 템플릿을 사용하려면 커맨드 라인 유틸리티 <code>sed</code> 가 필요하다.</p><p>고급 템플릿 예제를 따라하려면, <a href=https://www.python.org/>파이썬(Python)</a>과
파이썬용 Jinja2 템플릿 라이브러리의 설치가
필요하다.</p><p>파이썬을 설정했으면, 다음을 실행하여 Jinja2를 설치할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pip install --user jinja2
</span></span></code></pre></div><h2 id=템플릿-기반의-잡-생성하기>템플릿 기반의 잡 생성하기</h2><p>먼저, 다음의 잡 템플릿을 다운로드해서 <code>job-tmpl.yaml</code> 파일로 저장한다.
다운로드할 내용은 다음과 같다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/job-tmpl.yaml download=application/job/job-tmpl.yaml><code>application/job/job-tmpl.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-job-tmpl-yaml")' title="Copy application/job/job-tmpl.yaml to clipboard"></img></div><div class=includecode id=application-job-job-tmpl-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>process-item-$ITEM<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>jobgroup</span>:<span style=color:#bbb> </span>jobexample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jobexample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>jobgroup</span>:<span style=color:#bbb> </span>jobexample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo Processing item $ITEM &amp;&amp; sleep 5&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># job-tmpl.yaml를 다운로드하기 위해 curl을 사용한다</span>
</span></span><span style=display:flex><span>curl -L -s -O https://k8s.io/examples/application/job/job-tmpl.yaml
</span></span></code></pre></div><p>다운로드한 파일은 아직 유효한 쿠버네티스
<a class=glossary-tooltip title='하나 이상의 쿠버네티스 API 오브젝트를 직렬화한 명세(specification).' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-manifest' target=_blank aria-label=매니페스트>매니페스트</a>가 아니다.
대신 해당 템플릿은 사용하기 전에 채워야하는 자리 표시자가 있는 잡 오브젝트의
YAML 표현이다. <code>$ITEM</code> 구문은 쿠버네티스에 의미가 있지 않다.</p><h3 id=템플릿에서-매니페스트-생성하기>템플릿에서 매니페스트 생성하기</h3><p>다음의 셸 스니펫은 <code>sed</code> 를 사용하여 루프 변수로 <code>$ITEM</code> 문자열을 바꾸고,
<code>jobs</code> 라는 임시 디렉터리에 기록한다. 다음과 같이 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 처리할 각 항목에 대해 하나씩, 템플릿을 여러 파일로 확장한다.</span>
</span></span><span style=display:flex><span>mkdir ./jobs
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in apple banana cherry
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>  cat job-tmpl.yaml | sed <span style=color:#b44>&#34;s/\$ITEM/</span><span style=color:#b8860b>$i</span><span style=color:#b44>/&#34;</span> &gt; ./jobs/job-<span style=color:#b8860b>$i</span>.yaml
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><p>작동하는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls jobs/
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>job-apple.yaml
job-banana.yaml
job-cherry.yaml
</code></pre><p>모든 유형의 템플릿 언어(예를 들어, Jinja2, ERB)를 사용하거나,
프로그램을 작성하여 잡 매니페스트를 생성할 수 있다.</p><h3 id=매니페스트에서-잡-생성하기>매니페스트에서 잡 생성하기</h3><p>다음으로, 하나의 kubectl 명령으로 모든 잡을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./jobs
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>job.batch/process-item-apple created
job.batch/process-item-banana created
job.batch/process-item-cherry created
</code></pre><p>이제, 작업을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get <span style=color:#a2f>jobs</span> -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME                  COMPLETIONS   DURATION   AGE
process-item-apple    1/1           14s        22s
process-item-banana   1/1           12s        21s
process-item-cherry   1/1           12s        20s
</code></pre><p>kubectl 명령에 <code>-l</code> 옵션을 사용하면 이 잡 그룹의
일부인 잡만 선택된다(시스템에서 관련이 없는 다른 잡이 있을 수 있음).</p><p>파드도 동일한 <a class=glossary-tooltip title='사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label='레이블 셀렉터'>레이블 셀렉터</a>를
사용하여 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME                        READY     STATUS      RESTARTS   AGE
process-item-apple-kixwv    0/1       Completed   0          4m
process-item-banana-wrsf7   0/1       Completed   0          4m
process-item-cherry-dnfu9   0/1       Completed   0          4m
</code></pre><p>이 단일 명령을 사용하여 모든 잡의 출력을 한 번에 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs -f -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</span></span></code></pre></div><p>출력 결과는 다음과 같아야 한다.</p><pre tabindex=0><code>Processing item apple
Processing item banana
Processing item cherry
</code></pre><h3 id=cleanup-1>정리</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 생성한 잡 제거</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 클러스터가 자동으로 잡의 파드들을 정리</span>
</span></span><span style=display:flex><span>kubectl delete job -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</span></span></code></pre></div><h2 id=고급-템플릿-파라미터-사용하기>고급 템플릿 파라미터 사용하기</h2><p><a href=#%ED%85%9C%ED%94%8C%EB%A6%BF-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%A1-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0>첫 번째 예제</a>에서, 템플릿의 각 인스턴스는 하나의
파라미터를 가지고, 해당 파라미터는 잡의 이름에도 사용되었다. 그러나,
<a href=/ko/docs/concepts/overview/working-with-objects/names/#names>이름</a>은
특정 문자들만 포함하도록 제한된다.</p><p>이런 약간 더 복잡한 예제는 <a href=https://palletsprojects.com/p/jinja/>Jinja 템플릿 언어</a>를
사용하여 각 잡에 대한 여러 파라미터로 매니페스트를 생성한 다음
해당 매니페스트에서 오브젝트를 생성한다.</p><p>태스크의 이 부분에서는, 한줄 파이썬 스크립트를 사용하여
매니페스트 집합으로 템플릿을 변환한다.</p><p>먼저, 다음의 잡 오브젝트 템플릿을 복사하고 붙여넣기하여, <code>job.yaml.jinja2</code> 파일로 저장한다.</p><pre tabindex=0><code class=language-liquid data-lang=liquid>{% set params = [{ &#34;name&#34;: &#34;apple&#34;, &#34;url&#34;: &#34;http://dbpedia.org/resource/Apple&#34;, },
                  { &#34;name&#34;: &#34;banana&#34;, &#34;url&#34;: &#34;http://dbpedia.org/resource/Banana&#34;, },
                  { &#34;name&#34;: &#34;cherry&#34;, &#34;url&#34;: &#34;http://dbpedia.org/resource/Cherry&#34; }]
%}
{% for p in params %}
{% set name = p[&#34;name&#34;] %}
{% set url = p[&#34;url&#34;] %}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: jobexample-{{ name }}
  labels:
    jobgroup: jobexample
spec:
  template:
    metadata:
      name: jobexample
      labels:
        jobgroup: jobexample
    spec:
      containers:
      - name: c
        image: busybox:1.28
        command: [&#34;sh&#34;, &#34;-c&#34;, &#34;echo Processing URL {{ url }} &amp;&amp; sleep 5&#34;]
      restartPolicy: Never
{% endfor %}
</code></pre><p>위의 템플릿은 파이썬 딕셔너리(dicts)로 구성된 항목(1-4행)을 사용하여 각 잡 오브젝트에 대해
두 개의 파라미터를 정의한다. <code>for</code> 루프는 각 파라미터의 집합(나머지 행)에 대해
하나의 잡 매니페스트를 방출한다.</p><p>이 예제는 YAML의 기능에 의존한다. 하나의 YAML 파일은 여러
문서(이 경우, 쿠버네티스 매니페스트)를 포함할 수 있으며, 행에 있는 <code>---</code> 로
구분된다.
출력 결과를 <code>kubectl</code> 에 직접 파이프를 사용해 잡을 생성할 수 있다.</p><p>다음으로, 이 한 줄 파이썬 프로그램을 사용하여 템플릿을 확장한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>render_template</span><span style=color:#666>=</span><span style=color:#b44>&#39;python -c &#34;from jinja2 import Template; import sys; print(Template(sys.stdin.read()).render());&#34;&#39;</span>
</span></span></code></pre></div><p><code>render_template</code> 을 사용해서 파라미터와 템플릿을 쿠버네티스 매니페스트가
포함된 하나의 YAML 파일로 변환한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 앞에서 정의한 앨리어스(alias)가 필요하다</span>
</span></span><span style=display:flex><span>cat job.yaml.jinja2 | render_template &gt; jobs.yaml
</span></span></code></pre></div><p><code>render_template</code> 스크립트가 제대로 동작하는지 확인하기 위해 <code>jobs.yaml</code> 을
볼 수 있다.</p><p><code>render_template</code> 스크립트가 원하는대로 동작하는 것을 확인했다면,
스크립트의 출력 결과를 파이프를 사용하여 <code>kubectl</code> 에 보낼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat job.yaml.jinja2 | render_template | kubectl apply -f -
</span></span></code></pre></div><p>쿠버네티스는 생성한 잡을 수락하고 실행한다.</p><h3 id=cleanup-2>정리</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 생성한 잡 제거</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 클러스터가 자동으로 잡이 있던 파드를 정리</span>
</span></span><span style=display:flex><span>kubectl delete job -l <span style=color:#b8860b>jobgroup</span><span style=color:#666>=</span>jobexample
</span></span></code></pre></div><h2 id=실제-워크로드에서-잡-사용하기>실제 워크로드에서 잡 사용하기</h2><p>실제 유스케이스에서, 각 잡은 동영상의 프레임을 렌더링하거나, 데이터베이스에서 행 범위를
처리하는 것과 같은 상당한 규모의 계산을 수행한다. 동영상을 렌더링하는 경우 프레임 번호에
<code>$ITEM</code> 을 설정한다. 데이터베이스에서 행을 처리하는
경우, 처리할 데이터베이스 행의 범위를 나타내도록 <code>$ITEM</code> 을 설정한다.</p><p>이번 태스크에서, 로그를 가져와 파드에서 출력 결과를 수집하는 명령어를
실행했다. 실제 유스케이스에서, 잡의 각 파드는 완료하기 전에 출력 결과를
내구성있는 스토리지에 기록한다. 각 잡에 대해 퍼시스턴트볼륨(PersistentVolume)을
사용하거나 외장 스토리지 서비스를 사용할 수 있다. 예를 들어, 동영상의 프레임을 렌더링하는 경우,
HTTP를 사용하여 렌더링된 프레임 데이터를 각 프레임에 대한 다른 URL을 사용해서 URL에 <code>PUT</code>
한다.</p><h2 id=잡과-파드의-레이블>잡과 파드의 레이블</h2><p>잡을 생성한 후, 쿠버네티스는 한 잡의 파드를 다른 잡의 파드와 구별하기 위해서
추가 <a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>을
자동으로 추가한다.</p><p>이 예시에서, 각 잡과 잡의 파드 템플릿은 <code>jobgroup=jobexample</code>
레이블을 갖는다.</p><p>쿠버네티스 자체는 <code>jobgroup</code> 이라는 레이블에 신경쓰지 않는다. 템플릿에서
생성한 모든 잡에 대해 레이블을 설정하면 한번에 모든 잡을 편리하게
조작할 수 있다.
<a href=#%ED%85%9C%ED%94%8C%EB%A6%BF-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%9E%A1-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0>첫 번째 예제</a>에서 템플릿을 사용해서
여러 잡을 생성했다. 템플릿은 각 파드도 동일한 레이블을 가질 수 있도록 보장하므로,
단일 명령어로 이러한 템플릿 기반 잡들의 모든 파드에서 확인할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 레이블 키 <code>jobgroup</code> 은 특별하거나 예약되어 있지 않다.
고유한 레이블링 체계를 선택할 수 있다.
원하는 경우 사용할 수 있는
<a href=/ko/docs/concepts/overview/working-with-objects/common-labels/#%EB%A0%88%EC%9D%B4%EB%B8%94>권장 레이블</a>이 있다.</div><h2 id=대안>대안</h2><p>많은 수의 잡 오브젝트의 생성을 계획 중이라면, 아마도 다음의 사항을 파악하게 될 것이다.</p><ul><li>레이블을 사용해도, 너무 많은 잡을 관리하는 것은 번거롭다.</li><li>일괄적으로 많은 잡을 생성하는 경우, 쿠버네티스 컨트롤 플레인에
높음 부하를 가할 수 있다. 대안으로, 쿠버네티스 API 서버가
속도를 제한하여 429 상태의 사용자 요청을 일시적으로 거부할 수 있다.</li><li>사용자는 잡의 <a class=glossary-tooltip title='네임스페이스당 전체 리소스 소비를 제한하는 제약을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/resource-quotas/ target=_blank aria-label='리소스 쿼터'>리소스 쿼터</a>로
제한될 수 있다. 한번에 많은 작업을 생성하면 API 서버가 사용자의 요청 중
일부를 영구적으로 거부한다.</li></ul><p>아주 많은 잡 오브젝트를 생성하지 않고 많은 양의 작업을 처리하는데 사용할 수 있는
다른 <a href=/ko/docs/concepts/workloads/controllers/job/#%EC%9E%A1-%ED%8C%A8%ED%84%B4>잡 패턴</a>도
있다.</p><p>잡 오브젝트를 자동으로 관리하기 위해 자체 <a href=/ko/docs/concepts/architecture/controller/>컨트롤러</a>를
작성하는 것도 고려할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b74b959f5a531003dd0653dfbfc2e88b>10 - 클러스터 내 어플리케이션 접근</h1><div class=lead>클러스터의 애플리케이션에 접근하기 위해 로드 밸런싱, 포트 포워딩, 방화벽 설정 또는 DNS 구성을 설정한다.</div></div><div class=td-content><h1 id=pg-777447042cd4e81df3fa5beb3357a485>10.1 - 쿠버네티스 대시보드를 배포하고 접속하기</h1><div class=lead>웹 UI(쿠버네티스 대시보드)를 배포하고 접속한다.</div><p>대시보드는 웹 기반 쿠버네티스 유저 인터페이스이다.
대시보드를 통해 컨테이너화 된 애플리케이션을 쿠버네티스 클러스터에 배포할 수 있고,
컨테이너화 된 애플리케이션을 트러블슈팅할 수 있으며, 클러스터 리소스들을 관리할 수 있다.
대시보드를 통해 클러스터에서 동작 중인 애플리케이션의 정보를 볼 수 있고,
개별적인 쿠버네티스 리소스들을(예를 들면 디플로이먼트, 잡, 데몬셋 등)
생성하거나 수정할 수 있다.
예를 들면, 디플로이먼트를 스케일하거나, 롤링 업데이트를 초기화하거나, 파드를 재시작하거나
또는 배포 마법사를 이용해 새로운 애플리케이션을 배포할 수 있다.</p><p>또한 대시보드는 클러스터 내 쿠버네티스 리소스들의 상태와 발생하는 모든 에러 정보를 제공한다.</p><p><img src=/images/docs/ui-dashboard.png alt="Kubernetes Dashboard UI"></p><h2 id=대시보드-ui-배포>대시보드 UI 배포</h2><p>대시보드 UI는 기본으로 배포되지 않는다. 배포하려면 다음 커맨드를 실행한다.</p><pre tabindex=0><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml
</code></pre><h2 id=대시보드-ui-접근>대시보드 UI 접근</h2><p>클러스터 데이터를 보호하기 위해, 대시보드는 기본적으로 최소한의 RBAC 설정을 제공한다.
현재, 대시보드는 Bearer 토큰으로 로그인하는 방법을 제공한다.
본 시연을 위한 토큰을 생성하기 위해서는,
<a href=https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md>샘플 사용자 만들기</a> 가이드를 따른다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 시연 중 생성한 샘플의 사용자에게는 관리자(admin) 권한이 부여되며, 이는 교육 목적으로만 사용한다.</div><h3 id=커맨드-라인-프록시>커맨드 라인 프록시</h3><p><code>kubectl</code> 커맨드라인 도구를 이용해 다음 커맨드를 실행함으로써 대시보드로의
접속을 활성화할 수 있다.</p><pre tabindex=0><code>kubectl proxy
</code></pre><p>kubectl은 <a href=http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a>를 통해 대시보드에 접속할 수 있게 해줄 것이다.</p><p>UI는 <em>오직</em> 커맨드가 실행된 머신에서만 접근 가능하다. 상세 내용은 <code>kubectl proxy --help</code> 옵션을 확인한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> Kubeconfig 인증 방법은 외부 아이덴티티 프로바이더
또는 X.509 인증서를 <strong>지원하지 않는다</strong>.</div><h2 id=웰컴-뷰>웰컴 뷰</h2><p>초기 클러스터 대시보드에 접근하면, 환영 페이지를 볼 수 있다.
이 페이지는 첫 애플리케이션을 배포하는 버튼이 있을 뿐만 아니라, 이 문서의 링크를 포함하고 있다.
게다가, 대시보드가 있는 클러스터에서 기본적으로 <code>kube-system</code>
<a href=/ko/docs/tasks/administer-cluster/namespaces/>네임스페이스</a>이 동작중인 시스템 애플리케이션을 볼 수 있다.</p><p><img src=/images/docs/ui-dashboard-zerostate.png alt="Kubernetes Dashboard welcome page"></p><h2 id=컨테이너화-된-애플리케이션-배포>컨테이너화 된 애플리케이션 배포</h2><p>대시보드를 이용하여 컨테이너화 된 애플리케이션을 디플로이먼트와 간단한 마법사를 통한 선택적인 서비스로 생성하고 배포할 수 있다.
애플리케이션 세부 정보를 수동으로 지정할 수 있고, 또는 애플리케이션 구성을 포함한 YAML 또는 JSON <em>매니페스트(manifest)</em> 파일을 업로드할 수 있다.</p><p>시작하는 페이지의 상위 오른쪽 코너에 있는 <strong>CREATE</strong> 버튼을 클릭한다.</p><h3 id=애플리케이션-세부-정보-지정>애플리케이션 세부 정보 지정</h3><p>배포 마법사는 다음 정보를 제공한다.</p><ul><li><p><strong>앱 이름</strong> (필수): 애플리케이션 이름.
<a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a> 이름은
배포할 모든 디플로이먼트와 서비스에 추가되어야 한다.</p><p>애플리케이션 이름은 선택된 쿠버네티스 <a href=/ko/docs/tasks/administer-cluster/namespaces/>네임스페이스</a> 안에서 유일해야 한다.
소문자로 시작해야 하며, 소문자 또는 숫자로 끝나고,
소문자, 숫자 및 대쉬(-)만을 포함해야 한다. 24 문자만을 제한한다.
처음과 끝의 스페이스는 무시된다.</p></li><li><p><strong>컨테이너 이미지</strong> (필수):
레지스트리에 올라간 퍼블릭 도커 <a href=/ko/docs/concepts/containers/images/>컨테이너 이미지</a>
또는 프라이빗 이미지(대체로 Google Container Registry 또는 도커 허브에 올라간)의 URL.
컨테이너 이미지 사양은 콜론으로 끝난다.</p></li><li><p><strong>파드의 수</strong> (필수): 배포하고 싶은 애플리케이션의 원하는 목표 파드 개수.
값은 양의 정수만 허용됩니다.</p><p>클러스터에 의도한 파드의 수를 유지하기 위해서
<a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>가 생성될 것이다.</p></li><li><p><strong>서비스</strong> (선택): 일부 애플리케이션의 경우, (예를 들어, 프론트엔드) 아마도 클러스터 바깥의
퍼블릭 IP 주소를 가진 (외부 서비스) 외부에 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>를
노출시키고 싶을 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 외부 서비스들을 위해, 한 개 또는 여러 개의 포트를 열어 둘 필요가 있다.</div><p>클러스터 내부에서만 보고 싶은 어떤 서비스들이 있을 것이다. 이를 내부 서비스라고 한다.</p><p>서비스 타입과는 무관하게, 서비스 생성을 선택해서 컨테이너의 (들어오는 패킷의) 포트를 리슨한다면,
두 개의 포트를 정의해야 한다.
서비스는 컨테이너가 바라보는 타겟 포트와 (들어오는 패킷의) 맵핑하는 포트가 만들어져야 할 것이다.
서비스는 배포된 파드에 라우팅 될 것이다. 지원하는 프로토콜은 TCP와 UDP이다.
서비스가 이용하는 내부 DNS 이름은 애플리케이션 이름으로 지정한 값이 될 것이다.</p></li></ul><p>만약 필요하다면, 더 많은 세팅을 지정할 수 있는 <strong>자세한 옵션 보기</strong> 섹션에서 확장할 수 있다.</p><ul><li><p><strong>설명</strong>: 입력하는 텍스트값은 디플로이먼트에
<a href=/ko/docs/concepts/overview/working-with-objects/annotations/>어노테이션</a>으로
추가될 것이고, 애플리케이션의 세부사항에 표시될 것이다.</p></li><li><p><strong>레이블</strong>: 애플리케이션에 사용되는 기본적인 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>은
애플리케이션 이름과 버전이다.
릴리스, 환경, 티어, 파티션, 그리고 릴리스 트랙과 같은 레이블을 디플로이먼트, 서비스, 그리고 파드를
생성할 때 추가적으로 정의할 수 있다.</p><p>예를 들면:</p><pre tabindex=0><code class=language-conf data-lang=conf>release=1.0
tier=frontend
environment=pod
track=stable
</code></pre></li><li><p><strong>네임스페이스</strong>: 쿠버네티스는 동일한 물리 클러스터를 바탕으로 여러 가상의 클러스터를 제공한다.
이러한 가상 클러스터들을 <a href=/ko/docs/tasks/administer-cluster/namespaces/>네임스페이스</a>라고 부른다.
논리적으로 명명된 그룹으로 리소스들을 분할할 수 있다.</p><p>대시보드는 드롭다운 리스트로 가능한 모든 네임스페이스를 제공하고, 새로운 네임스페이스를 생성할 수 있도록 한다.
네임스페이스 이름은 최대 63개의 영숫자 단어와 대시(-)를 포함하고 있지만 대문자를 가지지 못한다.
네임스페이스 이름은 숫자로만 구성할 수 없다.
만약 이름을 10이라는 숫자로 세팅한다면, 파드는 기본 네임스페이스로 배정하게 될 것이다.</p><p>네임스페이스 생성이 성공하는 경우, 생성된 네임스페이스가 기본으로 선택된다.
만약 생성에 실패하면, 첫 번째 네임스페이스가 선택된다.</p></li><li><p><strong>이미지 풀(Pull) 시크릿</strong>:
특정 도커 컨테이너 이미지가 프라이빗한 경우,
<a href=/ko/docs/concepts/configuration/secret/>풀(Pull) 시크릿</a> 자격 증명을 요구한다.</p><p>대시보드는 가능한 모든 시크릿을 드롭다운 리스트로 제공하며, 새로운 시크릿을 생성할 수 있도록 한다.
시크릿 이름은 예를 들어 <code>new.image-pull.secret</code> 과 같이 DNS 도메인 이름 구문으로 따르기로 한다.
시크릿 내용은 base64 인코딩 방식이며,
<a href=/ko/docs/concepts/containers/images/#%ED%8C%8C%EB%93%9C%EC%97%90-imagepullsecrets-%EB%AA%85%EC%8B%9C><code>.dockercfg</code></a> 파일로 정의된다.
시크릿 이름은 최대 253 문자를 포함할 수 있다.</p><p>이미지 풀(Pull) 시크릿의 생성이 성공한 경우, 기본으로 선택된다. 만약 생성에 실패하면, 시크릿은 허용되지 않는다.</p></li><li><p><strong>CPU 요구 사항 (cores)</strong> 와 <strong>메모리 요구 사항 (MiB)</strong>:
컨테이너를 위한 최소 <a href=/ko/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>리소스 상한</a>을
정의할 수 있다. 기본적으로, 파드는 CPU와 메모리 상한을 두지 않고 동작한다.</p></li><li><p><strong>커맨드 실행</strong> 와 <strong>커맨드 인수 실행</strong>:
기본적으로, 컨테이너는 선택된 도커 이미지의
<a href=/ko/docs/tasks/inject-data-application/define-command-argument-container/>기본 엔트리포인트 커맨드</a>를 실행한다.
커맨드 옵션과 인자를 기본 옵션에 우선 적용하여 사용할 수 있다.</p></li><li><p><strong>특권을 가진(privileged) 상태로 실행</strong>: 다음 세팅은 호스트에서 루트 권한을 가진 프로세스들이
<a href=/ko/docs/concepts/workloads/pods/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90-%EB%8C%80%ED%95%9C-%ED%8A%B9%EA%B6%8C-%EB%AA%A8%EB%93%9C>특권을 가진 컨테이너</a>의
프로세스들과 동등한지 아닌지 정의한다.
특권을 가진(privileged) 컨테이너는 네트워크 스택과 디바이스에 접근하는 것을 조작하도록 활용할 수 있다.</p></li><li><p><strong>환경 변수</strong>: 쿠버네티스 서비스를
<a href=/ko/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>환경 변수</a>를 통해 노출한다.
환경 변수 또는 인자를 환경 변수들의 값으로 커맨드를 통해 구성할 수 있다.
애플리케이션들이 서비스를 찾는데 사용된다.
값들은 <code>$(VAR_NAME)</code> 구문을 사용하는 다른 변수들로 참조할 수 있다.</p></li></ul><h3 id=yaml-또는-json-파일-업로드>YAML 또는 JSON 파일 업로드</h3><p>쿠버네티스는 선언적인 설정을 제공한다.
이 방식에서는 모든 설정이 매니페스트(YAML 또는 JSON 설정 파일)에 저장된다.
매니페스트는 쿠버네티스 <a href=/ko/docs/concepts/overview/kubernetes-api/>API</a> 리소스 스키마를
사용한다.</p><p>배포 마법사를 통해 애플리케이션 세부 사항들을 지정하는 대신, 애플리케이션을 하나 이상의 매니페스트로 정의할 수 있고 대시보드를 이용해서 파일을 업로드할 수 있다.</p><h2 id=대시보드-사용>대시보드 사용</h2><p>다음 섹션들은 어떻게 제공하고 어떻게 사용할 수 있는지에 대한 쿠버네티스 대시보드 UI의 모습을 보여준다.</p><h3 id=탐색>탐색</h3><p>클러스터에 정의된 쿠버네티스 오프젝트가 있으면, 대시보드는 초기화된 뷰를 제공한다.
기본적으로 <em>기본</em> 네임스페이스의 오프젝트만이 보이는데,
이는 탐색 창에 위치한 네임스페이스 셀렉터를 이용해 변경할 수 있다.</p><p>대시보드는 몇 가지 메뉴 카테고리 중에서 대부분의 쿠버네티스 오브젝트 종류와 그룹을 보여준다.</p><h4 id=어드민-개요>어드민 개요</h4><p>클러스터와 네임스페이스 관리자에게 대시보드는 노드, 네임스페이스 그리고 퍼시스턴트 볼륨과 세부사항들이 보여진다.
노드는 모든 노드를 통틀어 CPU와 메모리 사용량을 보여준다.
세부사항은 각 노드들에 대한 사용량, 사양, 상태,
할당된 리소스, 이벤트 그리고 노드에서 돌아가는 파드를 보여준다.</p><h4 id=워크로드>워크로드</h4><p>선택된 네임스페이스에서 구동되는 모든 애플리케이션을 보여준다.
해당 뷰는 애플리케이션의 워크로드 종류(예시: 디플로이먼트, 레플리카셋(ReplicaSet), 스테이트풀셋(StatefulSet))를 보여준다.
각각의 워크로드 종류는 분리하여 볼 수 있다.
리스트는 예를 들어 레플리카셋에서 준비된 파드의 숫자 또는 파드의 현재 메모리 사용량과 같은
워크로드에 대한 실용적인 정보를 요약한다.</p><p>워크로드에 대한 세부적인 것들은 상태와 사양 정보,
오프젝트들 간의 관계를 보여준다.
예를 들어, 레플리카셋으로 관리하는 파드들 또는 새로운 레플리카셋과 디플로이먼트를 위한 Horizontal Pod Autoscalers 이다.</p><h4 id=서비스>서비스</h4><p>외부로 노출되는 서비스들과 클러스터 내에 발견되는 서비스들을 허용하는
쿠버네티스 리소스들을 보여준다.
이러한 이유로 서비스와 인그레스는 클러스터간의 연결을 위한 내부 엔드포인트들과
외부 사용자를 위한 외부 엔드포인트들에 의해 타게팅된 파드들을 보여준다.</p><h4 id=스토리지>스토리지</h4><p>스토리지는 애플리케이션이 데이터를 저장하기 위해 사용하는 퍼시턴트볼륨클레임 리소스들을 보여준다.</p><h4 id=config-maps-and-secrets>컨피그맵과 시크릿</h4><p>클러스터에서 동작 중인 애플리케이션의 라이브 설정을 사용하는 모든 쿠버네티스 리소스들을 보여준다.
컨피그 오브젝트들을 수정하고 관리할 수 있도록 허용하며, 기본적으로는 숨겨져 있는 시크릿들을 보여준다.</p><h4 id=로그-뷰어>로그 뷰어</h4><p>파드 목록과 세부사항 페이지들은 대시보드에 구현된 로그 뷰어에 링크된다.
뷰어는 단일 파드에 있는 컨테이너들의 로그들을 내려가면 볼 수 있도록 한다.</p><p><img src=/images/docs/ui-dashboard-logs-view.png alt="Logs viewer"></p><h2 id=다음-내용>다음 내용</h2><p>더 많은 정보는
<a href=https://github.com/kubernetes/dashboard>쿠버네티스 대시보드 프로젝트 페이지</a>를 참고한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6a8d9e9e05f2b6825afbb8889c957370>10.2 - 클러스터 접근</h1><p>여기에서는 클러스터와 통신을 하는 다양한 방식에 대해서 다룰 것이다.</p><h2 id=처음이라면-kubectl을-사용하여-접근>처음이라면 kubectl을 사용하여 접근</h2><p>최초로 쿠버네티스 API에 접근할 때 우리는
쿠버네티스 CLI인 <code>kubectl</code>을 사용하는 것을 추천한다.</p><p>클러스터에 접근하려면 클러스터의 위치정보를 알아야 하고 클러스터에 접속하기 위한
인증정보를 가져야 한다. 일반적으로 이는 당신이
<a href=/ko/docs/setup/>Getting started guide</a>를 다 진행했을 때 자동으로 구성되거나,
다른 사람이 클러스터를 구성하고 당신에게 인증정보와 위치정보를 제공할 수도 있다.</p><p>kubectl이 인지하는 위치정보와 인증정보는 다음 커맨드로 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p><a href=/ko/docs/reference/kubectl/cheatsheet/>여기</a>에서
<code>kubectl</code> 사용 예시를 볼 수 있으며, 완전한 문서는
<a href=/ko/docs/reference/kubectl/>kubectl 레퍼런스</a>에서 확인할 수 있다.</p><h2 id=rest-api에-직접-접근>REST API에 직접 접근</h2><p>kubectl은 apiserver의 위치 파악과 인증을 처리한다.
만약 당신이 curl, wget 또는 웹브라우저와 같은 http 클라이언트로
REST API에 직접 접근하려고 한다면 위치 파악과 인증을 하는 몇 가지 방법이 존재한다.</p><ul><li>kubectl을 proxy 모드로 실행.<ul><li>권장하는 접근 방식.</li><li>저장된 apiserver 위치를 사용.</li><li>self-signed 인증서를 사용하여 apiserver의 identity를 검증. MITM은 불가능.</li><li>apiserver 인증.</li><li>앞으로는 클라이언트 측의 지능형 load balancing과 failover가 될 것이다.</li></ul></li><li>직접적으로 http 클라이언트에 위치정보와 인증정보를 제공.<ul><li>대안적인 접근 방식.</li><li>proxy 사용과 혼동되는 몇 가지 타입의 클라이언트 코드와 같이 동작한다.</li><li>MITM로부터 보호를 위해 root 인증서를 당신의 브라우저로 임포트해야 한다.</li></ul></li></ul><h3 id=kubectl-proxy-사용>kubectl proxy 사용</h3><p>다음 커맨드는 kubectl을 리버스 프록시(reverse proxy)처럼 동작하는 모드를 실행한다. 이는
apiserver의 위치지정과 인증을 처리한다.
다음과 같이 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>상세 내용은 <a href=/docs/reference/generated/kubectl/kubectl-commands/#proxy>kubectl proxy</a>를 참조한다</p><p>이후에 당신은 curl, wget, 웹브라우저로 다음과 같이 API를 탐색할 수 있다. localhost는
IPv6 주소 [::1]로도 대체할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://localhost:8080/api/
</span></span></code></pre></div><p>결괏값은 다음과 같을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=kubectl-proxy를-사용하지-않음>kubectl proxy를 사용하지 않음</h3><p><code>kubectl apply</code> 및 <code>kubectl describe secret...</code> 명령과 grep/cut을 활용하여 기본 서비스 어카운트의 토큰을 생성한다.</p><p>먼저, 기본 서비스어카운트를 위한 토큰을 요청하는 시크릿을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: default-token
</span></span></span><span style=display:flex><span><span style=color:#b44>  annotations:
</span></span></span><span style=display:flex><span><span style=color:#b44>    kubernetes.io/service-account.name: default
</span></span></span><span style=display:flex><span><span style=color:#b44>type: kubernetes.io/service-account-token
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>다음으로, 토큰 컨트롤러가 해당 시크릿에 토큰을 채우기를 기다린다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>while</span> ! kubectl describe secret default-token | grep -E <span style=color:#b44>&#39;^token&#39;</span> &gt;/dev/null; <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;waiting for token...&#34;</span> &gt;&amp;<span style=color:#666>2</span>
</span></span><span style=display:flex><span>  sleep <span style=color:#666>1</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><p>결과를 캡처하여 생성된 토큰을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view --minify | grep server | cut -f 2- -d <span style=color:#b44>&#34;:&#34;</span> | tr -d <span style=color:#b44>&#34; &#34;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl describe secret default-token | grep -E <span style=color:#b44>&#39;^token&#39;</span> | cut -f2 -d<span style=color:#b44>&#39;:&#39;</span> | tr -d <span style=color:#b44>&#34; &#34;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>curl <span style=color:#b8860b>$APISERVER</span>/api --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b8860b>$TOKEN</span><span style=color:#b44>&#34;</span> --insecure
</span></span></code></pre></div><p>결과값은 다음과 같을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>jsonpath</code>를 사용한다면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view --minify -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.clusters[0].cluster.server}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get secret default-token -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.token}&#39;</span> | base64 --decode<span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>curl <span style=color:#b8860b>$APISERVER</span>/api --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b8860b>$TOKEN</span><span style=color:#b44>&#34;</span> --insecure
</span></span></code></pre></div><p>결과값은 다음과 같을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위 예제에서는 <code>--insecure</code> flag를 사용했다. 이는 MITM 공격을 받을 수 있는 상태로
두는 것이다. kubectl로 클러스터에 접속할 때 저장된 root 인증서와 클라이언트 인증서들을
서버 접속에 사용한다.
(이들은 <code>~/.kube</code> 디렉터리에 설치된다.)
일반적으로 self-signed 인증서가 클러스터 인증서로 사용되므로 당신의 http 클라이언트가
root 인증서를 사용하려면 특수한 설정을 필요로 할 것이다.</p><p>localhost에서 제공되거나 방화벽으로 보호되는 몇몇 클러스터들에서는 apiserver가 인증을
요구하지 않지만 이는 표준이 아니다.
<a href=/ko/docs/concepts/security/controlling-access>API에 대한 접근 제어</a>은
클러스터 관리자가 이를 어떻게 구성할 수 있는지를 설명한다.</p><h2 id=api에-프로그래밍-방식으로-접근>API에 프로그래밍 방식으로 접근</h2><p>쿠버네티스는 공식적으로 <a href=#go-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8>Go</a>와 <a href=#python-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8>Python</a>
클라이언트 라이브러리를 지원한다.</p><h3 id=go-클라이언트>Go 클라이언트</h3><ul><li>라이브러리를 취득하려면 <code>go get k8s.io/client-go@kubernetes-&lt;kubernetes-version-number></code> 커맨드를 실행한다. <a href=https://github.com/kubernetes/client-go/blob/master/INSTALL.md#for-the-casual-user>INSTALL.md</a>에서 상세한 설치 방법을 알 수 있다. <a href=https://github.com/kubernetes/client-go#compatibility-matrix>https://github.com/kubernetes/client-go</a>에서 어떤 버젼이 지원되는지 확인할 수 있다.</li><li>client-go 클라이언트 위에 애플리케이션을 작성하자. client-go는 자체적으로 API 오브젝트를 정의하므로 필요하다면 main 레포지터리보다는 client-go에서 API 정의들을 import하기를 바란다. 정확하게 <code>import "k8s.io/client-go/kubernetes"</code>로 import하는 것을 예로 들 수 있다.</li></ul><p>Go 클라이언트는 apiserver의 위치지정과 인증에 kubectl CLI와 동일하게 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig file</a>을 사용할 수 있다.
<a href=https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go>예제</a>를 참고한다.</p><p>만약 애플리케이션이 클러스터 내에 파드로 배포되었다면 <a href=#%ED%8C%8C%EB%93%9C%EC%97%90%EC%84%9C-api-%EC%A0%91%EA%B7%BC>다음 장</a>을 참조하기를 바란다.</p><h3 id=python-클라이언트>Python 클라이언트</h3><p>Python 클라이언트를 사용하려면 <code>pip install kubernetes</code> 커맨드를 실행한다. 설치 옵션에 대한 상세 사항은 <a href=https://github.com/kubernetes-client/python>Python Client Library page</a>를 참조한다.</p><p>Python 클라이언트는 apiserver의 위치지정과 인증에 kubectl CLI와 동일하게 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig file</a>을 사용할 수 있다.
<a href=https://github.com/kubernetes-client/python/tree/master/examples>예제</a>를 참조한다.</p><h3 id=다른-언어>다른 언어</h3><p>다른 언어에서 API를 접속하기 위한 <a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리들</a>도 존재한다.
이들이 어떻게 인증하는지는 다른 라이브러리들의 문서를 참조한다.</p><h2 id=파드에서-api-접근>파드에서 API 접근</h2><p>파드에서 API에 접근하는 경우,
API 서버를 찾고 인증하는 방식이 약간 다를 수 있다.</p><p>더 자세한 내용은
<a href=/ko/docs/tasks/run-application/access-api-from-pod/>파드 내에서 쿠버네티스 API에 접근</a>을 참조한다.</p><h2 id=클러스터에서-실행되는-서비스로-접근>클러스터에서 실행되는 서비스로 접근</h2><p>이전 섹션에서는 쿠버네티스 API 서버에 연결하는 방법을 소개하였다.
쿠버네티스 클러스터에서 실행되는 다른 서비스에 연결하는 방법은
<a href=/ko/docs/tasks/access-application-cluster/access-cluster-services/>클러스터 서비스에 접근</a> 페이지를 참조한다.</p><h2 id=redirect-요청하기>redirect 요청하기</h2><p>redirect 기능은 deprecated되고 제거 되었다. 대신 (아래의) 프록시를 사용하기를 바란다.</p><h2 id=다양한-프록시들>다양한 프록시들</h2><p>쿠버네티스를 사용하면서 당신이 접할 수 있는 몇 가지 다른 프록시들이 존재한다.</p><ol><li><p><a href=#rest-api%EC%97%90-%EC%A7%81%EC%A0%91-%EC%A0%91%EA%B7%BC>kubectl proxy</a>:</p><ul><li>사용자의 데스크탑이나 파드 내에서 실행한다</li><li>localhost 주소에서 쿠버네티스 apiserver로 프록시한다</li><li>프록시하는 클라이언트는 HTTP를 사용한다</li><li>apiserver의 프록시는 HTTPS를 사용한다</li><li>apiserver를 위치지정한다</li><li>인증 header들을 추가한다</li></ul></li><li><p><a href=/ko/docs/tasks/access-application-cluster/access-cluster-services/#%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B2%80%EC%83%89>apiserver proxy</a>:</p><ul><li>apiserver 내의 빌트인 bastion이다</li><li>다른 방식으로는 연결할 수 없는 클러스터 외부의 사용자를 클러스터 IP로 연결한다</li><li>apiserver process들 내에서 실행된다</li><li>프록시하는 클라이언트는 HTTPS를 사용한다(또는 apiserver가 http로 구성되었다면 http)</li><li>타겟으로의 프록시는 가용정보를 사용하는 프록시에 의해서 HTTP 또는 HTTPS를 사용할 수도 있다</li><li>노드, 파드, 서비스에 접근하는 데 사용될 수 있다</li><li>서비스에 접근하는 데 사용되면 load balacing한다</li></ul></li><li><p><a href=/ko/docs/concepts/services-networking/service/#ips-and-vips>kube proxy</a>:</p><ul><li>각 노드 상에서 실행된다</li><li>UDP와 TCP를 프록시한다</li><li>HTTP를 인지하지 않는다</li><li>load balancing을 제공한다</li><li>서비스에 접근하는 데에만 사용된다</li></ul></li><li><p>apiserver(s) 전면의 Proxy/Load-balancer:</p><ul><li>존재내용과 구현사항은 클러스터 별로 다양하다(예. nginx)</li><li>모든 클라이언트와 하나 이상의 apiserver들의 사이에 위치한다</li><li>apiserver가 여러 대 존재한다면 load balancer로 동작한다</li></ul></li><li><p>외부 서비스의 Cloud Load Balancer들:</p><ul><li>Cloud provider들에 의해서 제공된다(예. AWS ELB, Google Cloud Load Balancer)</li><li>쿠버네티스 서비스의 타입이 <code>LoadBalancer</code>라면 자동으로 생성된다</li><li>UDP/TCP 만 사용한다</li><li>cloud provider마다 구현된 내용이 상이하다</li></ul></li></ol><p>일반적으로 쿠버네티스 사용자들은 처음 두 타입이 아닌 다른 방식은 고려할 필요가 없지만 클러스터 관리자는
나머지 타입을 적절하게 구성해줘야 한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5a233e14205d77fe1294917d2da6f876>10.3 - 다중 클러스터 접근 구성</h1><p>이 페이지에서는 구성 파일을 사용하여 다수의 클러스터에 접근할 수 있도록
설정하는 방식을 보여준다. 클러스터, 사용자, 컨텍스트가 하나 이상의
구성 파일에 정의된 다음 <code>kubectl config use-context</code> 커맨드를
사용하여 클러스터를 빠르게 변경할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 클러스터에 접근할 수 있도록 설정하는데 사용되는 파일은 종종 <em>kubeconfig file</em> 이라고
불린다. 이는 구성 파일을 참조하는 일반적인 방식으로 <code>kubeconfig</code>라는 이름을 가진 파일이
반드시 존재해야 한다는 것을 의미하는 것은 아니다.</div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 신뢰할 수 있는 소스의 kubeconfig 파일만 사용해야 한다. 특수 제작된 kubeconfig 파일은 악성코드를 실행하거나 파일을 노출시킬 수 있다.
신뢰할 수 없는 kubeconfig 파일을 꼭 사용해야 한다면, 셸 스크립트를 사용하는 경우처럼 신중한 검사가 선행되어야 한다.</div><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p><a class=glossary-tooltip title='쿠버네티스 클러스터와 통신하기 위한 커맨드라인 툴.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>이 설치되었는지 확인하려면,
<code>kubectl version --client</code>을 실행한다. kubectl 버전은 클러스터의 API 서버 버전과
<a href=/ko/releases/version-skew-policy/#kubectl>마이너 버전 하나 차이 이내</a>여야
한다.</p><h2 id=클러스터-사용자-컨텍스트-정의>클러스터, 사용자, 컨텍스트 정의</h2><p>당신이 개발 작업을 위한 클러스터와 스크래치 작업을 위한 클러스터를 가지고 있다고 가정해보자.
<code>development</code> 클러스터에서는 프런트 엔드 개발자들이 <code>frontend</code>라는 네임스페이스에서
작업을 하고 있고, 스토리지 개발자들은 <code>storage</code>라는 네임스페이스에서 작업을 하고 있다.
<code>scratch</code> 클러스터에서는 개발자들이 default 네임스페이스에서 개발하거나 필요에 따라 보조
네임스페이스들을 생성하고 있다. development 클러스터에 접근하려면 인증서로 인증을 해야 하고,
scratch 클러스터에 접근하려면 사용자네임과 패스워드로 인증을 해야 한다.</p><p><code>config-exercise</code>라는 디렉터리를 생성한다. <code>config-exercise</code> 디렉터리에
다음 내용을 가진 <code>config-demo</code>라는 파일을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exp-scratch<span style=color:#bbb>
</span></span></span></code></pre></div><p>구성 파일은 클러스터들, 사용자들, 컨텍스트들을 기술한다. <code>config-demo</code> 파일은 두 클러스터들과
두 사용자들, 세 컨텍스트들을 기술하기 위한 프레임워크를 가진다.</p><p><code>config-exercise</code> 디렉터리로 이동한다. 그리고 다음 커맨드들을 실행하여 구성 파일에 클러스터의
세부사항들을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster development --server<span style=color:#666>=</span>https://1.2.3.4 --certificate-authority<span style=color:#666>=</span>fake-ca-file
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster scratch --server<span style=color:#666>=</span>https://5.6.7.8 --insecure-skip-tls-verify
</span></span></code></pre></div><p>사용자의 세부사항들을 구성 파일에 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials developer --client-certificate<span style=color:#666>=</span>fake-cert-file --client-key<span style=color:#666>=</span>fake-key-seefile
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials experimenter --username<span style=color:#666>=</span>exp --password<span style=color:#666>=</span>some-password
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><ul><li>사용자를 삭제하려면 <code>kubectl --kubeconfig=config-demo config unset users.&lt;name></code> 를 실행한다.</li><li>클러스터를 제거하려면 <code>kubectl --kubeconfig=config-demo config unset clusters.&lt;name></code> 를 실행한다.</li><li>컨텍스트를 제거하려면 <code>kubectl --kubeconfig=config-demo config unset contexts.&lt;name></code> 를 실행한다.</li></ul></div><p>컨텍스트 세부사항들을 구성 파일에 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-frontend --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>frontend --user<span style=color:#666>=</span>developer
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-storage --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>storage --user<span style=color:#666>=</span>developer
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context exp-scratch --cluster<span style=color:#666>=</span>scratch --namespace<span style=color:#666>=</span>default --user<span style=color:#666>=</span>experimenter
</span></span></code></pre></div><p><code>config-demo</code> 파일을 열어서 세부사항들이 추가되었는지 확인한다. <code>config-demo</code> 파일을 열어보는
것 대신에 <code>config view</code> 커맨드를 사용할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view
</span></span></code></pre></div><p>두 클러스터, 두 사용자, 세 컨텍스트들이 출력 결과로 나온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>fake-ca-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://1.2.3.4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>insecure-skip-tls-verify</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://5.6.7.8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exp-scratch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>fake-cert-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>fake-key-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>some-password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>exp<span style=color:#bbb>
</span></span></span></code></pre></div><p>위 <code>fake-ca-file</code>, <code>fake-cert-file</code>, <code>fake-key-file</code>은 인증서 파일들의 실제 경로 이름을 위한
플레이스홀더(placeholder)이다.
당신의 환경에 맞게 이들을 실제 인증서 경로로 변경해줘야 한다.</p><p>만약 당신이 인증서 파일들의 경로 대신에 여기에 포함된 base64로 인코딩된 데이터를 사용하려고 한다면
이 경우 키에 <code>-data</code> 접미사를 추가해야 한다. 예를 들면 <code>certificate-authority-data</code>,
<code>client-certificate-data</code>, <code>client-key-data</code> 같이 사용할 수 있다.</p><p>컨텍스트는 세 가지(클러스터, 사용자, 네임스페이스) 요소들로 이뤄진다. 예를 들어
<code>dev-frontend</code> 컨텍스트는 "<code>development</code> 클러스터의 <code>frontend</code> 네임스페이스에 접근하는데
<code>developer</code> 사용자 자격증명을 사용하라고 알려준다."</p><p>현재 컨텍스트를 설정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-frontend
</span></span></code></pre></div><p>이제 당신이 <code>kubectl</code> 커맨드를 입력할 때마다 <code>dev-frontend</code> 컨텍스트에 명시된 클러스터와
네임스페이스 상에서 동작하게 될 것이다. 그리고 커맨드는 <code>dev-frontend</code> 컨텍스트 내에 명시된
사용자 자격증명을 사용할 것이다.</p><p>현재 컨텍스트에 관련된 구성 정보만을 보려면
<code>--minify</code> 플래그를 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><p><code>dev-frontend</code> 컨텍스트에 관련된 구성 정보가 출력 결과로 표시될 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>fake-ca-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://1.2.3.4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>fake-cert-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>fake-key-file<span style=color:#bbb>
</span></span></span></code></pre></div><p>이제 당신이 잠시 scratch 클러스터에서 작업하려고 한다고 가정해보자.</p><p>현재 컨텍스트를 <code>exp-scratch</code>로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context exp-scratch
</span></span></code></pre></div><p>이제 당신이 실행하는 모든 <code>kubectl</code> 커맨드는 <code>scratch</code> 클러스터의
default 네임스페이스에 적용되며 <code>exp-scratch</code> 컨텍스트에 나열된
사용자의 자격증명을 사용할 것이다.</p><p>현재의 컨텍스트인 <code>exp-scratch</code>에 관련된 설정을 보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><p>마지막으로 당신이 <code>development</code> 클러스터의 <code>storage</code> 네임스페이스에서
잠시 작업을 하려고 한다고 가정해보자.</p><p>현재 컨텍스트를 <code>dev-storage</code>로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-storage
</span></span></code></pre></div><p>현재 컨텍스트인 <code>dev-storage</code>에 관련된 설정을 보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><h2 id=두-번째-구성-파일-생성>두 번째 구성 파일 생성</h2><p><code>config-exercise</code> 디렉터리에서 다음 내용으로 <code>config-demo-2</code>라는 파일을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ramp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-ramp-up<span style=color:#bbb>
</span></span></span></code></pre></div><p>위 구성 파일은 <code>dev-ramp-up</code>이라는 신규 컨텍스트를 정의한다.</p><h2 id=kubeconfig-환경-변수-설정>KUBECONFIG 환경 변수 설정</h2><p><code>KUBECONFIG</code>라는 환경 변수를 가지고 있는지 확인해보자. 만약 가지고 있다면,
이후에 복원할 수 있도록 <code>KUBECONFIG</code> 환경 변수의 현재 값을 저장한다.
예:</p><h3 id=리눅스>리눅스</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG_SAVED</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$KUBECONFIG</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><h3 id=윈도우-powershell>윈도우 PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#b8860b>$Env:KUBECONFIG_SAVED</span>=<span style=color:#b8860b>$ENV:KUBECONFIG</span>
</span></span></code></pre></div><p><code>KUBECONFIG</code> 환경 변수는 구성 파일들의 경로의 리스트이다. 이 리스트는
리눅스와 Mac에서는 콜론으로 구분되며 윈도우에서는 세미콜론으로 구분된다.
<code>KUBECONFIG</code> 환경 변수를 가지고 있다면, 리스트에 포함된 구성 파일들에
익숙해지길 바란다.</p><p>다음 예와 같이 임시로 <code>KUBECONFIG</code> 환경 변수에 두 개의 경로들을 덧붙여보자.</p><h3 id=리눅스-1>리눅스</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>:config-demo:config-demo-2&#34;</span>
</span></span></code></pre></div><h3 id=윈도우-powershell-1>윈도우 PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#b8860b>$Env:KUBECONFIG</span>=(<span style=color:#b44>&#34;config-demo;config-demo-2&#34;</span>)
</span></span></code></pre></div><p><code>config-exercise</code> 디렉터리에서 다음 커맨드를 입력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>당신의 <code>KUBECONFIG</code> 환경 변수에 나열된 모든 파일들이 합쳐진 정보가 출력 결과로
표시될 것이다. 특히, 합쳐진 정보가 <code>config-demo-2</code> 파일의 <code>dev-ramp-up</code>
컨텍스트와 <code>config-demo</code> 파일의 세 개의 컨텍스트들을
가지고 있다는 것에 주목하길 바란다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ramp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-ramp-up<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>scratch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>experimenter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exp-scratch<span style=color:#bbb>
</span></span></span></code></pre></div><p>kubeconfig 파일들을 어떻게 병합하는지에 대한 상세정보는
<a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일을 사용하여 클러스터 접근 구성하기</a>를 참조한다.</p><h2 id=home-kube-디렉터리-탐색>$HOME/.kube 디렉터리 탐색</h2><p>만약 당신이 이미 클러스터를 가지고 있고 <code>kubectl</code>을 사용하여
해당 클러스터를 제어하고 있다면, 아마 <code>$HOME/.kube</code> 디렉터리에 <code>config</code>라는
파일을 가지고 있을 것이다.</p><p><code>$HOME/.kube</code>로 가서 어떤 파일들이 존재하는지 보자.
보통 <code>config</code>라는 파일이 존재할 것이다. 해당 디렉터리 내에는 다른 구성 파일들도 있을 수 있다.
간단하게 말하자면 당신은 이 파일들의 컨텐츠에 익숙해져야 한다.</p><h2 id=home-kube-config를-kubeconfig-환경-변수에-추가>$HOME/.kube/config를 KUBECONFIG 환경 변수에 추가</h2><p>당신이 <code>$HOME/.kube/config</code> 파일을 가지고 있는데 <code>KUBECONFIG</code>
환경 변수에 나타나지 않는다면 <code>KUBECONFIG</code> 환경 변수에 추가해보자.
예:</p><h3 id=리눅스-2>리눅스</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOME</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/.kube/config&#34;</span>
</span></span></code></pre></div><h3 id=윈도우-powershell-2>윈도우 Powershell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#b8860b>$Env:KUBECONFIG</span>=<span style=color:#b44>&#34;</span><span style=color:#b8860b>$Env:KUBECONFIG</span><span style=color:#b44>;</span><span style=color:#b8860b>$HOME</span><span style=color:#b44>\.kube\config&#34;</span>
</span></span></code></pre></div><p>이제 <code>KUBECONFIG</code> 환경 변수에 리스트에 포함된 모든 파일들이 합쳐진 구성 정보를 보자.
config-exercise 디렉터리에서 다음 커맨드를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><h2 id=정리>정리</h2><p><code>KUBECONFIG</code> 환경 변수를 원래 값으로 되돌려 놓자. 예를 들면:<br></p><h3 id=리눅스-3>리눅스</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$KUBECONFIG_SAVED</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><h3 id=윈도우-powershell-3>윈도우 PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#b8860b>$Env:KUBECONFIG</span>=<span style=color:#b8860b>$ENV:KUBECONFIG_SAVED</span>
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig 파일을 사용하여 클러스터 접근 구성하기</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-72d3dddbc0c166c9a364e753d2b31ff0>10.4 - 포트 포워딩을 사용해서 클러스터 내 애플리케이션에 접근하기</h1><p>이 페이지는 <code>kubectl port-forward</code> 를 사용해서 쿠버네티스 클러스터 내에서
실행중인 MongoDB 서버에 연결하는 방법을 보여준다. 이 유형의 연결은 데이터베이스
디버깅에 유용할 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.10.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p></li><li><p><a href=https://www.mongodb.com/try/download/shell>MongoDB Shell</a>을 설치한다.</p></li></ul><h2 id=mongodb-디플로이먼트와-서비스-생성하기>MongoDB 디플로이먼트와 서비스 생성하기</h2><ol><li><p>MongoDB를 실행하기 위해 디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/mongodb/mongo-deployment.yaml
</span></span></code></pre></div><p>성공적인 명령어의 출력은 디플로이먼트가 생성됐다는 것을 확인해준다.</p><pre tabindex=0><code>deployment.apps/mongo created
</code></pre><p>파드 상태를 조회하여 파드가 준비되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>출력은 파드가 생성되었다는 것을 보여준다.</p><pre tabindex=0><code>NAME                     READY   STATUS    RESTARTS   AGE
mongo-75f59d57f4-4nd6q   1/1     Running   0          2m4s
</code></pre></li></ol><pre tabindex=0><code>
 디플로이먼트 상태를 조회한다.

 ```shell
 kubectl get deployment
</code></pre><p>출력은 디플로이먼트가 생성되었다는 것을 보여준다.</p><pre tabindex=0><code>NAME    READY   UP-TO-DATE   AVAILABLE   AGE
mongo   1/1     1            1           2m21s
</code></pre><p>디플로이먼트는 자동으로 레플리카셋을 관리한다.
아래의 명령어를 사용하여 레플리카셋 상태를 조회한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get replicaset
</span></span></code></pre></div><p>출력은 레플리카셋이 생성되었다는 것을 보여준다.</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY   AGE
mongo-75f59d57f4   1         1         1       3m12s
</code></pre><ol start=2><li><p>MongoDB를 네트워크에 노출시키기 위해 서비스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/mongodb/mongo-service.yaml
</span></span></code></pre></div><p>성공적인 커맨드의 출력은 서비스가 생성되었다는 것을 확인해준다.</p><pre tabindex=0><code>service/mongo created
</code></pre><p>서비스가 생성되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> kubectl get service mongo
</span></span></code></pre></div></li></ol><pre tabindex=0><code>
 출력은 서비스가 생성되었다는 것을 보여준다.
</code></pre><p>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
mongo ClusterIP 10.96.41.183 <none>27017/TCP 11s</p><pre tabindex=0><code>
3. MongoDB 서버가 파드 안에서 실행되고 있고, 27017번 포트에서 수신하고 있는지 확인한다.

```shell
# mongo-75f59d57f4-4nd6q 를 당신의 파드 이름으로 대체한다.
kubectl get pod mongo-75f59d57f4-4nd6q --template=&#39;{{(index (index .spec.containers 0).ports 0).containerPort}}{{&#34;\n&#34;}}&#39;
</code></pre><p>출력은 파드 내 MongoDB 포트 번호를 보여준다.</p><pre tabindex=0><code>27017
</code></pre><pre><code>(27017은 인터넷 상의 MongoDB에 할당된 TCP 포트이다.)
</code></pre><h2 id=파드의-포트를-로컬-포트로-포워딩하기>파드의 포트를 로컬 포트로 포워딩하기</h2><ol><li><p><code>kubectl port-forward</code> 명령어는 파드 이름과 같이 리소스 이름을 사용하여 일치하는 파드를 선택해 포트 포워딩하는 것을 허용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># mongo-75f59d57f4-4nd6q 를 당신의 파드 이름으로 대체한다.</span>
</span></span><span style=display:flex><span>kubectl port-forward mongo-75f59d57f4-4nd6q 28015:27017
</span></span></code></pre></div><p>이것은</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward pods/mongo-75f59d57f4-4nd6q 28015:27017
</span></span></code></pre></div><p>또는</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward deployment/mongo 28015:27017
</span></span></code></pre></div><p>또는</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward replicaset/mongo-75f59d57f4 28015:27017
</span></span></code></pre></div><p>또는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward service/mongo 28015:27017
</span></span></code></pre></div><p>위의 명령어들은 모두 동일하게 동작한다. 이와 유사하게 출력된다.</p><pre tabindex=0><code>Forwarding from 127.0.0.1:28015 -&gt; 27017
Forwarding from [::1]:28015 -&gt; 27017
</code></pre></li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubectl port-forward</code> 는 프롬프트를 리턴하지 않으므로, 이 연습을 계속하려면 다른 터미널을 열어야 한다.</div><ol start=2><li><p>MongoDB 커맨드라인 인터페이스를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mongosh --port <span style=color:#666>28015</span>
</span></span></code></pre></div></li><li><p>MongoDB 커맨드라인 프롬프트에 <code>ping</code> 명령을 입력한다.</p><pre tabindex=0><code>db.runCommand( { ping: 1 } )
</code></pre><p>성공적인 핑 요청을 반환한다.</p><pre tabindex=0><code>{ ok: 1 }
</code></pre></li></ol><h3 id=let-kubectl-choose-local-port>선택적으로 <em>kubectl</em> 이 로컬 포트를 선택하게 하기</h3><p>만약 특정 로컬 포트가 필요하지 않다면, <code>kubectl</code> 이 로컬 포트를 선택 및 할당하게 하여,
조금 더 단순한 문법으로 로컬 포트 충돌 관리를 위한
부담을 줄일 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward deployment/mongo :27017
</span></span></code></pre></div><p><code>kubectl</code> 도구는 사용 중이 아닌 로컬 포트 번호를 찾는다 (낮은 포트 번호는
다른 애플리케이션에서 사용될 것이므로, 낮은 포트 번호를 피해서). 출력은 다음과 같을 것이다.</p><pre tabindex=0><code>Forwarding from 127.0.0.1:63753 -&gt; 27017
Forwarding from [::1]:63753 -&gt; 27017
</code></pre><h2 id=토의>토의</h2><p>로컬 28015 포트에 대한 연결은 MongoDB 서버가 실행중인 파드의 27017 포트로 포워딩된다.
이 연결로 로컬 워크스테이션에서 파드 안에서 실행 중인 데이터베이스를 디버깅하는데
사용할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubectl port-forward</code> 는 TCP 포트에서만 구현된다.
UDP 프로토콜에 대한 지원은
<a href=https://github.com/kubernetes/kubernetes/issues/47862>이슈 47862</a>에서 추적되고 있다.</div><h2 id=다음-내용>다음 내용</h2><p><a href=/docs/reference/generated/kubectl/kubectl-commands/#port-forward>kubectl port-forward</a>에 대해 더 알아본다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-312f29f850826b74618634cd877aa065>10.5 - 클러스터 내 애플리케이션에 접근하기 위해 서비스 사용하기</h1><p>이 문서는 외부 클라이언트가 클러스터에서 실행 중인 애플리케이션에 접근하기
위해 사용하는 쿠버네티스 서비스 오브젝트를 생성하는 방법을 설명한다. 서비스는
실행 중인 두 개의 인스턴스를 갖는 애플리케이션에 대한 로드 밸런싱을 제공한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=목적>목적</h2><ul><li>Hello World 애플리케이션 인스턴스 두 개를 실행한다.</li><li>노드 포트를 노출하는 서비스 오브젝트를 생성한다.</li><li>실행 중인 애플리케이션에 접근하기 위해 서비스 오브젝트를 사용한다.</li></ul><h2 id=두-개의-파드에서-실행-중인-애플리케이션에-대한-서비스-생성하기>두 개의 파드에서 실행 중인 애플리케이션에 대한 서비스 생성하기</h2><p>다음은 애플리케이션 디플로이먼트(Deployment) 설정 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/hello-application.yaml download=service/access/hello-application.yaml><code>service/access/hello-application.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-hello-application-yaml")' title="Copy service/access/hello-application.yaml to clipboard"></img></div><div class=includecode id=service-access-hello-application-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>클러스터 내 Hello World 애플리케이션을 실행하자.
위 파일을 사용하여 애플리케이션 디플로이먼트를 생성하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/access/hello-application.yaml
</span></span></code></pre></div><p>앞의 명령은
<a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>
오브젝트와 연관된
<a class=glossary-tooltip title='레플리카셋은 지정된 수의 파드 레플리카가 동시에 실행이 되도록 보장한다' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=레플리카셋(ReplicaSet)>레플리카셋(ReplicaSet)</a>
오브젝트를 생성한다. 레플리카셋은 두 개의
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 갖고,
각각은 Hello World 애플리케이션을 실행한다.</p></li><li><p>디플로이먼트에 대한 정보를 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployments hello-world
</span></span><span style=display:flex><span>kubectl describe deployments hello-world
</span></span></code></pre></div></li><li><p>레플리카셋 오브젝트에 대한 정보를 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get replicasets
</span></span><span style=display:flex><span>kubectl describe replicasets
</span></span></code></pre></div></li><li><p>디플로이먼트를 노출하는 서비스 오브젝트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment hello-world --type<span style=color:#666>=</span>NodePort --name<span style=color:#666>=</span>example-service
</span></span></code></pre></div></li><li><p>서비스에 대한 정보를 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe services example-service
</span></span></code></pre></div><p>결과는 아래와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:                   example-service
</span></span><span style=display:flex><span>Namespace:              default
</span></span><span style=display:flex><span>Labels:                 <span style=color:#b8860b>run</span><span style=color:#666>=</span>load-balancer-example
</span></span><span style=display:flex><span>Annotations:            &lt;none&gt;
</span></span><span style=display:flex><span>Selector:               <span style=color:#b8860b>run</span><span style=color:#666>=</span>load-balancer-example
</span></span><span style=display:flex><span>Type:                   NodePort
</span></span><span style=display:flex><span>IP:                     10.32.0.16
</span></span><span style=display:flex><span>Port:                   &lt;unset&gt; 8080/TCP
</span></span><span style=display:flex><span>TargetPort:             8080/TCP
</span></span><span style=display:flex><span>NodePort:               &lt;unset&gt; 31496/TCP
</span></span><span style=display:flex><span>Endpoints:              10.200.1.4:8080,10.200.2.5:8080
</span></span><span style=display:flex><span>Session Affinity:       None
</span></span><span style=display:flex><span>Events:                 &lt;none&gt;
</span></span></code></pre></div><p>서비스의 노드포트(NodePort) 값을 메모하자. 예를 들어,
앞선 결과에서, 노드포트 값은 31496이다.</p></li><li><p>Hello World 애플리케이션이 실행 중인 파드를 나열한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b44>&#34;run=load-balancer-example&#34;</span> --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><p>결과는 아래와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                           READY   STATUS    ...  IP           NODE
</span></span><span style=display:flex><span>hello-world-2895499144-bsbk5   1/1     Running   ...  10.200.1.4   worker1
</span></span><span style=display:flex><span>hello-world-2895499144-m1pwt   1/1     Running   ...  10.200.2.5   worker2
</span></span></code></pre></div></li><li><p>Hello World 파드가 실행 중인 노드들 중 하나의 노드에 대해 공용
IP 주소를 얻자. 이 주소를 얻는 방법은 어떻게 클러스터를 설치했는지에
따라 다르다. 예를 들어, Minikube를 사용하면, <code>kubectl cluster-info</code>를
실행하여 노드 주소를 알 수 있다. Google Compute Engine 인스턴스를
사용하면, <code>gcloud compute instances list</code> 명령어를
사용하여 노드들의 공용 주소를 알 수
있다.</p></li><li><p>선택한 노드에서 노드 포트에 대해 TCP 통신을 허용하도록 방화벽 규칙을
생성하자. 예를 들어, 서비스의 노드포트 값이 31568인 경우,
31568 포트로 TCP 통신을 허용하도록 방화벽 규칙을 생성하자. 다른
클라우드 공급자는 방화벽 규칙을 설정하는 다른 방법을 제공한다.</p></li><li><p>Hello World 애플리케이션 접근을 위해 노드 주소와 노드 포트를 사용하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://&lt;public-node-ip&gt;:&lt;node-port&gt;
</span></span></code></pre></div><p><code>&lt;public-node-ip></code>는 노드의 공용 IP 주소이고,
<code>&lt;node-port></code>는 서비스의 노드포트 값이다.
성공적인 요청에 대한 응답은 hello 메시지이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Hello Kubernetes!
</span></span></code></pre></div></li></ol><h2 id=서비스-설정-파일-사용하기>서비스 설정 파일 사용하기</h2><p><code>kubectl expose</code>를 사용하는 대신,
<a href=/ko/docs/concepts/services-networking/service/>서비스 설정 파일</a>을 사용해
서비스를 생성할 수 있다.</p><h2 id=정리하기>정리하기</h2><p>서비스를 삭제하기 위해 다음 명령어를 입력하자.</p><pre><code>kubectl delete services example-service
</code></pre><p>디플로이먼트, 레플리카셋, Hello World 애플리케이션이 실행 중인 파드를
삭제하기 위해 다음 명령어를 입력하자.</p><pre><code>kubectl delete deployment hello-world
</code></pre><h2 id=다음-내용>다음 내용</h2><p><a href=/ko/docs/concepts/services-networking/connect-applications-service/>서비스와 애플리케이션 연결하기</a>에
대해 더 알아본다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f3dac629bea950fc026d920306f09fb4>10.6 - 서비스를 사용하여 프론트엔드를 백엔드에 연결</h1><p>이 작업은 <em>프론트엔드</em> 와 <em>백엔드</em> 마이크로서비스를 어떻게 생성하는지를 설명한다. 백엔드
마이크로서비스는 인사하기(hello greeter)이다. 프론트엔드는 nginx 및 쿠버네티스
<a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a> 오브젝트를 사용해 백엔드를 노출한다.</p><h2 id=목적>목적</h2><ul><li><a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a> 오브젝트를 사용해
샘플 <code>hello</code> 백엔드 마이크로서비스를 생성하고 실행한다.</li><li>서비스 오브젝트를 사용하여 백엔드 마이크로서비스의 여러 복제본으로 트래픽을 보낸다.</li><li>디플로이먼트 오브젝트를 사용하여 <code>nginx</code> 프론트엔드 마이크로서비스를 생성하고 실행한다.</li><li>트래픽을 백엔드 마이크로서비스로 보내도록 프론트엔드 마이크로서비스를 구성한다.</li><li><code>type=LoadBalancer</code> 의 서비스 오브젝트를 사용해 클러스터 외부에 프론트엔드 마이크로서비스를
노출한다.</li></ul><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><p>이 작업은
지원되는 환경이 필요한
<a href=/ko/docs/tasks/access-application-cluster/create-external-load-balancer/>외부 로드밸런서가 있는 서비스</a>를 사용한다. 만약, 이를 지원하지 않는 환경이라면, <a href=/ko/docs/concepts/services-networking/service/#type-nodeport>노드포트</a> 서비스 타입을
대신 사용할 수 있다.</p><h2 id=디플로이먼트를-사용해-백엔드-생성하기>디플로이먼트를 사용해 백엔드 생성하기</h2><p>백엔드는 인사하기라는 간단한 마이크로서비스이다. 여기에 백엔드 디플로이먼트
구성 파일이 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/backend-deployment.yaml download=service/access/backend-deployment.yaml><code>service/access/backend-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-backend-deployment-yaml")' title="Copy service/access/backend-deployment.yaml to clipboard"></img></div><div class=includecode id=service-access-backend-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>7</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;gcr.io/google-samples/hello-go-gke:1.0&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>백엔드 디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/access/backend-deployment.yaml
</span></span></code></pre></div><p>백엔드 디플로이먼트에 관한 정보를 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment backend
</span></span></code></pre></div><p>결과는 아래와 같다.</p><pre tabindex=0><code>Name:                           backend
Namespace:                      default
CreationTimestamp:              Mon, 24 Oct 2016 14:21:02 -0700
Labels:                         app=hello
                                tier=backend
                                track=stable
Annotations:                    deployment.kubernetes.io/revision=1
Selector:                       app=hello,tier=backend,track=stable
Replicas:                       3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:                   RollingUpdate
MinReadySeconds:                0
RollingUpdateStrategy:          1 max unavailable, 1 max surge
Pod Template:
  Labels:       app=hello
                tier=backend
                track=stable
  Containers:
   hello:
    Image:              &#34;gcr.io/google-samples/hello-go-gke:1.0&#34;
    Port:               80/TCP
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
OldReplicaSets:                 &lt;none&gt;
NewReplicaSet:                  hello-3621623197 (3/3 replicas created)
Events:
...
</code></pre><h2 id=hello-서비스-오브젝트-생성하기><code>hello</code> 서비스 오브젝트 생성하기</h2><p>프론트엔드에서 백엔드로 요청을 보내는 핵심은 백엔드
서비스이다. 서비스는 백엔드 마이크로서비스에 언제든 도달하기 위해
변하지 않는 IP 주소와 DNS 이름 항목을 생성한다. 서비스는
트래픽을 보내는 파드를 찾기 위해
<a class=glossary-tooltip title='사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=셀렉터>셀렉터</a>를 사용한다.</p><p>먼저, 서비스 구성 파일을 살펴보자.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/backend-service.yaml download=service/access/backend-service.yaml><code>service/access/backend-service.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-backend-service-yaml")' title="Copy service/access/backend-service.yaml to clipboard"></img></div><div class=includecode id=service-access-backend-service-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>구성 파일에서 <code>hello</code> 라는 이름의 서비스가 <code>app: hello</code> 및 <code>tier: backend</code> 레이블을 갖는
파드에 트래픽을 보내는 것을 볼 수 있다.</p><p>백엔드 서비스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/access/backend-service.yaml
</span></span></code></pre></div><p>이 시점에서 <code>hello</code> 애플리케이션의 복제본 3개를 실행하는 <code>backend</code>
디플로이먼트가 있고, 해당 백엔드로 트래픽을 보내는 서비스가 있다. 그러나, 이
서비스는 클러스터 외부에서 사용할 수 없거나 확인할 수 없다.</p><h2 id=프론트엔드-생성하기>프론트엔드 생성하기</h2><p>이제 백엔드를 실행했으므로, 클러스터 외부에서 접근할 수 있는
프론트엔드를 만들고, 백엔드로의 요청을 프록시하여 백엔드에 연결할 수 있다.</p><p>프론트엔드는 백엔드 서비스에 지정된 DNS 이름을 사용하여 백엔드
워커 파드에 요청을 보낸다. DNS 이름은
<code>examples/service/access/backend-service.yaml</code> 구성 파일의
<code>name</code> 필드 값인 <code>hello</code> 이다.</p><p>프론트엔드 디플로이먼트 안의 파드는 <code>hello</code> 백엔드 서비스에 대한 요청을
프록시하도록 구성된 nginx 이미지를 실행한다. 다음은 nginx 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/frontend-nginx.conf download=service/access/frontend-nginx.conf><code>service/access/frontend-nginx.conf</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-frontend-nginx-conf")' title="Copy service/access/frontend-nginx.conf to clipboard"></img></div><div class=includecode id=service-access-frontend-nginx-conf><pre tabindex=0><code class=language-conf data-lang=conf># The identifier Backend is internal to nginx, and used to name this specific upstream
upstream Backend {
    # hello is the internal DNS name used by the backend Service inside Kubernetes
    server hello;
}

server {
    listen 80;

    location / {
        # The following statement will proxy traffic to the upstream named Backend
        proxy_pass http://Backend;
    }
}
</code></pre></div></div><p>백엔드와 같이, 프론트엔드는 디플로이먼트와 서비스를 갖고 있다. 백엔드
서비스와 프론트엔드 서비스 간에 주목해야 할 중요한 차이점은 프론트엔드
서비스의 구성에 <code>type: LoadBalancer</code> 가 있다는 것이다. 즉,
서비스가 클라우드 공급자가 프로비저닝한 로드 밸런서를 사용하고
클러스터 외부에서 접근할 수 있음을 의미한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/frontend-service.yaml download=service/access/frontend-service.yaml><code>service/access/frontend-service.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-frontend-service-yaml")' title="Copy service/access/frontend-service.yaml to clipboard"></img></div><div class=includecode id=service-access-frontend-service-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;TCP&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span></span></span></code></pre></div></div></div><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/access/frontend-deployment.yaml download=service/access/frontend-deployment.yaml><code>service/access/frontend-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-access-frontend-deployment-yaml")' title="Copy service/access/frontend-deployment.yaml to clipboard"></img></div><div class=includecode id=service-access-frontend-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;gcr.io/google-samples/hello-frontend:1.0&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>preStop</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/usr/sbin/nginx&#34;</span>,<span style=color:#b44>&#34;-s&#34;</span>,<span style=color:#b44>&#34;quit&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span></span></span></code></pre></div></div></div><p>프론트엔드 디플로이먼트와 서비스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/access/frontend-deployment.yaml
</span></span><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/access/frontend-service.yaml
</span></span></code></pre></div><p>결과는 두 리소스가 생성되었음을 확인한다.</p><pre tabindex=0><code>deployment.apps/frontend created
service/frontend created
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> nginx 구성은 <a href=/examples/service/access/Dockerfile>컨테이너 이미지</a>에
반영 되었다. 이를 실행하는 더 좋은 방법은
구성을
보다 쉽게 변경할
수 있는 <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그맵(ConfigMap)</a>을 사용하는 것이다.</div><h2 id=프론트엔드-서비스와-통신하기>프론트엔드 서비스와 통신하기</h2><p>일단 로드밸런서 타입의 서비스를 생성하면, 이 명령어를
사용해 외부 IP를 찾을 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get service frontend --watch
</span></span></code></pre></div><p><code>frontend</code> 서비스의 구성을 보여주고, 변경 사항을
주시한다. 처음에, 외부 IP는 <code>&lt;pending></code> 으로 나열된다.</p><pre tabindex=0><code>NAME       TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)  AGE
frontend   LoadBalancer   10.51.252.116   &lt;pending&gt;     80/TCP   10s
</code></pre><p>하지만, 외부 IP가 생성되자마자 구성은
<code>EXTERNAL-IP</code> 제목 아래에 새로운 IP를 포함하여 갱신한다.</p><pre tabindex=0><code>NAME       TYPE           CLUSTER-IP      EXTERNAL-IP        PORT(S)  AGE
frontend   LoadBalancer   10.51.252.116   XXX.XXX.XXX.XXX    80/TCP   1m
</code></pre><p>이제 해당 IP는 클러스터 외부에서 <code>frontend</code> 서비스와 통신하는데
사용된다.</p><h2 id=프론트엔드-통해서-트래픽-보내기>프론트엔드 통해서 트래픽 보내기</h2><p>이제 프론트엔드와 백엔드가 연결되었다. 프론트엔드 서비스의 외부 IP에서
curl 명령을 사용해 엔드포인트에 도달할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>EXTERNAL_IP</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#080;font-style:italic># 앞의 예에서 본 EXTERNAL-IP로 수정한다</span>
</span></span></code></pre></div><p>결과로 백엔드에서 생성된 메시지가 보인다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;message&#34;</span>:<span style=color:#b44>&#34;Hello&#34;</span>}
</span></span></code></pre></div><h2 id=정리하기>정리하기</h2><p>서비스를 삭제하기 위해, 아래 명령어를 입력하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete services frontend backend
</span></span></code></pre></div><p>백엔드와 프론트엔드 애플리케이션에서 실행 중인 디플로이먼트, 레플리카셋, 파드를 삭제하기 위해, 아래 명령어를 입력하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment frontend backend
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/services-networking/service/>서비스</a>에 대해 더 알아본다.</li><li><a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그맵</a>에 대해 더 알아본다.</li><li><a href=/ko/docs/concepts/services-networking/dns-pod-service/>서비스와 파드용 DNS</a>에 대해 더 알아본다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-21cd8f87563675fb0278d3694ba9ecb0>10.7 - 외부 로드 밸런서 생성하기</h1><p>이 문서는 외부 로드 밸런서를 생성하는 방법에 관하여 설명한다.</p><p><a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를 생성할 때,
클라우드 로드 밸런서를 자동으로 생성하는 옵션을 사용할 수 있다.
이것은 클러스터 노드의 올바른 포트로 트래픽을 전송할 수 있도록
외부에서 접근 가능한 IP 주소를 제공한다.
<em>클러스터가 지원되는 환경과
올바른 클라우드 로드 밸런서 제공자 패키지 구성으로 실행되는 경우.</em></p><p>또한, 서비스 대신 <a class=glossary-tooltip title='클러스터 내의 서비스에 대한 외부 접근을 관리하는 API 오브젝트이며, 일반적으로 HTTP를 관리함.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/ingress/ target=_blank aria-label=인그레스(Ingress)>인그레스(Ingress)</a> 를 사용할 수 있다.
자세한 사항은 <a href=/ko/docs/concepts/services-networking/ingress/>인그레스(Ingress)</a>
문서를 참고한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>클러스터는 반드시 클라우드 또는 외부 로드 밸런서 구성을 지원하는
환경에서 실행 중이어야 한다.</p><h2 id=서비스-생성>서비스 생성</h2><h3 id=매니페스트를-사용하여-서비스-생성하기>매니페스트를 사용하여 서비스 생성하기</h3><p>외부 로드 밸런서를 생성하기 위해서, 서비스 매니페스트에
다음을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span></code></pre></div><p>매니페스트는 아래와 같을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8765</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=kubectl를-이용하여-서비스-생성하기>kubectl를 이용하여 서비스 생성하기</h3><p>또한, <code>kubectl expose</code> 명령어에 <code>--type=LoadBalancer</code> 플래그를 이용해
서비스를 생성할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl expose deployment example --port<span style=color:#666>=</span><span style=color:#666>8765</span> --target-port<span style=color:#666>=</span><span style=color:#666>9376</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --name<span style=color:#666>=</span>example-service --type<span style=color:#666>=</span>LoadBalancer
</span></span></code></pre></div><p>이 명령은 동일한 리소스를 셀렉터로 참조하는 새로운 서비스를 만든다.
(위 예시의 경우, <code>example</code>로 명명된
<a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a> ).</p><p>명령줄 옵션 플래그를 포함한, 더 자세한 내용은
<a href=/docs/reference/generated/kubectl/kubectl-commands/#expose><code>kubectl expose</code> 레퍼런스</a> 문서를 참고한다.</p><h2 id=ip-주소-찾기>IP 주소 찾기</h2><p><code>kubectl</code> 명령어를 사용해 서비스 정보를 얻어,
생성된 서비스에 관한 IP 주소를 찾을 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe services example-service
</span></span></code></pre></div><p>출력은 다음과 같다.</p><pre tabindex=0><code>Name:                     example-service
Namespace:                default
Labels:                   app=example
Annotations:              &lt;none&gt;
Selector:                 app=example
Type:                     LoadBalancer
IP Families:              &lt;none&gt;
IP:                       10.3.22.96
IPs:                      10.3.22.96
LoadBalancer Ingress:     192.0.2.89
Port:                     &lt;unset&gt;  8765/TCP
TargetPort:               9376/TCP
NodePort:                 &lt;unset&gt;  30593/TCP
Endpoints:                172.17.0.3:9376
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   &lt;none&gt;
</code></pre><p>로드 밸런서의 IP 주소는 <code>LoadBalancer Ingress</code> 옆에 나타난다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>만약 서비스가 Minikube에서 실행되고 있다면, 아래의 명령을 통해 할당된 IP 주소와 포트를 찾을 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>minikube service example-service --url
</span></span></code></pre></div></div><h2 id=preserving-the-client-source-ip>클라이언트 소스 IP 보존하기</h2><p>기본적으로 대상 컨테이너에 보이는 소스 IP는 클라이언트의 <em>원래 소스 IP가 아니다.</em>
클라이언트의 IP를 보존할 수 있도록 하려면,
아래의 서비스 <code>.spec</code> 필드 구성을 따른다.</p><ul><li><code>.spec.externalTrafficPolicy</code> - 이 서비스가 외부 트래픽을 노드-로컬 또는
클러스터-전체 엔드포인트로 라우팅할지 여부를 나타낸다.
두 가지 옵션이 있다. <code>Cluster</code> (기본) 그리고 <code>Local</code>.
<code>Cluster</code> 는 클라이언트 소스 IP를 가리고 다른 노드에 대한
두 번째 홉(hop)을 발생시킬 수 있지만,
전체적인 부하 분산에서 이점이 있다.
<code>Local</code> 은 클라이언트 소스 IP를 보존하고
<code>LoadBalancer</code>와 <code>NodePort</code> 타입의 서비스에서 두 번째 홉(hop) 발생을 피할 수 있지만,
트래픽 분산이 불균형적인 잠재적인 위험이 있다.</li><li><code>.spec.healthCheckNodePort</code> - 서비스를 위한 헬스 체크 노드 포트(정수 포트 번호)를 지정한다.
<code>healthCheckNodePort</code>를 지정하지 않으면,
서비스 컨트롤러가 클러스터의 노트 포트 범위에서 포트를 할당한다.
API 서버 명령줄 플래그 <code>--service-node-port-range</code>를 설정하여 해당 범위를 구성할 수 있다.
서비스 <code>type</code>이 <code>LoadBalancer</code>이고 <code>externalTrafficPolicy</code>를 <code>Local</code>로 설정한 경우,
서비스는 <code>healthCheckNodePort</code>가 지정되었다면,
사용자가 지정한 설정을 이용한다.</li></ul><p>서비스 매니페스트에서 <code>externalTrafficPolicy</code>를 <code>Local</code>로 설정하면 이 기능이 작동한다.
예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8765</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalTrafficPolicy</span>:<span style=color:#bbb> </span>Local<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=caveats-and-limitations-when-preserving-source-ips>소스 IP를 보존할 때 주의사항 및 제한 사항</h3><p>일부 클라우드 제공자의 로드 밸런싱 서비스에서는 대상별로 다른 가중치를 구성할 수 없다.</p><p>각 대상의 가중치는 노드로 전송하는 트래픽을 측면에서 균등하게 부여하기 때문에
외부 트래픽은 서로 다른 파드 간에 로드 밸런싱되지 않는다.
외부 로드 밸런서는 각 노드에서 대상으로 사용되는 파드의 개수를 인식하지 못한다.</p><p><code>서비스파드개수 &lt;&lt; 노드개수</code> 이거나 <code>서비스파드개수 >> 노드개수</code> 인 경우에선
가중치 없이도 거의 균등한 분포를 볼 수 있다.</p><p>내부 파드 간 트래픽은 <code>ClusterIP</code> 서비스에서와 비슷하게 모든 파드에서 동일한 확률로 IP 서비스를 제공한다.</p><h2 id=garbage-collecting-load-balancers>가비지(Garbage) 수집 로드 밸런서</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.17 [stable]</code></div><p>일반적으로 클라우드 제공자와 관련 있는 로드밸런서 리소스는 <code>type</code>이 <code>LoadBalancer</code>인
서비스가 삭제된 후 즉시 정리되어야 한다.
그러나 관련 서비스가 삭제된 후 클라우드 리소스가 고아가 되는 코너 케이스가 다양한 것으로 알려져 있다.
이러한 문제를 예방하기 위해 서비스 로드밸런서를 위한 <code>Finalizer Protection</code>이 도입되었다.
<code>Finalizer</code>를 사용하면, 서비스 리소스는 로드밸런서 관련 리소스가 삭제될 때까지 삭제되지 않는다.</p><p>특히 서비스에 <code>type</code>이 <code>LoadBalancer</code>인 경우
서비스 컨트롤러는 <code>service.kubernetes.io/load-balancer-cleanup</code>
이라는 이름의 <code>finalizer</code>를 붙인다.
<code>finalizer</code>는 (클라우드) 로드 밸런서 리소스를 정리한 후에만 제거된다.
이렇게 하면 서비스 컨트롤러 충돌(crash)과 같은 코너 케이스에서도
로드 밸런서 리소스가 고아가 되는 것을 방지할 수 있다.</p><h2 id=external-load-balancer-providers>외부 로드 밸런서 제공자</h2><p>중요한 점은 이 기능을 위한 데이터 경로는 쿠버네티스 클러스터 외부의 로드 밸런서에서 제공한다는 것이다.</p><p>서비스의 <code>type</code>이 <code>LoadBalancer</code>로 설정된 경우,
쿠버네티스는 <code>type</code>이 <code>ClusterIP</code>인 경우처럼 동등한 기능을 클러스터 내의 파드에 제공하고
관련 쿠버네티스 파드를 호스팅하는 노드에 대한 항목으로 (쿠버네티스 외부) 로드 밸런서를 프로그래밍을 통해 확장한다.
쿠버네티스 컨트롤 플레인은 외부 로드 밸런서, (필요한 경우) 헬스 체크 및 (필요한 경우) 패킷 필터링 규칙의 생성을 자동화한다.
클라우드 공급자가 로드 밸런서에 대한 IP 주소를 할당하면 컨트롤 플레인이 해당 외부 IP 주소를 찾아 서비스 오브젝트를 갱신한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/services-networking/service/>서비스</a>에 대해 알아보기</li><li><a href=/ko/docs/concepts/services-networking/ingress/>인그레스</a>에 대해 알아보기</li><li><a href=/ko/docs/concepts/services-networking/connect-applications-service/>서비스와 애플리케이션 연결하기</a> 알아보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1839d8468a083839ed1cc8d18fe1142e>10.8 - NGINX 인그레스(Ingress) 컨트롤러로 Minikube에서 인그레스 설정하기</h1><p><a href=/ko/docs/concepts/services-networking/ingress/>인그레스</a>는 클러스터의 서비스에 대한 외부 액세스를 허용하는 규칙을 정의하는
API 객체이다. <a href=/ko/docs/concepts/services-networking/ingress-controllers/>인그레스 컨트롤러</a>는 인그레스에 설정된 규칙을 이행한다.</p><p>이 페이지에서는 HTTP URI에 따라 요청을 Service web 또는 web2로 라우팅하는 간단한 인그레스를 설정하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: 1.19.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.
만약 이보다 더 이전 버전의 쿠버네티스를 사용하고 있다면,
해당 쿠버네티스 버전의 문서를 참고한다.</p><h3 id=minikube-클러스터-생성하기>Minikube 클러스터 생성하기</h3><dl><dt>Katacoda 활용하기</dt><dd><script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button></dd><dt>로컬에서 생성하기</dt><dd>이미 로컬에 <a href=/ko/docs/tasks/tools/#minikube>Minikube를 설치</a>했다면,
<code>minikube start</code>를 실행하여 클러스터를 생성한다.</dd></dl><h2 id=인그레스-컨트롤러-활성화>인그레스 컨트롤러 활성화</h2><ol><li><p>NGINX 인그레스 컨트롤러를 활성화하기 위해 다음 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> ingress
</span></span></code></pre></div></li><li><p>NGINX 인그레스 컨트롤러가 실행 중인지 확인한다.</p><ul class="nav nav-tabs" id=tab-with-md role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-with-md-0 role=tab aria-controls=tab-with-md-0 aria-selected=true>minikube v1.19 or later</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-md-1 role=tab aria-controls=tab-with-md-1>minikube v1.18.1 or earlier</a></li></ul><div class=tab-content id=tab-with-md><div id=tab-with-md-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-with-md-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -n ingress-nginx
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드가 정상적으로 실행되기까지 1분 정도 소요될 수 있다.</div><p>결과는 다음과 같다.</p><pre tabindex=0><code>NAME                                        READY   STATUS      RESTARTS    AGE
ingress-nginx-admission-create-g9g49        0/1     Completed   0          11m
ingress-nginx-admission-patch-rqp78         0/1     Completed   1          11m
ingress-nginx-controller-59b45fb494-26npt   1/1     Running     0          11m
</code></pre></div><div id=tab-with-md-1 class=tab-pane role=tabpanel aria-labelledby=tab-with-md-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -n kube-system
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드가 정상적으로 실행되기까지 1분 정도 소요될 수 있다.</div><p>결과는 다음과 같다.</p><pre tabindex=0><code>NAME                                        READY     STATUS    RESTARTS   AGE
default-http-backend-59868b7dd6-xb8tq       1/1       Running   0          1m
kube-addon-manager-minikube                 1/1       Running   0          3m
kube-dns-6dcb57bcc8-n4xd4                   3/3       Running   0          2m
kubernetes-dashboard-5498ccf677-b8p5h       1/1       Running   0          2m
nginx-ingress-controller-5984b97644-rnkrg   1/1       Running   0          1m
storage-provisioner                         1/1       Running   0          2m
</code></pre><p><code>nginx-ingress-controller-</code>로 시작하는 파드가 있는지 확인한다.</p></div></div></li></ol><h2 id=hello-world-앱-배포하기>hello, world 앱 배포하기</h2><ol><li><p>다음 명령을 사용하여 디플로이먼트(Deployment)를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment web --image<span style=color:#666>=</span>gcr.io/google-samples/hello-app:1.0
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>deployment.apps/web created
</code></pre></li><li><p>디플로이먼트를 노출시킨다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment web --type<span style=color:#666>=</span>NodePort --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>service/web exposed
</code></pre></li><li><p>서비스(Service)가 생성되고 노드 포트에서 사용할 수 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get service web
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>NAME      TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
web       NodePort   10.104.133.249   &lt;none&gt;        8080:31637/TCP   12m
</code></pre></li><li><p>노드포트(NodePort)를 통해 서비스에 접속한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube service web --url
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>http://172.17.0.15:31637
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> Katacoda 환경만 해당: 터미널 패널 상단에서 더하기 기호를 클릭한 다음 <strong>Select port to view on Host 1</strong>을 클릭한다. 노드포트(이 경우 '31637')를 입력한 다음 <strong>Display Port</strong>를 클릭한다.</div><p>결과는 다음과 같다.</p><pre tabindex=0><code>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre><p>이제 Minikube IP 주소와 노드포트를 통해 샘플 앱에 액세스할 수 있다. 다음 단계에서는
인그레스 리소스를 사용하여 앱에 액세스할 수 있다.</p></li></ol><h2 id=인그레스-생성하기>인그레스 생성하기</h2><p>다음 매니페스트는 hello-world.info를 통해 서비스로 트래픽을 보내는 인그레스를 정의한다.</p><ol><li>다음 파일을 통해 <code>example-ingress.yaml</code>을 만든다.</li></ol><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/networking/example-ingress.yaml download=service/networking/example-ingress.yaml><code>service/networking/example-ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-example-ingress-yaml")' title="Copy service/networking/example-ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-example-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-ingress<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/$1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>hello-world.info<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span></span></span></code></pre></div></div></div><ol><li><p>다음 명령어를 실행하여 인그레스 오브젝트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/networking/example-ingress.yaml
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>ingress.networking.k8s.io/example-ingress created
</code></pre></li><li><p>IP 주소가 설정되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 작업은 몇 분 정도 소요될 수 있다.</div></li></ol><p>다음 예시와 같이, ADDRESS 열에서 IPv4 주소를 확인할 수 있다.</p><pre tabindex=0><code>NAME              CLASS    HOSTS              ADDRESS        PORTS   AGE
example-ingress   &lt;none&gt;   hello-world.info   172.17.0.15    80      38s
</code></pre><ol><li><p>호스트 컴퓨터의 <code>/etc/hosts</code> 파일 맨 아래에
다음 행을 추가한다 (관리자 권한 필요).</p><pre tabindex=0><code>172.17.0.15 hello-world.info
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> Minikube를 로컬에서 실행하는 경우 'minikube ip'를 사용하여 외부 IP를 가져온다. 인그레스 목록에 표시되는 IP 주소는 내부 IP가 된다.</div><p>이렇게 하면, 웹 브라우저가
hello-world.info URL에 대한 요청을 Minikube로 전송한다.</p></li><li><p>인그레스 컨트롤러가 트래픽을 전달하는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl hello-world.info
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> Minikube를 로컬에서 실행하는 경우 브라우저에서 hello-world.info에 접속할 수 있다.</div></li></ol><h2 id=두-번째-디플로이먼트-생성하기>두 번째 디플로이먼트 생성하기</h2><ol><li><p>다음 명령을 사용하여 두 번째 디플로이먼트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment web2 --image<span style=color:#666>=</span>gcr.io/google-samples/hello-app:2.0
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>deployment.apps/web2 created
</code></pre></li><li><p>두 번째 디플로이먼트를 노출시킨다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment web2 --port<span style=color:#666>=</span><span style=color:#666>8080</span> --type<span style=color:#666>=</span>NodePort
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>service/web2 exposed
</code></pre></li></ol><h2 id=edit-ingress>기존 인그레스 수정하기</h2><ol><li><p>기존 <code>example-ingress.yaml</code> 매니페스트를 편집하고,
하단에 다음 줄을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/v2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p>변경 사항을 적용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f example-ingress.yaml
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>ingress.networking/example-ingress configured
</code></pre></li></ol><h2 id=인그레스-테스트하기>인그레스 테스트하기</h2><ol><li><p>Hello World 앱의 첫 번째 버전에 액세스한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl hello-world.info
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></li><li><p>Hello World 앱의 두 번째 버전에 액세스한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl hello-world.info/v2
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>Hello, world!
Version: 2.0.0
Hostname: web2-75cd47646f-t8cjk
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> Minikube를 로컬에서 실행하는 경우 브라우저에서 hello-world.info 및 hello-world.info/v2에 접속할 수 있다.</div></li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/services-networking/ingress/>인그레스</a>에 대해 더 보기.</li><li><a href=/ko/docs/concepts/services-networking/ingress-controllers/>인그레스 컨트롤러</a>에 대해 더 보기.</li><li><a href=/ko/docs/concepts/services-networking/service/>서비스</a>에 대해 더 보기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-48e8f306f919c5b81265e265a2b76ab4>10.9 - 클러스터 내 모든 컨테이너 이미지 목록 보기</h1><p>이 문서는 kubectl을 이용하여 클러스터 내 모든 컨테이너 이미지 목록을
조회하는 방법에 관해 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><p>이 작업에서는 kubectl을 사용하여 클러스터 내 모든 파드의 정보를
조회하고, 결과값의 서식을 변경하여 각 파드에 대한 컨테이너 이미지 목록으로
재구성할 것이다.</p><h2 id=모든-네임스페이스의-모든-컨테이너-이미지-가져오기>모든 네임스페이스의 모든 컨테이너 이미지 가져오기</h2><ul><li><code>kubectl get pods --all-namespaces</code> 를 사용하여 모든 네임스페이스의 모든 파드 정보를 가져온다.</li><li>컨테이너 이미지 이름만 출력하기 위해 <code>-o jsonpath={.items[*].spec.containers[*].image}</code> 를 사용한다.
이 명령어는 결과값으로 받은 json을 반복적으로 파싱하여,
<code>image</code> 필드만을 출력한다.<ul><li>jsonpath를 사용하는 방법에 대해 더 많은 정보를 얻고 싶다면
<a href=/ko/docs/reference/kubectl/jsonpath/>Jsonpath 지원</a>을 확인한다.</li></ul></li><li>다음의 표준 툴을 이용해서 결과값을 처리한다. <code>tr</code>, <code>sort</code>, <code>uniq</code><ul><li><code>tr</code> 을 사용하여 공백을 줄 바꾸기로 대체한다.</li><li><code>sort</code> 를 사용하여 결과값을 정렬한다.</li><li><code>uniq</code> 를 사용하여 이미지 개수를 합산한다.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>tr -s <span style=color:#b44>&#39;[[:space:]]&#39;</span> <span style=color:#b44>&#39;\n&#39;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>sort |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>uniq -c
</span></span></code></pre></div><p>이 커맨드는 결과값으로 나온 모든 아이템 중에 <code>image</code> 라고 명명된 필드를
모두 출력한다.</p><p>이와 다른 방법으로 파드 이미지 필드 값의 절대 경로를 사용할 수 있다.
이것은 필드명이 반복될 때에도
정확한 값을 출력하도록 보장한다.
예) 결과값 중에 많은 필드들이 <code>name</code>으로 명명되었을 경우,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</span></span></code></pre></div><p>이 jsonpath는 다음과 같이 해석할 수 있다.</p><ul><li><code>.items[*]</code>: 각 결과값에 대하여</li><li><code>.spec</code>: spec 값을 가져온다.</li><li><code>.containers[*]</code>: 각 컨테이너에 대하여</li><li><code>.image</code>: image 값을 가져온다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 명령어로 하나의 파드를 가져올 때, 예를 들어 <code>kubectl get pod nginx</code> 라면,
jsonpath에서 <code>.items[*]</code> 부분은 생략해야 하는데, 이는 명령어가 아이템 목록이 아닌
단 한 개의 아이템(여기선 파드)으로 결과값을 주기 때문이다.</div><h2 id=각-파드의-컨테이너-이미지-보기>각 파드의 컨테이너 이미지 보기</h2><p><code>range</code> 연산을 사용하여 명령어의 결과값에서 각각의 요소들을
반복하여 출력할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{&#34;\n&#34;}{.metadata.name}{&#34;:\t&#34;}{range .spec.containers[*]}{.image}{&#34;, &#34;}{end}{end}&#39;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>sort
</span></span></code></pre></div><h2 id=파드-레이블로-필터링된-컨테이너-이미지-목록-보기>파드 레이블로 필터링된 컨테이너 이미지 목록 보기</h2><p>특정 레이블에 맞는 파드를 지정하기 위해서 -l 플래그를 사용한다. 아래의
명령어 결과값은 <code>app=nginx</code> 레이블에 일치하는 파드만 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span> -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><h2 id=파드-네임스페이스로-필터링된-컨테이너-이미지-목록-보기>파드 네임스페이스로 필터링된 컨테이너 이미지 목록 보기</h2><p>특정 네임스페이스의 파드를 지정하려면, 네임스페이스 플래그를 사용한다.
아래의 명령어 결과값은 <code>kube-system</code> 네임스페이스에 있는 파드만 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --namespace kube-system -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</span></span></code></pre></div><h2 id=jsonpath-대신-go-템플릿을-사용하여-컨테이너-이미지-목록-보기>jsonpath 대신 Go 템플릿을 사용하여 컨테이너 이미지 목록 보기</h2><p>jsonpath의 대안으로 Kubectl은 <a href=https://golang.org/pkg/text/template/>Go 템플릿</a>을 지원한다.
다음과 같이 결과값의 서식을 지정할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#34;{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}&#34;</span>
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><h3 id=참조>참조</h3><ul><li><a href=/ko/docs/reference/kubectl/jsonpath/>Jsonpath</a> 참조</li><li><a href=https://golang.org/pkg/text/template/>Go 템플릿</a> 참조</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7c319a9981586e5fbcfa21b392720650>10.10 - 공유 볼륨을 이용하여 동일한 파드의 컨테이너 간에 통신하기</h1><p>이 페이지에서는 동일한 파드에서 실행 중인 두 개의 컨테이너 간에 통신할 때에,
어떻게 볼륨을 이용하는지 살펴본다. 컨테이너 간에
<a href=/docs/tasks/configure-pod-container/share-process-namespace/>프로세스 네임스페이스 공유하기</a>를
통해 통신할 수 있는 방법을 참고하자.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=두-개의-컨테이너를-실행하는-파드-생성>두 개의 컨테이너를 실행하는 파드 생성</h2><p>이 실습에서 두 개의 컨테이너를 실행하는 파드를 생성한다. 이 컨테이너들은
통신에 사용할 수 있는 볼륨을 공유한다.
아래는 이 파드의 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/two-container-pod.yaml download=pods/two-container-pod.yaml><code>pods/two-container-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-two-container-pod-yaml")' title="Copy pods/two-container-pod.yaml to clipboard"></img></div><div class=includecode id=pods-two-container-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>two-containers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>debian-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/pod-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo debian 컨테이너에서 안녕하세요 &gt; /pod-data/index.html&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이 구성 파일에는 파드가 <code>shared-data</code>로 명명한 볼륨을 가진 것을
알 수 있다.</p><p>첫 번째 컨테이너에는 nginx 웹 서버를 실행하는 구성 파일이 나열되어 있다.
공유 볼륨의 마운트 경로는 <code>/usr/share/nginx/html</code>이다.
두 번째 컨테이너는 debian 이미지 기반이고, 마운트 경로는 <code>/pod-data</code>이다.
두 번째 컨테이너는 다음 명령어를 실행한 후에 종료한다.</p><pre><code>echo debian 컨테이너에서 안녕하세요 &gt; /pod-data/index.html
</code></pre><p>두 번째 컨테이너는 <code>index.html</code> 파일을
nginx 웹 서버에서 호스팅하는 문서의 루트 디렉터리(<code>/usr/share/nginx/html/</code>)에 저장한다.</p><p>이제, 파드와 두 개의 컨테이너를 생성한다.</p><pre><code>kubectl apply -f https://k8s.io/examples/pods/two-container-pod.yaml
</code></pre><p>파드와 컨테이너의 정보를 확인한다.</p><pre><code>kubectl get pod two-containers --output=yaml
</code></pre><p>출력의 일부는 다음과 같다.</p><pre><code>apiVersion: v1
kind: Pod
metadata:
  ...
  name: two-containers
  namespace: default
  ...
spec:
  ...
  containerStatuses:

  - containerID: docker://c1d8abd1 ...
    image: debian
    ...
    lastState:
      terminated:
        ...
    name: debian-container
    ...

  - containerID: docker://96c1ff2c5bb ...
    image: nginx
    ...
    name: nginx-container
    ...
    state:
      running:
    ...
</code></pre><p>Debian 컨테이너가 종료되었음을 알 수 있고, nginx 컨테이너는
아직 실행 중이다.</p><p>nginx 컨테이너의 쉘(shell)을 실행한다.</p><pre><code>kubectl exec -it two-containers -c nginx-container -- /bin/bash
</code></pre><p>쉘에서 nginx 웹 서버가 실행 중인지 확인한다.</p><pre><code>root@two-containers:/# apt-get update
root@two-containers:/# apt-get install curl procps
root@two-containers:/# ps aux
</code></pre><p>출력은 아래와 유사하다.</p><pre><code>USER       PID  ...  STAT START   TIME COMMAND
root         1  ...  Ss   21:12   0:00 nginx: master process nginx -g daemon off;
</code></pre><p>Debian 컨테이너에서 nginx 웹 서버가 호스팅하는 문서의 루트 디렉터리에 <code>index.html</code> 파일을 생성했었음을 상기하자.
<code>curl</code>을 이용하여 nginx 웹 서버에 HTTP GET 요청을 보낸다.</p><pre tabindex=0><code>root@two-containers:/# curl localhost
</code></pre><p>출력을 보면, nginx 웹 서버에서 debian 컨테이너에서 쓰여진 웹 페이지를 제공하는 것을 알 수 있다.</p><pre tabindex=0><code>debian 컨테이너에서 안녕하세요
</code></pre><h2 id=토의>토의</h2><p>파드가 여러 컨테이너를 가질 수 있는 주요 이유는 기본 애플리케이션을 보조할
도우미(helper) 애플리케이션을 제공하기 위해서이다. 도우미 애플리케이션의 일반적인 예로는
데이터를 가지고 오는 경우(data puller)나 데이터를 보내주는 경우(data pusher)이거나 프록시가 있다.
도우미와 기본 애플리케이션은 종종 서로 간에 통신을 해야 할 수 있다.
일반적으로 이는 이번 예제에서 살펴본 것 같이, 공유 파일 시스템을 통하거나,
루프백 네트워크 인터페이스 곧 로컬 호스트(localhost)를 통해서 이뤄진다. 이 패턴의 한가지 예는
웹 서버가 도우미 프로그램과 함께 Git 저장소에서 새 업데이트를 받아오는 경우이다.</p><p>이 예제에서 볼륨은 파드의 생명 주기 동안 컨테이너를 위한 통신 방법으로 이용했다.
파드가 삭제되고 재생성되면, 공유 볼륨에 저장된 데이터는 잃어버린다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><p><a href=/blog/2015/06/the-distributed-system-toolkit-patterns>합성 컨테이너(composite container) 패턴</a>에 관하여 더 공부한다.</p></li><li><p><a href=https://www.slideshare.net/Docker/slideshare-burns>모듈 구조를 위한 합성 컨테이너 구조</a>에 관하여 더 공부한다.</p></li><li><p><a href=/ko/docs/tasks/configure-pod-container/configure-volume-storage/>파드에서 저장소로 볼룸을 사용하도록 구성하기</a>에 관하여 확인한다.</p></li><li><p><a href=/docs/tasks/configure-pod-container/share-process-namespace/>파드에서 컨테이너 간에 프로세스 네임스페이스를 공유하는 파드 구성하는 방법</a>을 참고한다.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#volume-v1-core>볼륨</a>을 확인한다.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>파드</a>을 확인한다.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-322786b38586b210fab68f785259c5f6>10.11 - 클러스터의 DNS 구성하기</h1><p>쿠버네티스는 지원하는 모든 환경에서 기본으로 활성화된 DNS 클러스터 애드온을 제공한다. 쿠버네티스 1.11과 이후 버전에서는, CoreDNS가 권장되고 기본적으로 kubeadm과 함께 설치 된다.</p><p>쿠버네티스 클러스터의 CoreDNS 설정에 대한 더 많은 정보는, <a href=/ko/docs/tasks/administer-cluster/dns-custom-nameservers/>DNS 서비스 사용자화 하기</a>을 본다. kube-dns와 함께 쿠버네티스 DNS를 사용하는 방법을 보여주는 예시는 <a href=https://github.com/kubernetes/examples/tree/master/staging/cluster-dns>쿠버네티스 DNS 샘플 플러그인</a>을 본다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-43591bb11cc02c39e278cf07f6546810>10.12 - 클러스터에서 실행되는 서비스에 접근</h1><p>이 페이지는 쿠버네티스 클러스터에서 실행되는 서비스에 연결하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=클러스터에서-실행되는-서비스에-접근>클러스터에서 실행되는 서비스에 접근</h2><p>쿠버네티스에서, <a href=/ko/docs/concepts/architecture/nodes/>노드</a>,
<a href=/ko/docs/concepts/workloads/pods/>파드</a> 및 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>는 모두
고유한 IP를 가진다. 당신의 데스크탑 PC와 같은 클러스터 외부 장비에서는
클러스터 상의 노드 IP, 파드 IP, 서비스 IP로 라우팅되지 않아서
접근할 수 없을 것이다.</p><h3 id=연결하는-방법>연결하는 방법</h3><p>클러스터 외부에서 노드, 파드 및 서비스에 접속하기 위한 몇 가지 옵션이 있다.</p><ul><li>퍼블릭 IP를 통해 서비스에 접근한다.<ul><li>클러스터 외부에서 접근할 수 있도록 <code>NodePort</code> 또는 <code>LoadBalancer</code> 타입의
서비스를 사용한다. <a href=/ko/docs/concepts/services-networking/service/>서비스</a>와
<a href=/docs/reference/generated/kubectl/kubectl-commands/#expose>kubectl expose</a> 문서를 참고한다.</li><li>클러스터 환경에 따라, 서비스는 회사 네트워크에만 노출되기도 하며,
인터넷에 노출되는 경우도 있다. 이 경우 노출되는 서비스의 보안 여부를 고려해야 한다.
해당 서비스는 자체적으로 인증을 수행하는가?</li><li>파드는 서비스 뒤에 위치시킨다. 디버깅과 같은 목적으로 레플리카 집합에서 특정 파드에 접근하려면,
파드에 고유한 레이블을 배치하고 이 레이블을 선택하는 새 서비스를 생성한다.</li><li>대부분의 경우, 애플리케이션 개발자가 nodeIP를 통해 노드에 직접
접근할 필요는 없다.</li></ul></li><li>프록시 작업(Proxy Verb)을 사용하여 서비스, 노드 또는 파드에 접근한다.<ul><li>원격 서비스에 접근하기 전에 apiserver 인증과 권한 부여를 수행한다.
서비스가 인터넷에 노출되거나, 노드 IP의 포트에 접근하거나, 디버깅하기에
충분히 안전하지 않은 경우 사용한다.</li><li>프록시는 일부 웹 애플리케이션에 문제를 일으킬 수 있다.</li><li>HTTP/HTTPS에서만 작동한다.</li><li><a href=#apiserver-%ED%94%84%EB%A1%9D%EC%8B%9C-url-%EC%88%98%EB%8F%99-%EA%B5%AC%EC%84%B1>여기</a>에 설명되어 있다.</li></ul></li><li>클러스터의 노드 또는 파드에서 접근한다.<ul><li>파드를 실행한 다음, <a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>를 사용하여 셸에 연결한다.
해당 셸에서 다른 노드, 파드 및 서비스에 연결한다.</li><li>일부 클러스터는 클러스터의 노드로 ssh를 통해 접근하는 것을 허용한다. 거기에서 클러스터 서비스에
접근할 수 있다. 이것은 비표준 방법이며, 일부 클러스터에서는 작동하지만 다른 클러스터에서는
작동하지 않는다. 브라우저 및 기타 도구가 설치되거나 설치되지 않을 수 있다. 클러스터 DNS가 작동하지 않을 수도 있다.</li></ul></li></ul><h3 id=빌트인-서비스-검색>빌트인 서비스 검색</h3><p>일반적으로 kube-system에 의해 클러스터에 실행되는 몇 가지 서비스가 있다.
<code>kubectl cluster-info</code> 커맨드로 이 서비스의 리스트를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><p>출력은 다음과 비슷하다.</p><pre tabindex=0><code>Kubernetes master is running at https://192.0.2.1
elasticsearch-logging is running at https://192.0.2.1/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy
kibana-logging is running at https://192.0.2.1/api/v1/namespaces/kube-system/services/kibana-logging/proxy
kube-dns is running at https://192.0.2.1/api/v1/namespaces/kube-system/services/kube-dns/proxy
grafana is running at https://192.0.2.1/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
heapster is running at https://192.0.2.1/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
</code></pre><p>각 서비스에 접근하기 위한 프록시-작업 URL이 표시된다.
예를 들어, 이 클러스터에는 <code>https://192.0.2.1/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code> 로
접근할 수 있는 (Elasticsearch를 사용한) 클러스터 수준 로깅이 활성화되어 있다. 적합한 자격 증명이 전달되는 경우나 kubectl proxy를 통해 도달할 수 있다. 예를 들어 다음의 URL에서 확인할 수 있다.
<code>http://localhost:8080/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code>.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 자격 증명을 전달하거나 kubectl proxy를 사용하는 방법은 <a href=/ko/docs/tasks/administer-cluster/access-cluster-api/>쿠버네티스 API를 사용하여 클러스터에 접근하기</a>를 참고한다.</div><h4 id=apiserver-프록시-url-수동-구성>apiserver 프록시 URL 수동 구성</h4><p>위에서 언급한 것처럼, <code>kubectl cluster-info</code> 명령을 사용하여 서비스의 프록시 URL을 검색한다. 서비스 엔드포인트, 접미사 및 매개 변수를 포함하는 프록시 URL을 작성하려면, 서비스의 프록시 URL에 추가하면 된다.
<code>http://</code><em><code>kubernetes_master_address</code></em><code>/api/v1/namespaces/</code><em><code>namespace_name</code></em><code>/services/</code><em><code>[https:]service_name[:port_name]</code></em><code>/proxy</code></p><p>포트에 대한 이름을 지정하지 않은 경우, URL에 <em>port_name</em> 을 지정할 필요가 없다. 또한, 이름이 지정된 포트와 지정되지 않은 포트 모두에 대해, <em>port_name</em> 자리에 포트 번호를 기재할 수도 있다.</p><p>기본적으로, API 서버는 서비스로의 프록시를 HTTP로 제공한다. HTTPS를 사용하려면, 서비스 이름 앞에 <code>https:</code>를 추가한다.
<code>http://&lt;쿠버네티스_컨트롤_플레인_주소>/api/v1/namespaces/&lt;네임스페이스_이름>/services/&lt;서비스_이름>/proxy</code></p><p>URL에서 <code>&lt;서비스_이름></code>이 지원하는 형식은 다음과 같다.</p><ul><li><code>&lt;서비스_이름></code> - 기본 포트 또는 이름이 지정되지 않은 포트로 http를 사용하여 프록시</li><li><code>&lt;서비스_이름>:&lt;포트_이름></code> - 기재된 포트 이름 또는 포트 번호로 http를 사용하여 프록시</li><li><code>https:&lt;서비스_이름>:</code> - 기본 포트 또는 이름이 지정되지 않은 포트로 https를 사용하여 프록시(맨 끝의 콜론에 유의)</li><li><code>https:&lt;서비스_이름>:&lt;포트_이름></code> - 기재된 포트 이름 또는 포트 번호로 https를 사용하여 프록시</li></ul><h5 id=예제>예제</h5><ul><li><p>Elasticsearch 서비스 엔드포인트 <code>_search?q=user:kimchy</code> 에 접근하려면, 다음을 사용한다.</p><pre tabindex=0><code>http://192.0.2.1/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_search?q=user:kimchy
</code></pre></li><li><p>Elasticsearch 클러스터 상태 정보 <code>_cluster/health?pretty=true</code> 에 접근하려면, 다음을 사용한다.</p><pre tabindex=0><code>https://192.0.2.1/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_cluster/health?pretty=true
</code></pre><p>상태 정보는 다음과 비슷하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cluster_name&#34;</span> : <span style=color:#b44>&#34;kubernetes_logging&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span> : <span style=color:#b44>&#34;yellow&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;timed_out&#34;</span> : <span style=color:#a2f;font-weight:700>false</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;number_of_nodes&#34;</span> : <span style=color:#666>1</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;number_of_data_nodes&#34;</span> : <span style=color:#666>1</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;active_primary_shards&#34;</span> : <span style=color:#666>5</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;active_shards&#34;</span> : <span style=color:#666>5</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;relocating_shards&#34;</span> : <span style=color:#666>0</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;initializing_shards&#34;</span> : <span style=color:#666>0</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;unassigned_shards&#34;</span> : <span style=color:#666>5</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><em>https</em> Elasticsearch 서비스 상태 정보 <code>_cluster/health?pretty=true</code> 에 접근하려면, 다음을 사용한다.</p><pre tabindex=0><code>https://192.0.2.1/api/v1/namespaces/kube-system/services/https:elasticsearch-logging/proxy/_cluster/health?pretty=true
</code></pre></li></ul><h4 id=웹-브라우저를-사용하여-클러스터에서-실행되는-서비스에-접근>웹 브라우저를 사용하여 클러스터에서 실행되는 서비스에 접근</h4><p>브라우저의 주소 표시줄에 apiserver 프록시 URL을 넣을 수 있다. 그러나,</p><ul><li>웹 브라우저는 일반적으로 토큰을 전달할 수 없으므로, 기본 (비밀번호) 인증을 사용해야 할 수도 있다. Apiserver는 기본 인증을 수락하도록 구성할 수 있지만,
클러스터는 기본 인증을 수락하도록 구성되지 않을 수 있다.</li><li>일부 웹 앱, 특히 프록시 경로 접두사를 인식하지 못하는 방식으로 URL을 구성하는 클라이언트 측 자바스크립트가 있는
웹 앱이 작동하지 않을 수 있다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-11a6d16334428909c99e7208ab8fa5e9>11 - 쿠버네티스 확장</h1><div class=lead>쿠버네티스 클러스터를 작업 환경의 요구에 맞게 조정하는 고급 과정을 이해한다.</div></div><div class=td-content><h1 id=pg-c4798e42eaccc051e396542befb3c57b>11.1 - 확장 API 서버 설정</h1><p>애그리게이션 레이어(aggregation layer)와 작동하도록 확장 API 서버를 설정하면 쿠버네티스 API 서버를 쿠버네티스의 핵심 API의 일부가 아닌 추가 API로 확장할 수 있다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><ul><li><a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>애그리게이션 레이어를 구성</a>하고 apiserver 플래그를 활성화해야 한다.</li></ul><h2 id=애그리게이션-레이어와-작동하도록-확장-api-서버-설정하기>애그리게이션 레이어와 작동하도록 확장 API 서버 설정하기</h2><p>다음 단계는 확장 API 서버를 <em>높은 수준</em> 으로 설정하는 방법을 설명한다. 이 단계는 YAML 구성을 사용하거나 API를 사용하는 것에 상관없이 적용된다. 둘 사이의 차이점을 구체적으로 식별하려고 시도한다. YAML 구성을 사용하여 구현하는 방법에 대한 구체적인 예를 보려면, 쿠버네티스 리포지터리에서 <a href=https://github.com/kubernetes/sample-apiserver/blob/master/README.md>sample-apiserver</a>를 참고할 수 있다.</p><p>또는, <a href=https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/README.md>apiserver-builder</a>와 같은 기존의 타사 솔루션을 사용하여 스켈레톤(skeleton)을 생성하고 다음 단계를 모두 자동화해야 한다.</p><ol><li>API서비스(APIService) API가 활성화되어 있는지 확인한다(<code>--runtime-config</code> 확인). 클러스터에서 일부러 해제하지 않았다면, 기본적으로 활성화되어 있어야 한다.</li><li>API서비스 오브젝트를 추가하거나 클러스터 관리자가 작성하도록 RBAC 규칙을 작성해야 할 수도 있다. (API 확장은 전체 클러스터에 영향을 주기 때문에, 운영 중인 클러스터에서 API 확장에 대한 테스트/개발/디버깅을 수행하지 않는 것이 좋다.)</li><li>확장 API 서비스를 실행하려는 쿠버네티스 네임스페이스를 생성한다.</li><li>HTTPS를 위해 확장 API 서버가 사용하는 서버 인증서에 서명하는 데 사용할 CA 인증서를 생성하거나 가져온다.</li><li>HTTPS를 위해 API 서버가 사용할 서버 인증서/키를 생성한다. 이 인증서는 위의 CA 인증서에 의해 서명해야 한다. 또한 Kube DNS 이름의 CN이 있어야 한다. 이것은 쿠버네티스 서비스에서 파생되었으며 <code>&lt;service name>.&lt;service name namespace>.svc</code> 형식이다.</li><li>네임스페이스에 서버 인증서/키를 사용하여 쿠버네티스 시크릿을 생성한다.</li><li>확장 API 서버에 대한 쿠버네티스 디플로이먼트를 생성하고 시크릿을 볼륨으로 로드하는지 확인한다. 확장 API 서버의 작동하는(working) 이미지에 대한 참조를 포함해야 한다. 디플로이먼트는 네임스페이스에도 있어야 한다.</li><li>확장 API 서버가 해당 볼륨에서 해당 인증서를 로드하고 HTTPS 핸드셰이크에 사용되는지 확인한다.</li><li>네임스페이스에서 쿠버네티스 서비스 어카운트를 생성한다.</li><li>리소스에 허용하려는 작업에 대한 쿠버네티스 클러스터 롤(role)을 생성한다.</li><li>네임스페이스의 서비스 어카운트에서 방금 만든 클러스터 롤로 쿠버네티스 클러스터 롤 바인딩을 생성한다.</li><li>네임스페이스의 서비스 어카운트에서 <code>system:auth-delegator</code> 클러스터 롤로 쿠버네티스 클러스터 롤 바인딩을 만들어 인증 결정을 쿠버네티스 핵심 API 서버에 위임한다.</li><li>네임스페이스의 서비스 어카운트에서 <code>extension-apiserver-authentication-reader</code> 롤로 쿠버네티스 롤 바인딩을 생성한다. 이를 통해 확장 API 서버가 <code>extension-apiserver-authentication</code> 컨피그맵(configmap)에 접근할 수 있다.</li><li>쿠버네티스 API 서비스를 생성한다. 위의 CA 인증서는 base64로 인코딩되어, 새로운 라인이 제거되고 API 서비스에서 spec.caBundle로 사용되어야 한다. 이것은 namespaced가 아니어야 한다. <a href=https://github.com/kubernetes/kube-aggregator/>kube-aggregator API</a>를 사용하는 경우, base64 인코딩이 수행되므로 PEM 인코딩된 CA 번들만 통과한다.</li><li>kubectl을 사용하여 리소스를 얻는다. kubectl을 실행하면, "No resources found."가 반환된다. 이 메시지는
모든 것이 작동됐지만 현재 해당 리소스 유형의 오브젝트가 생성되지 않았음을 나타낸다.</li></ol><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>API 애그리게이션 레이어를 구성</a>하고 apiserver 플래그를 활성화하는 단계를 수행한다.</li><li>높은 수준의 개요에 대해서는, <a href=/ko/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>애그리게이션 레이어로 쿠버네티스 API 확장하기</a>를 참고한다.</li><li><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>커스텀 리소스 데피니션을 사용하여 쿠버네티스 API 확장</a>하는 방법에 대해 알아본다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c00a2767fac9dbfafce583cf489cc423>11.2 - 다중 스케줄러 설정</h1><p>쿠버네티스는 <a href=/docs/reference/command-line-tools-reference/kube-scheduler/>여기</a>에서
설명한 스케줄러를 기본 스케줄러로 사용한다.
만일 기본 스케줄러가 사용자의 필요를 만족시키지 못한다면 직접 스케줄러를 구현하여 사용할 수 있다.
이에 더해, 기본 스케줄러와 함께 여러 스케줄러를 동시에 사용하여
쿠버네티스가 각 파드에 대해 어떤 스케줄러를 적용할지에 대한 설정도 할 수 있다.
예제와 함께 쿠버네티스에서 다중 스케줄러를 사용하는 방법에 대해 배워보도록 하자.</p><p>스케줄러를 구현하는 방법에 대한 자세한 설명은 해당 문서에서 다루지 않는다.
kube-scheduler 구현을 다루는 공식 예시는 쿠버네티스 소스 디렉토리에 있는
<a href=https://github.com/kubernetes/kubernetes/tree/master/pkg/scheduler>pkg/scheduler</a>
를 참고한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><h2 id=스케줄러-패키징>스케줄러 패키징</h2><p>스케줄러 바이너리를 컨테이너 이미지로 패키징한다. 해당 예제를 통해
기본 스케줄러 (kube-scheduler)를 두 번째 스케줄러로 사용할 수 있다.
<a href=https://github.com/kubernetes/kubernetes>GitHub 쿠버네티스 소스코드</a>를
클론하고 소스를 빌드하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git clone https://github.com/kubernetes/kubernetes.git
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> kubernetes
</span></span><span style=display:flex><span>make
</span></span></code></pre></div><p>kube-scheduler 바이너리를 담은 컨테이너 이미지를 생성하자.
이미지를 빌드 하기 위한 <code>Dockerfile</code>은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#a2f;font-weight:700>FROM</span><span style=color:#b44> busybox</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#a2f;font-weight:700>ADD</span> ./_output/local/bin/linux/amd64/kube-scheduler /usr/local/bin/kube-scheduler<span>
</span></span></span></code></pre></div><p>파일을 <code>Dockerfile</code>로 저장하고 이미지를 빌드한 후 레지스트리로 푸시하자. 해당 예제에서는 이미지를
<a href=https://cloud.google.com/container-registry/>Google Container Registry (GCR)</a>로
푸시하고 있다.
이에 대한 자세한 내용은 GCR
<a href=https://cloud.google.com/container-registry/docs/>문서</a>를 참고하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker build -t gcr.io/my-gcp-project/my-kube-scheduler:1.0 .
</span></span><span style=display:flex><span>gcloud docker -- push gcr.io/my-gcp-project/my-kube-scheduler:1.0
</span></span></code></pre></div><h2 id=스케줄러에서-사용할-쿠버네티스-디플로이먼트-정의하기>스케줄러에서 사용할 쿠버네티스 디플로이먼트 정의하기</h2><p>이제 스케줄러 컨테이너 이미지가 있으니, 해당 이미지를 포함하는 파드 구성을 생성하고
쿠버네티스 클러스터 내에서 실행해보자. 해당 예제에서는, 클러스터 내에 직접 파드를 생성하는 대신에
<a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>를 사용해도 된다.
<a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>는
<a href=/ko/docs/concepts/workloads/controllers/replicaset/>레플리카 셋</a>을 관리하며,
이는 또 파드를 관리하기 때문에 스케줄러에 대한 회복 탄력성을 제공한다.
다음은 디플로이먼트에 대한 구성 파일이다. 이 파일을 <code>my-scheduler.yaml</code>으로 저장한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/sched/my-scheduler.yaml download=admin/sched/my-scheduler.yaml><code>admin/sched/my-scheduler.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-sched-my-scheduler-yaml")' title="Copy admin/sched/my-scheduler.yaml to clipboard"></img></div><div class=includecode id=admin-sched-my-scheduler-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler-as-kube-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:kube-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler-as-volume-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:volume-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>my-scheduler-config.yaml</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    apiVersion: kubescheduler.config.k8s.io/v1beta2
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    kind: KubeSchedulerConfiguration
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    profiles:
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      - schedulerName: my-scheduler
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    leaderElection:
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      leaderElect: false</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>control-plane<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>control-plane<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>control-plane<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- /usr/local/bin/kube-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- --config=/etc/kubernetes/my-scheduler/my-scheduler-config.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/my-gcp-project/my-kube-scheduler:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>10259</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>scheme</span>:<span style=color:#bbb> </span>HTTPS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-second-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>10259</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>scheme</span>:<span style=color:#bbb> </span>HTTPS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;0.1&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/my-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPID</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-scheduler-config<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>해당 매니페스트에서는 <a href=/ko/docs/reference/scheduling/config/>KubeSchedulerConfiguration</a>을
사용하여 구현할 스케줄러의 특성을 정의한다. 이러한 설정은 초기화 과정에서 <code>--config</code> 옵션을 통해 <code>kube-scheduler</code>에게 전달된다.
해당 구성 파일은 <code>my-scheduler-config</code> 컨피그맵에 저장된다. <code>my-scheduler</code> 디플로이먼트의 파드에서는 <code>my-scheduler-config</code> 컨피그맵을 볼륨으로 마운트 시킨다.</p><p>앞서 언급한 스케줄러 구성에서는, 구현한 스케줄러가
<a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerProfile>KubeSchedulerProfile</a>의 형식으로 나타나게 된다.<div class="alert alert-info note callout" role=alert><strong>참고:</strong> 스케줄러가 특정 파드에 대한 스케줄링을 수행하는지 판단하기 위해서는, PodTemplate 또는 파드 매니페스트의
<code>spec.schedulerName</code> 필드가 <code>KubeSchedulerProfile</code>의 <code>schedulerName</code> 필드와 일치하는지 확인해야 한다.
클러스터 내 실행되고 있는 모든 스케줄러는 고유한 이름을 가져야 한다.</div></p><p>또한, <code>kube-scheduler</code>와 같은 권한을 부여받기 위해서는 전용 서비스 어카운트 <code>my-scheduler</code>를 생성하고
해당 서비스 어카운트를 클러스터롤 <code>system:kube-scheduler</code>와 바인딩해야 한다.</p><p>이외의 커맨드 라인 인자에 대한 자세한 설명은
<a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler 문서</a>에서 참고하고
이외의 사용자 정의 <code>kube-scheduler</code> 구성에 대한 자세한 설명은
<a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>스케줄러 구성 레퍼런스</a>
에서 참고한다.</p><h2 id=두-번째-스케줄러를-클러스터에서-실행하기>두 번째 스케줄러를 클러스터에서 실행하기</h2><p>쿠버네티스 클러스터에서 스케줄러를 실행하기 위해서,
위의 구성 파일에서 명시한 디플로이먼트를 쿠버네티스 클러스터 내에 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f my-scheduler.yaml
</span></span></code></pre></div><p>스케줄러 파드가 실행되고 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div><pre tabindex=0><code>NAME                                           READY     STATUS    RESTARTS   AGE
....
my-scheduler-lnf4s-4744f                       1/1       Running   0          2m
...
</code></pre><p>기본 kube-scheduler 파드와 더불어,
my-scheduler 파드가 실행("Running")되고 있다는 것을 목록에서 볼 수 있을 것이다.</p><h3 id=리더-선출-활성화>리더 선출 활성화</h3><p>리더 선출이 활성화된 상태로 다중 스케줄러를 실행하기 위해서는 다음과 같은 작업을 수행해야 한다.</p><p><code>my-scheduler-config</code> 컨피그맵의 YAML 파일에서 KubeSchedulerConfiguration의 다음과 같은 필드들을 갱신한다.</p><ul><li><code>leaderElection.leaderElect</code> 를 <code>true</code> 로</li><li><code>leaderElection.resourceNamespace</code> 를 <code>&lt;lock-object-namespace></code> 로</li><li><code>leaderElection.resourceName</code> 을 <code>&lt;lock-object-name></code> 으로</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 컨트롤 플레인이 잠금 오브젝트를 생성해 주지만, 해당 네임스페이스가 존재하는 상태이어야 한다.
<code>kube-system</code> 네임스페이스를 사용해도 된다.</div><p>클러스터 내에 RBAC가 활성화되어 있는 상태라면, <code>system:kube-scheduler</code> 클러스터롤을 업데이트 해야 한다.
다음 예시와 같이, 구현한 스케줄러의 이름을 <code>endpoints</code>와 <code>leases</code> 리소스에 적용되는 룰의 resourceNames에 추가하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit clusterrole system:kube-scheduler
</span></span></code></pre></div><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/sched/clusterrole.yaml download=admin/sched/clusterrole.yaml><code>admin/sched/clusterrole.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-sched-clusterrole-yaml")' title="Copy admin/sched/clusterrole.yaml to clipboard"></img></div><div class=includecode id=admin-sched-clusterrole-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.kubernetes.io/autoupdate</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/bootstrapping</span>:<span style=color:#bbb> </span>rbac-defaults<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:kube-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- coordination.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- leases<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- coordination.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- kube-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- my-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- leases<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- kube-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- my-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h2 id=파드의-스케줄러를-지정하기>파드의 스케줄러를 지정하기</h2><p>이제 두 번째 스케줄러가 실행되고 있으니,
파드를 몇 개 생성하여 기본 스케줄러 또는 새로 배치한 스케줄러에 의해 스케줄링이 되도록 설정해 보자.
특정 스케줄러를 이용하여 파드를 스케줄링하기 위해서는
해당 파드의 명세에 해당 스케줄러의 이름을 명시해야 한다. 세 가지 예시를 참고해 보자.</p><ul><li><p>스케줄러 이름을 명시하지 않은 파드 명세</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/sched/pod1.yaml download=admin/sched/pod1.yaml><code>admin/sched/pod1.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-sched-pod1-yaml")' title="Copy admin/sched/pod1.yaml to clipboard"></img></div><div class=includecode id=admin-sched-pod1-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>no</span>-annotation<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>multischeduler-example<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-no-annotation-container<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/pause:2.0</span></span></code></pre></div></div></div><p>스케줄러 이름을 제공받지 못했다면,
파드는 자동으로 기본 스케줄러에 의해 스케줄링이 수행된다.</p><p>해당 파일을 <code>pod1.yaml</code>로 저장하고 쿠버네티스 클러스터에 제출해 보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f pod1.yaml
</span></span></code></pre></div></li><li><p><code>default-scheduler</code>를 명시한 파드 명세</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/sched/pod2.yaml download=admin/sched/pod2.yaml><code>admin/sched/pod2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-sched-pod2-yaml")' title="Copy admin/sched/pod2.yaml to clipboard"></img></div><div class=includecode id=admin-sched-pod2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotation-default-scheduler<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>multischeduler-example<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>default-scheduler<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-default-annotation-container<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/pause:2.0<span style=color:#bbb>
  </span></span></span></code></pre></div></div></div><p><code>spec.schedulerName</code>의 값으로 스케줄러 이름을 제공함으로써 스케줄러가 정해진다.
이와 같은 경우에서는, 기본 스케줄러의 이름인 <code>default-scheduler</code>를 명시하고 있다.</p><p>해당 파일을 <code>pod2.yaml</code>로 저장하고 쿠버네티스 클러스터에 제출해 보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f pod2.yaml
</span></span></code></pre></div></li><li><p><code>my-scheduler</code>를 명시한 파드 명세</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/sched/pod3.yaml download=admin/sched/pod3.yaml><code>admin/sched/pod3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-sched-pod3-yaml")' title="Copy admin/sched/pod3.yaml to clipboard"></img></div><div class=includecode id=admin-sched-pod3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotation-second-scheduler<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>multischeduler-example<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>my-scheduler<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-second-annotation-container<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/pause:2.0<span style=color:#bbb>
  </span></span></span></code></pre></div></div></div><p>이와 같은 경우에서는, 직접 배치한 스케줄러 - <code>my-scheduler</code>를 통해
해당 파드의 스케줄링이 수행되어야 한다는 것을 명시하고 있다.
<code>spec.schedulerName</code>의 값은 <code>KubeSchedulerProfile</code> 매핑의 <code>schedulerName</code> 필드와 일치해야 한다.</p><p>해당 파일을 <code>pod3.yaml</code>로 저장하고 쿠버네티스 클러스터에 제출해 보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f pod3.yaml
</span></span></code></pre></div><p>세 개의 파드가 모두 실행되고 있는지 확인해 보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div></li></ul><h3 id=파드가-원하는-스케줄러에-의해-스케줄링-되었는지-확인해보기>파드가 원하는 스케줄러에 의해 스케줄링 되었는지 확인해보기</h3><p>이번 예제들을 수월하게 진행하기 위해,
파드가 실제로 원하는 스케줄러에 의해 스케줄링되고 있는지 확인해 보지 않았다.
해당 사항은 파드와 디플로이먼트 구성 파일의 제출 순서를 바꿔보면 확인해 볼 수 있다.
만일 스케줄러 디플로이먼트 구성 파일을 제출하기 전에 모든 파드의 구성 파일을 쿠버네티스 클러스터에 제출한다면,
다른 두 개의 파드는 스케줄링 되는 와중에 <code>annotation-second-scheduler</code> 파드는
무기한 "Pending" 상태에 머무르는 것을 관찰할 수 있다.
스케줄러 디플로이먼트 구성 파일을 제출하여 새로운 스케줄러가 실행되기 시작하면,
<code>annotation-second-scheduler</code> 파드도 스케줄링 된다.</p><p>다른 방법으로는, 이벤트 로그에서 "Scheduled" 항목을 찾아
파드가 원하는 스케줄러에 의해 스케줄링 되었는지 확인해 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>또한, 관련된 컨트롤 플레인 노드들의 스태틱 파드 매니페스트를 수정하면 클러스터의 메인 스케줄러로
<a href=/ko/docs/reference/scheduling/config/#multiple-profiles>사용자 정의 스케줄러 구성</a>
또는 사용자 정의 컨테이너 이미지를 사용할 수도 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1707517970dd390995f760308c2e2de6>11.3 - HTTP 프록시를 사용하여 쿠버네티스 API에 접근</h1><p>이 페이지는 쿠버네티스 API에 접근하기 위해 HTTP 프록시를 사용하는 방법을 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><p>클러스터에서 실행 중인 애플리케이션이 없다면,
아래 명령을 입력하여 Hello world 애플리케이션을 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment node-hello --image<span style=color:#666>=</span>gcr.io/google-samples/node-hello:1.0 --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><h2 id=kubectl을-사용하여-프록시-서버-시작>kubectl을 사용하여 프록시 서버 시작</h2><p>아래 커맨드는 쿠버네티스 API 서버의 프록시를 시작한다.</p><pre><code>kubectl proxy --port=8080
</code></pre><h2 id=kubernetes-api-탐색>Kubernetes API 탐색</h2><p>프록시 서버가 실행 중일 때 <code>curl</code>, <code>wget</code>
또는 브라우저를 사용하여 API를 탐색할 수 있다.</p><p>API 버전 가져오기.</p><pre><code>curl http://localhost:8080/api/
</code></pre><p>출력은 다음과 유사하다.</p><pre><code>{
  &quot;kind&quot;: &quot;APIVersions&quot;,
  &quot;versions&quot;: [
    &quot;v1&quot;
  ],
  &quot;serverAddressByClientCIDRs&quot;: [
    {
      &quot;clientCIDR&quot;: &quot;0.0.0.0/0&quot;,
      &quot;serverAddress&quot;: &quot;10.0.2.15:8443&quot;
    }
  ]
}
</code></pre><p>파드 목록 가져오기.</p><pre><code>curl http://localhost:8080/api/v1/namespaces/default/pods
</code></pre><p>출력은 다음과 유사하다.</p><pre><code>{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;: &quot;33074&quot;
  },
  &quot;items&quot;: [
    {
      &quot;metadata&quot;: {
        &quot;name&quot;: &quot;kubernetes-bootcamp-2321272333-ix8pt&quot;,
        &quot;generateName&quot;: &quot;kubernetes-bootcamp-2321272333-&quot;,
        &quot;namespace&quot;: &quot;default&quot;,
        &quot;uid&quot;: &quot;ba21457c-6b1d-11e6-85f7-1ef9f1dab92b&quot;,
        &quot;resourceVersion&quot;: &quot;33003&quot;,
        &quot;creationTimestamp&quot;: &quot;2016-08-25T23:43:30Z&quot;,
        &quot;labels&quot;: {
          &quot;pod-template-hash&quot;: &quot;2321272333&quot;,
          &quot;run&quot;: &quot;kubernetes-bootcamp&quot;
        },
        ...
}
</code></pre><h2 id=다음-내용>다음 내용</h2><p><a href=/docs/reference/generated/kubectl/kubectl-commands#proxy>kubectl 프록시</a>에 대해 더 배우기.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-46417c7cdd2da2c530aaeddca1861e5c>11.4 - SOCKS5 프록시를 사용하여 쿠버네티스 API에 접근</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [stable]</code></div><p>이 문서는 SOCKS5 프록시를 사용하여 원격 쿠버네티스 클러스터의 API에 접근하는 방법을 설명한다.
이 기능은 접근하려는 클러스터의 API를 공용 인터넷에 직접 노출하지 않으려고 할 때 유용하다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.24.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><p>SSH 클라이언트 소프트웨어(<code>ssh</code> 도구)와 원격 서버에서 실행되는 SSH 서비스가 필요하다.
원격 서버의 SSH 서비스에 로그인할 수 있어야 한다.</p><h2 id=작업-내용>작업 내용</h2><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 아래 예시는 SSH 클라이언트 및 서버가 SOCKS 프록시 역할을 하는 SSH를 사용하여 트래픽을 터널링(tunnel)한다.
다른 종류의 <a href=https://en.wikipedia.org/wiki/SOCKS#SOCKS5>SOCKS5</a> 프록시를 대신 사용할 수 있다.</div><p>그림 1은 이 작업에서 달성하고자 하는 목표를 나타낸다.</p><ul><li>우선 쿠버네티스 API와 통신을 시작하는 로컬 클라이언트 컴퓨터가 있다.</li><li>쿠버네티스 서버/API는 원격 서버에서 호스팅된다.</li><li>SSH 클라이언트와 서버 소프트웨어를 사용하여 로컬 서버와 원격 서버 간에 보안 SOCKS5 터널을 생성한다.
클라이언트와 쿠버네티스 API 간의 HTTPS 트래픽은 SOCKS5 터널을 통해 전송되며,
터널은 SSH를 통해 터널링된다.</li></ul><p><figure><div class=mermaid>graph LR;
subgraph local[로컬 클라이언트 머신]
client([클라이언트])-- 로컬<br>트래픽 .-> local_ssh[로컬 SSH<br>SOCKS5 프록시];
end
local_ssh[SSH<br>SOCKS5<br>프록시]-- SSH 터널 -->sshd
subgraph remote[원격 서버]
sshd[SSH<br>서버]-- 로컬 트래픽 -->service1;
end
client([클라이언트])-. 프록시된 HTTPs 트래픽<br>프록시를 통과 .->service1[쿠버네티스 API];
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class ingress,service1,service2,pod1,pod2,pod3,pod4 k8s;
class client plain;
class cluster cluster;</div></figure><noscript><div class="alert alert-secondary callout" role=alert><em class=javascript-required>이 컨텐츠를 보려면 자바스크립트가 <a href=https://www.enable-javascript.com/>활성화</a>되어 있어야 합니다.</em></div></noscript>그림 1. SOCKS5 튜토리얼 구성 요소</p><h2 id=ssh를-사용하여-socks5-프록시-생성하기>ssh를 사용하여 SOCKS5 프록시 생성하기</h2><p>아래 커맨드(command)는 클라이언트 컴퓨터와 원격 서버 간에 SOCKS5 프록시를 시작한다.
SOCKS5 프록시를 사용하여 클러스터의 API 서버에 연결할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 아래 커맨드를 실행한 후 SSH 터널은 포그라운드(foreground)에서 실행된다.</span>
</span></span><span style=display:flex><span>ssh -D <span style=color:#666>1080</span> -q -N username@kubernetes-remote-server.example
</span></span></code></pre></div><ul><li><code>-D 1080</code>: SOCKS 프록시를 로컬 포트 1080으로 연다.</li><li><code>-q</code>: quiet 모드. 경고 및 진단 메시지 대부분을 표시하지 않는다.</li><li><code>-N</code>: 원격 커맨드를 실행하지 않는다. 포트 포워딩에 유용.</li><li><code>username@kubernetes-remote-server.example</code>: 쿠버네티스 클러스터가 실행 중인 원격 SSH 서버.</li></ul><h2 id=클라이언트-환경-설정>클라이언트 환경 설정</h2><p>쿠버네티스 API를 사용하려면
먼저, 클라이언트에게 앞에서 만든 SOCKS5 프록시를 통해 쿼리를 전송하도록 지시해야 한다.</p><p><code>https_proxy</code> 환경 변수를 설정하고 실행하는 커맨드를 커맨드라인 툴에 전달한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>https_proxy</span><span style=color:#666>=</span>socks5h://localhost:1080
</span></span></code></pre></div><p><code>https_proxy</code> 변수를 설정하면 <code>curl</code>과 같은 툴은 구성한 프록시를 통해 HTTPS 트래픽을 라우팅한다.
툴이 SOCKS5 프록시를 지원해야 이 기능이 동작한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> URL https://localhost:6443/api에서 <code>localhost</code>는 로컬 클라이언트 컴퓨터를 참조하지 않는다.
대신 <code>localhost</code>라고 알려진 원격 서버의 엔드포인트(endpoint)를 가리킨다.
<code>curl</code> 툴은 호스트 이름을 HTTPS URL에서 SOCKS를 통해 전송하고,
원격 서버는 이것을 로컬(루프백 인터페이스에 속하는 주소)로 처리한다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -k -v https://localhost:6443/api
</span></span></code></pre></div><p>프록시와 함께 공식 쿠버네티스 클라이언트 <code>kubectl</code>을 사용하려면, <code>~/.kube/config</code> 파일에서 관련 <code>cluster</code> 항목에 대한 <code>proxy-url</code> 요소를 설정한다.
예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority-data</span>:<span style=color:#bbb> </span>LRMEMMW2<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 가독성을 위해서 축약함</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://&lt;API_SERVER_IP_ADRESS&gt;:6443 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#34;쿠버네티스 API&#34; 서버, 쿠버네티스-원격-서버의 IP 주소</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>proxy-url</span>:<span style=color:#bbb> </span>socks5://localhost:1080  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 위 다이어그램의 &#34;SSH SOCKS5 프록시&#34; (SOCKS를 통한 DNS 확인 기능 빌트-인)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate-data</span>:<span style=color:#bbb> </span>LS0tLS1CR==<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 가독성을 위해서 축약함</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key-data</span>:<span style=color:#bbb> </span>LS0tLS1CRUdJT=     <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 가독성을 위해서 축약함</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>터널이 동작 중이고 이 클러스터를 사용하는 컨텍스트에서 <code>kubectl</code>을 사용하는 경우 프록시를 통해 클러스터와 상호 작용할 수 있다. 예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>NAMESPACE     NAME                                     READY   STATUS      RESTARTS   AGE
</span></span></span><span style=display:flex><span><span style=color:#888>kube-system   coredns-85cb69466-klwq8                  1/1     Running     0          5m46s
</span></span></span></code></pre></div><h2 id=정리하기>정리하기</h2><p>SSH 포트 포워딩 프로세스가 실행 중인 터미널에서 <code>CTRL+C</code>를 눌러 프로세스를 중지한다.</p><p>터미널에 <code>unset https_proxy</code>를 입력하여 프록시를 통한 http 트래픽 전송을 중지한다.</p><h2 id=더-읽어보기>더 읽어보기</h2><ul><li><a href=https://man.openbsd.org/ssh>OpenSSH 원격 로그인 클라이언트</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-61cf1f2f0fbe98e7635fce65f04a775f>11.5 - Konnectivity 서비스 설정</h1><p>Konnectivity 서비스는 컨트롤 플레인에 클러스터 통신을 위한 TCP 수준 프록시를
제공한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 있어야 하며, kubectl 명령줄 도구가
클러스터와 통신하도록 설정되어 있어야 한다. 컨트롤 플레인 호스트가 아닌
두 개 이상의 노드로 구성된 클러스터에서 이 튜토리얼을 수행하는 것을 권장한다.
클러스터가 없다면, <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>를
이용하여 생성할 수 있다.</p><h2 id=konnectivity-서비스-설정>Konnectivity 서비스 설정</h2><p>다음 단계에는 송신(egress) 설정이 필요하다. 예를 들면 다음과 같다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/konnectivity/egress-selector-configuration.yaml download=admin/konnectivity/egress-selector-configuration.yaml><code>admin/konnectivity/egress-selector-configuration.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-konnectivity-egress-selector-configuration-yaml")' title="Copy admin/konnectivity/egress-selector-configuration.yaml to clipboard"></img></div><div class=includecode id=admin-konnectivity-egress-selector-configuration-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EgressSelectorConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>egressSelections</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 클러스터에 대한 송신(egress) 트래픽을 제어하기 위해 </span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#34;cluster&#34;를 name으로 사용한다. 기타 지원되는 값은 &#34;etcd&#34; 및 &#34;controlplane&#34;이다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>connection</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># API 서버와 Konnectivity 서버 간의 프로토콜을</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 제어한다. 지원되는 값은 &#34;GRPC&#34; 및 &#34;HTTPConnect&#34;이다. 두 모드 간에</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 최종 사용자가 볼 수 있는 차이점은 없다. 동일한 모드에서 작동하도록</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Konnectivity 서버를 설정해야 한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>proxyProtocol</span>:<span style=color:#bbb> </span>GRPC<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>transport</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># API 서버가 Konnectivity 서버와 통신하는 데 사용하는 </span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># transport를 제어한다. Konnectivity 서버가 API 서버와 동일한 시스템에 </span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 있는 경우 UDS를 사용하는 것이 좋다. 동일한 UDS 소켓에서 </span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 수신 대기하도록 Konnectivity 서버를 구성해야 한다. </span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 지원되는 다른 전송은 &#34;tcp&#34;이다. TCP 전송을 보호하려면 TLS 구성을 설정해야 한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>uds</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>udsName</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server/konnectivity-server.socket<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Konnectivity 서비스를 사용하고 네트워크 트래픽을 클러스터 노드로 보내도록
API 서버를 구성해야 한다.</p><ol><li><a href=/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection>Service Account Token Volume Projection</a>
기능이 활성화되어 있는지 확인한다.
쿠버네티스 v1.20부터는 기본적으로 활성화되어 있다.</li><li><code>admin/konnectivity/egress-selector-configuration.yaml</code>과 같은 송신 구성 파일을 생성한다.</li><li>API 서버의 <code>--egress-selector-config-file</code> 플래그를
API 서버 송신 구성 파일의 경로로 설정한다.</li><li>UDS 연결을 사용하는 경우 kube-apiserver에 볼륨 구성을 추가한다.<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-uds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-uds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></span></span></code></pre></div></li></ol><p>konnectivity-server에 대한 인증서 및 kubeconfig를 생성하거나 얻는다.
예를 들어 OpenSSL 커맨드라인 툴을 사용하여 컨트롤 플레인 호스트에서
클러스터 CA 인증서 <code>/etc/kubernetes/pki/ca.crt</code>를 사용하여 X.509 인증서를 발급할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openssl req -subj <span style=color:#b44>&#34;/CN=system:konnectivity-server&#34;</span> -new -newkey rsa:2048 -nodes -out konnectivity.csr -keyout konnectivity.key -out konnectivity.csr
</span></span><span style=display:flex><span>openssl x509 -req -in konnectivity.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out konnectivity.crt -days <span style=color:#666>375</span> -sha256
</span></span><span style=display:flex><span><span style=color:#b8860b>SERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.clusters..server}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>kubectl --kubeconfig /etc/kubernetes/konnectivity-server.conf config set-credentials system:konnectivity-server --client-certificate konnectivity.crt --client-key konnectivity.key --embed-certs<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>kubectl --kubeconfig /etc/kubernetes/konnectivity-server.conf config set-cluster kubernetes --server <span style=color:#b44>&#34;</span><span style=color:#b8860b>$SERVER</span><span style=color:#b44>&#34;</span> --certificate-authority /etc/kubernetes/pki/ca.crt --embed-certs<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>kubectl --kubeconfig /etc/kubernetes/konnectivity-server.conf config set-context system:konnectivity-server@kubernetes --cluster kubernetes --user system:konnectivity-server
</span></span><span style=display:flex><span>kubectl --kubeconfig /etc/kubernetes/konnectivity-server.conf config use-context system:konnectivity-server@kubernetes
</span></span><span style=display:flex><span>rm -f konnectivity.crt konnectivity.key konnectivity.csr
</span></span></code></pre></div><p>다음으로 Konnectivity 서버와 에이전트를 배포해야 한다.
<a href=https://github.com/kubernetes-sigs/apiserver-network-proxy>kubernetes-sigs/apiserver-network-proxy</a>에서
구현을 참조할 수 있다.</p><p>컨트롤 플레인 노드에 Konnectivity 서버를 배포한다. 제공된
<code>konnectivity-server.yaml</code> 매니페스트는
쿠버네티스 구성 요소가 클러스터에 <a class=glossary-tooltip title='특정 노드의 Kubelet 데몬이 직접 관리하는 파드' data-toggle=tooltip data-placement=top href=/ko/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='스태틱 파드(static Pod)'>스태틱 파드(static Pod)</a>로 배포되었다고 가정한다. 그렇지 않은 경우에는 Konnectivity
서버를 데몬셋(DaemonSet)으로 배포할 수 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/konnectivity/konnectivity-server.yaml download=admin/konnectivity/konnectivity-server.yaml><code>admin/konnectivity/konnectivity-server.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-konnectivity-konnectivity-server-yaml")' title="Copy admin/konnectivity/konnectivity-server.yaml to clipboard"></img></div><div class=includecode id=admin-konnectivity-konnectivity-server-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>system-cluster-critical<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-server-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/kas-network-proxy/proxy-server:v0.0.32<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/proxy-server&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--logtostderr=true&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># 이것은 egressSelectorConfiguration에 설정된 값과 일치해야 한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--uds-name=/etc/kubernetes/konnectivity-server/konnectivity-server.socket&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># 다음 두 줄은 Konnectivity 서버가 apiserver와 </span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># 동일한 시스템에 배포되고 API 서버의 인증서와 </span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># 키가 지정된 위치에 있다고 가정한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--cluster-cert=/etc/kubernetes/pki/apiserver.crt&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--cluster-key=/etc/kubernetes/pki/apiserver.key&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># 이것은 egressSelectorConfiguration에 설정된 값과 일치해야 한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--mode=grpc&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--server-port=0&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--agent-port=8132&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--admin-port=8133&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--health-port=8134&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--agent-namespace=kube-system&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--agent-service-account=konnectivity-agent&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--kubeconfig=/etc/kubernetes/konnectivity-server.conf&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#34;--authentication-audience=system:konnectivity-server&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scheme</span>:<span style=color:#bbb> </span>HTTP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span><span style=color:#666>127.0.0.1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8134</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>agentport<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8132</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8132</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>adminport<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8133</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8133</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>healthport<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8134</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8134</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>k8s-certs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/pki<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubeconfig<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server.conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-uds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>k8s-certs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/pki<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubeconfig<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server.conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>FileOrCreate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-uds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/etc/kubernetes/konnectivity-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>그런 다음 클러스터에 Konnectivity 에이전트를 배포한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/konnectivity/konnectivity-agent.yaml download=admin/konnectivity/konnectivity-agent.yaml><code>admin/konnectivity/konnectivity-agent.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-konnectivity-konnectivity-agent-yaml")' title="Copy admin/konnectivity/konnectivity-agent.yaml to clipboard"></img></div><div class=includecode id=admin-konnectivity-konnectivity-agent-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 에이전트를 Deployment(디플로이먼트)로 배포할 수도 있다. 각 노드에 에이전트가</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 있을 필요는 없다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>addonmanager.kubernetes.io/mode</span>:<span style=color:#bbb> </span>Reconcile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>system-cluster-critical<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;CriticalAddonsOnly&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>us.gcr.io/k8s-artifacts-prod/kas-network-proxy/proxy-agent:v0.0.16<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/proxy-agent&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--logtostderr=true&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--ca-cert=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:#080;font-style:italic># konnectivity 서버는 hostNetwork=true로 실행되기 때문에,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:#080;font-style:italic># 이것은 마스터 머신의 IP 주소이다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--proxy-server-host=35.225.206.7&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--proxy-server-port=8132&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--admin-server-port=8133&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--health-server-port=8134&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:#b44>&#34;--service-account-token-path=/var/run/secrets/tokens/konnectivity-agent-token&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/run/secrets/tokens<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-agent-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8134</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-agent-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>konnectivity-agent-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>system:konnectivity-server<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>마지막으로 클러스터에서 RBAC가 활성화된 경우 관련 RBAC 규칙을 생성한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/konnectivity/konnectivity-rbac.yaml download=admin/konnectivity/konnectivity-rbac.yaml><code>admin/konnectivity/konnectivity-rbac.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-konnectivity-konnectivity-rbac-yaml")' title="Copy admin/konnectivity/konnectivity-rbac.yaml to clipboard"></img></div><div class=includecode id=admin-konnectivity-konnectivity-rbac-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:konnectivity-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>addonmanager.kubernetes.io/mode</span>:<span style=color:#bbb> </span>Reconcile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:auth-delegator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:konnectivity-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>konnectivity-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>addonmanager.kubernetes.io/mode</span>:<span style=color:#bbb> </span>Reconcile<span style=color:#bbb>
</span></span></span></code></pre></div></div></div></div><div class=td-content style=page-break-before:always><h1 id=pg-d3c88a8663f58e9ec0bed73faff5b670>12 - TLS</h1><div class=lead>TLS(Transport Layer Security)를 사용하여 클러스터 내 트래픽을 보호하는 방법을 이해한다.</div></div><div class=td-content><h1 id=pg-1272b18ac0c008f6ffc2c62a29fa929f>12.1 - Kubelet의 인증서 갱신 구성</h1><p>이 페이지는 kubelet에 대한 인증서 갱신을 활성화하고 구성하는 방법을 보여준다.</p><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.19 [stable]</code></div><h2 id=시작하기-전에>시작하기 전에</h2><ul><li>쿠버네티스 1.8.0 버전 혹은 그 이상의 버전이 요구됨</li></ul><h2 id=개요>개요</h2><p>kubelet은 쿠버네티스 API 인증을 위해 인증서를 사용한다.
기본적으로 이러한 인증서는 1년 만기로 발급되므로
너무 자주 갱신할 필요는 없다.</p><p>쿠버네티스는 <a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>kubelet 인증서
갱신</a>을 포함하며,
이 기능은 현재 인증서의 만료 시한이 임박한 경우,
새로운 키를 자동으로 생성하고 쿠버네티스 API에서 새로운 인증서를 요청하는 기능이다.
새로운 인증서를 사용할 수 있게 되면
쿠버네티스 API에 대한 연결을 인증하는데 사용된다.</p><h2 id=클라이언트-인증서-갱신-활성화하기>클라이언트 인증서 갱신 활성화하기</h2><p><code>kubelet</code> 프로세스는 현재 사용 중인 인증서의 만료 시한이 다가옴에 따라
kubelet이 자동으로 새 인증서를 요청할지 여부를 제어하는
<code>--rotate-certificates</code> 인자를 허용한다.</p><p><code>kube-controller-manager</code> 프로세스는 얼마나 오랜 기간 인증서가 유효한지를 제어하는
<code>--cluster-signing-duration</code> (1.19 이전은 <code>--experimental-cluster-signing-duration</code>)
인자를 허용한다.</p><h2 id=인증서-갱신-구성에-대한-이해>인증서 갱신 구성에 대한 이해</h2><p>kubelet이 시작할 때 부트 스트랩 (<code>--bootstrap-kubeconfig</code> 플래그를 사용)
을 구성하면 초기 인증서를 사용하여 쿠버네티스 API에 연결하고
인증서 서명 요청을 발행한다.
다음을 사용하여 인증서 서명 요청 상태를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><p>초기에 노드의 kubelet에서 인증서 서명 요청은 <code>Pending</code> 상태이다.
인증서 서명 요청이 특정 기준을 충족하면 컨트롤러 관리자가
자동으로 승인한 후 상태가 <code>Approved</code> 가 된다.
다음으로, 컨트롤러 관리자는
<code>--cluster-signing-duration</code> 파라미터에 의해 지정된 기간 동안
발행된 인증서에 서명하고
서명된 인증서는 인증서 서명 요청에 첨부된다.</p><p>kubelet은 쿠버네티스 API로 서명된 인증서를 가져와서
<code>--cert-dir</code>에 지정된 위치에 디스크에 기록한다.
그런 다음 kubelet은 쿠버네티스 API에 연결해서 새로운 인증서를 사용한다.</p><p>서명된 인증서의 만료가 다가오면 kubelet은 쿠버네티스 API를 사용하여
새로운 인증서 서명 요청을 자동으로 발행한다.
이는 인증서 유효 기간이 30%-10% 남은 시점에 언제든지 실행될 수 있다.
또한, 컨트롤러 관리자는 인증서 요청을 자동으로 승인하고
서명된 인증서를 인증서 서명 요청에 첨부한다.
kubelet은 쿠버네티스 API로 서명된 새로운 인증서를 가져와서 디스크에 쓴다.
그런 다음 새로운 인증서를 사용한 재연결을 위해서
가지고 있는 쿠버네티스 API로의 연결을 업데이트 한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9a87de8ee8332cb487f34a05debb1125>12.2 - 클러스터에서 TLS 인증서 관리</h1><p>쿠버네티스는 사용자가 제어하는 인증 기관 (CA)에서 서명한 TLS 인증서를
프로비저닝 할 수 있는 <code>certificates.k8s.io</code> API를 제공한다.
이러한 CA 및 인증서는 워크로드 간의 신뢰 관계를 구성하는 용도로 사용할 수 있다.</p><p><code>certificates.k8s.io</code> API는 <a href=https://github.com/ietf-wg-acme/acme/>ACME 초안</a>과
유사한 프로토콜을 사용한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>certificates.k8s.io</code> API를 사용하여 생성된 인증서는 <a href=#a-note-to-cluster-administrators>전용 CA</a>로 서명된다.
이러한 목적을 위해 클러스터 루트 CA를 사용하도록 클러스터를
구성할 수 있지만, 절대 이에 의존해서는 안된다.
해당 인증서가 클러스터 루트 CA에 대해 유효성을 검사한다고 가정하면 안된다.</div><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p><code>cfssl</code> 도구가 필요하다.
<a href=https://github.com/cloudflare/cfssl/releases>https://github.com/cloudflare/cfssl/releases</a>에서 <code>cfssl</code>을 다운로드할 수 있다.</p><p>이 페이지의 일부 단계에서 <code>jq</code> 도구를 사용한다.
<code>jq</code>가 없다면, 사용 중인 운영 체제의 소프트웨어 소스를 통해 설치하거나,
<a href=https://stedolan.github.io/jq/>https://stedolan.github.io/jq/</a>에서 받을 수 있다.</p><h2 id=클러스터에서-tls-신뢰>클러스터에서 TLS 신뢰</h2><p>파드로 실행되는 애플리케이션에서 <a href=#a-note-to-cluster-administrators>사용자 정의 CA</a>를 신뢰하려면
일반적으로 몇 가지 추가 애플리케이션 구성이 필요하다.
TLS 클라이언트 또는 서버가 신뢰하는 CA 인증서 목록에
CA 인증서 번들을 추가해야 한다.
예를 들어 인증서 체인을 파싱하고, 파싱된 인증서를 <a href=https://pkg.go.dev/crypto/tls#Config><code>tls.Config</code></a> 구조체의
<code>RootCAs</code> 필드에 추가하여, golang TLS 구성으로 이를 수행할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>사용자 정의 CA 인증서가
파일시스템(<code>kube-root-ca.crt</code> 컨피그맵 내)에 포함될 수 있더라도,
이 인증서 권한을 내부 쿠버네티스 엔드포인트 검증 용도 외에는 사용하지 말아야 한다.
내부 쿠버네티스 엔드포인트에 대한 하나의 예시는
기본 네임스페이스에 있는 <code>kubernetes</code>라는 서비스이다.</p><p>당신의 워크로드를 위한 사용자 정의 인증서 권한을 사용하고 싶다면,
이 CA를 별도로 생성하고, 파드가 읽을 수 있는
<a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그맵</a> 형태로
해당 CA 인증서를 배포해야 한다.</p></div><h2 id=인증서-요청>인증서 요청</h2><p>다음 섹션에서는 DNS를 통해 액세스되는 쿠버네티스 서비스의
TLS 인증서를 생성하는 방법을 보여준다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 튜토리얼에서는 CFSSL을 사용한다. <a href=https://blog.cloudflare.com/introducing-cfssl/>여기를 클릭</a>하여 Cloudflare의 PKI 및 TLS 툴킷을 자세히 알아본다.</div><h2 id=인증서-서명-요청-csr-생성>인증서 서명 요청 (CSR) 생성</h2><p>다음 명령을 실행하여 개인 키 및 인증서 서명 요청(또는 CSR)을
생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | cfssl genkey - | cfssljson -bare server
</span></span></span><span style=display:flex><span><span style=color:#b44>{
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;hosts&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;my-svc.my-namespace.svc.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;192.0.2.24&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;10.0.34.2&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>  ],
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;CN&#34;: &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;key&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;algo&#34;: &#34;ecdsa&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;size&#34;: 256
</span></span></span><span style=display:flex><span><span style=color:#b44>  }
</span></span></span><span style=display:flex><span><span style=color:#b44>}
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>여기서 <code>192.0.2.24</code>는 서비스의 클러스터 IP,
<code>my-svc.my-namespace.svc.cluster.local</code>은 서비스의 DNS 이름,
<code>10.0.34.2</code>는 파드의 IP,<code>my-pod.my-namespace.pod.cluster.local</code>은
파드의 DNS 이름이다. 다음과 비슷한 출력이 표시되어야 한다.</p><pre tabindex=0><code>2022/02/01 11:45:32 [INFO] generate received request
2022/02/01 11:45:32 [INFO] received CSR
2022/02/01 11:45:32 [INFO] generating key: ecdsa-256
2022/02/01 11:45:32 [INFO] encoded CSR
</code></pre><p>이 명령은 두 개의 파일을 생성한다. PEM으로
인코딩된 <a href=https://tools.ietf.org/html/rfc2986>PKCS#10</a>
인증 요청이 포함된 <code>server.csr</code>과 생성할 인증서 키를 PEM 인코딩한 값이
포함된 <code>server-key.pem</code>을 생성한다.</p><h2 id=쿠버네티스-api로-보낼-인증서-서명-요청-객체-만들기>쿠버네티스 API로 보낼 인증서 서명 요청 객체 만들기</h2><p>CSR 매니페스트(YAML 형태)를 생성하고, API 서버로 전송한다.
다음 명령어를 실행하여 수행할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: certificates.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: CertificateSigningRequest
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-svc.my-namespace
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  request: $(cat server.csr | base64 | tr -d &#39;\n&#39;)
</span></span></span><span style=display:flex><span><span style=color:#b44>  signerName: example.com/serving
</span></span></span><span style=display:flex><span><span style=color:#b44>  usages:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - digital signature
</span></span></span><span style=display:flex><span><span style=color:#b44>  - key encipherment
</span></span></span><span style=display:flex><span><span style=color:#b44>  - server auth
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>1단계에서 만든 <code>server.csr</code> 파일은 base64로 인코딩되고
<code>.spec.request</code> 필드에 숨겨져 있다.
또한 예시 <code>example.com/serving</code> 서명자가 서명한
"digitalSignature", "keyEnciperment" 및 "serverAuth" 키 사용(keyUsage)이 있는 인증서를 요청한다.
특정 <code>signerName</code>을 요청해야 한다.
자세한 내용은 <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#signers>지원되는 서명자 이름</a>
문서를 참조한다.</p><p>이제 CSR이 API에서 보류 상태로 표시되어야 한다. 다음을 실행하여
확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe csr my-svc.my-namespace
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Name:                   my-svc.my-namespace
Labels:                 &lt;none&gt;
Annotations:            &lt;none&gt;
CreationTimestamp:      Tue, 01 Feb 2022 11:49:15 -0500
Requesting User:        yourname@example.com
Signer:                 example.com/serving
Status:                 Pending
Subject:
        Common Name:    my-pod.my-namespace.pod.cluster.local
        Serial Number:
Subject Alternative Names:
        DNS Names:      my-pod.my-namespace.pod.cluster.local
                        my-svc.my-namespace.svc.cluster.local
        IP Addresses:   192.0.2.24
                        10.0.34.2
Events: &lt;none&gt;
</code></pre><h2 id=get-the-certificate-signing-request-approved>인증서 서명 요청 승인 받기</h2><p><a href=/docs/reference/access-authn-authz/certificate-signing-requests/>인증서 서명 요청</a> 승인은
자동화된 승인 프로세스 또는 클러스터 관리자의 일회성 승인으로 수행된다.
인증서 요청 승인 권한을 갖고 있다면,
<code>kubectl</code>을 이용하여 다음과 같이 수동으로 승인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl certificate approve my-svc.my-namespace
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>certificatesigningrequest.certificates.k8s.io/my-svc.my-namespace approved
</code></pre><p>출력은 다음과 같을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   10m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved
</code></pre><p>이는 즉 인증서 요청이 승인되었으며
요청받은 서명자의 서명을 기다리고 있음을 나타낸다.</p><h2 id=sign-the-certificate-signing-request>인증서 서명 요청에 서명하기</h2><p>다음으로, 인증서 서명자로서, 인증서를 발급하고, 이를 API에 업로드할 것이다.</p><p>서명자는 일반적으로 인증서 서명 요청 API를 조회하여 오브젝트의 <code>signerName</code>을 확인하고,
요청이 승인되었는지 체크하고, 해당 요청에 대해 인증서에 서명하고,
발급된 인증서로 API 오브젝트 상태를 업데이트한다.</p><h3 id=인증-기관-생성하기>인증 기관 생성하기</h3><p>새 인증서의 디지털 서명에 제공할 인증 기관이 필요하다.</p><p>먼저, 다음을 실행하여 서명 인증서를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | cfssl gencert -initca - | cfssljson -bare ca
</span></span></span><span style=display:flex><span><span style=color:#b44>{
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;CN&#34;: &#34;My Example Signer&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;key&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;algo&#34;: &#34;rsa&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;size&#34;: 2048
</span></span></span><span style=display:flex><span><span style=color:#b44>  }
</span></span></span><span style=display:flex><span><span style=color:#b44>}
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>출력은 다음과 같을 것이다.</p><pre tabindex=0><code class=language-none data-lang=none>2022/02/01 11:50:39 [INFO] generating a new CA key and certificate from CSR
2022/02/01 11:50:39 [INFO] generate received request
2022/02/01 11:50:39 [INFO] received CSR
2022/02/01 11:50:39 [INFO] generating key: rsa-2048
2022/02/01 11:50:39 [INFO] encoded CSR
2022/02/01 11:50:39 [INFO] signed certificate with serial number 263983151013686720899716354349605500797834580472
</code></pre><p>이제 인증 기관 키 파일(<code>ca-key.pem</code>)과 인증서(<code>ca.pem</code>)가 생성되었다.</p><h3 id=인증서-발급하기>인증서 발급하기</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/tls/server-signing-config.json download=tls/server-signing-config.json><code>tls/server-signing-config.json</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("tls-server-signing-config-json")' title="Copy tls/server-signing-config.json to clipboard"></img></div><div class=includecode id=tls-server-signing-config-json><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;signing&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;default&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;usages&#34;</span>: [
</span></span><span style=display:flex><span>                <span style=color:#b44>&#34;digital signature&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#b44>&#34;key encipherment&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#b44>&#34;server auth&#34;</span>
</span></span><span style=display:flex><span>            ],
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;expiry&#34;</span>: <span style=color:#b44>&#34;876000h&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;ca_constraint&#34;</span>: {
</span></span><span style=display:flex><span>                <span style=color:green;font-weight:700>&#34;is_ca&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><p><code>server-signing-config.json</code> 서명 구성 파일, 인증 기관 키 파일 및 인증서를 사용하여
인증서 요청에 서명한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr my-svc.my-namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.request}&#39;</span> | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  base64 --decode | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  cfssl sign -ca ca.pem -ca-key ca-key.pem -config server-signing-config.json - | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  cfssljson -bare ca-signed-server
</span></span></code></pre></div><p>출력은 다음과 같을 것이다.</p><pre tabindex=0><code>2022/02/01 11:52:26 [INFO] signed certificate with serial number 576048928624926584381415936700914530534472870337
</code></pre><p>이제 서명된 제공(serving) 인증서 파일 <code>ca-signed-server.pem</code>이 생성되었다.</p><h3 id=서명된-인증서-업로드하기>서명된 인증서 업로드하기</h3><p>마지막으로, 서명된 인증서를 API 오브젝트의 상태에 기재한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr my-svc.my-namespace -o json | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  jq <span style=color:#b44>&#39;.status.certificate = &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>base64 ca-signed-server.pem | tr -d <span style=color:#b44>&#39;\n&#39;</span><span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34;&#39;</span> | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  kubectl replace --raw /apis/certificates.k8s.io/v1/certificatesigningrequests/my-svc.my-namespace/status -f -
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 위의 명령에서 <code>.status.certificate</code> 필드에 base64로 인코딩된 내용을 채우기 위해
<a href=https://stedolan.github.io/jq/><code>jq</code></a> 명령줄 도구를 사용하였다.
<code>jq</code>가 없다면, JSON 출력을 파일에 저장하고,
해당 필드를 수동으로 채우고, 그 결과 파일을 업로드할 수도 있다.</div><p>인증서 서명 요청이 승인되고 서명된 인증서가 업로드되면 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><p>출력은 다음과 같을 것이다.</p><pre tabindex=0><code class=language-none data-lang=none>NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   20m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved,Issued
</code></pre><h2 id=인증서-다운로드-및-사용>인증서 다운로드 및 사용</h2><p>이제, 요청하는 사용자로서, 다음 명령을 실행하여
발급된 인증서를 다운로드하고 <code>server.crt</code> 파일에 저장할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr my-svc.my-namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.status.certificate}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    | base64 --decode &gt; server.crt
</span></span></code></pre></div><p>이제 <code>server.crt</code> 및 <code>server-key.pem</code>의 내용으로
<a class=glossary-tooltip title='비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿>시크릿</a>을 생성할 수 있으며,
이 시크릿은 추후 파드에 마운트할 수 있다(예를 들어,
HTTPS를 제공하는 웹서버에 사용).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls server --cert server.crt --key server-key.pem
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>secret/server created
</code></pre><p>마지막으로, <code>ca.pem</code>의 내용으로 <a class=glossary-tooltip title='키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>을 생성하여
제공(serving) 인증서 검증에 필요한 신뢰 루트로 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap example-serving-ca --from-file ca.crt<span style=color:#666>=</span>ca.pem
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>configmap/example-serving-ca created
</code></pre><h2 id=approving-certificate-signing-requests>CertificateSigningRequest 승인</h2><p>(적절한 권한이 있는) 쿠버네티스 관리자는
<code>kubectl certificate approve</code> 과 <code>kubectl certificate deny</code>
명령을 사용하여 CertificateSigningRequest을 수동으로 승인 (또는 거부) 할 수 있다.
그러나 이 API를 많이 사용한다면,
자동화된 인증서 컨트롤러 작성을 고려할 수 있다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong><p>CSR을 승인할 수 있는 권한이 있다는 것은 당신의 환경에서 누가 누구를 신뢰할 수 있는지를 결정할 수 있다는 것이다.
CSR을 승인할 수 있는 권한은 넓게/가볍게 부여되지 않아야 한다.</p><p><code>approve</code> 권한을 부여하기 전에,
승인자에게 할당되는 검증 요구 사항 <strong>및</strong> 특정 인증서 발급에 따른 영향을
모두 확실히 이해하고 있는지 확인해야 한다.</p></div><p>위와 같이 kubectl을 사용하는 시스템이든 사람이든, <em>승인자</em> 의 역할은
CSR이 다음 두 가지 요구 사항을 충족하는지 확인하는 것이다.</p><ol><li>CSR은 CSR에 서명하는 데 사용되는 개인 키를 제어하는 것이다. 이는
승인된 대상으로 가장하는 제 3자의 위협을 해결한다. 위의 예에서
이 단계는 파드(pod)가 CSR을 생성하는 데
사용되는 개인 키를 제어하는지 확인하는 것이다.</li><li>CSR은 요청된 상황에서 작동할 권한이 있다. 이것은
원하지 않는 대상이 클러스터에 합류(join)하는 위협을
해결한다. 위의 예에서, 이 단계는
파드가 요청된 서비스에 참여할 수 있는지 확인하는 것이다.</li></ol><p>이 두 가지 요구 사항이 충족되는 경우에만, 승인자가 CSR을 승인하고
그렇지 않으면 CSR을 거부해야 한다.</p><p>인증서 승인 및 접근 제어에 대한 추가 정보를 보려면,
<a href=/docs/reference/access-authn-authz/certificate-signing-requests/>인증서 서명 요청</a> 레퍼런스 페이지를
참조한다.</p><h2 id=서명을-제공하도록-클러스터-구성하기>서명을 제공하도록 클러스터 구성하기</h2><p>이 페이지에서는 서명자가 인증서 API를 제공하도록 설정되었다고 가정한다. 쿠버네티스
컨트롤러 관리자는 서명자의 기본 구현을 제공한다. 이를
활성화하려면 인증 기관(CA)의 키 쌍에 대한 경로와 함께 <code>--cluster-signing-cert-file</code> 와
<code>--cluster-signing-key-file</code> 매개 변수를
컨트롤러 관리자에 전달한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ba58efa15c6d46f10e34d799be220965>13 - 클러스터 데몬 관리</h1><div class=lead>롤링 업데이트 수행과 같은 데몬셋 관리를 위한 일반적인 작업을 수행한다.</div></div><div class=td-content><h1 id=pg-bcfd795e4b59420f7db275a0482af37c>13.1 - 데몬셋(DaemonSet)에서 롤링 업데이트 수행</h1><p>이 페이지는 데몬셋에서 롤링 업데이트를 수행하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=데몬셋-업데이트-전략>데몬셋 업데이트 전략</h2><p>데몬셋에는 두 가지 업데이트 전략 유형이 있다.</p><ul><li><code>OnDelete</code>: <code>OnDelete</code> 업데이트 전략을 사용하여, 데몬셋 템플릿을 업데이트한 후,
이전 데몬셋 파드를 수동으로 삭제할 때 <em>만</em> 새 데몬셋 파드가
생성된다. 이것은 쿠버네티스 버전 1.5 이하에서의 데몬셋의 동작과
동일하다.</li><li><code>RollingUpdate</code>: 기본 업데이트 전략이다.
<code>RollingUpdate</code> 업데이트 전략을 사용하여, 데몬셋 템플릿을
업데이트한 후, 오래된 데몬셋 파드가 종료되고, 새로운 데몬셋 파드는
제어 방식으로 자동 생성된다. 전체 업데이트 프로세스 동안
데몬셋의 최대 하나의 파드가 각 노드에서 실행된다.</li></ul><h2 id=롤링-업데이트-수행>롤링 업데이트 수행</h2><p>데몬셋의 롤링 업데이트 기능을 사용하려면,
<code>.spec.updateStrategy.type</code> 에 <code>RollingUpdate</code> 를 설정해야 한다.</p><p><a href=/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec><code>.spec.updateStrategy.rollingUpdate.maxUnavailable</code></a>
(기본값은 1),
<a href=/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec><code>.spec.minReadySeconds</code></a>
(기본값은 0),
<a href=/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec><code>.spec.updateStrategy.rollingUpdate.maxSurge</code></a>
(기본값은 0)를
설정할 수도 있다.</p><h3 id=rollingupdate-업데이트-전략으로-데몬셋-생성><code>RollingUpdate</code> 업데이트 전략으로 데몬셋 생성</h3><p>이 YAML 파일은 'RollingUpdate'를 업데이트 전략으로 사용하여 데몬셋을 명시한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/controllers/fluentd-daemonset.yaml download=controllers/fluentd-daemonset.yaml><code>controllers/fluentd-daemonset.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-fluentd-daemonset-yaml")' title="Copy controllers/fluentd-daemonset.yaml to clipboard"></img></div><div class=includecode id=controllers-fluentd-daemonset-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>fluentd-logging<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>updateStrategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RollingUpdate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 이 톨러레이션(toleration)은 데몬셋이 컨트롤 플레인 노드에서 실행될 수 있도록 만든다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 컨트롤 플레인 노드가 이 파드를 실행해서는 안 되는 경우, 이 톨러레이션을 제거한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/control-plane<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>quay.io/fluentd_elasticsearch/fluentd:v2.5.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>데몬셋 매니페스트의 업데이트 전략을 확인한 후, 데몬셋을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/controllers/fluentd-daemonset.yaml
</span></span></code></pre></div><p>또는, <code>kubectl apply</code> 로 데몬셋을 업데이트하려는 경우, 동일한 데몬셋을
생성하는 데 <code>kubectl apply</code> 를 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/fluentd-daemonset.yaml
</span></span></code></pre></div><h3 id=데몬셋-rollingupdate-업데이트-전략-확인>데몬셋 <code>RollingUpdate</code> 업데이트 전략 확인</h3><p>데몬셋의 업데이트 전략을 확인하고, <code>RollingUpdate</code> 로 설정되어 있는지
확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ds/fluentd-elasticsearch -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{.spec.updateStrategy.type}}{{&#34;\n&#34;}}&#39;</span> -n kube-system
</span></span></code></pre></div><p>시스템에서 데몬셋을 생성하지 않은 경우, 대신 다음의 명령으로
데몬셋 매니페스트를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/fluentd-daemonset.yaml --dry-run<span style=color:#666>=</span>client -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{.spec.updateStrategy.type}}{{&#34;\n&#34;}}&#39;</span>
</span></span></code></pre></div><p>두 명령의 출력 결과는 다음과 같아야 한다.</p><pre tabindex=0><code>RollingUpdate
</code></pre><p>출력 결과가 <code>RollingUpdate</code> 가 아닌 경우, 이전 단계로 돌아가서 데몬셋 오브젝트나 매니페스트를
적절히 수정한다.</p><h3 id=데몬셋-템플릿-업데이트>데몬셋 템플릿 업데이트</h3><p><code>RollingUpdate</code> 데몬셋 <code>.spec.template</code> 에 대한 업데이트는 롤링 업데이트를
트리거한다. 새 YAML 파일을 적용하여 데몬셋을 업데이트한다. 이것은 여러 가지 다른 <code>kubectl</code> 명령으로 수행할 수 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/controllers/fluentd-daemonset-update.yaml download=controllers/fluentd-daemonset-update.yaml><code>controllers/fluentd-daemonset-update.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-fluentd-daemonset-update-yaml")' title="Copy controllers/fluentd-daemonset-update.yaml to clipboard"></img></div><div class=includecode id=controllers-fluentd-daemonset-update-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>fluentd-logging<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>updateStrategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RollingUpdate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 이 톨러레이션(toleration)은 데몬셋이 컨트롤 플레인 노드에서 실행될 수 있도록 만든다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 컨트롤 플레인 노드가 이 파드를 실행해서는 안 되는 경우, 이 톨러레이션을 제거한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/control-plane<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>quay.io/fluentd_elasticsearch/fluentd:v2.5.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h4 id=선언적-커맨드>선언적 커맨드</h4><p><a href=/ko/docs/tasks/manage-kubernetes-objects/declarative-config/>구성 파일</a>을
사용하여 데몬셋을 업데이트하는 경우,
<code>kubectl apply</code> 를 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/fluentd-daemonset-update.yaml
</span></span></code></pre></div><h4 id=명령형-커맨드>명령형 커맨드</h4><p><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-command/>명령형 커맨드</a>를
사용하여 데몬셋을 업데이트하는 경우,
<code>kubectl edit</code> 를 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit ds/fluentd-elasticsearch -n kube-system
</span></span></code></pre></div><h5 id=컨테이너-이미지만-업데이트>컨테이너 이미지만 업데이트</h5><p>데몬셋 템플릿(예: <code>.spec.template.spec.containers[*].image</code>)에 의해 정의된 컨테이너 이미지만 업데이트하려면,
<code>kubectl set image</code> 를 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image ds/fluentd-elasticsearch fluentd-elasticsearch<span style=color:#666>=</span>quay.io/fluentd_elasticsearch/fluentd:v2.6.0 -n kube-system
</span></span></code></pre></div><h3 id=롤링-업데이트-상태-관찰>롤링 업데이트 상태 관찰</h3><p>마지막으로, 최신 데몬셋 롤링 업데이트의 롤아웃 상태를 관찰한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status ds/fluentd-elasticsearch -n kube-system
</span></span></code></pre></div><p>롤아웃이 완료되면, 출력 결과는 다음과 비슷하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>daemonset <span style=color:#b44>&#34;fluentd-elasticsearch&#34;</span> successfully rolled out
</span></span></code></pre></div><h2 id=문제-해결>문제 해결</h2><h3 id=데몬셋-롤링-업데이트가-더-이상-진행되지-않는다-stuck>데몬셋 롤링 업데이트가 더 이상 진행되지 않는다(stuck)</h3><p>가끔씩, 데몬셋 롤링 업데이트가 더 이상 진행되지 않을 수 있다. 이와 같은 상황이 발생할 수 있는 원인은
다음과 같다.</p><h4 id=일부-노드에-리소스가-부족하다>일부 노드에 리소스가 부족하다</h4><p>적어도 하나의 노드에서 새 데몬셋 파드를 스케줄링할 수 없어서 롤아웃이
중단되었다. 노드에 <a href=/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/>리소스가 부족</a>할 때
발생할 수 있다.</p><p>이 경우, <code>kubectl get nodes</code> 의 출력 결과와 다음의 출력 결과를 비교하여
데몬셋 파드가 스케줄링되지 않은 노드를 찾는다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>fluentd-elasticsearch -o wide -n kube-system
</span></span></code></pre></div><p>해당 노드를 찾으면, 데몬셋이 아닌 파드를 노드에서 삭제하여
새 데몬셋 파드를 위한 공간을 생성한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 삭제된 파드가 컨트롤러에 의해 제어되지 않거나 파드가 복제되지 않은 경우 서비스 중단이
발생한다. 이 때 <a href=/docs/tasks/run-application/configure-pdb/>PodDisruptionBudget</a>정책도 적용되지
않는다.</div><h4 id=롤아웃-실패>롤아웃 실패</h4><p>최근 데몬셋 템플릿 업데이트가 중단된 경우(예를 들어, 컨테이너가
계속 크래시되거나, 컨테이너 이미지가 존재하지 않는 경우(종종 오타로 인해)),
데몬셋 롤아웃이 진행되지 않는다.</p><p>이 문제를 해결하려면, 데몬셋 템플릿을 다시 업데이트한다. 이전의 비정상 롤아웃으로 인해
새로운 롤아웃이 차단되지는 않는다.</p><h4 id=클럭-차이-skew>클럭 차이(skew)</h4><p>데몬셋에 <code>.spec.minReadySeconds</code> 가 명시된 경우, 마스터와 노드 사이의
클럭 차이로 인해 데몬셋이 올바른 롤아웃 진행 상황을 감지할 수
없다.</p><h2 id=정리>정리</h2><p>네임스페이스에서 데몬셋을 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete ds fluentd-elasticsearch -n kube-system
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/manage-daemon/rollback-daemon-set/>데몬셋에서 롤백 수행</a>을 참고한다.</li><li><a href=/ko/docs/concepts/workloads/controllers/daemonset/>기존 데몬셋 파드를 채택하기 위한 데몬셋 생성</a>을 참고한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f1bf7e426f482a85e1a417d1fd9ea7b7>13.2 - 데몬셋(DaemonSet)에서 롤백 수행</h1><p>이 페이지는 <a class=glossary-tooltip title='파드의 복제본을 클러스터 노드 집합에서 동작하게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋>데몬셋</a>에서 롤백을 수행하는 방법을 보여준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p><p>쿠버네티스 클러스터가 필요하고, kubectl 커맨드-라인 툴이 클러스터와
통신할 수 있도록 설정되어 있어야 한다. 이 튜토리얼은 컨트롤 플레인 호스트가 아닌 노드가 적어도 2개 포함된 클러스터에서 실행하는 것을 추천한다. 만약, 아직 클러스터를 가지고
있지 않다면,
<a href=/ko/docs/tasks/tools/#minikube>minikube</a>를 사용해서 생성하거나
다음 쿠버네티스 플레이그라운드 중 하나를 사용할 수 있다.</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=https://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: 1.7.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.</p><p><a href=/ko/docs/tasks/manage-daemon/update-daemon-set/>데몬셋에서 롤링 업데이트를
수행</a>하는 방법을 이미 알고 있어야 한다.</p><h2 id=데몬셋에서-롤백-수행>데몬셋에서 롤백 수행</h2><h3 id=1단계-롤백할-데몬셋-리비전-찾기>1단계: 롤백할 데몬셋 리비전 찾기</h3><p>마지막 리비전으로 롤백하려는 경우 이 단계를 건너뛸 수 있다.</p><p>데몬셋의 모든 리비전을 나열한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> daemonset &lt;daemonset-name&gt;
</span></span></code></pre></div><p>이 명령은 데몬셋 리비전 목록을 반환한다.</p><pre tabindex=0><code>daemonsets &#34;&lt;daemonset-name&gt;&#34;
REVISION        CHANGE-CAUSE
1               ...
2               ...
...
</code></pre><ul><li>변경 원인은 데몬셋 어노테이션 <code>kubernetes.io/change-cause</code> 에서
생성 시의 리비전으로 복사된다. 변경 원인 어노테이션에서 실행된 명령을 기록하도록
<code>kubectl</code> 에 <code>--record=true</code> 를 지정할 수 있다.</li></ul><p>특정 리비전의 세부 사항을 보려면 다음을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> daemonset &lt;daemonset-name&gt; --revision<span style=color:#666>=</span><span style=color:#666>1</span>
</span></span></code></pre></div><p>이 명령은 해당 리비전의 세부 사항을 반환한다.</p><pre tabindex=0><code>daemonsets &#34;&lt;daemonset-name&gt;&#34; with revision #1
Pod Template:
Labels:       foo=bar
Containers:
app:
 Image:        ...
 Port:         ...
 Environment:  ...
 Mounts:       ...
Volumes:      ...
</code></pre><h3 id=2단계-특정-리비전으로-롤백>2단계: 특정 리비전으로 롤백</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># --to-revision에 1단계에서 얻는 리비전 번호를 지정한다</span>
</span></span><span style=display:flex><span>kubectl rollout undo daemonset &lt;daemonset-name&gt; --to-revision<span style=color:#666>=</span>&lt;revision&gt;
</span></span></code></pre></div><p>성공하면, 명령은 다음을 반환한다.</p><pre tabindex=0><code>daemonset &#34;&lt;daemonset-name&gt;&#34; rolled back
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>--to-revision</code> 플래그를 지정하지 않은 경우, kubectl은 가장 최신의 리비전을 선택한다.</div><h3 id=3단계-데몬셋-롤백-진행-상황-확인>3단계: 데몬셋 롤백 진행 상황 확인</h3><p><code>kubectl rollout undo daemonset</code> 은 서버에 데몬셋 롤백을 시작하도록
지시한다. 실제 롤백은 클러스터 <a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>
내에서 비동기적으로 수행된다.</p><p>롤백 진행 상황을 보려면 다음의 명령을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status ds/&lt;daemonset-name&gt;
</span></span></code></pre></div><p>롤백이 완료되면, 출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>daemonset &#34;&lt;daemonset-name&gt;&#34; successfully rolled out
</code></pre><h2 id=데몬셋-리비전의-이해>데몬셋 리비전의 이해</h2><p>이전 <code>kubectl rollout history</code> 단계에서, 데몬셋 리비전 목록을
얻었다. 각 리비전은 ControllerRevision이라는 리소스에 저장된다.</p><p>각 리비전에 저장된 내용을 보려면, 데몬셋 리비전 원시 리소스를
찾는다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get controllerrevision -l &lt;daemonset-selector-key&gt;<span style=color:#666>=</span>&lt;daemonset-selector-value&gt;
</span></span></code></pre></div><p>이 명령은 ControllerRevision의 목록을 반환한다.</p><pre tabindex=0><code>NAME                               CONTROLLER                     REVISION   AGE
&lt;daemonset-name&gt;-&lt;revision-hash&gt;   DaemonSet/&lt;daemonset-name&gt;     1          1h
&lt;daemonset-name&gt;-&lt;revision-hash&gt;   DaemonSet/&lt;daemonset-name&gt;     2          1h
</code></pre><p>각 ControllerRevision은 데몬셋 리비전의 어노테이션과 템플릿을
저장한다.</p><p><code>kubectl rollout undo</code> 는 특정 ControllerRevision을 가져와 데몬셋
템플릿을 ControllerRevision에 저장된 템플릿으로 바꾼다.
<code>kubectl rollout undo</code> 는 <code>kubectl edit</code> 또는 <code>kubectl apply</code> 와 같은 다른 명령을 통해
데몬셋 템플릿을 이전 리비전으로 업데이트하는 것과
같다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 데몬셋 리비전은 롤 포워드만 한다. 즉, 롤백이
완료된 후, 롤백될 ControllerRevision의
리비전 번호(<code>.revision</code> 필드)가 증가한다. 예를 들어,
시스템에 리비전 1과 2가 있고, 리비전 2에서 리비전 1으로 롤백하면,
ControllerRevision은 <code>.revision: 1</code> 에서 <code>.revision: 3</code> 이 된다.</div><h2 id=문제-해결>문제 해결</h2><ul><li><a href=/ko/docs/tasks/manage-daemon/update-daemon-set/#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0>데몬셋 롤링 업데이트
문제 해결</a>을 참고한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a701e71f3b32dae474c63ae4c596c856>14 - 네트워킹</h1><div class=lead>클러스터에 대한 네트워킹 설정 방법에 대해 배운다.</div></div><div class=td-content><h1 id=pg-2edb5b02ea1e646c333c9fe4d5f02ff1>14.1 - HostAliases로 파드의 /etc/hosts 항목 추가하기</h1><p>파드의 <code>/etc/hosts</code> 파일에 항목을 추가하는 것은 DNS나 다른 방법들이 적용되지 않을 때 파드 수준의 호스트네임 해석을 제공한다. PodSpec의 HostAliases 항목을 사용하여 이러한 사용자 정의 항목들을 추가할 수 있다.</p><p>HostAliases를 사용하지 않은 수정은 권장하지 않는데, 이는 호스트 파일이 kubelet에 의해 관리되고, 파드 생성/재시작 중에 덮어쓰여질 수 있기 때문이다.</p><h2 id=기본-호스트-파일-내용>기본 호스트 파일 내용</h2><p>파드 IP가 할당된 Nginx 파드를 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image nginx
</span></span></code></pre></div><pre tabindex=0><code>pod/nginx created
</code></pre><p>파드 IP를 확인해보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><pre tabindex=0><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre><p>호스트 파일의 내용은 아래와 같을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> nginx -- cat /etc/hosts
</span></span></code></pre></div><pre tabindex=0><code># Kubernetes-managed hosts file.
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.4	nginx
</code></pre><p>기본적으로, <code>hosts</code> 파일은 <code>localhost</code>와 자기 자신의 호스트네임과 같은 IPv4와 IPv6
상용구들만 포함하고 있다.</p><h2 id=hostaliases를-사용하여-추가-항목들-추가하기>hostAliases를 사용하여 추가 항목들 추가하기</h2><p>기본 상용구 이외에, 추가 항목들을 <code>hosts</code> 파일에
추가할 수 있다.
예를 들어, <code>foo.local</code>, <code>bar.local</code>이 <code>127.0.0.1</code>로,
<code>foo.remote</code>, <code>bar.remote</code>가 <code>10.1.2.3</code>로 해석될 수 있도록, <code>.spec.hostAliases</code> 항목에서 정의하여 파드에
HostAliases를 추가하면 가능하다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/networking/hostaliases-pod.yaml download=service/networking/hostaliases-pod.yaml><code>service/networking/hostaliases-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-hostaliases-pod-yaml")' title="Copy service/networking/hostaliases-pod.yaml to clipboard"></img></div><div class=includecode id=service-networking-hostaliases-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostaliases-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostAliases</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;127.0.0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.local&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.local&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.remote&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.remote&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cat-hosts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/hosts&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>다음을 실행하여 해당 구성으로 파드를 실행할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/networking/hostaliases-pod.yaml
</span></span></code></pre></div><pre tabindex=0><code>pod/hostaliases-pod created
</code></pre><p>파드의 세부 정보를 검토하여 IPv4 주소와 상태를 확인해보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><pre tabindex=0><code>NAME                           READY     STATUS      RESTARTS   AGE       IP              NODE
hostaliases-pod                0/1       Completed   0          6s        10.200.0.5      worker0
</code></pre><p><code>hosts</code> 파일 내용은 아래와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs hostaliases-pod
</span></span></code></pre></div><pre tabindex=0><code># Kubernetes-managed hosts file.
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.5	hostaliases-pod

# Entries added by HostAliases.
127.0.0.1	foo.local	bar.local
10.1.2.3	foo.remote	bar.remote
</code></pre><p>가장 마지막에 추가 항목들이 정의되어 있는 것을 확인할 수 있다.</p><h2 id=why-does-kubelet-manage-the-hosts-file>왜 Kubelet이 호스트 파일을 관리하는가?</h2><p>컨테이너가 이미 시작되고 난 뒤에
컨테이너 런타임이 <code>hosts</code> 파일을 수정하는 것을 방지하기 위해,
Kubelet이 파드의 각 컨테이너의 <code>hosts</code> 파일을 관리한다.
역사적으로, 쿠버네티스는 컨테이너 런타임으로 계속 도커 엔진을 사용해 왔으며,
각 컨테이너가 시작된 뒤에 도커 엔진이 <code>/etc/hosts</code> 파일을 수정할 수 있었다.</p><p>현재 쿠버네티스는 다양한 컨테이너 런타임을 사용할 수 있으며,
kubelet이 각 컨테이너 내의 <code>hosts</code> 파일을 관리하므로
어떤 컨테이너 런타임을 사용하는지에 상관없이 동일한 결과를 얻을 수 있다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong><p>컨테이너 내부의 호스트 파일을 수동으로 변경하면 안된다.</p><p>호스트 파일을 수동으로 변경하면,
컨테이너가 종료되면 변경 사항이 손실된다.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-eebac062766222247063d6513f95c7b2>14.2 - IPv4/IPv6 이중 스택 검증</h1><p>이 문서는 IPv4/IPv6 이중 스택이 활성화된 쿠버네티스 클러스터들을 어떻게 검증하는지 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li>이중 스택 네트워킹을 위한 제공자 지원 (클라우드 제공자 또는 기타 제공자들은 라우팅 가능한 IPv4/IPv6 네트워크 인터페이스를 제공하는 쿠버네티스 노드들을 제공해야 한다.)</li><li>이중 스택 네트워킹을 지원하는 <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>네트워크 플러그인</a></li><li><a href=/ko/docs/concepts/services-networking/dual-stack/>이중 스택 활성화</a> 클러스터</li></ul>쿠버네티스 서버의 버전은 다음과 같거나 더 높아야 함. 버전: v1.23.
버전 확인을 위해서, 다음 커맨드를 실행 <code>kubectl version</code>.<div class="alert alert-info note callout" role=alert><strong>참고:</strong> v1.23 이전 버전에서도 검증을 수행할 수 있지만 GA 기능으로만 제공되며, v1.23부터 공식적으로 지원된다.</div><h2 id=어드레싱-검증>어드레싱 검증</h2><h3 id=노드-어드레싱-검증>노드 어드레싱 검증</h3><p>각각의 이중 스택 노드는 단일 IPv4 블록 및 단일 IPv6 블록을 할당받아야 한다. IPv4/IPv6 파드 주소 범위를 다음 커맨드를 실행하여 검증한다. 샘플 노드 이름을 클러스터 내 검증된 이중 스택 노드로 대체한다. 본 예제에서, 노드 이름은 <code>k8s-linuxpool1-34450317-0</code> 이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes k8s-linuxpool1-34450317-0 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .spec.podCIDRs}}{{printf &#34;%s\n&#34; .}}{{end}}&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>10.244.1.0/24
2001:db8::/64
</code></pre><p>단일 IPv4 블록과 단일 IPv6 블록이 할당되어야 한다.</p><p>노드가 IPv4 및 IPv6 인터페이스를 가지고 있는지 검증한다. 노드 이름을 클러스터의 검증된 노드로 대체한다. 본 예제에서 노드 이름은 <code>k8s-linuxpool1-34450317-0</code> 이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes k8s-linuxpool1-34450317-0 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .status.addresses}}{{printf &#34;%s: %s\n&#34; .type .address}}{{end}}&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>Hostname: k8s-linuxpool1-34450317-0
InternalIP: 10.0.0.5
InternalIP: 2001:db8:10::5
</code></pre><h3 id=파드-어드레싱-검증>파드 어드레싱 검증</h3><p>파드가 IPv4 및 IPv6 주소를 할당받았는지 검증한다. 파드 이름을 클러스터에서 검증된 파드로 대체한다. 본 예제에서 파드 이름은 <code>pod01</code> 이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods pod01 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .status.podIPs}}{{printf &#34;%s\n&#34; .ip}}{{end}}&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>10.244.1.4
2001:db8::4
</code></pre><p><code>status.podIPs</code> fieldPath를 통한 다운워드(downward) API로 파드 IP들을 검증할 수도 있다. 다음 스니펫은 컨테이너 내 <code>MY_POD_IPS</code> 라는 환경 변수를 통해 파드 IP들을 어떻게 노출시킬 수 있는지 보여준다.</p><pre tabindex=0><code>        env:
        - name: MY_POD_IPS
          valueFrom:
            fieldRef:
              fieldPath: status.podIPs
</code></pre><p>다음 커맨드는 컨테이너 내 <code>MY_POD_IPS</code> 환경 변수의 값을 출력한다. 해당 값은 파드의 IPv4 및 IPv6 주소를 나타내는 쉼표로 구분된 목록이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it pod01 -- <span style=color:#a2f>set</span> | grep MY_POD_IPS
</span></span></code></pre></div><pre tabindex=0><code>MY_POD_IPS=10.244.1.4,2001:db8::4
</code></pre><p>파드의 IP 주소는 또한 컨테이너 내 <code>/etc/hosts</code> 에 적힐 것이다. 다음 커맨드는 이중 스택 파드의 <code>/etc/hosts</code> 에 cat을 실행시킨다. 출력 값을 통해 파드의 IPv4 및 IPv6 주소 모두 검증할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it pod01 -- cat /etc/hosts
</span></span></code></pre></div><pre tabindex=0><code># Kubernetes-managed hosts file.
127.0.0.1    localhost
::1    localhost ip6-localhost ip6-loopback
fe00::0    ip6-localnet
fe00::0    ip6-mcastprefix
fe00::1    ip6-allnodes
fe00::2    ip6-allrouters
10.244.1.4    pod01
2001:db8::4    pod01
</code></pre><h2 id=서비스-검증>서비스 검증</h2><p><code>.spec.ipFamilyPolicy</code> 를 명시적으로 정의하지 않은 다음의 서비스를 생성한다. 쿠버네티스는 처음 구성된 <code>service-cluster-ip-range</code> 에서 서비스에 대한 클러스터 IP를 할당하고 <code>.spec.ipFamilyPolicy</code> 를 <code>SingleStack</code> 으로 설정한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-default-svc-yaml")' title="Copy service/networking/dual-stack-default-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-default-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p><code>kubectl</code> 을 사용하여 서비스의 YAML을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc my-service -o yaml
</span></span></code></pre></div><p>이 서비스에서 <code>.spec.ipFamilyPolicy</code> 를 <code>SingleStack</code> 으로 설정하고 <code>.spec.clusterIP</code> 를 kube-controller-manager의 <code>--service-cluster-ip-range</code> 플래그를 통해 설정된 첫 번째 구성 범위에서 IPv4 주소로 설정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.217.164</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#666>10.0.217.164</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- IPv4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sessionAffinity</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>.spec.ipFamilies</code> 의 첫 번째 배열 요소로 <code>IPv6</code> 을 명시적으로 정의하는 다음 서비스를 생성한다. Kubernetes는 <code>service-cluster-ip-range</code>로 구성된 IPv6 범위에서 서비스용 클러스터 IP를 할당하고 <code>.spec.ipFamilyPolicy</code> 를 <code>SingleStack</code> 으로 설정한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/networking/dual-stack-ipfamilies-ipv6.yaml download=service/networking/dual-stack-ipfamilies-ipv6.yaml><code>service/networking/dual-stack-ipfamilies-ipv6.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-ipfamilies-ipv6-yaml")' title="Copy service/networking/dual-stack-ipfamilies-ipv6.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-ipfamilies-ipv6-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p><code>kubectl</code> 를 사용하여 서비스의 YAML을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc my-service -o yaml
</span></span></code></pre></div><p>이 서비스에서 <code>.spec.ipFamilyPolicy</code> 를 <code>SingleStack</code> 으로 설정하고 <code>.spec.clusterIP</code> 를 kube-controller-manager의 <code>--service-cluster-ip-range</code> 플래그를 통해 설정된 IPv6 범위에서 IPv6 주소로 설정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>2001</span>:db8:fd00::5118<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#666>2001</span>:db8:fd00::5118<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sessionAffinity</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>PreferDualStack</code> 에 <code>.spec.ipFamilyPolicy</code> 을 명시적으로 정의하는 다음 서비스를 생성한다. 쿠버네티스는 IPv4 및 IPv6 주소를 모두 할당하고 (이 클러스터에는 이중 스택을 사용하도록 설정되었으므로) <code>.spec.ipFamilies</code> 배열에 있는 첫 번째 요소의 주소 계열을 기반으로<code>.spec.ClusterIP</code> 목록에서 <code>.spec.ClusterIPs</code> 를 선택한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/networking/dual-stack-preferred-svc.yaml download=service/networking/dual-stack-preferred-svc.yaml><code>service/networking/dual-stack-preferred-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-preferred-svc-yaml")' title="Copy service/networking/dual-stack-preferred-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-preferred-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p><code>kubectl get svc</code> 명령어는 오직 <code>CLUSTER-IP</code> 필드에 주요 IP만 표시한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> kubectl get svc -l app.kubernetes.io/name: MyApp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>   AGE
</span></span><span style=display:flex><span>my-service   ClusterIP   10.0.216.242   &lt;none&gt;        80/TCP    5s
</span></span></code></pre></div></div><p>서비스가 <code>kubectl describe</code> 를 사용하여 IPv4 및 IPv6 주소 블록에서 클러스터 IP를 가져오는지 확인한다. 그런 다음 IP 및 포트를 통해 서비스에 대한 접속을 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe svc -l app.kubernetes.io/name: MyApp
</span></span></code></pre></div><pre tabindex=0><code>Name:              my-service
Namespace:         default
Labels:            app.kubernetes.io/name: MyApp
Annotations:       &lt;none&gt;
Selector:          app.kubernetes.io/name: MyApp
Type:              ClusterIP
IP Family Policy:  PreferDualStack
IP Families:       IPv4,IPv6
IP:                10.0.216.242
IPs:               10.0.216.242,2001:db8:fd00::af55
Port:              &lt;unset&gt;  80/TCP
TargetPort:        9376/TCP
Endpoints:         &lt;none&gt;
Session Affinity:  None
Events:            &lt;none&gt;
</code></pre><h3 id=이중-스택-로드-밸런싱-서비스-생성>이중 스택 로드 밸런싱 서비스 생성</h3><p>만약 클라우드 제공자가 IPv6 기반 외부 로드 밸런서 구성을 지원한다면 <code>.spec.ipFamilyPolicy</code> 의 <code>PreferDualStack</code> 과 <code>.spec.ipFamilies</code> 배열의 첫 번째 요소로 <code>IPv6</code> 및 <code>LoadBalancer</code> 로 설정된 <code>type</code> 필드를 사용하여 다음 서비스를 생성한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/service/networking/dual-stack-prefer-ipv6-lb-svc.yaml download=service/networking/dual-stack-prefer-ipv6-lb-svc.yaml><code>service/networking/dual-stack-prefer-ipv6-lb-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-prefer-ipv6-lb-svc-yaml")' title="Copy service/networking/dual-stack-prefer-ipv6-lb-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-prefer-ipv6-lb-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Check the Service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc -l app.kubernetes.io/name: MyApp
</span></span></code></pre></div><p>서비스가 IPv6 주소 블록에서 <code>CLUSTER-IP</code> 주소 및 <code>EXTERNAL-IP</code> 주소를 할당받는지 검증한다. 그리고 나서 IP 및 포트로 서비스 접근이 가능한지 검증할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME         TYPE           CLUSTER-IP            EXTERNAL-IP        PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>        AGE
</span></span><span style=display:flex><span>my-service   LoadBalancer   2001:db8:fd00::7ebc   2603:1030:805::5   80:30790/TCP   35s
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5ab7bc7f14942c5c4b29d19f4a87271c>15 - GPU 스케줄링</h1><div class=lead>클러스터의 노드별로 리소스로 사용할 GPU를 구성하고 스케줄링한다.</div><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.10 [beta]</code></div><p>쿠버네티스는 AMD 및 NVIDIA GPU(그래픽 프로세싱 유닛)를 노드들에 걸쳐 관리하기 위한 <strong>실험적인</strong>
지원을 포함한다.</p><p>이 페이지는 여러 쿠버네티스 버전에서 사용자가 GPU를 활용할 수 있는 방법과
현재의 제약 사항을 설명한다.</p><h2 id=디바이스-플러그인-사용하기>디바이스 플러그인 사용하기</h2><p>쿠버네티스는 <a class=glossary-tooltip title='파드가 공급자별 초기화 또는 설정이 필요한 장치에 접근할 수 있도록 하는 소프트웨어 확장' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/ target=_blank aria-label='디바이스 플러그인'>디바이스 플러그인</a>을 구현하여
파드가 GPU와 같이 특별한 하드웨어 기능에 접근할 수 있게 한다.</p><p>관리자는 해당하는 하드웨어 벤더의 GPU 드라이버를 노드에
설치해야 하며, GPU 벤더가 제공하는 디바이스 플러그인을
실행해야 한다.</p><ul><li><a href=#amd-gpu-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0>AMD</a></li><li><a href=#nvidia-gpu-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0>NVIDIA</a></li></ul><p>위의 조건이 만족되면, 쿠버네티스는 <code>amd.com/gpu</code> 또는
<code>nvidia.com/gpu</code> 를 스케줄 가능한 리소스로써 노출시킨다.</p><p>사용자는 이 GPU들을 <code>cpu</code> 나 <code>memory</code> 를 요청하는 방식과 동일하게
<code>&lt;vendor>.com/gpu</code> 를 요청함으로써 컨테이너에서 활용할 수 있다.
그러나 GPU를 사용할 때는 리소스 요구 사항을 명시하는 방식에 약간의
제약이 있다.</p><ul><li>GPU는 <code>limits</code> 섹션에서만 명시되는 것을 가정한다. 그 의미는 다음과 같다.<ul><li>쿠버네티스는 limits를 requests의 기본 값으로 사용하게 되므로
사용자는 GPU <code>limits</code> 를 명시할 때 <code>requests</code> 명시하지 않아도 된다.</li><li>사용자는 <code>limits</code> 과 <code>requests</code> 를 모두 명시할 수 있지만, 두 값은
동일해야 한다.</li><li>사용자는 <code>limits</code> 명시 없이는 GPU <code>requests</code> 를 명시할 수 없다.</li></ul></li><li>컨테이너들(그리고 파드들)은 GPU를 공유하지 않는다. GPU에 대한 초과 할당(overcommitting)은 제공되지 않는다.</li><li>각 컨테이너는 하나 이상의 GPU를 요청할 수 있다. GPU의 일부(fraction)를 요청하는 것은
불가능하다.</li></ul><p>다음은 한 예제를 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># https://github.com/kubernetes/kubernetes/blob/v1.7.11/test/images/nvidia-cuda/Dockerfile</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;registry.k8s.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># GPU 1개 요청하기</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=amd-gpu-디바이스-플러그인-배치하기>AMD GPU 디바이스 플러그인 배치하기</h3><p><a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>공식 AMD GPU 디바이스 플러그인</a>에는
다음의 요구 사항이 있다.</p><ul><li>쿠버네티스 노드들에는 AMD GPU 리눅스 드라이버가 미리 설치되어 있어야 한다.</li></ul><p>클러스터가 실행 중이고 위의 요구 사항이 만족된 후, AMD 디바이스 플러그인을 배치하기 위해서는
아래 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://raw.githubusercontent.com/RadeonOpenCompute/k8s-device-plugin/v1.10/k8s-ds-amdgpu-dp.yaml
</span></span></code></pre></div><p><a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>RadeonOpenCompute/k8s-device-plugin</a>에 이슈를 로깅하여
해당 서드 파티 디바이스 플러그인에 대한 이슈를 리포트할 수 있다.</p><h3 id=nvidia-gpu-디바이스-플러그인-배치하기>NVIDIA GPU 디바이스 플러그인 배치하기</h3><p>현재는 NVIDIA GPU에 대한 두 개의 디바이스 플러그인 구현체가 있다.</p><h4 id=공식-nvidia-gpu-디바이스-플러그인>공식 NVIDIA GPU 디바이스 플러그인</h4><p><a href=https://github.com/NVIDIA/k8s-device-plugin>공식 NVIDIA GPU 디바이스 플러그인</a>은
다음의 요구 사항을 가진다.</p><ul><li>쿠버네티스 노드에는 NVIDIA 드라이버가 미리 설치되어 있어야 한다.</li><li>쿠버네티스 노드에는 <a href=https://github.com/NVIDIA/nvidia-docker>nvidia-docker 2.0</a>이 미리 설치되어 있어야 한다.</li><li>Kubelet은 자신의 컨테이너 런타임으로 도커를 사용해야 한다.</li><li>도커는 runc 대신 <code>nvidia-container-runtime</code> 이 <a href=https://github.com/NVIDIA/k8s-device-plugin#preparing-your-gpu-nodes>기본 런타임</a>으로
설정되어야 한다.</li><li>NVIDIA 드라이버의 버전은 조건 ~= 384.81을 만족해야 한다.</li></ul><p>클러스터가 실행 중이고 위의 요구 사항이 만족된 후, NVIDIA 디바이스 플러그인을 배치하기 위해서는
아래 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/1.0.0-beta4/nvidia-device-plugin.yml
</span></span></code></pre></div><p><a href=https://github.com/NVIDIA/k8s-device-plugin>NVIDIA/k8s-device-plugin</a>에 이슈를 로깅하여
해당 서드 파티 디바이스 플러그인에 대한 이슈를 리포트할 수 있다.</p><h4 id=gce에서-사용되는-nvidia-gpu-디바이스-플러그인>GCE에서 사용되는 NVIDIA GPU 디바이스 플러그인</h4><p><a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu>GCE에서 사용되는 NVIDIA GPU 디바이스 플러그인</a>은
nvidia-docker의 사용이 필수가 아니며 컨테이너 런타임 인터페이스(CRI)에
호환되는 다른 컨테이너 런타임을 사용할 수 있다. 해당 사항은
<a href=https://cloud.google.com/container-optimized-os/>컨테이너에 최적화된 OS</a>에서 테스트되었고,
우분투 1.9 이후 버전에 대한 실험적인 코드를 가지고 있다.</p><p>사용자는 다음 커맨드를 사용하여 NVIDIA 드라이버와 디바이스 플러그인을 설치할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 컨테이너에 최적회된 OS에 NVIDIA 드라이버 설치:</span>
</span></span><span style=display:flex><span>kubectl create -f https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/stable/daemonset.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 우분투에 NVIDIA 드라이버 설치(실험적):</span>
</span></span><span style=display:flex><span>kubectl create -f https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/stable/nvidia-driver-installer/ubuntu/daemonset.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 디바이스 플러그인 설치:</span>
</span></span><span style=display:flex><span>kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.14/cluster/addons/device-plugins/nvidia-gpu/daemonset.yaml
</span></span></code></pre></div><p><a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators>GoogleCloudPlatform/container-engine-accelerators</a>에 이슈를 로깅하여
해당 서드 파티 디바이스 플러그인에 대한 이슈를 리포트할 수 있다.</p><p>Google은 GKE에서 NVIDIA GPU 사용에 대한 자체 <a href=https://cloud.google.com/kubernetes-engine/docs/how-to/gpus>설명서</a>를 게재하고 있다.</p><h2 id=다른-타입의-gpu들을-포함하는-클러스터>다른 타입의 GPU들을 포함하는 클러스터</h2><p>만약 클러스터의 노드들이 서로 다른 타입의 GPU를 가지고 있다면, 사용자는
파드를 적합한 노드에 스케줄 하기 위해서
<a href=/ko/docs/tasks/configure-pod-container/assign-pods-nodes/>노드 레이블과 노드 셀렉터</a>를 사용할 수 있다.</p><p>예를 들면,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 노드가 가진 가속기 타입에 따라 레이블을 단다.</span>
</span></span><span style=display:flex><span>kubectl label nodes &lt;node-with-k80&gt; <span style=color:#b8860b>accelerator</span><span style=color:#666>=</span>nvidia-tesla-k80
</span></span><span style=display:flex><span>kubectl label nodes &lt;node-with-p100&gt; <span style=color:#b8860b>accelerator</span><span style=color:#666>=</span>nvidia-tesla-p100
</span></span></code></pre></div><h2 id=node-labeller>노드 레이블링 자동화</h2><p>만약 AMD GPU 디바이스를 사용하고 있다면,
<a href=https://github.com/RadeonOpenCompute/k8s-device-plugin/tree/master/cmd/k8s-node-labeller>노드 레이블러</a>를 배치할 수 있다.
노드 레이블러는 GPU 디바이스의 속성에 따라서 노드에 자동으로 레이블을 달아 주는
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>이다.</p><p>현재 이 컨트롤러는 다음의 속성에 대해 레이블을 추가할 수 있다.</p><ul><li>디바이스 ID (-device-id)</li><li>VRAM 크기 (-vram)</li><li>SIMD 개수 (-simd-count)</li><li>계산 유닛 개수 (-cu-count)</li><li>펌웨어 및 기능 버전 (-firmware)</li><li>GPU 계열, 두 개 문자 형태의 축약어 (-family)<ul><li>SI - Southern Islands</li><li>CI - Sea Islands</li><li>KV - Kaveri</li><li>VI - Volcanic Islands</li><li>CZ - Carrizo</li><li>AI - Arctic Islands</li><li>RV - Raven</li></ul></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node cluster-node-23
</span></span></code></pre></div><pre tabindex=0><code>    Name:               cluster-node-23
    Roles:              &lt;none&gt;
    Labels:             beta.amd.com/gpu.cu-count.64=1
                        beta.amd.com/gpu.device-id.6860=1
                        beta.amd.com/gpu.family.AI=1
                        beta.amd.com/gpu.simd-count.256=1
                        beta.amd.com/gpu.vram.16G=1
                        beta.kubernetes.io/arch=amd64
                        beta.kubernetes.io/os=linux
                        kubernetes.io/hostname=cluster-node-23
    Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock
                        node.alpha.kubernetes.io/ttl: 0
    …
</code></pre><p>노드 레이블러가 사용된 경우, GPU 타입을 파드 스펙에 명시할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># https://github.com/kubernetes/kubernetes/blob/v1.7.11/test/images/nvidia-cuda/Dockerfile</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;registry.k8s.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 또는 nvidia-tesla-k80 등.</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이것은 파드가 사용자가 지정한 GPU 타입을 가진 노드에 스케줄 되도록
만든다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-fdfb2a2cba62a1e624897eaebac0168e>16 - HugePages 관리</h1><div class=lead>클러스터에서 huge page를 스케줄할 수 있는 리소스로 구성하고 관리한다.</div><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><p>쿠버네티스는 파드의 애플리케이션에 미리 할당된
huge page의 할당과 사용을 지원한다. 이 페이지에서는 사용자가 huge page를 사용하는 방법에 대해 설명한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ol><li>쿠버네티스 노드는 노드에 대한 huge page 용량을 보고하기 위해
huge page를 미리 할당해야 한다. 노드는 여러 크기의 huge page를 미리 할당할 수
있다.</li></ol><p>노드는 모든 huge page 리소스를 스케줄 가능한 리소스로 자동 검색하고
보고한다.</p><h2 id=api>API</h2><p>리소스 이름 <code>hugepages-&lt;size></code> (<code>&lt;size></code> 는 특정 노드에서 지원되는 정수값을
사용하는 가장 간단한 2진 표기법)를 사용하여 컨테이너 레벨의 리소스
요구 사항을 통해 huge page를 사용할 수 있다. 예를 들어,
노드가 2048KiB 및 1048576KiB 페이지 크기를 지원하는 경우, 스케줄 가능한
리소스인 <code>hugepages-2Mi</code> 와 <code>hugepages-1Gi</code> 를 노출한다. CPU나 메모리와 달리,
huge page는 오버커밋을 지원하지 않는다. 참고로 hugepage 리소스를 요청하는 경우,
메모리 또는 CPU 리소스도 요청해야 한다.</p><p>파드는 단일 파드 스펙에 여러 개의 huge page 크기를 사용할 수 있다. 이 경우
모든 볼륨 마운트에 대해 <code>medium: HugePages-&lt;hugepagesize></code> 표기법을 사용해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>huge-pages-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:latest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- inf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages-2Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-2mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages-1Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-1gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-2Mi</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-1Gi</span>:<span style=color:#bbb> </span>2Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-2mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages-2Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-1gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages-1Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>파드는 동일한 크기의 huge page들을 요청하는 경우에만 <code>medium: HugePages</code> 를 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>huge-pages-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:latest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- inf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-2Mi</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li>Huge page 요청(requests)은 제한(limits)과 같아야 한다. 제한이 지정되었지만, 요청은 지정되지 않은 경우
이것이 기본값이다.</li><li>Huge page는 컨테이너 범위에서 격리되므로, 각 컨테이너에는 컨테이너 사양에서 요청한대로
cgroup 샌드박스에 대한 제한이 있다.</li><li>Huge page가 지원하는 EmptyDir 볼륨은 파드 요청보다 더 많은 huge page 메모리를
사용하지 말아야 한다.</li><li><code>shmget()</code> 의 <code>SHM_HUGETLB</code> 를 통해 huge page를 사용하는 애플리케이션은
<code>proc/sys/vm/hugetlb_shm_group</code> 과 일치하는 보충 그룹(supplemental group)으로 실행해야 한다.</li><li>네임스페이스에서의 huge page 사용은 <code>hugepages-&lt;size></code> 토큰을 사용하는 <code>cpu</code> 또는 <code>memory</code> 와 같은
다른 컴퓨트 리소스와 비슷한 리소스쿼터(ResourceQuota)를 통해 제어할 수
있다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0c4484d31ad3902880897e694bbd306f>17 - kubelet 이미지 자격 증명 공급자 구성하기</h1><div class=lead>kubelet의 이미지 자격 증명 공급자 플러그인을 구성한다.</div><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [beta]</code></div><p>쿠버네티스 v1.20부터 kubelet은 exec 플러그인을 사용하여 컨테이너 이미지 레지스트리에 대한 자격 증명(credential)을 동적으로 검색할 수 있다.
kubelet과 exec 플러그인은 쿠버네티스 버전 API를 사용하여 stdio(stdin, stdout, stderr)를 통해 통신한다.
kubelet은 플러그인을 통해 정적 자격 증명을 디스크에 저장하는 대신 컨테이너 레지스트리에 대한 자격 증명을 동적으로 요청할 수 있다.
예를 들어, 플러그인은 로컬 메타데이터 서버와 통신하여 kubelet에 의해 풀(pulled) 된
이미지에 대한 단기 유효(short-lived) 자격 증명을 검색할 수 있다.</p><p>아래 중 하나에 해당하면 이 기능의 사용을 고려해도 좋다.</p><ul><li>레지스트리에 대한 인증 정보를 찾기 위해 클라우드 공급자 서비스에 대한 API 호출이 필요할 때.</li><li>자격 증명 만료 시간이 짧아 새 자격 증명 요청이 자주 필요할 때.</li><li>레지스트리 자격 증명을 디스크 또는 이미지 풀 시크릿에 저장하는 것을 허용하지 않을 때.</li></ul><p>이 가이드는 kubelet의 이미지 자격 증명 공급자 플러그인 메커니즘을 구성하는 방법을 보여 준다.</p><h2 id=시작하기-전에>시작하기 전에</h2><ul><li>kubelet 이미지 자격 증명 공급자는 알파(alpha) 기능으로 v1.20에서 도입되었다.
이 기능을 구동하려면, 다른 알파 기능과 마찬가지로 기능 게이트(feature gate) <code>KubeletCredentialProviders</code>가 kubelet에서만 활성화되어야 한다.</li><li>자격 증명 공급자 exec 플러그인에 대한 구현체(implementation)가 필요하다. 이를 위해 자체 플러그인을 구축하거나 클라우드 공급자가 제공하는 플러그인을 사용할 수 있다.</li></ul><h2 id=노드에-플러그인-설치하기>노드에 플러그인 설치하기</h2><p>자격 증명 공급자 플러그인은 kubelet에 의해 실행될 실행 가능한 바이너리이다. 클러스터의 모든 노드에 플러그인 바이너리가 있고 알려진 디렉터리에 저장됐는지 확인한다.
이후 kubelet 플래그를 구성할 때 해당 디렉터리가 필요하다.</p><h2 id=kubelet-구성하기>kubelet 구성하기</h2><p>이 기능을 사용하려면 kubelet에 두 개의 플래그가 설정돼야 한다.</p><ul><li><code>--image-credential-provider-config</code> - 자격 증명 공급자 플러그인 구성 파일 경로.</li><li><code>--image-credential-provider-bin-dir</code> - 자격 증명 공급자 플러그인 바이너리 파일이 있는 디렉터리 경로.</li></ul><h3 id=kubelet-자격-증명-공급자-구성>kubelet 자격 증명 공급자 구성</h3><p>kubelet은 <code>--image-credential-provider-config</code>로 전달된 구성 파일을 읽고,
컨테이너 이미지에 대해 어떤 exec 플러그인을 호출할지 결정한다.
<a href=https://aws.amazon.com/ecr/>ECR</a>-based 플러그인을 사용하는 경우 사용하게 될 수 있는 구성 파일의 예:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CredentialProviderConfig<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># providers is a list of credential provider plugins that will be enabled by the kubelet.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Multiple providers may match against a single image, in which case credentials</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># from all providers will be returned to the kubelet. If multiple providers are called</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># for a single image, the results are combined. If providers return overlapping</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># auth keys, the value from the provider earlier in this list is used.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>providers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># name is the required name of the credential provider. It must match the name of the</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># provider executable as seen by the kubelet. The executable must be in the kubelet&#39;s</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># bin directory (set by the --image-credential-provider-bin-dir flag).</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ecr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># matchImages is a required list of strings used to match against images in order to</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># determine if this provider should be invoked. If one of the strings matches the</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># requested image from the kubelet, the plugin will be invoked and given a chance</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># to provide credentials. Images are expected to contain the registry domain</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># and URL path.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Each entry in matchImages is a pattern which can optionally contain a port and a path.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Globs can be used in the domain, but not in the port or the path. Globs are supported</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># as subdomains like &#39;*.k8s.io&#39; or &#39;k8s.*.io&#39;, and top-level-domains such as &#39;k8s.*&#39;.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Matching partial subdomains like &#39;app*.k8s.io&#39; is also supported. Each glob can only match</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># a single subdomain segment, so *.io does not match *.k8s.io.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># A match exists between an image and a matchImage when all of the below are true:</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - Both contain the same number of domain parts and each part matches.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - The URL path of an imageMatch must be a prefix of the target image URL path.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - If the imageMatch contains a port, then the port must match in the image as well.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Example values of matchImages:</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - 123456789.dkr.ecr.us-east-1.amazonaws.com</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - *.azurecr.io</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - gcr.io</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - *.*.registry.io</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - registry.io:8080/path</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchImages</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;*.dkr.ecr.*.amazonaws.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;*.dkr.ecr.*.amazonaws.cn&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;*.dkr.ecr-fips.*.amazonaws.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;*.dkr.ecr.us-iso-east-1.c2s.ic.gov&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;*.dkr.ecr.us-isob-east-1.sc2s.sgov.gov&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># defaultCacheDuration is the default duration the plugin will cache credentials in-memory</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># if a cache duration is not provided in the plugin response. This field is required.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultCacheDuration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;12h&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Required input version of the exec CredentialProviderRequest. The returned CredentialProviderResponse</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># MUST use the same encoding version as the input. Current supported values are:</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - credentialprovider.kubelet.k8s.io/v1alpha1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>credentialprovider.kubelet.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Arguments to pass to the command when executing it.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># +optional</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- get-credentials<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Env defines additional environment variables to expose to the process. These</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># are unioned with the host&#39;s environment, as well as variables client-go uses</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># to pass argument to the plugin.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># +optional</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>AWS_PROFILE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>example_profile<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>providers</code> 필드는 kubelet에서 사용되는 활성화된 플러그인의 목록으로, 각 항목에는 몇 가지 필수 필드가 있다.</p><ul><li><code>name</code>: <code>--image-credential-provider-bin-dir</code>로 전달된 디렉터리에 존재하는
실행 가능한 바이너리의 이름과 반드시 일치해야 하는 플러그인의 이름.</li><li><code>matchImages</code>: 이 공급자를 호출할지 결정하기 위해 이미지를 대조하는 데 사용되는 문자열 목록.
아래의 더 많은 내용 참조.</li><li><code>defaultCacheDuration</code>: 플러그인에 의해 캐시 기간이 지정되지 않으면,
kubelet이 메모리에 자격 증명을 캐시하는 기본 기간.</li><li><code>apiVersion</code>: kubelet과 exec 플러그인이 통신할 때 사용하는 API 버전.</li></ul><p>각 자격 증명 공급자에게 인수(arg) 및 환경 변수도 선택적으로 제공할 수 있다.
플러그인에 필요한 인수 및 환경 변수 집합을 확인하려면 해당 플러그인 구현자에게 문의하는 것이 좋다.</p><h4 id=이미지-매칭-구성>이미지 매칭 구성</h4><p>kubelet은 각 자격 증명 공급자에 대한 <code>matchImages</code> 필드를 사용해 파드가 사용하고 있는 특정 이미지에 대해 플러그인을 호출할지 결정한다.
Globs는 도메인에서 사용할 수 있지만 포트나 경로에서는 사용할 수 없다.
Glob은 <code>*.k8s.io</code>이나 <code>k8s.*.io</code> 같은 서브도메인과 <code>k8s.*</code>와 같은 최상위 도메인으로 지원된다.
또한, <code>app*.k8s.io</code>와 같은 부분 서브도메인을 매칭하는 것도 지원된다.
각 Glob은 단일 하위 도메인 세그먼트만 일치할 수 있으므로 <code>*.io</code>는 <code>*.k8s.io</code>과 일치하지 않는다.</p><p>아래와 같은 경우 이미지 이름과 <code>matchImage</code> 항목 사이에 매치가 존재한다.</p><ul><li>둘 다 동일한 수의 도메인 파트를 포함하고 있으며 각 파트가 매치한다.</li><li>매치 이미지의 URL 경로는 대상 이미지 URL 경로의 접두사여야 한다.</li><li>imageMatch에 포트가 포함되어 있으면 해당 포트는 이미지에서도 매치해야 한다.</li></ul><p><code>matchImages</code> 패턴의 예시 값은 아래와 같다.</p><ul><li><code>123456789.dkr.ecr.us-east-1.amazonaws.com</code></li><li><code>*.azurecr.io</code></li><li><code>gcr.io</code></li><li><code>*.*.registry.io</code></li><li><code>foo.registry.io:8080/path</code></li></ul><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/reference/config-api/kubelet-config.v1alpha1/>kubelet 구성 API(v1alpha1) 레퍼런스</a>에서
<code>CredentialProviderConfig</code>에 대한 세부 정보 읽기</li><li><a href=/docs/reference/config-api/kubelet-credentialprovider.v1alpha1/>kubelet 자격 증명 공급자 API (v1alpha1) 레퍼런스</a> 읽기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f34d6e348a8e677d6c6eb155cd1a99aa>18 - 플러그인으로 kubectl 확장</h1><div class=lead>kubectl 플러그인을 작성하고 설치해서 kubectl을 확장한다.</div><p>이 가이드는 <a href=/ko/docs/reference/kubectl/kubectl/>kubectl</a> 확장을 설치하고 작성하는 방법을 보여준다. 핵심 <code>kubectl</code> 명령을 쿠버네티스 클러스터와 상호 작용하기 위한 필수 구성 요소로 생각함으로써, 클러스터 관리자는
플러그인을 이러한 구성 요소를 활용하여 보다 복잡한 동작을 만드는 수단으로 생각할 수 있다. 플러그인은 새로운 하위 명령으로 <code>kubectl</code> 을 확장하고, 주요 배포판에 포함되지 않은 <code>kubectl</code> 의 새로운 사용자 정의 기능을 허용한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>동작하는 <code>kubectl</code> 바이너리가 설치되어 있어야 한다.</p><h2 id=kubectl-플러그인-설치>kubectl 플러그인 설치</h2><p>플러그인은 이름이 <code>kubectl-</code> 로 시작되는 독립형 실행 파일이다. 플러그인을 설치하려면, 실행 파일을 <code>PATH</code> 에 지정된 디렉터리로 옮기면 된다.</p><p><a href=https://krew.dev/>Krew</a>를 사용하여 오픈소스에서 사용 가능한
kubectl 플러그인을 검색하고 설치할 수도 있다. Krew는 쿠버네티스 SIG CLI 커뮤니티에서 관리하는
플러그인 관리자이다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> Krew <a href=https://krew.sigs.k8s.io/plugins/>플러그인 인덱스</a>를 통해 사용할 수 있는 kubectl 플러그인은
보안 감사를 받지 않는다. 써드파티 플러그인은 시스템에서 실행되는 임의의
프로그램이므로, 사용자는 이를 인지한 상태에서 설치하고 실행해야 한다.</div><h3 id=플러그인-디스커버리>플러그인 디스커버리</h3><p><code>kubectl</code> 은 유효한 플러그인 실행 파일을 <code>PATH</code> 에서 검색하는 <code>kubectl plugin list</code> 명령을 제공한다.
이 명령을 실행하면 <code>PATH</code> 에 있는 모든 파일을 탐색한다. 실행 가능하고, <code>kubectl-</code> 로 시작하는 모든 파일은 이 명령의 출력 결과에 <em><code>PATH</code> 에 있는 순서대로</em> 표시된다.
실행 파일이 <em>아닌</em> 파일이 <code>kubectl-</code> 시작하는 경우 경고가 포함된다.
서로의 이름과 겹치는 유효한 플러그인 파일에 대한 경고도 포함된다.</p><p><a href=https://krew.dev/>Krew</a>를 사용하여 커뮤니티가 관리하는
<a href=https://krew.sigs.k8s.io/plugins/>플러그인 인덱스</a>에서 <code>kubectl</code>
플러그인을 검색하고 설치할 수 있다.</p><h4 id=제한-사항>제한 사항</h4><p>현재 기존 <code>kubectl</code> 명령을 덮어 쓰는 플러그인을 생성할 수 없다. 예를 들어, 플러그인 <code>kubectl-version</code> 을 만들면 기존의 <code>kubectl version</code> 명령이 항상 우선하므로, 플러그인이 실행되지 않는다. 이 제한으로 인해, 플러그인을 사용하여 기존 <code>kubectl</code> 명령에 새로운 하위 명령을 추가할 수도 <em>없다</em>. 예를 들어, 플러그인 이름을 <code>kubectl-create-foo</code> 로 지정하여 <code>kubectl create foo</code> 하위 명령을 추가하면 해당 플러그인이 무시된다.</p><p><code>kubectl plugin list</code> 는 이를 시도하는 유효한 플러그인에 대한 경고를 표시한다.</p><h2 id=kubectl-플러그인-작성>kubectl 플러그인 작성</h2><p>커맨드-라인 명령을 작성할 수 있는 프로그래밍 언어나 스크립트로 플러그인을 작성할 수 있다.</p><p>플러그인 설치 또는 사전 로딩이 필요하지 않다. 플러그인 실행 파일은
<code>kubectl</code> 바이너리에서 상속된 환경을 받는다.
플러그인은 이름을 기반으로 구현할 명령 경로를 결정한다.
예를 들어, <code>kubectl-foo</code> 라는 플러그인은 <code>kubectl foo</code> 명령을 제공한다.
<code>PATH</code> 어딘가에 플러그인 실행 파일을 설치해야 한다.</p><h3 id=플러그인-예제>플러그인 예제</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#080></span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 선택적 인수 처리</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>[[</span> <span style=color:#b44>&#34;</span><span style=color:#b8860b>$1</span><span style=color:#b44>&#34;</span> <span style=color:#666>==</span> <span style=color:#b44>&#34;version&#34;</span> <span style=color:#666>]]</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>then</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;1.0.0&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f>exit</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 선택적 인수 처리</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>[[</span> <span style=color:#b44>&#34;</span><span style=color:#b8860b>$1</span><span style=color:#b44>&#34;</span> <span style=color:#666>==</span> <span style=color:#b44>&#34;config&#34;</span> <span style=color:#666>]]</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>then</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#b8860b>$KUBECONFIG</span><span style=color:#b44>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f>exit</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;I am a plugin named kubectl-foo&#34;</span>
</span></span></code></pre></div><h3 id=플러그인-사용>플러그인 사용</h3><p>플러그인을 사용하려면, 실행 가능하게 만든다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo chmod +x ./kubectl-foo
</span></span></code></pre></div><p>그리고 <code>PATH</code> 의 어느 곳에나 옮겨 놓는다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo mv ./kubectl-foo /usr/local/bin
</span></span></code></pre></div><p>이제 플러그인을 <code>kubectl</code> 명령으로 호출할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl foo
</span></span></code></pre></div><pre tabindex=0><code>I am a plugin named kubectl-foo
</code></pre><p>모든 인수와 플래그는 그대로 실행 파일로 전달된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl foo version
</span></span></code></pre></div><pre tabindex=0><code>1.0.0
</code></pre><p>모든 환경 변수도 실행 파일로 그대로 전달된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config
</span></span><span style=display:flex><span>kubectl foo config
</span></span></code></pre></div><pre tabindex=0><code>/home/&lt;user&gt;/.kube/config
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>/etc/kube/config kubectl foo config
</span></span></code></pre></div><pre tabindex=0><code>/etc/kube/config
</code></pre><p>또한, 플러그인으로 전달되는 첫 번째 인수는 항상 호출된 위치의 전체 경로이다(위의 예에서 <code>$0</code> 은 <code>/usr/local/bin/kubectl-foo</code> 와 동일하다).</p><h3 id=플러그인-이름-지정>플러그인 이름 지정</h3><p>위 예제에서 볼 수 있듯이, 플러그인은 파일명을 기반으로 구현할 명령 경로를 결정한다. 플러그인이 대상으로 하는 명령 경로의 모든 하위 명령은 대시(<code>-</code>)로 구분된다.
예를 들어, 사용자가 <code>kubectl foo bar baz</code> 명령을 호출할 때마다 호출되는 플러그인은 파일명이 <code>kubectl-foo-bar-baz</code> 이다.</p><h4 id=플래그와-인수-처리>플래그와 인수 처리</h4><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>플러그인 메커니즘은 플러그인 프로세스에 대한 사용자 정의, 플러그인 특정 값 또는 환경 변수를 생성하지 <em>않는다</em>.</p><p>이전 kubectl 플러그인 메커니즘은 <code>KUBECTL_PLUGINS_CURRENT_NAMESPACE</code> 와 같이 더이상 사용하지 않는 환경 변수를 제공했다.</p></div><p>kubectl 플러그인은 전달된 모든 인수를 파싱하고 유효성을 검사해야 한다.
플러그인 작성자를 대상으로 하는 Go 라이브러리에 대한 자세한 내용은 <a href=#%EC%BB%A4%EB%A7%A8%EB%93%9C-%EB%9D%BC%EC%9D%B8-%EB%9F%B0%ED%83%80%EC%9E%84-%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%82%AC%EC%9A%A9>커맨드 라인 런타임 패키지 사용</a>을 참고한다.</p><p>다음은 사용자가 추가 플래그와 인수를 제공하면서 플러그인을 호출하는 추가 사례이다. 이것은 위 시나리오의 <code>kubectl-foo-bar-baz</code> 플러그인을 기반으로한다.</p><p><code>kubectl foo bar baz arg1 --flag=value arg2</code> 를 실행하면, kubectl의 플러그인 메커니즘은 먼저 가장 긴 가능한 이름을 가진 플러그인을 찾으려고 시도한다. 여기서는
<code>kubectl-foo-bar-baz-arg1</code> 이다. 해당 플러그인을 찾지 못하면, kubectl은 대시로 구분된 마지막 값을 인수(여기서는 <code>arg1</code>)로 취급하고, 다음으로 가장 긴 가능한 이름인 <code>kubectl-foo-bar-baz</code> 를 찾는다.
이 이름의 플러그인을 찾으면, kubectl은 해당 플러그인을 호출하여, 플러그인 이름 뒤에 모든 인수와 플래그를 플러그인 프로세스의 인수로 전달한다.</p><p>예:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 플러그인 생성</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -e <span style=color:#b44>&#39;#!/bin/bash\n\necho &#34;My first command-line argument was $1&#34;&#39;</span> &gt; kubectl-foo-bar-baz
</span></span><span style=display:flex><span>sudo chmod +x ./kubectl-foo-bar-baz
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># $PATH에 있는 디렉터리로 옮겨 플러그인을 &#34;설치&#34;</span>
</span></span><span style=display:flex><span>sudo mv ./kubectl-foo-bar-baz /usr/local/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 플러그인을 kubectl이 인식하는지 확인</span>
</span></span><span style=display:flex><span>kubectl plugin list
</span></span></code></pre></div><pre tabindex=0><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-foo-bar-baz
</code></pre><pre tabindex=0><code># test that calling your plugin via a &#34;kubectl&#34; command works
# even when additional arguments and flags are passed to your
# plugin executable by the user.
kubectl foo bar baz arg1 --meaningless-flag=true
</code></pre><pre tabindex=0><code>My first command-line argument was arg1
</code></pre><p>보시다시피, 사용자가 지정한 <code>kubectl</code> 명령을 기반으로 플러그인을 찾았으며, 모든 추가 인수와 플래그는 플러그인 실행 파일이 발견되면 그대로 전달된다.</p><h4 id=대시와-언더스코어가-있는-이름>대시와 언더스코어가 있는 이름</h4><p><code>kubectl</code> 플러그인 메커니즘은 플러그인 파일명에 대시(<code>-</code>)를 사용하여 플러그인이 처리하는 하위 명령 시퀀스를 분리하지만, 파일명에
언더스코어(<code>_</code>)를 사용하여 커맨드 라인 호출에 대시를 포함하는 플러그인 명령을 생성할 수 있다.</p><p>예:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 파일명에 언더스코어(_)가 있는 플러그인 생성</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -e <span style=color:#b44>&#39;#!/bin/bash\n\necho &#34;I am a plugin with a dash in my name&#34;&#39;</span> &gt; ./kubectl-foo_bar
</span></span><span style=display:flex><span>sudo chmod +x ./kubectl-foo_bar
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># $PATH에 플러그인을 옮긴다</span>
</span></span><span style=display:flex><span>sudo mv ./kubectl-foo_bar /usr/local/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이제 kubectl을 통해 플러그인을 사용할 수 있다</span>
</span></span><span style=display:flex><span>kubectl foo-bar
</span></span></code></pre></div><pre tabindex=0><code>I am a plugin with a dash in my name
</code></pre><p>참고로 플러그인 파일명에 언더스코어를 추가해도 <code>kubectl foo_bar</code> 와 같은 명령을 사용할 수 있다.
위 예에서 명령은 대시(<code>-</code>) 또는 언더스코어(<code>_</code>)을 사용하여 호출할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 대시를 포함한 사용자 정의 명령을 사용할 수 있다</span>
</span></span><span style=display:flex><span>kubectl foo-bar
</span></span></code></pre></div><pre tabindex=0><code>I am a plugin with a dash in my name
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 언더스코어를 포함한 사용자 정의 명령을 사용할 수도 있다</span>
</span></span><span style=display:flex><span>kubectl foo_bar
</span></span></code></pre></div><pre tabindex=0><code>I am a plugin with a dash in my name
</code></pre><h4 id=이름-충돌과-오버셰도잉-overshadowing>이름 충돌과 오버셰도잉(overshadowing)</h4><p><code>PATH</code> 의 다른 위치에 동일한 파일명을 가진 여러 플러그인이 있을 수 있다.
예를 들어, <code>PATH</code> 값이 <code>PATH=/usr/local/bin/plugins:/usr/local/bin/moreplugins</code> 로 주어지고, <code>kubectl-foo</code> 플러그인을 복사한 파일이 <code>/usr/local/bin/plugins</code> 와 <code>/usr/local/bin/moreplugins</code> 에 있을 수 있다.
<code>kubectl plugin list</code> 명령의 출력 결과는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>PATH</span><span style=color:#666>=</span>/usr/local/bin/plugins:/usr/local/bin/moreplugins kubectl plugin list
</span></span></code></pre></div><pre tabindex=0><code>The following kubectl-compatible plugins are available:

/usr/local/bin/plugins/kubectl-foo
/usr/local/bin/moreplugins/kubectl-foo
  - warning: /usr/local/bin/moreplugins/kubectl-foo is overshadowed by a similarly named plugin: /usr/local/bin/plugins/kubectl-foo

error: one plugin warning was found
</code></pre><p>위 시나리오에서, <code>/usr/local/bin/moreplugins/kubectl-foo</code> 아래의 경고는 이 플러그인이 실행되지 않을 것임을 알려준다. 대신, <code>PATH</code> 에 먼저 나타나는 실행 파일인 <code>/usr/local/bin/plugins/kubectl-foo</code> 는 항상 발견되고 <code>kubectl</code> 플러그인 메카니즘에 의해 먼저 실행된다.</p><p>이 문제를 해결하는 방법은 <code>kubectl</code> 와 함께 사용하려는 플러그인의 위치가 <code>PATH</code> 에 항상에서 먼저 오도록 하는 것이다. 예를 들어, <code>kubectl</code> 명령 <code>kubectl foo</code> 가 호출될 때마다 항상 <code>/usr/local/bin/moreplugins/kubectl-foo</code> 를 사용하려면, <code>PATH</code> 의 값을 <code>/usr/local/bin/moreplugins:/usr/local/bin/plugins</code> 로 변경한다.</p><h4 id=가장-긴-실행-파일명의-호출>가장 긴 실행 파일명의 호출</h4><p>플러그인 파일명으로 발생할 수 있는 또 다른 종류의 오버셰도잉이 있다. 사용자의 <code>PATH</code> 에 <code>kubectl-foo-bar</code> 와 <code>kubectl-foo-bar-baz</code> 라는 두 개의 플러그인이 있다면, <code>kubectl</code> 플러그인 메커니즘은 항상 주어진 사용자의 명령에 대해 가장 긴 가능한 플러그인 이름을 선택한다. 아래에 몇 가지 예가 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 주어진 kubectl 명령의 경우, 가장 긴 가능한 파일명을 가진 플러그인이 항상 선호된다</span>
</span></span><span style=display:flex><span>kubectl foo bar baz
</span></span></code></pre></div><pre tabindex=0><code>Plugin kubectl-foo-bar-baz is executed
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl foo bar
</span></span></code></pre></div><pre tabindex=0><code>Plugin kubectl-foo-bar is executed
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl foo bar baz buz
</span></span></code></pre></div><pre tabindex=0><code>Plugin kubectl-foo-bar-baz is executed, with &#34;buz&#34; as its first argument
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl foo bar buz
</span></span></code></pre></div><pre tabindex=0><code>Plugin kubectl-foo-bar is executed, with &#34;buz&#34; as its first argument
</code></pre><p>이 디자인 선택은 필요한 경우 여러 파일에 플러그인 하위 명령을 구현할 수 있도록 하고 이러한 하위 명령을 "부모" 플러그인 명령 아래에 중첩할 수 있도록 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls ./plugin_command_tree
</span></span></code></pre></div><pre tabindex=0><code>kubectl-parent
kubectl-parent-subcommand
kubectl-parent-subcommand-subsubcommand
</code></pre><h3 id=플러그인-경고-확인>플러그인 경고 확인</h3><p>위에서 언급한 <code>kubectl plugin list</code> 명령을 사용하여 <code>kubectl</code> 에 의해 플러그인이 표시되는지 확인하고, <code>kubectl</code> 명령으로 호출되지 못하게 하는 경고가 없는지 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl plugin list
</span></span></code></pre></div><pre tabindex=0><code>The following kubectl-compatible plugins are available:

test/fixtures/pkg/kubectl/plugins/kubectl-foo
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo is overshadowed by a similarly named plugin: test/fixtures/pkg/kubectl/plugins/kubectl-foo
plugins/kubectl-invalid
  - warning: plugins/kubectl-invalid identified as a kubectl plugin, but it is not executable

error: 2 plugin warnings were found
</code></pre><h3 id=커맨드-라인-런타임-패키지-사용>커맨드 라인 런타임 패키지 사용</h3><p>kubectl 용 플러그인을 작성하고 있고 Go를 사용한다면,
<a href=https://github.com/kubernetes/cli-runtime>cli-runtime</a> 유틸리티 라이브러리를
사용할 수 있다.</p><p>이 라이브러리는 사용자의
<a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
파일을 파싱이나 업데이트하거나, REST 스타일의 요청을 API 서버에 작성하거나, 구성 및 출력과
관련된 플래그를 바인딩하기 위한 헬퍼를 제공한다.</p><p>CLI 런타임 리포지터리에 제공된 도구 사용법의 예제는
<a href=https://github.com/kubernetes/sample-cli-plugin>샘플 CLI 플러그인</a>을 참고한다.</p><h2 id=kubectl-플러그인-배포>kubectl 플러그인 배포</h2><p>다른 사람이 사용할 수 있는 플러그인을 개발한 경우, 이를 패키징하고, 배포하고
사용자에게 업데이트를 제공하는 방법을 고려해야 한다.</p><h3 id=distributing-krew>Krew</h3><p><a href=https://krew.dev/>Krew</a>는 플러그인을 패키징하고 배포하는 크로스-플랫폼
방식을 제공한다. 이렇게 하면, 모든 대상 플랫폼(리눅스, 윈도우, macOS 등)에
단일 패키징 형식을 사용하고 사용자에게 업데이트를 제공한다.
Krew는 또한 다른 사람들이 여러분의 플러그인을 검색하고 설치할 수 있도록
<a href=https://krew.sigs.k8s.io/plugins/>플러그인 인덱스</a>를
유지 관리한다.</p><h3 id=distributing-native>네이티브 / 플랫폼 별 패키지 관리</h3><p>다른 방법으로는, 리눅스의 <code>apt</code> 나 <code>yum</code>,
윈도우의 Chocolatey, macOS의 Homebrew와 같은 전통적인 패키지 관리자를 사용할 수 있다.
새 실행 파일을 사용자의 <code>PATH</code> 어딘가에 배치할 수 있는 패키지 관리자라면
어떤 패키지 관리자도 괜찮다.
플러그인 작성자로서, 이 옵션을 선택하면 각 릴리스의 여러 플랫폼에서
kubectl 플러그인의 배포 패키지를
업데이트해야 한다.</p><h3 id=distributing-source-code>소스 코드</h3><p>소스 코드를 게시(예를 들어, Git 리포지터리)할 수 있다. 이
옵션을 선택하면, 해당 플러그인을 사용하려는 사람이 코드를 가져와서,
빌드 환경을 설정하고(컴파일이 필요한 경우), 플러그인을 배포해야 한다.
컴파일된 패키지를 사용 가능하게 하거나, Krew를 사용하면 설치가
더 쉬워진다.</p><h2 id=다음-내용>다음 내용</h2><ul><li>Go로 작성된 플러그인의
<a href=https://github.com/kubernetes/sample-cli-plugin>자세한 예제</a>에 대해서는
샘플 CLI 플러그인 리포지터리를 확인한다.
궁금한 사항이 있으면,
<a href=https://github.com/kubernetes/community/tree/master/sig-cli>SIG CLI 팀</a>에 문의한다.</li><li>kubectl 플러그인 패키지 관리자인 <a href=https://krew.dev/>Krew</a>에 대해 읽어본다.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>