<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/windows/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/windows/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/windows/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>쿠버네티스에서의 윈도우 | Kubernetes</title><meta property="og:title" content="쿠버네티스에서의 윈도우"><meta property="og:description" content="운영 수준의 컨테이너 오케스트레이션"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/windows/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="쿠버네티스에서의 윈도우"><meta itemprop=description content="운영 수준의 컨테이너 오케스트레이션"><meta name=twitter:card content="summary"><meta name=twitter:title content="쿠버네티스에서의 윈도우"><meta name=twitter:description content="운영 수준의 컨테이너 오케스트레이션"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/windows/"><meta property="og:title" content="쿠버네티스에서의 윈도우"><meta name=twitter:title content="쿠버네티스에서의 윈도우"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/windows/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/windows/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/windows/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/concepts/windows/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/concepts/windows/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/windows/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/windows/>中文 (Chinese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/concepts/windows/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>쿠버네티스에서의 윈도우</h1><ul><li>1: <a href=#pg-849246a35c3de66980f66e1b0944ceb4>쿠버네티스에서의 윈도우 컨테이너</a></li><li>2: <a href=#pg-0d8bfd3be43b3580681c56f6fec9d6dc>쿠버네티스에서 윈도우 컨테이너 스케줄링을 위한 가이드</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-849246a35c3de66980f66e1b0944ceb4>1 - 쿠버네티스에서의 윈도우 컨테이너</h1><p>윈도우 애플리케이션은 많은 조직에서 실행되는 서비스 및 애플리케이션의 상당 부분을 구성한다.
<a href=https://aka.ms/windowscontainers>윈도우 컨테이너</a>는
프로세스와 패키지 종속성을 캡슐화하는 현대적인 방법을 제공하여,
데브옵스(DevOps) 사례를 더욱 쉽게 사용하고 윈도우 애플리케이션의 클라우드 네이티브 패턴을 따르도록 한다.</p><p>윈도우 기반 애플리케이션과 리눅스 기반 애플리케이션에 투자한 조직은
워크로드를 관리하기 위해 별도의 오케스트레이터를 찾을 필요가 없으므로,
운영 체제와 관계없이
배포 전반에 걸쳐 운영 효율성이 향상된다.</p><h2 id=쿠버네티스에서의-윈도우-노드>쿠버네티스에서의 윈도우 노드</h2><p>쿠버네티스에서 윈도우 컨테이너 오케스트레이션을 활성화하려면,
기존 리눅스 클러스터에 윈도우 노드를 추가한다.
쿠버네티스에서 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 내의 윈도우 컨테이너를 스케줄링하는 것은
리눅스 기반 컨테이너를 스케줄링하는 것과 유사하다.</p><p>윈도우 컨테이너를 실행하려면,
쿠버네티스 클러스터가 여러 운영 체제를 포함하고 있어야 한다.
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>은 리눅스에서만 실행할 수 있는 반면,
워커 노드는 윈도우 또는 리눅스를 실행할 수 있다.</p><p><a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>의 운영 체제가
Windows Server 2019인 경우에만
윈도우 노드로써 <a href=#windows-os-version-support>사용할 수 있다</a>.</p><p>이 문서에서 <em>윈도우 컨테이너</em>라는 용어는 프로세스 격리 기반의 윈도우 컨테이너를 의미한다.
쿠버네티스는 <a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container>Hyper-V 격리</a> 기반의
윈도우 컨테이너를 지원하지 않는다.</p><h2 id=limitations>호환성 및 제한</h2><p>일부 노드 기능은 특정 <a href=#container-runtime>컨테이너 런타임</a>을 사용할 때에만 이용 가능하며,
윈도우 노드에서 사용할 수 없는 기능도 있다.
예시는 다음과 같다.</p><ul><li>HugePages: 윈도우 컨테이너에서 지원되지 않음</li><li>특권을 가진(Privileged) 컨테이너: 윈도우 컨테이너에서 지원되지 않음.
<a href=/docs/tasks/configure-pod-container/create-hostprocess-pod/>HostProcess 컨테이너</a>가 비슷한 기능을 제공한다.</li><li>TerminationGracePeriod: containerD를 필요로 한다.</li></ul><p>공유 네임스페이스(shared namespaces)의 모든 기능이 지원되는 것은 아니다.
자세한 내용은 <a href=#api>API 호환성</a>을 참조한다.</p><p><a href=#windows-os-version-support>윈도우 OS 버전 호환성</a>에서
쿠버네티스와의 동작이 테스트된 윈도우 버전 상세사항을 확인한다.</p><p>API 및 kubectl의 관점에서, 윈도우 컨테이너는 리눅스 기반 컨테이너와 거의 같은 방식으로 작동한다.
그러나, 주요 기능에서 몇 가지 주목할 만한 차이점이 있으며,
이 섹션에서 소개된다.</p><h3 id=compatibility-linux-similarities>리눅스와의 비교</h3><p>윈도우에서 주요 쿠버네티스 요소는 리눅스와 동일한 방식으로 작동한다.
이 섹션에서는 몇 가지 주요 워크로드 추상화 및 이들이 윈도우에서 어떻게 매핑되는지를 다룬다.</p><ul><li><p><a href=/ko/docs/concepts/workloads/pods/>파드</a></p><p>파드는 쿠버네티스의 기본 빌딩 블록이며,
이는 쿠버네티스 오브젝트 모델에서 생성하고 배포하는 가장 작고 간단한 단위임을 의미한다.
동일한 파드에 윈도우 컨테이너와 리눅스 컨테이너를 배포할 수 없다.
파드의 모든 컨테이너는 단일 노드로 스케줄되며 이 때 각 노드는 특정 플랫폼 및 아키텍처를 갖는다.
다음과 같은 파드 기능, 속성 및 이벤트가 윈도우 컨테이너에서 지원된다.</p><ul><li><p>프로세스 격리 및 볼륨 공유 기능을 갖춘 파드 당 하나 또는 여러 개의 컨테이너</p></li><li><p>파드의 <code>status</code> 필드</p></li><li><p>준비성 프로브(readinessprobe), 활성 프로브(liveness probe) 및 시작 프로브(startup probe)</p></li><li><p>postStart 및 preStop 컨테이너 라이프사이클 훅</p></li><li><p>컨피그맵(ConfigMap), 시크릿(Secrets): 환경 변수 또는 볼륨 형태로</p></li><li><p><code>emptyDir</code> 볼륨</p></li><li><p>명명된 파이프 호스트 마운트</p></li><li><p>리소스 제한</p></li><li><p>OS 필드:</p><p>특정 파드가 윈도우 컨테이너를 사용하고 있다는 것을 나타내려면 <code>.spec.os.name</code> 필드를 <code>windows</code>로 설정해야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 쿠버네티스 1.25부터, <code>IdentifyPodOS</code> 기능 게이트는 GA 단계이며 기본적으로 활성화되어 있다.</div><p><code>.spec.os.name</code> 필드를 <code>windows</code>로 설정했다면,
해당 파드의 <code>.spec</code> 내의 다음 필드는 설정하지 않아야 한다.</p><ul><li><code>spec.hostPID</code></li><li><code>spec.hostIPC</code></li><li><code>spec.securityContext.seLinuxOptions</code></li><li><code>spec.securityContext.seccompProfile</code></li><li><code>spec.securityContext.fsGroup</code></li><li><code>spec.securityContext.fsGroupChangePolicy</code></li><li><code>spec.securityContext.sysctls</code></li><li><code>spec.shareProcessNamespace</code></li><li><code>spec.securityContext.runAsUser</code></li><li><code>spec.securityContext.runAsGroup</code></li><li><code>spec.securityContext.supplementalGroups</code></li><li><code>spec.containers[*].securityContext.seLinuxOptions</code></li><li><code>spec.containers[*].securityContext.seccompProfile</code></li><li><code>spec.containers[*].securityContext.capabilities</code></li><li><code>spec.containers[*].securityContext.readOnlyRootFilesystem</code></li><li><code>spec.containers[*].securityContext.privileged</code></li><li><code>spec.containers[*].securityContext.allowPrivilegeEscalation</code></li><li><code>spec.containers[*].securityContext.procMount</code></li><li><code>spec.containers[*].securityContext.runAsUser</code></li><li><code>spec.containers[*].securityContext.runAsGroup</code></li></ul><p>위의 리스트에서 와일드카드(<code>*</code>)는 목록의 모든 요소를 가리킨다.
예를 들어, <code>spec.containers[*].securityContext</code>는
모든 컨테이너의 시큐리티컨텍스트(SecurityContext) 오브젝트를 나타낸다.
위의 필드 중 하나라도 설정되어 있으면, API 서버는 해당 파드는 수용하지 않을 것이다.</p></li></ul></li><li><p>다음과 같은 <a href=/ko/docs/concepts/workloads/controllers/>워크로드 리소스</a>:</p><ul><li>레플리카셋(ReplicaSet)</li><li>디플로이먼트(Deployment)</li><li>스테이트풀셋(StatefulSet)</li><li>데몬셋(DaemonSet)</li><li>잡(Job)</li><li>크론잡(CronJob)</li><li>레플리케이션컨트롤러(ReplicationController)</li></ul></li><li><p><a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>
<a href=/ko/docs/concepts/services-networking/windows-networking/#load-balancing-and-services>로드 밸런싱과 서비스</a>에서 상세 사항을 확인한다.</p></li></ul><p>파드, 워크로드 리소스 및 서비스는
쿠버네티스에서 윈도우 워크로드를 관리하는 데 중요한 요소이다.
그러나 그 자체만으로는 동적인 클라우드 네이티브 환경에서
윈도우 워크로드의 적절한 라이프사이클 관리를 수행하기에 충분하지 않다.</p><ul><li><code>kubectl exec</code></li><li>파드 및 컨테이너 메트릭</li><li><a class=glossary-tooltip title='CPU 사용률 또는 사용자 정의 메트릭을 기반으로 파드의 레플리카 수를 자동으로 조절하는 API 리소스이다.' data-toggle=tooltip data-placement=top href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/ target=_blank aria-label='Horizontal pod autoscaling'>Horizontal pod autoscaling</a></li><li><a class=glossary-tooltip title='네임스페이스당 전체 리소스 소비를 제한하는 제약을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/policy/resource-quotas/ target=_blank aria-label='리소스 쿼터(Resource quota)'>리소스 쿼터(Resource quota)</a></li><li>스케쥴러 선점(preemption)</li></ul><h3 id=kubelet-compatibility>kubelet을 위한 명령줄 옵션</h3><p>윈도우에서는 일부 kubelet 명령줄 옵션이 다르게 동작하며, 아래에 설명되어 있다.</p><ul><li><code>--windows-priorityclass</code>를 사용하여 kubelet 프로세스의 스케줄링 우선 순위를 설정할 수 있다.
(<a href=/ko/docs/concepts/configuration/windows-resource-management/#resource-management-cpu>CPU 리소스 관리</a> 참고)</li><li><code>--kube-reserved</code>, <code>--system-reserved</code> 및 <code>--eviction-hard</code> 플래그는
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>NodeAllocatable</a>을 업데이트한다.</li><li><code>--enforce-node-allocable</code>을 이용한 축출은 구현되어 있지 않다.</li><li><code>--eviction-hard</code> 및 <code>--eviction-soft</code>를 이용한 축출은 구현되어 있지 않다.</li><li>윈도우 노드에서 실행되는 kubelet은 메모리 및 CPU 제한을 받지 않는다.
<code>NodeAllocatable</code>에서 <code>--kube-reserved</code>와 <code>--system-reserved</code>가 차감될 뿐이며
워크로드에 제공될 리소스는 보장되지 않는다.
추가 정보는 <a href=/ko/docs/concepts/configuration/windows-resource-management/#resource-reservation>윈도우 노드의 리소스 관리</a>를
참고한다.</li><li><code>MemoryPressure</code> 컨디션은 구현되어 있지 않다.</li><li>kubelet은 메모리 부족(OOM, Out-of-Memory) 축출 동작을 수행하지 않는다.</li></ul><h3 id=api>API 호환성</h3><p>운영 체제와 컨테이너 런타임의 차이로 인해, 윈도우에 대해 쿠버네티스 API가 동작하는 방식에 미묘한 차이가 있다.
일부 워크로드 속성은 리눅스에 맞게 설계되었으며, 이로 인해 윈도우에서 실행되지 않는다.</p><p>높은 수준에서, OS 개념에 대해 다음과 같은 차이점이 존재한다.</p><ul><li>ID - 리눅스는 정수형으로 표시되는 userID(UID) 및 groupID(GID)를 사용한다.
사용자와 그룹 이름은 정식 이름이 아니다.
UID+GID에 대한 <code>/etc/groups</code> 또는 <code>/etc/passwd</code>의 별칭일 뿐이다.
윈도우는 윈도우 보안 계정 관리자(Security Account Manager, SAM) 데이터베이스에 저장된
더 큰 이진 <a href=https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers>보안 식별자</a>(SID)를 사용한다.
이 데이터베이스는 호스트와 컨테이너 간에 또는
컨테이너들 간에 공유되지 않는다.</li><li>파일 퍼미션 - 윈도우는 SID 기반 접근 제어 목록을 사용하는 반면,
리눅스와 같은 POSIX 시스템은 오브젝트 권한 및 UID+GID 기반의 비트마스크(bitmask)를 사용하며,
접근 제어 목록도 선택적으로 사용한다.</li><li>파일 경로 - 윈도우의 규칙은 <code>/</code> 대신 <code>\</code>를 사용하는 것이다.
Go IO 라이브러리는 두 가지 파일 경로 분리자를 모두 허용한다.
하지만, 컨테이너 내부에서 해석되는 경로 또는 커맨드 라인을 설정할 때 <code>\</code>가 필요할 수 있다.</li><li>신호(Signals) - 윈도우 대화형(interactive) 앱은 종료를 다르게 처리하며,
다음 중 하나 이상을 구현할 수 있다.<ul><li>UI 스레드는 <code>WM_CLOSE</code> 등의 잘 정의된(well-defined) 메시지를 처리한다.</li><li>콘솔 앱은 컨트롤 핸들러(Control Handler)를 사용하여 Ctrl-c 또는 Ctrl-break를 처리한다.</li><li>서비스는 <code>SERVICE_CONTROL_STOP</code> 제어 코드를 수용할 수 있는
Service Control Handler 함수를 등록한다.</li></ul></li></ul><p>컨테이너 종료 코드는 리눅스와 동일하게 성공이면 0, 실패이면 0이 아닌 디른 수이다.
상세 오류 코드는 윈도우와 리눅스 간에 다를 수 있다.
그러나 쿠버네티스 컴포넌트(kubelet, kube-proxy)에서 전달된 종료 코드는 변경되지 않는다.</p><h4 id=compatibility-v1-pod-spec-containers>컨테이너 명세의 필드 호환성</h4><p>다음 목록은 윈도우와 리눅스에서
파드 컨테이너 명세가 어떻게 다르게 동작하는지 기술한다.</p><ul><li>Huge page는 윈도우 컨테이너 런타임에서 구현되지 않았으며,
따라서 사용할 수 없다. 컨테이너에 대해 구성할 수 없는(not configurable)
<a href=https://docs.microsoft.com/en-us/windows/desktop/Memory/large-page-support>사용자 권한(user privilege) 어설트(assert)</a>가
필요하다.</li><li><code>requests.cpu</code> 및 <code>requests.memory</code> - 요청(requests)이 노드의 사용 가능한 리소스에서 차감되며,
이는 노드 오버프로비저닝을 방지하기 위해 사용될 수 있다.
그러나, 오버프로비저닝된 노드 내에서 리소스를 보장하기 위해서는 사용될 수 없다.
운영자가 오버 프로비저닝을 완전히 피하려는 경우
모범 사례로 모든 컨테이너에 적용해야 한다.</li><li><code>securityContext.allowPrivilegeEscalation</code> -
어떠한 기능도 연결되지 않아서, 윈도우에서는 사용할 수 없다.</li><li><code>securityContext.capabilities</code> -
POSIX 기능은 윈도우에서 구현되지 않았다.</li><li><code>securityContext.privileged</code> -
윈도우는 특권을 가진(privileged) 컨테이너를 지원하지 않는다.</li><li><code>securityContext.procMount</code> -
윈도우에는 <code>/proc</code> 파일시스템이 없다.</li><li><code>securityContext.readOnlyRootFilesystem</code> -
윈도우에서는 사용할 수 없으며,
이는 레지스트리 및 시스템 프로세스가 컨테이너 내부에서 실행될 때 쓰기 권한이 필요하기 때문이다.</li><li><code>securityContext.runAsGroup</code> -
윈도우에서는 GID가 지원되지 않으므로 사용할 수 없다.</li><li><code>securityContext.runAsNonRoot</code> -
이 설정은 컨테이너가 <code>ContainerAdministrator</code> 사용자로 실행되는 것을 방지하는데,
이는 리눅스의 root 사용자와 가장 가까운 윈도우 역할이다.</li><li><code>securityContext.runAsUser</code> -
대신 <a href=/ko/docs/tasks/configure-pod-container/configure-runasusername/><code>runAsUserName</code></a>을
사용한다.</li><li><code>securityContext.seLinuxOptions</code> -
SELinux는 리눅스 전용이므로 윈도우에서는 사용할 수 없다.</li><li><code>terminationMessagePath</code> -
윈도우가 단일 파일 매핑을 지원하지 않음으로 인하여 몇 가지 제한이 있다.
기본값은 <code>/dev/termination-log</code>이며,
이 경로가 기본적으로 윈도우에 존재하지 않기 때문에 정상적으로 작동한다.</li></ul><h4 id=compatibility-v1-pod>파드 명세의 필드 호환성</h4><p>다음 목록은 윈도우와 리눅스에서 파드 명세가 어떻게 다르게 동작하는지 기술한다.</p><ul><li><code>hostIPC</code> 및 <code>hostpid</code> - 호스트 네임스페이스 공유 기능은 윈도우에서 사용할 수 없다.</li><li><code>hostNetwork</code> - 윈도우 운영 체제에서 호스트 네트워크 공유 기능을 지원하지 않는다.</li><li><code>dnsPolicy</code> - 윈도우에서 호스트 네트워킹이 지원되지 않기 때문에
<code>dnsPolicy</code>를 <code>ClusterFirstWithHostNet</code>로 설정할 수 없다.
파드는 항상 컨테이너 네트워크와 함께 동작한다.</li><li><code>podSecurityContext</code> (하단 참조)</li><li><code>shareProcessNamespace</code> - 이것은 베타 기능이며, 윈도우에서 구현되지 않은 리눅스 네임스페이스에 의존한다.
윈도우는 프로세스 네임스페이스 또는 컨테이너의 루트 파일시스템을 공유할 수 없다.
네트워크만 공유할 수 있다.</li><li><code>terminationGracePeriodSeconds</code> - 이것은 윈도우용 도커에서 완전히 구현되지 않았다.
<a href=https://github.com/moby/moby/issues/25982>GitHub 이슈</a>를 참고한다.
현재 동작은 <code>ENTRYPOINT</code> 프로세스가 <code>CTRL_SHUTDOWN_EVENT</code>로 전송된 다음,
윈도우가 기본적으로 5초를 기다린 후,
마지막으로 정상적인 윈도우 종료 동작을 사용하여 모든 프로세스를 종료하는 것이다.
5초 기본값은 실제로는
<a href=https://github.com/moby/moby/issues/25982#issuecomment-426441183>컨테이너 내부</a> 윈도우 레지스트리에 있으므로
컨테이너를 빌드할 때 재정의할 수 있다.</li><li><code>volumeDevices</code> - 이것은 베타 기능이며, 윈도우에서 구현되지 않았다.
윈도우는 원시 블록 장치(raw block device)를 파드에 연결할 수 없다.</li><li><code>volumes</code><ul><li><code>emptyDir</code> 볼륨을 정의한 경우, 이 볼륨의 소스(source)를 <code>memory</code>로 설정할 수는 없다.</li></ul></li><li><code>mountPropagation</code> - 마운트 전파(propagation)는 윈도우에서 지원되지 않으므로
이 필드는 활성화할 수 없다.</li></ul><h4 id=compatibility-v1-pod-spec-containers-securitycontext>파드 시큐리티 컨텍스트의 필드 호환성</h4><p>파드 <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context><code>securityContext</code></a>의 모든 필드는 윈도우에서 작동하지 않는다.</p><h2 id=노드-문제-감지기>노드 문제 감지기</h2><p>노드 문제 감지기(<a href=/ko/docs/tasks/debug/debug-cluster/monitor-node-health/>노드 헬스 모니터링하기</a> 참조)는
기초적인 윈도우 지원을 포함한다.
더 자세한 정보는 프로젝트의
<a href=https://github.com/kubernetes/node-problem-detector#windows>GitHub 페이지</a>를 참고한다.</p><h2 id=퍼즈-pause-컨테이너>퍼즈(pause) 컨테이너</h2><p>쿠버네티스 파드에서, 컨테이너를 호스팅하기 위해 먼저 "퍼즈" 컨테이너라는 인프라 컨테이너가 생성된다.
리눅스에서, 파드를 구성하는 cgroup과 네임스페이스가 계속 유지되기 위해서는 프로세스가 필요하며,
퍼즈 프로세스가 이를 담당한다.
동일한 파드에 속한 (인프라 및 워커) 컨테이너는
공통의 네트워크 엔드포인트(공통 IPv4/IPv6 주소, 공통 네트워크 포트 공간)를 공유한다.
쿠버네티스는 퍼즈 컨테이너를 사용하여
워커 컨테이너가 충돌하거나 재시작하여도 네트워킹 구성을 잃지 않도록 한다.</p><p>쿠버네티스는 윈도우 지원을 포함하는 다중 아키텍처 이미지를 유지보수한다.
쿠버네티스 v1.25의 경우
권장 퍼즈 이미지는 <code>registry.k8s.io/pause:3.6</code>이다.
<a href=https://github.com/kubernetes/kubernetes/tree/master/build/pause>소스 코드</a>는 GitHub에서 찾을 수 있다.</p><p>Microsoft는 리눅스 및 윈도우 amd64를 지원하는 다중 아키텍처 이미지를
<code>mcr.microsoft.com/oss/kubernetes/pause:3.6</code>에서 유지보수하고 있다.
이 이미지는 쿠버네티스가 유지 관리하는 이미지와 동일한 소스코드에서 생성되었지만,
모든 윈도우 바이너리가 Microsoft에 의해
<a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/install/authenticode>인증 코드(authenticode)로 서명</a>되었다.
서명된 바이너리를 필요로 하는 프로덕션 또는 프로덕션에 준하는 환경에 파드를 배포하는 경우,
Microsoft가 유지 관리하는 이미지를 사용하는 것을 권장한다.</p><h2 id=container-runtime>컨테이너 런타임</h2><p>파드가 각 노드에서 실행될 수 있도록,
클러스터의 각 노드에 <a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>을
설치해야 한다.</p><p>다음 컨테이너 런타임은 윈도우에서 동작한다.</p><div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div><h3 id=containerd>ContainerD</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.20 [stable]</code></div><p><a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=ContainerD>ContainerD</a> 1.4.0+를
윈도우 노드의 컨테이너 런타임으로 사용할 수 있다.</p><p><a href=/ko/docs/setup/production-environment/container-runtimes/#containerd-%EC%84%A4%EC%B9%98>윈도우 노드에 ContainerD를 설치</a>하는 방법을 확인한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> containerd와 GMSA 사용 시 윈도우 네트워크 공유 접근에 대한
<a href=/ko/docs/tasks/configure-pod-container/configure-gmsa/#gmsa-limitations>알려진 제한</a>이 있으며,
이는 커널 패치를 필요로 한다.</div><h3 id=mcr>Mirantis Container Runtime</h3><p><a href=https://docs.mirantis.com/mcr/20.10/overview.html>Mirantis Container Runtime</a>(MCR)은
Windows Server 2019 및 이후 버전을 지원하는 컨테이너 런타임이다.</p><p>더 많은 정보는 <a href=https://docs.mirantis.com/mcr/20.10/install/mcr-windows.html>Windows Server에 MCR 설치하기</a>를 참고한다.</p><h2 id=windows-os-version-support>윈도우 운영 체제 버전 호환성</h2><p>윈도우에는 호스트 OS 버전이 컨테이너 베이스 이미지 OS 버전과 일치해야 한다는
엄격한 호환성 규칙이 있다.
컨테이너 운영 체제가 Windows Server 2019인 윈도우 컨테이너만이 완전히 지원된다.</p><p>쿠버네티스 v1.25에서,
윈도우 노드(및 파드)에 대한 운영 체제 호환성은 다음과 같다.</p><dl><dt>Windows Server LTSC 릴리스</dt><dd>Windows Server 2019</dd><dd>Windows Server 2022</dd><dt>Windows Server SAC 릴리스</dt><dd>Windows Server 버전 20H2</dd></dl><p>쿠버네티스 <a href=/ko/releases/version-skew-policy/>버전 차이 정책</a> 또한 적용된다.</p><h2 id=troubleshooting>도움 받기 및 트러블슈팅</h2><p>쿠버네티스 클러스터 트러블슈팅을 위한
기본 도움말은 <a href=/ko/docs/tasks/debug/>이 섹션</a>을
먼저 찾아 본다.</p><p>이 섹션에는 몇 가지 추가 윈도우 관련 트러블슈팅 도움말이 포함되어 있다.
로그는 쿠버네티스에서 트러블슈팅하는 데 중요한 요소이다.
다른 기여자로부터 트러블슈팅 지원을 구할 때마다 이를 포함시켜야 한다.
SIG Windows의
<a href=https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs>로그 수집에 대한 기여 가이드</a>의
지침을 따른다.</p><h3 id=이슈-리포팅-및-기능-요청>이슈 리포팅 및 기능 요청</h3><p>버그처럼 보이는 부분이 있거나 기능 요청을 하고 싶다면,
<a href=https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#reporting-issues-and-feature-requests>SIG Windows 기여 가이드</a>를 참고하여
새 이슈를 연다. 먼저 이전에 이미 보고된 이슈가 있는지 검색하고,
이슈에 대한 경험과 추가 로그를 기재해야 한다.
티켓을 만들기 전에, 쿠버네티스 슬랙의 SIG Windows 채널 또한
초기 지원 및 트러블슈팅 아이디어를 얻을 수 있는 좋은 곳이다.</p><h2 id=배포-도구>배포 도구</h2><p>kubeadm 도구는 클러스터를 관리할 컨트롤 플레인과 워크로드를 실행할 노드를 제공함으로써
쿠버네티스 클러스터를 배포할 수 있게 해 준다.
<a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>윈도우 노드 추가하기</a> 문서에서
kubeadm을 사용해 어떻게 클러스터에 윈도우 노드를 배포하는지를 설명한다.</p><p>쿠버네티스 <a href=https://cluster-api.sigs.k8s.io/>클러스터 API</a> 프로젝트는 윈도우 노드 배포를 자동화하는 수단을 제공한다.</p><h2 id=윈도우-배포-채널>윈도우 배포 채널</h2><p>윈도우 배포 채널에 대한 자세한 설명은
<a href=https://docs.microsoft.com/ko-kr/windows-server/get-started-19/servicing-channels-19>Microsoft 문서</a>를 참고한다.</p><p>각각의 Windows Server 서비스 채널 및 지원 모델은
<a href=https://docs.microsoft.com/en-us/windows-server/get-started/servicing-channels-comparison>Windows Server 서비스 채널</a>에서
확인할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0d8bfd3be43b3580681c56f6fec9d6dc>2 - 쿠버네티스에서 윈도우 컨테이너 스케줄링을 위한 가이드</h1><p>많은 조직에서 실행하는 서비스와 애플리케이션의 상당 부분이 윈도우 애플리케이션으로 구성된다.
이 가이드는 쿠버네티스에서 윈도우 컨테이너를 구성하고 배포하는 단계를 안내한다.</p><h2 id=목표>목표</h2><ul><li>윈도우 노드에서 윈도우 컨테이너를 실행하는 예시 디플로이먼트를 구성한다.</li><li>쿠버네티스의 윈도우 관련 기능을 강조한다.</li></ul><h2 id=시작하기-전에>시작하기 전에</h2><ul><li>컨트롤 플레인과 <a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>윈도우 서버로 운영되는 워커 노드</a>를
포함하는 쿠버네티스 클러스터를 생성한다.</li><li>쿠버네티스에서 서비스와 워크로드를 생성하고 배포하는 것은 리눅스나 윈도우 컨테이너
모두 비슷한 방식이라는 것이 중요하다.
<a href=/ko/docs/reference/kubectl/>kubectl 커맨드</a>로 클러스터에 접속하는 것은 동일하다.
아래 단원의 예시를 통해 윈도우 컨테이너와 좀 더 빨리 친숙해질 수 있다.</li></ul><h2 id=시작하기-윈도우-컨테이너-배포하기>시작하기: 윈도우 컨테이너 배포하기</h2><p>아래 예시 YAML 파일은 윈도우 컨테이너 안에서 실행되는 간단한 웹서버 애플리케이션을 배포한다.</p><p>아래 내용으로 채운 서비스 스펙을 <code>win-webserver.yaml</code>이라는 이름으로 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 서비스가 서비스를 제공할 포트</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>windowswebserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- powershell.exe<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- -command<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;&lt;#code used from https://gist.github.com/19WAS85/5424431#&gt; ; $$listener = New-Object System.Net.HttpListener ; $$listener.Prefixes.Add(&#39;http://*:80/&#39;) ; $$listener.Start() ; $$callerCounts = @{} ; Write-Host(&#39;Listening at http://*:80/&#39;) ; while ($$listener.IsListening) { ;$$context = $$listener.GetContext() ;$$requestUrl = $$context.Request.Url ;$$clientIP = $$context.Request.RemoteEndPoint.Address ;$$response = $$context.Response ;Write-Host &#39;&#39; ;Write-Host(&#39;&gt; {0}&#39; -f $$requestUrl) ;  ;$$count = 1 ;$$k=$$callerCounts.Get_Item($$clientIP) ;if ($$k -ne $$null) { $$count += $$k } ;$$callerCounts.Set_Item($$clientIP, $$count) ;$$ip=(Get-NetAdapter | Get-NetIpAddress); $$header=&#39;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Windows Container Web Server&lt;/H1&gt;&#39; ;$$callerCountsString=&#39;&#39; ;$$callerCounts.Keys | % { $$callerCountsString+=&#39;&lt;p&gt;IP {0} callerCount {1} &#39; -f $$ip[1].IPAddress,$$callerCounts.Item($$_) } ;$$footer=&#39;&lt;/body&gt;&lt;/html&gt;&#39; ;$$content=&#39;{0}{1}{2}&#39; -f $$header,$$callerCountsString,$$footer ;Write-Output $$content ;$$buffer = [System.Text.Encoding]::UTF8.GetBytes($$content) ;$$response.ContentLength64 = $$buffer.Length ;$$response.OutputStream.Write($$buffer, 0, $$buffer.Length) ;$$response.Close() ;$$responseStatus = $$response.StatusCode ;Write-Host(&#39;&lt; {0}&#39; -f $$responseStatus)  } ; &#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 포트 매핑도 지원하지만, 이 예시에서는 간결성을 위해
컨테이너 포트 80을 서비스로 직접 노출한다.</div><ol><li><p>모든 노드가 건강한지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div></li><li><p>서비스를 배포하고 파드 갱신을 지켜보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f win-webserver.yaml
</span></span><span style=display:flex><span>kubectl get pods -o wide -w
</span></span></code></pre></div><p>이 서비스가 정확히 배포되면 모든 파드는 Ready로 표기된다. 지켜보기를 중단하려면, Ctrl+C 를 누르자.</p></li><li><p>이 디플로이먼트가 성공적인지 확인한다. 다음을 검토하자.</p><ul><li>리눅스 컨트롤 플레인 노드에서 나열된 두 파드가 존재하는지 확인하려면, <code>kubectl get pods</code>를 사용한다.</li><li>네트워크를 통한 노드에서 파드로의 통신이 되는지 확인하려면, 리눅스 컨트롤 플레인 노드에서 <code>curl</code>을
파드 IP 주소의 80 포트로 실행하여 웹 서버 응답을 확인한다.</li><li>파드 간 통신이 되는지 확인하려면, <code>docker exec</code> 나 <code>kubectl exec</code>를 이용해 파드 간에
핑(ping)한다(윈도우 노드가 2대 이상이라면, 서로 다른 노드에 있는 파드 간 통신도 확인할 수 있다).</li><li>서비스에서 파드로의 통신이 되는지 확인하려면, 리눅스 컨트롤 플레인 노드와 독립 파드에서 <code>curl</code>을 가상 서비스
IP 주소(<code>kubectl get services</code>로 볼 수 있는)로 실행한다.</li><li>서비스 검색(discovery)이 되는지 확인하려면, 쿠버네티스 <a href=/ko/docs/concepts/services-networking/dns-pod-service/#%EC%84%9C%EB%B9%84%EC%8A%A4>기본 DNS 접미사</a>와 서비스 이름으로 <code>curl</code>을 실행한다.</li><li>인바운드 연결이 되는지 확인하려면, 클러스터 외부 장비나 리눅스 컨트롤 플레인 노드에서 NodePort로 <code>curl</code>을 실행한다.</li><li>아웃바운드 연결이 되는지 확인하려면, <code>kubectl exec</code>를 이용해서 파드에서 외부 IP 주소로 <code>curl</code>을 실행한다.</li></ul></li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 윈도우 컨테이너 호스트는 현재 윈도우 네트워킹 스택의 플랫폼 제한으로 인해, 그 안에서 스케줄링하는 서비스의 IP 주소로 접근할 수 없다.
윈도우 파드만 서비스 IP 주소로 접근할 수 있다.</div><h2 id=가시성>가시성</h2><h3 id=워크로드에서-로그-캡쳐하기>워크로드에서 로그 캡쳐하기</h3><p>로그는 가시성의 중요한 요소이다. 로그는 사용자가 워크로드의 운영측면을
파악할 수 있도록 하며 문제 해결의 핵심 요소이다.
윈도우 컨테이너, 그리고 윈도우 컨테이너 내의 워크로드는 리눅스 컨테이너와는 다르게 동작하기 때문에,
사용자가 로그를 수집하기 어려웠고 이로 인해 운영 가시성이 제한되어 왔다.
예를 들어 윈도우 워크로드는 일반적으로 ETW(Event Tracing for Windows)에 로그인하거나
애플리케이션 이벤트 로그에 항목을 푸시하도록 구성한다.
Microsoft의 오픈 소스 도구인 <a href=https://github.com/microsoft/windows-container-tools/tree/master/LogMonitor>LogMonitor</a>는
윈도우 컨테이너 안에 구성된 로그 소스를 모니터링하는 권장하는 방법이다.
LogMonitor는 이벤트 로그, ETW 공급자 그리고 사용자 정의 애플리케이션 로그 모니터링을 지원하고
<code>kubectl logs &lt;pod></code> 에 의한 사용을 위해 STDOUT으로 파이프한다.</p><p>LogMonitor GitHub 페이지의 지침에 따라 모든 컨테이너 바이너리와 설정 파일을 복사하고,
LogMonitor가 로그를 STDOUT으로 푸시할 수 있도록 필요한 엔트리포인트를 추가한다.</p><h2 id=컨테이너-사용자-구성하기>컨테이너 사용자 구성하기</h2><h3 id=설정-가능한-컨테이너-username-사용하기>설정 가능한 컨테이너 username 사용하기</h3><p>윈도우 컨테이너는 이미지 기본값과는 다른 username으로
엔트리포인트와 프로세스를 실행하도록 설정할 수 있다.
<a href=/ko/docs/tasks/configure-pod-container/configure-runasusername/>여기</a>에서 이에 대해 추가적으로 배울 수 있다.</p><h3 id=그룹-매니지드-서비스-어카운트를-이용하여-워크로드-신원-관리하기>그룹 매니지드 서비스 어카운트를 이용하여 워크로드 신원 관리하기</h3><p>윈도우 컨테이너 워크로드는 그룹 매니지드 서비스 어카운트(GMSA, Group Managed Service Account)를 이용하여 구성할 수 있다.
그룹 매니지드 서비스 어카운트는 액티브 디렉터리 어카운트의 특정한 종류로 자동 암호 관리 기능,
단순화된 서비스 주체 이름(SPN, simplified service principal name), 여러 서버의 다른 관리자에게 관리를 위임하는 기능을 제공한다.
GMSA로 구성한 컨테이너는 GMSA로 구성된 신원을 들고 있는 동안 외부 액티브 디렉터리 도메인 리소스를 접근할 수 있다.
윈도우 컨테이너를 위한 GMSA를 이용하고 구성하는 방법은 <a href=/ko/docs/tasks/configure-pod-container/configure-gmsa/>여기</a>에서 알아보자.</p><h2 id=테인트-taint-와-톨러레이션-toleration>테인트(Taint)와 톨러레이션(Toleration)</h2><p>사용자는 리눅스와 윈도우 워크로드를 (동일한 OS를 실행하는) 적절한 노드에 스케줄링되도록 하기 위해
테인트와 노드셀렉터(nodeSelector)의 조합을 이용해야 한다.
아래는 권장되는 방식의 개요인데,
이것의 주요 목표 중에 하나는 이 방식이 기존 리눅스 워크로드와 호환되어야 한다는 것이다.</p><p>1.25부터, 파드의 컨테이너가 어떤 운영체제 용인지를 파드의 <code>.spec.os.name</code>에 설정할 수 있다(그리고 설정해야 한다).
리눅스 컨테이너를 실행하는 파드에는 <code>.spec.os.name</code>을 <code>linux</code>로 설정한다.
윈도우 컨테이너를 실행하는 파드에는 <code>.spec.os.name</code>을
<code>windows</code>로 설정한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 1.25부터, <code>IdentifyPodOS</code> 기능은 GA 단계이며 기본적으로 활성화되어 있다.</div><p>스케줄러는 파드를 노드에 할당할 때
<code>.spec.os.name</code> 필드의 값을 사용하지 않는다.
컨트롤 플레인이 파드를 적절한 운영 체제가 실행되고 있는 노드에 배치하도록 하려면,
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/>파드를 노드에 할당</a>하는
일반적인 쿠버네티스 메카니즘을 사용해야 한다.</p><p><code>.spec.os.name</code> 필드는 윈도우 파드의 스케줄링에는 영향을 미치지 않기 때문에,
윈도우 파드가 적절한 윈도우 노드에 할당되도록 하려면
테인트, 톨러레이션 및 노드 셀렉터가 여전히 필요하다.</p><h3 id=특정-os-워크로드를-적절한-컨테이너-호스트에서-처리하도록-보장하기>특정 OS 워크로드를 적절한 컨테이너 호스트에서 처리하도록 보장하기</h3><p>사용자는 테인트와 톨러레이션을 이용하여 윈도우 컨테이너가 적절한 호스트에서 스케줄링되기를 보장할 수 있다.
오늘날 모든 쿠버네티스 노드는 다음 기본 레이블을 가지고 있다.</p><ul><li>kubernetes.io/os = [windows|linux]</li><li>kubernetes.io/arch = [amd64|arm64|...]</li></ul><p>파드 사양에 노드 셀렉터를 <code>"kubernetes.io/os": windows</code>와 같이 지정하지 않았다면,
그 파드는 리눅스나 윈도우, 아무 호스트에나 스케줄링될 수 있다.
윈도우 컨테이너는 윈도우에서만 운영될 수 있고 리눅스 컨테이너는 리눅스에서만 운영될 수 있기 때문에 이는 문제를 일으킬 수 있다.
가장 좋은 방법은 노드 셀렉터를 사용하는 것이다.</p><p>그러나 많은 경우 사용자는 이미 존재하는 대량의 리눅스 컨테이너용 디플로이먼트를 가지고 있을 뿐만 아니라,
헬름(Helm) 차트 커뮤니티 같은 상용 구성의 에코시스템이나, 오퍼레이터(Operator) 같은 프로그래밍 방식의 파드 생성 사례가 있음을 알고 있다.
이런 상황에서는 노드 셀렉터를 추가하는 구성 변경을 망설일 수 있다.
이에 대한 대안은 테인트를 사용하는 것이다. Kubelet은 등록하는 동안 테인트를 설정할 수 있기 때문에,
윈도우에서만 운영할 때에 자동으로 테인트를 추가하기 쉽다.</p><p>예를 들면, <code>--register-with-taints='os=windows:NoSchedule'</code></p><p>모든 윈도우 노드에 테인트를 추가하여 아무 것도 거기에 스케줄링하지 않게 될 것이다(존재하는 리눅스 파드를 포함하여).
윈도우 파드가 윈도우 노드에 스케줄링되도록 하려면,
윈도우 노드가 선택되도록 하기 위한 노드 셀렉터 및 적합하게 일치하는 톨러레이션이 모두 필요하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>node.kubernetes.io/windows-build</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;10.0.17763&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;os&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;windows&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=동일-클러스터에서-여러-윈도우-버전을-조작하는-방법>동일 클러스터에서 여러 윈도우 버전을 조작하는 방법</h3><p>파드에서 사용하는 윈도우 서버 버전은 노드의 윈도우 서버 버전과 일치해야 한다. 만약 동일한 클러스터에서 여러 윈도우
서버 버전을 사용하려면, 추가로 노드 레이블과 nodeSelectors를 설정해야 한다.</p><p>쿠버네티스 1.17은 이것을 단순화하기 위해 새로운 레이블인 <code>node.kubernetes.io/windows-build</code> 를 자동으로 추가한다.
만약 이전 버전을 실행 중인 경우, 이 레이블을 윈도우 노드에 수동으로 추가하는 것을 권장한다.</p><p>이 레이블은 호환성을 위해 일치시켜야 하는 윈도우 메이저, 마이너 및 빌드 번호를 나타낸다.
각 윈도우 서버 버전에 대해 현재 사용하고 있는 빌드 번호는 다음과 같다.</p><table><thead><tr><th>제품 이름</th><th>빌드 번호</th></tr></thead><tbody><tr><td>Windows Server 2019</td><td>10.0.17763</td></tr><tr><td>Windows Server, 버전 20H2</td><td>10.0.19042</td></tr><tr><td>Windows Server 2022</td><td>10.0.20348</td></tr></tbody></table><h3 id=runtimeclass로-단순화>RuntimeClass로 단순화</h3><p><a href=/ko/docs/concepts/containers/runtime-class/>런타임클래스(RuntimeClass)</a>를 사용해서 테인트(taint)와 톨러레이션(toleration)을 사용하는 프로세스를 간소화 할 수 있다.
클러스터 관리자는 이 테인트와 톨러레이션을 캡슐화하는 데 사용되는 <code>RuntimeClass</code> 오브젝트를 생성할 수 있다.</p><ol><li>이 파일을 <code>runtimeClasses.yml</code> 로 저장한다. 여기에는 윈도우 OS,
아키텍처 및 버전에 적합한 <code>nodeSelector</code> 가 포함되어 있다.</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>windows-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>scheduling</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;windows&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/arch</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;amd64&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>node.kubernetes.io/windows-build</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;10.0.17763&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>os<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Equal<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;windows&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ol><li>클러스터 관리자로 <code>kubectl create -f runtimeClasses.yml</code> 를 실행해서 사용한다.</li><li>파드 사양에 적합한 <code>runtimeClassName: windows-2019</code> 를 추가한다.</li></ol><p>예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>windows-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>800Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>300Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span></code></pre></div></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>