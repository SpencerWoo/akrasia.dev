<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/overview/working-with-objects/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>쿠버네티스 오브젝트로 작업하기 | Kubernetes</title><meta property="og:title" content="쿠버네티스 오브젝트로 작업하기"><meta property="og:description" content="쿠버네티스 오브젝트는 쿠버네티스 시스템의 영구 엔티티이다. 쿠버네티스는 이러한 엔티티들을 사용하여 클러스터의 상태를 나타낸다. 쿠버네티스 오브젝트 모델과 쿠버네티스 오브젝트를 사용하는 방법에 대해 학습한다.
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="쿠버네티스 오브젝트로 작업하기"><meta itemprop=description content="쿠버네티스 오브젝트는 쿠버네티스 시스템의 영구 엔티티이다. 쿠버네티스는 이러한 엔티티들을 사용하여 클러스터의 상태를 나타낸다. 쿠버네티스 오브젝트 모델과 쿠버네티스 오브젝트를 사용하는 방법에 대해 학습한다.
"><meta name=twitter:card content="summary"><meta name=twitter:title content="쿠버네티스 오브젝트로 작업하기"><meta name=twitter:description content="쿠버네티스 오브젝트는 쿠버네티스 시스템의 영구 엔티티이다. 쿠버네티스는 이러한 엔티티들을 사용하여 클러스터의 상태를 나타낸다. 쿠버네티스 오브젝트 모델과 쿠버네티스 오브젝트를 사용하는 방법에 대해 학습한다.
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="쿠버네티스 오브젝트는 쿠버네티스 시스템의 영구 엔티티이다. 쿠버네티스는 이러한 엔티티들을 사용하여 클러스터의 상태를 나타낸다. 쿠버네티스 오브젝트 모델과 쿠버네티스 오브젝트를 사용하는 방법에 대해 학습한다.
"><meta property="og:description" content="쿠버네티스 오브젝트는 쿠버네티스 시스템의 영구 엔티티이다. 쿠버네티스는 이러한 엔티티들을 사용하여 클러스터의 상태를 나타낸다. 쿠버네티스 오브젝트 모델과 쿠버네티스 오브젝트를 사용하는 방법에 대해 학습한다.
"><meta name=twitter:description content="쿠버네티스 오브젝트는 쿠버네티스 시스템의 영구 엔티티이다. 쿠버네티스는 이러한 엔티티들을 사용하여 클러스터의 상태를 나타낸다. 쿠버네티스 오브젝트 모델과 쿠버네티스 오브젝트를 사용하는 방법에 대해 학습한다.
"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/"><meta property="og:title" content="쿠버네티스 오브젝트로 작업하기"><meta name=twitter:title content="쿠버네티스 오브젝트로 작업하기"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/overview/working-with-objects/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/overview/working-with-objects/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/concepts/overview/working-with-objects/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/concepts/overview/working-with-objects/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/overview/working-with-objects/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/overview/working-with-objects/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/concepts/overview/working-with-objects/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/overview/working-with-objects/>Français (French)</a>
<a class=dropdown-item href=/es/docs/concepts/overview/working-with-objects/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/overview/working-with-objects/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/overview/working-with-objects/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/concepts/overview/working-with-objects/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/concepts/overview/working-with-objects/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>쿠버네티스 오브젝트로 작업하기</h1><div class=lead>쿠버네티스 오브젝트는 쿠버네티스 시스템의 영구 엔티티이다. 쿠버네티스는 이러한 엔티티들을 사용하여 클러스터의 상태를 나타낸다. 쿠버네티스 오브젝트 모델과 쿠버네티스 오브젝트를 사용하는 방법에 대해 학습한다.</div><ul><li>1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>쿠버네티스 오브젝트 이해하기</a></li><li>2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>쿠버네티스 오브젝트 관리</a></li><li>3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>오브젝트 이름과 ID</a></li><li>4: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>네임스페이스</a></li><li>5: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>레이블과 셀렉터</a></li><li>6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>어노테이션</a></li><li>7: <a href=#pg-13ce5627ef1dc8cbb4530ed231cb7d38>파이널라이저</a></li><li>8: <a href=#pg-046c03090d47bc4b89b818dc645c3865>필드 셀렉터</a></li><li>9: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>권장 레이블</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>1 - 쿠버네티스 오브젝트 이해하기</h1><p>이 페이지에서는 쿠버네티스 오브젝트가 쿠버네티스 API에서 어떻게 표현되고, 그 오브젝트를
어떻게 <code>.yaml</code> 형식으로 표현할 수 있는지에 대해 설명한다.</p><h2 id=kubernetes-objects>쿠버네티스 오브젝트 이해하기</h2><p><em>쿠버네티스 오브젝트</em> 는 쿠버네티스 시스템에서 영속성을 가지는 오브젝트이다. 쿠버네티스는 클러스터의 상태를
나타내기 위해 이 오브젝트를 이용한다. 구체적으로 말하자면, 다음같이 기술할 수 있다.</p><ul><li>어떤 컨테이너화된 애플리케이션이 동작 중인지 (그리고 어느 노드에서 동작 중인지)</li><li>그 애플리케이션이 이용할 수 있는 리소스</li><li>그 애플리케이션이 어떻게 재구동 정책, 업그레이드, 그리고 내고장성과 같은 것에 동작해야 하는지에 대한 정책</li></ul><p>쿠버네티스 오브젝트는 하나의 "의도를 담은 레코드"이다. 오브젝트를 생성하게 되면, 쿠버네티스 시스템은
그 오브젝트 생성을 보장하기 위해 지속적으로 작동할 것이다. 오브젝트를 생성함으로써, 여러분이 클러스터의
워크로드를 어떤 형태로 보이고자 하는지에 대해 효과적으로 쿠버네티스 시스템에 전한다. 이것이 바로 여러분의
클러스터에 대해 <em>의도한 상태</em> 가 된다.</p><p>생성이든, 수정이든, 또는 삭제든 쿠버네티스 오브젝트를 동작시키려면,
<a href=/ko/docs/concepts/overview/kubernetes-api/>쿠버네티스 API</a>를 이용해야 한다. 예를 들어,
<code>kubectl</code> 커맨드-라인 인터페이스를 이용할 때, CLI는 여러분 대신 필요한 쿠버네티스 API를 호출해 준다.
또한, 여러분은 <a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리</a> 중 하나를
이용하여 여러분만의 프로그램에서 쿠버네티스 API를 직접 이용할 수도 있다.</p><h3 id=오브젝트-명세-spec-와-상태-status>오브젝트 명세(spec)와 상태(status)</h3><p>거의 모든 쿠버네티스 오브젝트는 오브젝트의 구성을 결정해주는
두 개의 중첩된 오브젝트 필드를 포함하는데 오브젝트 <em><code>spec</code></em> 과 오브젝트 <em><code>status</code></em> 이다.
<code>spec</code>을 가진 오브젝트는 오브젝트를 생성할 때 리소스에
원하는 특징(<em>의도한 상태</em>)에 대한 설명을
제공해서 설정한다.</p><p><code>status</code> 는 쿠버네티스 시스템과 컴포넌트에 의해 제공되고
업데이트된 오브젝트의 <em>현재 상태</em> 를 설명한다. 쿠버네티스
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>은 모든 오브젝트의
실제 상태를 사용자가 의도한 상태와 일치시키기 위해 끊임없이 그리고
능동적으로 관리한다.</p><p>예를 들어, 쿠버네티스 디플로이먼트는 클러스터에서 동작하는 애플리케이션을
표현해줄 수 있는 오브젝트이다. 디플로이먼트를 생성할 때, 디플로이먼트
spec에 3개의 애플리케이션 레플리카가 동작되도록
설정할 수 있다. 쿠버네티스 시스템은 그 디플로이먼트 spec을 읽어
spec에 일치되도록 상태를 업데이트하여 3개의 의도한
애플리케이션 인스턴스를 구동시킨다. 만약, 그 인스턴스들 중 어느 하나가
어떤 문제로 인해 멈춘다면(상태 변화 발생), 쿠버네티스 시스템은 보정(이
경우에는 대체 인스턴스를 시작하여)을 통해
spec과 status간의 차이에 대응한다.</p><p>오브젝트 명세, 상태, 그리고 메타데이터에 대한 추가 정보는,
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Kubernetes API Conventions</a> 를 참조한다.</p><h3 id=쿠버네티스-오브젝트-기술하기>쿠버네티스 오브젝트 기술하기</h3><p>쿠버네티스에서 오브젝트를 생성할 때, (이름과 같은)오브젝트에 대한 기본적인 정보와 더불어,
의도한 상태를 기술한 오브젝트 spec을 제시해 줘야만 한다. 오브젝트를 생성하기 위해
(직접이든 또는 <code>kubectl</code>을 통해서든) 쿠버네티스 API를 이용할 때, API 요청은 요청 내용 안에
JSON 형식으로 정보를 포함시켜 줘야만 한다. <strong>대부분의 경우 정보를 .yaml 파일로 <code>kubectl</code>에
제공한다.</strong> <code>kubectl</code>은 API 요청이 이루어질 때, JSON 형식으로 정보를
변환시켜 준다.</p><p>여기 쿠버네티스 디플로이먼트를 위한 필수 필드와 오브젝트 spec을 보여주는 <code>.yaml</code> 파일 예시가 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>위 예시와 같이 .yaml 파일을 이용하여 디플로이먼트를 생성하기 위한 하나의 방식으로는
<code>kubectl</code> 커맨드-라인 인터페이스에 인자값으로 <code>.yaml</code> 파일을 건네
<a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a> 커맨드를 이용하는 것이다. 다음 예시와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</span></span></code></pre></div><p>그 출력 내용은 다음과 유사하다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=요구되는-필드>요구되는 필드</h3><p>생성하고자 하는 쿠버네티스 오브젝트에 대한 <code>.yaml</code> 파일 내, 다음 필드를 위한 값들을 설정해 줘야한다.</p><ul><li><code>apiVersion</code> - 이 오브젝트를 생성하기 위해 사용하고 있는 쿠버네티스 API 버전이 어떤 것인지</li><li><code>kind</code> - 어떤 종류의 오브젝트를 생성하고자 하는지</li><li><code>metadata</code> - <code>이름</code> 문자열, <code>UID</code>, 그리고 선택적인 <code>네임스페이스</code>를 포함하여 오브젝트를 유일하게 구분지어 줄 데이터</li><li><code>spec</code> - 오브젝트에 대해 어떤 상태를 의도하는지</li></ul><p>오브젝트 <code>spec</code>에 대한 정확한 포맷은 모든 쿠버네티스 오브젝트마다 다르고, 그 오브젝트 특유의
중첩된 필드를 포함한다. <a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 API 레퍼런스</a> 는
쿠버네티스를 이용하여 생성할 수 있는 오브젝트에 대한 모든 spec 포맷을 살펴볼 수 있도록 해준다.</p><p>예를 들어, 파드 API 레퍼런스를 보려면
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec><code>spec</code> 필드</a>를 참조한다.
각 파드에 대해, <code>.spec</code> 필드는 파드 및 파드의 원하는 상태(desired state)를
기술한다(예: 파드의 각 컨테이너에 대한 컨테이너 이미지).
오브젝트 상세에 대한 또 다른 예시는 스테이트풀셋 API의
<a href=/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec><code>spec</code> 필드</a>이다.
스테이트풀셋의 경우, <code>.spec</code> 필드는 스테이트풀셋 및 스테이트풀셋의 원하는 상태(desired state)를 기술한다.
스테이트풀셋의 <code>.spec</code>에는 파드 오브젝트에 대한
<a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>템플릿</a>이 존재한다.
이 템플릿은 스테이트풀셋 명세를 만족시키기 위해
스테이트풀셋 컨트롤러가 생성할 파드에 대한 상세 사항을 설명한다.
서로 다른 종류의 오브젝트는 서로 다른 <code>.status</code>를 가질 수 있다.
다시 한번 말하자면, 각 API 레퍼런스 페이지는 각 오브젝트 타입에 대해 해당 <code>.status</code> 필드의 구조와 내용에 대해 소개한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/workloads/pods/>파드</a>와 같이, 가장 중요하고 기본적인 쿠버네티스 오브젝트에 대해 배운다.</li><li>쿠버네티스의 <a href=/ko/docs/concepts/architecture/controller/>컨트롤러</a>에 대해 배운다.</li><li>API 개념의 더 많은 설명은 <a href=/ko/docs/reference/using-api/>쿠버네티스 API 사용</a>을 본다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6751db8ff5409476de8225d17d6c42dd>2 - 쿠버네티스 오브젝트 관리</h1><p><code>kubectl</code> 커맨드라인 툴은 쿠버네티스 오브젝트를 생성하고 관리하기 위한
몇 가지 상이한 방법을 지원한다. 이 문서는 여러가지 접근법에 대한 개요를
제공한다. Kubectl로 오브젝트 관리하기에 대한 자세한 설명은
<a href=https://kubectl.docs.kubernetes.io>Kubectl 서적</a>에서 확인한다.</p><h2 id=관리-기법>관리 기법</h2><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 쿠버네티스 오브젝트는 하나의 기법만 사용하여 관리해야 한다. 동일한 오브젝트에
대해 여러 기법을 혼용하는 것은 예상치 못한 동작을 초래하게 된다.</div><table><thead><tr><th>관리기법</th><th>대상</th><th>권장 환경</th><th>지원하는 작업자 수</th><th>학습 난이도</th></tr></thead><tbody><tr><td>명령형 커맨드</td><td>활성 오브젝트</td><td>개발 환경</td><td>1+</td><td>낮음</td></tr><tr><td>명령형 오브젝트 구성</td><td>개별 파일</td><td>프로덕션 환경</td><td>1</td><td>보통</td></tr><tr><td>선언형 오브젝트 구성</td><td>파일이 있는 디렉터리</td><td>프로덕션 환경</td><td>1+</td><td>높음</td></tr></tbody></table><h2 id=명령형-커맨드>명령형 커맨드</h2><p>명령형 커맨드를 사용할 경우, 사용자는 클러스터 내 활성 오브젝트를 대상으로
직접 동작시킨다. 사용자는 실행할 작업을 인수 또는 플래그로 <code>kubectl</code> 커맨드에
지정한다.</p><p>이것은 클러스터에서 일회성 작업을 개시시키거나 동작시키기 위한
추천 방법이다. 이 기법은 활성 오브젝트를 대상으로 직접적인
영향을 미치기 때문에, 이전 구성에 대한 이력을 제공해 주지 않는다.</p><h3 id=예시>예시</h3><p>디플로이먼트 오브젝트를 생성하여 nginx 컨테이너의 인스턴스를 구동시킨다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id=트레이드-오프>트레이드 오프</h3><p>오브젝트 구성에 비해 장점은 다음과 같다.</p><ul><li>커맨드는 하나의 동작을 나타내는 단어로 표현된다.</li><li>커맨드는 클러스터를 수정하기 위해 단 하나의 단계만을 필요로 한다.</li></ul><p>오브젝트 구성에 비해 단점은 다음과 같다.</p><ul><li>커맨드는 변경 검토 프로세스와 통합되지 않는다.</li><li>커맨드는 변경에 관한 감사 추적(audit trail)을 제공하지 않는다.</li><li>커맨드는 활성 동작 중인 경우를 제외하고는 레코드의 소스를 제공하지 않는다.</li><li>커맨드는 새로운 오브젝트 생성을 위한 템플릿을 제공하지 않는다.</li></ul><h2 id=명령형-오브젝트-구성>명령형 오브젝트 구성</h2><p>명령형 오브젝트 구성에서는 kubectl 커맨드로 작업(생성, 교체 등),
선택적 플래그, 그리고 최소 하나의 파일 이름을 지정한다.
그 파일은 YAML 또는 JSON 형식으로 오브젝트의 완전한 정의를
포함해야만 한다.</p><p>오브젝트 정의에 대한 더 자세한 내용은 <a href=/docs/reference/generated/kubernetes-api/v1.25/>API 참조</a>를
참고한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 명령형 <code>replace</code> 커맨드는 기존 spec을 새로 제공된 spec으로 바꾸고
구성 파일에서 누락된 오브젝트의 모든 변경 사항을 삭제한다.
이 방법은 spec이 구성 파일과는 별개로 업데이트되는 리소스 유형에는
사용하지 말아야한다.
예를 들어 <code>LoadBalancer</code> 유형의 서비스는 클러스터의 구성과 별도로
<code>externalIPs</code> 필드가 업데이트된다.</div><h3 id=예시-1>예시</h3><p>구성 파일에 정의된 오브젝트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>두 개의 구성 파일에 정의된 오브젝트를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>활성 동작하는 구성을 덮어씀으로써 구성 파일에 정의된 오브젝트를
업데이트한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id=트레이드-오프-1>트레이드 오프</h3><p>명령형 커맨드에 비해 장점은 다음과 같다.</p><ul><li>오브젝트 구성은 Git과 같은 소스 컨트롤 시스템에 보관할 수 있다.</li><li>오브젝트 구성은 푸시와 감사 추적 전에 변경사항을 검토하는 것과 같은 프로세스들과 통합할 수 있다.</li><li>오브젝트 구성은 새로운 오브젝트 생성을 위한 템플릿을 제공한다.</li></ul><p>명령형 커맨드에 비해 단점은 다음과 같다.</p><ul><li>오브젝트 구성은 오브젝트 스키마에 대한 기본적인 이해를 필요로 한다.</li><li>오브젝트 구성은 YAML 파일을 기록하는 추가적인 과정을 필요로 한다.</li></ul><p>선언형 오브젝트 구성에 비해 장점은 다음과 같다.</p><ul><li>명령형 오브젝트 구성의 동작은 보다 간결하고 이해하기 쉽다.</li><li>쿠버네티스 버전 1.5 부터는 더 성숙한 명령형 오브젝트 구성을 제공한다.</li></ul><p>선언형 오브젝트 구성에 비해 단점은 다음과 같다.</p><ul><li>명령형 오브젝트 구성은 디렉터리가 아닌, 파일에 가장 적합하다.</li><li>활성 오브젝트에 대한 업데이트는 구성 파일에 반영되어야 한다. 그렇지 않으면 다음 교체 중에 손실된다.</li></ul><h2 id=선언형-오브젝트-구성>선언형 오브젝트 구성</h2><p>선언형 오브젝트 구성을 사용할 경우, 사용자는 로컬에 보관된 오브젝트
구성 파일을 대상으로 작동시키지만, 사용자는 파일에서 수행 할
작업을 정의하지 않는다. 생성, 업데이트, 그리고 삭제 작업은
<code>kubectl</code>에 의해 오브젝트마다 자동으로 감지된다. 이를 통해 다른 오브젝트에 대해
다른 조작이 필요할 수 있는 디렉터리에서 작업할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 선언형 오브젝트 구성은 변경 사항이 오브젝트 구성 파일에
다시 병합되지 않더라도 다른 작성자가 작성한 변경 사항을 유지한다.
이것은 전체 오브젝트 구성 변경을 위한 <code>replace</code> API를
사용하는 대신, <code>patch</code> API를 사용하여 인지되는 차이만
작성하기 때문에 가능하다.</div><h3 id=예시-2>예시</h3><p><code>configs</code> 디렉터리 내 모든 오브젝트 구성 파일을 처리하고 활성 오브젝트를
생성 또는 패치한다. 먼저 어떠한 변경이 이루어지게 될지 알아보기 위해 <code>diff</code>
하고 나서 적용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -f configs/
</span></span><span style=display:flex><span>kubectl apply -f configs/
</span></span></code></pre></div><p>재귀적으로 디렉터리를 처리한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -R -f configs/
</span></span><span style=display:flex><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id=트레이드-오프-2>트레이드 오프</h3><p>명령형 오브젝트 구성에 비해 장점은 다음과 같다.</p><ul><li>활성 오브젝트에 직접 작성된 변경 사항은 구성 파일로 다시 병합되지 않더라도 유지된다.</li><li>선언형 오브젝트 구성은 디렉터리에서의 작업 및 오브젝트 별 작업 유형(생성, 패치, 삭제)의 자동 감지에 더 나은 지원을 제공한다.</li></ul><p>명령형 오브젝트 구성에 비해 단점은 다음과 같다.</p><ul><li>선언형 오브젝트 구성은 예상치 못한 결과를 디버깅하고 이해하기가 더 어렵다.</li><li>diff를 사용한 부분 업데이트는 복잡한 병합 및 패치 작업을 일으킨다.</li></ul><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-command/>명령형 커맨드를 이용한 쿠버네티스 오브젝트 관리하기</a></li><li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-config/>구성파일을 이용한 명령형 쿠버네티스 오브젝트 관리</a></li><li><a href=/ko/docs/tasks/manage-kubernetes-objects/declarative-config/>구성 파일을 이용한 쿠버네티스 오브젝트의 선언형 관리</a></li><li><a href=/ko/docs/tasks/manage-kubernetes-objects/kustomization/>Kustomize를 이용한 쿠버네티스 오브젝트의 선언형 관리</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl 커맨드 참조</a></li><li><a href=https://kubectl.docs.kubernetes.io>Kubectl 서적</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 API 참조</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>3 - 오브젝트 이름과 ID</h1><p>클러스터의 각 오브젝트는 해당 유형의 리소스에 대하여 고유한 <a href=#names><em>이름</em></a> 을 가지고 있다.
또한, 모든 쿠버네티스 오브젝트는 전체 클러스터에 걸쳐 고유한 <a href=#uids><em>UID</em></a> 를 가지고 있다.</p><p>예를 들어, 이름이 <code>myapp-1234</code>인 파드는 동일한 <a href=/ko/docs/concepts/overview/working-with-objects/namespaces/>네임스페이스</a> 내에서 하나만 존재할 수 있지만, 이름이 <code>myapp-1234</code>인 파드와 디플로이먼트는 각각 존재할 수 있다.</p><p>유일하지 않은 사용자 제공 속성의 경우 쿠버네티스는 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>과 <a href=/ko/docs/concepts/overview/working-with-objects/annotations/>어노테이션</a>을 제공한다.</p><h2 id=names>이름</h2><p><code>/api/v1/pods/some-name</code>과 같이, 리소스 URL에서 오브젝트를 가리키는 클라이언트 제공 문자열.</p><p>특정 시점에 같은 종류(kind) 내에서는 하나의 이름은 하나의 오브젝트에만 지정될 수 있다. 하지만, 오브젝트를 삭제한 경우, 삭제된 오브젝트와 같은 이름을 새로운 오브젝트에 지정 가능하다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 물리적 호스트를 나타내는 노드와 같이 오브젝트가 물리적 엔티티를 나타내는 경우, 노드를 삭제한 후 다시 생성하지 않은 채 동일한 이름으로 호스트를 다시 생성하면, 쿠버네티스는 새 호스트를 불일치로 이어질 수 있는 이전 호스트로 취급한다.</div><p>다음은 리소스에 일반적으로 사용되는 네 가지 유형의 이름 제한 조건이다.</p><h3 id=dns-서브도메인-이름>DNS 서브도메인 이름</h3><p>대부분의 리소스 유형에는 <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>에 정의된 대로
DNS 서브도메인 이름으로 사용할 수 있는 이름이 필요하다.
이것은 이름이 다음을 충족해야 한다는 것을 의미한다.</p><ul><li>253자를 넘지 말아야 한다.</li><li>소문자와 영숫자 <code>-</code> 또는 <code>.</code> 만 포함한다.</li><li>영숫자로 시작한다.</li><li>영숫자로 끝난다.</li></ul><h3 id=dns-label-names>RFC 1123 레이블 이름</h3><p>일부 리소스 유형은 <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>에
정의된 대로 DNS 레이블 표준을 따라야 한다.
이것은 이름이 다음을 충족해야 한다는 것을 의미한다.</p><ul><li>최대 63자이다.</li><li>소문자와 영숫자 또는 <code>-</code> 만 포함한다.</li><li>영숫자로 시작한다.</li><li>영숫자로 끝난다.</li></ul><h3 id=rfc-1035-레이블-이름>RFC 1035 레이블 이름</h3><p>몇몇 리소스 타입은 자신의 이름을 <a href=https://tools.ietf.org/html/rfc1035>RFC 1035</a>에
정의된 DNS 레이블 표준을 따르도록 요구한다.
이것은 이름이 다음을 만족해야 한다는 의미이다.</p><ul><li>최대 63개 문자를 포함</li><li>소문자 영숫자 또는 '-'만 포함</li><li>알파벳 문자로 시작</li><li>영숫자로 끝남</li></ul><h3 id=경로-세그먼트-이름>경로 세그먼트 이름</h3><p>일부 리소스 유형에서는 이름을 경로 세그먼트로 안전하게 인코딩 할 수
있어야 한다. 즉 이름이 "." 또는 ".."이 아닐 수 있으며 이름에는
"/" 또는 "%"가 포함될 수 없다.</p><p>아래는 파드의 이름이 <code>nginx-demo</code>라는 매니페스트 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 일부 리소스 유형은 이름에 추가적인 제약이 있다.</div><h2 id=uids>UID</h2><p>오브젝트를 중복 없이 식별하기 위해 쿠버네티스 시스템이 생성하는 문자열.</p><p>쿠버네티스 클러스터가 구동되는 전체 시간에 걸쳐 생성되는 모든 오브젝트는 서로 구분되는 UID를 갖는다. 이는 기록상 유사한 오브젝트의 출현을 서로 구분하기 위함이다.</p><p>쿠버네티스 UID는 보편적으로 고유한 식별자이다(또는 UUID라고 한다).
UUID는 ISO/IEC 9834-8 과 ITU-T X.667 로 표준화 되어 있다.</p><h2 id=다음-내용>다음 내용</h2><ul><li>쿠버네티스의 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>에 대해 읽기.</li><li><a href=https://git.k8s.io/design-proposals-archive/architecture/identifiers.md>쿠버네티스의 식별자와 이름</a> 디자인 문서 읽기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>4 - 네임스페이스</h1><p>쿠버네티스에서, <em>네임스페이스</em> 는 단일 클러스터 내에서의 리소스 그룹 격리 메커니즘을 제공한다. 리소스의 이름은 네임스페이스 내에서 유일해야 하며, 네임스페이스 간에서 유일할 필요는 없다. 네임스페이스 기반 스코핑은 네임스페이스 기반 오브젝트 <em>(예: 디플로이먼트, 서비스 등)</em> 에만 적용 가능하며 클러스터 범위의 오브젝트 <em>(예: 스토리지클래스, 노드, 퍼시스턴트볼륨 등)</em> 에는 적용 불가능하다.</p><h2 id=여러-개의-네임스페이스를-사용하는-경우>여러 개의 네임스페이스를 사용하는 경우</h2><p>네임스페이스는 여러 개의 팀이나, 프로젝트에 걸쳐서 많은 사용자가 있는 환경에서 사용하도록
만들어졌다. 사용자가 거의 없거나, 수 십명 정도가 되는 경우에는
네임스페이스를 전혀 고려할 필요가 없다.
네임스페이스가 제공하는 기능이 필요할 때 사용하도록 하자.</p><p>네임스페이스는 이름의 범위를 제공한다. 리소스의 이름은 네임스페이스 내에서 유일해야하지만,
네임스페이스를 통틀어서 유일할 필요는 없다. 네임스페이스는 서로 중첩될 수 없으며,
각 쿠버네티스 리소스는 하나의 네임스페이스에만 있을 수 있다.</p><p>네임스페이스는 클러스터 자원을 (<a href=/ko/docs/concepts/policy/resource-quotas/>리소스 쿼터</a>를 통해) 여러 사용자 사이에서 나누는 방법이다.</p><p>동일한 소프트웨어의 다른 버전과 같이 약간 다른 리소스를 분리하기 위해
여러 네임스페이스를 사용할 필요는 없다. 동일한 네임스페이스 내에서 리소스를
구별하기 위해 <a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>을
사용한다.</p><h2 id=네임스페이스-다루기>네임스페이스 다루기</h2><p>네임스페이스의 생성과 삭제는
<a href=/ko/docs/tasks/administer-cluster/namespaces/>네임스페이스 관리자 가이드 문서</a>에 기술되어 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kube-</code> 접두사로 시작하는 네임스페이스는 쿠버네티스 시스템용으로 예약되어 있으므로, 사용자는 이러한 네임스페이스를 생성하지 않는다.</div><h3 id=네임스페이스-조회>네임스페이스 조회</h3><p>사용 중인 클러스터의 현재 네임스페이스를 나열할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
</code></pre><p>쿠버네티스는 처음에 네 개의 초기 네임스페이스를 갖는다.</p><ul><li><code>default</code> 다른 네임스페이스가 없는 오브젝트를 위한 기본 네임스페이스</li><li><code>kube-system</code> 쿠버네티스 시스템에서 생성한 오브젝트를 위한 네임스페이스</li><li><code>kube-public</code> 이 네임스페이스는 자동으로 생성되며 모든 사용자(인증되지 않은 사용자 포함)가 읽기 권한으로 접근할 수 있다. 이 네임스페이스는 주로 전체 클러스터 중에 공개적으로 드러나서 읽을 수 있는 리소스를 위해 예약되어 있다. 이 네임스페이스의 공개적인 성격은 단지 관례이지 요구 사항은 아니다.</li><li><code>kube-node-lease</code> 이 네임스페이스는 각 노드와 연관된 <a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>리스</a>
오브젝트를 갖는다. 노드 리스는 kubelet이 <a href=/ko/docs/concepts/architecture/nodes/#%ED%95%98%ED%8A%B8%EB%B9%84%ED%8A%B8>하트비트</a>를
보내서 컨트롤 플레인이 노드의 장애를 탐지할 수 있게 한다.</li></ul><h3 id=요청에-네임스페이스-설정하기>요청에 네임스페이스 설정하기</h3><p>현재 요청에 대한 네임스페이스를 설정하기 위해서 <code>--namespace</code> 플래그를 사용한다.</p><p>예를 들면,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id=선호하는-네임스페이스-설정하기>선호하는 네임스페이스 설정하기</h3><p>이후 모든 kubectl 명령에서 사용하는 네임스페이스를 컨텍스트에
영구적으로 저장할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 확인하기</span>
</span></span><span style=display:flex><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id=네임스페이스와-dns>네임스페이스와 DNS</h2><p><a href=/ko/docs/concepts/services-networking/service/>서비스</a>를 생성하면 해당
<a href=/ko/docs/concepts/services-networking/dns-pod-service/>DNS 엔트리</a>가 생성된다.
이 엔트리는 <code>&lt;서비스-이름>.&lt;네임스페이스-이름>.svc.cluster.local</code>의 형식을 갖는데,
이는 컨테이너가 <code>&lt;서비스-이름></code>만 사용하는 경우, 네임스페이스 내에 국한된 서비스로 연결된다.
개발, 스테이징, 운영과 같이 여러 네임스페이스 내에서 동일한 설정을 사용하는 경우에 유용하다.
네임스페이스를 넘어서 접근하기 위해서는,
전체 주소 도메인 이름(FQDN)을 사용해야 한다.</p><p>그렇기 때문에, 모든 네임스페이스 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-label-names>RFC 1123 DNS 레이블</a>이어야 한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong><p>네임스페이스의 이름을 <a href=https://data.iana.org/TLD/tlds-alpha-by-domain.txt>공개 최상위 도메인</a> 중 하나와 동일하게 만들면,
해당 네임스페이스 내의 서비스의 짧은 DNS 이름이 공개 DNS 레코드와 겹칠 수 있다.
어떠한 네임스페이스 내의 워크로드가
<a href=https://datatracker.ietf.org/doc/html/rfc1034#page-8>접미점(trailing dot)</a> 없이 DNS 룩업을 수행하면
공개 DNS 레코드보다 우선하여 해당 서비스로 리다이렉트될 것이다.</p><p>이를 방지하기 위해, 신뢰하는 사용자만 네임스페이스를
생성할 수 있도록 권한을 제한한다.
필요한 경우, 추가적으로 써드파티 보안 컨트롤을 구성할 수 있으며,
예를 들어 <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>어드미션 웹훅</a>을 이용하여
<a href=https://data.iana.org/TLD/tlds-alpha-by-domain.txt>공개 TLD</a>와
동일한 이름의 네임스페이스 생성을 금지시킬 수 있다.</p></div><h2 id=모든-오브젝트가-네임스페이스에-속하지는-않음>모든 오브젝트가 네임스페이스에 속하지는 않음</h2><p>대부분의 쿠버네티스 리소스(예를 들어, 파드, 서비스, 레플리케이션 컨트롤러 외)는
네임스페이스에 속한다. 하지만 네임스페이스 리소스 자체는 네임스페이스에 속하지 않는다.
그리고 <a href=/ko/docs/concepts/architecture/nodes/>노드</a>나
퍼시스턴트 볼륨과 같은 저수준 리소스는 어느
네임스페이스에도 속하지 않는다.</p><p>다음은 네임스페이스에 속하지 않는 쿠버네티스 리소스를 조회하는 방법이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 네임스페이스에 속하는 리소스</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 네임스페이스에 속하지 않는 리소스</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h2 id=자동-레이블링>자동 레이블링</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes 1.21 [beta]</code></div><p>쿠버네티스 컨트롤 플레인은 <code>NamespaceDefaultLabelName</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가
활성화된 경우 모든 네임스페이스에 변경할 수 없는(immutable) <a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>
<code>kubernetes.io / metadata.name</code> 을 설정한다.
레이블 값은 네임스페이스 이름이다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/administer-cluster/namespaces/#%EC%83%88-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0>신규 네임스페이스 생성</a>에 대해 더 배우기.</li><li><a href=/ko/docs/tasks/administer-cluster/namespaces/#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0>네임스페이스 삭제</a>에 대해 더 배우기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>5 - 레이블과 셀렉터</h1><p><em>레이블</em> 은 파드와 같은 오브젝트에 첨부된 키와 값의 쌍이다.
레이블은 오브젝트의 특성을 식별하는 데 사용되어 사용자에게 중요하지만, 코어 시스템에 직접적인 의미는 없다.
레이블로 오브젝트의 하위 집합을 선택하고, 구성하는데 사용할 수 있다. 레이블은 오브젝트를 생성할 때에 붙이거나 생성 이후에 붙이거나 언제든지 수정이 가능하다.
오브젝트마다 키와 값으로 레이블을 정의할 수 있다. 오브젝트의 키는 고유한 값이어야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>레이블은 UI와 CLI에서 효율적인 쿼리를 사용하고 검색에 사용하기에
적합하다. 식별되지 않는 정보는
<a href=/ko/docs/concepts/overview/working-with-objects/annotations/>어노테이션</a>으로 기록해야 한다.</p><h2 id=사용-동기>사용 동기</h2><p>레이블을 이용하면 사용자가 느슨하게 결합한 방식으로 조직 구조와 시스템 오브젝트를 매핑할 수 있으며, 클라이언트에 매핑 정보를 저장할 필요가 없다.</p><p>서비스 배포와 배치 프로세싱 파이프라인은 흔히 다차원의 엔티티들이다(예: 다중 파티션 또는 배포, 다중 릴리스 트랙, 다중 계층, 계층 속 여러 마이크로 서비스들). 관리에는 크로스-커팅 작업이 필요한 경우가 많은데 이 작업은 사용자보다는 인프라에 의해 결정된 엄격한 계층 표현인 캡슐화를 깨트린다.</p><p>레이블 예시:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>이 예시는 <a href=/ko/docs/concepts/overview/working-with-objects/common-labels/>일반적으로 사용하는 레이블</a>이며, 사용자는 자신만의 규칙(convention)에 따라 자유롭게 개발할 수 있다. 오브젝트에 붙여진 레이블 키는 고유해야 한다는 것을 기억해야 한다.</p><h2 id=구문과-캐릭터-셋>구문과 캐릭터 셋</h2><p><em>레이블</em> 은 키와 값의 쌍이다. 유효한 레이블 키에는 슬래시(<code>/</code>)로 구분되는 선택한 접두사와 이름이라는 2개의 세그먼트가 있다. 이름 세그먼트는 63자 미만으로 시작과 끝은 알파벳과 숫자(<code>[a-z0-9A-Z]</code>)이며, 대시(<code>-</code>), 밑줄(<code>_</code>), 점(<code>.</code>)과 함께 사용할 수 있다. 접두사는 선택이다. 만약 접두사를 지정한 경우 접두사는 DNS의 하위 도메인으로 해야 하며, 점(<code>.</code>)과 전체 253자 이하, 슬래시(<code>/</code>)로 구분되는 DNS 레이블이다.</p><p>접두사를 생략하면 키 레이블은 개인용으로 간주한다. 최종 사용자의 오브젝트에 자동화된 시스템 컴포넌트(예: <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code> 또는 다른 타사의 자동화 구성 요소)의 접두사를 지정해야 한다.</p><p><code>kubernetes.io/</code>와 <code>k8s.io/</code> 접두사는 쿠버네티스의 핵심 컴포넌트로 <a href=/ko/docs/reference/labels-annotations-taints/>예약</a>되어 있다.</p><p>유효한 레이블 값은 다음과 같다.</p><ul><li>63 자 이하여야 하고 (공백일 수도 있음),</li><li>(공백이 아니라면) 시작과 끝은 알파벳과 숫자(<code>[a-z0-9A-Z]</code>)이며,</li><li>알파벳과 숫자, 대시(<code>-</code>), 밑줄(<code>_</code>), 점(<code>.</code>)을 중간에 포함할 수 있다.</li></ul><p>다음의 예시는 파드에 <code>environment: production</code> 과 <code>app: nginx</code> 2개의 레이블이 있는 구성 파일이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=레이블-셀렉터>레이블 셀렉터</h2><p><a href=/ko/docs/concepts/overview/working-with-objects/names/>이름과 UID</a>와 다르게 레이블은 고유하지 않다. 일반적으로 우리는 많은 오브젝트에 같은 레이블을 가질 것으로 예상한다.</p><p>레이블 셀렉터를 통해 클라이언트와 사용자는 오브젝트를 식별할 수 있다. 레이블 셀렉터는 쿠버네티스 코어 그룹의 기본이다.</p><p>API는 현재 <em>일치성 기준</em> 과 <em>집합성 기준</em> 이라는 두 종류의 셀렉터를 지원한다.
레이블 셀렉터는 쉼표로 구분된 다양한 <em>요구사항</em> 에 따라 만들 수 있다. 다양한 요구사항이 있는 경우 쉼표 기호가 AND(<code>&&</code>) 연산자로 구분되는 역할을 하도록 해야 한다.</p><p>비어있거나 지정되지 않은 셀렉터는 상황에 따라 달라진다.
셀렉터를 사용하는 API 유형은 유효성과 의미를
문서화해야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 레플리카셋(ReplicaSet)과 같은 일부 API 유형에서 두 인스턴스의 레이블 셀렉터는 네임스페이스 내에서 겹치지 않아야 한다. 그렇지 않으면 컨트롤러는 상충하는 명령으로 보고, 얼마나 많은 복제본이 필요한지 알 수 없다.</div><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 일치성 기준과 집합성 기준 조건 모두에 대해 논리적인 <em>OR</em> (<code>||</code>) 연산자가 없다. 필터 구문이 적절히 구성되어 있는지 확인해야 한다.</div><h3 id=일치성-기준-요건><em>일치성 기준</em> 요건</h3><p><em>일치성 기준</em> 또는 <em>불일치 기준</em> 의 요구사항으로 레이블의 키와 값의 필터링을 허용한다. 일치하는 오브젝트는 추가 레이블을 가질 수 있지만, 레이블의 명시된 제약 조건을 모두 만족해야 한다.
<code>=</code>,<code>==</code>,<code>!=</code> 이 세 가지 연산자만 허용한다. 처음 두 개의 연산자의 <em>일치성</em>(그리고 동의어), 나머지는 <em>불일치</em> 를 의미한다. 예를 들면,</p><pre tabindex=0><code>environment = production
tier != frontend
</code></pre><p>전자는 <code>environment</code>를 키로 가지는 것과 <code>production</code>을 값으로 가지는 모든 리소스를 선택한다.
후자는 <code>tier</code>를 키로 가지고, 값을 <code>frontend</code>를 가지는 리소스를 제외한 모든 리소스를 선택하고, <code>tier</code>를 키로 가지며, 값을 공백으로 가지는 모든 리소스를 선택한다.
<code>environment=production,tier!=frontend</code> 처럼 쉼표를 통해 한 문장으로 <code>frontend</code>를 제외한 <code>production</code>을 필터링할 수 있다.</p><p>일치성 기준 레이블 요건에 대한 하나의 이용 시나리오는 파드가 노드를 선택하는 기준을 지정하는 것이다.
예를 들어, 아래 샘플 파드는 "<code>accelerator=nvidia-tesla-p100</code>"
레이블을 가진 노드를 선택한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;registry.k8s.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=집합성-기준-요건><em>집합성 기준</em> 요건</h3><p><em>집합성 기준</em> 레이블 요건에 따라 값 집합을 키로 필터링할 수 있다. <code>in</code>,<code>notin</code>과 <code>exists</code>(키 식별자만 해당)의 3개의 연산자를 지원한다. 예를 들면,</p><pre tabindex=0><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><ul><li>첫 번째 예시에서 키가 <code>environment</code>이고 값이 <code>production</code> 또는 <code>qa</code>인 모든 리소스를 선택한다.</li><li>두 번째 예시에서 키가 <code>tier</code>이고 값이 <code>frontend</code>와 <code>backend</code>를 가지는 리소스를 제외한 모든 리소스와 키로 <code>tier</code>를 가지고 값을 공백으로 가지는 모든 리소스를 선택한다.</li><li>세 번째 예시에서 레이블의 값에 상관없이 키가 <code>partition</code>을 포함하는 모든 리소스를 선택한다.</li><li>네 번째 예시에서 레이블의 값에 상관없이 키가 <code>partition</code>을 포함하지 않는 모든 리소스를 선택한다.</li></ul><p>마찬가지로 쉼표는 <em>AND</em> 연산자로 작동한다. 따라서 <code>partition,environment notin (qa)</code>와 같이 사용하면 값과 상관없이 키가 <code>partition</code>인 것과 키가 <code>environment</code>이고 값이 <code>qa</code>와 다른 리소스를 필터링할 수 있다.
<em>집합성 기준</em> 레이블 셀렉터는 일반적으로 <code>environment=production</code>과 <code>environment in (production)</code>을 같은 것으로 본다. 유사하게는 <code>!=</code>과 <code>notin</code>을 같은 것으로 본다.</p><p><em>집합성 기준</em> 요건은 <em>일치성 기준</em> 요건과 조합해서 사용할 수 있다. 예를 들어 <code>partition in (customerA, customerB),environment!=qa</code></p><h2 id=api>API</h2><h3 id=list와-watch-필터링>LIST와 WATCH 필터링</h3><p>LIST와 WATCH 작업은 쿼리 파라미터를 사용해서 반환되는 오브젝트 집합을 필터링하기 위해 레이블 셀렉터를 지정할 수 있다. 다음의 두 가지 요건 모두 허용된다(URL 쿼리 문자열을 그대로 표기함).</p><ul><li><em>일치성 기준</em> 요건: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li><em>집합성 기준</em> 요건: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>두 가지 레이블 셀렉터 스타일은 모두 REST 클라이언트를 통해 선택된 리소스를 확인하거나 목록을 볼 수 있다. 예를 들어, <code>kubectl</code>로 <code>apiserver</code>를 대상으로 <em>일치성 기준</em> 으로 하는 셀렉터를 다음과 같이 이용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>또는 <em>집합성 기준</em> 요건을 사용하면</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</span></span></code></pre></div><p>앞서 안내한 것처럼 <em>집합성 기준</em> 요건은 더 보여준다. 예시에서 다음과 같이 OR 연산자를 구현할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</span></span></code></pre></div><p>또는 <em>exists</em> 연산자에 불일치한 것으로 제한할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</span></span></code></pre></div><h3 id=api-오브젝트에서-참조-설정>API 오브젝트에서 참조 설정</h3><p><a href=/ko/docs/concepts/services-networking/service/><code>services</code></a> 와
<a href=/ko/docs/concepts/workloads/controllers/replicationcontroller/><code>replicationcontrollers</code></a>와 같은
일부 쿠버네티스 오브젝트는 레이블 셀렉터를 사용해서
<a href=/ko/docs/concepts/workloads/pods/>파드</a>와 같은 다른 리소스 집합을 선택한다.</p><h4 id=서비스와-레플리케이션-컨트롤러>서비스와 레플리케이션 컨트롤러</h4><p><code>services</code>에서 지정하는 파드 집합은 레이블 셀렉터로 정의한다. 마찬가지로 <code>replicationcontrollers</code>가 관리하는 파드의 오브젝트 그룹도 레이블 셀렉터로 정의한다.</p><p>서비스와 레플리케이션 컨트롤러의 레이블 셀렉터는 <code>json</code> 또는 <code>yaml</code> 파일에 매핑된 <em>일치성 기준</em> 요구사항의 셀렉터만 지원한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>or</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>json</code> 또는 <code>yaml</code> 서식에서 셀렉터는 <code>component=redis</code> 또는 <code>component in (redis)</code> 모두 같은 것이다.</p><h4 id=세트-기반-요건을-지원하는-리소스>세트-기반 요건을 지원하는 리소스</h4><p><a href=/ko/docs/concepts/workloads/controllers/job/><code>Job</code></a>,
<a href=/ko/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>,
<a href=/ko/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a> 그리고
<a href=/ko/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a> 같은
새로운 리소스들은 <em>집합성 기준</em> 의 요건도 지원한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>matchLabels</code>는 <code>{key,value}</code>의 쌍과 매칭된다. <code>matchLabels</code>에 매칭된 단일 <code>{key,value}</code>는 <code>matchExpressions</code>의 요소와 같으며 <code>key</code> 필드는 "key"로, <code>operator</code>는 "In" 그리고 <code>values</code>에는 "value"만 나열되어 있다. <code>matchExpressions</code>는 파드 셀렉터의 요건 목록이다. 유효한 연산자에는 In, NotIn, Exists 및 DoNotExist가 포함된다. In 및 NotIn은 설정된 값이 있어야 한다. <code>matchLabels</code>와 <code>matchExpressions</code> 모두 AND로 되어 있어 일치하기 위해서는 모든 요건을 만족해야 한다.</p><h4 id=노드-셋-선택>노드 셋 선택</h4><p>레이블을 통해 선택하는 사용 사례 중 하나는 파드를 스케줄 할 수 있는 노드 셋을 제한하는 것이다.
자세한 내용은 <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/>노드 선택</a> 문서를 참조한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>6 - 어노테이션</h1><p>쿠버네티스 어노테이션을 사용하여 임의의 비-식별 메타데이터를
오브젝트에 첨부할 수 있다. 도구 및 라이브러리와 같은 클라이언트는 이 메타데이터를 검색할 수 있다.</p><h2 id=오브젝트에-메타데이터-첨부>오브젝트에 메타데이터 첨부</h2><p>레이블이나 어노테이션을 사용하여 쿠버네티스
오브젝트에 메타데이터를 첨부할 수 있다. 레이블을 사용하여 오브젝트를 선택하고, 특정 조건을 만족하는 오브젝트
컬렉션을 찾을 수 있다. 반면에, 어노테이션은
오브젝트를 식별하고 선택하는데 사용되지 않는다. 어노테이션의 메타데이터는
작거나 크고, 구조적이거나 구조적이지 않을 수 있으며, 레이블에서
허용되지 않는 문자를 포함할 수 있다.</p><p>어노테이션은 레이블과 같이 키/값 맵이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 맵의 키와 값은 문자열이어야 한다. 다르게 말해서, 숫자,
불리언(boolean), 리스트 등의 다른 형식을 키나 값에 사용할 수 없다.</div><p>다음은 어노테이션에 기록할 수 있는 정보의 예제이다.</p><ul><li><p>필드는 선언적 구성 계층에 의해 관리된다. 이러한 필드를 어노테이션으로 첨부하는 것은
클라이언트 또는 서버가 설정한 기본 값,
자동 생성된 필드, 그리고
오토사이징 또는 오토스케일링 시스템에 의해 설정된 필드와 구분된다.</p></li><li><p>빌드, 릴리스, 또는 타임 스탬프, 릴리스 ID, git 브랜치,
PR 번호, 이미지 해시 및 레지스트리 주소와 같은 이미지 정보.</p></li><li><p>로깅, 모니터링, 분석 또는 감사 리포지터리에 대한 포인터.</p></li><li><p>디버깅 목적으로 사용될 수 있는 클라이언트 라이브러리 또는 도구 정보:
예를 들면, 이름, 버전, 그리고 빌드 정보.</p></li><li><p>다른 생태계 구성 요소의 관련 오브젝트 URL과 같은
사용자 또는 도구/시스템 출처 정보.</p></li><li><p>경량 롤아웃 도구 메타데이터. 예: 구성 또는 체크포인트</p></li><li><p>책임자의 전화번호 또는 호출기 번호, 또는 팀 웹 사이트 같은
해당 정보를 찾을 수 있는 디렉터리 진입점.</p></li><li><p>행동을 수정하거나 비표준 기능을 수행하기 위한
최종 사용자의 지시 사항.</p></li></ul><p>어노테이션을 사용하는 대신, 이 유형의 정보를
외부 데이터베이스 또는 디렉터리에 저장할 수 있지만, 이는 배포, 관리, 인트로스펙션(introspection) 등을 위한
공유 클라이언트 라이브러리와 도구 생성을
훨씬 더 어렵게 만들 수 있다.</p><h2 id=문법과-캐릭터-셋>문법과 캐릭터 셋</h2><p><em>어노테이션</em> 은 키/값 쌍이다. 유효한 어노테이션 키에는 두 개의 세그먼트가 있다. 두 개의 세그먼트는 선택적인 접두사와 이름(name)이며, 슬래시(<code>/</code>)로 구분된다. 이름 세그먼트는 필수이며, 영문 숫자(<code>[a-z0-9A-Z]</code>)로 시작하고 끝나는 63자 이하이어야 하고, 사이에 대시(<code>-</code>), 밑줄(<code>_</code>), 점(<code>.</code>)이 들어갈 수 있다. 접두사는 선택적이다. 지정된 경우, 접두사는 DNS 서브도메인이어야 한다. 점(<code>.</code>)으로 구분된 일련의 DNS 레이블은 총 253자를 넘지 않고, 뒤에 슬래시(<code>/</code>)가 붙는다.</p><p>접두사가 생략되면, 어노테이션 키는 사용자에게 비공개로 간주된다. 최종 사용자 오브젝트에 어노테이션을 추가하는 자동화된 시스템 구성 요소(예 :<code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, 또는 다른 써드파티 자동화)는 접두사를 지정해야 한다.</p><p><code>kubernetes.io/</code>와 <code>k8s.io/</code> 접두사는 쿠버네티스 핵심 구성 요소를 위해 예약되어 있다.</p><p>다음은 <code>imageregistry: https://hub.docker.com/</code> 어노테이션이 있는 파드의 구성 파일 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotations-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageregistry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://hub.docker.com/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><p><a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블과 셀렉터</a>에 대해 알아본다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-13ce5627ef1dc8cbb4530ed231cb7d38>7 - 파이널라이저</h1><p>파이널라이저는 쿠버네티스가 오브젝트를 완전히 삭제하기 이전, 삭제 표시를 위해
특정 조건이 충족될 때까지 대기하도록 알려주기 위한 네임스페이스에 속한 키(namespaced key)이다.
파이널라이저는 삭제 완료된 오브젝트가 소유한 리소스를 정리하기 위해
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>에게 알린다.</p><p>파이널라이저를 가진 특정한 오브젝트를 쿠버네티스가 삭제하도록 지시할 때,
쿠버네티스 API는 <code>.metadata.delationTimestamp</code>을 덧붙여 삭제하도록 오브젝트에 표시하며,
<code>202</code> 상태코드(HTTP "Accepted")을 리턴한다. 대상 오브젝트가 Terminating 상태를 유지하는 동안 컨트롤 플레인
또는 다른 컴포넌트는 하나의 파이널라이저에서 정의한 작업을 수행한다.
정의된 작업이 완료 후에, 그 컨트롤러는 대상 오브젝트로부터 연관된 파이널라이저을 삭제한다.
<code>metadata.finalizers</code> 필드가 비어 있을 때, 쿠버네티스는
삭제가 완료된 것으로 간주하고 오브젝트를 삭제한다.</p><p>파이널라이저가 리소스들의 <a class=glossary-tooltip title='쿠버네티스가 클러스터 자원을 정리하기 위해 사용하는 다양한 방법을 종합한 용어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/garbage-collection/ target=_blank aria-label='가비지 컬렉션'>가비지 컬렉션</a>을 제어하도록
사용할 수 있다. 예를 들어, 하나의 파이널라이저를 컨트롤러가 대상 리소소를 삭제하기 전에
연관된 리소스들 또는 인프라를 정리하도록 정의할 수 있다.</p><p>파이널라이저(Finalizer)를 사용하면 리소스를 삭제하기 전 특정 정리 작업을 수행하도록
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러(Controller)>컨트롤러(Controller)</a>에 경고하여
리소스의 <a class=glossary-tooltip title='쿠버네티스가 클러스터 자원을 정리하기 위해 사용하는 다양한 방법을 종합한 용어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/garbage-collection/ target=_blank aria-label='가비지(Garbage) 수집'>가비지(Garbage) 수집</a>을 제어할 수 있다.</p><p>파이널라이저는 보통 실행할 코드를 지정하지 않는다.
대신 파이널라이저는 일반적으로 어노테이션과 비슷하게 특정 리소스에 대한 키들의 목록이다.
일부 파이널라이저는 쿠버네티스가 자동으로 지정하지만,
사용자가 직접 지정할 수도 있다.</p><h2 id=파이널라이저의-작동-방식>파이널라이저의 작동 방식</h2><p>매니페스트 파일을 사용해 리소스를 생성하면
<code>metadata.finalizers</code> 필드에 파이널라이저를 명시할 수 있다.
리소스를 삭제하려 할 때는
삭제 요청을 처리하는 API 서버가 <code>finalizers</code> 필드의 값을 인식하고 다음을 수행한다.</p><ul><li>삭제를 시작한 시각과 함께 <code>metadata.deletionTimestamp</code> 필드를 추가하도록
오브젝트를 수정한다.</li><li>오브젝트의 <code>metadata.finalizers</code> 필드가 비워질 때까지 오브젝트가 제거되지 않도록 한다.</li><li><code>202</code> 상태 코드를 리턴한다(HTTP "Accepted").</li></ul><p>이 파이널라이저를 관리하는 컨트롤러는 <code>metadata.deletionTimestamp</code>를 설정하는 오브젝트가 업데이트 되었음을 인지하여
오브젝트의 삭제가 요청되었음을 나타낸다.
그런 다음 컨트롤러는 그 리소스에 지정된 파이널라이저의 요구사항을 충족하려 시도한다.
컨트롤러는 파이널라이저 조건이 충족될 때 마다
리소스의 <code>finalizers</code> 필드에서 해당 키(key)를 제거한다.
<code>finalizers</code> 필드가 비워지면 <code>deletionTimestamp</code> 필드가 설정된 오브젝트는 자동으로 삭제된다.
또한 파이널라이저를 사용하여 관리되지 않는 리소스가 삭제되지 않도록 할 수 있다.</p><p>파이널라이저의 일반적인 예로는 <code>퍼시스턴트 볼륨(Persistent Volume)</code> 오브젝트가 실수로 삭제되는 것을 방지하는 <code>kubernetes.io/pv-protection</code>가 있다.
파드가 <code>퍼시스턴트 볼륨</code> 오브젝트를 사용 중일 때
쿠버네티스는 <code>pv-protection</code> 파이널라이저를 추가한다.
<code>퍼시스턴트 볼륨</code>을 삭제하려 하면 <code>Terminating</code> 상태가 되지만
파이널라이저가 존재하기 때문에 컨트롤러가 삭제할 수 없다.
파드가 <code>퍼시스턴트 볼륨</code>의 사용을 중지하면
쿠버네티스가 <code>pv-protection</code> 파이널라이저를 해제하고 컨트롤러는 볼륨을 삭제한다.</p><h2 id=소유자-레이블-파이널라이저>소유자 참조, 레이블, 파이널라이저</h2><p><a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블(Label)>레이블(Label)</a>와 마찬가지로
쿠버네티스에서
<a href=/docs/concepts/overview/working-with-objects/owners-dependents/>소유자 참조(Owner reference)</a>는
오브젝트 간의 관계를 설명하지만 다른 목적으로 사용된다.
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러(Controller)>컨트롤러(Controller)</a>가 파드와 같은 오브젝트를 관리할 때
레이블을 사용하여 관련 오브젝트의 그룹에 대한 변경 사항을 추적한다.
예를 들어 <a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a>이 하나 이상의 파드를 생성하면
잡 컨트롤러는 해당 파드에 레이블을 적용하고
클러스터 내 동일한 레이블을 갖는 파드에 대한 변경 사항을 추적한다.</p><p>또한, 잡 컨트롤러는 이러한 파드에 <em>소유자 참조</em>도 추가하여 파드를 생성한 잡을 가리킨다.
이 파드가 실행될 때 잡을 삭제하면
쿠버네티스는 사용자 참조(레이블 대신)를 사용하여
클러스터 내 어떤 파드가 정리되어야 하는지 결정한다.</p><p>쿠버네티스는 또한 삭제 대상 리소스에 대한 소유자 참조를 식별할 때
파이널라이저를 처리한다.</p><p>경우에 따라 파이널라이저는 종속 오브젝트의 삭제를 차단할 수 있으며
이로 인해 대상 소유자 오브젝트가
완전히 삭제되지 않고 예상보다 오래 유지될 수 있다.
이 경우 대상 소유자 및 종속 객체에 대한
파이널라이저와 소유자 참조를 확인해 원인을 해결해야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 오브젝트가 삭제 상태에 있는 경우, 삭제를 계속하려면 파이널라이저를 수동으로 제거해서는 안 된다.
일반적으로 파이널라이저는 특정한 목적으로 가지고 리소스에 추가되므로,
강제로 제거하면 클러스터에 문제가 발생할 수 있다.
이는 파이널라이저의 목적을 이해하고
다른 방법(예를 들어, 일부 종속 객체를 수동으로 정리하는 것)으로
수행될 때만 수행해야 한다.</div><h2 id=다음-내용>다음 내용</h2><ul><li>쿠버네티스 블로그에서
<a href=/blog/2021/05/14/using-finalizers-to-control-deletion/>파이널라이저를 사용해 삭제 제어하기</a>를 읽어본다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>8 - 필드 셀렉터</h1><p><em>필드 셀렉터</em> 는 한 개 이상의 리소스 필드 값에 따라 <a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/>쿠버네티스 리소스를 선택</a>하기 위해 사용된다. 필드 셀렉터 쿼리의 예시는 다음과 같다.</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>다음의 <code>kubectl</code> 커맨드는 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EB%8B%A8%EA%B3%84-phase><code>status.phase</code></a> 필드의 값이 <code>Running</code> 인 모든 파드를 선택한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 필드 셀렉터는 본질적으로 리소스 <em>필터</em> 이다. 기본적으로 적용되는 셀렉터나 필드는 없으며, 이는 명시된 종류의 모든 리소스가 선택된다는 것을 의미한다. 여기에 따라오는 <code>kubectl</code> 쿼리인 <code>kubectl get pods</code> 와 <code>kubectl get pods --field-selector ""</code> 는 동일하다.</div><h2 id=사용-가능한-필드>사용 가능한 필드</h2><p>사용 가능한 필드는 쿠버네티스의 리소스 종류에 따라서 다르다. 모든 리소스 종류는 <code>metadata.name</code> 과 <code>metadata.namespace</code> 필드 셀렉터를 사용할 수 있다. 사용할 수 없는 필드 셀렉터를 사용하면 다음과 같이 에러를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=사용-가능한-연산자>사용 가능한 연산자</h2><p>필드 셀렉터에서 <code>=</code>, <code>==</code>, <code>!=</code> 연산자를 사용할 수 있다 (<code>=</code>와 <code>==</code>는 동일한 의미이다). 예를 들면, 다음의 <code>kubectl</code> 커맨드는 <code>default</code> 네임스페이스에 속해있지 않은 모든 쿠버네티스 서비스를 선택한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=연계되는-셀렉터>연계되는 셀렉터</h2><p><a href=/ko/docs/concepts/overview/working-with-objects/labels>레이블</a>을 비롯한 다른 셀렉터처럼, 쉼표로 구분되는 목록을 통해 필드 셀렉터를 연계해서 사용할 수 있다. 다음의 <code>kubectl</code> 커맨드는 <code>status.phase</code> 필드가 <code>Running</code> 이 아니고, <code>spec.restartPolicy</code> 필드가 <code>Always</code> 인 모든 파드를 선택한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=여러-개의-리소스-종류>여러 개의 리소스 종류</h2><p>필드 셀렉터를 여러 개의 리소스 종류에 걸쳐 사용할 수 있다. 다음의 <code>kubectl</code> 커맨드는 <code>default</code> 네임스페이스에 속해있지 않은 모든 스테이트풀셋(StatefulSet)과 서비스를 선택한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>9 - 권장 레이블</h1><p>kubectl과 대시보드와 같은 많은 도구들로 쿠버네티스 오브젝트를 시각화 하고 관리할 수 있다.
공통 레이블 셋은 모든 도구들이 이해할 수 있는 공통의 방식으로 오브젝트를 식별하고
도구들이 상호 운용적으로 작동할 수 있도록 한다.</p><p>권장 레이블은 지원 도구 외에도 쿼리하는 방식으로
애플리케이션을 식별하게 한다.</p><p>메타데이터는 <em>애플리케이션</em> 의 개념을 중심으로 정리된다.
쿠버네티스는 플랫폼 서비스(PaaS)가 아니며 애플리케이션에 대해 공식적인 개념이 없거나 강요하지 않는다.
대신 애플리케이션은 비공식적이며 메타데이터로 설명된다.
애플리케이션에 포함된 정의는 유연하다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 메타데이터들은 권장하는 레이블이다. 애플리케이션을 보다 쉽게 관리할 수 있지만
코어 도구에는 필요하지 않다.</div><p>공유 레이블과 주석에는 공통 접두사인 <code>app.kubernetes.io</code> 가 있다.
접두사가 없는 레이블은 사용자가 개인적으로 사용할 수 있다.
공유 접두사는 공유 레이블이 사용자 정의 레이블을 방해하지 않도록 한다.</p><h2 id=레이블>레이블</h2><p>레이블을 최대한 활용하려면 모든 리소스 오브젝트에
적용해야 한다.</p><table><thead><tr><th>키</th><th>설명</th><th>예시</th><th>타입</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>애플리케이션 이름</td><td><code>mysql</code></td><td>문자열</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>애플리케이션의 인스턴스를 식별하는 고유한 이름</td><td><code>mysql-abcxzy</code></td><td>문자열</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>애플리케이션의 현재 버전 (예: a semantic version, revision hash 등.)</td><td><code>5.7.21</code></td><td>문자열</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>아키텍처 내 구성요소</td><td><code>database</code></td><td>문자열</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>이 애플리케이션의 전체 이름</td><td><code>wordpress</code></td><td>문자열</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>애플리케이션의 작동을 관리하는 데 사용되는 도구</td><td><code>helm</code></td><td>문자열</td></tr></tbody></table><p>위 레이블의 실제 예시는 다음 <a class=glossary-tooltip title='내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a> 오브젝트를 고려한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 아래는 전체 명세의 일부분이다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=애플리케이션과-애플리케이션-인스턴스>애플리케이션과 애플리케이션 인스턴스</h2><p>애플리케이션은 동일한 쿠버네티스 클러스터에,
심지어는 동일한 네임스페이스에도 한번 또는 그 이상 설치될 수 있다. 예를 들어, 하나의 쿠버네티스 클러스터에
WordPress가 여러 번 설치되어 각각 서로 다른 웹사이트를 서비스할 수 있다.</p><p>애플리케이션의 이름과 애플리케이션 인스턴스 이름은 별도로 기록된다.
예를 들어 WordPress는 애플리케이션 이름으로 <code>app.kubernetes.io/name</code> 이라는 레이블에 <code>wordpress</code> 라는 값을 가지며,
애플리케이션 인스턴스 이름으로는 <code>app.kubernetes.io/instance</code> 라는 레이블에
<code>wordpress-abcxzy</code> 라는 값을 가진다. 이를 통해 애플리케이션과 애플리케이션 인스턴스를
식별할 수 있다. 모든 애플리케이션 인스턴스는 고유한 이름을 가져야 한다.</p><h2 id=예시>예시</h2><p>위 레이블을 사용하는 다른 방식에 대한 예시는 다양한 복잡성이 있다.</p><h3 id=단순한-스테이트리스-서비스>단순한 스테이트리스 서비스</h3><p><code>Deployment</code> 와 <code>Service</code> 오브젝트를 통해 배포된 단순한 스테이트리스 서비스의 경우를 보자. 다음 두 식별자는 레이블을 가장 간단한 형태로 사용하는 방법을 나타낸다.</p><p><code>Deployment</code> 는 애플리케이션을 실행하는 파드를 감시하는 데 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>Service</code>는 애플리케이션을 노출하기 위해 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=데이터베이스가-있는-웹-애플리케이션>데이터베이스가 있는 웹 애플리케이션</h3><p>Helm을 이용해서 데이터베이스(MySQL)을 이용하는 웹 애플리케이션(WordPress)을
설치한 것과 같이 좀 더 복잡한 애플리케이션을 고려할 수 있다.
다음 식별자는 이 애플리케이션을 배포하는 데 사용하는 오브젝트의 시작을 보여준다.</p><p>WordPress를 배포하는 데 다음과 같이 <code>Deployment</code> 로 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>Service</code> 는 애플리케이션을 노출하기 위해 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL은 <code>StatefulSet</code> 에 MySQL의 소속과 상위 애플리케이션에 대한 메타데이터가 포함되어 노출된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>Service</code> 는 WordPress의 일부로 MySQL을 노출하는 데 이용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL <code>StatefulSet</code> 과 <code>Service</code> 로 MySQL과 WordPress가 더 큰 범위의 애플리케이션에 포함되어 있는 것을 알게 된다.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>