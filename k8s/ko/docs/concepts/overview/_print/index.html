<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/overview/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/overview/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/overview/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/overview/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/overview/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/overview/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/overview/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/overview/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/overview/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/overview/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/overview/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/overview/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/overview/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/overview/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>쿠버네티스란 무엇인가? | Kubernetes</title><meta property="og:title" content="쿠버네티스란 무엇인가?"><meta property="og:description" content="쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식할 수 있고, 확장 가능한 오픈소스 플랫폼으로, 선언적 구성과 자동화를 모두 지원한다. 쿠버네티스는 크고 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 지원 그리고 도구들은 광범위하게 제공된다.
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/overview/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="쿠버네티스란 무엇인가?"><meta itemprop=description content="쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식할 수 있고, 확장 가능한 오픈소스 플랫폼으로, 선언적 구성과 자동화를 모두 지원한다. 쿠버네티스는 크고 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 지원 그리고 도구들은 광범위하게 제공된다.
"><meta name=twitter:card content="summary"><meta name=twitter:title content="쿠버네티스란 무엇인가?"><meta name=twitter:description content="쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식할 수 있고, 확장 가능한 오픈소스 플랫폼으로, 선언적 구성과 자동화를 모두 지원한다. 쿠버네티스는 크고 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 지원 그리고 도구들은 광범위하게 제공된다.
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식할 수 있고, 확장 가능한 오픈소스 플랫폼으로, 선언적 구성과 자동화를 모두 지원한다. 쿠버네티스는 크고 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 지원 그리고 도구들은 광범위하게 제공된다.
"><meta property="og:description" content="쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식할 수 있고, 확장 가능한 오픈소스 플랫폼으로, 선언적 구성과 자동화를 모두 지원한다. 쿠버네티스는 크고 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 지원 그리고 도구들은 광범위하게 제공된다.
"><meta name=twitter:description content="쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식할 수 있고, 확장 가능한 오픈소스 플랫폼으로, 선언적 구성과 자동화를 모두 지원한다. 쿠버네티스는 크고 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 지원 그리고 도구들은 광범위하게 제공된다.
"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/overview/"><meta property="og:title" content="쿠버네티스란 무엇인가?"><meta name=twitter:title content="쿠버네티스란 무엇인가?"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/overview/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/overview/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/overview/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/concepts/overview/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/concepts/overview/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/overview/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/overview/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/concepts/overview/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/overview/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/overview/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/overview/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/overview/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/overview/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/overview/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/overview/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/concepts/overview/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/concepts/overview/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/concepts/overview/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/concepts/overview/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>쿠버네티스란 무엇인가?</h1><div class=lead>쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식할 수 있고, 확장 가능한 오픈소스 플랫폼으로, 선언적 구성과 자동화를 모두 지원한다. 쿠버네티스는 크고 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 지원 그리고 도구들은 광범위하게 제공된다.</div><ul><li>1: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>쿠버네티스 컴포넌트</a></li><li>2: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>쿠버네티스 API</a></li><li>3: <a href=#pg-110f33530cf761140cb1dab536baef04>쿠버네티스 오브젝트로 작업하기</a></li><ul><li>3.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>쿠버네티스 오브젝트 이해하기</a></li><li>3.2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>쿠버네티스 오브젝트 관리</a></li><li>3.3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>오브젝트 이름과 ID</a></li><li>3.4: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>네임스페이스</a></li><li>3.5: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>레이블과 셀렉터</a></li><li>3.6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>어노테이션</a></li><li>3.7: <a href=#pg-13ce5627ef1dc8cbb4530ed231cb7d38>파이널라이저</a></li><li>3.8: <a href=#pg-046c03090d47bc4b89b818dc645c3865>필드 셀렉터</a></li><li>3.9: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>권장 레이블</a></li></ul></ul><div class=content><p>이 페이지에서는 쿠버네티스 개요를 설명한다.</p><p>쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼이다. 쿠버네티스는 선언적 구성과 자동화를 모두 용이하게 해준다. 쿠버네티스는 크고, 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.</p><p>쿠버네티스란 명칭은 키잡이(helmsman)나 파일럿을 뜻하는 그리스어에서 유래했다. K8s라는 표기는 "K"와 "s"와 그 사이에 있는 8글자를 나타내는 약식 표기이다. 구글이 2014년에 쿠버네티스 프로젝트를 오픈소스화했다. 쿠버네티스는 프로덕션 워크로드를 대규모로 운영하는 <a href=/blog/2015/04/borg-predecessor-to-kubernetes/>15년 이상의 구글 경험</a>과 커뮤니티의 최고의 아이디어와 적용 사례가 결합되어 있다.</p><h2 id=여정-돌아보기>여정 돌아보기</h2><p>시간이 지나면서 쿠버네티스가 왜 유용하게 되었는지 살펴보자.</p><p><img src=/images/docs/Container_Evolution.svg alt="배포 혁명"></p><p><strong>전통적인 배포 시대:</strong>
초기 조직은 애플리케이션을 물리 서버에서 실행했었다. 한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기에, 리소스 할당의 문제가 발생했다. 예를 들어 물리 서버 하나에서 여러 애플리케이션을 실행하면, 리소스 전부를 차지하는 애플리케이션 인스턴스가 있을 수 있고, 결과적으로는 다른 애플리케이션의 성능이 저하될 수 있었다. 이에 대한 해결책은 서로 다른 여러 물리 서버에서 각 애플리케이션을 실행하는 것이 있다. 그러나 이는 리소스가 충분히 활용되지 않는다는 점에서 확장 가능하지 않았으므로, 물리 서버를 많이 유지하기 위해서 조직에게 많은 비용이 들었다.</p><p><strong>가상화된 배포 시대:</strong> 그 해결책으로 가상화가 도입되었다. 이는 단일 물리 서버의 CPU에서 여러 가상 시스템 (VM)을 실행할 수 있게 한다. 가상화를 사용하면 VM간에 애플리케이션을 격리하고 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스 할 수 없으므로, 일정 수준의 보안성을 제공할 수 있다.</p><p>가상화를 사용하면 물리 서버에서 리소스를 보다 효율적으로 활용할 수 있으며, 쉽게 애플리케이션을 추가하거나 업데이트할 수 있고 하드웨어 비용을 절감할 수 있어 더 나은 확장성을 제공한다. 가상화를 통해 일련의 물리 리소스를 폐기 가능한(disposable) 가상 머신으로 구성된 클러스터로 만들 수 있다.</p><p>각 VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성 요소를 실행하는 하나의 완전한 머신이다.</p><p><strong>컨테이너 개발 시대:</strong> 컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제(OS)를 공유한다. 그러므로 컨테이너는 가볍다고 여겨진다. VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU 점유율, 메모리, 프로세스 공간 등이 있다. 기본 인프라와의 종속성을 끊었기 때문에, 클라우드나 OS 배포본에 모두 이식할 수 있다.</p><p>컨테이너는 다음과 같은 추가적인 혜택을 제공하기 때문에 인기가 있다.</p><ul><li>기민한 애플리케이션 생성과 배포: VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적임.</li><li>지속적인 개발, 통합 및 배포: 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 (이미지의 불변성 덕에) 빠르고 효율적으로 롤백할 수 있다.</li><li>개발과 운영의 관심사 분리: 배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭처에서 분리된다.</li><li>가시성(observability): OS 수준의 정보와 메트릭에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있다.</li><li>개발, 테스팅 및 운영 환경에 걸친 일관성: 랩탑에서도 클라우드에서와 동일하게 구동된다.</li><li>클라우드 및 OS 배포판 간 이식성: Ubuntu, RHEL, CoreOS, 온-프레미스, 주요 퍼블릭 클라우드와 어디에서든 구동된다.</li><li>애플리케이션 중심 관리: 가상 하드웨어 상에서 OS를 실행하는 수준에서 논리적인 리소스를 사용하는 OS 상에서 애플리케이션을 실행하는 수준으로 추상화 수준이 높아진다.</li><li>느슨하게 커플되고, 분산되고, 유연하며, 자유로운 마이크로서비스: 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있다.</li><li>리소스 격리: 애플리케이션 성능을 예측할 수 있다.</li><li>리소스 사용량: 고효율 고집적.</li></ul><h2 id=why-you-need-kubernetes-and-what-can-it-do>쿠버네티스가 왜 필요하고 무엇을 할 수 있나</h2><p>컨테이너는 애플리케이션을 포장하고 실행하는 좋은 방법이다. 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 한다. 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 한다. 이 문제를 시스템에 의해 처리한다면 더 쉽지 않을까?</p><p>그것이 쿠버네티스가 필요한 이유이다! 쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다. 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공한다. 예를 들어, 쿠버네티스는 시스템의 카나리아 배포를 쉽게 관리 할 수 있다.</p><p>쿠버네티스는 다음을 제공한다.</p><ul><li><strong>서비스 디스커버리와 로드 밸런싱</strong>
쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.</li><li><strong>스토리지 오케스트레이션</strong>
쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.</li><li><strong>자동화된 롤아웃과 롤백</strong>
쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.</li><li><strong>자동화된 빈 패킹(bin packing)</strong>
컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.</li><li><strong>자동화된 복구(self-healing)</strong>
쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.</li><li><strong>시크릿과 구성 관리</strong>
쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다.</li></ul><h2 id=쿠버네티스가-아닌-것>쿠버네티스가 아닌 것</h2><p>쿠버네티스는 전통적인, 모든 것이 포함된 Platform as a Service(PaaS)가 아니다. 쿠버네티스는 하드웨어 수준보다는 컨테이너 수준에서 운영되기 때문에, PaaS가 일반적으로 제공하는 배포, 스케일링, 로드 밸런싱과 같은 기능을 제공하며, 사용자가 로깅, 모니터링 및 알림 솔루션을 통합할 수 있다. 하지만, 쿠버네티스는 모놀리식(monolithic)이 아니어서, 이런 기본 솔루션이 선택적이며 추가나 제거가 용이하다. 쿠버네티스는 개발자 플랫폼을 만드는 구성 요소를 제공하지만, 필요한 경우 사용자의 선택권과 유연성을 지켜준다.</p><p>쿠버네티스는:</p><ul><li>지원하는 애플리케이션의 유형을 제약하지 않는다. 쿠버네티스는 상태 유지가 필요 없는(stateless) 워크로드, 상태 유지가 필요한(stateful) 워크로드, 데이터 처리를 위한 워크로드를 포함해서 극단적으로 다양한 워크로드를 지원하는 것을 목표로 한다. 애플리케이션이 컨테이너에서 구동될 수 있다면, 쿠버네티스에서도 잘 동작할 것이다.</li><li>소스 코드를 배포하지 않으며 애플리케이션을 빌드하지 않는다. 지속적인 통합과 전달과 배포, 곧 CI/CD 워크플로우는 조직 문화와 취향에 따를 뿐만 아니라 기술적인 요구사항으로 결정된다.</li><li>애플리케이션 레벨의 서비스를 제공하지 않는다. 애플리케이션 레벨의 서비스에는 미들웨어(예, 메시지 버스), 데이터 처리 프레임워크(예, Spark), 데이터베이스(예, MySQL), 캐시 또는 클러스터 스토리지 시스템(예, Ceph) 등이 있다. 이런 컴포넌트는 쿠버네티스 상에서 구동될 수 있고, 쿠버네티스 상에서 구동 중인 애플리케이션이 <a href=https://openservicebrokerapi.org/>Open Service Broker</a> 와 같은 이식 가능한 메커니즘을 통해 접근할 수도 있다.</li><li>로깅, 모니터링 또는 경보 솔루션을 포함하지 않는다. 개념 증명을 위한 일부 통합이나, 메트릭을 수집하고 노출하는 메커니즘을 제공한다.</li><li>기본 설정 언어/시스템(예, Jsonnet)을 제공하거나 요구하지 않는다. 선언적 명세의 임의적인 형식을 목적으로 하는 선언적 API를 제공한다.</li><li>포괄적인 머신 설정, 유지보수, 관리, 자동 복구 시스템을 제공하거나 채택하지 않는다.</li><li>추가로, 쿠버네티스는 단순한 오케스트레이션 시스템이 아니다. 사실, 쿠버네티스는 오케스트레이션의 필요성을 없애준다. 오케스트레이션의 기술적인 정의는 A를 먼저 한 다음, B를 하고, C를 하는 것과 같이 정의된 워크플로우를 수행하는 것이다. 반면에, 쿠버네티스는 독립적이고 조합 가능한 제어 프로세스들로 구성되어 있다. 이 프로세스는 지속적으로 현재 상태를 입력받은 의도한 상태로 나아가도록 한다. A에서 C로 어떻게 갔는지는 상관이 없다. 중앙화된 제어도 필요치 않다. 이로써 시스템이 보다 더 사용하기 쉬워지고, 강력해지며, 견고하고, 회복력을 갖추게 되며, 확장 가능해진다.</li></ul><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/overview/components/>쿠버네티스 구성요소</a> 살펴보기</li><li><a href=/ko/docs/concepts/overview/kubernetes-api/>쿠버네티스 API</a> 살펴보기</li><li><a href=/ko/docs/concepts/architecture/>클러스터 아키텍처</a> 살펴보기</li><li><a href=/ko/docs/setup/>시작하기</a> 준비가 되었는가?</li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>1 - 쿠버네티스 컴포넌트</h1><div class=lead>쿠버네티스 클러스터는 컴퓨터 집합인 노드 컴포넌트와 컨트롤 플레인 컴포넌트로 구성된다.</div><p>쿠버네티스를 배포하면 클러스터를 얻는다.<p><p>쿠버네티스 클러스터는 컨테이너화된 애플리케이션을 실행하는 <a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>라고
하는 워커 머신의 집합. 모든 클러스터는 최소 한 개의 워커 노드를 가진다.</p></p><p>워커 노드는 애플리케이션의 구성요소인
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 호스트한다.
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>은 워커 노드와
클러스터 내 파드를 관리한다. 프로덕션 환경에서는 일반적으로 컨트롤 플레인이
여러 컴퓨터에 걸쳐 실행되고, 클러스터는 일반적으로 여러 노드를
실행하므로 내결함성과 고가용성이 제공된다.</p></p><p>이 문서는 완전히 작동하는 쿠버네티스 클러스터를 갖기 위해 필요한
다양한 컴포넌트들에 대해 요약하고 정리한다.</p><figure class=diagram-large><img src=/images/docs/components-of-kubernetes.svg alt="쿠버네티스 구성 요소"><figcaption><p>쿠버네티스 클러스터 구성 요소</p></figcaption></figure><h2 id=컨트롤-플레인-컴포넌트>컨트롤 플레인 컴포넌트</h2><p>컨트롤 플레인 컴포넌트는 클러스터에 관한 전반적인 결정(예를 들어, 스케줄링)을 수행하고 클러스터 이벤트(예를 들어, 디플로이먼트의 <code>replicas</code> 필드에 대한 요구 조건이 충족되지 않을 경우 새로운 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 구동시키는 것)를 감지하고 반응한다.</p><p>컨트롤 플레인 컴포넌트는 클러스터 내 어떠한 머신에서든지 동작할 수 있다. 그러나
간결성을 위하여, 구성 스크립트는 보통 동일 머신 상에 모든 컨트롤 플레인 컴포넌트를 구동시키고,
사용자 컨테이너는 해당 머신 상에 동작시키지 않는다. 여러 머신에서
실행되는 컨트롤 플레인 설정의 예제를 보려면
<a href=/docs/setup/production-environment/tools/kubeadm/high-availability/>kubeadm을 사용하여 고가용성 클러스터 만들기</a>를 확인해본다.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>API 서버는 쿠버네티스 API를
노출하는 쿠버네티스 <a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a> 컴포넌트이다.
API 서버는 쿠버네티스 컨트롤 플레인의 프론트 엔드이다.</p><p>쿠버네티스 API 서버의 주요 구현은 <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a> 이다.
kube-apiserver는 수평으로 확장되도록 디자인되었다. 즉, 더 많은 인스턴스를 배포해서 확장할 수 있다.
여러 kube-apiserver 인스턴스를 실행하고, 인스턴스간의 트래픽을 균형있게 조절할 수 있다.</p><h3 id=etcd>etcd</h3><p>모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소.</p><p>쿠버네티스 클러스터에서 etcd를 뒷단의 저장소로 사용한다면,
이 데이터를 <a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>백업</a>하는 계획은
필수이다.</p><p>etcd에 대한 자세한 정보는, 공식 <a href=https://etcd.io/docs>문서</a>를 참고한다.</p><h3 id=kube-scheduler>kube-scheduler</h3><p><a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>가 배정되지 않은 새로 생성된
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 를 감지하고,
실행할 노드를 선택하는 컨트롤
플레인 컴포넌트.</p><p>스케줄링 결정을 위해서 고려되는 요소는 리소스에 대한
개별 및 총체적 요구 사항, 하드웨어/소프트웨어/정책적 제약,
어피니티(affinity) 및 안티-어피니티(anti-affinity) 명세,
데이터 지역성, 워크로드-간 간섭, 데드라인을 포함한다.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p><a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 프로세스를 실행하는 컨트롤 플레인 컴포넌트.</p><p>논리적으로, 각 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는 분리된 프로세스이지만, 복잡성을 낮추기 위해 모두 단일 바이너리로 컴파일되고 단일 프로세스 내에서 실행된다.</p><p>이들 컨트롤러는 다음을 포함한다.</p><ul><li>노드 컨트롤러: 노드가 다운되었을 때 통지와 대응에 관한 책임을 가진다.</li><li>잡 컨트롤러: 일회성 작업을 나타내는 잡 오브젝트를 감시한 다음, 해당 작업을
완료할 때까지 동작하는 파드를 생성한다.</li><li>엔드포인트 컨트롤러: 엔드포인트 오브젝트를 채운다(즉, 서비스와 파드를 연결시킨다.)</li><li>서비스 어카운트 & 토큰 컨트롤러: 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성한다.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3>클라우드별 컨트롤 로직을 포함하는 쿠버네티스
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a> 컴포넌트이다.
클라우드 컨트롤러 매니저를 통해 클러스터를 클라우드 공급자의 API에 연결하고,
해당 클라우드 플랫폼과 상호 작용하는 컴포넌트와 클러스터와만 상호 작용하는 컴포넌트를 구분할 수 있게 해 준다.<p>cloud-controller-manager는 클라우드 제공자 전용 컨트롤러만 실행한다.
자신의 사내 또는 PC 내부의 학습 환경에서 쿠버네티스를 실행 중인 경우
클러스터에는 클라우드 컨트롤러 매니저가 없다.</p><p>kube-controller-manager와 마찬가지로 cloud-controller-manager는 논리적으로
독립적인 여러 컨트롤 루프를 단일 프로세스로 실행하는 단일 바이너리로 결합한다.
수평으로 확장(두 개 이상의 복제 실행)해서 성능을 향상시키거나 장애를 견딜 수 있다.</p><p>다음 컨트롤러들은 클라우드 제공 사업자의 의존성을 가질 수 있다.</p><ul><li>노드 컨트롤러: 노드가 응답을 멈춘 후 클라우드 상에서 삭제되었는지 판별하기 위해 클라우드 제공 사업자에게 확인하는 것</li><li>라우트 컨트롤러: 기본 클라우드 인프라에 경로를 구성하는 것</li><li>서비스 컨트롤러: 클라우드 제공 사업자 로드밸런서를 생성, 업데이트 그리고 삭제하는 것</li></ul><h2 id=노드-컴포넌트>노드 컴포넌트</h2><p>노드 컴포넌트는 동작 중인 파드를 유지시키고 쿠버네티스 런타임 환경을 제공하며, 모든 노드 상에서 동작한다.</p><h3 id=kubelet>kubelet</h3><p>클러스터의 각 <a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에서 실행되는 에이전트. Kubelet은 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>에서 <a class=glossary-tooltip title='소프트웨어와 그것에 종속된 모든 것을 포함한 가볍고 휴대성이 높은 실행 가능 이미지.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/containers/ target=_blank aria-label=컨테이너>컨테이너</a>가 확실하게 동작하도록 관리한다.</p><p>Kubelet은 다양한 메커니즘을 통해 제공된 파드 스펙(PodSpec)의 집합을 받아서 컨테이너가 해당 파드 스펙에 따라 건강하게 동작하는 것을 확실히 한다. Kubelet은 쿠버네티스를 통해 생성되지 않는 컨테이너는 관리하지 않는다.</p><h3 id=kube-proxy>kube-proxy</h3><p>kube-proxy는 클러스터의 각
<a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에서
실행되는 네트워크 프록시로, 쿠버네티스의
<a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a> 개념의 구현부이다.</p><p><a href=/ko/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>는
노드의 네트워크 규칙을 유지 관리한다. 이 네트워크 규칙이 내부 네트워크
세션이나 클러스터 바깥에서 파드로 네트워크 통신을
할 수 있도록 해준다.</p><p>kube-proxy는 운영 체제에 가용한 패킷
필터링 계층이 있는 경우, 이를 사용한다. 그렇지 않으면, kube-proxy는 트래픽 자체를 포워드(forward)한다.</p><h3 id=컨테이너-런타임>컨테이너 런타임</h3><p>컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.</p><p>쿠버네티스는 <a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>,
<a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>와 같은 컨테이너 런타임 및
모든 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (컨테이너 런타임 인터페이스)</a>
구현체를 지원한다.</p><h2 id=애드온>애드온</h2><p>애드온은 쿠버네티스 리소스(<a class=glossary-tooltip title='파드의 복제본을 클러스터 노드 집합에서 동작하게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋>데몬셋</a>,
<a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a> 등)를
이용하여 클러스터 기능을 구현한다. 이들은 클러스터 단위의 기능을 제공하기 때문에
애드온에 대한 네임스페이스 리소스는 <code>kube-system</code> 네임스페이스에 속한다.</p><p>선택된 일부 애드온은 아래에 설명하였고, 사용 가능한 전체 확장 애드온 리스트는
<a href=/ko/docs/concepts/cluster-administration/addons/>애드온</a>을 참조한다.</p><h3 id=dns>DNS</h3><p>여타 애드온들이 절대적으로 요구되지 않지만, 많은 예시에서 필요로 하기 때문에 모든 쿠버네티스 클러스터는 <a href=/ko/docs/concepts/services-networking/dns-pod-service/>클러스터 DNS</a>를 갖추어야만 한다.</p><p>클러스터 DNS는 구성환경 내 다른 DNS 서버와 더불어, 쿠버네티스 서비스를 위해 DNS 레코드를 제공해주는 DNS 서버다.</p><p>쿠버네티스에 의해 구동되는 컨테이너는 DNS 검색에서 이 DNS 서버를 자동으로 포함한다.</p><h3 id=웹-ui-대시보드>웹 UI (대시보드)</h3><p><a href=/ko/docs/tasks/access-application-cluster/web-ui-dashboard/>대시보드</a>는 쿠버네티스 클러스터를 위한 범용의 웹 기반 UI다. 사용자가 클러스터 자체뿐만 아니라, 클러스터에서 동작하는 애플리케이션에 대한 관리와 문제 해결을 할 수 있도록 해준다.</p><h3 id=컨테이너-리소스-모니터링>컨테이너 리소스 모니터링</h3><p><a href=/ko/docs/tasks/debug/debug-cluster/resource-usage-monitoring/>컨테이너 리소스 모니터링</a>은
중앙 데이터베이스 내의 컨테이너들에 대한 포괄적인 시계열 매트릭스를 기록하고 그 데이터를 열람하기 위한 UI를 제공해 준다.</p><h3 id=클러스터-레벨-로깅>클러스터-레벨 로깅</h3><p><a href=/ko/docs/concepts/cluster-administration/logging/>클러스터-레벨 로깅</a> 메커니즘은
검색/열람 인터페이스와 함께 중앙 로그 저장소에 컨테이너 로그를 저장하는 책임을 진다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/architecture/nodes/>노드</a>에 대해 더 배우기</li><li><a href=/ko/docs/concepts/architecture/controller/>컨트롤러</a>에 대해 더 배우기</li><li><a href=/ko/docs/concepts/scheduling-eviction/kube-scheduler/>kube-scheduler</a>에 대해 더 배우기</li><li>etcd의 공식 <a href=https://etcd.io/docs/>문서</a> 읽기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>2 - 쿠버네티스 API</h1><div class=lead>쿠버네티스 API를 사용하면 쿠버네티스 오브젝트들의 상태를 쿼리하고 조작할 수 있다. 쿠버네티스 컨트롤 플레인의 핵심은 API 서버와 그것이 노출하는 HTTP API이다. 사용자와 클러스터의 다른 부분 및 모든 외부 컴포넌트는 API 서버를 통해 서로 통신한다.</div><p>쿠버네티스 <a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>의 핵심은
<a class=glossary-tooltip title='쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 서버'>API 서버</a>이다. API 서버는
최종 사용자, 클러스터의 다른 부분 그리고 외부 컴포넌트가 서로 통신할
수 있도록 HTTP API를 제공한다.</p><p>쿠버네티스 API를 사용하면 쿠버네티스의 API 오브젝트(예:
파드(Pod), 네임스페이스(Namespace), 컨피그맵(ConfigMap) 그리고 이벤트(Event))를 질의(query)하고 조작할 수 있다.</p><p>대부분의 작업은 <a href=/ko/docs/reference/kubectl/>kubectl</a>
커맨드 라인 인터페이스 또는 API를 사용하는
<a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a>과
같은 다른 커맨드 라인 도구를 통해 수행할 수 있다.
그러나, REST 호출을 사용하여 API에 직접 접근할 수도 있다.</p><p>쿠버네티스 API를 사용하여 애플리케이션을 작성하는 경우
<a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리</a> 중 하나를 사용하는 것이 좋다.</p><h2 id=api-specification>OpenAPI 명세</h2><p>완전한 API 상세 내용은 <a href=https://www.openapis.org/>OpenAPI</a>를 활용해서 문서화했다.</p><h3 id=openapi-v2>OpenAPI V2</h3><p>쿠버네티스 API 서버는 <code>/openapi/v2</code> 엔드포인트를 통해
통합된(aggregated) OpenAPI v2 스펙을 제공한다.
요청 헤더에 다음과 같이 기재하여 응답 형식을 지정할 수 있다.</p><table><caption style=display:none>OpenAPI v2 질의에 사용할 수 있는 유효한 요청 헤더 값</caption><thead><tr><th>헤더</th><th style=min-width:50%>사용할 수 있는 값</th><th>참고</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>이 헤더를 제공하지 않는 것도 가능</em></td></tr><tr><td rowspan=3><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code></td><td><em>주로 클러스터 내부 용도로 사용</em></td></tr><tr><td><code>application/json</code></td><td><em>기본값</em></td></tr><tr><td><code>*</code></td><td><code>JSON으로 응답</em></td></tr></tbody></table><p>쿠버네티스는 주로 클러스터 내부 통신을 위해 대안적인
Protobuf에 기반한 직렬화 형식을 구현한다. 이 형식에 대한
자세한 내용은 <a href=https://git.k8s.io/design-proposals-archive/api-machinery/protobuf.md>쿠버네티스 Protobuf 직렬화</a> 디자인 제안과
API 오브젝트를 정의하는 Go 패키지에 들어있는 각각의 스키마에 대한
IDL(인터페이스 정의 언어) 파일을 참고한다.</p><h3 id=openapi-v3>OpenAPI V3</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [beta]</code></div><p>쿠버네티스 v1.25 버전은 OpenAPI v3 API 발행(publishing)에 대한 베타 지원을 제공한다.
이는 베타 기능이며 기본적으로 활성화되어 있다.
kube-apiserver 구성 요소에
<code>OpenAPIV3</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 비활성화하여
이 베타 기능을 비활성화할 수 있다.</p><p><code>/openapi/v3</code> 디스커버리 엔드포인트는 사용 가능한 모든
그룹/버전의 목록을 제공한다. 이 엔드포인트는 JSON 만을 반환한다.
이러한 그룹/버전은 다음과 같은 형식으로 제공된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;paths&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;api/v1&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;serverRelativeURL&#34;: </span><span style=color:#b44>&#34;/openapi/v3/api/v1?hash=CC0E9BFD992D8C59AEC98A1E2336F899E8318D3CF4C68944C3DEC640AF5AB52D864AC50DAA8D145B3494F75FA3CFF939FCBDDA431DAD3CA79738B297795818CF&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;apis/admissionregistration.k8s.io/v1&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;serverRelativeURL&#34;: </span><span style=color:#b44>&#34;/openapi/v3/apis/admissionregistration.k8s.io/v1?hash=E19CC93A116982CE5422FC42B590A8AFAD92CDE9AE4D59B5CAAD568F083AD07946E6CB5817531680BCE6E215C16973CD39003B0425F3477CFD854E89A9DB6597&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>....<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>위의 상대 URL은 변경 불가능한(immutable) OpenAPI 상세를 가리키고 있으며,
이는 클라이언트에서의 캐싱을 향상시키기 위함이다.
같은 목적을 위해 API 서버는 적절한 HTTP 캐싱 헤더를
설정한다(<code>Expires</code>를 1년 뒤로, <code>Cache-Control</code>을 <code>immutable</code>).
사용 중단된 URL이 사용되면, API 서버는 최신 URL로의 리다이렉트를 반환한다.</p><p>쿠버네티스 API 서버는
쿠버네티스 그룹 버전에 따른 OpenAPI v3 스펙을
<code>/openapi/v3/apis/&lt;group>/&lt;version>?hash=&lt;hash></code> 엔드포인트에 게시한다.</p><p>사용 가능한 요청 헤더 목록은 아래의 표를 참고한다.</p><table><caption style=display:none>OpenAPI v3 질의에 사용할 수 있는 유효한 요청 헤더 값</caption><thead><tr><th>헤더</th><th style=min-width:50%>사용할 수 있는 값</th><th>참고</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>이 헤더를 제공하지 않는 것도 가능</em></td></tr><tr><td rowspan=3><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v3@v1.0+protobuf</code></td><td><em>주로 클러스터 내부 용도로 사용</em></td></tr><tr><td><code>application/json</code></td><td><em>기본값</em></td></tr><tr><td><code>*</code></td><td><code>JSON으로 응답</em></td></tr></tbody></table><h2 id=지속성>지속성</h2><p>쿠버네티스는 오브젝트의 직렬화된 상태를
<a class=glossary-tooltip title='모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>에 기록하여 저장한다.</p><h2 id=api-그룹과-버전-규칙>API 그룹과 버전 규칙</h2><p>필드를 쉽게 제거하거나 리소스 표현을 재구성하기 위해,
쿠버네티스는 각각 <code>/api/v1</code> 또는 <code>/apis/rbac.authorization.k8s.io/v1alpha1</code> 과
같은 서로 다른 API 경로에서 여러 API 버전을 지원한다.</p><p>버전 규칙은 리소스나 필드 수준이 아닌 API 수준에서 수행되어
API가 시스템 리소스 및 동작에 대한 명확하고 일관된 보기를 제공하고
수명 종료 및/또는 실험적 API에 대한 접근을
제어할 수 있도록 한다.</p><p>보다 쉽게 발전하고 API를 확장하기 위해, 쿠버네티스는
<a href=/ko/docs/reference/using-api/#api-%EA%B7%B8%EB%A3%B9-%ED%99%9C%EC%84%B1%ED%99%94-%EB%98%90%EB%8A%94-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94>활성화 또는 비활성화</a>가
가능한 <a href=/ko/docs/reference/using-api/#api-%EA%B7%B8%EB%A3%B9>API 그룹</a>을 구현한다.</p><p>API 리소스는 API 그룹, 리소스 유형, 네임스페이스
(네임스페이스 리소스용) 및 이름으로 구분된다. API 서버는 API 버전 간의
변환을 투명하게 처리한다. 서로 다른 모든 버전은 실제로
동일한 지속 데이터의 표현이다. API 서버는 여러 API 버전을 통해
동일한 기본 데이터를 제공할 수 있다.</p><p>예를 들어, 동일한 리소스에 대해 <code>v1</code> 과 <code>v1beta1</code> 이라는 두 가지 API 버전이
있다고 가정한다. 원래 API의 <code>v1beta1</code> 버전을 사용하여 오브젝트를
만든 경우, 나중에 <code>v1beta1</code> 또는 <code>v1</code> API 버전을 사용하여 해당 오브젝트를
읽거나, 업데이트하거나, 삭제할 수 있다.</p><h2 id=api-변경-사항>API 변경 사항</h2><p>성공적인 시스템은 새로운 유스케이스가 등장하거나 기존 사례가 변경됨에 따라 성장하고 변화해야 한다.
따라서, 쿠버네티스는 쿠버네티스 API가 지속적으로 변경되고 성장할 수 있도록 설계했다.
쿠버네티스 프로젝트는 기존 클라이언트와의 호환성을 깨지 <em>않고</em> 다른 프로젝트가
적응할 기회를 가질 수 있도록 장기간 해당 호환성을 유지하는 것을 목표로 한다.</p><p>일반적으로, 새 API 리소스와 새 리소스 필드는 자주 추가될 수 있다.
리소스 또는 필드를 제거하려면
<a href=/docs/reference/using-api/deprecation-policy/>API 지원 중단 정책</a>을 따라야 한다.</p><p>쿠버네티스는 일반적으로 API 버전 <code>v1</code> 에서 안정 버전(GA)에 도달하면, 공식 쿠버네티스 API에
대한 호환성 유지를 강력하게 이행한다. 또한,
쿠버네티스는 가능한 경우 <em>베타</em> API 버전에서도 호환성을 유지한다.
베타 API를 채택하면 기능이 안정된 후에도 해당 API를 사용하여 클러스터와
계속 상호 작용할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 쿠버네티스는 또한 <em>알파</em> API 버전에 대한 호환성을 유지하는 것을 목표로 하지만, 일부
상황에서는 호환성이 깨진다. 알파 API 버전을 사용하는 경우, API가 변경된 경우 클러스터를
업그레이드할 때 쿠버네티스에 대한 릴리스 정보를 확인한다.</div><p>API 버전 수준 정의에 대한 자세한 내용은
<a href=/ko/docs/reference/using-api/#api-%EB%B2%84%EC%A0%84-%EA%B7%9C%EC%B9%99>API 버전 레퍼런스</a>를 참조한다.</p><h2 id=api-확장>API 확장</h2><p>쿠버네티스 API는 다음 두 가지 방법 중 하나로 확장할 수 있다.</p><ol><li><a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>커스텀 리소스</a>를
사용하면 API 서버가 선택한 리소스 API를 제공하는 방법을 선언적으로 정의할 수 있다.</li><li><a href=/ko/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>애그리게이션 레이어(aggregation layer)</a>를
구현하여 쿠버네티스 API를 확장할 수도 있다.</li></ol><h2 id=다음-내용>다음 내용</h2><ul><li>자체 <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>을
추가하여 쿠버네티스 API를 확장하는 방법에 대해 배우기.</li><li><a href=/ko/docs/concepts/security/controlling-access/>쿠버네티스 API 접근 제어하기</a>는
클러스터가 API 접근을 위한 인증 및 권한을 관리하는 방법을 설명한다.</li><li><a href=/docs/reference/kubernetes-api/>API 레퍼런스</a>를
읽고 API 엔드포인트, 리소스 유형 및 샘플에 대해 배우기.</li><li><a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#readme>API 변경 사항</a>에서
호환 가능한 변경 사항을 구성하고, API를 변경하는 방법에 대해 알아본다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>3 - 쿠버네티스 오브젝트로 작업하기</h1><div class=lead>쿠버네티스 오브젝트는 쿠버네티스 시스템의 영구 엔티티이다. 쿠버네티스는 이러한 엔티티들을 사용하여 클러스터의 상태를 나타낸다. 쿠버네티스 오브젝트 모델과 쿠버네티스 오브젝트를 사용하는 방법에 대해 학습한다.</div></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>3.1 - 쿠버네티스 오브젝트 이해하기</h1><p>이 페이지에서는 쿠버네티스 오브젝트가 쿠버네티스 API에서 어떻게 표현되고, 그 오브젝트를
어떻게 <code>.yaml</code> 형식으로 표현할 수 있는지에 대해 설명한다.</p><h2 id=kubernetes-objects>쿠버네티스 오브젝트 이해하기</h2><p><em>쿠버네티스 오브젝트</em> 는 쿠버네티스 시스템에서 영속성을 가지는 오브젝트이다. 쿠버네티스는 클러스터의 상태를
나타내기 위해 이 오브젝트를 이용한다. 구체적으로 말하자면, 다음같이 기술할 수 있다.</p><ul><li>어떤 컨테이너화된 애플리케이션이 동작 중인지 (그리고 어느 노드에서 동작 중인지)</li><li>그 애플리케이션이 이용할 수 있는 리소스</li><li>그 애플리케이션이 어떻게 재구동 정책, 업그레이드, 그리고 내고장성과 같은 것에 동작해야 하는지에 대한 정책</li></ul><p>쿠버네티스 오브젝트는 하나의 "의도를 담은 레코드"이다. 오브젝트를 생성하게 되면, 쿠버네티스 시스템은
그 오브젝트 생성을 보장하기 위해 지속적으로 작동할 것이다. 오브젝트를 생성함으로써, 여러분이 클러스터의
워크로드를 어떤 형태로 보이고자 하는지에 대해 효과적으로 쿠버네티스 시스템에 전한다. 이것이 바로 여러분의
클러스터에 대해 <em>의도한 상태</em> 가 된다.</p><p>생성이든, 수정이든, 또는 삭제든 쿠버네티스 오브젝트를 동작시키려면,
<a href=/ko/docs/concepts/overview/kubernetes-api/>쿠버네티스 API</a>를 이용해야 한다. 예를 들어,
<code>kubectl</code> 커맨드-라인 인터페이스를 이용할 때, CLI는 여러분 대신 필요한 쿠버네티스 API를 호출해 준다.
또한, 여러분은 <a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리</a> 중 하나를
이용하여 여러분만의 프로그램에서 쿠버네티스 API를 직접 이용할 수도 있다.</p><h3 id=오브젝트-명세-spec-와-상태-status>오브젝트 명세(spec)와 상태(status)</h3><p>거의 모든 쿠버네티스 오브젝트는 오브젝트의 구성을 결정해주는
두 개의 중첩된 오브젝트 필드를 포함하는데 오브젝트 <em><code>spec</code></em> 과 오브젝트 <em><code>status</code></em> 이다.
<code>spec</code>을 가진 오브젝트는 오브젝트를 생성할 때 리소스에
원하는 특징(<em>의도한 상태</em>)에 대한 설명을
제공해서 설정한다.</p><p><code>status</code> 는 쿠버네티스 시스템과 컴포넌트에 의해 제공되고
업데이트된 오브젝트의 <em>현재 상태</em> 를 설명한다. 쿠버네티스
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>은 모든 오브젝트의
실제 상태를 사용자가 의도한 상태와 일치시키기 위해 끊임없이 그리고
능동적으로 관리한다.</p><p>예를 들어, 쿠버네티스 디플로이먼트는 클러스터에서 동작하는 애플리케이션을
표현해줄 수 있는 오브젝트이다. 디플로이먼트를 생성할 때, 디플로이먼트
spec에 3개의 애플리케이션 레플리카가 동작되도록
설정할 수 있다. 쿠버네티스 시스템은 그 디플로이먼트 spec을 읽어
spec에 일치되도록 상태를 업데이트하여 3개의 의도한
애플리케이션 인스턴스를 구동시킨다. 만약, 그 인스턴스들 중 어느 하나가
어떤 문제로 인해 멈춘다면(상태 변화 발생), 쿠버네티스 시스템은 보정(이
경우에는 대체 인스턴스를 시작하여)을 통해
spec과 status간의 차이에 대응한다.</p><p>오브젝트 명세, 상태, 그리고 메타데이터에 대한 추가 정보는,
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Kubernetes API Conventions</a> 를 참조한다.</p><h3 id=쿠버네티스-오브젝트-기술하기>쿠버네티스 오브젝트 기술하기</h3><p>쿠버네티스에서 오브젝트를 생성할 때, (이름과 같은)오브젝트에 대한 기본적인 정보와 더불어,
의도한 상태를 기술한 오브젝트 spec을 제시해 줘야만 한다. 오브젝트를 생성하기 위해
(직접이든 또는 <code>kubectl</code>을 통해서든) 쿠버네티스 API를 이용할 때, API 요청은 요청 내용 안에
JSON 형식으로 정보를 포함시켜 줘야만 한다. <strong>대부분의 경우 정보를 .yaml 파일로 <code>kubectl</code>에
제공한다.</strong> <code>kubectl</code>은 API 요청이 이루어질 때, JSON 형식으로 정보를
변환시켜 준다.</p><p>여기 쿠버네티스 디플로이먼트를 위한 필수 필드와 오브젝트 spec을 보여주는 <code>.yaml</code> 파일 예시가 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>위 예시와 같이 .yaml 파일을 이용하여 디플로이먼트를 생성하기 위한 하나의 방식으로는
<code>kubectl</code> 커맨드-라인 인터페이스에 인자값으로 <code>.yaml</code> 파일을 건네
<a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a> 커맨드를 이용하는 것이다. 다음 예시와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</span></span></code></pre></div><p>그 출력 내용은 다음과 유사하다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=요구되는-필드>요구되는 필드</h3><p>생성하고자 하는 쿠버네티스 오브젝트에 대한 <code>.yaml</code> 파일 내, 다음 필드를 위한 값들을 설정해 줘야한다.</p><ul><li><code>apiVersion</code> - 이 오브젝트를 생성하기 위해 사용하고 있는 쿠버네티스 API 버전이 어떤 것인지</li><li><code>kind</code> - 어떤 종류의 오브젝트를 생성하고자 하는지</li><li><code>metadata</code> - <code>이름</code> 문자열, <code>UID</code>, 그리고 선택적인 <code>네임스페이스</code>를 포함하여 오브젝트를 유일하게 구분지어 줄 데이터</li><li><code>spec</code> - 오브젝트에 대해 어떤 상태를 의도하는지</li></ul><p>오브젝트 <code>spec</code>에 대한 정확한 포맷은 모든 쿠버네티스 오브젝트마다 다르고, 그 오브젝트 특유의
중첩된 필드를 포함한다. <a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 API 레퍼런스</a> 는
쿠버네티스를 이용하여 생성할 수 있는 오브젝트에 대한 모든 spec 포맷을 살펴볼 수 있도록 해준다.</p><p>예를 들어, 파드 API 레퍼런스를 보려면
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec><code>spec</code> 필드</a>를 참조한다.
각 파드에 대해, <code>.spec</code> 필드는 파드 및 파드의 원하는 상태(desired state)를
기술한다(예: 파드의 각 컨테이너에 대한 컨테이너 이미지).
오브젝트 상세에 대한 또 다른 예시는 스테이트풀셋 API의
<a href=/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec><code>spec</code> 필드</a>이다.
스테이트풀셋의 경우, <code>.spec</code> 필드는 스테이트풀셋 및 스테이트풀셋의 원하는 상태(desired state)를 기술한다.
스테이트풀셋의 <code>.spec</code>에는 파드 오브젝트에 대한
<a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>템플릿</a>이 존재한다.
이 템플릿은 스테이트풀셋 명세를 만족시키기 위해
스테이트풀셋 컨트롤러가 생성할 파드에 대한 상세 사항을 설명한다.
서로 다른 종류의 오브젝트는 서로 다른 <code>.status</code>를 가질 수 있다.
다시 한번 말하자면, 각 API 레퍼런스 페이지는 각 오브젝트 타입에 대해 해당 <code>.status</code> 필드의 구조와 내용에 대해 소개한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/workloads/pods/>파드</a>와 같이, 가장 중요하고 기본적인 쿠버네티스 오브젝트에 대해 배운다.</li><li>쿠버네티스의 <a href=/ko/docs/concepts/architecture/controller/>컨트롤러</a>에 대해 배운다.</li><li>API 개념의 더 많은 설명은 <a href=/ko/docs/reference/using-api/>쿠버네티스 API 사용</a>을 본다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6751db8ff5409476de8225d17d6c42dd>3.2 - 쿠버네티스 오브젝트 관리</h1><p><code>kubectl</code> 커맨드라인 툴은 쿠버네티스 오브젝트를 생성하고 관리하기 위한
몇 가지 상이한 방법을 지원한다. 이 문서는 여러가지 접근법에 대한 개요를
제공한다. Kubectl로 오브젝트 관리하기에 대한 자세한 설명은
<a href=https://kubectl.docs.kubernetes.io>Kubectl 서적</a>에서 확인한다.</p><h2 id=관리-기법>관리 기법</h2><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 쿠버네티스 오브젝트는 하나의 기법만 사용하여 관리해야 한다. 동일한 오브젝트에
대해 여러 기법을 혼용하는 것은 예상치 못한 동작을 초래하게 된다.</div><table><thead><tr><th>관리기법</th><th>대상</th><th>권장 환경</th><th>지원하는 작업자 수</th><th>학습 난이도</th></tr></thead><tbody><tr><td>명령형 커맨드</td><td>활성 오브젝트</td><td>개발 환경</td><td>1+</td><td>낮음</td></tr><tr><td>명령형 오브젝트 구성</td><td>개별 파일</td><td>프로덕션 환경</td><td>1</td><td>보통</td></tr><tr><td>선언형 오브젝트 구성</td><td>파일이 있는 디렉터리</td><td>프로덕션 환경</td><td>1+</td><td>높음</td></tr></tbody></table><h2 id=명령형-커맨드>명령형 커맨드</h2><p>명령형 커맨드를 사용할 경우, 사용자는 클러스터 내 활성 오브젝트를 대상으로
직접 동작시킨다. 사용자는 실행할 작업을 인수 또는 플래그로 <code>kubectl</code> 커맨드에
지정한다.</p><p>이것은 클러스터에서 일회성 작업을 개시시키거나 동작시키기 위한
추천 방법이다. 이 기법은 활성 오브젝트를 대상으로 직접적인
영향을 미치기 때문에, 이전 구성에 대한 이력을 제공해 주지 않는다.</p><h3 id=예시>예시</h3><p>디플로이먼트 오브젝트를 생성하여 nginx 컨테이너의 인스턴스를 구동시킨다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id=트레이드-오프>트레이드 오프</h3><p>오브젝트 구성에 비해 장점은 다음과 같다.</p><ul><li>커맨드는 하나의 동작을 나타내는 단어로 표현된다.</li><li>커맨드는 클러스터를 수정하기 위해 단 하나의 단계만을 필요로 한다.</li></ul><p>오브젝트 구성에 비해 단점은 다음과 같다.</p><ul><li>커맨드는 변경 검토 프로세스와 통합되지 않는다.</li><li>커맨드는 변경에 관한 감사 추적(audit trail)을 제공하지 않는다.</li><li>커맨드는 활성 동작 중인 경우를 제외하고는 레코드의 소스를 제공하지 않는다.</li><li>커맨드는 새로운 오브젝트 생성을 위한 템플릿을 제공하지 않는다.</li></ul><h2 id=명령형-오브젝트-구성>명령형 오브젝트 구성</h2><p>명령형 오브젝트 구성에서는 kubectl 커맨드로 작업(생성, 교체 등),
선택적 플래그, 그리고 최소 하나의 파일 이름을 지정한다.
그 파일은 YAML 또는 JSON 형식으로 오브젝트의 완전한 정의를
포함해야만 한다.</p><p>오브젝트 정의에 대한 더 자세한 내용은 <a href=/docs/reference/generated/kubernetes-api/v1.25/>API 참조</a>를
참고한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 명령형 <code>replace</code> 커맨드는 기존 spec을 새로 제공된 spec으로 바꾸고
구성 파일에서 누락된 오브젝트의 모든 변경 사항을 삭제한다.
이 방법은 spec이 구성 파일과는 별개로 업데이트되는 리소스 유형에는
사용하지 말아야한다.
예를 들어 <code>LoadBalancer</code> 유형의 서비스는 클러스터의 구성과 별도로
<code>externalIPs</code> 필드가 업데이트된다.</div><h3 id=예시-1>예시</h3><p>구성 파일에 정의된 오브젝트를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>두 개의 구성 파일에 정의된 오브젝트를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>활성 동작하는 구성을 덮어씀으로써 구성 파일에 정의된 오브젝트를
업데이트한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id=트레이드-오프-1>트레이드 오프</h3><p>명령형 커맨드에 비해 장점은 다음과 같다.</p><ul><li>오브젝트 구성은 Git과 같은 소스 컨트롤 시스템에 보관할 수 있다.</li><li>오브젝트 구성은 푸시와 감사 추적 전에 변경사항을 검토하는 것과 같은 프로세스들과 통합할 수 있다.</li><li>오브젝트 구성은 새로운 오브젝트 생성을 위한 템플릿을 제공한다.</li></ul><p>명령형 커맨드에 비해 단점은 다음과 같다.</p><ul><li>오브젝트 구성은 오브젝트 스키마에 대한 기본적인 이해를 필요로 한다.</li><li>오브젝트 구성은 YAML 파일을 기록하는 추가적인 과정을 필요로 한다.</li></ul><p>선언형 오브젝트 구성에 비해 장점은 다음과 같다.</p><ul><li>명령형 오브젝트 구성의 동작은 보다 간결하고 이해하기 쉽다.</li><li>쿠버네티스 버전 1.5 부터는 더 성숙한 명령형 오브젝트 구성을 제공한다.</li></ul><p>선언형 오브젝트 구성에 비해 단점은 다음과 같다.</p><ul><li>명령형 오브젝트 구성은 디렉터리가 아닌, 파일에 가장 적합하다.</li><li>활성 오브젝트에 대한 업데이트는 구성 파일에 반영되어야 한다. 그렇지 않으면 다음 교체 중에 손실된다.</li></ul><h2 id=선언형-오브젝트-구성>선언형 오브젝트 구성</h2><p>선언형 오브젝트 구성을 사용할 경우, 사용자는 로컬에 보관된 오브젝트
구성 파일을 대상으로 작동시키지만, 사용자는 파일에서 수행 할
작업을 정의하지 않는다. 생성, 업데이트, 그리고 삭제 작업은
<code>kubectl</code>에 의해 오브젝트마다 자동으로 감지된다. 이를 통해 다른 오브젝트에 대해
다른 조작이 필요할 수 있는 디렉터리에서 작업할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 선언형 오브젝트 구성은 변경 사항이 오브젝트 구성 파일에
다시 병합되지 않더라도 다른 작성자가 작성한 변경 사항을 유지한다.
이것은 전체 오브젝트 구성 변경을 위한 <code>replace</code> API를
사용하는 대신, <code>patch</code> API를 사용하여 인지되는 차이만
작성하기 때문에 가능하다.</div><h3 id=예시-2>예시</h3><p><code>configs</code> 디렉터리 내 모든 오브젝트 구성 파일을 처리하고 활성 오브젝트를
생성 또는 패치한다. 먼저 어떠한 변경이 이루어지게 될지 알아보기 위해 <code>diff</code>
하고 나서 적용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -f configs/
</span></span><span style=display:flex><span>kubectl apply -f configs/
</span></span></code></pre></div><p>재귀적으로 디렉터리를 처리한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -R -f configs/
</span></span><span style=display:flex><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id=트레이드-오프-2>트레이드 오프</h3><p>명령형 오브젝트 구성에 비해 장점은 다음과 같다.</p><ul><li>활성 오브젝트에 직접 작성된 변경 사항은 구성 파일로 다시 병합되지 않더라도 유지된다.</li><li>선언형 오브젝트 구성은 디렉터리에서의 작업 및 오브젝트 별 작업 유형(생성, 패치, 삭제)의 자동 감지에 더 나은 지원을 제공한다.</li></ul><p>명령형 오브젝트 구성에 비해 단점은 다음과 같다.</p><ul><li>선언형 오브젝트 구성은 예상치 못한 결과를 디버깅하고 이해하기가 더 어렵다.</li><li>diff를 사용한 부분 업데이트는 복잡한 병합 및 패치 작업을 일으킨다.</li></ul><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-command/>명령형 커맨드를 이용한 쿠버네티스 오브젝트 관리하기</a></li><li><a href=/ko/docs/tasks/manage-kubernetes-objects/imperative-config/>구성파일을 이용한 명령형 쿠버네티스 오브젝트 관리</a></li><li><a href=/ko/docs/tasks/manage-kubernetes-objects/declarative-config/>구성 파일을 이용한 쿠버네티스 오브젝트의 선언형 관리</a></li><li><a href=/ko/docs/tasks/manage-kubernetes-objects/kustomization/>Kustomize를 이용한 쿠버네티스 오브젝트의 선언형 관리</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl 커맨드 참조</a></li><li><a href=https://kubectl.docs.kubernetes.io>Kubectl 서적</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 API 참조</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>3.3 - 오브젝트 이름과 ID</h1><p>클러스터의 각 오브젝트는 해당 유형의 리소스에 대하여 고유한 <a href=#names><em>이름</em></a> 을 가지고 있다.
또한, 모든 쿠버네티스 오브젝트는 전체 클러스터에 걸쳐 고유한 <a href=#uids><em>UID</em></a> 를 가지고 있다.</p><p>예를 들어, 이름이 <code>myapp-1234</code>인 파드는 동일한 <a href=/ko/docs/concepts/overview/working-with-objects/namespaces/>네임스페이스</a> 내에서 하나만 존재할 수 있지만, 이름이 <code>myapp-1234</code>인 파드와 디플로이먼트는 각각 존재할 수 있다.</p><p>유일하지 않은 사용자 제공 속성의 경우 쿠버네티스는 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>과 <a href=/ko/docs/concepts/overview/working-with-objects/annotations/>어노테이션</a>을 제공한다.</p><h2 id=names>이름</h2><p><code>/api/v1/pods/some-name</code>과 같이, 리소스 URL에서 오브젝트를 가리키는 클라이언트 제공 문자열.</p><p>특정 시점에 같은 종류(kind) 내에서는 하나의 이름은 하나의 오브젝트에만 지정될 수 있다. 하지만, 오브젝트를 삭제한 경우, 삭제된 오브젝트와 같은 이름을 새로운 오브젝트에 지정 가능하다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 물리적 호스트를 나타내는 노드와 같이 오브젝트가 물리적 엔티티를 나타내는 경우, 노드를 삭제한 후 다시 생성하지 않은 채 동일한 이름으로 호스트를 다시 생성하면, 쿠버네티스는 새 호스트를 불일치로 이어질 수 있는 이전 호스트로 취급한다.</div><p>다음은 리소스에 일반적으로 사용되는 네 가지 유형의 이름 제한 조건이다.</p><h3 id=dns-서브도메인-이름>DNS 서브도메인 이름</h3><p>대부분의 리소스 유형에는 <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>에 정의된 대로
DNS 서브도메인 이름으로 사용할 수 있는 이름이 필요하다.
이것은 이름이 다음을 충족해야 한다는 것을 의미한다.</p><ul><li>253자를 넘지 말아야 한다.</li><li>소문자와 영숫자 <code>-</code> 또는 <code>.</code> 만 포함한다.</li><li>영숫자로 시작한다.</li><li>영숫자로 끝난다.</li></ul><h3 id=dns-label-names>RFC 1123 레이블 이름</h3><p>일부 리소스 유형은 <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>에
정의된 대로 DNS 레이블 표준을 따라야 한다.
이것은 이름이 다음을 충족해야 한다는 것을 의미한다.</p><ul><li>최대 63자이다.</li><li>소문자와 영숫자 또는 <code>-</code> 만 포함한다.</li><li>영숫자로 시작한다.</li><li>영숫자로 끝난다.</li></ul><h3 id=rfc-1035-레이블-이름>RFC 1035 레이블 이름</h3><p>몇몇 리소스 타입은 자신의 이름을 <a href=https://tools.ietf.org/html/rfc1035>RFC 1035</a>에
정의된 DNS 레이블 표준을 따르도록 요구한다.
이것은 이름이 다음을 만족해야 한다는 의미이다.</p><ul><li>최대 63개 문자를 포함</li><li>소문자 영숫자 또는 '-'만 포함</li><li>알파벳 문자로 시작</li><li>영숫자로 끝남</li></ul><h3 id=경로-세그먼트-이름>경로 세그먼트 이름</h3><p>일부 리소스 유형에서는 이름을 경로 세그먼트로 안전하게 인코딩 할 수
있어야 한다. 즉 이름이 "." 또는 ".."이 아닐 수 있으며 이름에는
"/" 또는 "%"가 포함될 수 없다.</p><p>아래는 파드의 이름이 <code>nginx-demo</code>라는 매니페스트 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 일부 리소스 유형은 이름에 추가적인 제약이 있다.</div><h2 id=uids>UID</h2><p>오브젝트를 중복 없이 식별하기 위해 쿠버네티스 시스템이 생성하는 문자열.</p><p>쿠버네티스 클러스터가 구동되는 전체 시간에 걸쳐 생성되는 모든 오브젝트는 서로 구분되는 UID를 갖는다. 이는 기록상 유사한 오브젝트의 출현을 서로 구분하기 위함이다.</p><p>쿠버네티스 UID는 보편적으로 고유한 식별자이다(또는 UUID라고 한다).
UUID는 ISO/IEC 9834-8 과 ITU-T X.667 로 표준화 되어 있다.</p><h2 id=다음-내용>다음 내용</h2><ul><li>쿠버네티스의 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>에 대해 읽기.</li><li><a href=https://git.k8s.io/design-proposals-archive/architecture/identifiers.md>쿠버네티스의 식별자와 이름</a> 디자인 문서 읽기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>3.4 - 네임스페이스</h1><p>쿠버네티스에서, <em>네임스페이스</em> 는 단일 클러스터 내에서의 리소스 그룹 격리 메커니즘을 제공한다. 리소스의 이름은 네임스페이스 내에서 유일해야 하며, 네임스페이스 간에서 유일할 필요는 없다. 네임스페이스 기반 스코핑은 네임스페이스 기반 오브젝트 <em>(예: 디플로이먼트, 서비스 등)</em> 에만 적용 가능하며 클러스터 범위의 오브젝트 <em>(예: 스토리지클래스, 노드, 퍼시스턴트볼륨 등)</em> 에는 적용 불가능하다.</p><h2 id=여러-개의-네임스페이스를-사용하는-경우>여러 개의 네임스페이스를 사용하는 경우</h2><p>네임스페이스는 여러 개의 팀이나, 프로젝트에 걸쳐서 많은 사용자가 있는 환경에서 사용하도록
만들어졌다. 사용자가 거의 없거나, 수 십명 정도가 되는 경우에는
네임스페이스를 전혀 고려할 필요가 없다.
네임스페이스가 제공하는 기능이 필요할 때 사용하도록 하자.</p><p>네임스페이스는 이름의 범위를 제공한다. 리소스의 이름은 네임스페이스 내에서 유일해야하지만,
네임스페이스를 통틀어서 유일할 필요는 없다. 네임스페이스는 서로 중첩될 수 없으며,
각 쿠버네티스 리소스는 하나의 네임스페이스에만 있을 수 있다.</p><p>네임스페이스는 클러스터 자원을 (<a href=/ko/docs/concepts/policy/resource-quotas/>리소스 쿼터</a>를 통해) 여러 사용자 사이에서 나누는 방법이다.</p><p>동일한 소프트웨어의 다른 버전과 같이 약간 다른 리소스를 분리하기 위해
여러 네임스페이스를 사용할 필요는 없다. 동일한 네임스페이스 내에서 리소스를
구별하기 위해 <a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>을
사용한다.</p><h2 id=네임스페이스-다루기>네임스페이스 다루기</h2><p>네임스페이스의 생성과 삭제는
<a href=/ko/docs/tasks/administer-cluster/namespaces/>네임스페이스 관리자 가이드 문서</a>에 기술되어 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kube-</code> 접두사로 시작하는 네임스페이스는 쿠버네티스 시스템용으로 예약되어 있으므로, 사용자는 이러한 네임스페이스를 생성하지 않는다.</div><h3 id=네임스페이스-조회>네임스페이스 조회</h3><p>사용 중인 클러스터의 현재 네임스페이스를 나열할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
</code></pre><p>쿠버네티스는 처음에 네 개의 초기 네임스페이스를 갖는다.</p><ul><li><code>default</code> 다른 네임스페이스가 없는 오브젝트를 위한 기본 네임스페이스</li><li><code>kube-system</code> 쿠버네티스 시스템에서 생성한 오브젝트를 위한 네임스페이스</li><li><code>kube-public</code> 이 네임스페이스는 자동으로 생성되며 모든 사용자(인증되지 않은 사용자 포함)가 읽기 권한으로 접근할 수 있다. 이 네임스페이스는 주로 전체 클러스터 중에 공개적으로 드러나서 읽을 수 있는 리소스를 위해 예약되어 있다. 이 네임스페이스의 공개적인 성격은 단지 관례이지 요구 사항은 아니다.</li><li><code>kube-node-lease</code> 이 네임스페이스는 각 노드와 연관된 <a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>리스</a>
오브젝트를 갖는다. 노드 리스는 kubelet이 <a href=/ko/docs/concepts/architecture/nodes/#%ED%95%98%ED%8A%B8%EB%B9%84%ED%8A%B8>하트비트</a>를
보내서 컨트롤 플레인이 노드의 장애를 탐지할 수 있게 한다.</li></ul><h3 id=요청에-네임스페이스-설정하기>요청에 네임스페이스 설정하기</h3><p>현재 요청에 대한 네임스페이스를 설정하기 위해서 <code>--namespace</code> 플래그를 사용한다.</p><p>예를 들면,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id=선호하는-네임스페이스-설정하기>선호하는 네임스페이스 설정하기</h3><p>이후 모든 kubectl 명령에서 사용하는 네임스페이스를 컨텍스트에
영구적으로 저장할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 확인하기</span>
</span></span><span style=display:flex><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id=네임스페이스와-dns>네임스페이스와 DNS</h2><p><a href=/ko/docs/concepts/services-networking/service/>서비스</a>를 생성하면 해당
<a href=/ko/docs/concepts/services-networking/dns-pod-service/>DNS 엔트리</a>가 생성된다.
이 엔트리는 <code>&lt;서비스-이름>.&lt;네임스페이스-이름>.svc.cluster.local</code>의 형식을 갖는데,
이는 컨테이너가 <code>&lt;서비스-이름></code>만 사용하는 경우, 네임스페이스 내에 국한된 서비스로 연결된다.
개발, 스테이징, 운영과 같이 여러 네임스페이스 내에서 동일한 설정을 사용하는 경우에 유용하다.
네임스페이스를 넘어서 접근하기 위해서는,
전체 주소 도메인 이름(FQDN)을 사용해야 한다.</p><p>그렇기 때문에, 모든 네임스페이스 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-label-names>RFC 1123 DNS 레이블</a>이어야 한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong><p>네임스페이스의 이름을 <a href=https://data.iana.org/TLD/tlds-alpha-by-domain.txt>공개 최상위 도메인</a> 중 하나와 동일하게 만들면,
해당 네임스페이스 내의 서비스의 짧은 DNS 이름이 공개 DNS 레코드와 겹칠 수 있다.
어떠한 네임스페이스 내의 워크로드가
<a href=https://datatracker.ietf.org/doc/html/rfc1034#page-8>접미점(trailing dot)</a> 없이 DNS 룩업을 수행하면
공개 DNS 레코드보다 우선하여 해당 서비스로 리다이렉트될 것이다.</p><p>이를 방지하기 위해, 신뢰하는 사용자만 네임스페이스를
생성할 수 있도록 권한을 제한한다.
필요한 경우, 추가적으로 써드파티 보안 컨트롤을 구성할 수 있으며,
예를 들어 <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>어드미션 웹훅</a>을 이용하여
<a href=https://data.iana.org/TLD/tlds-alpha-by-domain.txt>공개 TLD</a>와
동일한 이름의 네임스페이스 생성을 금지시킬 수 있다.</p></div><h2 id=모든-오브젝트가-네임스페이스에-속하지는-않음>모든 오브젝트가 네임스페이스에 속하지는 않음</h2><p>대부분의 쿠버네티스 리소스(예를 들어, 파드, 서비스, 레플리케이션 컨트롤러 외)는
네임스페이스에 속한다. 하지만 네임스페이스 리소스 자체는 네임스페이스에 속하지 않는다.
그리고 <a href=/ko/docs/concepts/architecture/nodes/>노드</a>나
퍼시스턴트 볼륨과 같은 저수준 리소스는 어느
네임스페이스에도 속하지 않는다.</p><p>다음은 네임스페이스에 속하지 않는 쿠버네티스 리소스를 조회하는 방법이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 네임스페이스에 속하는 리소스</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 네임스페이스에 속하지 않는 리소스</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h2 id=자동-레이블링>자동 레이블링</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes 1.21 [beta]</code></div><p>쿠버네티스 컨트롤 플레인은 <code>NamespaceDefaultLabelName</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가
활성화된 경우 모든 네임스페이스에 변경할 수 없는(immutable) <a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>
<code>kubernetes.io / metadata.name</code> 을 설정한다.
레이블 값은 네임스페이스 이름이다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/administer-cluster/namespaces/#%EC%83%88-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0>신규 네임스페이스 생성</a>에 대해 더 배우기.</li><li><a href=/ko/docs/tasks/administer-cluster/namespaces/#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0>네임스페이스 삭제</a>에 대해 더 배우기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>3.5 - 레이블과 셀렉터</h1><p><em>레이블</em> 은 파드와 같은 오브젝트에 첨부된 키와 값의 쌍이다.
레이블은 오브젝트의 특성을 식별하는 데 사용되어 사용자에게 중요하지만, 코어 시스템에 직접적인 의미는 없다.
레이블로 오브젝트의 하위 집합을 선택하고, 구성하는데 사용할 수 있다. 레이블은 오브젝트를 생성할 때에 붙이거나 생성 이후에 붙이거나 언제든지 수정이 가능하다.
오브젝트마다 키와 값으로 레이블을 정의할 수 있다. 오브젝트의 키는 고유한 값이어야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>레이블은 UI와 CLI에서 효율적인 쿼리를 사용하고 검색에 사용하기에
적합하다. 식별되지 않는 정보는
<a href=/ko/docs/concepts/overview/working-with-objects/annotations/>어노테이션</a>으로 기록해야 한다.</p><h2 id=사용-동기>사용 동기</h2><p>레이블을 이용하면 사용자가 느슨하게 결합한 방식으로 조직 구조와 시스템 오브젝트를 매핑할 수 있으며, 클라이언트에 매핑 정보를 저장할 필요가 없다.</p><p>서비스 배포와 배치 프로세싱 파이프라인은 흔히 다차원의 엔티티들이다(예: 다중 파티션 또는 배포, 다중 릴리스 트랙, 다중 계층, 계층 속 여러 마이크로 서비스들). 관리에는 크로스-커팅 작업이 필요한 경우가 많은데 이 작업은 사용자보다는 인프라에 의해 결정된 엄격한 계층 표현인 캡슐화를 깨트린다.</p><p>레이블 예시:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>이 예시는 <a href=/ko/docs/concepts/overview/working-with-objects/common-labels/>일반적으로 사용하는 레이블</a>이며, 사용자는 자신만의 규칙(convention)에 따라 자유롭게 개발할 수 있다. 오브젝트에 붙여진 레이블 키는 고유해야 한다는 것을 기억해야 한다.</p><h2 id=구문과-캐릭터-셋>구문과 캐릭터 셋</h2><p><em>레이블</em> 은 키와 값의 쌍이다. 유효한 레이블 키에는 슬래시(<code>/</code>)로 구분되는 선택한 접두사와 이름이라는 2개의 세그먼트가 있다. 이름 세그먼트는 63자 미만으로 시작과 끝은 알파벳과 숫자(<code>[a-z0-9A-Z]</code>)이며, 대시(<code>-</code>), 밑줄(<code>_</code>), 점(<code>.</code>)과 함께 사용할 수 있다. 접두사는 선택이다. 만약 접두사를 지정한 경우 접두사는 DNS의 하위 도메인으로 해야 하며, 점(<code>.</code>)과 전체 253자 이하, 슬래시(<code>/</code>)로 구분되는 DNS 레이블이다.</p><p>접두사를 생략하면 키 레이블은 개인용으로 간주한다. 최종 사용자의 오브젝트에 자동화된 시스템 컴포넌트(예: <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code> 또는 다른 타사의 자동화 구성 요소)의 접두사를 지정해야 한다.</p><p><code>kubernetes.io/</code>와 <code>k8s.io/</code> 접두사는 쿠버네티스의 핵심 컴포넌트로 <a href=/ko/docs/reference/labels-annotations-taints/>예약</a>되어 있다.</p><p>유효한 레이블 값은 다음과 같다.</p><ul><li>63 자 이하여야 하고 (공백일 수도 있음),</li><li>(공백이 아니라면) 시작과 끝은 알파벳과 숫자(<code>[a-z0-9A-Z]</code>)이며,</li><li>알파벳과 숫자, 대시(<code>-</code>), 밑줄(<code>_</code>), 점(<code>.</code>)을 중간에 포함할 수 있다.</li></ul><p>다음의 예시는 파드에 <code>environment: production</code> 과 <code>app: nginx</code> 2개의 레이블이 있는 구성 파일이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=레이블-셀렉터>레이블 셀렉터</h2><p><a href=/ko/docs/concepts/overview/working-with-objects/names/>이름과 UID</a>와 다르게 레이블은 고유하지 않다. 일반적으로 우리는 많은 오브젝트에 같은 레이블을 가질 것으로 예상한다.</p><p>레이블 셀렉터를 통해 클라이언트와 사용자는 오브젝트를 식별할 수 있다. 레이블 셀렉터는 쿠버네티스 코어 그룹의 기본이다.</p><p>API는 현재 <em>일치성 기준</em> 과 <em>집합성 기준</em> 이라는 두 종류의 셀렉터를 지원한다.
레이블 셀렉터는 쉼표로 구분된 다양한 <em>요구사항</em> 에 따라 만들 수 있다. 다양한 요구사항이 있는 경우 쉼표 기호가 AND(<code>&&</code>) 연산자로 구분되는 역할을 하도록 해야 한다.</p><p>비어있거나 지정되지 않은 셀렉터는 상황에 따라 달라진다.
셀렉터를 사용하는 API 유형은 유효성과 의미를
문서화해야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 레플리카셋(ReplicaSet)과 같은 일부 API 유형에서 두 인스턴스의 레이블 셀렉터는 네임스페이스 내에서 겹치지 않아야 한다. 그렇지 않으면 컨트롤러는 상충하는 명령으로 보고, 얼마나 많은 복제본이 필요한지 알 수 없다.</div><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 일치성 기준과 집합성 기준 조건 모두에 대해 논리적인 <em>OR</em> (<code>||</code>) 연산자가 없다. 필터 구문이 적절히 구성되어 있는지 확인해야 한다.</div><h3 id=일치성-기준-요건><em>일치성 기준</em> 요건</h3><p><em>일치성 기준</em> 또는 <em>불일치 기준</em> 의 요구사항으로 레이블의 키와 값의 필터링을 허용한다. 일치하는 오브젝트는 추가 레이블을 가질 수 있지만, 레이블의 명시된 제약 조건을 모두 만족해야 한다.
<code>=</code>,<code>==</code>,<code>!=</code> 이 세 가지 연산자만 허용한다. 처음 두 개의 연산자의 <em>일치성</em>(그리고 동의어), 나머지는 <em>불일치</em> 를 의미한다. 예를 들면,</p><pre tabindex=0><code>environment = production
tier != frontend
</code></pre><p>전자는 <code>environment</code>를 키로 가지는 것과 <code>production</code>을 값으로 가지는 모든 리소스를 선택한다.
후자는 <code>tier</code>를 키로 가지고, 값을 <code>frontend</code>를 가지는 리소스를 제외한 모든 리소스를 선택하고, <code>tier</code>를 키로 가지며, 값을 공백으로 가지는 모든 리소스를 선택한다.
<code>environment=production,tier!=frontend</code> 처럼 쉼표를 통해 한 문장으로 <code>frontend</code>를 제외한 <code>production</code>을 필터링할 수 있다.</p><p>일치성 기준 레이블 요건에 대한 하나의 이용 시나리오는 파드가 노드를 선택하는 기준을 지정하는 것이다.
예를 들어, 아래 샘플 파드는 "<code>accelerator=nvidia-tesla-p100</code>"
레이블을 가진 노드를 선택한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;registry.k8s.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=집합성-기준-요건><em>집합성 기준</em> 요건</h3><p><em>집합성 기준</em> 레이블 요건에 따라 값 집합을 키로 필터링할 수 있다. <code>in</code>,<code>notin</code>과 <code>exists</code>(키 식별자만 해당)의 3개의 연산자를 지원한다. 예를 들면,</p><pre tabindex=0><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><ul><li>첫 번째 예시에서 키가 <code>environment</code>이고 값이 <code>production</code> 또는 <code>qa</code>인 모든 리소스를 선택한다.</li><li>두 번째 예시에서 키가 <code>tier</code>이고 값이 <code>frontend</code>와 <code>backend</code>를 가지는 리소스를 제외한 모든 리소스와 키로 <code>tier</code>를 가지고 값을 공백으로 가지는 모든 리소스를 선택한다.</li><li>세 번째 예시에서 레이블의 값에 상관없이 키가 <code>partition</code>을 포함하는 모든 리소스를 선택한다.</li><li>네 번째 예시에서 레이블의 값에 상관없이 키가 <code>partition</code>을 포함하지 않는 모든 리소스를 선택한다.</li></ul><p>마찬가지로 쉼표는 <em>AND</em> 연산자로 작동한다. 따라서 <code>partition,environment notin (qa)</code>와 같이 사용하면 값과 상관없이 키가 <code>partition</code>인 것과 키가 <code>environment</code>이고 값이 <code>qa</code>와 다른 리소스를 필터링할 수 있다.
<em>집합성 기준</em> 레이블 셀렉터는 일반적으로 <code>environment=production</code>과 <code>environment in (production)</code>을 같은 것으로 본다. 유사하게는 <code>!=</code>과 <code>notin</code>을 같은 것으로 본다.</p><p><em>집합성 기준</em> 요건은 <em>일치성 기준</em> 요건과 조합해서 사용할 수 있다. 예를 들어 <code>partition in (customerA, customerB),environment!=qa</code></p><h2 id=api>API</h2><h3 id=list와-watch-필터링>LIST와 WATCH 필터링</h3><p>LIST와 WATCH 작업은 쿼리 파라미터를 사용해서 반환되는 오브젝트 집합을 필터링하기 위해 레이블 셀렉터를 지정할 수 있다. 다음의 두 가지 요건 모두 허용된다(URL 쿼리 문자열을 그대로 표기함).</p><ul><li><em>일치성 기준</em> 요건: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li><em>집합성 기준</em> 요건: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>두 가지 레이블 셀렉터 스타일은 모두 REST 클라이언트를 통해 선택된 리소스를 확인하거나 목록을 볼 수 있다. 예를 들어, <code>kubectl</code>로 <code>apiserver</code>를 대상으로 <em>일치성 기준</em> 으로 하는 셀렉터를 다음과 같이 이용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>또는 <em>집합성 기준</em> 요건을 사용하면</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</span></span></code></pre></div><p>앞서 안내한 것처럼 <em>집합성 기준</em> 요건은 더 보여준다. 예시에서 다음과 같이 OR 연산자를 구현할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</span></span></code></pre></div><p>또는 <em>exists</em> 연산자에 불일치한 것으로 제한할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</span></span></code></pre></div><h3 id=api-오브젝트에서-참조-설정>API 오브젝트에서 참조 설정</h3><p><a href=/ko/docs/concepts/services-networking/service/><code>services</code></a> 와
<a href=/ko/docs/concepts/workloads/controllers/replicationcontroller/><code>replicationcontrollers</code></a>와 같은
일부 쿠버네티스 오브젝트는 레이블 셀렉터를 사용해서
<a href=/ko/docs/concepts/workloads/pods/>파드</a>와 같은 다른 리소스 집합을 선택한다.</p><h4 id=서비스와-레플리케이션-컨트롤러>서비스와 레플리케이션 컨트롤러</h4><p><code>services</code>에서 지정하는 파드 집합은 레이블 셀렉터로 정의한다. 마찬가지로 <code>replicationcontrollers</code>가 관리하는 파드의 오브젝트 그룹도 레이블 셀렉터로 정의한다.</p><p>서비스와 레플리케이션 컨트롤러의 레이블 셀렉터는 <code>json</code> 또는 <code>yaml</code> 파일에 매핑된 <em>일치성 기준</em> 요구사항의 셀렉터만 지원한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>or</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>json</code> 또는 <code>yaml</code> 서식에서 셀렉터는 <code>component=redis</code> 또는 <code>component in (redis)</code> 모두 같은 것이다.</p><h4 id=세트-기반-요건을-지원하는-리소스>세트-기반 요건을 지원하는 리소스</h4><p><a href=/ko/docs/concepts/workloads/controllers/job/><code>Job</code></a>,
<a href=/ko/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>,
<a href=/ko/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a> 그리고
<a href=/ko/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a> 같은
새로운 리소스들은 <em>집합성 기준</em> 의 요건도 지원한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>matchLabels</code>는 <code>{key,value}</code>의 쌍과 매칭된다. <code>matchLabels</code>에 매칭된 단일 <code>{key,value}</code>는 <code>matchExpressions</code>의 요소와 같으며 <code>key</code> 필드는 "key"로, <code>operator</code>는 "In" 그리고 <code>values</code>에는 "value"만 나열되어 있다. <code>matchExpressions</code>는 파드 셀렉터의 요건 목록이다. 유효한 연산자에는 In, NotIn, Exists 및 DoNotExist가 포함된다. In 및 NotIn은 설정된 값이 있어야 한다. <code>matchLabels</code>와 <code>matchExpressions</code> 모두 AND로 되어 있어 일치하기 위해서는 모든 요건을 만족해야 한다.</p><h4 id=노드-셋-선택>노드 셋 선택</h4><p>레이블을 통해 선택하는 사용 사례 중 하나는 파드를 스케줄 할 수 있는 노드 셋을 제한하는 것이다.
자세한 내용은 <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/>노드 선택</a> 문서를 참조한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>3.6 - 어노테이션</h1><p>쿠버네티스 어노테이션을 사용하여 임의의 비-식별 메타데이터를
오브젝트에 첨부할 수 있다. 도구 및 라이브러리와 같은 클라이언트는 이 메타데이터를 검색할 수 있다.</p><h2 id=오브젝트에-메타데이터-첨부>오브젝트에 메타데이터 첨부</h2><p>레이블이나 어노테이션을 사용하여 쿠버네티스
오브젝트에 메타데이터를 첨부할 수 있다. 레이블을 사용하여 오브젝트를 선택하고, 특정 조건을 만족하는 오브젝트
컬렉션을 찾을 수 있다. 반면에, 어노테이션은
오브젝트를 식별하고 선택하는데 사용되지 않는다. 어노테이션의 메타데이터는
작거나 크고, 구조적이거나 구조적이지 않을 수 있으며, 레이블에서
허용되지 않는 문자를 포함할 수 있다.</p><p>어노테이션은 레이블과 같이 키/값 맵이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 맵의 키와 값은 문자열이어야 한다. 다르게 말해서, 숫자,
불리언(boolean), 리스트 등의 다른 형식을 키나 값에 사용할 수 없다.</div><p>다음은 어노테이션에 기록할 수 있는 정보의 예제이다.</p><ul><li><p>필드는 선언적 구성 계층에 의해 관리된다. 이러한 필드를 어노테이션으로 첨부하는 것은
클라이언트 또는 서버가 설정한 기본 값,
자동 생성된 필드, 그리고
오토사이징 또는 오토스케일링 시스템에 의해 설정된 필드와 구분된다.</p></li><li><p>빌드, 릴리스, 또는 타임 스탬프, 릴리스 ID, git 브랜치,
PR 번호, 이미지 해시 및 레지스트리 주소와 같은 이미지 정보.</p></li><li><p>로깅, 모니터링, 분석 또는 감사 리포지터리에 대한 포인터.</p></li><li><p>디버깅 목적으로 사용될 수 있는 클라이언트 라이브러리 또는 도구 정보:
예를 들면, 이름, 버전, 그리고 빌드 정보.</p></li><li><p>다른 생태계 구성 요소의 관련 오브젝트 URL과 같은
사용자 또는 도구/시스템 출처 정보.</p></li><li><p>경량 롤아웃 도구 메타데이터. 예: 구성 또는 체크포인트</p></li><li><p>책임자의 전화번호 또는 호출기 번호, 또는 팀 웹 사이트 같은
해당 정보를 찾을 수 있는 디렉터리 진입점.</p></li><li><p>행동을 수정하거나 비표준 기능을 수행하기 위한
최종 사용자의 지시 사항.</p></li></ul><p>어노테이션을 사용하는 대신, 이 유형의 정보를
외부 데이터베이스 또는 디렉터리에 저장할 수 있지만, 이는 배포, 관리, 인트로스펙션(introspection) 등을 위한
공유 클라이언트 라이브러리와 도구 생성을
훨씬 더 어렵게 만들 수 있다.</p><h2 id=문법과-캐릭터-셋>문법과 캐릭터 셋</h2><p><em>어노테이션</em> 은 키/값 쌍이다. 유효한 어노테이션 키에는 두 개의 세그먼트가 있다. 두 개의 세그먼트는 선택적인 접두사와 이름(name)이며, 슬래시(<code>/</code>)로 구분된다. 이름 세그먼트는 필수이며, 영문 숫자(<code>[a-z0-9A-Z]</code>)로 시작하고 끝나는 63자 이하이어야 하고, 사이에 대시(<code>-</code>), 밑줄(<code>_</code>), 점(<code>.</code>)이 들어갈 수 있다. 접두사는 선택적이다. 지정된 경우, 접두사는 DNS 서브도메인이어야 한다. 점(<code>.</code>)으로 구분된 일련의 DNS 레이블은 총 253자를 넘지 않고, 뒤에 슬래시(<code>/</code>)가 붙는다.</p><p>접두사가 생략되면, 어노테이션 키는 사용자에게 비공개로 간주된다. 최종 사용자 오브젝트에 어노테이션을 추가하는 자동화된 시스템 구성 요소(예 :<code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, 또는 다른 써드파티 자동화)는 접두사를 지정해야 한다.</p><p><code>kubernetes.io/</code>와 <code>k8s.io/</code> 접두사는 쿠버네티스 핵심 구성 요소를 위해 예약되어 있다.</p><p>다음은 <code>imageregistry: https://hub.docker.com/</code> 어노테이션이 있는 파드의 구성 파일 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotations-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageregistry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://hub.docker.com/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><p><a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블과 셀렉터</a>에 대해 알아본다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-13ce5627ef1dc8cbb4530ed231cb7d38>3.7 - 파이널라이저</h1><p>파이널라이저는 쿠버네티스가 오브젝트를 완전히 삭제하기 이전, 삭제 표시를 위해
특정 조건이 충족될 때까지 대기하도록 알려주기 위한 네임스페이스에 속한 키(namespaced key)이다.
파이널라이저는 삭제 완료된 오브젝트가 소유한 리소스를 정리하기 위해
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>에게 알린다.</p><p>파이널라이저를 가진 특정한 오브젝트를 쿠버네티스가 삭제하도록 지시할 때,
쿠버네티스 API는 <code>.metadata.delationTimestamp</code>을 덧붙여 삭제하도록 오브젝트에 표시하며,
<code>202</code> 상태코드(HTTP "Accepted")을 리턴한다. 대상 오브젝트가 Terminating 상태를 유지하는 동안 컨트롤 플레인
또는 다른 컴포넌트는 하나의 파이널라이저에서 정의한 작업을 수행한다.
정의된 작업이 완료 후에, 그 컨트롤러는 대상 오브젝트로부터 연관된 파이널라이저을 삭제한다.
<code>metadata.finalizers</code> 필드가 비어 있을 때, 쿠버네티스는
삭제가 완료된 것으로 간주하고 오브젝트를 삭제한다.</p><p>파이널라이저가 리소스들의 <a class=glossary-tooltip title='쿠버네티스가 클러스터 자원을 정리하기 위해 사용하는 다양한 방법을 종합한 용어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/garbage-collection/ target=_blank aria-label='가비지 컬렉션'>가비지 컬렉션</a>을 제어하도록
사용할 수 있다. 예를 들어, 하나의 파이널라이저를 컨트롤러가 대상 리소소를 삭제하기 전에
연관된 리소스들 또는 인프라를 정리하도록 정의할 수 있다.</p><p>파이널라이저(Finalizer)를 사용하면 리소스를 삭제하기 전 특정 정리 작업을 수행하도록
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러(Controller)>컨트롤러(Controller)</a>에 경고하여
리소스의 <a class=glossary-tooltip title='쿠버네티스가 클러스터 자원을 정리하기 위해 사용하는 다양한 방법을 종합한 용어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/garbage-collection/ target=_blank aria-label='가비지(Garbage) 수집'>가비지(Garbage) 수집</a>을 제어할 수 있다.</p><p>파이널라이저는 보통 실행할 코드를 지정하지 않는다.
대신 파이널라이저는 일반적으로 어노테이션과 비슷하게 특정 리소스에 대한 키들의 목록이다.
일부 파이널라이저는 쿠버네티스가 자동으로 지정하지만,
사용자가 직접 지정할 수도 있다.</p><h2 id=파이널라이저의-작동-방식>파이널라이저의 작동 방식</h2><p>매니페스트 파일을 사용해 리소스를 생성하면
<code>metadata.finalizers</code> 필드에 파이널라이저를 명시할 수 있다.
리소스를 삭제하려 할 때는
삭제 요청을 처리하는 API 서버가 <code>finalizers</code> 필드의 값을 인식하고 다음을 수행한다.</p><ul><li>삭제를 시작한 시각과 함께 <code>metadata.deletionTimestamp</code> 필드를 추가하도록
오브젝트를 수정한다.</li><li>오브젝트의 <code>metadata.finalizers</code> 필드가 비워질 때까지 오브젝트가 제거되지 않도록 한다.</li><li><code>202</code> 상태 코드를 리턴한다(HTTP "Accepted").</li></ul><p>이 파이널라이저를 관리하는 컨트롤러는 <code>metadata.deletionTimestamp</code>를 설정하는 오브젝트가 업데이트 되었음을 인지하여
오브젝트의 삭제가 요청되었음을 나타낸다.
그런 다음 컨트롤러는 그 리소스에 지정된 파이널라이저의 요구사항을 충족하려 시도한다.
컨트롤러는 파이널라이저 조건이 충족될 때 마다
리소스의 <code>finalizers</code> 필드에서 해당 키(key)를 제거한다.
<code>finalizers</code> 필드가 비워지면 <code>deletionTimestamp</code> 필드가 설정된 오브젝트는 자동으로 삭제된다.
또한 파이널라이저를 사용하여 관리되지 않는 리소스가 삭제되지 않도록 할 수 있다.</p><p>파이널라이저의 일반적인 예로는 <code>퍼시스턴트 볼륨(Persistent Volume)</code> 오브젝트가 실수로 삭제되는 것을 방지하는 <code>kubernetes.io/pv-protection</code>가 있다.
파드가 <code>퍼시스턴트 볼륨</code> 오브젝트를 사용 중일 때
쿠버네티스는 <code>pv-protection</code> 파이널라이저를 추가한다.
<code>퍼시스턴트 볼륨</code>을 삭제하려 하면 <code>Terminating</code> 상태가 되지만
파이널라이저가 존재하기 때문에 컨트롤러가 삭제할 수 없다.
파드가 <code>퍼시스턴트 볼륨</code>의 사용을 중지하면
쿠버네티스가 <code>pv-protection</code> 파이널라이저를 해제하고 컨트롤러는 볼륨을 삭제한다.</p><h2 id=소유자-레이블-파이널라이저>소유자 참조, 레이블, 파이널라이저</h2><p><a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블(Label)>레이블(Label)</a>와 마찬가지로
쿠버네티스에서
<a href=/docs/concepts/overview/working-with-objects/owners-dependents/>소유자 참조(Owner reference)</a>는
오브젝트 간의 관계를 설명하지만 다른 목적으로 사용된다.
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러(Controller)>컨트롤러(Controller)</a>가 파드와 같은 오브젝트를 관리할 때
레이블을 사용하여 관련 오브젝트의 그룹에 대한 변경 사항을 추적한다.
예를 들어 <a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a>이 하나 이상의 파드를 생성하면
잡 컨트롤러는 해당 파드에 레이블을 적용하고
클러스터 내 동일한 레이블을 갖는 파드에 대한 변경 사항을 추적한다.</p><p>또한, 잡 컨트롤러는 이러한 파드에 <em>소유자 참조</em>도 추가하여 파드를 생성한 잡을 가리킨다.
이 파드가 실행될 때 잡을 삭제하면
쿠버네티스는 사용자 참조(레이블 대신)를 사용하여
클러스터 내 어떤 파드가 정리되어야 하는지 결정한다.</p><p>쿠버네티스는 또한 삭제 대상 리소스에 대한 소유자 참조를 식별할 때
파이널라이저를 처리한다.</p><p>경우에 따라 파이널라이저는 종속 오브젝트의 삭제를 차단할 수 있으며
이로 인해 대상 소유자 오브젝트가
완전히 삭제되지 않고 예상보다 오래 유지될 수 있다.
이 경우 대상 소유자 및 종속 객체에 대한
파이널라이저와 소유자 참조를 확인해 원인을 해결해야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 오브젝트가 삭제 상태에 있는 경우, 삭제를 계속하려면 파이널라이저를 수동으로 제거해서는 안 된다.
일반적으로 파이널라이저는 특정한 목적으로 가지고 리소스에 추가되므로,
강제로 제거하면 클러스터에 문제가 발생할 수 있다.
이는 파이널라이저의 목적을 이해하고
다른 방법(예를 들어, 일부 종속 객체를 수동으로 정리하는 것)으로
수행될 때만 수행해야 한다.</div><h2 id=다음-내용>다음 내용</h2><ul><li>쿠버네티스 블로그에서
<a href=/blog/2021/05/14/using-finalizers-to-control-deletion/>파이널라이저를 사용해 삭제 제어하기</a>를 읽어본다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>3.8 - 필드 셀렉터</h1><p><em>필드 셀렉터</em> 는 한 개 이상의 리소스 필드 값에 따라 <a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/>쿠버네티스 리소스를 선택</a>하기 위해 사용된다. 필드 셀렉터 쿼리의 예시는 다음과 같다.</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>다음의 <code>kubectl</code> 커맨드는 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EB%8B%A8%EA%B3%84-phase><code>status.phase</code></a> 필드의 값이 <code>Running</code> 인 모든 파드를 선택한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 필드 셀렉터는 본질적으로 리소스 <em>필터</em> 이다. 기본적으로 적용되는 셀렉터나 필드는 없으며, 이는 명시된 종류의 모든 리소스가 선택된다는 것을 의미한다. 여기에 따라오는 <code>kubectl</code> 쿼리인 <code>kubectl get pods</code> 와 <code>kubectl get pods --field-selector ""</code> 는 동일하다.</div><h2 id=사용-가능한-필드>사용 가능한 필드</h2><p>사용 가능한 필드는 쿠버네티스의 리소스 종류에 따라서 다르다. 모든 리소스 종류는 <code>metadata.name</code> 과 <code>metadata.namespace</code> 필드 셀렉터를 사용할 수 있다. 사용할 수 없는 필드 셀렉터를 사용하면 다음과 같이 에러를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=사용-가능한-연산자>사용 가능한 연산자</h2><p>필드 셀렉터에서 <code>=</code>, <code>==</code>, <code>!=</code> 연산자를 사용할 수 있다 (<code>=</code>와 <code>==</code>는 동일한 의미이다). 예를 들면, 다음의 <code>kubectl</code> 커맨드는 <code>default</code> 네임스페이스에 속해있지 않은 모든 쿠버네티스 서비스를 선택한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=연계되는-셀렉터>연계되는 셀렉터</h2><p><a href=/ko/docs/concepts/overview/working-with-objects/labels>레이블</a>을 비롯한 다른 셀렉터처럼, 쉼표로 구분되는 목록을 통해 필드 셀렉터를 연계해서 사용할 수 있다. 다음의 <code>kubectl</code> 커맨드는 <code>status.phase</code> 필드가 <code>Running</code> 이 아니고, <code>spec.restartPolicy</code> 필드가 <code>Always</code> 인 모든 파드를 선택한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=여러-개의-리소스-종류>여러 개의 리소스 종류</h2><p>필드 셀렉터를 여러 개의 리소스 종류에 걸쳐 사용할 수 있다. 다음의 <code>kubectl</code> 커맨드는 <code>default</code> 네임스페이스에 속해있지 않은 모든 스테이트풀셋(StatefulSet)과 서비스를 선택한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>3.9 - 권장 레이블</h1><p>kubectl과 대시보드와 같은 많은 도구들로 쿠버네티스 오브젝트를 시각화 하고 관리할 수 있다.
공통 레이블 셋은 모든 도구들이 이해할 수 있는 공통의 방식으로 오브젝트를 식별하고
도구들이 상호 운용적으로 작동할 수 있도록 한다.</p><p>권장 레이블은 지원 도구 외에도 쿼리하는 방식으로
애플리케이션을 식별하게 한다.</p><p>메타데이터는 <em>애플리케이션</em> 의 개념을 중심으로 정리된다.
쿠버네티스는 플랫폼 서비스(PaaS)가 아니며 애플리케이션에 대해 공식적인 개념이 없거나 강요하지 않는다.
대신 애플리케이션은 비공식적이며 메타데이터로 설명된다.
애플리케이션에 포함된 정의는 유연하다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 메타데이터들은 권장하는 레이블이다. 애플리케이션을 보다 쉽게 관리할 수 있지만
코어 도구에는 필요하지 않다.</div><p>공유 레이블과 주석에는 공통 접두사인 <code>app.kubernetes.io</code> 가 있다.
접두사가 없는 레이블은 사용자가 개인적으로 사용할 수 있다.
공유 접두사는 공유 레이블이 사용자 정의 레이블을 방해하지 않도록 한다.</p><h2 id=레이블>레이블</h2><p>레이블을 최대한 활용하려면 모든 리소스 오브젝트에
적용해야 한다.</p><table><thead><tr><th>키</th><th>설명</th><th>예시</th><th>타입</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>애플리케이션 이름</td><td><code>mysql</code></td><td>문자열</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>애플리케이션의 인스턴스를 식별하는 고유한 이름</td><td><code>mysql-abcxzy</code></td><td>문자열</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>애플리케이션의 현재 버전 (예: a semantic version, revision hash 등.)</td><td><code>5.7.21</code></td><td>문자열</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>아키텍처 내 구성요소</td><td><code>database</code></td><td>문자열</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>이 애플리케이션의 전체 이름</td><td><code>wordpress</code></td><td>문자열</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>애플리케이션의 작동을 관리하는 데 사용되는 도구</td><td><code>helm</code></td><td>문자열</td></tr></tbody></table><p>위 레이블의 실제 예시는 다음 <a class=glossary-tooltip title='내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a> 오브젝트를 고려한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 아래는 전체 명세의 일부분이다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=애플리케이션과-애플리케이션-인스턴스>애플리케이션과 애플리케이션 인스턴스</h2><p>애플리케이션은 동일한 쿠버네티스 클러스터에,
심지어는 동일한 네임스페이스에도 한번 또는 그 이상 설치될 수 있다. 예를 들어, 하나의 쿠버네티스 클러스터에
WordPress가 여러 번 설치되어 각각 서로 다른 웹사이트를 서비스할 수 있다.</p><p>애플리케이션의 이름과 애플리케이션 인스턴스 이름은 별도로 기록된다.
예를 들어 WordPress는 애플리케이션 이름으로 <code>app.kubernetes.io/name</code> 이라는 레이블에 <code>wordpress</code> 라는 값을 가지며,
애플리케이션 인스턴스 이름으로는 <code>app.kubernetes.io/instance</code> 라는 레이블에
<code>wordpress-abcxzy</code> 라는 값을 가진다. 이를 통해 애플리케이션과 애플리케이션 인스턴스를
식별할 수 있다. 모든 애플리케이션 인스턴스는 고유한 이름을 가져야 한다.</p><h2 id=예시>예시</h2><p>위 레이블을 사용하는 다른 방식에 대한 예시는 다양한 복잡성이 있다.</p><h3 id=단순한-스테이트리스-서비스>단순한 스테이트리스 서비스</h3><p><code>Deployment</code> 와 <code>Service</code> 오브젝트를 통해 배포된 단순한 스테이트리스 서비스의 경우를 보자. 다음 두 식별자는 레이블을 가장 간단한 형태로 사용하는 방법을 나타낸다.</p><p><code>Deployment</code> 는 애플리케이션을 실행하는 파드를 감시하는 데 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>Service</code>는 애플리케이션을 노출하기 위해 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=데이터베이스가-있는-웹-애플리케이션>데이터베이스가 있는 웹 애플리케이션</h3><p>Helm을 이용해서 데이터베이스(MySQL)을 이용하는 웹 애플리케이션(WordPress)을
설치한 것과 같이 좀 더 복잡한 애플리케이션을 고려할 수 있다.
다음 식별자는 이 애플리케이션을 배포하는 데 사용하는 오브젝트의 시작을 보여준다.</p><p>WordPress를 배포하는 데 다음과 같이 <code>Deployment</code> 로 시작한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>Service</code> 는 애플리케이션을 노출하기 위해 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL은 <code>StatefulSet</code> 에 MySQL의 소속과 상위 애플리케이션에 대한 메타데이터가 포함되어 노출된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>Service</code> 는 WordPress의 일부로 MySQL을 노출하는 데 이용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL <code>StatefulSet</code> 과 <code>Service</code> 로 MySQL과 WordPress가 더 큰 범위의 애플리케이션에 포함되어 있는 것을 알게 된다.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>