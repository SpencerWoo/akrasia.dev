<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/architecture/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/architecture/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/architecture/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/architecture/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/architecture/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/architecture/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/architecture/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/architecture/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/architecture/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/architecture/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/architecture/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/architecture/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>클러스터 아키텍처 | Kubernetes</title><meta property="og:title" content="클러스터 아키텍처"><meta property="og:description" content="쿠버네티스 뒤편의 구조와 설계 개념들
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/architecture/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="클러스터 아키텍처"><meta itemprop=description content="쿠버네티스 뒤편의 구조와 설계 개념들
"><meta name=twitter:card content="summary"><meta name=twitter:title content="클러스터 아키텍처"><meta name=twitter:description content="쿠버네티스 뒤편의 구조와 설계 개념들
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="쿠버네티스 뒤편의 구조와 설계 개념들
"><meta property="og:description" content="쿠버네티스 뒤편의 구조와 설계 개념들
"><meta name=twitter:description content="쿠버네티스 뒤편의 구조와 설계 개념들
"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/architecture/"><meta property="og:title" content="클러스터 아키텍처"><meta name=twitter:title content="클러스터 아키텍처"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/architecture/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/architecture/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/architecture/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/concepts/architecture/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/concepts/architecture/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/architecture/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/architecture/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/concepts/architecture/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/architecture/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/architecture/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/architecture/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/architecture/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/architecture/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/architecture/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/architecture/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/concepts/architecture/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/concepts/architecture/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>클러스터 아키텍처</h1><div class=lead>쿠버네티스 뒤편의 구조와 설계 개념들</div><ul><li>1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>노드</a></li><li>2: <a href=#pg-c0251def6da29b30afebfb04549f1703>컨트롤 플레인-노드 간 통신</a></li><li>3: <a href=#pg-ca8819042a505291540e831283da66df>컨트롤러</a></li><li>4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>클라우드 컨트롤러 매니저</a></li><li>5: <a href=#pg-44a2e2e592af0846101e970aff9243e5>가비지(Garbage) 수집</a></li><li>6: <a href=#pg-c0ea5310f52e22c5de34dc84d9ab5e0d>컨테이너 런타임 인터페이스(CRI)</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>1 - 노드</h1><p>쿠버네티스는 컨테이너를 파드내에 배치하고 <em>노드</em> 에서 실행함으로 워크로드를 구동한다.
노드는 클러스터에 따라 가상 또는 물리적 머신일 수 있다. 각 노드는
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>에
의해 관리되며
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를
실행하는 데 필요한 서비스를 포함한다.</p><p>일반적으로 클러스터에는 여러 개의 노드가 있으며, 학습 또는 리소스가 제한되는
환경에서는 하나만 있을 수도 있다.</p><p>노드의 <a href=/ko/docs/concepts/overview/components/#%EB%85%B8%EB%93%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>컴포넌트</a>에는
<a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>,
<a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>
그리고 <a class=glossary-tooltip title='kube-proxy는 클러스터의 각 노드에서 실행되는 네트워크 프록시이다.' data-toggle=tooltip data-placement=top href=/ko/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>가 포함된다.</p><h2 id=관리>관리</h2><p><a class=glossary-tooltip title='쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 서버'>API 서버</a>에 노드를 추가하는 두가지 주요 방법이 있다.</p><ol><li>노드의 kubelet으로 컨트롤 플레인에 자체 등록</li><li>사용자(또는 다른 사용자)가 노드 오브젝트를 수동으로 추가</li></ol><p>노드 <a class=glossary-tooltip title='클러스터 상태의 일부를 나타내는 쿠버네티스 시스템의 엔티티이다.' data-toggle=tooltip data-placement=top href=https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects target=_blank aria-label=오브젝트>오브젝트</a> 또는 노드의 kubelet으로 자체 등록한 후
컨트롤 플레인은 새 노드 오브젝트가 유효한지 확인한다.
예를 들어 다음 JSON 매니페스트에서 노드를 만들려는 경우이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>쿠버네티스는 내부적으로 노드 오브젝트를 생성한다(표시한다). 쿠버네티스는
kubelet이 노드의 <code>metadata.name</code> 필드와 일치하는 API 서버에 등록이 되어 있는지 확인한다.
노드가 정상이면(예를 들어 필요한 모든 서비스가 실행중인 경우) 파드를 실행할 수 있게 된다.
그렇지 않으면, 해당 노드는 정상이 될 때까지 모든 클러스터 활동에
대해 무시된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>쿠버네티스는 유효하지 않은 노드 오브젝트를 유지하고, 노드가
정상적인지 확인한다.</p><p>상태 확인을 중지하려면 사용자 또는 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>에서
노드 오브젝트를 명시적으로 삭제해야 한다.</p></div><p>노드 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><h3 id=노드-이름-고유성>노드 이름 고유성</h3><p><a href=/ko/docs/concepts/overview/working-with-objects/names#names>이름</a>은 노드를 식별한다. 두 노드는
동시에 같은 이름을 가질 수 없다. 쿠버네티스는 또한 같은 이름의 리소스가
동일한 객체라고 가정한다. 노드의 경우, 동일한 이름을 사용하는 인스턴스가 동일한
상태(예: 네트워크 설정, 루트 디스크 내용)와 노드 레이블과 같은 동일한 속성(attribute)을
갖는다고 암시적으로 가정한다. 인스턴스가
이름을 변경하지 않고 수정된 경우 이로 인해 불일치가 발생할 수 있다. 노드를 대폭 교체하거나
업데이트해야 하는 경우, 기존 노드 오브젝트를 먼저 API 서버에서 제거하고
업데이트 후 다시 추가해야 한다.</p><h3 id=노드에-대한-자체-등록-self-registration>노드에 대한 자체-등록(self-registration)</h3><p>kubelet 플래그 <code>--register-node</code>가 참(기본값)일 경우, kubelet은 API 서버에
스스로 등록을 시도할 것이다. 이는 선호되는 패턴이며, 대부분의 배포판에서 사용된다.</p><p>자체-등록에 대해, kubelet은 다음 옵션과 함께 시작된다.</p><ul><li><p><code>--kubeconfig</code> - apiserver에 스스로 인증하기 위한 자격증명에 대한 경로.</p></li><li><p><code>--cloud-provider</code> - 자신에 대한 메터데이터를 읽기 위해 어떻게
<a class=glossary-tooltip title='클라우드 컴퓨팅 플랫폼을 제공하는 조직.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-cloud-provider' target=_blank aria-label='클라우드 제공자'>클라우드 제공자</a>와 소통할지에 대한 방법.</p></li><li><p><code>--register-node</code> - 자동으로 API 서버에 등록.</p></li><li><p><code>--register-with-taints</code> - 주어진 <a class=glossary-tooltip title='세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 테인트는 파드가 노드나 노드 그룹에 스케줄링되는 것을 방지한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=테인트(taint)>테인트(taint)</a>
리스트(콤마로 분리된 <code>&lt;key>=&lt;value>:&lt;effect></code>)를 가진 노드 등록.</p><p><code>register-node</code>가 거짓이면 동작 안 함.</p></li><li><p><code>--node-ip</code> - 노드의 IP 주소.</p></li><li><p><code>--node-labels</code> - 클러스터에 노드를 등록할 때 추가 할
<a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>
(<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>에 의해 적용되는 레이블 제한 사항 참고).</p></li><li><p><code>--node-status-update-frequency</code> - 얼마나 자주 kubelet이 API 서버에 해당 노드 상태를 게시할 지 정의.</p></li></ul><p><a href=/docs/reference/access-authn-authz/node/>Node authorization mode</a>와
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>이 활성화 되면,
각 kubelet은 자신이 속한 노드의 리소스에 대해서만 생성/수정할 권한을 가진다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p><a href=#%EB%85%B8%EB%93%9C-%EC%9D%B4%EB%A6%84-%EA%B3%A0%EC%9C%A0%EC%84%B1>노드 이름 고유성</a> 섹션에서 언급했듯이,
노드 구성을 업데이트해야 하는 경우 API 서버에 노드를
다시 등록하는 것이 좋다. 예를 들어 kubelet이 <code>--node-labels</code>의 새로운 구성으로
다시 시작되더라도, 동일한 노드 이름이 사용된 경우
레이블이 해당 노드의 등록에 설정되기 때문에 변경 사항이 적용되지 않는다.</p><p>노드에 이미 스케줄된 파드는 해당 노드 구성이 kubelet 재시작에 의해 변경된 경우
오작동하거나 문제를 일으킬 수 있다. 예를 들어 이미 실행 중인 파드가 노드에
할당된 새 레이블에 대해 테인트(taint)될 수 있는 반면 해당 파드와 호환되지 않는 다른 파드는
새 레이블을 기반으로 스케줄링된다. 노드 재등록(re-registration)은 모든 파드를
비우고(drain) 다시 적절하게 스케줄링되도록
한다.</p></div><h4 id=수동-노드-관리>수동 노드 관리</h4><p><a class=glossary-tooltip title='쿠버네티스 클러스터와 통신하기 위한 커맨드라인 툴.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>을
사용해서 노드 오브젝트를 생성하고 수정할 수 있다.</p><p>노드 오브젝트를 수동으로 생성하려면 kubelet 플래그를 <code>--register-node=false</code> 로 설정한다.</p><p><code>--register-node</code> 설정과 관계 없이 노드 오브젝트를 수정할 수 있다.
예를 들어 기존 노드에 레이블을 설정하거나, 스케줄 불가로 표시할 수 있다.</p><p>파드의 노드 셀렉터와 함께 노드의 레이블을 사용해서 스케줄링을 제어할 수 있다.
예를 들어, 사용 가능한 노드의 하위 집합에서만 실행되도록
파드를 제한할 수 있다.</p><p>노드를 스케줄 불가로 표시하면 스케줄러가 해당 노드에 새 파드를 배치할 수 없지만,
노드에 있는 기존 파드에는 영향을 미치지 않는다.
이는 노드 재부팅 또는 기타 유지보수 준비 단계에서 유용하다.</p><p>노드를 스케줄 불가로 표시하려면 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</span></span></code></pre></div><p>보다 자세한 내용은 <a href=/docs/tasks/administer-cluster/safely-drain-node/>안전하게 노드를 드레인(drain)하기</a>
를 참고한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <a class=glossary-tooltip title='파드의 복제본을 클러스터 노드 집합에서 동작하게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋(DaemonSet)>데몬셋(DaemonSet)</a>에 포함되는 일부 파드는
스케줄 불가 노드에서 실행될 수 있다. 일반적으로 데몬셋은 워크로드 애플리케이션을
비우는 경우에도 노드에서 실행되어야 하는 노드 로컬 서비스를 제공한다.</div><h2 id=노드-상태>노드 상태</h2><p>노드의 상태는 다음의 정보를 포함한다.</p><ul><li><a href=#addresses>주소</a></li><li><a href=#condition>컨디션</a></li><li><a href=#capacity>용량과 할당가능</a></li><li><a href=#info>정보</a></li></ul><p><code>kubectl</code> 을 사용해서 노드 상태와 기타 세부 정보를 볼수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node &lt;insert-node-name-here&gt;
</span></span></code></pre></div><p>출력되는 각 섹션은 아래에 설명되어 있다.</p><h3 id=addresses>주소</h3><p>이 필드의 용법은 클라우드 제공사업자 또는 베어메탈 구성에 따라 다양하다.</p><ul><li>HostName: 노드의 커널에 의해 알려진 호스트명이다.
<code>--hostname-override</code> 파라미터를 통해 치환될 수 있다.</li><li>ExternalIP: 일반적으로 노드의 IP 주소는 외부로 라우트 가능
(클러스터 외부에서 이용 가능) 하다 .</li><li>InternalIP: 일반적으로 노드의 IP 주소는 클러스터 내에서만 라우트 가능하다.</li></ul><h3 id=condition>컨디션</h3><p><code>conditions</code> 필드는 모든 <code>Running</code> 노드의 상태를 기술한다. 컨디션의 예로 다음을 포함한다.</p><table><caption style=display:none>노드 컨디션과 각 컨디션이 적용되는 시기에 대한 설명들이다.</caption><thead><tr><th>노드 컨디션</th><th>설명</th></tr></thead><tbody><tr><td><code>Ready</code></td><td>노드가 상태 양호하며 파드를 수용할 준비가 되어 있는 경우 <code>True</code>, 노드의 상태가 불량하여 파드를 수용하지 못할 경우 <code>False</code>, 그리고 노드 컨트롤러가 마지막 <code>node-monitor-grace-period</code> (기본값 40 기간 동안 노드로부터 응답을 받지 못한 경우) <code>Unknown</code></td></tr><tr><td><code>DiskPressure</code></td><td>디스크 사이즈 상에 압박이 있는 경우, 즉 디스크 용량이 넉넉치 않은 경우 <code>True</code>, 반대의 경우 <code>False</code></td></tr><tr><td><code>MemoryPressure</code></td><td>노드 메모리 상에 압박이 있는 경우, 즉 노드 메모리가 넉넉치 않은 경우 <code>True</code>, 반대의 경우 <code>False</code></td></tr><tr><td><code>PIDPressure</code></td><td>프로세스 상에 압박이 있는 경우, 즉 노드 상에 많은 프로세스들이 존재하는 경우 <code>True</code>, 반대의 경우 <code>False</code></td></tr><tr><td><code>NetworkUnavailable</code></td><td>노드에 대해 네트워크가 올바르게 구성되지 않은 경우 <code>True</code>, 반대의 경우 <code>False</code></td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 커맨드 라인 도구를 사용해서 통제된(cordoned) 노드의 세부 정보를 출력하는 경우 조건에는
<code>SchedulingDisabled</code> 이 포함된다. <code>SchedulingDisabled</code> 은 쿠버네티스 API의 조건이 아니며,
대신 통제된(cordoned) 노드는 사양에 스케줄 불가로 표시된다.</div><p>쿠버네티스 API에서, 노드의 컨디션은 노드 리소스의 <code>.status</code> 부분에
표현된다. 예를 들어, 다음의 JSON 구조는 상태가 양호한 노드를 나타낸다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>ready 컨디션의 <code>status</code>가 <code>pod-eviction-timeout</code>
(<a class=glossary-tooltip title='컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>에 전달된 인수)보다 더 길게 <code>Unknown</code> 또는 <code>False</code>로 유지되는 경우,
<a href=#node-controller>노드 컨트롤러</a>가 해당 노드에 할당된 전체 파드에 대해
<a class=glossary-tooltip title='API를 이용한 축출은 축출 API를 사용하여 파드의 정상 종료를 트리거하는 축출 오브젝트를 만드는 프로세스이다' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/api-eviction/ target=_blank aria-label='API를 이용한 축출'>API를 이용한 축출</a>
을 트리거한다. 기본 축출 타임아웃 기간은
<strong>5분</strong> 이다.
노드에 접근이 불가할 때와 같은 경우, API 서버는 노드 상의 kubelet과 통신이 불가하다.
API 서버와의 통신이 재개될 때까지 파드 삭제에 대한 결정은 kubelet에 전해질 수 없다.
그 사이, 삭제되도록 스케줄 되어진 파드는 분할된 노드 상에서 계속 동작할 수도 있다.</p><p>노드 컨트롤러가 클러스터 내 동작 중지된 것을 확신할 때까지는 파드를 강제로 삭제하지 않는다.
파드가 <code>Terminating</code> 또는 <code>Unknown</code> 상태로 있을 때 접근 불가한 노드 상에서
동작되고 있는 것을 보게 될 수도 있다. 노드가 영구적으로 클러스터에서 삭제되었는지에
대한 여부를 쿠버네티스가 기반 인프라로부터 유추할 수 없는 경우, 노드가 클러스터를 영구적으로
탈퇴하게 되면, 클러스터 관리자는 손수 노드 오브젝트를 삭제해야 할 수도 있다.
쿠버네티스에서 노드 오브젝트를 삭제하면
노드 상에서 동작 중인 모든 파드 오브젝트가 API 서버로부터 삭제되며
파드가 사용하던 이름을 다시 사용할 수 있게 된다.</p><p>노드에서 문제가 발생하면, 쿠버네티스 컨트롤 플레인은 자동으로 노드 상태에 영향을 주는 조건과 일치하는
<a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트(taints)</a>를
생성한다.
스케줄러는 파드를 노드에 할당할 때 노드의 테인트를 고려한다.
또한 파드는 노드에 특정 테인트가 있더라도 해당 노드에서 동작하도록
<a class=glossary-tooltip title='세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 톨러레이션은 매칭되는 테인트(taint)를 가진 노드나 노드 그룹에 파드가 스케줄링되는 것을 활성화한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=톨러레이션(toleration)>톨러레이션(toleration)</a>을 가질 수 있다.</p><p>자세한 내용은
<a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/#%EC%BB%A8%EB%94%94%EC%85%98%EB%B3%84-%EB%85%B8%EB%93%9C-%ED%85%8C%EC%9D%B8%ED%8A%B8%ED%95%98%EA%B8%B0>컨디션별 노드 테인트하기</a>를 참조한다.</p><h3 id=capacity>용량과 할당가능</h3><p>노드 상에 사용 가능한 리소스를 나타낸다. 리소스에는 CPU, 메모리 그리고
노드 상으로 스케줄 되어질 수 있는 최대 파드 수가 있다.</p><p>용량 블록의 필드는 노드에 있는 리소스의 총량을 나타낸다.
할당가능 블록은 일반 파드에서 사용할 수 있는
노드의 리소스 양을 나타낸다.</p><p>노드에서
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>컴퓨팅 리소스 예약</a>하는 방법을
배우는 동안 용량 및 할당가능 리소스에 대해 자세히 읽어보자.</p><h3 id=정보>정보</h3><p>커널 버전, 쿠버네티스 버전 (kubelet과 kube-proxy 버전), 컨테이너
런타임 상세 정보 및 노드가 사용하는 운영 체제가 무엇인지와 같은
노드에 대한 일반적인 정보가 기술된다.
이 정보는 Kubelet이 노드에서 수집하여
쿠버네티스 API로 전송한다.</p><h2 id=하트비트>하트비트</h2><p>쿠버네티스 노드가 보내는 하트비트는 클러스터가 개별 노드가 가용한지를
판단할 수 있도록 도움을 주고, 장애가 발견된 경우 조치를 할 수 있게한다.</p><p>노드에는 두 가지 형태의 하트비트가 있다.</p><ul><li>노드의 <code>.status</code>에 대한 업데이트</li><li><code>kube-node-lease</code>
<a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>
내의 <a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>리스(Lease)</a>
오브젝트. 각 노드는 연관된 리스 오브젝트를 갖는다.</li></ul><p>노드의 <code>.status</code>에 비하면, 리스는 경량의 리소스이다.
큰 규모의 클러스터에서는 리스를 하트비트에 사용하여
업데이트로 인한 성능 영향을 줄일 수 있다.</p><p>kubelet은 노드의 <code>.status</code> 생성과 업데이트 및
관련된 리스의 업데이트를 담당한다.</p><ul><li>kubelet은 상태가 변경되거나 설정된 인터벌보다 오래 업데이트가 없는 경우
노드의 <code>.status</code>를 업데이트한다. 노드의 <code>.status</code> 업데이트에 대한 기본
인터벌은 접근이 불가능한 노드에 대한 타임아웃인
40초 보다 훨씬 긴 5분이다.</li><li>kubelet은 리스 오브젝트를 (기본 업데이트 인터벌인) 매 10초마다
생성하고 업데이트한다. 리스 업데이트는 노드의 <code>.status</code> 업데이트와는 독립적이다.
만약 리스 업데이트가 실패하면, kubelet은 200밀리초에서 시작하고
7초의 상한을 갖는 지수적 백오프를 사용해서 재시도한다.</li></ul><h3 id=노드-컨트롤러>노드 컨트롤러</h3><p>노드 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는
노드의 다양한 측면을 관리하는 쿠버네티스 컨트롤 플레인 컴포넌트이다.</p><p>노드 컨트롤러는 노드가 생성되어 유지되는 동안 다양한 역할을 한다. 첫째는 등록 시점에
(CIDR 할당이 사용토록 설정된 경우) 노드에 CIDR 블럭을 할당하는 것이다.</p><p>두 번째는 노드 컨트롤러의 내부 노드 리스트를 클라우드 제공사업자의
사용 가능한 머신 리스트 정보를 근거로 최신상태로 유지하는 것이다. 클라우드 환경에서
동작 중일 경우, 노드상태가 불량할 때마다, 노드 컨트롤러는
해당 노드용 VM이 여전히 사용 가능한지에 대해 클라우드 제공사업자에게 묻는다. 사용 가능하지 않을 경우,
노드 컨트롤러는 노드 리스트로부터 그 노드를 삭제한다.</p><p>세 번째는 노드의 동작 상태를 모니터링하는 것이다. 노드 컨트롤러는
다음을 담당한다.</p><ul><li>노드가 접근 불가능(unreachable) 상태가 되는 경우,
노드의 <code>.status</code> 필드의 <code>Ready</code> 컨디션을 업데이트한다.
이 경우에는 노드 컨트롤러가 <code>Ready</code> 컨디션을 <code>Unknown</code>으로 설정한다.</li><li>노드가 계속 접근 불가능 상태로 남아있는 경우, 해당 노드의 모든 파드에 대해서
<a href=/ko/docs/concepts/scheduling-eviction/api-eviction/>API를 이용한 축출</a>을
트리거한다. 기본적으로, 노드 컨트롤러는 노드를
<code>Unknown</code>으로 마킹한 뒤 5분을 기다렸다가
최초의 축출 요청을 시작한다.</li></ul><p>기본적으로, 노드 컨트롤러는 5 초마다 각 노드의 상태를 체크한다.
체크 주기는 <code>kube-controller-manager</code> 구성 요소의
<code>--node-monitor-period</code> 플래그를 이용하여 설정할 수 있다.</p><h4 id=축출-빈도-제한>축출 빈도 제한</h4><p>대부분의 경우, 노드 컨트롤러는 초당 <code>--node-eviction-rate</code>(기본값 0.1)로
축출 속도를 제한한다. 이 말은 10초당 1개의 노드를 초과하여
파드 축출을 하지 않는다는 의미가 된다.</p><p>노드 축출 행위는 주어진 가용성 영역 내 하나의 노드가 상태가 불량할
경우 변화한다. 노드 컨트롤러는 영역 내 동시에 상태가 불량한 노드의 퍼센티지가 얼마나 되는지
체크한다(<code>Ready</code> 컨디션은 <code>Unknown</code> 또는
<code>False</code> 값을 가진다).</p><ul><li>상태가 불량한 노드의 비율이 최소 <code>--unhealthy-zone-threshold</code>
(기본값 0.55)가 되면 축출 속도가 감소한다.</li><li>클러스터가 작으면 (즉 <code>--large-cluster-size-threshold</code>
노드 이하면 - 기본값 50) 축출이 중지된다.</li><li>이외의 경우, 축출 속도는 초당
<code>--secondary-node-eviction-rate</code>(기본값 0.01)로 감소된다.</li></ul><p>이 정책들이 가용성 영역 단위로 실행되어지는 이유는 나머지가 연결되어 있는 동안
하나의 가용성 영역이 컨트롤 플레인으로부터 분할되어 질 수도 있기 때문이다.
만약 클러스터가 여러 클라우드 제공사업자의 가용성 영역에 걸쳐 있지 않는 이상,
축출 매커니즘은 영역 별 가용성을 고려하지 않는다.</p><p>노드가 가용성 영역들에 걸쳐 퍼져 있는 주된 이유는 하나의 전체 영역이
장애가 발생할 경우 워크로드가 상태 양호한 영역으로 이전되어질 수 있도록 하기 위해서이다.
그러므로, 하나의 영역 내 모든 노드들이 상태가 불량하면 노드 컨트롤러는
<code>--node-eviction-rate</code> 의 정상 속도로 축출한다. 코너 케이스란 모든 영역이
완전히 상태불량(클러스터 내 양호한 노드가 없는 경우)한 경우이다.
이러한 경우, 노드 컨트롤러는 컨트롤 플레인과 노드 간 연결에 문제가
있는 것으로 간주하고 축출을 실행하지 않는다. (중단 이후 일부 노드가
다시 보이는 경우 노드 컨트롤러는 상태가 양호하지 않거나 접근이 불가능한
나머지 노드에서 파드를 축출한다.)</p><p>또한, 노드 컨트롤러는 파드가 테인트를 허용하지 않을 때 <code>NoExecute</code> 테인트 상태의
노드에서 동작하는 파드에 대한 축출 책임을 가지고 있다.
추가로, 노드 컨틀로러는 연결할 수 없거나, 준비되지 않은 노드와 같은 노드 문제에 상응하는
<a class=glossary-tooltip title='세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 테인트는 파드가 노드나 노드 그룹에 스케줄링되는 것을 방지한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=테인트>테인트</a>를 추가한다.
이는 스케줄러가 비정상적인 노드에 파드를 배치하지 않게 된다.</p><h2 id=node-capacity>리소스 용량 추적</h2><p>노드 오브젝트는 노드 리소스 용량에 대한 정보: 예를 들어, 사용 가능한 메모리의
양과 CPU의 수를 추적한다.
노드의 <a href=#%EB%85%B8%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9E%90%EC%B2%B4-%EB%93%B1%EB%A1%9D>자체 등록</a>은 등록하는 중에 용량을 보고한다.
<a href=#%EC%88%98%EB%8F%99-%EB%85%B8%EB%93%9C-%EA%B4%80%EB%A6%AC>수동</a>으로 노드를 추가하는 경우 추가할 때
노드의 용량 정보를 설정해야 한다.</p><p>쿠버네티스 <a class=glossary-tooltip title='노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=스케줄러>스케줄러</a>는
노드 상에 모든 노드에 대해 충분한 리소스가 존재하도록 보장한다. 스케줄러는 노드 상에
컨테이너에 대한 요청의 합이 노드 용량보다 더 크지 않도록 체크한다.
요청의 합은 kubelet에서 관리하는 모든 컨테이너를 포함하지만, 컨테이너 런타임에
의해 직접적으로 시작된 컨 테이너는 제외되고 kubelet의 컨트롤 범위
밖에서 실행되는 모든 프로세스도 제외된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드 형태가 아닌 프로세스에 대해 명시적으로 리소스를 확보하려면,
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>시스템 데몬에 사용할 리소스 예약하기</a>을 본다.</div><h2 id=노드-토폴로지>노드 토폴로지</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [beta]</code></div><p><code>TopologyManager</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트(feature gate)</a>를
활성화 시켜두면, kubelet이 리소스 할당 결정을 할 때 토폴로지 힌트를 사용할 수 있다.
자세한 내용은
<a href=/docs/tasks/administer-cluster/topology-manager/>노드의 컨트롤 토폴로지 관리 정책</a>을 본다.</p><h2 id=graceful-node-shutdown>그레이스풀(Graceful) 노드 셧다운(shutdown)</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [beta]</code></div><p>kubelet은 노드 시스템 셧다운을 감지하고 노드에서 실행 중인 파드를 종료하려고 시도한다.</p><p>Kubelet은 노드가 종료되는 동안 파드가
일반 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>파드 종료 프로세스</a>를
따르도록 한다.</p><p>그레이스풀 노드 셧다운 기능은
<a href=https://www.freedesktop.org/wiki/Software/systemd/inhibit/>systemd inhibitor locks</a>를
사용하여 주어진 기간 동안 노드 종료를 지연시키므로 systemd에 의존한다.</p><p>그레이스풀 노드 셧다운은 1.21에서 기본적으로 활성화된 <code>GracefulNodeShutdown</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>로
제어된다.</p><p>기본적으로, 아래 설명된 두 구성 옵션,
<code>shutdownGracePeriod</code> 및 <code>shutdownGracePeriodCriticalPods</code> 는 모두 0으로 설정되어 있으므로,
그레이스풀 노드 셧다운 기능이 활성화되지 않는다.
기능을 활성화하려면, 두 개의 kubelet 구성 설정을 적절하게 구성하고
0이 아닌 값으로 설정해야 한다.</p><p>그레이스풀 셧다운 중에 kubelet은 다음의 두 단계로 파드를 종료한다.</p><ol><li>노드에서 실행 중인 일반 파드를 종료시킨다.</li><li>노드에서 실행 중인
<a href=/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0>중요(critical) 파드</a>를 종료시킨다.</li></ol><p>그레이스풀 노드 셧다운 기능은
두 개의 <a href=/docs/tasks/administer-cluster/kubelet-config-file/><code>KubeletConfiguration</code></a> 옵션으로 구성된다.</p><ul><li><code>shutdownGracePeriod</code>:<ul><li>노드가 종료를 지연해야 하는 총 기간을 지정한다.
이것은 모든 일반 및 <a href=/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0>중요 파드</a>의
파드 종료에 필요한 총 유예 기간에 해당한다.</li></ul></li><li><code>shutdownGracePeriodCriticalPods</code>:<ul><li>노드 종료 중에 <a href=/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0>중요 파드</a>를
종료하는 데 사용되는 기간을 지정한다.
이 값은 <code>shutdownGracePeriod</code> 보다 작아야 한다.</li></ul></li></ul><p>예를 들어, <code>shutdownGracePeriod=30s</code>,
<code>shutdownGracePeriodCriticalPods=10s</code> 인 경우, kubelet은 노드 종료를 30초까지
지연시킨다. 종료하는 동안 처음 20(30-10)초는 일반 파드의
유예 종료에 할당되고, 마지막 10초는
<a href=/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0>중요 파드</a>의 종료에 할당된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>그레이스풀 노드 셧다운 과정에서 축출된 파드는 셧다운(shutdown)된 것으로 표시된다.
<code>kubectl get pods</code> 명령을 실행하면 축출된 파드의 상태가 <code>Terminated</code>으로 표시된다.
그리고 <code>kubectl describe pod</code> 명령을 실행하면 노드 셧다운으로 인해 파드가 축출되었음을 알 수 있다.</p><pre tabindex=0><code>Reason:         Terminated
Message:        Pod was terminated in response to imminent node shutdown.
</code></pre></div><h2 id=non-graceful-node-shutdown>논 그레이스풀 노드 셧다운</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [alpha]</code></div><p>전달한 명령이 kubelet에서 사용하는 금지 잠금 메커니즘(inhibitor locks mechanism)을 트리거하지 않거나,
또는 사용자 오류(예: ShutdownGracePeriod 및 ShutdownGracePeriodCriticalPods가 제대로 설정되지 않음)로 인해
kubelet의 노드 셧다운 관리자(Node Shutdown Mananger)가
노드 셧다운 액션을 감지하지 못할 수 있다.
자세한 내용은 위의 <a href=#graceful-node-shutdown>그레이스풀 노드 셧다운</a> 섹션을 참조한다.</p><p>노드가 셧다운되었지만 kubelet의 노드 셧다운 관리자가 이를 감지하지 못하면,
스테이트풀셋에 속한 파드는 셧다운된 노드에 '종료 중(terminating)' 상태로 고착되어
다른 동작 중인 노드로 이전될 수 없다.
이는 셧다운된 노드의 kubelet이 파드를 지울 수 없어서
결국 스테이트풀셋이 동일한 이름으로 새 파드를 만들 수 없기 때문이다.
만약 파드가 사용하던 볼륨이 있다면,
볼륨어태치먼트(VolumeAttachment)도 기존의 셧다운된 노드에서 삭제되지 않아
결국 파드가 사용하던 볼륨이 다른 동작 중인 노드에 연결(attach)될 수 없다.
결과적으로, 스테이트풀셋에서 실행되는 애플리케이션이 제대로 작동하지 않는다.
기존의 셧다운된 노드가 정상으로 돌아오지 못하면,
이러한 파드는 셧다운된 노드에 '종료 중(terminating)' 상태로 영원히 고착될 것이다.</p><p>위와 같은 상황을 완화하기 위해, 사용자가 <code>node.kubernetes.io/out-of-service</code> 테인트를 <code>NoExecute</code> 또는 <code>NoSchedule</code> 값으로
추가하여 노드를 서비스 불가(out-of-service) 상태로 표시할 수 있다.
<code>kube-controller-manager</code>에 <code>NodeOutOfServiceVolumeDetach</code><a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>
가 활성화되어 있고, 노드가 이 테인트에 의해 서비스 불가 상태로 표시되어 있는 경우,
노드에 매치되는 톨러레이션이 없다면 노드 상의 파드는 강제로 삭제될 것이고,
노드 상에서 종료되는 파드에 대한 볼륨 해제(detach) 작업은 즉시 수행될 것이다.
이를 통해 서비스 불가 상태 노드의 파드가 빠르게 다른 노드에서 복구될 수 있다.</p><p>논 그레이스풀 셧다운 과정 동안, 파드는 다음의 두 단계로 종료된다.</p><ol><li>매치되는 <code>out-of-service</code> 톨러레이션이 없는 파드를 강제로 삭제한다.</li><li>이러한 파드에 대한 볼륨 해제 작업을 즉시 수행한다.</li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong><ul><li><code>node.kubernetes.io/out-of-service</code> 테인트를 추가하기 전에,
노드가 완전한 셧다운 또는 전원 꺼짐 상태에 있는지
(재시작 중인 것은 아닌지) 확인한다.</li><li>사용자가 서비스 불가 상태 테인트를 직접 추가한 것이기 때문에,
파드가 다른 노드로 옮겨졌고 셧다운 상태였던 노드가 복구된 것을 확인했다면
사용자가 서비스 불가 상태 테인트를 수동으로 제거해야 한다.</li></ul></div><h3 id=pod-priority-graceful-node-shutdown>파드 우선순위 기반 그레이스풀 노드 셧다운</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [alpha]</code></div><p>그레이스풀 노드 셧다운 시 파드 셧다운 순서에 더 많은 유연성을 제공할 수 있도록,
클러스터에 프라이어리티클래스(PriorityClass) 기능이 활성화되어 있으면
그레이스풀 노드 셧다운 과정에서 파드의 프라이어리티클래스가 고려된다.
이 기능으로 그레이스풀 노드 셧다운 시 파드가 종료되는 순서를 클러스터 관리자가
<a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/#%ED%94%84%EB%9D%BC%EC%9D%B4%EC%96%B4%EB%A6%AC%ED%8B%B0%ED%81%B4%EB%9E%98%EC%8A%A4>프라이어리티 클래스</a>
기반으로 명시적으로 정할 수 있다.</p><p>위에서 기술된 것처럼, <a href=#graceful-node-shutdown>그레이스풀 노드 셧다운</a> 기능은 파드를
중요하지 않은(non-critical) 파드와
중요한(critical) 파드 2단계(phase)로 구분하여 종료시킨다.
셧다운 시 파드가 종료되는 순서를 명시적으로 더 상세하게 정해야 한다면,
파드 우선순위 기반 그레이스풀 노드 셧다운을 사용할 수 있다.</p><p>그레이스풀 노드 셧다운 과정에서 파드 우선순위가 고려되기 때문에,
그레이스풀 노드 셧다운이 여러 단계로 일어날 수 있으며,
각 단계에서 특정 프라이어리티 클래스의 파드를 종료시킨다.
정확한 단계와 단계별 셧다운 시간은 kubelet에 설정할 수 있다.</p><p>다음과 같이 클러스터에 커스텀 파드
<a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/#%ED%94%84%EB%9D%BC%EC%9D%B4%EC%96%B4%EB%A6%AC%ED%8B%B0%ED%81%B4%EB%9E%98%EC%8A%A4>프라이어리티 클래스</a>가 있다고
가정하자.</p><table><thead><tr><th>파드 프라이어리티 클래스 이름</th><th>파드 프라이어리티 클래스 값</th></tr></thead><tbody><tr><td><code>custom-class-a</code></td><td>100000</td></tr><tr><td><code>custom-class-b</code></td><td>10000</td></tr><tr><td><code>custom-class-c</code></td><td>1000</td></tr><tr><td><code>regular/unset</code></td><td>0</td></tr></tbody></table><p><a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>kubelet 환경 설정</a> 안의
<code>shutdownGracePeriodByPodPriority</code> 설정은 다음과 같을 수 있다.</p><table><thead><tr><th>파드 프라이어리티 클래스 값</th><th>종료 대기 시간</th></tr></thead><tbody><tr><td>100000</td><td>10 seconds</td></tr><tr><td>10000</td><td>180 seconds</td></tr><tr><td>1000</td><td>120 seconds</td></tr><tr><td>0</td><td>60 seconds</td></tr></tbody></table><p>이를 나타내는 kubelet 환경 설정 YAML은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>shutdownGracePeriodByPodPriority</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>100000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>10000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>180</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>120</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>위의 표에 의하면 <code>priority</code> 값이 100000 이상인 파드는 종료까지 10초만 주어지며,
10000 이상 ~ 100000 미만이면 180초,
1000 이상 ~ 10000 미만이면 120초가 주어진다.
마지막으로, 다른 모든 파드는 종료까지 60초가 주어질 것이다.</p><p>모든 클래스에 대해 값을 명시할 필요는 없다.
예를 들어, 대신 다음과 같은 구성을 사용할 수도 있다.</p><table><thead><tr><th>파드 프라이어리티 클래스 값</th><th>종료 대기 시간</th></tr></thead><tbody><tr><td>100000</td><td>300 seconds</td></tr><tr><td>1000</td><td>120 seconds</td></tr><tr><td>0</td><td>60 seconds</td></tr></tbody></table><p>위의 경우, <code>custom-class-b</code>에 속하는 파드와 <code>custom-class-c</code>에 속하는 파드는
동일한 종료 대기 시간을 갖게 될 것이다.</p><p>특정 범위에 해당되는 파드가 없으면,
kubelet은 해당 범위에 해당되는 파드를 위해 기다려 주지 않는다.
대신, kubelet은 즉시 다음 프라이어리티 클래스 값 범위로 넘어간다.</p><p>기능이 활성화되어 있지만 환경 설정이 되어 있지 않으면,
순서 지정 동작이 수행되지 않을 것이다.</p><p>이 기능을 사용하려면 <code>GracefulNodeShutdownBasedOnPodPriority</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 하고,
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>kubelet config</a>의
<code>ShutdownGracePeriodByPodPriority</code>를
파드 프라이어리티 클래스 값과 각 값에 대한 종료 대기 시간을 명시하여
지정해야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 그레이스풀 노드 셧다운 과정에서 파드 프라이어리티를 고려하는 기능은
쿠버네티스 v1.23에서 알파 기능으로 도입되었다.
쿠버네티스 1.25에서 이 기능은 베타 상태이며 기본적으로 활성화되어 있다.</div><p><code>graceful_shutdown_start_time_seconds</code> 및 <code>graceful_shutdown_end_time_seconds</code> 메트릭은
노드 셧다운을 모니터링하기 위해 kubelet 서브시스템에서 방출된다.</p><h2 id=swap-memory>스왑(swap) 메모리 관리</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.22 [alpha]</code></div><p>쿠버네티스 1.22 이전에는 노드가 스왑 메모리를 지원하지 않았다. 그리고
kubelet은 노드에서 스왑을 발견하지 못한 경우 시작과 동시에 실패하도록 되어 있었다.
1.22부터는 스왑 메모리 지원을 노드 단위로 활성화할 수 있다.</p><p>노드에서 스왑을 활성화하려면, <code>NodeSwap</code> 기능 게이트가 kubelet에서
활성화되어야 하며, 명령줄 플래그 <code>--fail-swap-on</code> 또는
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>구성 설정</a>에서 <code>failSwapOn</code>가
false로 지정되어야 한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 메모리 스왑 기능이 활성화되면, 시크릿 오브젝트의 내용과 같은
tmpfs에 기록되었던 쿠버네티스 데이터가 디스크에 스왑될 수 있다.</div><p>사용자는 또한 선택적으로 <code>memorySwap.swapBehavior</code>를 구성할 수 있으며,
이를 통해 노드가 스왑 메모리를 사용하는 방식을 명시한다. 예를 들면,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>memorySwap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>swapBehavior</span>:<span style=color:#bbb> </span>LimitedSwap<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>swapBehavior</code>에 가용한 구성 옵션은 다음과 같다.</p><ul><li><code>LimitedSwap</code>: 쿠버네티스 워크로드는 스왑을 사용할 수 있는 만큼으로
제한된다. 쿠버네티스에 의해 관리되지 않는 노드의 워크로드는 여전히 스왑될 수 있다.</li><li><code>UnlimitedSwap</code>: 쿠버네티스 워크로드는 요청한 만큼 스왑 메모리를 사용할 수 있으며,
시스템의 최대치까지 사용 가능하다.</li></ul><p>만약 <code>memorySwap</code> 구성이 명시되지 않았고 기능 게이트가 활성화되어 있다면,
kubelet은 <code>LimitedSwap</code> 설정과 같은 행동을
기본적으로 적용한다.</p><p><code>LimitedSwap</code> 설정에 대한 행동은 노드가 ("cgroups"으로 알려진)
제어 그룹이 v1 또는 v2 중에서 무엇으로 동작하는가에 따라서 결정된다.</p><ul><li><strong>cgroupsv1:</strong> 쿠버네티스 워크로드는 메모리와 스왑의 조합을 사용할 수 있다.
파드의 메모리 제한이 설정되어 있다면 가용 상한이 된다.</li><li><strong>cgroupsv2:</strong> 쿠버네티스 워크로드는 스왑 메모리를 사용할 수 없다.</li></ul><p>테스트를 지원하고 피드벡을 제공하기 위한 정보는
<a href=https://github.com/kubernetes/enhancements/issues/2400>KEP-2400</a> 및
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md>디자인 제안</a>에서 찾을 수 있다.</p><h2 id=다음-내용>다음 내용</h2><ul><li>노드를 구성하는 <a href=/ko/docs/concepts/overview/components/#%EB%85%B8%EB%93%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>컴포넌트</a>에 대해 알아본다.</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>노드에 대한 API 정의</a>를 읽어본다.</li><li>아키텍처 디자인 문서의 <a href=https://git.k8s.io/design-proposals-archive/architecture/architecture.md#the-kubernetes-node>노드</a>
섹션을 읽어본다.</li><li><a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트와 톨러레이션</a>을 읽어본다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>2 - 컨트롤 플레인-노드 간 통신</h1><p>이 문서는 API 서버와 쿠버네티스 클러스터 사이에 대한 통신 경로의 목록을 작성한다.
이는 사용자가 신뢰할 수 없는 네트워크(또는 클라우드 공급자의 완전한 퍼블릭 IP)에서
클러스터를 실행할 수 있도록 네트워크 구성을 강화하기 위한 맞춤 설치를 할 수 있도록 한다.</p><h2 id=노드에서-컨트롤-플레인으로의-통신>노드에서 컨트롤 플레인으로의 통신</h2><p>쿠버네티스에는 "허브 앤 스포크(hub-and-spoke)" API 패턴을 가지고 있다. 노드(또는 노드에서 실행되는 파드들)의
모든 API 사용은 API 서버에서 종료된다. 다른 컨트롤 플레인 컴포넌트 중 어느 것도 원격 서비스를 노출하도록
설계되지 않았다. API 서버는 하나 이상의 클라이언트
<a href=/docs/reference/access-authn-authz/authentication/>인증</a> 형식이 활성화된
보안 HTTPS 포트(일반적으로 443)에서 원격 연결을 수신하도록 구성된다.
특히 <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>익명의 요청</a>
또는<a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>서비스 어카운트 토큰</a>이 허용되는 경우,
하나 이상의 <a href=/ko/docs/reference/access-authn-authz/authorization/>권한 부여</a> 형식을
사용해야 한다.</p><p>노드는 유효한 클라이언트 자격 증명과 함께 API 서버에 안전하게 연결할 수 있도록
클러스터에 대한 공개 루트 인증서(root certificate)로 프로비전해야 한다. 클라이언트 인증서(client certificate) 형식으로
kubelet의 클라이언트 자격 증명을 사용하는 것은 좋은 방법이다.
kubelet 클라이언트 인증서(client certificate)의 자동 프로비저닝은
<a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>kubelet TLS 부트스트랩</a>을 참고한다.</p><p>API 서버에 연결하려는 파드는 서비스 어카운트를 활용하여 안전하게
쿠버네티스가 공개 루트 인증서(root certificate)와 유효한 베어러 토큰(bearer token)을 파드가 인스턴스화될 때
파드에 자동으로 주입할 수 있다.
<code>kubernetes</code> 서비스(<code>default</code> 네임스페이스의)는 API 서버의 HTTPS 엔드포인트로 리디렉션되는
가상 IP 주소(kube-proxy를 통해)로 구성되어 있다.</p><p>컨트롤 플레인 컴포넌트는 보안 포트를 통해 클러스터 API 서버와도 통신한다.</p><p>결과적으로, 노드 및 노드에서 실행되는 파드에서 컨트롤 플레인으로 연결하기 위한
기본 작동 모드는 기본적으로 보호되며
신뢰할 수 없는 네트워크 및/또는 공용 네트워크에서 실행될 수 있다.</p><h2 id=컨트롤-플레인에서-노드로의-통신>컨트롤 플레인에서 노드로의 통신</h2><p>컨트롤 플레인(API 서버)에서 노드로는 두 가지 기본 통신 경로가 있다.
첫 번째는 API 서버에서 클러스터의 각 노드에서 실행되는 kubelet 프로세스이다.
두 번째는 API 서버의 <em>프록시</em> 기능을 통해 API 서버에서 모든 노드, 파드 또는 서비스에
이르는 것이다.</p><h3 id=api-서버에서-kubelet으로의-통신>API 서버에서 kubelet으로의 통신</h3><p>API 서버에서 kubelet으로의 연결은 다음의 용도로 사용된다.</p><ul><li>파드에 대한 로그를 가져온다.</li><li>실행 중인 파드에 (보통의 경우 kubectl을 통해) 연결한다.</li><li>kubelet의 포트-포워딩 기능을 제공한다.</li></ul><p>위와 같은 연결은 kubelet의 HTTPS 엔드포인트에서 종료된다. 기본적으로, API 서버는 kubelet의
제공(serving) 인증서를 확인하지 않는다. 이는 연결이 중간자 공격(man-in-the-middle)에 시달리게 하며,
신뢰할 수 없는 네트워크 및/또는 공용 네트워크에서 실행하기에 <strong>안전하지 않다</strong> .</p><p>이 연결을 확인하려면, <code>--kubelet-certificate-authority</code> 플래그를 사용하여
API 서버에 kubelet의 제공(serving) 인증서를 확인하는데 사용할 루트 인증서 번들을 제공한다.</p><p>이것이 가능하지 않은 경우, 신뢰할 수 없는 네트워크 또는 공용 네트워크를 통한 연결을 피하기 위해
필요한 경우, API 서버와 kubelet 간 <a href=#ssh-%ED%84%B0%EB%84%90>SSH 터널링</a>을
사용한다.</p><p>마지막으로, kubelet API를 보호하려면
<a href=/ko/docs/reference/access-authn-authz/kubelet-authn-authz/>Kubelet 인증 및/또는 인가</a>를 활성화해야 한다.</p><h3 id=api-서버에서-노드-파드-및-서비스로의-통신>API 서버에서 노드, 파드 및 서비스로의 통신</h3><p>API 서버에서 노드, 파드 또는 서비스로의 연결은 기본적으로 일반 HTTP 연결로 연결되므로
인증되거나 암호화되지 않는다. 이 연결에서 URL을 노드, 파드 또는 서비스 이름에 접두어 <code>https:</code> 을 붙여
보안 HTTPS 연결이 되도록 실행할 수 있지만, HTTPS 엔드포인트가 제공한 인증서의 유효성을 검증하지 않으며
클라이언트 자격 증명도 제공하지 않는다.
그래서 연결이 암호화되는 동안 그 어떤 무결성도 보장되지 않는다.
이러한 연결은 신뢰할 수 없는 네트워크 및/또는 공용 네트워크에서 실행하기에 <strong>현재는 안전하지 않다</strong> .</p><h3 id=ssh-터널>SSH 터널</h3><p>쿠버네티스는 SSH 터널을 지원하여 컨트롤 플레인에서 노드로의 통신 경로를 보호한다.
이 구성에서, API 서버는 클러스터의 각 노드에 SSH 터널을 시작하고
(포트 22에서 수신 대기하는 ssh 서버에 연결) 터널을 통해
kubelet, 노드, 파드 또는 서비스로 향하는 모든 트래픽을 전달한다.
이 터널은 노드가 실행 중인 네트워크의 외부로 트래픽이
노출되지 않도록 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>SSH 터널은 현재 더 이상 사용되지 않으므로, 수행 중인 작업이 어떤 것인지 모른다면 사용하면 안 된다.
<a href=#konnectivity-service>Konnectivity 서비스</a>가 SSH 통신 채널을
대체한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><h3 id=konnectivity-service>Konnectivity 서비스</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [beta]</code></div><p>SSH 터널을 대체로, Konnectivity 서비스는 컨트롤 플레인과 클러스터 간 통신에 TCP 레벨 프록시를 제공한다.
Konnectivity 서비스는 컨트롤 플레인 네트워크의 Konnectivity 서버와
노드 네트워크의 Konnectivity 에이전트, 두 부분으로 구성된다.
Konnectivity 에이전트는 Konnectivity 서버에 대한 연결을 시작하고
네트워크 연결을 유지한다.
Konnectivity 서비스를 활성화한 후, 모든 컨트롤 플레인에서 노드로의 트래픽은
이 연결을 통과한다.</p><p><a href=/ko/docs/tasks/extend-kubernetes/setup-konnectivity/>Konnectivity 서비스 태스크</a>에 따라
클러스터에서 Konnectivity 서비스를 설정한다.</p></div></div></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>3 - 컨트롤러</h1><p>로보틱스와 자동화에서 <em>컨트롤 루프</em> 는
시스템 상태를 조절하는 종료되지 않는 루프이다.</p><p>컨트롤 루프의 예시: 실내 온도 조절기</p><p>사용자는 온도를 설정해서, 사용자가 <em>의도한 상태</em> 를
온도 조절기에 알려준다.
<em>현재 상태</em> 이다. 온도 조절기는 장비를 켜거나 꺼서
현재 상태를 의도한 상태에 가깝게 만든다.</p>쿠버네티스에서 컨트롤러는 <a class=glossary-tooltip title='컨테이너화된 애플리케이션을 실행하는 노드라고 하는 워커 머신의 집합. 모든 클러스터는 최소 한 개의 워커 노드를 가진다.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=클러스터>클러스터</a>
의 상태를 관찰 한 다음, 필요한 경우에 생성 또는 변경을
요청하는 컨트롤 루프이다.
각 컨트롤러는 현재 클러스터 상태를 의도한 상태에 가깝게
이동한다.<h2 id=컨트롤러-패턴>컨트롤러 패턴</h2><p>컨트롤러는 적어도 하나 이상의 쿠버네티스 리소스 유형을 추적한다.
이 <a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>오브젝트</a>
는 의도한 상태를 표현하는 사양 필드를 가지고 있다.
해당 리소스의 컨트롤러(들)은 현재 상태를 의도한
상태에 가깝게 만드는 역할을 한다.</p><p>컨트롤러는 스스로 작업을 수행할 수 있다. 보다 일반적으로,
쿠버네티스에서는 컨트롤러가
<a class=glossary-tooltip title='쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 서버'>API 서버</a> 로
유용한 부수적인 효과가 있는 메시지를 발송한다. 그 예시는 아래에서 볼 수 있다.</p><h3 id=api-서버를-통한-제어>API 서버를 통한 제어</h3><p><a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a> 컨트롤러는 쿠버네티스
내장 컨트롤러의 예시이다. 내장 컨트롤러는 클러스터 API 서버와
상호 작용하며 상태를 관리한다.</p><p>잡은 단일 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 또는 여러 파드를 실행하고,
작업을 수행한 다음 중지하는
쿠버네티스 리소스 이다.</p><p>(일단 <a href=/ko/docs/concepts/scheduling-eviction/>스케줄되면</a>, 파드 오브젝트는 kubelet
의 의도한 상태 중 일부가 된다.)</p><p>잡 컨트롤러가 새로운 작업을 확인하면, 클러스터 어딘가에서
노드 집합의 kubelet이 작업을 수행하기에 적합한
수의 파드를 실행하게 한다.
잡 컨트롤러는 어떤 파드 또는 컨테이너를 스스로 실행하지 않는다.
대신, 잡 컨트롤러는 API 서버에 파드를 생성하거나 삭제하도록
지시한다.
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>의
다른 컴포넌트는 신규 정보
(예약 및 실행해야 하는 새 파드가 있다는 정보)에 대응하여,
결국 해당 작업을 완료시킨다.</p><p>새 잡을 생성하고 나면, 의도한 상태는 해당 잡을 완료하는 것이 된다.
잡 컨트롤러는 현재 상태를 의도한 상태에 가깝게
만들며, 사용자가 원하는 잡을 수행하기 위해 파드를 생성해서
잡이 완료에 가까워 지도록 한다.</p><p>또한, 컨트롤러는 오브젝트의 설정을 업데이트 한다.
예시: 잡을 위한 작업이 종료된 경우, 잡 컨트롤러는
잡 오브젝트가 <code>Finished</code> 로 표시되도록 업데이트한다.</p><p>(이것은 지금 방 온도가 설정한 온도인 것을 표시하기
위해 실내 온도 조절기의 빛을 끄는 것과 약간 비슷하다).</p><h3 id=직접-제어>직접 제어</h3><p>잡과는 대조적으로, 일부 컨트롤러는 클러스터 외부의 것을
변경해야 할 필요가 있다.</p><p>예를 들어, 만약 컨트롤 루프를 사용해서
클러스터에 충분한 <a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드들>노드들</a>이
있도록 만드는 경우, 해당 컨트롤러는 필요할 때 새 노드를 설정할 수 있도록
현재 클러스터 외부의 무언가를 필요로 한다.</p><p>외부 상태와 상호 작용하는 컨트롤러는 API 서버에서 의도한
상태를 찾은 다음, 외부 시스템과 직접 통신해서
현재 상태를 보다 가깝게 만든다.</p><p>(실제로 클러스터의 노드를 수평으로 확장하는
<a href=https://github.com/kubernetes/autoscaler/>컨트롤러</a>가 있다.)</p><p>여기서 중요한 점은 컨트롤러가 의도한 상태를 가져오기 위해 약간의 변화를 주고,
현재 상태를 클러스터의 API 서버에 다시 보고한다는 것이다.
다른 컨트롤 루프는 보고된 데이터를 관찰하고 자체 조치를 할 수 있다.</p><p>온도 조절기 예에서 방이 매우 추우면 다른 컨트롤러가
서리 방지 히터를 켤 수도 있다. 쿠버네티스 클러스터에서는
<a href=/ko/docs/concepts/extend-kubernetes/>쿠버네티스 확장</a>을 통해
IP 주소 관리 도구, 스토리지 서비스, 클라우드 제공자의 API 및
기타 서비스 등과 간접적으로 연동하여 이를 구현한다.</p><h2 id=desired-vs-current>의도한 상태와 현재 상태</h2><p>쿠버네티스는 클라우드-네이티브 관점에서 시스템을 관찰하며, 지속적인
변화에 대응할 수 있다.</p><p>작업이 발생함에 따라 어떤 시점에서든 클러스터가
변경 될 수 있으며 컨트롤 루프가 자동으로 실패를 바로잡는다. 이는 잠재적으로,
클러스터가 안정적인 상태에 도달하지 못하는 것을 의미한다.</p><p>클러스터의 컨트롤러가 실행 중이고 유용한 변경을 수행할 수 있는 한,
전체 상태가 안정적인지 아닌지는 중요하지 않다.</p><h2 id=디자인>디자인</h2><p>디자인 원리에 따라, 쿠버네티스는 클러스터 상태의 각 특정 측면을
관리하는 많은 컨트롤러를 사용한다. 가장 일반적으로, 특정 컨트롤 루프
(컨트롤러)는 의도한 상태로서 한 종류의 리소스를 사용하고, 의도한 상태로
만들기 위해 다른 종류의 리소스를 관리한다. 예를 들어, 잡 컨트롤러는
잡 오브젝트(새 작업을 발견하기 위해)와 파드 오브젝트(잡을 실행하고, 완료된 시기를
확인하기 위해)를 추적한다. 이 경우 파드는 잡 컨트롤러가 생성하는 반면,
잡은 다른 컨트롤러가 생성한다.</p><p>컨트롤 루프들로 연결 구성된 하나의 모놀리식(monolithic) 집합보다,
간단한 컨트롤러를 여러 개 사용하는 것이 유용하다. 컨트롤러는 실패할 수 있으므로, 쿠버네티스는 이를
허용하도록 디자인되었다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>동일한 종류의 오브젝트를 만들거나 업데이트하는 여러 컨트롤러가 있을 수 있다.
이면에, 쿠버네티스 컨트롤러는 컨트롤 하고 있는 리소스에
연결된 리소스에만 주의를 기울인다.</p><p>예를 들어, 디플로이먼트와 잡을 가지고 있다. 이 두 가지 모두 파드를 생성한다.
잡 컨트롤러는 디플로이먼트가 생성한 파드를 삭제하지 않는다.
이는 컨트롤러가 해당 파드를 구별하기 위해 사용할 수 있는
정보(<a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>)가 있기 때문이다.</p></div><h2 id=running-controllers>컨트롤러를 실행하는 방법</h2><p>쿠버네티스에는 <a class=glossary-tooltip title='컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>
내부에서 실행되는 내장된 컨트롤러 집합이 있다. 이
내장 컨트롤러는 중요한 핵심 동작을 제공한다.</p><p>디플로이먼트 컨트롤러와 잡 컨트롤러는 쿠버네티스의
자체("내장" 컨트롤러)로 제공되는 컨트롤러 예시이다.
쿠버네티스를 사용하면 복원력이 뛰어난 컨트롤 플레인을 실행할 수 있으므로,
어떤 내장 컨트롤러가 실패하더라도 다른 컨트롤 플레인의 일부가 작업을 이어서 수행한다.</p><p>컨트롤 플레인의 외부에서 실행하는 컨트롤러를 찾아서 쿠버네티스를 확장할 수 있다.
또는, 원하는 경우 새 컨트롤러를 직접 작성할 수 있다.
소유하고 있는 컨트롤러를 파드 집합으로서 실행하거나,
또는 쿠버네티스 외부에서 실행할 수 있다. 가장 적합한 것은 특정 컨트롤러의 기능에
따라 달라진다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/overview/components/#%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%94%8C%EB%A0%88%EC%9D%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>쿠버네티스 컨트롤 플레인</a>에 대해 읽기</li><li><a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/>쿠버네티스 오브젝트</a>의 몇 가지 기본 사항을 알아보자.</li><li><a href=/ko/docs/concepts/overview/kubernetes-api/>쿠버네티스 API</a>에 대해 더 배워 보자.</li><li>만약 자신만의 컨트롤러를 작성하기 원한다면,
쿠버네티스 확장하기의 <a href=/ko/docs/concepts/extend-kubernetes/#%EC%9D%B5%EC%8A%A4%ED%85%90%EC%85%98-%ED%8C%A8%ED%84%B4>확장 패턴</a>을
본다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>4 - 클라우드 컨트롤러 매니저</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.11 [beta]</code></div><p>클라우드 인프라스트럭처 기술을 통해 퍼블릭, 프라이빗 그리고 하이브리드 클라우드에서 쿠버네티스를 실행할 수 있다.
쿠버네티스는 컴포넌트간의 긴밀한 결합 없이 자동화된 API 기반의 인프라스트럭처를
신뢰한다.</p><p><p>클라우드 컨트롤러 매니저는 클라우드별 컨트롤 로직을 포함하는 쿠버네티스
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a> 컴포넌트이다.
클라우드 컨트롤러 매니저를 통해 클러스터를 클라우드 공급자의 API에 연결하고,
해당 클라우드 플랫폼과 상호 작용하는 컴포넌트와 클러스터와만 상호 작용하는 컴포넌트를 구분할 수 있게 해 준다.</p></p><p>쿠버네티스와 기본 클라우드 인프라스터럭처 간의 상호 운용성 로직을
분리함으로써, cloud-controller-manager 컴포넌트는 클라우드 공급자가
주요 쿠버네티스 프로젝트와 다른 속도로 기능들을 릴리스할 수 있도록 한다.</p><p>클라우드 컨트롤러 매니저는 다양한 클라우드 공급자가 자신의
플랫폼에 쿠버네티스를 통합할 수 있도록 하는 플러그인 메커니즘을 사용해서 구성된다.</p><h2 id=디자인>디자인</h2><p><img src=/images/docs/components-of-kubernetes.svg alt="쿠버네티스 컴포넌트"></p><p>클라우드 컨트롤러 매니저는 컨트롤 플레인에서 복제된 프로세스의 집합으로 실행된다(일반적으로,
파드의 컨테이너). 각 클라우드 컨트롤러 매니저는 단일
프로세스에 여러 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>를
구현한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 또한 사용자는 클라우드 컨트롤러 매니저를 컨트롤 플레인의 일부가 아닌 쿠버네티스
<a class=glossary-tooltip title='쿠버네티스의 기능을 확장하는 리소스.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/cluster-administration/addons/ target=_blank aria-label=애드온>애드온</a>으로
실행할 수도 있다.</div><h2 id=functions-of-the-ccm>클라우드 컨트롤러 매니저의 기능</h2><p>클라우드 컨틀롤러 매니저의 내부 컨트롤러에는 다음 컨트롤러들이 포함된다.</p><h3 id=노드-컨트롤러>노드 컨트롤러</h3><p>노드 컨트롤러는 클라우드 인프라스트럭처에 새 서버가 생성될 때 <a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>
오브젝트를 업데이트하는 역할을 한다. 노드 컨트롤러는 클라우드 공급자의 사용자
테넌시 내에서 실행되는 호스트에 대한 정보를 가져온다. 노드 컨트롤러는 다음 기능들을 수행한다.</p><ol><li>클라우드 공급자 API를 통해 획득한 해당 서버의 고유 ID를 노드 오브젝트에 업데이트한다.</li><li>클라우드 관련 정보(예를 들어, 노드가 배포되는 지역과 사용 가능한 리소스(CPU, 메모리 등))를
사용해서 노드 오브젝트에 어노테이션과 레이블을 작성한다.</li><li>노드의 호스트 이름과 네트워크 주소를 가져온다.</li><li>노드의 상태를 확인한다. 노드가 응답하지 않는 경우, 이 컨트롤러는 사용자가
이용하는 클라우드 공급자의 API를 통해 서버가 비활성화됨 / 삭제됨 / 종료됨인지 확인한다.
노드가 클라우드에서 삭제된 경우, 컨트롤러는 사용자의 쿠버네티스 클러스터에서 노드
오브젝트를 삭제한다.</li></ol><p>일부 클라우드 공급자의 구현에서는 이를 노드 컨트롤러와 별도의 노드
라이프사이클 컨트롤러로 분리한다.</p><h3 id=라우트-컨트롤러>라우트 컨트롤러</h3><p>라우트 컨트롤러는 사용자의 쿠버네티스 클러스터의 다른 노드에
있는 각각의 컨테이너가 서로 통신할 수 있도록 클라우드에서
라우트를 적절히 구성해야 한다.</p><p>클라우드 공급자에 따라 라우트 컨트롤러는 파드 네트워크
IP 주소 블록을 할당할 수도 있다.</p><h3 id=서비스-컨트롤러>서비스 컨트롤러</h3><p><a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a> 는 관리형 로드 밸런서,
IP 주소, 네트워크 패킷 필터링 그리고 대상 상태 확인과 같은
클라우드 인프라스트럭처 컴포넌트와 통합된다. 서비스 컨트롤러는 사용자의 클라우드
공급자 API와 상호 작용해서 필요한 서비스 리소스를 선언할 때
로드 밸런서와 기타 인프라스트럭처 컴포넌트를 설정한다.</p><h2 id=인가>인가</h2><p>이 섹션에서는 클라우드 컨트롤러 매니저가 작업을 수행하기 위해
다양한 API 오브젝트에 필요한 접근 권한을 세분화한다.</p><h3 id=authorization-node-controller>노드 컨트롤러</h3><p>노드 컨트롤러는 노드 오브젝트에서만 작동한다. 노드 오브젝트를 읽고,
수정하려면 전체 접근 권한이 필요하다.</p><p><code>v1/Node</code>:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=authorization-route-controller>라우트 컨트롤러</h3><p>라우트 컨트롤러가 노드 오브젝트의 생성을 수신하고 적절하게
라우트를 구성한다. 노드 오브젝트에 대한 접근 권한이 필요하다.</p><p><code>v1/Node</code>:</p><ul><li>Get</li></ul><h3 id=authorization-service-controller>서비스 컨트롤러</h3><p>서비스 컨트롤러는 서비스 오브젝트 생성, 업데이트 그리고 삭제 이벤트를 수신한 다음 해당 서비스에 대한 엔드포인트를 적절하게 구성한다.</p><p>서비스에 접근하려면, 목록과 감시 접근 권한이 필요하다. 서비스를 업데이트하려면, 패치와 업데이트 접근 권한이 필요하다.</p><p>서비스에 대한 엔드포인트 리소스를 설정하려면 생성, 목록, 가져오기, 감시 그리고 업데이트에 대한 접근 권한이 필요하다.</p><p><code>v1/Service</code>:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=authorization-miscellaneous>그 외의 것들</h3><p>클라우드 컨트롤러 매니저의 핵심 구현을 위해 이벤트 오브젝트를 생성하고, 안전한 작동을 보장하기 위해 서비스어카운트(ServiceAccounts)를 생성해야 한다.</p><p><code>v1/Event</code>:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p><code>v1/ServiceAccount</code>:</p><ul><li>Create</li></ul><p>클라우드 컨트롤러 매니저의 <a class=glossary-tooltip title='인가 결정을 관리하며, 운영자가 쿠버네티스 API를 통해서 동적으로 엑세스 정책을 설정하게 한다.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a>
클러스터롤(ClusterRole)은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>클라우드 컨트롤러 매니저 관리</a>에는
클라우드 컨트롤러 매니저의 실행과 관리에 대한 지침이 있다.</p><p>클라우드 컨트롤러 매니저를 사용하기 위해 HA 컨트롤 플레인을 업그레이드하려면, <a href=/docs/tasks/administer-cluster/controller-manager-leader-migration/>클라우드 컨트롤러 매니저를 사용하기 위해 복제된 컨트롤 플레인 마이그레이션 하기</a>를 참고한다.</p><p>자체 클라우드 컨트롤러 매니저를 구현하거나 기존 프로젝트를 확장하는 방법을 알고 싶은가?</p><p>클라우드 컨트롤러 매니저는 Go 인터페이스를 사용함으로써, 어떠한 클라우드에 대한 구현체(implementation)라도 플러그인 될 수 있도록 한다. 구체적으로는, <a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>의 <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a>에 정의된 <code>CloudProvider</code> 인터페이스를 사용한다.</p><p>이 문서(노드, 라우트와 서비스)에서 강조된 공유 컨트롤러의 구현과 공유 cloudprovider 인터페이스와 함께 일부 스캐폴딩(scaffolding)은 쿠버네티스 핵심의 일부이다. 클라우드 공급자 전용 구현은 쿠버네티스의 핵심 바깥에 있으며 <code>CloudProvider</code> 인터페이스를 구현한다.</p><p>플러그인 개발에 대한 자세한 내용은 <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>클라우드 컨트롤러 매니저 개발하기</a>를 참조한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-44a2e2e592af0846101e970aff9243e5>5 - 가비지(Garbage) 수집</h1><p>쿠버네티스가 클러스터 자원을 정리하기 위해 사용하는
다양한 방법을 종합한 용어이다.
다음과 같은 리소스를 정리한다:</p><ul><li><a href=/ko/docs/concepts/workloads/controllers/ttlafterfinished/>종료된 잡</a></li><li><a href=#owners-dependents>소유자 참조가 없는 오브젝트</a></li><li><a href=#containers-images>사용되지 않는 컨테이너와 컨테이너 이미지</a></li><li><a href=/ko/docs/concepts/storage/persistent-volumes/#delete>반환 정책이 삭제인 스토리지클래스에 의해 동적으로 생성된 퍼시스턴트볼륨</a></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process>Stale 또는 만료된 CertificateSigningRequests (CSRs)</a></li><li><a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a> 는 다음과 같은 상황에서 삭제된다:<ul><li>클러스터가 <a href=/ko/docs/concepts/architecture/cloud-controller/>클라우드 컨트롤러 매니저</a>를 사용하는 클라우드</li><li>클러스터가 클라우드 컨트롤러 매니저와 유사한 애드온을 사용하는
온프레미스</li></ul></li><li><a href=/ko/docs/concepts/architecture/nodes/#heartbeats>노드 리스(Lease) 오브젝트</a></li></ul><h2 id=owners-dependents>소유자(Owners)와 종속(dependents)</h2><p>쿠버네티스의 많은 오브젝트는 <a href=/docs/concepts/overview/working-with-objects/owners-dependents/><em>owner references</em></a>를 통해 서로 연결되어 있다.</p><p>소유자 참조(Owner references)는 컨트롤 플레인에게 어떤 오브젝트가 서로 종속적인지를 알려준다.
쿠버네티스는 소유자 참조를 사용하여 컨트롤 플레인과 다른 API 클라이언트에게 오브젝트를 삭제하기 전 관련 리소스를 정리하는 기회를 제공한다. 대부분의 경우, 쿠버네티스는 소유자 참조를 자동으로 관리한다.</p><p>소유권(Ownership)은 일부 리소스가 사용하는 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블과 셀렉터</a>
메커니즘과는 다르다. 예를 들어,
<code>EndpointSlice</code> 오브젝트를 생성하는 <a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를
생각해보자. 서비스는 <em>레이블</em>을 사용해 컨트롤 플레인이
어떤 <code>EndpointSlice</code> 오브젝트가 해당 서비스에 의해 사용되는지 판단하는 데 도움을 준다. 레이블과 더불어,
서비스를 대신해 관리되는 각 <code>EndpointSlice</code> 오브젝트는
소유자 참조를 가진다. 소유자 참조는 쿠버네티스의 다른 부분이 제어하지 않는
오브젝트를 방해하는 것을 방지하는 데 도움을 준다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>교차 네임스페이스(cross-namespace)의 소유자 참조는 디자인상 허용되지 않는다.
네임스페이스 종속 오브젝트는 클러스터 범위 또는 네임스페이스 소유자를 지정할 수 있다.
네임스페이스 소유자는 <strong>반드시</strong> 종속 오브젝트와 동일한 네임스페이스에 존재해야 한다.
그렇지 않다면, 소유자 참조는 없는 것으로 간주되어, 종속 오브젝트는
모든 소유자가 없는 것으로 확인되면 삭제될 수 있다.</p><p>클러스터 범위의 종속 오브젝트는 클러스터 범위의 소유자만 지정할 수 있다.
v1.20 이상에서, 클러스터 범위의 종속 오브젝트가 네임스페이스 종류를 소유자로 지정하면,
확인할 수 없는 소유자 참조가 있는 것으로 간주되어 가비지 수집이 될 수 없다.</p><p>v1.20 이상에서, 가비지 수집기가 잘못된 교차 네임스페이스 <code>ownerReference</code>
또는 네임스페이스 종류를 참조하는 <code>ownerReference</code>가 있는 클러스터 범위의 종속 항목을 감지하면,
<code>OwnerRefInvalidNamespace</code>가 원인인 경고 이벤트와 유효하지 않은 종속 항목의 <code>involvedObject</code>가 보고된다.
<code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code>
를 실행하여 이러한 종류의 이벤트를 확인할 수 있다.</p></div><h2 id=cascading-deletion>캐스케이딩(Cascading) 삭제</h2><p>쿠버네티스는 오브젝트를 삭제할 때 더 이상 소유자 참조가 없는지,
예를 들어 레플리카셋을 삭제할 때, 남겨진 파드가 없는지 확인하고 삭제한다.
오브젝트를 삭제할 때 쿠버네티스가 오브젝트의 종속 오브젝트들을 자동으로 삭제할 지 여부를 제어할 수 있다.
이 과정을 <code>캐스케이딩 삭제</code>라고 한다.
캐스케이딩 삭제에는 다음과 같은 두 가지 종류가 있다.</p><ul><li>포그라운드 캐스케이딩 삭제(Foreground cascading deletion)</li><li>백그라운드 캐스케이딩 삭제(Background cascading deletion)</li></ul><p>또한 쿠버네티스의 <a class=glossary-tooltip title='쿠버네티스가 오브젝트를 완전히 삭제하기 이전, 삭제 표시를 위해 특정 조건이 충족될 때까지 대기하도록 알려주기 위한 네임스페이스에 속한 키(namespaced key)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=finalizers>finalizers</a>를 사용하여
가비지 수집이 소유자 참조가 있는 자원을 언제 어떻게 삭제할 것인지 제어할 수 있다.</p><h3 id=foreground-deletion>포그라운드 캐스케이딩 삭제</h3><p>포그라운드 캐스케이딩 삭제에서는 삭제하려는 소유자 오브젝트가 먼저
<em>삭제 중</em> 상태가 된다. 이 상태에서는 소유자 오브젝트에게 다음과 같은 일이
일어난다:</p><ul><li>쿠버네티스 API 서버가 오브젝트의 <code>metadata.deletionTimestamp</code> 필드를
오브젝트가 삭제 표시된 시간으로 설정한다.</li><li>쿠버네티스 API 서버가 <code>metadata.finalizers</code> 필드를 <code>foregroundDeletion</code>로
설정한다.</li><li>오브젝트는 삭제 과정이 완료되기 전까지
쿠버네티스 API를 통해 조회할 수 있다.</li></ul><p>소유자 오브젝트가 삭제 중 상태가 된 이후, 컨트롤러는 종속 오브젝트들을 삭제한다.
모든 종속 오브젝트들이 삭제되고나면, 컨트롤러가 소유자 오브젝트를 삭제한다.
이 시점에서 오브젝트는 더 이상
쿠버네티스 API를 통해 조회할 수 없다.</p><p>포그라운드 캐스케이딩 삭제 중에 소유자 오브젝트의 삭제를 막는
종속 오브젝트는<code>ownerReference.blockOwnerDeletion=true</code>필드를 가진 오브젝트다.
더 자세한 내용은 <a href=/ko/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion>Use foreground cascading deletion</a>를
참고한다.</p><h3 id=background-deletion>백그라운드 캐스케이딩 삭제</h3><p>백그라운드 캐스케이딩 삭제에서는 쿠버네티스 API 서버가 소유자 오브젝트를 즉시 삭제하고
백그라운드에서 컨트롤러가 종속 오브젝트들을 삭제한다.
쿠버네티스는 수동으로 포그라운드 삭제를 사용하거나 종속 오브젝트를 분리하지 않는다면,
기본적으로 백그라운드 캐스케이딩 삭제를 사용한다.</p><p>더 자세한 내용은 <a href=/ko/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion>Use background cascading deletion</a>를
참고한다.</p><h3 id=분리된-종속-orphaned-dependents>분리된 종속 (Orphaned dependents)</h3><p>쿠버네티스가 소유자 오브젝트를 삭제할 때, 남은 종속 오브젝트는 <em>분리된</em> 오브젝트라고 부른다.
기본적으로 쿠버네티스는 종속 오브젝트를 삭제한다. 이 행동을 오버라이드하는 방법을 보려면,
<a href=/ko/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy>Delete owner objects and orphan dependents</a>를 참고한다.</p><h2 id=containers-images>사용되지 않는 컨테이너와 이미지 가비지 수집</h2><p><a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>은
사용되지 않는 이미지에 대한 가비지 수집을 5분마다, 컨테이너에 대한 가비지 수집을 1분마다
수행한다. 외부 가비지 수집 도구는 kubelet 의 행동을 중단시키고
존재해야만 하는 컨테이너를 삭제할 수 있으므로 사용을 피해야 한다.</p><p>사용되지 않는 컨테이너와 이미지에 대한 가비지 수집 옵션을 구성하려면,
<a href=/docs/tasks/administer-cluster/kubelet-config-file/>configuration file</a> 사용하여
kubelet 을 수정하거나
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>KubeletConfiguration</code></a> 리소스 타입의
가비지 수집과 관련된 파라미터를 수정한다.</p><h3 id=컨테이너-이미지-라이프사이클>컨테이너 이미지 라이프사이클</h3><p>쿠버네티스는 kubelet의 일부인 <em>이미지 관리자</em>가
<a class=glossary-tooltip title='Tool that provides understanding of the resource usage and performance characteristics for containers' data-toggle=tooltip data-placement=top href=https://github.com/google/cadvisor/ target=_blank aria-label=cadvisor>cadvisor</a>와 협동하여
모든 이미지의 라이프사이클을 관리한다.
kubelet은 가비지 수집 결정을 내릴 때,
다음 디스크 사용량 제한을 고려한다.</p><ul><li><code>HighThresholdPercent</code></li><li><code>LowThresholdPercent</code></li></ul><p><code>HighThresholdPercent</code> 값을 초과한 디스크 사용량은
마지막으로 사용된 시간을 기준으로 오래된 이미지순서대로 이미지를 삭제하는
가비지 수집을 트리거한다. kubelet은 디스크 사용량이 <code>LowThresholdPercent</code> 값에 도달할 때까지
이미지를 삭제한다.</p><h3 id=container-image-garbage-collection>컨테이너 이미지 가비지 수집</h3><p>kubelet은 사용자가 정의할 수 있는 다음 변수들을 기반으로
사용되지 않는 컨테이너들을 삭제한다:</p><ul><li><code>MinAge</code>: kubelet이 가비지 수집할 수 있는 최소 나이.
<code>0</code>으로 세팅하여 비활성화할 수 있다.</li><li><code>MaxPerPodContainer</code>: 각 파드 쌍이 가질 수 있는 죽은 컨테이너의 최대 개수.
<code>0</code>으로 세팅하여 비활성화할 수 있다.</li><li><code>MaxContainers</code>: 클러스터가 가질 수 있는 죽은 컨테이너의 최대 개수
<code>0</code>으로 세팅하여 비활성화할 수 있다.</li></ul><p>위 변수와 더불어, kubelet은 식별할 수 없고 삭제된 컨테이너들을
오래된 순서대로 가비지 수집한다.</p><p><code>MaxPerPodContainer</code>와 <code>MaxContainer</code>는
파드의 최대 컨테이너 개수(<code>MaxPerPodContainer</code>)를 유지하는 것이
전체 죽은 컨테이너의 개수 제한(<code>MaxContainers</code>)을 초과하게 될 때,
서로 충돌이 발생할 수 있다.
이 상황에서 kubelet은 충돌을 해결하기 위해 <code>MaxPodPerContainer</code>를 조절한다.
최악의 시나리오에서는 <code>MaxPerPodContainer</code>를 <code>1</code>로 다운그레이드하고
가장 오래된 컨테이너들을 축출한다.
또한, 삭제된 파드가 소유한 컨테이너들은 <code>MinAge</code>보다 오래되었을 때 삭제된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> kubelet은 자신이 관리하는 컨테이너에 대한 가비지 수집만을 수행한다.</div><h2 id=configuring-gc>가비지 수집 구성하기</h2><p>자원을 관리하는 컨트롤러의 옵션을 구성하여
가비지 컬렉션을 수정할 수 있다.
다음 페이지에서 어떻게 가비지 수집을 구성할 수 있는지 확인할 수 있다.</p><ul><li><a href=/ko/docs/tasks/administer-cluster/use-cascading-deletion/>쿠버네티스 오브젝트의 캐스케이딩 삭제 구성하기</a></li><li><a href=/ko/docs/concepts/workloads/controllers/ttlafterfinished/>완료된 잡 자동 정리하기</a></li></ul><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/concepts/overview/working-with-objects/owners-dependents/>쿠버네티스 오브젝트의 소유권</a>에 대해 알아보자.</li><li>쿠버네티스 <a href=/ko/docs/concepts/overview/working-with-objects/finalizers/>finalizers</a>에 대해 알아보자.</li><li>완료된 잡을 정리하는 <a href=/ko/docs/concepts/workloads/controllers/ttlafterfinished/>TTL 컨트롤러</a> (beta) 에 대해 알아보자.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0ea5310f52e22c5de34dc84d9ab5e0d>6 - 컨테이너 런타임 인터페이스(CRI)</h1><p>컨테이너 런타임 인터페이스(CRI)는 클러스터 컴포넌트를 다시 컴파일하지 않아도 Kubelet이 다양한
컨테이너 런타임을 사용할 수 있도록 하는 플러그인 인터페이스다.</p><p>클러스터의 모든 노드에 동작 중인
<a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>이 존재해야,
<a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>이
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>들과 컨테이너들을
구동할 수 있다.</p><p><p>컨테이너 런타임 인터페이스(CRI)는 kubelet과 컨테이너 런타임 사이의 통신을 위한 주요 프로토콜이다.</p></p><p>쿠버네티스 컨테이너 런타임 인터페이스(CRI)는
<a href=/ko/docs/concepts/overview/components/#%EB%85%B8%EB%93%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>클러스터 컴포넌트</a>
<a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>과
<a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='container runtime'>container runtime</a> 사이의
통신을 위한 주요 <a href=https://grpc.io>gRPC</a> 프로토콜을 정의한다.</p><h2 id=api>API</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [stable]</code></div><p>Kubelet은 gRPC를 통해 컨테이너 런타임과 연결할 때 클라이언트의 역할을 수행한다.
런타임과 이미지 서비스 엔드포인트는 컨테이너 런타임 내에서 사용 가능해야 하며,
이는 각각 Kubelet 내에서 <code>--image-service-endpoint</code>와 <code>--container-runtime-endpoint</code>
<a href=/docs/reference/command-line-tools-reference/kubelet>커맨드라인 플래그</a>
를 통해 설정할 수 있다.</p><p>쿠버네티스 v1.25에서는, Kubelet은 CRI <code>v1</code>을 사용하는 것을 권장한다.
컨테이너 런타임이 CRI <code>v1</code> 버전을 지원하지 않는다면,
Kubelet은 지원 가능한 이전 지원 버전으로 협상을 시도한다.
또한 v1.25 Kubelet은 CRI <code>v1alpha2</code>버전도 협상할 수 있지만,
해당 버전은 사용 중단(deprecated)으로 간주한다.
Kubelet이 지원되는 CRI 버전을 협상할 수 없는 경우,
Kubelet은 협상을 포기하고 노드로 등록하지 않는다.</p><h2 id=업그레이드>업그레이드</h2><p>쿠버네티스를 업그레이드할 때, Kubelet은 컴포넌트의 재시작 시점에서 최신 CRI 버전을 자동으로 선택하려고 시도한다.
이 과정이 실패하면 위에서 언급한 대로 이전 버전을 선택하는 과정을 거친다.
컨테이너 런타임이 업그레이드되어 gRPC 재다이얼이 필요하다면,
컨테이너 런타임도 처음에 선택된 버전을 지원해야 하며,
그렇지 못한 경우 재다이얼은 실패하게 될 것이다. 이 과정은 Kubelet의 재시작이 필요하다.</p><h2 id=다음-내용>다음 내용</h2><ul><li>CRI <a href=https://github.com/kubernetes/cri-api/blob/c75ef5b/pkg/apis/runtime/v1/api.proto>프로토콜 정의</a>를 자세히 알아보자.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>