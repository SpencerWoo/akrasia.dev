<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/configuration/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/configuration/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/configuration/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/configuration/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/configuration/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/configuration/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/configuration/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/configuration/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/configuration/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/configuration/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/configuration/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>구성 | Kubernetes</title><meta property="og:title" content="구성"><meta property="og:description" content="쿠버네티스가 파드 구성을 위해 제공하는 리소스
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/configuration/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="구성"><meta itemprop=description content="쿠버네티스가 파드 구성을 위해 제공하는 리소스
"><meta name=twitter:card content="summary"><meta name=twitter:title content="구성"><meta name=twitter:description content="쿠버네티스가 파드 구성을 위해 제공하는 리소스
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="쿠버네티스가 파드 구성을 위해 제공하는 리소스
"><meta property="og:description" content="쿠버네티스가 파드 구성을 위해 제공하는 리소스
"><meta name=twitter:description content="쿠버네티스가 파드 구성을 위해 제공하는 리소스
"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/configuration/"><meta property="og:title" content="구성"><meta name=twitter:title content="구성"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/configuration/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/configuration/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/configuration/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/concepts/configuration/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/concepts/configuration/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/configuration/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/configuration/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/concepts/configuration/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/configuration/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/configuration/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/configuration/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/configuration/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/configuration/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/configuration/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/configuration/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/concepts/configuration/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>구성</h1><div class=lead>쿠버네티스가 파드 구성을 위해 제공하는 리소스</div><ul><li>1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>구성 모범 사례</a></li><li>2: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>컨피그맵(ConfigMap)</a></li><li>3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>시크릿(Secret)</a></li><li>4: <a href=#pg-436057b96151ecb8a4a9a9f456b5d0fc>파드 및 컨테이너 리소스 관리</a></li><li>5: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>kubeconfig 파일을 사용하여 클러스터 접근 구성하기</a></li><li>6: <a href=#pg-0f628478dbd58516389164933f9d7da2>윈도우 노드의 자원 관리</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>1 - 구성 모범 사례</h1><p>이 문서는 사용자 가이드, 시작하기 문서 및 예제들에 걸쳐 소개된 구성 모범 사례를 강조하고 통합한다.</p><p>이 문서는 지속적으로 변경 가능하다. 이 목록에 없지만 다른 사람들에게 유용할 것 같은 무엇인가를 생각하고 있다면, 새로운 이슈를 생성하거나 풀 리퀘스트를 제출하는 것을 망설이지 말기를 바란다.</p><h2 id=일반적인-구성-팁>일반적인 구성 팁</h2><ul><li><p>구성을 정의할 때, 안정된 최신 API 버전을 명시한다.</p></li><li><p>구성 파일들은 클러스터에 적용되기 전에 버전 컨트롤에 저장되어 있어야 한다. 이는 만약 필요하다면 구성의 변경 사항을 빠르게 되돌릴 수 있도록 해준다. 이는 또한 클러스터의 재-생성과 복원을 도와준다.</p></li><li><p>JSON보다는 YAML을 사용해 구성 파일을 작성한다. 비록 이러한 포맷들은 대부분의 모든 상황에서 통용되어 사용될 수 있지만, YAML이 좀 더 사용자 친화적인 성향을 가진다.</p></li><li><p>의미상 맞다면 가능한 연관된 오브젝트들을 하나의 파일에 모아 놓는다. 때로는 여러 개의 파일보다 하나의 파일이 더 관리하기 쉽다. 이 문법의 예시로서 <a href=https://github.com/kubernetes/examples/tree/master/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a> 파일을 참고한다.</p></li><li><p>많은 <code>kubectl</code> 커맨드들은 디렉터리에 대해 호출될 수 있다. 예를 들어, 구성 파일들의 디렉터리에 대해 <code>kubectl apply</code>를 호출할 수 있다.</p></li><li><p>불필요하게 기본 값을 명시하지 않는다. 간단하고 최소한의 설정은 에러를 덜 발생시킨다.</p></li><li><p>더 나은 인트로스펙션(introspection)을 위해서, 어노테이션에 오브젝트의 설명을 넣는다.</p></li></ul><h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"단독(Naked)" 파드 vs 레플리카셋(ReplicaSet), 디플로이먼트(Deployment), 그리고 잡(Job)</h2><ul><li><p>가능하다면 단독 파드(즉, <a href=/ko/docs/concepts/workloads/controllers/replicaset/>레플리카셋</a>이나 <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>에 연결되지 않은 파드)를 사용하지 않는다. 단독 파드는 노드 장애 이벤트가 발생해도 다시 스케줄링되지 않는다.</p><p>명백하게 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%A0%95%EC%B1%85><code>restartPolicy: Never</code></a>를 사용하는 상황을 제외한다면, 의도한 파드의 수가 항상 사용 가능한 상태를 유지하는 레플리카셋을 생성하고, 파드를 교체하는 전략(<a href=/ko/docs/concepts/workloads/controllers/deployment/#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EB%A1%A4%EB%A7%81-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>롤링 업데이트</a>와 같은)을 명시하는 디플로이먼트는 파드를 직접 생성하기 위해 항상 선호되는 방법이다. <a href=/ko/docs/concepts/workloads/controllers/job/>잡</a> 또한 적절할 수 있다.</p></li></ul><h2 id=서비스>서비스</h2><ul><li><p>서비스에 대응하는 백엔드 워크로드(디플로이먼트 또는 레플리카셋) 또는 서비스 접근이 필요한 어떠한 워크로드를 생성하기 전에 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>를 미리 생성한다. 쿠버네티스가 컨테이너를 시작할 때, 쿠버네티스는 컨테이너 시작 당시에 생성되어 있는 모든 서비스를 가리키는 환경 변수를 컨테이너에 제공한다. 예를 들어, <code>foo</code> 라는 이름의 서비스가 존재한다면, 모든 컨테이너들은 초기 환경에서 다음의 변수들을 얻을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;서비스가 동작 중인 호스트&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;서비스가 동작 중인 포트&gt;
</span></span></code></pre></div><p><em>이는 순서를 정하는 일이 요구됨을 암시한다</em> - <code>파드</code>가 접근하기를 원하는 어떠한 <code>서비스</code>는 <code>파드</code> 스스로가 생성되기 전에 미리 생성되어 있어야 하며, 그렇지 않으면 환경 변수가 설정되지 않을 것이다. DNS는 이러한 제한을 가지고 있지 않다.</p></li><li><p>선택적인(그렇지만 매우 권장되는) <a href=/ko/docs/concepts/cluster-administration/addons/>클러스터 애드온</a>은 DNS 서버이다.
DNS 서버는 새로운 <code>서비스</code>를 위한 쿠버네티스 API를 Watch하며, 각 서비스를 위한 DNS 레코드 셋을 생성한다. 만약 DNS가 클러스터에 걸쳐 활성화되어 있다면, 모든 <code>파드</code>는 <code>서비스</code>의 이름을 자동으로 해석할 수 있어야 한다.</p></li><li><p>반드시 필요한 것이 아니라면 파드에 <code>hostPort</code> 를 명시하지 않는다. &lt;<code>hostIP</code>, <code>hostPort</code>, <code>protocol</code>> 조합은 유일해야 하기 때문에, <code>hostPort</code>로 바인드하는 것은 파드가 스케줄링될 수 있는 위치의 개수를 제한한다. 만약 <code>hostIP</code>와 <code>protocol</code>을 뚜렷히 명시하지 않으면, 쿠버네티스는 <code>hostIP</code>의 기본 값으로 <code>0.0.0.0</code>를, <code>protocol</code>의 기본 값으로 <code>TCP</code>를 사용한다.</p><p>만약 오직 디버깅의 목적으로 포트에 접근해야 한다면, <a href=/ko/docs/tasks/access-application-cluster/access-cluster/#%EC%88%98%EC%9E%91%EC%97%85%EC%9C%BC%EB%A1%9C-apiserver-proxy-url%EC%9D%84-%EA%B5%AC%EC%B6%95>apiserver proxy</a> 또는 <a href=/ko/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>를 사용할 수 있다.</p><p>만약 파드의 포트를 노드에서 명시적으로 노출해야 한다면, <code>hostPort</code>에 의존하기 전에 <a href=/ko/docs/concepts/services-networking/service/#type-nodeport>NodePort</a> 서비스를 사용하는 것을 고려할 수 있다.</p></li><li><p><code>hostPort</code>와 같은 이유로, <code>hostNetwork</code>를 사용하는 것을 피한다.</p></li><li><p><code>kube-proxy</code> 로드 밸런싱이 필요하지 않을 때, 서비스 발견을 위해 <a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>(<code>ClusterIP</code>의 값을 <code>None</code>으로 가지는)를 사용한다.</p></li></ul><h2 id=레이블-사용하기>레이블 사용하기</h2><ul><li><code>{ app.kubernetes.io/name: MyApp, tier: frontend, phase: test, deployment: v3 }</code>처럼 애플리케이션이나 디플로이먼트의 <strong>속성에 대한 의미</strong> 를 식별하는 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>을 정의해 사용한다. 다른 리소스를 위해 적절한 파드를 선택하는 용도로 이러한 레이블을 이용할 수 있다. 예를 들어, 모든 <code>tier: frontend</code> 파드를 선택하거나, <code>app.kubernetes.io/name: MyApp</code>의 모든 <code>phase: test</code> 컴포넌트를 선택하는 서비스를 생각해 볼 수 있다. 이 접근 방법의 예시는 <a href=https://github.com/kubernetes/examples/tree/master/guestbook/>방명록</a> 앱을 참고한다.</li></ul><p>릴리스에 특정되는 레이블을 서비스의 셀렉터에서 생략함으로써 여러 개의 디플로이먼트에 걸치는 서비스를 생성할 수 있다. 동작 중인 서비스를 다운타임 없이 갱신하려면, <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>를 사용한다.</p><p>오브젝트의 의도한 상태는 디플로이먼트에 의해 기술되며, 만약 그 스펙에 대한 변화가 <em>적용될</em> 경우, 디플로이먼트 컨트롤러는 일정한 비율로 실제 상태를 의도한 상태로 변화시킨다.</p><ul><li><p>일반적인 활용 사례인 경우 <a href=/ko/docs/concepts/overview/working-with-objects/common-labels/>쿠버네티스 공통 레이블</a>을 사용한다. 이 표준화된 레이블은 <code>kubectl</code> 및 <a href=/ko/docs/tasks/access-application-cluster/web-ui-dashboard>대시보드</a>와 같은 도구들이 상호 운용이 가능한 방식으로 동작할 수 있도록 메타데이터를 향상시킨다.</p></li><li><p>디버깅을 위해 레이블을 조작할 수 있다. (레플리카셋과 같은) 쿠버네티스 컨트롤러와 서비스는 셀렉터 레이블을 사용해 파드를 선택하기 때문에, 관련된 레이블을 파드에서 삭제하는 것은 컨트롤러로부터 관리되거나 서비스로부터 트래픽을 전달받는 것을 중단시킨다. 만약 이미 존재하는 파드의 레이블을 삭제한다면, 파드의 컨트롤러는 그 자리를 대신할 새로운 파드를 생성한다. 이것은 이전에 "살아 있는" 파드를 "격리된" 환경에서 디버그할 수 있는 유용한 방법이다. 레이블을 상호적으로 추가하고 삭제하기 위해서, <a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>를 사용할 수 있다.</p></li></ul><h2 id=kubectl-사용하기>kubectl 사용하기</h2><ul><li><p><code>kubectl apply -f &lt;디렉터리></code>를 사용한다. 이 명령어는 <code>&lt;디렉터리></code> 내부의 모든 <code>.yaml</code>, <code>.yml</code>, 그리고 <code>.json</code> 쿠버네티스 구성 파일을 찾아 <code>apply</code>에 전달한다.</p></li><li><p><code>get</code>과 <code>delete</code> 동작을 위해 특정 오브젝트의 이름 대신 레이블 셀렉터를 사용한다. <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%85%80%EB%A0%89%ED%84%B0>레이블 셀렉터</a>와 <a href=/ko/docs/concepts/cluster-administration/manage-deployment/#%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8-%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%82%AC%EC%9A%A9>효율적으로 레이블 사용하기</a>를 참고할 수 있다.</p></li><li><p>단일 컨테이너로 구성된 디플로이먼트와 서비스를 빠르게 생성하기 위해 <code>kubectl create deployment</code> 와 <code>kubectl expose</code> 를 사용한다. <a href=/ko/docs/tasks/access-application-cluster/service-access-application-cluster/>클러스터 내부의 애플리케이션에 접근하기 위한 서비스 사용</a>에서 예시를 확인할 수 있다.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6b5ccadd699df0904e8e9917c5450c4b>2 - 컨피그맵(ConfigMap)</h1><p><p>컨피그맵은 키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다.
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>는
<a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>에서
환경 변수, 커맨드-라인 인수 또는 구성 파일로 컨피그맵을 사용할 수 있다.</p></p><p>컨피그맵을 사용하면 <a class=glossary-tooltip title='컨테이너의 저장된 인스턴스이며, 애플리케이션 구동에 필요한 소프트웨어 집합을 가지고 있다.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='컨테이너 이미지'>컨테이너 이미지</a>에서 환경별 구성을 분리하여, 애플리케이션을 쉽게 이식할 수 있다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 컨피그맵은 보안 또는 암호화를 제공하지 않는다.
저장하려는 데이터가 기밀인 경우, 컨피그맵
대신 <a class=glossary-tooltip title='비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿(Secret)>시크릿(Secret)</a> 또는 추가(써드파티) 도구를
사용하여 데이터를 비공개로 유지하자.</div><h2 id=사용-동기>사용 동기</h2><p>애플리케이션 코드와 별도로 구성 데이터를 설정하려면 컨피그맵을 사용하자.</p><p>예를 들어, 자신의 컴퓨터(개발용)와 클라우드(실제 트래픽 처리)에서
실행할 수 있는 애플리케이션을 개발한다고 가정해보자.
<code>DATABASE_HOST</code> 라는 환경 변수를 찾기 위해 코드를 작성한다.
로컬에서는 해당 변수를 <code>localhost</code> 로 설정한다. 클라우드에서는, 데이터베이스
컴포넌트를 클러스터에 노출하는 쿠버네티스 <a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를
참조하도록 설정한다.
이를 통해 클라우드에서 실행 중인 컨테이너 이미지를 가져와
필요한 경우 정확히 동일한 코드를 로컬에서 디버깅할 수 있다.</p><p>컨피그맵은 많은 양의 데이터를 보유하도록 설계되지 않았다. 컨피그맵에 저장된
데이터는 1MiB를 초과할 수 없다. 이 제한보다 큰 설정을
저장해야 하는 경우, 볼륨을 마운트하는 것을 고려하거나 별도의
데이터베이스 또는 파일 서비스를 사용할 수 있다.</p><h2 id=컨피그맵-오브젝트>컨피그맵 오브젝트</h2><p>컨피그맵은 다른 오브젝트가 사용할 구성을 저장할 수 있는
API <a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/>오브젝트</a>이다.
<code>spec</code> 이 있는 대부분의 쿠버네티스 오브젝트와 달리, 컨피그맵에는 <code>data</code> 및 <code>binaryData</code>
필드가 있다. 이러한 필드는 키-값 쌍을 값으로 허용한다. <code>data</code> 필드와
<code>binaryData</code> 는 모두 선택 사항이다. <code>data</code> 필드는
UTF-8 문자열을 포함하도록 설계되었으며 <code>binaryData</code> 필드는 바이너리
데이터를 base64로 인코딩된 문자열로 포함하도록 설계되었다.</p><p>컨피그맵의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><p><code>data</code> 또는 <code>binaryData</code> 필드 아래의 각 키는
영숫자 문자, <code>-</code>, <code>_</code> 또는 <code>.</code> 으로 구성되어야 한다. <code>data</code> 에 저장된 키는
<code>binaryData</code> 필드의 키와 겹치지 않아야 한다.</p><p>v1.19부터 컨피그맵 정의에 <code>immutable</code> 필드를 추가하여
<a href=#configmap-immutable>변경할 수 없는 컨피그맵</a>을 만들 수 있다.</p><h2 id=컨피그맵과-파드>컨피그맵과 파드</h2><p>컨피그맵을 참조하는 파드 <code>spec</code> 을 작성하고 컨피그맵의 데이터를
기반으로 해당 파드의 컨테이너를 구성할 수 있다. 파드와 컨피그맵은
동일한 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a>에 있어야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <a class=glossary-tooltip title='특정 노드의 Kubelet 데몬이 직접 관리하는 파드' data-toggle=tooltip data-placement=top href=/ko/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='스태틱(static) 파드'>스태틱(static) 파드</a>의 <code>spec</code>은 컨피그맵
또는 다른 API 오브젝트를 참조할 수 없다.</div><p>다음은 단일 값을 가진 키와,
값이 구성 형식의 일부처럼 보이는 키를 가진 컨피그맵의
예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 속성과 비슷한 키; 각 키는 간단한 값으로 매핑됨</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>player_initial_lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui_properties_file_name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 파일과 비슷한 키</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemy.types=aliens,monsters
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    player.maximum-lives=5</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user-interface.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.good=purple
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    allow.textmode=true</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>컨피그맵을 사용하여 파드 내부에 컨테이너를 구성할 수 있는
네 가지 방법이 있다.</p><ol><li>컨테이너 커맨드와 인수 내에서</li><li>컨테이너에 대한 환경 변수</li><li>애플리케이션이 읽을 수 있도록 읽기 전용 볼륨에 파일 추가</li><li>쿠버네티스 API를 사용하여 컨피그맵을 읽는 파드 내에서 실행할 코드 작성</li></ol><p>이러한 방법들은 소비되는 데이터를 모델링하는
방식에 따라 다르게 쓰인다.
처음 세 가지 방법의 경우,
<a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>은 파드의 컨테이너를 시작할 때
컨피그맵의 데이터를 사용한다.</p><p>네 번째 방법은 컨피그맵과 데이터를 읽기 위해 코드를 작성해야 한다는 것을 의미한다.
그러나, 쿠버네티스 API를 직접 사용하기 때문에, 애플리케이션은
컨피그맵이 변경될 때마다 업데이트를 받기 위해 구독할 수 있고, 업데이트가
있으면 반응한다. 쿠버네티스 API에 직접 접근하면, 이
기술을 사용하여 다른 네임스페이스의 컨피그맵에 접근할 수도 있다.</p><p>다음은 <code>game-demo</code> 의 값을 사용하여 파드를 구성하는 파드 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>alpine<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;3600&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 환경 변수 정의</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PLAYER_INITIAL_LIVES<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 참고로 여기서는 컨피그맵의 키 이름과</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                                     </span><span style=color:#080;font-style:italic># 대소문자가 다르다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo          <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 이 값의 컨피그맵.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>player_initial_lives<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 가져올 키.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UI_PROPERTIES_FILE_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ui_properties_file_name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/config&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 파드 레벨에서 볼륨을 설정한 다음, 해당 파드 내의 컨테이너에 마운트한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 마운트하려는 컨피그맵의 이름을 제공한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 컨피그맵에서 파일로 생성할 키 배열</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>컨피그맵은 단일 라인 속성(single line property) 값과 멀티 라인의 파일과 비슷한(multi-line file-like) 값을
구분하지 않는다.
더 중요한 것은 파드와 다른 오브젝트가 이러한 값을 소비하는 방식이다.</p><p>이 예제에서, 볼륨을 정의하고 <code>demo</code> 컨테이너에
<code>/config</code> 로 마운트하면 컨피그맵에 4개의 키가 있더라도
<code>/config/game.properties</code> 와 <code>/config/user-interface.properties</code>
2개의 파일이 생성된다. 이것은 파드 정의가
<code>volume</code> 섹션에서 <code>items</code> 배열을 지정하기 때문이다.
<code>items</code> 배열을 완전히 생략하면, 컨피그맵의 모든 키가
키와 이름이 같은 파일이 되고, 4개의 파일을 얻게 된다.</p><h2 id=컨피그맵-사용하기>컨피그맵 사용하기</h2><p>컨피그맵은 데이터 볼륨으로 마운트할 수 있다. 컨피그맵은 파드에 직접적으로
노출되지 않고, 시스템의 다른 부분에서도 사용할 수 있다. 예를 들어,
컨피그맵은 시스템의 다른 부분이 구성을 위해 사용해야 하는 데이터를 보유할 수 있다.</p><p>컨피그맵을 사용하는 가장 일반적인 방법은 동일한 네임스페이스의
파드에서 실행되는 컨테이너에 대한 설정을 구성하는 것이다. 컨피그맵을
별도로 사용할 수도 있다.</p><p>예를 들어,
컨피그맵에 기반한 동작을 조정하는 <a class=glossary-tooltip title='쿠버네티스의 기능을 확장하는 리소스.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/cluster-administration/addons/ target=_blank aria-label=애드온>애드온</a>이나
<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=오퍼레이터>오퍼레이터</a>를
사용할 수도 있다.</p><h3 id=파드에서-컨피그맵을-파일로-사용하기>파드에서 컨피그맵을 파일로 사용하기</h3><p>파드의 볼륨에서 컨피그맵을 사용하려면 다음을 수행한다.</p><ol><li>컨피그맵을 생성하거나 기존 컨피그맵을 사용한다. 여러 파드가 동일한 컨피그맵을
참조할 수 있다.</li><li>파드 정의를 수정해서 <code>.spec.volumes[]</code> 아래에 볼륨을 추가한다. 볼륨 이름은
원하는 대로 정하고, 컨피그맵 오브젝트를 참조하도록 <code>.spec.volumes[].configMap.name</code>
필드를 설정한다.</li><li>컨피그맵이 필요한 각 컨테이너에 <code>.spec.containers[].volumeMounts[]</code> 를
추가한다. <code>.spec.containers[].volumeMounts[].readOnly = true</code> 를 설정하고
컨피그맵이 연결되기를 원하는 곳에 사용하지 않은 디렉터리 이름으로
<code>.spec.containers[].volumeMounts[].mountPath</code> 를 지정한다.</li><li>프로그램이 해당 디렉터리에서 파일을 찾도록 이미지 또는 커맨드 라인을
수정한다. 컨피그맵의 <code>data</code> 맵 각 키는 <code>mountPath</code> 아래의
파일 이름이 된다.</li></ol><p>다음은 볼륨에 컨피그맵을 마운트하는 파드의 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configmap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span></code></pre></div><p>사용하려는 각 컨피그맵은 <code>.spec.volumes</code> 에서 참조해야 한다.</p><p>파드에 여러 컨테이너가 있는 경우 각 컨테이너에는 자체 <code>volumeMounts</code> 블록이 필요하지만,
컨피그맵은 각 컨피그맵 당 하나의 <code>.spec.volumes</code> 만 필요하다.</p><h4 id=마운트된-컨피그맵이-자동으로-업데이트>마운트된 컨피그맵이 자동으로 업데이트</h4><p>현재 볼륨에서 사용된 컨피그맵이 업데이트되면, 프로젝션된 키도 마찬가지로 업데이트된다.
kubelet은 모든 주기적인 동기화에서 마운트된 컨피그맵이 최신 상태인지 확인한다.
그러나, kubelet은 로컬 캐시를 사용해서 컨피그맵의 현재 값을 가져온다.
캐시 유형은 <a href=/docs/reference/config-api/kubelet-config.v1beta1/>KubeletConfiguration 구조체</a>의
<code>ConfigMapAndSecretChangeDetectionStrategy</code> 필드를 사용해서 구성할 수 있다.
컨피그맵은 watch(기본값), ttl 기반 또는 API 서버로 직접
모든 요청을 리디렉션할 수 있다.
따라서 컨피그맵이 업데이트되는 순간부터 새 키가 파드에 업데이트되는 순간까지의
총 지연시간은 kubelet 동기화 기간 + 캐시 전파 지연만큼 길 수 있다. 여기서 캐시
전파 지연은 선택한 캐시 유형에 따라 달라질 수 있다(전파
지연을 지켜보거나, 캐시의 ttl 또는 0에 상응함).</p><p>환경 변수로 사용되는 컨피그맵은 자동으로 업데이트되지 않으며 파드를 다시 시작해야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 컨피그맵을 <a href=/ko/docs/concepts/storage/volumes/#using-subpath>subPath</a> 볼륨 마운트로 사용하는 컨테이너는 컨피그맵 업데이트를 받지 못할 것이다.</div><h2 id=configmap-immutable>변경할 수 없는(immutable) 컨피그맵</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [stable]</code></div><p>쿠버네티스 기능인 <em>변경할 수 없는 시크릿과 컨피그맵</em> 은 개별 시크릿과
컨피그맵을 변경할 수 없는 것으로 설정하는 옵션을 제공한다. 컨피그맵을 광범위하게
사용하는 클러스터(최소 수만 개의 고유한 컨피그맵이 파드에 마운트)의 경우
데이터 변경을 방지하면 다음과 같은 이점이 있다.</p><ul><li>애플리케이션 중단을 일으킬 수 있는 우발적(또는 원하지 않는) 업데이트로부터 보호</li><li>immutable로 표시된 컨피그맵에 대한 감시를 중단하여, kube-apiserver의 부하를 크게 줄임으로써
클러스터의 성능을 향상시킴</li></ul><p>이 기능은 <code>ImmutableEphemeralVolumes</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>에 의해 제어된다.
<code>immutable</code> 필드를 <code>true</code> 로 설정하여 변경할 수 없는 컨피그맵을 생성할 수 있다.
다음은 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>컨피그맵을 immutable로 표시하면, 이 변경 사항을 되돌리거나
<code>data</code> 또는 <code>binaryData</code> 필드 내용을 변경할 수 <em>없다</em>. 컨피그맵만
삭제하고 다시 작성할 수 있다. 기존 파드는 삭제된 컨피그맵에 대한 마운트 지점을
유지하므로, 이러한 파드를 다시 작성하는 것을 권장한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/configuration/secret/>시크릿</a>에 대해 읽어본다.</li><li><a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그맵을 사용하도록 파드 구성하기</a>를 읽어본다.</li><li><a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>컨피그맵 (또는 어떠한 쿠버네티스 오브젝트) 변경하기</a>를 읽어본다.</li><li>코드를 구성에서 분리하려는 동기를 이해하려면
<a href=https://12factor.net/ko/>Twelve-Factor 앱</a>을 읽어본다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>3 - 시크릿(Secret)</h1><p>시크릿은 암호, 토큰 또는 키와 같은 소량의 중요한 데이터를
포함하는 오브젝트이다. 이를 사용하지 않으면 중요한 정보가 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>
명세나 <a class=glossary-tooltip title='컨테이너의 저장된 인스턴스이며, 애플리케이션 구동에 필요한 소프트웨어 집합을 가지고 있다.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='컨테이너 이미지'>컨테이너 이미지</a>에
포함될 수 있다. 시크릿을 사용한다는 것은 사용자의 기밀 데이터를
애플리케이션 코드에 넣을 필요가
없음을 뜻한다.</p><p>시크릿은 시크릿을 사용하는 파드와 독립적으로 생성될 수 있기 때문에,
파드를 생성하고, 확인하고, 수정하는 워크플로우 동안 시크릿(그리고 데이터)이
노출되는 것에 대한 위험을 경감시킬 수 있다. 쿠버네티스
및 클러스터에서 실행되는 애플리케이션은 비밀 데이터를 비휘발성
저장소에 쓰는 것을 피하는 것과 같이, 시크릿에 대해 추가 예방 조치를 취할 수도 있다.</p><p>시크릿은 <a class=glossary-tooltip title='키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>과 유사하지만
특별히 기밀 데이터를 보관하기 위한 것이다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong><p>쿠버네티스 시크릿은 기본적으로 API 서버의 기본 데이터 저장소(etcd)에 암호화되지 않은 상태로 저장된다. API 접근(access) 권한이 있는 모든 사용자 또는 etcd에 접근할 수 있는 모든 사용자는 시크릿을 조회하거나 수정할 수 있다.
또한 네임스페이스에서 파드를 생성할 권한이 있는 사람은 누구나 해당 접근을 사용하여 해당 네임스페이스의 모든 시크릿을 읽을 수 있다. 여기에는 디플로이먼트 생성 기능과 같은 간접 접근이 포함된다.</p><p>시크릿을 안전하게 사용하려면 최소한 다음의 단계를 따르는 것이 좋다.</p><ol><li>시크릿에 대해 <a href=/docs/tasks/administer-cluster/encrypt-data/>저장된 데이터 암호화(Encryption at Rest)를 활성화</a>한다.</li><li>시크릿 읽기 및 쓰기를 제한하는
<a href=/ko/docs/reference/access-authn-authz/authorization/>RBAC 규칙을 활성화 또는 구성</a>한다.
파드 생성 권한을 가진 사람은 암묵적으로 시크릿에 접근할 수 있음에 주의한다.</li><li>적절한 경우, RBAC과 같은 메커니즘을 사용하여 새로운 시크릿을 생성하거나
기존 시크릿을 대체할 수 있는 주체(principal)들을 제한한다.</li></ol></div><p>더 자세한 것은 <a href=#%EC%8B%9C%ED%81%AC%EB%A6%BF%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%A0%95%EB%B3%B4-%EB%B3%B4%EC%95%88-information-security>시크릿을 위한 정보 보안(Information security)</a>을 참고한다.</p><h2 id=시크릿의-사용>시크릿의 사용</h2><p>파드가 시크릿을 사용하는 주요한 방법으로 다음의 세 가지가 있다.</p><ul><li>하나 이상의 컨테이너에 마운트된
<a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a> 내의
<a href=#using-secrets-as-files-from-a-pod>파일</a>로써 사용.</li><li><a href=#%EC%8B%9C%ED%81%AC%EB%A6%BF%EC%9D%84-%ED%99%98%EA%B2%BD-%EB%B3%80%EC%88%98-%ED%98%95%ED%83%9C%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>컨테이너 환경 변수</a>로써 사용.</li><li>파드의 <a href=#imagepullsecrets-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>이미지를 가져올 때 kubelet</a>에 의해 사용.</li></ul><p>쿠버네티스 컨트롤 플레인 또한 시크릿을 사용한다. 예를 들어,
<a href=#%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9-%ED%86%A0%ED%81%B0-%EC%8B%9C%ED%81%AC%EB%A6%BF>부트스트랩 토큰 시크릿</a>은
노드 등록을 자동화하는 데 도움을 주는 메커니즘이다.</p><h3 id=시크릿의-대체품>시크릿의 대체품</h3><p>기밀 데이터를 보호하기 위해 시크릿 대신 다음의 대안 중 하나를 고를 수 있다.</p><p>다음과 같은 대안이 존재한다.</p><ul><li>클라우드 네이티브 구성 요소가
동일 쿠버네티스 클러스터 안에 있는 다른 애플리케이션에 인증해야 하는 경우,
<a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>서비스어카운트(ServiceAccount)</a> 및
그의 토큰을 이용하여 클라이언트를 식별할 수 있다.</li><li>비밀 정보 관리 기능을 제공하는 써드파티 도구를
클러스터 내부 또는 외부에 실행할 수 있다.
예를 들어, 클라이언트가 올바르게 인증했을 때에만(예: 서비스어카운트 토큰으로 인증) 비밀 정보를 공개하고,
파드가 HTTPS를 통해서만 접근하도록 처리하는 서비스가 있을 수 있다.</li><li>인증을 위해, X.509 인증서를 위한 커스텀 인증자(signer)를 구현하고,
<a href=/docs/reference/access-authn-authz/certificate-signing-requests/>CertificateSigningRequests</a>를 사용하여
해당 커스텀 인증자가 인증서를 필요로 하는 파드에 인증서를 발급하도록 할 수 있다.</li><li><a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>장치 플러그인</a>을 사용하여
노드에 있는 암호화 하드웨어를 특정 파드에 노출할 수 있다.
예를 들어, 신뢰할 수 있는 파드를 별도로 구성된 TPM(Trusted Platform Module, 신뢰할 수 있는 플랫폼 모듈)을 제공하는 노드에 스케줄링할 수 있다.</li></ul><p>위의 옵션들 및 시크릿 오브젝트 자체를 이용하는 옵션 중 2가지 이상을 조합하여 사용할 수도 있다.</p><p>예시: 외부 서비스에서 단기 유효(short-lived) 세션 토큰을 가져오는
<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=오퍼레이터>오퍼레이터</a>를 구현(또는 배포)한 다음,
이 단기 유효 세션 토큰을 기반으로 시크릿을 생성할 수 있다.
클러스터의 파드는 이 세션 토큰을 활용할 수 있으며, 오퍼레이터는 토큰이 유효한지 검증해 준다.
이러한 분리 구조는 곧 파드가 이러한 세션 토큰의 발급 및 갱신에 대한 정확한 메커니즘을 모르게 하면서도 파드를 실행할 수 있음을 의미한다.</p><h2 id=시크릿-다루기>시크릿 다루기</h2><h3 id=시크릿-생성하기>시크릿 생성하기</h3><p>시크릿 생성에는 다음과 같은 방법이 있다.</p><ul><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kubectl/><code>kubectl</code> 명령으로 시크릿 생성</a></li><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-config-file/>환경 설정 파일을 사용하여 시크릿 생성</a></li><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomize를 사용하여 시크릿 생성</a></li></ul><h4 id=restriction-names-data>시크릿 이름 및 데이터에 대한 제약 사항</h4><p>시크릿 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><p>사용자는 시크릿을 위한 파일을 구성할 때 <code>data</code> 및 (또는) <code>stringData</code> 필드를
명시할 수 있다. 해당 <code>data</code> 와 <code>stringData</code> 필드는 선택적으로 명시할 수 있다.
<code>data</code> 필드의 모든 키(key)에 해당하는 값(value)은 base64로 인코딩된 문자열이어야 한다.
만약 사용자에게 base64로의 문자열 변환이 적합하지 않다면,
임의의 문자열을 값으로 받는 <code>stringData</code> 필드를 대신 사용할 수 있다.</p><p><code>data</code> 및 <code>stringData</code>의 키는 영숫자 문자,
<code>-</code>, <code>_</code>, 또는 <code>.</code> 으로 구성되어야 한다. <code>stringData</code> 필드의 모든 키-값 쌍은 의도적으로
<code>data</code> 필드로 합쳐진다. 만약 키가 <code>data</code> 와 <code>stringData</code> 필드 모두에 정의되어
있으면, <code>stringData</code> 필드에 지정된 값이
우선적으로 사용된다.</p><h4 id=restriction-data-size>크기 제한</h4><p>개별 시크릿의 크기는 1 MiB로 제한된다.
이는 API 서버 및 kubelet 메모리를 고갈시킬 수 있는 매우 큰 시크릿의 생성을 방지하기 위함이다.
그러나, 작은 크기의 시크릿을 많이 만드는 것도 메모리를 고갈시킬 수 있다.
<a href=/ko/docs/concepts/policy/resource-quotas/>리소스 쿼터</a>를 사용하여
한 네임스페이스의 시크릿 (또는 다른 리소스) 수를 제한할 수 있다.</p><h3 id=시크릿-편집하기>시크릿 편집하기</h3><p>kubectl을 사용하여 기존 시크릿을 편집할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit secrets mysecret
</span></span></code></pre></div><p>이렇게 하면 기본으로 설정된 에디터가 열리며,
다음과 같이 <code>data</code> 필드에 base64로 인코딩된 시크릿 값을 업데이트할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 아래 오브젝트를 수정한다. &#39;#&#39;로 시작하는 줄은 무시되고,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 빈 파일을 저장하면 편집이 취소된다. 이 파일을 저장하는 도중에 오류가 발생하면</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 관련 오류와 함께 파일이 다시 열릴 것이다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>{<span style=color:#bbb> </span>... }<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2020-01-22T18:41:56Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;164619&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>cfee02d6-c137-11e5-8d73-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><p>위의 예시 매니페스트는 <code>data</code>에 <code>username</code> 및 <code>password</code> 2개의 키를 갖는 시크릿을 정의한다.
매니페스트에서 이 값들은 Base64 문자열이지만,
이 시크릿을 파드에 대해 사용할 때에는 kubelet이 파드와 컨테이너에 <em>디코드된</em> 데이터를 제공한다.</p><p>한 시크릿에 여러 키 및 값을 넣을 수도 있고, 여러 시크릿으로 정의할 수도 있으며, 둘 중 편리한 쪽을 고르면 된다.</p><h3 id=시크릿-사용하기>시크릿 사용하기</h3><p>시크릿은 데이터 볼륨으로 마운트되거나 파드의 컨테이너에서 사용할
<a class=glossary-tooltip title='컨테이너 환경 변수는 파드에서 동작 중인 컨테이너에 유용한 정보를 제공하기 위한 이름=값 쌍이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/containers/container-environment/ target=_blank aria-label='환경 변수'>환경 변수</a>로
노출될 수 있다. 또한, 시크릿은 파드에 직접 노출되지 않고,
시스템의 다른 부분에서도 사용할 수 있다. 예를 들어, 시크릿은
시스템의 다른 부분이 사용자를 대신해서 외부 시스템과 상호 작용하는 데 사용해야 하는
자격 증명을 보유할 수 있다.</p><p>특정된 오브젝트 참조(reference)가 실제로 시크릿 유형의 오브젝트를 가리키는지 확인하기 위해,
시크릿 볼륨 소스의 유효성이 검사된다.
따라서, 시크릿은 자신에 의존하는 파드보다 먼저 생성되어야 한다.</p><p>시크릿을 가져올 수 없는 경우
(아마도 시크릿이 존재하지 않거나, 또는 API 서버에 대한 일시적인 연결 불가로 인해)
kubelet은 해당 파드 실행을 주기적으로 재시도한다.
kubelet은 또한 시크릿을 가져올 수 없는 문제에 대한 세부 정보를 포함하여 해당 파드에 대한 이벤트를 보고한다.</p><h4 id=restriction-secret-must-exist>선택적 시크릿</h4><p>시크릿을 기반으로 컨테이너 환경 변수를 정의하는 경우,
이 환경 변수를 <em>선택 사항</em> 으로 표시할 수 있다.
기본적으로는 시크릿은 필수 사항이다.</p><p>모든 필수 시크릿이 사용 가능해지기 전에는
파드의 컨테이너가 시작되지 않을 것이다.</p><p>파드가 시크릿의 특정 키를 참조하고, 해당 시크릿이 존재하지만 해당 키가 존재하지 않는 경우,
파드는 시작 과정에서 실패한다.</p><h3 id=using-secrets-as-files-from-a-pod>파드에서 시크릿을 파일처럼 사용하기</h3><p>파드 안에서 시크릿의 데이터에 접근하고 싶다면, 한 가지 방법은
쿠버네티스로 하여금 해당 시크릿의 값을
파드의 하나 이상의 컨테이너의 파일시스템 내에 파일 형태로 표시하도록 만드는 것이다.</p><p>이렇게 구성하려면, 다음을 수행한다.</p><ol><li>시크릿을 생성하거나 기존 시크릿을 사용한다. 여러 파드가 동일한 시크릿을 참조할 수 있다.</li><li><code>.spec.volumes[].</code> 아래에 볼륨을 추가하려면 파드 정의를 수정한다. 볼륨의 이름을 뭐든지 지정하고, 시크릿 오브젝트의 이름과 동일한 <code>.spec.volumes[].secret.secretName</code> 필드를 생성한다.</li><li>시크릿이 필요한 각 컨테이너에 <code>.spec.containers[].volumeMounts[]</code> 를 추가한다. 시크릿을 표시하려는 사용되지 않은 디렉터리 이름에 <code>.spec.containers[].volumeMounts[].readOnly = true</code> 와 <code>.spec.containers[].volumeMounts[].mountPath</code> 를 지정한다.</li><li>프로그램이 해당 디렉터리에서 파일을 찾도록 이미지 또는 커맨드 라인을 수정한다. 시크릿 <code>data</code> 맵의 각 키는 <code>mountPath</code> 아래의 파일명이 된다.</li></ol><p>다음은 볼륨에 <code>mysecret</code>이라는 시크릿을 마운트하는 파드의 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 기본값임; &#34;mysecret&#34; 은 반드시 존재해야 함</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>사용하려는 각 시크릿은 <code>.spec.volumes</code> 에서 참조해야 한다.</p><p>파드에 여러 컨테이너가 있는 경우, 모든 컨테이너는
자체 <code>volumeMounts</code> 블록이 필요하지만, 시크릿에 대해서는 시크릿당 하나의 <code>.spec.volumes</code> 만 필요하다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>쿠버네티스 v1.22 이전 버전은 쿠버네티스 API에 접근하기 위한 크리덴셜을 자동으로 생성했다.
이러한 예전 메커니즘은 토큰 시크릿 생성 및 이를 실행 중인 파드에 마운트하는 절차에 기반했다.
쿠버네티스 v1.25 버전을 포함한 최근 버전에서는,
API 크리덴셜이 <a href=/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a> API를 사용하여 직접 얻어지고,
<a href=/ko/docs/reference/access-authn-authz/service-accounts-admin/#%EB%B0%94%EC%9D%B8%EB%94%A9%EB%90%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%96%B4%EC%B9%B4%EC%9A%B4%ED%8A%B8-%ED%86%A0%ED%81%B0-%EB%B3%BC%EB%A5%A8>프로젝티드 볼륨</a>을
사용하여 파드 내에 마운트된다.
이러한 방법을 사용하여 얻은 토큰은 수명이 제한되어 있으며,
토큰이 탑재된 파드가 삭제되면 자동으로 무효화된다.</p><p>여전히 서비스 어카운트 토큰 시크릿을 <a href=/docs/tasks/configure-pod-container/configure-service-account/#manually-create-a-service-account-api-token>수동으로 생성</a>할 수도 있다.
예를 들어, 영원히 만료되지 않는 토큰이 필요한 경우에 활용할 수 있다.
그러나, 이렇게 하기보다는 API 접근에 필요한 토큰을 얻기 위해
<a href=/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a> 서브리소스를 사용하는 것을 권장한다.
<code>TokenRequest</code> API로부터 토큰을 얻기 위해
<a href=/docs/reference/generated/kubectl/kubectl-commands#-em-token-em-><code>kubectl create token</code></a> 커맨드를 사용할 수 있다.</p></div><h4 id=특정-경로에-대한-시크릿-키-투영하기>특정 경로에 대한 시크릿 키 투영하기</h4><p>시크릿 키가 투영되는 볼륨 내 경로를 제어할 수도 있다.
<code>.spec.volumes[].secret.items</code> 필드를 사용하여 각 키의 대상 경로를 변경할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span></code></pre></div><p>다음과 같은 일들이 일어날 것이다.</p><ul><li><code>mysecret</code>의 <code>username</code> 키는 컨테이너의 <code>/etc/foo/username</code> 경로 대신
<code>/etc/foo/my-group/my-username</code> 경로에서 사용 가능하다.</li><li>시크릿 오브젝트의 <code>password</code> 키는 투영되지 않는다.</li></ul><p><code>.spec.volumes[].secret.items</code> 를 사용하면, <code>items</code> 에 지정된 키만 투영된다.
시크릿의 모든 키를 사용하려면, 모든 키가 <code>items</code> 필드에 나열되어야 한다.</p><p>키를 명시적으로 나열했다면, 나열된 모든 키가 해당 시크릿에 존재해야 한다.
그렇지 않으면, 볼륨이 생성되지 않는다.</p><h4 id=시크릿-파일-퍼미션>시크릿 파일 퍼미션</h4><p>단일 시크릿 키에 대한 POSIX 파일 접근 퍼미션 비트를 설정할 수 있다.
만약 사용자가 퍼미션을 지정하지 않는다면, 기본적으로 <code>0644</code> 가 사용된다.
전체 시크릿 볼륨에 대한 기본 모드를 설정하고 필요한 경우 키별로 오버라이드할 수도 있다.</p><p>예를 들어, 다음과 같은 기본 모드를 지정할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>0400</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>시크릿이 <code>/etc/foo</code> 에 마운트되고,
시크릿 볼륨 마운트로 생성된 모든 파일의 퍼미션은 <code>0400</code> 이다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> JSON을 사용하여 파드 또는 파드 템플릿을 정의하는 경우,
JSON 스펙은 8진수 표기법을 지원하지 않음에 유의한다.
<code>defaultMode</code> 값으로 대신 10진수를 사용할 수 있다(예를 들어, 8진수 0400은 10진수로는 256이다).
YAML로 작성하는 경우, <code>defaultMode</code> 값을 8진수로 표기할 수 있다.</div><h4 id=볼륨으로부터-시크릿-값-사용하기>볼륨으로부터 시크릿 값 사용하기</h4><p>시크릿 볼륨을 마운트하는 컨테이너 내부에서, 시크릿 키는 파일 형태로 나타난다.
시크릿 값은 base64로 디코딩되어 이러한 파일 내에 저장된다.</p><p>다음은 위 예시의 컨테이너 내부에서 실행된 명령의 결과이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /etc/foo/
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>username
password
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/username
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/password
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><p>컨테이너의 프로그램은 필요에 따라
이러한 파일에서 시크릿 데이터를 읽는다.</p><h4 id=마운트된-시크릿은-자동으로-업데이트됨>마운트된 시크릿은 자동으로 업데이트됨</h4><p>볼륨이 시크릿의 데이터를 포함하고 있는 상태에서 시크릿이 업데이트되면, 쿠버네티스는 이를 추적하고
최종적으로 일관된(eventually-consistent) 접근 방식을 사용하여 볼륨 안의 데이터를 업데이트한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 시크릿을 <a href=/ko/docs/concepts/storage/volumes/#subpath-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>subPath</a>
볼륨 마운트로 사용하는 컨테이너는 자동 시크릿 업데이트를
받지 못한다.</div><p>kubelet은 해당 노드의 파드의 볼륨에서 사용되는 시크릿의 현재 키 및 값 캐시를 유지한다.
kubelet이 캐시된 값에서 변경 사항을 감지하는 방식을 변경할 수 있다.
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>kubelet 환경 설정</a>의 <code>configMapAndSecretChangeDetectionStrategy</code> 필드는
kubelet이 사용하는 전략을 제어한다. 기본 전략은 <code>Watch</code>이다.</p><p>시크릿 업데이트는 TTL(time-to-live)이 설정된 캐시 기반의
API 감시(watch) 메커니즘에 의해 전파되거나 (기본값임),
각 kubelet 동기화 때마다 클러스터 API 서버로부터의 폴링으로 달성될 수 있다.</p><p>결과적으로 시크릿이 업데이트되는 순간부터
새 키가 파드에 투영되는 순간까지의 총 지연은
kubelet 동기화 기간 + 캐시 전파 지연만큼 길어질 수 있다.
여기서 캐시 전파 지연은 선택한 캐시 유형에 따라 다르다(이전 단락과 동일한 순서로 나열하면,
감시(watch) 전파 지연, 설정된 캐시 TTL, 또는 직접 폴링의 경우 0임).</p><h3 id=시크릿을-환경-변수-형태로-사용하기>시크릿을 환경 변수 형태로 사용하기</h3><p>파드에서 <a class=glossary-tooltip title='컨테이너 환경 변수는 파드에서 동작 중인 컨테이너에 유용한 정보를 제공하기 위한 이름=값 쌍이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/containers/container-environment/ target=_blank aria-label='환경 변수'>환경 변수</a> 형태로
시크릿을 사용하려면 다음과 같이 한다.</p><ol><li>시크릿을 생성(하거나 기존 시크릿을 사용)한다. 여러 파드가 동일한 시크릿을 참조할 수 있다.</li><li>사용하려는 각 시크릿 키에 대한 환경 변수를 추가하려면
시크릿 키 값을 사용하려는 각 컨테이너에서 파드 정의를 수정한다.
시크릿 키를 사용하는 환경 변수는 시크릿의 이름과 키를 <code>env[].valueFrom.secretKeyRef</code> 에 채워야 한다.</li><li>프로그램이 지정된 환경 변수에서 값을 찾도록
이미지 및/또는 커맨드 라인을 수정한다.</li></ol><p>다음은 환경 변수를 통해 시크릿을 사용하는 파드의 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 기본값과 동일하다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                            </span><span style=color:#080;font-style:italic># &#34;mysecret&#34;이 존재하고 &#34;username&#34;라는 키를 포함해야 한다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 기본값과 동일하다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                            </span><span style=color:#080;font-style:italic># &#34;mysecret&#34;이 존재하고 &#34;password&#34;라는 키를 포함해야 한다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=restriction-env-from-invalid>올바르지 않은 환경 변수</h4><p>유효하지 않은 환경 변수 이름으로 간주되는 키가 있는 <code>envFrom</code> 필드로
환경 변수를 채우는 데 사용되는 시크릿은 해당 키를 건너뛴다.
하지만 파드를 시작할 수는 있다.</p><p>유효하지 않은 변수 이름이 파드 정의에 포함되어 있으면,
<code>reason</code>이 <code>InvalidVariableNames</code>로 설정된 이벤트와
유효하지 않은 스킵된 키 목록 메시지가 파드 시작 실패 정보에 추가된다.
다음 예시는 2개의 유효하지 않은 키 <code>1badkey</code> 및 <code>2alsobad</code>를 포함하는 <code>mysecret</code> 시크릿을 참조하는 파드를 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>출력은 다음과 같다.</p><pre tabindex=0><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</code></pre><h4 id=환경-변수로부터-시크릿-값-사용하기>환경 변수로부터 시크릿 값 사용하기</h4><p>환경 변수 형태로 시크릿을 사용하는 컨테이너 내부에서,
시크릿 키는 일반적인 환경 변수로 보인다.
이러한 환경 변수의 값은 시크릿 데이터를 base64 디코드한 값이다.</p><p>다음은 위 예시 컨테이너 내부에서 실행된 명령의 결과이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#b8860b>$SECRET_USERNAME</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#b8860b>$SECRET_PASSWORD</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 컨테이너가 이미 환경 변수 형태로 시크릿을 사용하는 경우,
컨테이너가 다시 시작되기 전에는
시크릿 업데이트를 볼 수 없다.
시크릿이 변경되면 컨테이너 재시작을 트리거하는 써드파티 솔루션이 존재한다.</div><h3 id=using-imagepullsecrets>컨테이너 이미지 풀 시크릿</h3><p>비공개 저장소에서 컨테이너 이미지를 가져오고 싶다면,
각 노드의 kubelet이 해당 저장소에 인증을 수행하는 방법을 마련해야 한다.
이를 위해 <em>이미지 풀 시크릿</em> 을 구성할 수 있다.
이러한 시크릿은 파드 수준에 설정된다.</p><p>파드의 <code>imagePullSecrets</code> 필드는 파드가 속한 네임스페이스에 있는 시크릿들에 대한 참조 목록이다.
<code>imagePullSecrets</code>를 사용하여 이미지 저장소 접근 크리덴셜을 kubelet에 전달할 수 있다.
kubelet은 이 정보를 사용하여 파드 대신 비공개 이미지를 가져온다.
<code>imagePullSecrets</code> 필드에 대한 더 많은 정보는
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>파드 API 레퍼런스</a>의
<code>PodSpec</code> 부분을 확인한다.</p><h4 id=imagepullsecrets-사용하기>imagePullSecrets 사용하기</h4><p><code>imagePullSecrets</code> 필드는 동일한 네임스페이스의 시크릿에 대한 참조 목록이다.
<code>imagePullSecrets</code> 를 사용하여 도커(또는 다른 컨테이너) 이미지 레지스트리 비밀번호가 포함된 시크릿을 kubelet에 전달할 수 있다.
kubelet은 이 정보를 사용해서 파드를 대신하여 프라이빗 이미지를 가져온다.
<code>imagePullSecrets</code> 필드에 대한 자세한 정보는 <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec API</a>를 참고한다.</p><h5 id=imagepullsecret-수동으로-지정하기>imagePullSecret 수동으로 지정하기</h5><p><a href=/ko/docs/concepts/containers/images/#%ED%8C%8C%EB%93%9C%EC%97%90-imagepullsecrets-%EB%AA%85%EC%8B%9C>컨테이너 이미지</a> 문서에서
<code>imagePullSecrets</code>를 지정하는 방법을 배울 수 있다.</p><h5 id=imagepullsecrets가-자동으로-연결되도록-준비하기>imagePullSecrets가 자동으로 연결되도록 준비하기</h5><p>수동으로 <code>imagePullSecrets</code> 를 생성하고,
서비스어카운트(ServiceAccount)에서 이들을 참조할 수 있다.
해당 서비스어카운트로 생성되거나 기본적인 서비스어카운트로 생성된 모든 파드는
파드의 <code>imagePullSecrets</code> 필드를 가져오고 서비스 어카운트의 필드로 설정한다.
해당 프로세스에 대한 자세한 설명은
<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>서비스 어카운트에 ImagePullSecrets 추가하기</a>를 참고한다.</p><h3 id=restriction-static-pod>스태틱 파드에서의 시크릿 사용</h3><p><a class=glossary-tooltip title='특정 노드의 Kubelet 데몬이 직접 관리하는 파드' data-toggle=tooltip data-placement=top href=/ko/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='스태틱(static) 파드'>스태틱(static) 파드</a>에서는
컨피그맵이나 시크릿을 사용할 수 없다.</p><h2 id=사용-사레>사용 사레</h2><h3 id=사용-사례-컨테이너-환경-변수로-사용하기>사용 사례: 컨테이너 환경 변수로 사용하기</h3><p>시크릿 정의를 작성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>USER_NAME</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>PASSWORD</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><p>시크릿을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f mysecret.yaml
</span></span></code></pre></div><p>모든 시크릿 데이터를 컨테이너 환경 변수로 정의하는 데 <code>envFrom</code> 을 사용한다. 시크릿의 키는 파드의 환경 변수 이름이 된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=사용-사례-ssh-키를-사용하는-파드>사용 사례: SSH 키를 사용하는 파드</h3><p>몇 가지 SSH 키를 포함하는 시크릿을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>secret &#34;ssh-key-secret&#34; created
</code></pre><p>SSH 키를 포함하는 <code>secretGenerator</code> 필드가 있는 <code>kustomization.yaml</code> 를 만들 수도 있다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong><p>사용자 자신의 SSH 키를 보내기 전에 신중하게 생각한다.
클러스터의 다른 사용자가 시크릿에 접근할 수 있게 될 수도 있기 때문이다.</p><p>대신, 쿠버네티스 클러스터를 공유하는 모든 사용자가 접근할 수 있으면서도,
크리덴셜이 유출된 경우 폐기가 가능한 서비스 아이덴티티를 가리키는
SSH 프라이빗 키를 만들 수 있다.</p></div><p>이제 SSH 키를 가진 시크릿을 참조하고
볼륨에서 시크릿을 사용하는 파드를 만들 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>컨테이너의 명령이 실행될 때, 다음 위치에서 키 부분을 사용할 수 있다.</p><pre tabindex=0><code>/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre><p>그러면 컨테이너는 SSH 연결을 맺기 위해 시크릿 데이터를 자유롭게 사용할 수 있다.</p><h3 id=사용-사례-운영-테스트-자격-증명을-사용하는-파드>사용 사례: 운영 / 테스트 자격 증명을 사용하는 파드</h3><p>이 예제에서는
운영 환경의 자격 증명이 포함된 시크릿을 사용하는 파드와
테스트 환경의 자격 증명이 있는 시크릿을 사용하는 다른 파드를 보여준다.</p><p>사용자는 <code>secretGenerator</code> 필드가 있는 <code>kustomization.yaml</code> 을 만들거나
<code>kubectl create secret</code> 을 실행할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>secret &#34;prod-db-secret&#34; created
</code></pre><p>테스트 환경의 자격 증명에 대한 시크릿을 만들 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>secret &#34;test-db-secret&#34; created
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p><code>$</code>, <code>\</code>, <code>*</code>, <code>=</code> 그리고 <code>!</code> 와 같은 특수 문자는 사용자의 <a href=https://ko.wikipedia.org/wiki/%EC%85%B8>셸</a>에 의해 해석되고 이스케이핑이 필요하다.</p><p>대부분의 셸에서 비밀번호를 이스케이프하는 가장 쉬운 방법은 작은 따옴표(<code>'</code>)로 묶는 것이다.
예를 들어, 실제 비밀번호가 <code>S!B\*d$zDsb=</code> 이면, 다음과 같은 명령을 실행해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</span></span></code></pre></div><p>파일(<code>--from-file</code>)에서는 비밀번호의 특수 문자를 이스케이프할 필요가 없다.</p></div><p>이제 파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: List
</span></span></span><span style=display:flex><span><span style=color:#b44>items:
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: prod-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: prod-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: prod-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: test-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: test-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: test-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>동일한 <code>kustomization.yaml</code>에 파드를 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>다음을 실행하여 API 서버에 이러한 모든 오브젝트를 적용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><p>두 컨테이너 모두 각 컨테이너의 환경에 대한 값을 가진 파일시스템에
다음의 파일이 존재한다.</p><pre tabindex=0><code>/etc/secret-volume/username
/etc/secret-volume/password
</code></pre><p>두 파드의 사양이 한 필드에서만 어떻게 다른지 확인한다. 이를 통해
공통 파드 템플릿에서 다양한 기능을 가진 파드를 생성할 수 있다.</p><p>두 개의 서비스 어카운트를 사용하여 기본 파드 명세를 더욱 단순화할 수 있다.</p><ol><li><code>prod-db-secret</code> 을 가진 <code>prod-user</code></li><li><code>test-db-secret</code> 을 가진 <code>test-user</code></li></ol><p>파드 명세는 다음과 같이 단축된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=사용-사례-시크릿-볼륨의-도트-파일-dotfile>사용 사례: 시크릿 볼륨의 도트 파일(dotfile)</h3><p>점으로 시작하는 키를 정의하여 데이터를 "숨김"으로 만들 수 있다.
이 키는 도트 파일 또는 "숨겨진" 파일을 나타낸다.
예를 들어, 다음 시크릿이 <code>secret-volume</code> 볼륨에 마운트되면 아래와 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>볼륨은 <code>.secret-file</code> 이라는 하나의 파일을 포함하고,
<code>dotfile-test-container</code> 는 <code>/etc/secret-volume/.secret-file</code> 경로에
이 파일을 가지게 된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>ls -l</code> 명령의 결과에서 숨겨진 점으로 시작하는 파일들은
디렉터리 내용을 나열할 때 <code>ls -la</code> 를 사용해야 이 파일들을 볼 수 있다.</div><h3 id=사용-사례-파드의-한-컨테이너에-표시되는-시크릿>사용 사례: 파드의 한 컨테이너에 표시되는 시크릿</h3><p>HTTP 요청을 처리하고, 복잡한 비즈니스 로직을 수행한 다음, HMAC이 있는 일부 메시지에
서명해야 하는 프로그램을 고려한다. 애플리케이션 로직이
복잡하기 때문에, 서버에서 눈에 띄지 않는 원격 파일 읽기 공격이
있을 수 있으며, 이로 인해 개인 키가 공격자에게 노출될 수 있다.</p><p>이는 두 개의 컨테이너의 두 개 프로세스로 나눌 수 있다. 사용자 상호 작용과
비즈니스 로직을 처리하지만, 개인 키를 볼 수 없는 프론트엔드 컨테이너와
개인 키를 볼 수 있고, 프론트엔드의 간단한 서명 요청(예를 들어, localhost 네트워킹을 통해)에
응답하는 서명자 컨테이너로 나눌 수 있다.</p><p>이 분할된 접근 방식을 사용하면, 공격자는 이제 애플리케이션 서버를 속여서
파일을 읽는 것보다 다소 어려운 임의적인 어떤 작업을 수행해야
한다.</p><h2 id=secret-types>시크릿 타입</h2><p>시크릿을 생성할 때, <a href=/docs/reference/generated/kubernetes-api/v1.25/#secret-v1-core><code>Secret</code></a>
리소스의 <code>type</code> 필드를 사용하거나, (활용 가능하다면) <code>kubectl</code> 의
유사한 특정 커맨드라인 플래그를 사용하여 시크릿의 타입을 명시할 수 있다.
시크릿 타입은 여러 종류의 기밀 데이터를 프로그래밍 방식으로 용이하게 처리하기 위해 사용된다.</p><p>쿠버네티스는 일반적인 사용 시나리오를 위해 몇 가지 빌트인 타입을 제공한다.
이 타입은 쿠버네티스가 부과하여 수행되는 검증 및 제약에
따라 달라진다.</p><table><thead><tr><th>빌트인 타입</th><th>사용처</th></tr></thead><tbody><tr><td><code>Opaque</code></td><td>임의의 사용자 정의 데이터</td></tr><tr><td><code>kubernetes.io/service-account-token</code></td><td>서비스 어카운트 토큰</td></tr><tr><td><code>kubernetes.io/dockercfg</code></td><td>직렬화 된(serialized) <code>~/.dockercfg</code> 파일</td></tr><tr><td><code>kubernetes.io/dockerconfigjson</code></td><td>직렬화 된 <code>~/.docker/config.json</code> 파일</td></tr><tr><td><code>kubernetes.io/basic-auth</code></td><td>기본 인증을 위한 자격 증명(credential)</td></tr><tr><td><code>kubernetes.io/ssh-auth</code></td><td>SSH를 위한 자격 증명</td></tr><tr><td><code>kubernetes.io/tls</code></td><td>TLS 클라이언트나 서버를 위한 데이터</td></tr><tr><td><code>bootstrap.kubernetes.io/token</code></td><td>부트스트랩 토큰 데이터</td></tr></tbody></table><p>사용자는 시크릿 오브젝트의 <code>type</code> 값에 비어 있지 않은 문자열을 할당하여 자신만의 시크릿 타입을 정의하고 사용할 수 있다
(비어 있는 문자열은 <code>Opaque</code> 타입으로 인식된다).</p><p>쿠버네티스는 타입 명칭에 제약을 부과하지는 않는다.
그러나 만약 빌트인 타입 중 하나를 사용한다면,
해당 타입에 정의된 모든 요구 사항을 만족시켜야 한다.</p><p>공개 사용을 위한 시크릿 타입을 정의하는 경우, 규칙에 따라
<code>cloud-hosting.example.net/cloud-api-credentials</code>와 같이 시크릿 타입 이름 앞에 도메인 이름 및 <code>/</code>를 추가하여
전체 시크릿 타입 이름을 구성한다.</p><h3 id=불투명-opaque-시크릿>불투명(Opaque) 시크릿</h3><p><code>Opaque</code> 은 시크릿 구성 파일에서 시크릿 타입을 지정하지 않았을 경우의 기본 시크릿 타입이다.
<code>kubectl</code> 을 사용하여 시크릿을 생성할 때 <code>Opaque</code> 시크릿 타입을 나타내기
위해서는 <code>generic</code> 하위 커맨드를 사용할 것이다. 예를 들어, 다음 커맨드는
타입 <code>Opaque</code> 의 비어 있는 시크릿을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic empty-secret
</span></span><span style=display:flex><span>kubectl get secret empty-secret
</span></span></code></pre></div><p>출력은 다음과 같다.</p><pre tabindex=0><code>NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
</code></pre><p>해당 <code>DATA</code> 열은 시크릿에 저장된 데이터 아이템의 수를 보여준다.
이 경우, <code>0</code> 은 비어 있는 시크릿을 생성하였다는 것을 의미한다.</p><h3 id=서비스-어카운트-토큰-시크릿>서비스 어카운트 토큰 시크릿</h3><p><code>kubernetes.io/service-account-token</code> 시크릿 타입은
<a class=glossary-tooltip title='파드에서 실행 중인 프로세스를 위한 신원(identity)을 제공한다.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label='서비스 어카운트'>서비스 어카운트</a>를 확인하는
토큰 자격증명을 저장하기 위해서 사용한다.</p><p>1.22 버전 이후로는 이러한 타입의 시크릿은 더 이상 파드에 자격증명을 마운트하는 데 사용되지 않으며,
서비스 어카운트 토큰 시크릿 오브젝트를 사용하는 대신
<a href=/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a> API를 통해 토큰을 얻는 것이 추천된다.
<code>TokenRequest</code> API에서 얻은 토큰은 제한된 수명을 가지며 다른 API 클라이언트에서 읽을 수 없기 때문에
시크릿 오브젝트에 저장된 토큰보다 더 안전하다.
<code>TokenRequest</code> API에서 토큰을 얻기 위해서
<a href=/docs/reference/generated/kubectl/kubectl-commands#-em-token-em-><code>kubectl create token</code></a> 커맨드를 사용할 수 있다.</p><p>토큰을 얻기 위한 <code>TokenRequest</code> API를 사용할 수 없는 경우에는
서비스 어카운트 토큰 시크릿 오브젝트를 생성할 수 밖에 없으나,
이는 만료되지 않는 토큰 자격증명을 읽기 가능한 API 오브젝트로
지속되는 보안 노출 상황을 감수할 수 있는 경우에만 생성해야 한다.</p><p>이 시크릿 타입을 사용할 때는,
<code>kubernetes.io/service-account.name</code> 어노테이션이 존재하는
서비스 어카운트 이름으로 설정되도록 해야 한다. 만약 서비스 어카운트와
시크릿 오브젝트를 모두 생성하는 경우, 서비스 어카운트를 먼저 생성해야만 한다.</p><p>시크릿이 생성된 후, 쿠버네티스 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는
<code>kubernetes.io/service-account.uid</code> 어노테이션 및
인증 토큰을 보관하고 있는 <code>data</code> 필드의 <code>token</code> 키와 같은 몇 가지 다른 필드들을 채운다.</p><p>다음은 서비스 어카운트 토큰 시크릿의 구성 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-sa-sample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sa-name&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 사용자는 불투명 시크릿을 사용하므로 추가적인 키 값 쌍을 포함할 수 있다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb> </span>YmFyCg==<span style=color:#bbb>
</span></span></span></code></pre></div><p>시크릿을 만든 후, 쿠버네티스가 <code>data</code> 필드에 <code>token</code> 키를 채울 때까지 기다린다.</p><p><a href=/docs/tasks/configure-pod-container/configure-service-account/>서비스 어카운트</a> 문서를 보면
서비스 어카운트가 동작하는 방법에 대한 더 자세한 정보를 얻을 수 있다.
또한 파드에서 서비스 어카운트 자격증명을 참조하는 방법에 대한 정보는
<a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core><code>Pod</code></a>의
<code>automountServiceAccountToken</code> 필드와 <code>serviceAccountName</code>
필드를 통해 확인할 수 있다.</p><h3 id=도커-컨피그-시크릿>도커 컨피그 시크릿</h3><p>이미지에 대한 도커 레지스트리 접속 자격 증명을 저장하기 위한
시크릿을 생성하기 위해서 다음의 <code>type</code> 값 중 하나를 사용할 수 있다.</p><ul><li><code>kubernetes.io/dockercfg</code></li><li><code>kubernetes.io/dockerconfigjson</code></li></ul><p><code>kubernetes.io/dockercfg</code> 는 직렬화된 도커 커맨드라인 구성을
위한 기존(legacy) 포맷 <code>~/.dockercfg</code> 를 저장하기 위해 할당된 타입이다.
시크릿 타입을 사용할 때는, <code>data</code> 필드가 base64 포맷으로
인코딩된 <code>~/.dockercfg</code> 파일의 콘텐츠를 값으로 가지는 <code>.dockercfg</code> 키를 포함하고 있는지
확실히 확인해야 한다.</p><p><code>kubernetes.io/dockerconfigjson</code> 타입은 <code>~/.dockercfg</code> 의
새로운 포맷인 <code>~/.docker/config.json</code> 파일과 동일한 포맷 법칙을
따르는 직렬화 된 JSON의 저장을 위해 디자인되었다.
이 시크릿 타입을 사용할 때는, 시크릿 오브젝트의 <code>data</code> 필드가 <code>.dockerconfigjson</code> 키를
꼭 포함해야 한다. <code>~/.docker/config.json</code> 파일을 위한 콘텐츠는
base64로 인코딩된 문자열으로 제공되어야 한다.</p><p>아래는 시크릿의 <code>kubernetes.io/dockercfg</code> 타입 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockercfg</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span><span style=color:#b44>&#34;&lt;base64 encoded ~/.dockercfg file&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 만약 base64 인코딩 수행을 원하지 않는다면,
그 대신 <code>stringData</code> 필드를 사용할 수 있다.</div><p>이러한 타입들을 매니페스트를 사용하여 생성하는 경우, API
서버는 해당 <code>data</code> 필드에 기대하는 키가 존재하는지 확인하고,
제공된 값이 유효한 JSON으로 파싱될 수 있는지 검증한다. API
서버가 해당 JSON이 실제 도커 컨피그 파일인지를 검증하지는 않는다.</p><p>도커 컨피그 파일을 가지고 있지 않거나 도커 레지스트리 시크릿을 생성하기
위해 <code>kubectl</code> 을 사용하고 싶은 경우, 다음과 같이 처리할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry secret-tiger-docker <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>tiger@acme.example <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>tiger <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>pass1234 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-server<span style=color:#666>=</span>my-registry.example:5000
</span></span></code></pre></div><p>이 커맨드는 <code>kubernetes.io/dockerconfigjson</code> 타입의 시크릿을 생성한다.
다음 명령으로 이 새 시크릿에서 <code>.data.dockerconfigjson</code> 필드를 덤프하고
base64로 디코드하면,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret secret-tiger-docker -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.*}&#39;</span> | base64 -d
</span></span></code></pre></div><p>출력은 다음과 같은 JSON 문서이다(그리고
이는 또한 유효한 도커 구성 파일이다).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;my-registry.example:5000&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;tiger&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;pass1234&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;email&#34;</span>: <span style=color:#b44>&#34;tiger@acme.example&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;dGlnZXI6cGFzczEyMzQ=&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 위의 <code>auth</code> 값은 base64 인코딩되어 있다. 이는 난독화된 것이지 암호화된 것이 아니다.
이 시크릿을 읽을 수 있는 사람은 레지스트리 접근 베어러 토큰을 알 수 있는 것이다.</div><h3 id=기본-인증-basic-authentication-시크릿>기본 인증(Basic authentication) 시크릿</h3><p><code>kubernetes.io/basic-auth</code> 타입은 기본 인증을 위한 자격 증명을 저장하기
위해 제공된다. 이 시크릿 타입을 사용할 때는 시크릿의 <code>data</code> 필드가
다음의 두 키 중 하나를 포함해야 한다.</p><ul><li><code>username</code>: 인증을 위한 사용자 이름</li><li><code>password</code>: 인증을 위한 암호나 토큰</li></ul><p>위의 두 키에 대한 두 값은 모두 base64로 인코딩된 문자열이다. 물론,
시크릿 생성 시 <code>stringData</code> 를 사용하여 평문 텍스트 콘텐츠(clear text content)를 제공할
수도 있다.</p><p>다음의 YAML은 기본 인증 시크릿을 위한 구성 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin     <span style=color:#bbb> </span><span style=color:#080;font-style:italic># kubernetes.io/basic-auth 에서 요구하는 필드</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>t0p-Secret<span style=color:#bbb> </span><span style=color:#080;font-style:italic># kubernetes.io/basic-auth 에서 요구하는 필드</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이 기본 인증 시크릿 타입은 오직 사용자 편의를 위해 제공되는 것이다.
사용자는 기본 인증에서 사용할 자격 증명을 위해 <code>Opaque</code> 타입의 시크릿을 생성할 수도 있다.
그러나, 미리 정의되어 공개된 시크릿 타입(<code>kubernetes.io/basic-auth</code>)을 사용하면
다른 사람이 이 시크릿의 목적을 이해하는 데 도움이 되며,
예상되는 키 이름에 대한 규칙이 설정된다.
쿠버네티스 API는 이 유형의 시크릿에 대해
필수 키가 설정되었는지 확인한다.</p><h3 id=ssh-인증-시크릿>SSH 인증 시크릿</h3><p>이 빌트인 타입 <code>kubernetes.io/ssh-auth</code> 는 SSH 인증에 사용되는 데이터를
저장하기 위해서 제공된다. 이 시크릿 타입을 사용할 때는 <code>ssh-privatekey</code>
키-값 쌍을 사용할 SSH 자격 증명으로 <code>data</code> (또는 <code>stringData</code>)
필드에 명시해야 할 것이다.</p><p>다음 매니페스트는
SSH 공개/개인 키 인증에 사용되는 시크릿 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 본 예시를 위해 축약된 데이터임</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ssh-privatekey</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>     </span><span style=color:#bbb>     </span>MIIEpQIBAAKCAQEAulqb/Y ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>SSH 인증 시크릿 타입은 오직 사용자 편의를 위해 제공되는 것이다.
사용자는 SSH 인증에서 사용할 자격 증명을 위해 <code>Opaque</code> 타입의 시크릿을 생성할 수도 있다.
그러나, 미리 정의되어 공개된 시크릿 타입(<code>kubernetes.io/ssh-auth</code>)을 사용하면
다른 사람이 이 시크릿의 목적을 이해하는 데 도움이 되며,
예상되는 키 이름에 대한 규칙이 설정된다.
그리고 API 서버가
시크릿 정의에 필수 키가 명시되었는지 확인한다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> SSH 개인 키는 자체적으로 SSH 클라이언트와 호스트 서버 간에 신뢰할 수 있는 통신을
설정하지 않는다. 컨피그맵(ConfigMap)에 추가된 <code>known_hosts</code> 파일과 같은
"중간자(man in the middle)" 공격을 완화하려면 신뢰를 설정하는
2차 수단이 필요하다.</div><h3 id=tls-시크릿>TLS 시크릿</h3><p>쿠버네티스는 일반적으로 TLS를 위해 사용되는 인증서 및 관련된 키를 저장하기 위한
빌트인 시크릿 타입 <code>kubernetes.io/tls</code> 를 제공한다.</p><p>TLS 시크릿의 일반적인 용도 중 하나는 <a href=/ko/docs/concepts/services-networking/ingress/>인그레스</a>에 대한
전송 암호화(encryption in transit)를 구성하는 것이지만,
다른 리소스와 함께 사용하거나 워크로드에서 직접 사용할 수도 있다.
이 타입의 시크릿을 사용할 때는 <code>tls.key</code> 와 <code>tls.crt</code> 키가
시크릿 구성의 <code>data</code> (또는 <code>stringData</code>) 필드에서 제공되어야 한다.
그러나, API 서버가 각 키에 대한 값이 유효한지 실제로 검증하지는 않는다.</p><p>다음 YAML은 TLS 시크릿을 위한 구성 예시를 포함한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 본 예시를 위해 축약된 데이터임</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIC2DCCAcCgAwIBAgIBATANBgkqh ...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>TLS 시크릿 타입은 사용자 편의만을 위해서 제공된다. 사용자는 TLS 서버 및/또는
클라이언트를 위해 사용되는 자격 증명을 위한 <code>Opaque</code> 를 생성할 수도 있다. 그러나, 빌트인
시크릿 타입을 사용하는 것은 사용자의 자격 증명들의 포맷을 통합하는 데 도움이 되고,
API 서버는 요구되는 키가 시크릿 구성에서 제공되고 있는지 검증도 한다.</p><p><code>kubectl</code> 를 사용하여 TLS 시크릿을 생성할 때, <code>tls</code> 하위 커맨드를
다음 예시와 같이 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls my-tls-secret <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --cert<span style=color:#666>=</span>path/to/cert/file <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --key<span style=color:#666>=</span>path/to/key/file
</span></span></code></pre></div><p>공개/개인 키 쌍은 사전에 준비되어야 한다.
<code>--cert</code> 에 들어가는 공개 키 인증서는
<a href=https://datatracker.ietf.org/doc/html/rfc7468#section-5.1>RFC 7468의 섹션 5.1</a>에 있는 DER 형식이어야 하고,
<code>--key</code> 에 들어가는 개인 키 인증서는
<a href=https://datatracker.ietf.org/doc/html/rfc7468#section-11>RFC 7468의 섹션 11</a>에 있는 DER 형식 PKCS #8 을 따라야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p><code>kubernetes.io/tls</code> 시크릿은
키 및 인증서에 Base64 인코드된 DER 데이터를 보관한다.
개인 키 및 인증서에 사용되는 PEM 형식에 익숙하다면,
이 base64 데이터는 PEM 형식에서 맨 윗줄과 아랫줄을 제거한 것과 동일하다.</p><p>예를 들어, 인증서의 경우,
<code>--------BEGIN CERTIFICATE-----</code> 및 <code>-------END CERTIFICATE----</code> 줄은 포함되면 <strong>안</strong> 된다.</p></div><h3 id=부트스트랩-토큰-시크릿>부트스트랩 토큰 시크릿</h3><p>부트스트랩 토큰 시크릿은 시크릿 <code>type</code> 을 <code>bootstrap.kubernetes.io/token</code> 으로
명확하게 지정하면 생성할 수 있다. 이 타입의 시크릿은 노드 부트스트랩 과정 중에 사용되는
토큰을 위해 디자인되었다. 이것은 잘 알려진 컨피그맵에 서명하는 데 사용되는
토큰을 저장한다.</p><p>부트스트랩 토큰 시크릿은 보통 <code>kube-system</code> 네임스페이스에 생성되며
<code>&lt;token-id></code> 가 해당 토큰 ID의 6개 문자의 문자열으로 구성된 <code>bootstrap-token-&lt;token-id></code> 형태로
이름이 지정된다.</p><p>쿠버네티스 매니페스트로서, 부트스트렙 토큰 시크릿은 다음과 유사할
것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>MjAyMC0wOS0xM1QwNDozOToxMFo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>NWVtaXRq<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>a3E0Z2lodnN6emduMXAwcg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span></code></pre></div><p>부트스트랩 타입 시크릿은 <code>data</code> 아래 명시된 다음의 키들을 가진다.</p><ul><li><code>token-id</code>: 토큰 식별자로 임의의 6개 문자의 문자열. 필수 사항.</li><li><code>token-secret</code>: 실제 토큰 시크릿으로 임의의 16개 문자의 문자열. 필수 사항.</li><li><code>description</code>: 토큰의 사용처를 설명하는 사람이 읽을 수 있는
문자열. 선택 사항.</li><li><code>expiration</code>: 토큰이 만료되어야 하는 시기를 명시한 RFC3339를
사용하는 절대 UTC 시간. 선택 사항.</li><li><code>usage-bootstrap-&lt;usage></code>: 부트스트랩 토큰의 추가적인 사용처를 나타내는
불리언(boolean) 플래그.</li><li><code>auth-extra-groups</code>: <code>system:bootstrappers</code> 그룹에 추가로 인증될
쉼표로 구분된 그룹 이름 목록.</li></ul><p>위의 YAML은 모두 base64로 인코딩된 문자열 값이므로 혼란스러워 보일
수 있다. 사실은 다음 YAML을 사용하여 동일한 시크릿을 생성할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 시크릿 이름이 어떻게 지정되었는지 확인</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 부트스트랩 토큰 시크릿은 일반적으로 kube-system 네임스페이스에 포함</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;system:bootstrappers:kubeadm:default-node-token&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-09-13T04:39:10Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 이 토큰 ID는 이름에 사용됨</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5emitj&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kq4gihvszzgn1p0r&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 이 토큰은 인증을 위해서 사용될 수 있음</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 또한 서명(signing)에도 사용될 수 있음</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=secret-immutable>수정 불가능한(immutable) 시크릿</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [stable]</code></div><p>쿠버네티스에서 특정 시크릿(및 컨피그맵)을 <em>수정 불가능</em> 으로 표시할 수 있다.
기존 시크릿 데이터의 변경을 금지시키면 다음과 같은 이점을 가진다.</p><ul><li>잘못된(또는 원치 않은) 업데이트를 차단하여 애플리케이션 중단을 방지</li><li>(수만 개 이상의 시크릿-파드 마운트와 같이 시크릿을 대규모로 사용하는 클러스터의 경우,)
수정 불가능한 시크릿으로 전환하면 kube-apiserver의 부하를 크게 줄여 클러스터의 성능을 향상시킬 수 있다.
kubelet은 수정 불가능으로 지정된 시크릿에 대해서는
[감시(watch)]를 유지할 필요가 없기 때문이다.</li></ul><h3 id=secret-immutable-create>시크릿을 수정 불가능으로 지정하기</h3><p>다음과 같이 시크릿의 <code>immutable</code> 필드를 <code>true</code>로 설정하여 수정 불가능한 시크릿을 만들 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>또한 기존의 수정 가능한 시크릿을 변경하여 수정 불가능한 시크릿으로 바꿀 수도 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 시크릿 또는 컨피그맵이 수정 불가능으로 지정되면, 이 변경을 취소하거나 <code>data</code> 필드의 내용을 바꿀 수 <em>없다</em>.
시크릿을 삭제하고 다시 만드는 것만 가능하다.
기존의 파드는 삭제된 시크릿으로의 마운트 포인트를 유지하기 때문에,
이러한 파드는 재생성하는 것을 추천한다.</div><h2 id=시크릿을-위한-정보-보안-information-security>시크릿을 위한 정보 보안(Information security)</h2><p>컨피그맵과 시크릿은 비슷하게 동작하지만,
쿠버네티스는 시크릿 오브젝트에 대해 약간의 추가적인 보호 조치를 적용한다.</p><p>시크릿은 종종 다양한 중요도에 걸친 값을 보유하며, 이 중 많은 부분이
쿠버네티스(예: 서비스 어카운트 토큰)와 외부 시스템으로 단계적으로
확대될 수 있다. 개별 앱이 상호 작용할 것으로 예상되는 시크릿의 힘에 대해 추론할 수 있더라도
동일한 네임스페이스 내의 다른 앱이 이러한 가정을
무효화할 수 있다.</p><p>해당 노드의 파드가 필요로 하는 경우에만 시크릿이 노드로 전송된다.
시크릿을 파드 내부로 마운트할 때, 기밀 데이터가 보존적인(durable) 저장소에 기록되지 않도록 하기 위해
kubelet이 데이터 복제본을 <code>tmpfs</code>에 저장한다.
해당 시크릿을 사용하는 파드가 삭제되면,
kubelet은 시크릿에 있던 기밀 데이터의 로컬 복사본을 삭제한다.</p><p>파드에는 여러 개의 컨테이너가 있을 수 있다.
기본적으로, 사용자가 정의한 컨테이너는 기본 서비스어카운트 및 이에 연관된 시크릿에만 접근할 수 있다.
다른 시크릿에 접근할 수 있도록 하려면
명시적으로 환경 변수를 정의하거나 컨테이너 내에 볼륨을 맵핑해야 한다.</p><p>동일한 노드의 여러 파드에 대한 시크릿이 있을 수 있다.
그러나 잠재적으로는 파드가 요청한 시크릿만 해당 파드의 컨테이너 내에서 볼 수 있다.
따라서, 하나의 파드는 다른 파드의 시크릿에 접근할 수 없다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 노드 상의 높은 권한을 갖는(privileged) 컨테이너는
해당 노드에 있는 모든 시크릿에 접근할 수 있다.</div><h3 id=개발자를-위한-보안-추천-사항>개발자를 위한 보안 추천 사항</h3><ul><li>애플리케이션은 환경 변수 또는 볼륨에서 기밀 정보를 읽은 뒤에 기밀 정보를 계속 보호해야 한다.
예를 들어, 애플리케이션은 비밀 데이터를 암호화되지 않은 상태로 기록하거나
신뢰할 수 없는 당사자에게 전송하지 말아야 한다.</li><li>파드에 여러 컨테이너가 있고,
그 중 한 컨테이너만 시크릿에 접근해야 하는 경우,
다른 컨테이너는 해당 시크릿에 접근할 수 없도록
볼륨 마운트 또는 환경 변수 구성을 적절히 정의한다.</li><li><a class=glossary-tooltip title='하나 이상의 쿠버네티스 API 오브젝트를 직렬화한 명세(specification).' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-manifest' target=_blank aria-label=매니페스트>매니페스트</a>를 통해 시크릿을 구성하고,
이 안에 비밀 데이터가 base64로 인코딩된 경우,
이 파일을 공유하거나 소스 저장소에 올리면
해당 매니페스트를 읽을 수 있는 모든 사람이 이 비밀 정보를 볼 수 있음에 주의한다.
base64 인코딩은 암호화 수단이 <em>아니기 때문에</em>, 평문과 마찬가지로 기밀성을 제공하지 않는다.</li><li>시크릿 API와 통신하는 애플리케이션을 배포할 때,
<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>과 같은
<a href=/ko/docs/reference/access-authn-authz/authorization/>인증 정책</a>을 사용하여
접근을 제한해야 한다.</li><li>쿠버네티스 API에서, 네임스페이스 내 시크릿에 대한 <code>watch</code> 와 <code>list</code> 요청은 매우 강력한 기능이다.
시크릿 목록 조회를 가능하게 하면
클라이언트가 해당 네임스페이스에 있는 모든 시크릿의 값을 검사할 수도 있기 때문에
가능한 한 이러한 접근 권한을 주는 것은 피해야 한다.</li></ul><h3 id=클러스터-관리자를-위한-보안-추천-사항>클러스터 관리자를 위한 보안 추천 사항</h3><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 시크릿을 사용하는 파드를 생성할 수 있는 사용자는 해당 시크릿의 값을 볼 수도 있다.
클러스터 정책에서 사용자가 직접 시크릿을 조회하는 것을 금지했더라도,
동일한 사용자가 시크릿을 노출하는 파드에 접근 권한을 가질 수 있다.</div><ul><li>(쿠버네티스 API를 사용하여) 클러스터의 모든 시크릿을 감시(<code>watch</code>) 또는 나열(<code>list</code>)하는 권한을 제한하여,
가장 특권이 있는 시스템 레벨의 컴포넌트에만 이 동작을 허용한다.</li><li>시크릿 API와 통신하는 애플리케이션을 배포할 때,
<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>과 같은
<a href=/ko/docs/reference/access-authn-authz/authorization/>인증 정책</a>을 사용하여
접근을 제한해야 한다.</li><li>API 서버에서, (시크릿을 포함한) 오브젝트는
<a class=glossary-tooltip title='모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>에 저장된다. 그러므로<ul><li>클러스터 관리자만 etcd에 접근할 수 있도록 한다(읽기 전용 접근 포함)</li><li>시크릿 오브젝트에 대해
<a href=/docs/tasks/administer-cluster/encrypt-data/>저장된 데이터 암호화(encryption at rest)</a>를 활성화하여,
이러한 시크릿의 데이터가 <a class=glossary-tooltip title='모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>에 암호화되지 않은 상태로 저장되지 않도록 한다.</li><li>etcd가 동작하던 장기 저장 장치를 더 이상 사용하지 않는다면
초기화 또는 파쇄하는 것을 검토한다.</li><li>etcd 인스턴스가 여러 개라면,
etcd 피어 간 통신에 SSL/TLS를 사용하고 있는지 확인한다.</li></ul></li></ul><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kubectl/><code>kubectl</code> 을 사용하여 시크릿 관리</a>하는 방법 배우기</li><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-config-file/>구성 파일을 사용하여 시크릿 관리</a>하는 방법 배우기</li><li><a href=/ko/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomize를 사용하여 시크릿 관리</a>하는 방법 배우기</li><li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>API 레퍼런스</a>에서 <code>Secret</code>에 대해 읽기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-436057b96151ecb8a4a9a9f456b5d0fc>4 - 파드 및 컨테이너 리소스 관리</h1><p><a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>를 지정할 때,
<a class=glossary-tooltip title='소프트웨어와 그것에 종속된 모든 것을 포함한 가볍고 휴대성이 높은 실행 가능 이미지.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/containers/ target=_blank aria-label=컨테이너>컨테이너</a>에 필요한 각 리소스의 양을 선택적으로 지정할 수 있다.
지정할 가장 일반적인 리소스는 CPU와 메모리(RAM) 그리고 다른 것들이 있다.</p><p>파드에서 컨테이너에 대한 리소스 <em>요청(request)</em> 을 지정하면,
<a class=glossary-tooltip title='노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>는 이 정보를
사용하여 파드가 배치될 노드를 결정한다. 컨테이너에 대한 리소스 <em>제한(limit)</em> 을
지정하면, kubelet은 실행 중인 컨테이너가 설정한 제한보다 많은 리소스를
사용할 수 없도록 해당 제한을 적용한다. 또한 kubelet은
컨테이너가 사용할 수 있도록 해당 시스템 리소스의 최소 <em>요청</em> 량을
예약한다.</p><h2 id=요청-및-제한>요청 및 제한</h2><p>파드가 실행 중인 노드에 사용 가능한 리소스가 충분하면, 컨테이너가 해당
리소스에 지정한 <code>request</code> 보다 더 많은 리소스를 사용할 수 있도록 허용된다.
그러나, 컨테이너는 리소스 <code>limit</code> 보다 더 많은 리소스를 사용할 수는 없다.</p><p>예를 들어, 컨테이너에 대해 256MiB의 <code>memory</code> 요청을 설정하고, 해당 컨테이너가
8GiB의 메모리를 가진 노드로 스케줄된 파드에 있고 다른 파드는 없는 경우, 컨테이너는 더 많은 RAM을
사용할 수 있다.</p><p>해당 컨테이너에 대해 4GiB의 <code>memory</code> 제한을 설정하면, kubelet(그리고
<a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>)이 제한을 적용한다.
런타임은 컨테이너가 구성된 리소스 제한을 초과하여 사용하지 못하게 한다. 예를 들어,
컨테이너의 프로세스가 허용된 양보다 많은 메모리를 사용하려고 하면,
시스템 커널은 메모리 부족(out of memory, OOM) 오류와 함께 할당을 시도한 프로세스를
종료한다.</p><p>제한은 반응적(시스템이 위반을 감지한 후에 개입)으로
또는 강제적(시스템이 컨테이너가 제한을 초과하지 않도록 방지)으로 구현할 수 있다. 런타임마다
다른 방식으로 동일한 제약을 구현할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 리소스에 대해 제한은 지정하지만 요청은 지정하지 않고,
해당 리소스에 대한 요청 기본값을 지정하는 승인-시점 메커니즘(admission-time mechanism)이 없는 경우,
쿠버네티스는 당신이 지정한 제한을 복사하여 해당 리소스의 요청 값으로 사용한다.</div><h2 id=리소스-타입>리소스 타입</h2><p><em>CPU</em> 와 <em>메모리</em> 는 각각 <em>리소스 타입</em> 이다. 리소스 타입에는 기본 단위가 있다.
CPU는 컴퓨팅 처리를 나타내며 <a href=#cpu%EC%9D%98-%EC%9D%98%EB%AF%B8>쿠버네티스 CPU</a> 단위로 지정된다.
메모리는 바이트 단위로 지정된다.
리눅스 워크로드에 대해서는, <em>huge page</em> 리소스를 지정할 수 있다.
Huge page는 노드 커널이 기본 페이지 크기보다 훨씬 큰 메모리
블록을 할당하는 리눅스 관련 기능이다.</p><p>예를 들어, 기본 페이지 크기가 4KiB인 시스템에서, <code>hugepages-2Mi: 80Mi</code> 제한을
지정할 수 있다. 컨테이너가 40개 이상의 2MiB huge page(총 80MiB)를
할당하려고 하면 해당 할당이 실패한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>hugepages-*</code> 리소스를 오버커밋할 수 없다.
이것은 <code>memory</code> 및 <code>cpu</code> 리소스와는 다르다.</div><p>CPU와 메모리를 통칭하여 <em>컴퓨트 리소스</em> 또는 <em>리소스</em> 라고 한다. 컴퓨트
리소스는 요청, 할당 및 소비될 수 있는 측정 가능한
수량이다. 이것은
<a href=/ko/docs/concepts/overview/kubernetes-api/>API 리소스</a>와는 다르다. 파드 및
<a href=/ko/docs/concepts/services-networking/service/>서비스</a>와 같은 API 리소스는
쿠버네티스 API 서버를 통해 읽고 수정할 수 있는 오브젝트이다.</p><h2 id=파드와-컨테이너의-리소스-요청-및-제한>파드와 컨테이너의 리소스 요청 및 제한</h2><p>각 컨테이너에 대해, 다음과 같은
리소스 제한(limit) 및 요청(request)을 지정할 수 있다.</p><ul><li><code>spec.containers[].resources.limits.cpu</code></li><li><code>spec.containers[].resources.limits.memory</code></li><li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li><li><code>spec.containers[].resources.requests.cpu</code></li><li><code>spec.containers[].resources.requests.memory</code></li><li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li></ul><p>요청 및 제한은 개별 컨테이너에 대해서만 지정할 수 있지만,
한 파드의 총 리소스 요청 및 제한에 대해 생각해 보는 것도
유용할 수 있다.
특정 리소스 종류에 대해, <em>파드 리소스 요청/제한</em> 은 파드의 각 컨테이너에 대한
해당 타입의 리소스 요청/제한의 합이다.</p><h2 id=쿠버네티스의-리소스-단위>쿠버네티스의 리소스 단위</h2><h3 id=meaning-of-cpu>CPU 리소스 단위</h3><p>CPU 리소스에 대한 제한 및 요청은 <em>cpu</em> 단위로 측정된다.
쿠버네티스에서, 1 CPU 단위는 노드가 물리 호스트인지
아니면 물리 호스트 내에서 실행되는 가상 머신인지에 따라
<strong>1 물리 CPU 코어</strong> 또는 <strong>1 가상 코어</strong> 에 해당한다.</p><p>요청량을 소수점 형태로 명시할 수도 있다. 컨테이너의
<code>spec.containers[].resources.requests.cpu</code>를 <code>0.5</code>로 설정한다는 것은,
<code>1.0</code> CPU를 요청했을 때와 비교하여 절반의 CPU 타임을 요청한다는 의미이다.
CPU 자원의 단위와 관련하여, <code>0.1</code> 이라는 <a href=/docs/reference/kubernetes-api/common-definitions/quantity/>수량</a> 표현은
"백 밀리cpu"로 읽을 수 있는 <code>100m</code> 표현과 동일하다. 어떤 사람들은
"백 밀리코어"라고 말하는데, 같은 것을 의미하는 것으로 이해된다.</p><p>CPU 리소스는 항상 리소스의 절대량으로 표시되며, 상대량으로 표시되지 않는다.
예를 들어, 컨테이너가 싱글 코어, 듀얼 코어, 또는 48 코어 머신 중 어디에서 실행되는지와 상관없이
<code>500m</code> CPU는 거의 같은 양의 컴퓨팅 파워를 가리킨다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 쿠버네티스에서 CPU 리소스를 <code>1m</code>보다 더 정밀한 단위로 표기할 수 없다.
이 때문에, CPU 단위를 <code>1.0</code> 또는 <code>1000m</code>보다 작은 밀리CPU 형태로 표기하는 것이 유용하다.
예를 들어, <code>0.005</code> 보다는 <code>5m</code>으로 표기하는 것이 좋다.</div><h3 id=meaning-of-memory>메모리 리소스 단위</h3><p><code>memory</code> 에 대한 제한 및 요청은 바이트 단위로 측정된다.
E, P, T, G, M, k 와 같은
<a href=/docs/reference/kubernetes-api/common-definitions/quantity/>수량</a> 접미사 중 하나를 사용하여 메모리를
일반 정수 또는 고정 소수점 숫자로 표현할 수 있다. Ei, Pi, Ti, Gi, Mi, Ki와
같은 2의 거듭제곱을 사용할 수도 있다. 예를 들어, 다음은 대략 동일한 값을 나타낸다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M, 128974848000m, 123Mi
</span></span></code></pre></div><p>접미사의 대소문자에 유의한다.
<code>400m</code>의 메모리를 요청하면, 이는 0.4 바이트를 요청한 것이다.
이 사람은 아마도 400 메비바이트(mebibytes) (<code>400Mi</code>) 또는 400 메가바이트 (<code>400M</code>) 를 요청하고 싶었을 것이다.</p><h2 id=example-1>컨테이너 리소스 예제</h2><p>다음 파드는 두 컨테이너로 구성된다.
각 컨테이너는 0.25 CPU와 64 MiB(2<sup>26</sup> 바이트) 메모리 요청을 갖도록 정의되어 있다.
또한 각 컨테이너는 0.5 CPU와 128 MiB 메모리 제한을 갖는다.
이 경우 파드는 0.5 CPU와 128 MiB 메모리 요청을 가지며,
1 CPU와 256 MiB 메모리 제한을 갖는다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=리소스-요청이-포함된-파드를-스케줄링하는-방법>리소스 요청이 포함된 파드를 스케줄링하는 방법</h2><p>파드를 생성할 때, 쿠버네티스 스케줄러는 파드를 실행할 노드를
선택한다. 각 노드는 파드에 제공할 수 있는 CPU와 메모리 양과 같은 각 리소스 타입에 대해
최대 용량을 갖는다. 스케줄러는 각 리소스 타입마다
스케줄된 컨테이너의 리소스 요청 합계가
노드 용량보다 작도록 한다.
참고로 노드의 실제 메모리나
CPU 리소스 사용량은 매우 적지만, 용량 확인에 실패한 경우
스케줄러는 여전히 노드에 파드를 배치하지 않는다. 이는 리소스 사용량이
나중에 증가할 때, 예를 들어, 일일 요청 비율이
최대일 때 노드의 리소스 부족을 방지한다.</p><h2 id=how-pods-with-resource-limits-are-run>쿠버네티스가 리소스 요청 및 제한을 적용하는 방법</h2><p>kubelet이 파드의 컨테이너를 시작할 때,
kubelet은 해당 컨테이너의 메모리/CPU 요청 및 제한을 컨테이너 런타임에 전달한다.</p><p>리눅스에서, 일반적으로 컨테이너 런타임은
적용될 커널 <a class=glossary-tooltip title='선택적으로 리소스를 격리, 관리, 제한하는 리눅스 프로세스의 그룹.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-cgroup' target=_blank aria-label=cgroup>cgroup</a>을 설정하고,
명시한 제한을 적용한다.</p><ul><li>CPU 제한은 해당 컨테이너가 사용할 수 있는 CPU 시간에 대한 강한 상한(hard ceiling)을 정의한다.
각 스케줄링 간격(시간 조각)마다, 리눅스 커널은 이 제한이 초과되었는지를 확인하고,
만약 초과되었다면 cgroup의 실행 재개를 허가하지 않고 기다린다.</li><li>CPU 요청은 일반적으로 가중치 설정(weighting)을 정의한다.
현재 부하율이 높은 시스템에서 여러 개의 컨테이너(cgroup)가 실행되어야 하는 경우,
큰 CPU 요청값을 갖는 워크로드가 작은 CPU 요청값을 갖는 워크로드보다 더 많은 CPU 시간을 할당받는다.</li><li>메모리 요청은 주로 (쿠버네티스) 파드 스케줄링 과정에서 사용된다.
cgroup v2를 사용하는 노드에서, 컨테이너 런타임은 메모리 요청을 힌트로 사용하여
<code>memory.min</code> 및 <code>memory.low</code>을 설정할 수 있다.</li><li>메모리 제한은 해당 cgroup에 대한 메모리 사용량 상한을 정의한다.
컨테이너가 제한보다 더 많은 메모리를 할당받으려고 시도하면,
리눅스 커널의 메모리 부족(out-of-memory) 서브시스템이 활성화되고
(일반적으로) 개입하여 메모리를 할당받으려고 했던 컨테이너의 프로세스 중 하나를 종료한다.
해당 프로세스의 PID가 1이고, 컨테이너가 재시작 가능(restartable)으로 표시되어 있으면, 쿠버네티스가 해당 컨테이너를 재시작한다.</li><li>파드 또는 컨테이너의 메모리 제한은 메모리 기반 볼륨(예: <code>emptyDir</code>)의 페이지에도 적용될 수 있다.
kubelet은 <code>tmpfs</code> emptyDir 볼륨을 로컬 임시(ephemeral) 스토리지가 아닌
컨테이너 메모리 사용으로 간주하여 추적한다.</li></ul><p>한 컨테이너가 메모리 요청을 초과하고
해당 노드의 메모리가 부족하지면,
해당 컨테이너가 속한 파드가 <a class=glossary-tooltip title='노드에 있는 한 개 이상의 파드를 중단하는 프로세스이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/ target=_blank aria-label=축출>축출</a>될 수 있다.</p><p>컨테이너가 비교적 긴 시간 동안 CPU 제한을 초과하는 것이 허용될 수도, 허용되지 않을 수도 있다.
그러나, 컨테이너 런타임은 과도한 CPU 사용률을 이유로 파드 또는 컨테이너를 종료시키지는 않는다.</p><p>리소스 제한으로 인해 컨테이너를 스케줄할 수 없는지 또는 종료 중인지 확인하려면,
<a href=#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0>문제 해결</a> 섹션을 참조한다.</p><h3 id=컴퓨트-및-메모리-리소스-사용량-모니터링>컴퓨트 및 메모리 리소스 사용량 모니터링</h3><p>kubelet은 파드의 리소스 사용량을 파드
<a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%AA%85%EC%84%B8-spec-%EC%99%80-%EC%83%81%ED%83%9C-status><code>status</code></a>에 포함하여 보고한다.</p><p>클러스터에서 선택적인 <a href=/ko/docs/tasks/debug/debug-cluster/resource-usage-monitoring/>모니터링 도구</a>를
사용할 수 있다면, <a href=/ko/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/#metrics-api>메트릭 API</a>에서
직접 또는 모니터링 도구에서 파드 리소스
사용량을 검색할 수 있다.</p><h2 id=로컬-임시-ephemeral-스토리지>로컬 임시(ephemeral) 스토리지</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><p>노드에는 로컬에 연결된 쓰기 가능 장치 또는, 때로는 RAM에 의해
지원되는 로컬 임시 스토리지가 있다.
"임시"는 내구성에 대한 장기간의 보증이 없음을 의미한다.</p><p>파드는 스크래치 공간, 캐싱 및 로그에 대해 임시 로컬 스토리지를 사용한다.
kubelet은 로컬 임시 스토리지를 사용하여 컨테이너에
<a href=/ko/docs/concepts/storage/volumes/#emptydir><code>emptyDir</code></a>
<a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>을 마운트하기 위해 파드에 스크래치 공간을 제공할 수 있다.</p><p>kubelet은 이러한 종류의 스토리지를 사용하여
<a href=/ko/docs/concepts/cluster-administration/logging/#%EB%85%B8%EB%93%9C-%EB%A0%88%EB%B2%A8%EC%97%90%EC%84%9C%EC%9D%98-%EB%A1%9C%EA%B9%85>노드-레벨 컨테이너 로그</a>,
컨테이너 이미지 및 실행 중인 컨테이너의 쓰기 가능 계층을 보유한다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 노드가 실패하면, 임시 스토리지의 데이터가 손실될 수 있다.
애플리케이션은 로컬 임시 스토리지에서 성능에 대한 SLA(예: 디스크 IOPS)를
기대할 수 없다.</div><p>베타 기능에서, 쿠버네티스는 파드가 사용할 수 있는 임시 로컬 스토리지의 양을
추적, 예약 및 제한할 수 있도록 해준다.</p><h3 id=로컬-임시-스토리지-구성>로컬 임시 스토리지 구성</h3><p>쿠버네티스는 노드에서 로컬 임시 스토리지를 구성하는 두 가지 방법을 지원한다.<ul class="nav nav-tabs" id=local-storage-configurations role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#local-storage-configurations-0 role=tab aria-controls=local-storage-configurations-0 aria-selected=true>단일 파일시스템</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#local-storage-configurations-1 role=tab aria-controls=local-storage-configurations-1>두 개의 파일시스템</a></li></ul><div class=tab-content id=local-storage-configurations><div id=local-storage-configurations-0 class="tab-pane show active" role=tabpanel aria-labelledby=local-storage-configurations-0><p><p>이 구성에서, 모든 종류의 임시 로컬 데이터(<code>emptyDir</code> 볼륨,
쓰기 가능 계층, 컨테이너 이미지, 로그)를 하나의 파일시스템에 배치한다.
kubelet을 구성하는 가장 효과적인 방법은 이 파일시스템을 쿠버네티스(kubelet) 데이터 전용으로
하는 것이다.</p><p>kubelet은 또한
<a href=/ko/docs/concepts/cluster-administration/logging/#%EB%85%B8%EB%93%9C-%EB%A0%88%EB%B2%A8%EC%97%90%EC%84%9C%EC%9D%98-%EB%A1%9C%EA%B9%85>노드-레벨 컨테이너 로그</a>를
작성하고 임시 로컬 스토리지와 유사하게 처리한다.</p><p>kubelet은 구성된 로그 디렉터리 내의 파일에 로그를 기록한다(기본적으로
<code>/var/log</code>). 그리고 로컬에 저장된 다른 데이터에 대한 기본 디렉터리가 있다(기본적으로
<code>/var/lib/kubelet</code>).</p><p>일반적으로, <code>/var/lib/kubelet</code> 와 <code>/var/log</code> 모두 시스템 루트 파일시스템에 위치하고,
그리고 kubelet은 이런 레이아웃을 염두에 두고 설계되었다.</p><p>노드는 쿠버네티스에서 사용하지 않는 다른 많은 파일시스템을
가질 수 있다.</p></div><div id=local-storage-configurations-1 class=tab-pane role=tabpanel aria-labelledby=local-storage-configurations-1><p><p>사용하고 있는 노드에 실행 중인 파드에서 발생하는 임시 데이터를
위한 파일시스템을 가진다(로그와 <code>emptyDir</code> 볼륨). 이 파일시스템을
다른 데이터(예를 들어, 쿠버네티스와 관련없는 시스템 로그)를 위해 사용할 수 있다. 이 파일시스템은
루트 파일시스템일 수도 있다.</p><p>kubelet은 또한
<a href=/ko/docs/concepts/cluster-administration/logging/#%EB%85%B8%EB%93%9C-%EB%A0%88%EB%B2%A8%EC%97%90%EC%84%9C%EC%9D%98-%EB%A1%9C%EA%B9%85>노드-레벨 컨테이너 로그</a>를
첫 번째 파일시스템에 기록하고, 임시 로컬 스토리지와 유사하게 처리한다.</p><p>또한 다른 논리 스토리지 장치가 지원하는 별도의 파일시스템을 사용한다.
이 구성에서, 컨테이너 이미지 계층과 쓰기 가능한 계층을 배치하도록
kubelet에 지시하는 디렉터리는 이 두 번째 파일시스템에 있다.</p><p>첫 번째 파일시스템에는 이미지 계층이나 쓰기 가능한 계층이 없다.</p><p>노드는 쿠버네티스에서 사용하지 않는 다른 많은 파일시스템을
가질 수 있다.</p></div></div></p><p>kubelet은 사용 중인 로컬 스토리지 양을 측정할 수 있다.
임시 볼륨(ephemeral storage)을 설정하기 위해 지원되는 구성 중 하나를 사용하여
노드를 설정한 경우 제공된다.</p><p>다른 구성을 사용하는 경우, kubelet은 임시 로컬 스토리지에 대한 리소스
제한을 적용하지 않는다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> kubelet은 로컬 임시 스토리지가 아닌 컨테이너 메모리 사용으로
<code>tmpfs</code> emptyDir 볼륨을 추적한다.</div><h3 id=로컬-임시-스토리지에-대한-요청-및-제한-설정>로컬 임시 스토리지에 대한 요청 및 제한 설정</h3><p><code>ephemeral-storage</code>를 명시하여 로컬 임시 저장소를 관리할 수 있다.
파드의 각 컨테이너는 다음 중 하나 또는 모두를 명시할 수 있다.</p><ul><li><code>spec.containers[].resources.limits.ephemeral-storage</code></li><li><code>spec.containers[].resources.requests.ephemeral-storage</code></li></ul><p><code>ephemeral-storage</code> 에 대한 제한 및 요청은 바이트 단위로 측정된다.
E, P, T, G, M, k와 같은 접미사 중 하나를 사용하여 스토리지를 일반 정수 또는 고정 소수점 숫자로 표현할 수 있다.
Ei, Pi, Ti, Gi, Mi, Ki와 같은 2의 거듭제곱을 사용할 수도 있다.
예를 들어, 다음은 거의 동일한 값을 나타낸다.</p><ul><li><code>128974848</code></li><li><code>129e6</code></li><li><code>129M</code></li><li><code>123Mi</code></li></ul><p>접미사의 대소문자에 유의한다.
<code>400m</code>의 메모리를 요청하면, 이는 0.4 바이트를 요청한 것이다.
이 사람은 아마도 400 메비바이트(mebibytes) (<code>400Mi</code>) 또는 400 메가바이트 (<code>400M</code>) 를 요청하고 싶었을 것이다.</p><p>다음 예에서, 파드에 두 개의 컨테이너가 있다.
각 컨테이너에는 2GiB의 로컬 임시 스토리지 요청이 있다.
각 컨테이너에는 4GiB의 로컬 임시 스토리지 제한이 있다.
따라서, 파드는 4GiB의 로컬 임시 스토리지 요청과 8GiB 로컬 임시 스토리지 제한을 가진다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=ephemeral-storage-요청이-있는-파드의-스케줄링-방법><code>ephemeral-storage</code> 요청이 있는 파드의 스케줄링 방법</h3><p>파드를 생성할 때, 쿠버네티스 스케줄러는 파드를 실행할 노드를 선택한다.
각 노드에는 파드에 제공할 수 있는 최대 임시 스토리지 공간이 있다.
자세한 정보는,
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>노드 할당 가능</a>을 참조한다.</p><p>스케줄러는 스케줄된 컨테이너의 리소스 요청 합계가 노드 용량보다 작도록 한다.</p><h3 id=resource-emphemeralstorage-consumption>임시 스토리지 소비 관리</h3><p>kubelet이 로컬 임시 스토리지를 리소스로 관리하는 경우,
kubelet은 다음에서 스토리지 사용을 측정한다.</p><ul><li><em>tmpfs</em> <code>emptyDir</code> 볼륨을 제외한 <code>emptyDir</code> 볼륨</li><li>노드-레벨 로그가 있는 디렉터리</li><li>쓰기 가능한 컨테이너 계층</li></ul><p>허용하는 것보다 더 많은 임시 스토리지를 파드가 사용하는 경우, kubelet은
파드 축출을 트리거하는 축출 신호를 설정한다.</p><p>컨테이너-레벨 격리의 경우, 컨테이너의 쓰기 가능한 계층과 로그
사용량이 스토리지 제한을 초과하면, kubelet은 파드를 축출하도록 표시한다.</p><p>파드-레벨 격리에 대해 kubelet은 해당 파드의 컨테이너에 대한 제한을 합하여
전체 파드 스토리지 제한을 해결한다. 이 경우, 모든
컨테이너와 파드의 <code>emptyDir</code> 볼륨의 로컬 임시 스토리지 사용량 합계가
전체 파드 스토리지 제한을 초과하면, kubelet은 파드를 축출 대상으로
표시한다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong><p>kubelet이 로컬 임시 스토리지를 측정하지 않는 경우,
로컬 스토리지 제한을 초과하는 파드는 로컬 스토리지 리소스 제한을
위반해도 축출되지 않는다.</p><p>그러나, 쓰기 가능한 컨테이너 계층, 노드-레벨 로그
또는 <code>emptyDir</code> 볼륨의 파일 시스템 공간이 부족하면, 로컬
스토리지가 부족하다고 노드 자체에 <a class=glossary-tooltip title='세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 테인트는 파드가 노드나 노드 그룹에 스케줄링되는 것을 방지한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=테인트>테인트</a>되고
이로인해 특별히 이 테인트를 허용하지 않는 모든 파드를 축출하도록 트리거한다.</p><p>임시 로컬 스토리지에 대해 지원되는 <a href=#%EB%A1%9C%EC%BB%AC-%EC%9E%84%EC%8B%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EA%B5%AC%EC%84%B1>구성</a>을
참조한다.</p></div><p>kubelet은 파드 스토리지 사용을 측정하는 다양한 방법을 지원한다.</p><ul class="nav nav-tabs" id=resource-emphemeralstorage-measurement role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#resource-emphemeralstorage-measurement-0 role=tab aria-controls=resource-emphemeralstorage-measurement-0 aria-selected=true>주기적 스캐닝</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#resource-emphemeralstorage-measurement-1 role=tab aria-controls=resource-emphemeralstorage-measurement-1>파일시스템 프로젝트 쿼터</a></li></ul><div class=tab-content id=resource-emphemeralstorage-measurement><div id=resource-emphemeralstorage-measurement-0 class="tab-pane show active" role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-0><p><p>kubelet은 각 <code>emptyDir</code> 볼륨, 컨테이너 로그 디렉터리 및 쓰기 가능한 컨테이너 계층을
스캔하는 정기적인 스케줄 검사를 수행한다.</p><p>스캔은 사용된 공간의 양을 측정한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>이 모드에서, kubelet은 삭제된 파일의 열린 파일 디스크립터를
추적하지 않는다.</p><p>여러분(또는 컨테이너)이 <code>emptyDir</code> 볼륨 안에 파일을 생성하면,
그 파일이 열리고, 파일이 열려있는 동안 파일을
삭제하면, 삭제된 파일의 inode는 해당 파일을 닫을 때까지
유지되지만 kubelet은 사용 중인 공간으로 분류하지 않는다.</p></div></div><div id=resource-emphemeralstorage-measurement-1 class=tab-pane role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-1><p><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.15 [alpha]</code></div><p>프로젝트 쿼터는 파일시스템에서 스토리지 사용을 관리하기 위한
운영체제 레벨의 기능이다. 쿠버네티스를 사용하면, 스토리지 사용을
모니터링하기 위해 프로젝트 쿼터를 사용할 수 있다. 노드에서 'emptyDir' 볼륨을
지원하는 파일시스템이 프로젝트 쿼터 지원을 제공하는지 확인한다.
예를 들어, XFS와 ext4fs는 프로젝트 쿼터를 지원한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 프로젝트 쿼터를 통해 스토리지 사용을 모니터링할 수 있다. 이는 제한을 강제하지 않는다.</div><p>쿠버네티스는 <code>1048576</code> 부터 프로젝트 ID를 사용한다. 사용 중인 ID는
<code>/etc/projects</code> 와 <code>/etc/projid</code> 에 등록되어 있다. 이 범위의 프로젝트 ID가
시스템에서 다른 목적으로 사용되는 경우, 쿠버네티스가
이를 사용하지 않도록 해당 프로젝트 ID를 <code>/etc/projects</code> 와 <code>/etc/projid</code> 에
등록해야 한다.</p><p>쿼터는 디렉터리 검색보다 빠르고 정확하다. 디렉터리가
프로젝트에 할당되면, 디렉터리 아래에 생성된
모든 파일이 해당 프로젝트에 생성되며, 커널은 해당 프로젝트의
파일에서 사용 중인 블록 수를 추적하기만 하면 된다.
파일이 생성되고 삭제되었지만, 열린 파일 디스크립터가 있으면,
계속 공간을 소비한다. 쿼터 추적은 공간을 정확하게 기록하는 반면
디렉터리 스캔은 삭제된 파일이 사용한 스토리지를 간과한다.</p><p>프로젝트 쿼터를 사용하려면, 다음을 수행해야 한다.</p><ul><li><p><a href=/docs/reference/config-api/kubelet-config.v1beta1/>kubelet 구성</a>의
<code>featureGates</code> 필드 또는 <code>--feature-gates</code> 커맨드 라인 플래그를 사용하여
<code>LocalStorageCapacityIsolationFSQuotaMonitoring=true</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
활성화한다.</p></li><li><p>루트 파일시스템(또는 선택적인 런타임 파일시스템)에
프로젝트 쿼터가 활성화되어 있는지 확인한다. 모든 XFS 파일시스템은 프로젝트 쿼터를 지원한다.
ext4 파일시스템의 경우, 파일시스템이 마운트되지 않은 상태에서 프로젝트 쿼터
추적 기능을 활성화해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># ext4인 /dev/block-device가 마운트되지 않은 경우</span>
</span></span><span style=display:flex><span>sudo tune2fs -O project -Q prjquota /dev/block-device
</span></span></code></pre></div></li><li><p>루트 파일시스템(또는 선택적인 런타임 파일시스템)은 프로젝트 쿼터를
활성화한 상태에서 마운트해야 힌다. XFS와 ext4fs 모두에서,
마운트 옵션의 이름은 <code>prjquota</code> 이다.</p></li></ul></div></div><h2 id=확장된-리소스>확장된 리소스</h2><p>확장된 리소스는 <code>kubernetes.io</code> 도메인 외부의 전체 주소(fully-qualified)
리소스 이름이다. 쿠버네티스에 내장되지 않은 리소스를 클러스터 운영자가 알리고
사용자는 사용할 수 있다.</p><p>확장된 리소스를 사용하려면 두 단계가 필요한다. 먼저, 클러스터
운영자는 확장된 리소스를 알려야 한다. 둘째, 사용자는 파드의
확장된 리소스를 요청해야 한다.</p><h3 id=확장된-리소스-관리>확장된 리소스 관리</h3><h4 id=노드-레벨의-확장된-리소스>노드-레벨의 확장된 리소스</h4><p>노드-레벨의 확장된 리소스는 노드에 연결된다.</p><h5 id=장치-플러그인-관리-리소스>장치 플러그인 관리 리소스</h5><p>각 노드에서
장치 플러그인 관리 리소스를 알리는 방법은
<a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>장치 플러그인</a>을 참조한다.</p><h5 id=기타-리소스>기타 리소스</h5><p>새로운 노드-레벨의 확장된 리소스를 알리기 위해, 클러스터 운영자는
API 서버에 <code>PATCH</code> HTTP 요청을 제출하여 클러스터의
노드에 대해 <code>status.capacity</code> 에서 사용할 수 있는 수량을 지정할 수 있다. 이 작업
후에는, 노드의 <code>status.capacity</code> 에 새로운 리소스가 포함된다. 이
<code>status.allocatable</code> 필드는 kubelet에 의해 비동기적으로 새로운
리소스로 자동 업데이트된다.</p><p>스케줄러가 파드 적합성을 평가할 때 노드의 <code>status.allocatable</code> 값을 사용하므로,
스케줄러는 해당 비동기 업데이트 이후의 새로운 값만을 고려한다.
따라서 노드 용량을 새 리소스로 패치하는 시점과
해당 자원을 요청하는 첫 파드가 해당 노드에 스케줄될 수 있는 시점 사이에
약간의 지연이 있을 수 있다.</p><p><strong>예제:</strong></p><p>다음은 <code>curl</code> 을 사용하여 마스터가 <code>k8s-master</code> 인 노드 <code>k8s-node-1</code> 에
5개의 "example.com/foo" 리소스를 알리는 HTTP 요청을 구성하는 방법을
보여주는 예이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 앞의 요청에서, <code>~1</code> 은 패치 경로에서 문자 <code>/</code> 의
인코딩이다. JSON-Patch의 작업 경로 값은
JSON-Pointer로 해석된다. 더 자세한 내용은,
<a href=https://tools.ietf.org/html/rfc6901#section-3>IETF RFC 6901, 섹션 3</a>을 참조한다.</div><h4 id=클러스터-레벨의-확장된-리소스>클러스터-레벨의 확장된 리소스</h4><p>클러스터-레벨의 확장된 리소스는 노드에 연결되지 않는다. 이들은 일반적으로
리소스 소비와 리소스 쿼터를 처리하는 스케줄러 익스텐더(extender)에 의해 관리된다.</p><p><a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>스케줄러 구성</a>에서
스케줄러 익스텐더가 처리하는 확장된 리소스를 지정할 수 있다.</p><p><strong>예제:</strong></p><p>스케줄러 정책에 대한 다음의 구성은 클러스터-레벨의 확장된 리소스
"example.com/foo"가 스케줄러 익스텐더에 의해 처리됨을
나타낸다.</p><ul><li>파드가 "example.com/foo"를 요청하는 경우에만 스케줄러가 파드를 스케줄러
익스텐더로 보낸다.</li><li>이 <code>ignoredByScheduler</code> 필드는 스케줄러가 <code>PodFitsResources</code> 속성에서
"example.com/foo" 리소스를 확인하지 않도록 지정한다.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=확장된-리소스-소비>확장된 리소스 소비</h3><p>사용자는 CPU와 메모리 같은 파드 스펙의 확장된 리소스를 사용할 수 있다.
스케줄러는 리소스 어카운팅(resource accounting)을 관리하여 사용 가능한 양보다
많은 양의 리소스가 여러 파드에 동시에 할당되지 않도록 한다.</p><p>API 서버는 확장된 리소스의 수량을 정수로 제한한다.
<em>유효한</em> 수량의 예로는 <code>3</code>, <code>3000m</code> 그리고 <code>3Ki</code> 를 들 수 있다. <em>유효하지 않은</em>
수량의 예는 <code>0.5</code> 와 <code>1500m</code> 이다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 확장된 리소스는 불명확한 정수 리소스를 대체한다.
사용자는 예약된 <code>kubernetes.io</code> 이외의 모든 도메인 이름 접두사를 사용할 수 있다.</div><p>파드에서 확장된 리소스를 사용하려면, 컨테이너 사양에서 <code>spec.containers[].resources.limits</code>
맵에 리소스 이름을 키로 포함한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 확장된 리소스는 오버커밋할 수 없으므로, 컨테이너 사양에
둘 다 있으면 요청과 제한이 동일해야 한다.</div><p>파드는 CPU, 메모리 및 확장된 리소스를 포함하여 모든 리소스 요청이
충족되는 경우에만 예약된다. 리소스 요청을 충족할 수 없다면
파드는 <code>PENDING</code> 상태를 유지한다.</p><p><strong>예제:</strong></p><p>아래의 파드는 2개의 CPU와 1개의 "example.com/foo"(확장된 리소스)를 요청한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=pid-제한>PID 제한</h2><p>프로세스 ID(PID) 제한은 kubelet의 구성에 대해
주어진 파드가 사용할 수 있는 PID 수를 제한할 수 있도록 허용한다.
자세한 내용은 <a href=/ko/docs/concepts/policy/pid-limiting/>PID 제한</a>을 참고한다.</p><h2 id=문제-해결>문제 해결</h2><h3 id=내-파드가-failedscheduling-이벤트-메시지로-보류-중이다>내 파드가 <code>FailedScheduling</code> 이벤트 메시지로 보류 중이다</h3><p>파드가 배치될 수 있는 노드를 스케줄러가 찾을 수 없으면,
노드를 찾을 수 있을 때까지 파드는 스케줄되지 않은 상태로 유지한다.
파드가 할당될 곳을 스케줄러가 찾지 못하면
<a href=/docs/reference/kubernetes-api/cluster-resources/event-v1/>Event</a>가 생성된다.
다음과 같이 <code>kubectl</code>을 사용하여 파드의 이벤트를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod frontend | grep -A <span style=color:#666>9999999999</span> Events
</span></span></code></pre></div><pre tabindex=0><code>Events:
  Type     Reason            Age   From               Message
  ----     ------            ----  ----               -------
  Warning  FailedScheduling  23s   default-scheduler  0/42 nodes available: insufficient cpu
</code></pre><p>위의 예에서, 모든 노드의 CPU 리소스가 충분하지 않아 이름이
"frontend"인 파드를 스케줄하지 못했다. 비슷한 메시지로
메모리 부족(PodExceedsFreeMemory)으로 인한 장애도 알릴 수 있다. 일반적으로, 파드가
이 타입의 메시지로 보류 중인 경우, 몇 가지 시도해 볼 것들이 있다.</p><ul><li>클러스터에 더 많은 노드를 추가한다.</li><li>불필요한 파드를 종료하여 보류 중인 파드를 위한 공간을 확보한다.</li><li>파드가 모든 노드보다 크지 않은지 확인한다. 예를 들어, 모든
노드의 용량이 <code>cpu: 1</code> 인 경우, <code>cpu: 1.1</code> 요청이 있는 파드는
절대 스케줄되지 않는다.</li><li>노드 테인트를 확인한다.
대부분의 노드에 테인트가 걸려 있고, 신규 파드가 해당 테인트에 배척된다면,
스케줄러는 해당 테인트가 걸려 있지 않은 나머지 노드에만 배치를 고려할 것이다.</li></ul><p><code>kubectl describe nodes</code> 명령으로 노드 용량과 할당된 양을
확인할 수 있다. 예를 들면, 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe nodes e2e-test-node-pool-4lw4
</span></span></code></pre></div><pre tabindex=0><code>Name:            e2e-test-node-pool-4lw4
[ ... 명확하게 하기 위해 라인들을 제거함 ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... 명확하게 하기 위해 라인들을 제거함 ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (11%)        1070Mi (13%)
</code></pre><p>위의 출력에서, 1.120 이상의 CPU 또는 6.23 Gi 이상의 메모리를 요청하는 파드는
노드에 할당될 수 없음을 확인할 수 있다.</p><p>"Pods" 섹션을 살펴보면, 어떤 파드가 노드에서 공간을 차지하고 있는지를
볼 수 있다.</p><p>사용 가능한 리소스의 일부를 시스템 데몬이 사용하기 때문에,
파드에 사용 가능한 리소스의 양은 노드 총 용량보다 적다.
쿠버네티스 API에서, 각 노드는 <code>.status.allocatable</code> 필드(상세 사항은
<a href=/docs/reference/kubernetes-api/cluster-resources/node-v1/#NodeStatus>NodeStatus</a> 참조)를
갖는다.</p><p><code>.status.allocatable</code> 필드는 해당 노드에서 파드가 사용할 수 있는
리소스의 양을 표시한다(예: 15 vCPUs 및 7538 MiB 메모리).
쿠버네티스의 노드 할당 가능 리소스에 대한 상세 사항은
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/>시스템 데몬을 위한 컴퓨트 자원 예약하기</a>를 참고한다.</p><p><a href=/ko/docs/concepts/policy/resource-quotas/>리소스 쿼터</a>를 설정하여,
한 네임스페이스가 사용할 수 있는 리소스 총량을 제한할 수 있다.
특정 네임스페이스 내에 ResourceQuota가 설정되어 있으면
쿠버네티스는 오브젝트에 대해 해당 쿼터를 적용한다.
예를 들어, 각 팀에 네임스페이스를 할당한다면, 각 네임스페이스에 ResourceQuota를 설정할 수 있다.
리소스 쿼터를 설정함으로써 한 팀이 지나치게 많은 리소스를 사용하여
다른 팀에 영향을 주는 것을 막을 수 있다.</p><p>해당 네임스페이스에 어떤 접근을 허용할지도 고려해야 한다.
네임스페이스에 대한 <strong>완전한</strong> 쓰기 권한을 가진 사람은
어떠한 리소스(네임스페이스에 설정된 ResourceQuota 포함)라도 삭제할 수 있다.</p><h3 id=내-컨테이너가-종료되었다>내 컨테이너가 종료되었다</h3><p>리소스가 부족하여 컨테이너가 종료될 수 있다. 리소스
제한에 도달하여 컨테이너가 종료되고 있는지 확인하려면,
관심있는 파드에 대해 <code>kubectl describe pod</code> 를 호출한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod simmemleak-hra99
</span></span></code></pre></div><p>출력은 다음과 같다.</p><pre tabindex=0><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Containers:
  simmemleak:
    Image:  saadali/simmemleak:latest
    Limits:
      cpu:          100m
      memory:       50Mi
    State:          Running
      Started:      Tue, 07 Jul 2019 12:54:41 -0700
    Last State:     Terminated
      Reason:       OOMKilled
      Exit Code:    137
      Started:      Fri, 07 Jul 2019 12:54:30 -0700
      Finished:     Fri, 07 Jul 2019 12:54:33 -0700
    Ready:          False
    Restart Count:  5
Conditions:
  Type      Status
  Ready     False
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  42s   default-scheduler  Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Normal  Pulled     41s   kubelet            Container image &#34;saadali/simmemleak:latest&#34; already present on machine
  Normal  Created    41s   kubelet            Created container simmemleak
  Normal  Started    40s   kubelet            Started container simmemleak
  Normal  Killing    32s   kubelet            Killing container with id ead3fb35-5cf5-44ed-9ae1-488115be66c6: Need to kill Pod
</code></pre><p>앞의 예제에서, <code>Restart Count: 5</code> 표시는 파드의 <code>simmemleak</code>
컨테이너가 종료되고 (지금까지) 5번 다시 시작되었음을 나타낸다.
<code>Reason: OOMKilled</code>를 통해 컨테이너가 제한보다 많은 양의 메모리를 사용하려고 했다는 것을 확인할 수 있다.</p><p>다음 단계로 메모리 누수가 있는지 애플리케이션 코드를 확인해 볼 수 있다.
애플리케이션이 예상한 대로 동작하는 것을 확인했다면,
해당 컨테이너의 메모리 제한(및 요청)을 더 높게 설정해 본다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>컨테이너와 파드에 메모리 리소스를 할당</a>하는 핸즈온 경험을 해보자.</li><li><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>컨테이너와 파드에 CPU 리소스를 할당</a>하는 핸즈온 경험을 해보자.</li><li>API 레퍼런스에 <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>컨테이너</a>와
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources>컨테이너 리소스 요구사항</a>이 어떻게 정의되어 있는지 확인한다.</li><li>XFS의 <a href=https://xfs.org/index.php/XFS_FAQ#Q:_Quota:_Do_quotas_work_on_XFS.3F>프로젝트 쿼터</a>에 대해 읽어보기</li><li><a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler 정책 레퍼런스 (v1beta3)</a>에 대해 더 읽어보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>5 - kubeconfig 파일을 사용하여 클러스터 접근 구성하기</h1><p>kubeconfig 파일들을 사용하여 클러스터, 사용자, 네임스페이스 및 인증 메커니즘에 대한 정보를 관리하자.
<code>kubectl</code> 커맨드라인 툴은 kubeconfig 파일을 사용하여
클러스터의 선택과
클러스터의 API 서버와의 통신에 필요한 정보를 찾는다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 클러스터에 대한 접근을 구성하는 데 사용되는 파일을 <em>kubeconfig 파일</em> 이라 한다.
이는 구성 파일을 참조하는 일반적인 방법을 의미한다.
<code>kubeconfig</code>라는 이름의 파일이 있다는 의미는 아니다.</div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 신뢰할 수 있는 소스의 kubeconfig 파일만 사용한다. 특수 제작된 kubeconfig 파일을 사용하면 악성 코드가 실행되거나 파일이 노출될 수 있다.
신뢰할 수 없는 kubeconfig 파일을 사용해야 하는 경우 셸 스크립트를 사용하는 경우처럼 먼저 신중하게 검사한다.</div><p>기본적으로 <code>kubectl</code>은 <code>$HOME/.kube</code> 디렉터리에서 <code>config</code>라는 이름의 파일을 찾는다.
<code>KUBECONFIG</code> 환경 변수를 설정하거나
<a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a> 플래그를 지정해서
다른 kubeconfig 파일을 사용할 수 있다.</p><p>kubeconfig 파일을 생성하고 지정하는 단계별 지시사항은
<a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>다중 클러스터로 접근 구성하기</a>를 참조한다.</p><h2 id=다중-클러스터-사용자와-인증-메커니즘-지원>다중 클러스터, 사용자와 인증 메커니즘 지원</h2><p>여러 클러스터가 있고, 사용자와 구성 요소가 다양한 방식으로 인증한다고 가정하자.
예를 들면 다음과 같다.</p><ul><li>실행 중인 kubelet은 인증서를 이용하여 인증할 수 있다.</li><li>사용자는 토큰으로 인증할 수 있다.</li><li>관리자는 개별 사용자에게 제공하는 인증서 집합을 가지고 있다.</li></ul><p>kubeconfig 파일을 사용하면 클러스터와 사용자와 네임스페이스를 구성할 수 있다.
또한 컨텍스트를 정의하여
빠르고 쉽게 클러스터와 네임스페이스 간에 전환할 수 있다.</p><h2 id=컨텍스트>컨텍스트</h2><p>kubeconfig에서 <em>컨텍스트</em> 요소는 편리한 이름으로 접속 매개 변수를 묶는데 사용한다.
각 컨텍스트는 클러스터, 네임스페이스와 사용자라는 세 가지 매개 변수를 가진다.
기본적으로 <code>kubectl</code> 커맨드라인 툴은 <em>현재 컨텍스트</em> 의 매개 변수를
사용하여 클러스터와 통신한다.</p><p>현재 컨택스트를 선택하려면 다음을 실행한다.</p><pre tabindex=0><code>kubectl config use-context
</code></pre><h2 id=kubeconfig-환경-변수>KUBECONFIG 환경 변수</h2><p><code>KUBECONFIG</code> 환경 변수는 kubeconfig 파일 목록을 보유한다.
리눅스 및 Mac의 경우 이는 콜론(:)으로 구분된 목록이다.
윈도우는 세미콜론(;)으로 구분한다. <code>KUBECONFIG</code> 환경 변수가 필수는 아니다.
<code>KUBECONFIG</code> 환경 변수가 없으면,
<code>kubectl</code>은 기본 kubeconfig 파일인 <code>$HOME/.kube/config</code>를 사용한다.</p><p><code>KUBECONFIG</code> 환경 변수가 존재하면, <code>kubectl</code>은
<code>KUBECONFIG</code> 환경 변수에 나열된 파일을 병합한 결과 형태의
효과적 구성을 이용한다.</p><h2 id=kubeconfig-파일-병합>kubeconfig 파일 병합</h2><p>구성을 보려면, 다음 커맨드를 입력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>앞서 설명한 것처럼, 이 출력 내용은 단일 kubeconfig 파일이나
여러 kubeconfig 파일을 병합한 결과 일 수 있다.</p><p>다음은 kubeconfig 파일을 병합할 때에 <code>kubectl</code>에서 사용하는 규칙이다.</p><ol><li><p><code>--kubeconfig</code> 플래그를 설정했으면, 지정한 파일만 사용한다. 병합하지 않는다.
이 플래그는 오직 한 개 인스턴스만 허용한다.</p><p>그렇지 않고, <code>KUBECONFIG</code> 환경 변수를 설정하였다면
병합해야 하는 파일의 목록으로 사용한다.
<code>KUBECONFIG</code> 환경 변수의 나열된 파일은
다음 규칙에 따라 병합한다.</p><ul><li>빈 파일명은 무시한다.</li><li>역 직렬화 불가한 파일 내용에 대해서 오류를 일으킨다.</li><li>특정 값이나 맵 키를 설정한 첫 번째 파일을 우선한다.</li><li>값이나 맵 키를 변경하지 않는다.
예: <code>현재 컨텍스트</code>를 설정할 첫 번째 파일의 컨택스트를 유지한다.
예: 두 파일이 <code>red-user</code>를 지정했다면, 첫 번째 파일의 <code>red-user</code> 값만을 사용한다.
두 번째 파일의 <code>red-user</code> 하위에 충돌하지 않는 항목이 있어도 버린다.</li></ul><p><code>KUBECONFIG</code> 환경 변수 설정의 예로,
<a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#kubeconfig-%ED%99%98%EA%B2%BD-%EB%B3%80%EC%88%98-%EC%84%A4%EC%A0%95>KUBECONFIG 환경 변수 설정</a>를 참조한다.</p><p>그렇지 않다면, 병합하지 않고 기본 kubeconfig 파일인 <code>$HOME/.kube/config</code>를 사용한다.</p></li><li><p>이 체인에서 첫 번째를 기반으로 사용할 컨텍스트를 결정한다.</p><ol><li>커맨드라인 플래그의 <code>--context</code>를 사용한다.</li><li>병합된 kubeconfig 파일에서 <code>current-context</code>를 사용한다.</li></ol><p>이 시점에서는 빈 컨텍스트도 허용한다.</p></li><li><p>클러스터와 사용자를 결정한다. 이 시점에서는 컨텍스트가 있을 수도 있고 없을 수도 있다.
사용자에 대해 한 번, 클러스터에 대해 한 번 총 두 번에 걸친
이 체인에서 첫 번째 것을 기반으로 클러스터와 사용자를 결정한다.</p><ol><li>커맨드라인 플래그가 존재하면, <code>--user</code> 또는 <code>--cluster</code>를 사용한다.</li><li>컨텍스트가 비어있지 않다면, 컨텍스트에서 사용자 또는 클러스터를 가져온다.</li></ol><p>이 시점에서는 사용자와 클러스터는 비워둘 수 있다.</p></li><li><p>사용할 실제 클러스터 정보를 결정한다.
이 시점에서 클러스터 정보가 있을 수 있고 없을 수도 있다.
이 체인을 기반으로 클러스터 정보를 구축한다. 첫 번째 것을 사용한다.</p><ol><li>커맨드라인 플래그가 존재하면, <code>--server</code>, <code>--certificate-authority</code>, <code>--insecure-skip-tls-verify</code>를 사용한다.</li><li>병합된 kubeconfig 파일에서 클러스터 정보 속성이 있다면 사용한다.</li><li>서버 위치가 없다면 실패한다.</li></ol></li><li><p>사용할 실제 사용자 정보를 결정한다.
사용자 당 하나의 인증 기법만 허용하는 것을 제외하고는
클러스터 정보와 동일한 규칙을 사용하여 사용자 정보를 작성한다.</p><ol><li>커맨드라인 플래그가 존재하면, <code>--client-certificate</code>, <code>--client-key</code>, <code>--username</code>, <code>--password</code>, <code>--token</code>을 사용한다.</li><li>병합된 kubeconfig 파일에서 <code>user</code> 필드를 사용한다.</li><li>충돌하는 두 가지 기법이 있다면 실패한다.</li></ol></li><li><p>여전히 누락된 정보는 기본 값을 사용하고
인증 정보를 묻는 메시지가 표시될 수 있다.</p></li></ol><h2 id=파일-참조>파일 참조</h2><p>kubeconfig 파일에서 파일과 경로 참조는 kubeconfig 파일의 위치와 관련 있다.
커맨드라인 상에 파일 참조는 현재 디렉터리를 기준으로 한다.
<code>$HOME/.kube/config</code>에서 상대 경로는 상대적으로, 절대 경로는
절대적으로 저장한다.</p><h2 id=프록시>프록시</h2><p>다음과 같이 kubeconfig 파일에서 <code>proxy-url</code>를 사용하여 <code>kubectl</code>이 각 클러스터마다 프록시를 거치도록 설정할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>proxy-url</span>:<span style=color:#bbb> </span>http://proxy.example.org:3128<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://k8s.example.org/k8s/clusters/c-xxyyzz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>다중 클러스터 접근 구성하기</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0f628478dbd58516389164933f9d7da2>6 - 윈도우 노드의 자원 관리</h1><p>이 페이지는 리눅스와 윈도우 간에 리소스를 관리하는 방법의 차이점을 간략하게 설명한다.</p><p>리눅스 노드에서, <a class=glossary-tooltip title='선택적으로 리소스를 격리, 관리, 제한하는 리눅스 프로세스의 그룹.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-cgroup' target=_blank aria-label=cgroup>cgroup</a>이
리소스 제어를 위한 파드 경계로서 사용된다.
컨테이너는 네트워크, 프로세스 및 파일시스템 격리를 위해 해당 경계 내에 생성된다.
cpu/io/memory 통계를 수집하기 위해 cgroup API를 사용할 수 있다.</p><p>반대로, 윈도우는 시스템 네임스페이스 필터와 함께
컨테이너별로 <a href=https://docs.microsoft.com/windows/win32/procthread/job-objects>잡(job) 오브젝트</a>를 사용하여
모든 프로세스를 컨테이너 안에 포함시키고 호스트와의 논리적 격리를 제공한다.
(잡 오브젝트는 윈도우의 프로세스 격리 메커니즘이며
쿠버네티스의 <a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a>과는 다른 것이다.)</p><p>네임스페이스 필터링 없이 윈도우 컨테이너를 실행할 수 있는 방법은 없다.
이는 곧 시스템 권한은 호스트 입장에서 주장할(assert) 수 없고,
이로 인해 특권을 가진(privileged) 컨테이너는 윈도우에서 사용할 수 없음을 의미한다.
또한 보안 계정 매니저(Security Account Manager, SAM)가 분리되어 있으므로
컨테이너는 호스트의 ID를 가정(assume)할 수 없다.</p><h2 id=resource-management-memory>메모리 관리</h2><p>윈도우에는 리눅스에는 있는 메모리 부족 프로세스 킬러가 없다.
윈도우는 모든 사용자 모드 메모리 할당을 항상 가상 메모리처럼 처리하며, 페이지파일(pagefile)이 필수이다.</p><p>윈도우 노드는 프로세스를 위해 메모리를 오버커밋(overcommit)하지 않는다.
이로 인해 윈도우는 메모리 컨디션에 도달하는 방식이 리눅스와 다르며,
프로세스는 메모리 부족(OOM, out of memory) 종료를 겪는 대신 디스크에 페이징을 수행한다.
메모리가 오버프로비저닝(over-provision)되고 전체 물리 메모리가 고갈되면,
페이징으로 인해 성능이 저하될 수 있다.</p><h2 id=resource-management-cpu>CPU 관리</h2><p>윈도우는 각 프로세스에 할당되는 CPU 시간의 양을 제한할 수는 있지만,
CPU 시간의 최소량을 보장하지는 않는다.</p><p>윈도우에서, kubelet은 kubelet 프로세스의
<a href=https://docs.microsoft.com/windows/win32/procthread/scheduling-priorities>스케줄링 우선 순위</a>를 설정하기 위한 명령줄 플래그인
<code>--windows-priorityclass</code>를 지원한다.
이 플래그를 사용하면 윈도우 호스트에서 실행되는 kubelet 프로세스가 다른 프로세스보다 더 많은 CPU 시간 슬라이스를 할당받는다.
할당 가능한 값 및 각각의 의미에 대한 자세한 정보는
<a href=https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities#priority-class>윈도우 프라이어리티 클래스</a>에서 확인할 수 있다.
실행 중인 파드가 kubelet의 CPU 사이클을 빼앗지 않도록 하려면, 이 플래그를 <code>ABOVE_NORMAL_PRIORITY_CLASS</code> 이상으로 설정한다.</p><h2 id=resource-reservation>리소스 예약</h2><p>운영 체제, 컨테이너 런타임, 그리고 kubelet과 같은 쿠버네티스 호스트 프로세스가 사용하는 메모리 및 CPU를 고려하기 위해,
kubelet 플래그 <code>--kube-reserved</code> 및 <code>--system-reserved</code>를 사용하여
메모리 및 CPU 리소스의 예약이 가능하다 (그리고 필요하다).
윈도우에서 이들 값은 노드의
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>할당 가능(allocatable)</a> 리소스의 계산에만 사용된다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong><p>워크로드를 배포할 때, 컨테이너에 메모리 및 CPU 리소스 제한을 걸자.
이 또한 NodeAllocatable에서 차감되며, 클러스터 수준 스케줄러가 각 파드를 어떤 노드에 할당할지 결정하는 데 도움을 준다.</p><p>제한을 설정하지 않은 파드를 스케줄링하면 윈도우 노드가 오버프로비전될 수 있으며,
극단적인 경우 노드가 비정상 상태(unhealthy)로 될 수도 있다.</p></div><p>윈도우에서는, 메모리를 최소 2GB 이상 예약하는 것이 좋다.</p><p>얼마나 많은 양의 CPU를 예약할지 결정하기 위해,
각 노드의 최대 파드 수를 확인하고 해당 노드의 시스템 서비스의 CPU 사용량을 모니터링한 뒤,
워크로드 요구사항을 충족하는 값을 선택한다.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>