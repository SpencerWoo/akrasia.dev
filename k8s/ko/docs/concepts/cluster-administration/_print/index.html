<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/cluster-administration/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/cluster-administration/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/cluster-administration/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/cluster-administration/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/cluster-administration/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/cluster-administration/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/cluster-administration/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/cluster-administration/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/cluster-administration/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/cluster-administration/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>클러스터 관리 | Kubernetes</title><meta property="og:title" content="클러스터 관리"><meta property="og:description" content="쿠버네티스 클러스터 생성 또는 관리에 관련된 로우-레벨(lower-level)의 세부 정보를 설명한다.
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/cluster-administration/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="클러스터 관리"><meta itemprop=description content="쿠버네티스 클러스터 생성 또는 관리에 관련된 로우-레벨(lower-level)의 세부 정보를 설명한다.
"><meta name=twitter:card content="summary"><meta name=twitter:title content="클러스터 관리"><meta name=twitter:description content="쿠버네티스 클러스터 생성 또는 관리에 관련된 로우-레벨(lower-level)의 세부 정보를 설명한다.
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="쿠버네티스 클러스터 생성 또는 관리에 관련된 로우-레벨(lower-level)의 세부 정보를 설명한다.
"><meta property="og:description" content="쿠버네티스 클러스터 생성 또는 관리에 관련된 로우-레벨(lower-level)의 세부 정보를 설명한다.
"><meta name=twitter:description content="쿠버네티스 클러스터 생성 또는 관리에 관련된 로우-레벨(lower-level)의 세부 정보를 설명한다.
"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/cluster-administration/"><meta property="og:title" content="클러스터 관리"><meta name=twitter:title content="클러스터 관리"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/cluster-administration/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/cluster-administration/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/cluster-administration/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/concepts/cluster-administration/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/concepts/cluster-administration/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/cluster-administration/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/cluster-administration/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/concepts/cluster-administration/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/cluster-administration/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/cluster-administration/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/cluster-administration/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/cluster-administration/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/cluster-administration/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/cluster-administration/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/concepts/cluster-administration/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/concepts/cluster-administration/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>클러스터 관리</h1><div class=lead>쿠버네티스 클러스터 생성 또는 관리에 관련된 로우-레벨(lower-level)의 세부 정보를 설명한다.</div><ul><li>1: <a href=#pg-2bf9a93ab5ba014fb6ff70b22c29d432>인증서</a></li><li>2: <a href=#pg-3aeeecf7cdb2a21eb4b31db7a71c81e2>리소스 관리</a></li><li>3: <a href=#pg-d649067a69d8d5c7e71564b42b96909e>클러스터 네트워킹</a></li><li>4: <a href=#pg-c4b1e87a84441f8a90699a345ce48d68>로깅 아키텍처</a></li><li>5: <a href=#pg-5cc31ecfba86467f8884856412cfb6b2>시스템 로그</a></li><li>6: <a href=#pg-cbfd3654996eae9fcdef009f70fa83f0>쿠버네티스 시스템 컴포넌트에 대한 메트릭</a></li><li>7: <a href=#pg-3da54ad355f6fe6574d67bd9a9a42bcb>쿠버네티스 시스템 컴포넌트에 대한 추적(trace)</a></li><li>8: <a href=#pg-08e94e6a480e0d6b2de72d84a1b97617>쿠버네티스에서 프락시(Proxy)</a></li><li>9: <a href=#pg-85d633ae590aa20ec024f1b7af1d74fc>애드온 설치</a></li></ul><div class=content><p>클러스터 관리 개요는 쿠버네티스 클러스터를 생성하거나 관리하는 모든 사람들을 위한 것이다.
핵심 쿠버네티스 <a href=/ko/docs/concepts/>개념</a>에 어느 정도 익숙하다고 가정한다.</p><h2 id=클러스터-계획>클러스터 계획</h2><p>쿠버네티스 클러스터를 계획, 설정 및 구성하는 방법에 대한 예는 <a href=/ko/docs/setup/>시작하기</a>에 있는 가이드를 참고한다.
이 문서에 나열된 솔루션을 <em>배포판</em> 이라고 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 모든 배포판이 활발하게 유지되는 것은 아니다. 최신 버전의 쿠버네티스에서 테스트된
배포판을 선택한다.</div><p>가이드를 선택하기 전에 고려해야 할 사항은 다음과 같다.</p><ul><li>컴퓨터에서 쿠버네티스를 한번 사용해보고 싶은가? 아니면, 고가용 멀티 노드 클러스터를 만들고 싶은가?
사용자의 필요에 따라 가장 적합한 배포판을 선택한다.</li><li><a href=https://cloud.google.com/kubernetes-engine/>구글 쿠버네티스 엔진(Google Kubernetes Engine)</a>과 같은 클라우드 제공자의 <strong>쿠버네티스 클러스터 호스팅</strong> 을 사용할 것인가?
아니면, <strong>자체 클러스터를 호스팅</strong> 할 것인가?</li><li>클러스터가 <strong>온-프레미스 환경</strong> 에 있나? 아니면, <strong>클라우드(IaaS)</strong> 에 있나?
쿠버네티스는 하이브리드 클러스터를 직접 지원하지는 않는다. 대신 여러 클러스터를 설정할 수 있다.</li><li><strong>온-프레미스 환경에 쿠버네티스</strong> 를 구성하는 경우,
어떤 <a href=/ko/docs/concepts/cluster-administration/networking/>네트워킹 모델</a>이 가장 적합한 지 고려한다.</li><li>쿠버네티스를 <strong>"베어 메탈" 하드웨어</strong> 에서 실행할 것인가? 아니면, <strong>가상 머신(VM)</strong> 에서 실행할 것인가?</li><li><strong>클러스터만 실행할 것인가?</strong> 아니면, <strong>쿠버네티스 프로젝트 코드를 적극적으로 개발</strong> 하는 것을 기대하는가?
만약 후자라면, 활발하게 개발이 진행되고 있는 배포판을 선택한다. 일부 배포판은 바이너리 릴리스만 사용하지만,
더 다양한 선택을 제공한다.</li><li>클러스터를 실행하는 데 필요한 <a href=/ko/docs/concepts/overview/components/>컴포넌트</a>에 익숙해지자.</li></ul><h2 id=클러스터-관리>클러스터 관리</h2><ul><li><p><a href=/ko/docs/concepts/architecture/nodes/>노드 관리</a> 방법을 배운다.</p></li><li><p>공유 클러스터에 대한 <a href=/ko/docs/concepts/policy/resource-quotas/>리소스 쿼터</a>를 설정하고 관리하는 방법을 배운다.</p></li></ul><h2 id=클러스터-보안>클러스터 보안</h2><ul><li><p><a href=/ko/docs/tasks/administer-cluster/certificates/>인증서 생성</a>은 다른 툴 체인을 사용하여
인증서를 생성하는 단계를 설명한다.</p></li><li><p><a href=/ko/docs/concepts/containers/container-environment/>쿠버네티스 컨테이너 환경</a>은
쿠버네티스 노드에서 Kubelet으로 관리하는 컨테이너에 대한 환경을 설명한다.</p></li><li><p><a href=/ko/docs/concepts/security/controlling-access>쿠버네티스 API에 대한 접근 제어</a>는
쿠버네티스가 자체 API에 대한 접근 제어를 구현하는 방법을 설명한다.</p></li><li><p><a href=/docs/reference/access-authn-authz/authentication/>인증</a>은
다양한 인증 옵션을 포함한 쿠버네티스에서의 인증에 대해 설명한다.</p></li><li><p><a href=/ko/docs/reference/access-authn-authz/authorization/>인가</a>는
인증과는 별개로, HTTP 호출 처리 방법을 제어한다.</p></li><li><p><a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러 사용하기</a>는
인증과 권한 부여 후
쿠버네티스 API 서버에 대한 요청을 가로채는 플러그인에 대해 설명한다.</p></li><li><p><a href=/ko/docs/tasks/administer-cluster/sysctl-cluster/>쿠버네티스 클러스터에서 Sysctls 사용하기</a>는
관리자가 <code>sysctl</code> 커맨드라인 도구를 사용하여 커널 파라미터를 설정하는 방법에 대해 설명한다
.</p></li><li><p><a href=/ko/docs/tasks/debug/debug-cluster/audit/>감사(audit)</a>는
쿠버네티스의 감사 로그를 다루는 방법에 대해 설명한다.</p></li></ul><h3 id=kubelet-보안>kubelet 보안</h3><ul><li><a href=/ko/docs/concepts/architecture/control-plane-node-communication/>컨트롤 플레인-노드 통신</a></li><li><a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>TLS 부트스트래핑(bootstrapping)</a></li><li><a href=/ko/docs/reference/access-authn-authz/kubelet-authn-authz/>Kubelet 인증/인가</a></li></ul><h2 id=선택적-클러스터-서비스>선택적 클러스터 서비스</h2><ul><li><p><a href=/ko/docs/concepts/services-networking/dns-pod-service/>DNS 통합</a>은
DNS 이름을 쿠버네티스 서비스로 직접 확인하는 방법을 설명한다.</p></li><li><p><a href=/ko/docs/concepts/cluster-administration/logging/>클러스터 액티비티 로깅과 모니터링</a>은
쿠버네티스에서의 로깅이 어떻게 작동하는지와 구현 방법에 대해 설명한다.</p></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf9a93ab5ba014fb6ff70b22c29d432>1 - 인증서</h1><p>클러스터를 위한 인증서를 생성하기 위해서는, <a href=/ko/docs/tasks/administer-cluster/certificates/>인증서</a>를 참고한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3aeeecf7cdb2a21eb4b31db7a71c81e2>2 - 리소스 관리</h1><p>애플리케이션을 배포하고 서비스를 통해 노출했다. 이제 무엇을 해야 할까? 쿠버네티스는 확장과 업데이트를 포함하여, 애플리케이션 배포를 관리하는 데 도움이 되는 여러 도구를 제공한다. 더 자세히 설명할 기능 중에는 <a href=/ko/docs/concepts/configuration/overview/>구성 파일</a>과 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a>이 있다.</p><h2 id=리소스-구성-구성하기>리소스 구성 구성하기</h2><p>많은 애플리케이션들은 디플로이먼트 및 서비스와 같은 여러 리소스를 필요로 한다. 여러 리소스의 관리는 동일한 파일에 그룹화하여 단순화할 수 있다(YAML에서 <code>---</code> 로 구분). 예를 들면 다음과 같다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/nginx-app.yaml download=application/nginx-app.yaml><code>application/nginx-app.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-nginx-app-yaml")' title="Copy application/nginx-app.yaml to clipboard"></img></div><div class=includecode id=application-nginx-app-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx-svc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>단일 리소스와 동일한 방식으로 여러 리소스를 생성할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx-app.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>service/my-nginx-svc created
</span></span><span style=display:flex><span>deployment.apps/my-nginx created
</span></span></code></pre></div><p>리소스는 파일에 표시된 순서대로 생성된다. 따라서, 스케줄러가 디플로이먼트와 같은 컨트롤러에서 생성한 서비스와 관련된 파드를 분산시킬 수 있으므로, 서비스를 먼저 지정하는 것이 가장 좋다.</p><p><code>kubectl apply</code> 는 여러 개의 <code>-f</code> 인수도 허용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx/nginx-svc.yaml -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml
</span></span></code></pre></div><p>그리고 개별 파일 대신 또는 추가로 디렉터리를 지정할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx/
</span></span></code></pre></div><p><code>kubectl</code> 은 접미사가 <code>.yaml</code>, <code>.yml</code> 또는 <code>.json</code> 인 파일을 읽는다.</p><p>동일한 마이크로서비스 또는 애플리케이션 티어(tier)와 관련된 리소스를 동일한 파일에 배치하고, 애플리케이션과 연관된 모든 파일을 동일한 디렉터리에 그룹화하는 것이 좋다. 애플리케이션의 티어가 DNS를 사용하여 서로 바인딩되면, 스택의 모든 컴포넌트를 함께 배포할 수 있다.</p><p>URL을 구성 소스로 지정할 수도 있다. 이는 GitHub에 체크인된 구성 파일에서 직접 배포하는 데 편리하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/nginx/nginx-deployment.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/my-nginx created
</span></span></code></pre></div><h2 id=kubectl에서의-대량-작업>kubectl에서의 대량 작업</h2><p><code>kubectl</code> 이 대량으로 수행할 수 있는 작업은 리소스 생성만이 아니다. 또한 다른 작업을 수행하기 위해, 특히 작성한 동일한 리소스를 삭제하기 위해 구성 파일에서 리소스 이름을 추출할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete -f https://k8s.io/examples/application/nginx-app.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps <span style=color:#b44>&#34;my-nginx&#34;</span> deleted
</span></span><span style=display:flex><span>service <span style=color:#b44>&#34;my-nginx-svc&#34;</span> deleted
</span></span></code></pre></div><p>두 개의 리소스가 있는 경우, 리소스/이름 구문을 사용하여 커맨드 라인에서 둘다 모두 지정할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployments/my-nginx services/my-nginx-svc
</span></span></code></pre></div><p>리소스가 많을 경우, <code>-l</code> 또는 <code>--selector</code> 를 사용하여 지정된 셀렉터(레이블 쿼리)를 지정하여 레이블별로 리소스를 필터링하는 것이 더 쉽다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment,services -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps <span style=color:#b44>&#34;my-nginx&#34;</span> deleted
</span></span><span style=display:flex><span>service <span style=color:#b44>&#34;my-nginx-svc&#34;</span> deleted
</span></span></code></pre></div><p><code>kubectl</code> 은 입력을 받아들이는 것과 동일한 구문으로 리소스 이름을 출력하므로, <code>$()</code> 또는 <code>xargs</code> 를 사용하여 작업을 연결할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get <span style=color:#a2f;font-weight:700>$(</span>kubectl create -f docs/concepts/cluster-administration/nginx/ -o name | grep service<span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>kubectl create -f docs/concepts/cluster-administration/nginx/ -o name | grep service | xargs -i kubectl get <span style=color:#666>{}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME           TYPE           CLUSTER-IP   EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>      AGE
</span></span><span style=display:flex><span>my-nginx-svc   LoadBalancer   10.0.0.208   &lt;pending&gt;     80/TCP       0s
</span></span></code></pre></div><p>위의 명령을 사용하여, 먼저 <code>examples/application/nginx/</code> 에 리소스를 생성하고 <code>-o name</code> 출력 형식으로 생성한 리소스를 출력한다(각 리소스를 resource/name으로 출력).
그런 다음 "service"만 <code>grep</code> 한 다음 <code>kubectl get</code> 으로 출력한다.</p><p>특정 디렉터리 내의 여러 서브 디렉터리에서 리소스를 구성하는 경우, <code>--filename,-f</code> 플래그와 함께 <code>--recursive</code> 또는 <code>-R</code> 을 지정하여, 서브 디렉터리에 대한 작업을 재귀적으로 수행할 수도 있다.</p><p>예를 들어, 리소스 유형별로 구성된 개발 환경에 필요한 모든 <a class=glossary-tooltip title='하나 이상의 쿠버네티스 API 오브젝트를 직렬화한 명세(specification).' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-manifest' target=_blank aria-label=매니페스트>매니페스트</a>를 보유하는 <code>project/k8s/development</code> 디렉터리가 있다고 가정하자.</p><pre tabindex=0><code>project/k8s/development
├── configmap
│   └── my-configmap.yaml
├── deployment
│   └── my-deployment.yaml
└── pvc
    └── my-pvc.yaml
</code></pre><p>기본적으로, <code>project/k8s/development</code> 에서 대량 작업을 수행하면, 서브 디렉터리를 처리하지 않고, 디렉터리의 첫 번째 레벨에서 중지된다. 다음 명령을 사용하여 이 디렉터리에 리소스를 생성하려고 하면, 오류가 발생할 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f project/k8s/development
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>error: you must provide one or more resources by argument or filename <span style=color:#666>(</span>.json|.yaml|.yml|stdin<span style=color:#666>)</span>
</span></span></code></pre></div><p>대신, 다음과 같이 <code>--filename,-f</code> 플래그와 함께 <code>--recursive</code> 또는 <code>-R</code> 플래그를 지정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f project/k8s/development --recursive
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>configmap/my-config created
</span></span><span style=display:flex><span>deployment.apps/my-deployment created
</span></span><span style=display:flex><span>persistentvolumeclaim/my-pvc created
</span></span></code></pre></div><p><code>--recursive</code> 플래그는 <code>kubectl {create,get,delete,describe,rollout}</code> 등과 같이 <code>--filename,-f</code> 플래그를 허용하는 모든 작업에서 작동한다.</p><p><code>--recursive</code> 플래그는 여러 개의 <code>-f</code> 인수가 제공될 때도 작동한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f project/k8s/namespaces -f project/k8s/development --recursive
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>namespace/development created
</span></span><span style=display:flex><span>namespace/staging created
</span></span><span style=display:flex><span>configmap/my-config created
</span></span><span style=display:flex><span>deployment.apps/my-deployment created
</span></span><span style=display:flex><span>persistentvolumeclaim/my-pvc created
</span></span></code></pre></div><p><code>kubectl</code> 에 대해 더 자세히 알고 싶다면, <a href=/ko/docs/reference/kubectl/>명령줄 도구 (kubectl)</a>를 참조한다.</p><h2 id=효과적인-레이블-사용>효과적인 레이블 사용</h2><p>지금까지 사용한 예는 모든 리소스에 최대 한 개의 레이블만 적용하는 것이었다. 세트를 서로 구별하기 위해 여러 레이블을 사용해야 하는 많은 시나리오가 있다.</p><p>예를 들어, 애플리케이션마다 <code>app</code> 레이블에 다른 값을 사용하지만, <a href=https://github.com/kubernetes/examples/tree/master/guestbook/>방명록 예제</a>와 같은 멀티-티어 애플리케이션은 각 티어를 추가로 구별해야 한다. 프론트엔드는 다음의 레이블을 가질 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span></code></pre></div><p>Redis 마스터와 슬레이브는 프론트엔드와 다른 <code>tier</code> 레이블을 가지지만, 아마도 추가로 <code>role</code> 레이블을 가질 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span></code></pre></div><p>그리고</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>slave<span style=color:#bbb>
</span></span></span></code></pre></div><p>레이블은 레이블로 지정된 차원에 따라 리소스를 분할하고 사용할 수 있게 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f examples/guestbook/all-in-one/guestbook-all-in-one.yaml
</span></span><span style=display:flex><span>kubectl get pods -Lapp -Ltier -Lrole
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                           READY     STATUS    RESTARTS   AGE       APP         TIER       ROLE
</span></span><span style=display:flex><span>guestbook-fe-4nlpb             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
</span></span><span style=display:flex><span>guestbook-fe-ght6d             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
</span></span><span style=display:flex><span>guestbook-fe-jpy62             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
</span></span><span style=display:flex><span>guestbook-redis-master-5pg3b   1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    master
</span></span><span style=display:flex><span>guestbook-redis-slave-2q2yf    1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    slave
</span></span><span style=display:flex><span>guestbook-redis-slave-qgazl    1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    slave
</span></span><span style=display:flex><span>my-nginx-divi2                 1/1       Running   <span style=color:#666>0</span>          29m       nginx       &lt;none&gt;     &lt;none&gt;
</span></span><span style=display:flex><span>my-nginx-o0ef1                 1/1       Running   <span style=color:#666>0</span>          29m       nginx       &lt;none&gt;     &lt;none&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -lapp<span style=color:#666>=</span>guestbook,role<span style=color:#666>=</span>slave
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                          READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>guestbook-redis-slave-2q2yf   1/1       Running   <span style=color:#666>0</span>          3m
</span></span><span style=display:flex><span>guestbook-redis-slave-qgazl   1/1       Running   <span style=color:#666>0</span>          3m
</span></span></code></pre></div><h2 id=카나리-canary-디플로이먼트>카나리(canary) 디플로이먼트</h2><p>여러 레이블이 필요한 또 다른 시나리오는 동일한 컴포넌트의 다른 릴리스 또는 구성의 디플로이먼트를 구별하는 것이다. 새 릴리스가 완전히 롤아웃되기 전에 실제 운영 트래픽을 수신할 수 있도록 새로운 애플리케이션 릴리스(파드 템플리트의 이미지 태그를 통해 지정됨)의 <em>카나리</em> 를 이전 릴리스와 나란히 배포하는 것이 일반적이다.</p><p>예를 들어, <code>track</code> 레이블을 사용하여 다른 릴리스를 구별할 수 있다.</p><p>기본(primary), 안정(stable) 릴리스에는 값이 <code>stable</code> 인 <code>track</code> 레이블이 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gb-frontend:v3<span style=color:#bbb>
</span></span></span></code></pre></div><p>그런 다음 서로 다른 값(예: <code>canary</code>)으로 <code>track</code> 레이블을 전달하는 방명록 프론트엔드의 새 릴리스를 생성하여, 두 세트의 파드가 겹치지 않도록 할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-canary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>canary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gb-frontend:v4<span style=color:#bbb>
</span></span></span></code></pre></div><p>프론트엔드 서비스는 레이블의 공통 서브셋을 선택하여(즉, <code>track</code> 레이블 생략) 두 레플리카 세트에 걸쳐 있으므로, 트래픽이 두 애플리케이션으로 리디렉션된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span></code></pre></div><p>안정 및 카나리 릴리스의 레플리카 수를 조정하여 실제 운영 트래픽을 수신할 각 릴리스의 비율을 결정한다(이 경우, 3:1).
확신이 들면, 안정 릴리스의 track을 새로운 애플리케이션 릴리스로 업데이트하고 카나리를 제거할 수 있다.</p><p>보다 구체적인 예시는, <a href=https://github.com/kelseyhightower/talks/tree/master/kubecon-eu-2016/demo#deploy-a-canary>Ghost 배포에 대한 튜토리얼</a>을 확인한다.</p><h2 id=레이블-업데이트>레이블 업데이트</h2><p>새로운 리소스를 만들기 전에 기존 파드 및 기타 리소스의 레이블을 다시 지정해야 하는 경우가 있다. 이것은 <code>kubectl label</code> 로 수행할 수 있다.
예를 들어, 모든 nginx 파드에 프론트엔드 티어로 레이블을 지정하려면, 다음과 같이 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx <span style=color:#b8860b>tier</span><span style=color:#666>=</span>fe
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pod/my-nginx-2035384211-j5fhi labeled
</span></span><span style=display:flex><span>pod/my-nginx-2035384211-u2c7e labeled
</span></span><span style=display:flex><span>pod/my-nginx-2035384211-u3t6x labeled
</span></span></code></pre></div><p>먼저 "app=nginx" 레이블이 있는 모든 파드를 필터링한 다음, "tier=fe" 레이블을 지정한다.
레이블을 지정한 파드를 보려면, 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -L tier
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                        READY     STATUS    RESTARTS   AGE       TIER
</span></span><span style=display:flex><span>my-nginx-2035384211-j5fhi   1/1       Running   <span style=color:#666>0</span>          23m       fe
</span></span><span style=display:flex><span>my-nginx-2035384211-u2c7e   1/1       Running   <span style=color:#666>0</span>          23m       fe
</span></span><span style=display:flex><span>my-nginx-2035384211-u3t6x   1/1       Running   <span style=color:#666>0</span>          23m       fe
</span></span></code></pre></div><p>그러면 파드 티어의 추가 레이블 열(<code>-L</code> 또는 <code>--label-columns</code> 로 지정)과 함께, 모든 "app=nginx" 파드가 출력된다.</p><p>더 자세한 내용은, <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블</a> 및 <a href=/docs/reference/generated/kubectl/kubectl-commands/#label>kubectl label</a>을 참고하길 바란다.</p><h2 id=어노테이션-업데이트>어노테이션 업데이트</h2><p>때로는 어노테이션을 리소스에 첨부하려고 할 수도 있다. 어노테이션은 도구, 라이브러리 등과 같은 API 클라이언트가 검색할 수 있는 임의의 비-식별 메타데이터이다. 이는 <code>kubectl annotate</code> 으로 수행할 수 있다. 예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl annotate pods my-nginx-v4-9gw19 <span style=color:#b8860b>description</span><span style=color:#666>=</span><span style=color:#b44>&#39;my frontend running nginx&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods my-nginx-v4-9gw19 -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: pod
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    description: my frontend running nginx
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>더 자세한 내용은, <a href=/ko/docs/concepts/overview/working-with-objects/annotations/>어노테이션</a> 및 <a href=/docs/reference/generated/kubectl/kubectl-commands/#annotate>kubectl annotate</a> 문서를 참고하길 바란다.</p><h2 id=애플리케이션-스케일링>애플리케이션 스케일링</h2><p>애플리케이션의 로드가 증가하거나 축소되면, <code>kubectl</code> 을 사용하여 애플리케이션을 스케일링한다. 예를 들어, nginx 레플리카 수를 3에서 1로 줄이려면, 다음을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment/my-nginx --replicas<span style=color:#666>=</span><span style=color:#666>1</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/my-nginx scaled
</span></span></code></pre></div><p>이제 디플로이먼트가 관리하는 파드가 하나만 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                        READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>my-nginx-2035384211-j5fhi   1/1       Running   <span style=color:#666>0</span>          30m
</span></span></code></pre></div><p>시스템이 필요에 따라 1에서 3까지의 범위에서 nginx 레플리카 수를 자동으로 선택하게 하려면, 다음을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment/my-nginx --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>3</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>horizontalpodautoscaler.autoscaling/my-nginx autoscaled
</span></span></code></pre></div><p>이제 nginx 레플리카가 필요에 따라 자동으로 확장되거나 축소된다.</p><p>더 자세한 내용은, <a href=/docs/reference/generated/kubectl/kubectl-commands/#scale>kubectl scale</a>, <a href=/docs/reference/generated/kubectl/kubectl-commands/#autoscale>kubectl autoscale</a> 및 <a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/>horizontal pod autoscaler</a> 문서를 참고하길 바란다.</p><h2 id=리소스-인플레이스-in-place-업데이트>리소스 인플레이스(in-place) 업데이트</h2><p>때로는 자신이 만든 리소스를 필요한 부분만, 중단없이 업데이트해야 할 때가 있다.</p><h3 id=kubectl-apply>kubectl apply</h3><p>구성 파일 셋을 소스 제어에서 유지하는 것이 좋으며
(<a href=https://martinfowler.com/bliki/InfrastructureAsCode.html>코드로서의 구성</a> 참조),
그렇게 하면 구성하는 리소스에 대한 코드와 함께 버전을 지정하고 유지할 수 있다.
그런 다음, <a href=/docs/reference/generated/kubectl/kubectl-commands/#apply><code>kubectl apply</code></a>를 사용하여 구성 변경 사항을 클러스터로 푸시할 수 있다.</p><p>이 명령은 푸시하려는 구성의 버전을 이전 버전과 비교하고 지정하지 않은 속성에 대한 자동 변경 사항을 덮어쓰지 않은 채 수정한 변경 사항을 적용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml
</span></span><span style=display:flex><span>deployment.apps/my-nginx configured
</span></span></code></pre></div><p>참고로 <code>kubectl apply</code> 는 이전의 호출 이후 구성의 변경 사항을 판별하기 위해 리소스에 어노테이션을 첨부한다. 호출되면, <code>kubectl apply</code> 는 리소스를 수정하는 방법을 결정하기 위해, 이전 구성과 제공된 입력 및 리소스의 현재 구성 간에 3-way diff를 수행한다.</p><p>현재, 이 어노테이션 없이 리소스가 생성되므로, <code>kubectl apply</code> 의 첫 번째 호출은 제공된 입력과 리소스의 현재 구성 사이의 2-way diff로 대체된다. 이 첫 번째 호출 중에는, 리소스를 생성할 때 설정된 특성의 삭제를 감지할 수 없다. 이러한 이유로, 그 특성들을 삭제하지 않는다.</p><p><code>kubectl apply</code> 에 대한 모든 후속 호출, 그리고 <code>kubectl replace</code> 및 <code>kubectl edit</code> 와 같이 구성을 수정하는 다른 명령은, 어노테이션을 업데이트하여, <code>kubectl apply</code> 에 대한 후속 호출이 3-way diff를 사용하여 삭제를 감지하고 수행할 수 있도록 한다.</p><h3 id=kubectl-edit>kubectl edit</h3><p>또는, <code>kubectl edit</code>로 리소스를 업데이트할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment/my-nginx
</span></span></code></pre></div><p>이것은 먼저 리소스를 <code>get</code> 하여, 텍스트 편집기에서 편집한 다음, 업데이트된 버전으로 리소스를 <code>apply</code> 하는 것과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment my-nginx -o yaml &gt; /tmp/nginx.yaml
</span></span><span style=display:flex><span>vi /tmp/nginx.yaml
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 편집한 다음, 파일을 저장한다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl apply -f /tmp/nginx.yaml
</span></span><span style=display:flex><span>deployment.apps/my-nginx configured
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rm /tmp/nginx.yaml
</span></span></code></pre></div><p>이를 통해 보다 중요한 변경을 더 쉽게 수행할 수 있다. 참고로 <code>EDITOR</code> 또는 <code>KUBE_EDITOR</code> 환경 변수를 사용하여 편집기를 지정할 수 있다.</p><p>더 자세한 내용은, <a href=/docs/reference/generated/kubectl/kubectl-commands/#edit>kubectl edit</a> 문서를 참고하길 바란다.</p><h3 id=kubectl-patch>kubectl patch</h3><p><code>kubectl patch</code> 를 사용하여 API 오브젝트를 인플레이스 업데이트할 수 있다. 이 명령은 JSON 패치,
JSON 병합 패치 그리고 전략적 병합 패치를 지원한다.
<a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>kubectl patch를 사용한 인플레이스 API 오브젝트 업데이트</a>와
<a href=/docs/reference/generated/kubectl/kubectl-commands/#patch>kubectl patch</a>를
참조한다.</p><h2 id=파괴적-disruptive-업데이트>파괴적(disruptive) 업데이트</h2><p>경우에 따라, 한 번 초기화하면 업데이트할 수 없는 리소스 필드를 업데이트해야 하거나, 디플로이먼트에서 생성된 손상된 파드를 고치는 등의 재귀적 변경을 즉시 원할 수도 있다. 이러한 필드를 변경하려면, <code>replace --force</code> 를 사용하여 리소스를 삭제하고 다시 만든다. 이 경우, 원래 구성 파일을 수정할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml --force
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/my-nginx deleted
</span></span><span style=display:flex><span>deployment.apps/my-nginx replaced
</span></span></code></pre></div><h2 id=서비스-중단없이-애플리케이션-업데이트>서비스 중단없이 애플리케이션 업데이트</h2><p>언젠가는, 위의 카나리 디플로이먼트 시나리오에서와 같이, 일반적으로 새 이미지 또는 이미지 태그를 지정하여, 배포된 애플리케이션을 업데이트해야 한다. <code>kubectl</code> 은 여러 가지 업데이트 작업을 지원하며, 각 업데이트 작업은 서로 다른 시나리오에 적용할 수 있다.</p><p>디플로이먼트를 사용하여 애플리케이션을 생성하고 업데이트하는 방법을 안내한다.</p><p>nginx 1.14.2 버전을 실행한다고 가정해 보겠다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment my-nginx --image<span style=color:#666>=</span>nginx:1.14.2
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/my-nginx created
</span></span></code></pre></div><p>3개의 레플리카를 포함한다(이전과 새 개정판이 공존할 수 있음).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment my-nginx --current-replicas<span style=color:#666>=</span><span style=color:#666>1</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/my-nginx scaled
</code></pre><p>1.16.1 버전으로 업데이트하려면, 위에서 배운 kubectl 명령을 사용하여 <code>.spec.template.spec.containers[0].image</code> 를 <code>nginx:1.14.2</code> 에서 <code>nginx:1.16.1</code> 로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment/my-nginx
</span></span></code></pre></div><p>이것으로 끝이다! 디플로이먼트는 배포된 nginx 애플리케이션을 배후에서 점차적으로 업데이트한다. 업데이트되는 동안 특정 수의 이전 레플리카만 중단될 수 있으며, 원하는 수의 파드 위에 특정 수의 새 레플리카만 생성될 수 있다. 이에 대한 더 자세한 내용을 보려면, <a href=/ko/docs/tasks/debug/debug-application/debug-running-pod/>디플로이먼트 페이지</a>를 방문한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/debug/debug-application/debug-running-pod/>애플리케이션 검사 및 디버깅에 <code>kubectl</code> 을 사용하는 방법</a>에 대해 알아본다.</li><li><a href=/ko/docs/concepts/configuration/overview/>구성 모범 사례 및 팁</a>을 참고한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d649067a69d8d5c7e71564b42b96909e>3 - 클러스터 네트워킹</h1><p>네트워킹은 쿠버네티스의 중심적인 부분이지만, 어떻게 작동하는지 정확하게
이해하기가 어려울 수 있다. 쿠버네티스에는 4가지 대응해야 할 네트워킹
문제가 있다.</p><ol><li>고도로 결합된 컨테이너 간의 통신: 이 문제는
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>와 <code>localhost</code> 통신으로 해결된다.</li><li>파드 간 통신: 이 문제가 이 문서의 주요 초점이다.</li><li>파드와 서비스 간 통신: 이 문제는 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>에서 다룬다.</li><li>외부와 서비스 간 통신: 이 문제는 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>에서 다룬다.</li></ol><p>쿠버네티스는 애플리케이션 간에 머신을 공유하는 것이다. 일반적으로,
머신을 공유하려면 두 애플리케이션이 동일한 포트를 사용하지 않도록
해야 한다. 여러 개발자 간에 포트를 조정하는 것은 대규모로 실시하기가 매우 어렵고,
사용자가 통제할 수 없는 클러스터 수준의 문제에 노출된다.</p><p>동적 포트 할당은 시스템에 많은 복잡성을 야기한다. 모든
애플리케이션은 포트를 플래그로 가져와야 하며, API 서버는 동적 포트 번호를
구성 블록에 삽입하는 방법을 알아야 하고, 서비스는 서로를
찾는 방법 등을 알아야 한다. 쿠버네티스는 이런 것들을 다루는 대신
다른 접근법을 취한다.</p><p>쿠버네티스 네트워킹 모델에 대한 상세 정보는 <a href=/ko/docs/concepts/services-networking/>여기</a>를 참고한다.</p><h2 id=쿠버네티스-네트워크-모델의-구현-방법>쿠버네티스 네트워크 모델의 구현 방법</h2><p>네트워크 모델은 각 노드의 컨테이너 런타임에 의해 구현된다. 가장 일반적인 컨테이너 런타임은 <a href=https://github.com/containernetworking/cni>컨테이너 네트워크 인터페이스</a>(CNI) 플러그인을 사용하여 네트워크 및 보안 기능을 관리한다. 여러 공급 업체의 다양한 CNI 플러그인이 존재하며, 이들 중 일부는 네트워크 인터페이스를 추가 및 제거하는 기본 기능만 제공하는 반면, 다른 일부는 다른 컨테이너 오케스트레이션 시스템과의 통합, 여러 CNI 플러그인 실행, 고급 IPAM 기능 등과 같은 보다 정교한 솔루션을 제공한다.</p><p>쿠버네티스에서 지원하는 네트워킹 애드온의 일부 목록은 <a href=/ko/docs/concepts/cluster-administration/addons/#network-and-networking-policy>이 페이지</a>를 참조한다.</p><h2 id=다음-내용>다음 내용</h2><p>네트워크 모델의 초기 설계와 그 근거 및 미래의 계획은
<a href=https://git.k8s.io/design-proposals-archive/network/networking.md>네트워킹 디자인 문서</a>에
자세히 설명되어 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c4b1e87a84441f8a90699a345ce48d68>4 - 로깅 아키텍처</h1><p>애플리케이션 로그는 애플리케이션 내부에서 발생하는 상황을 이해하는 데 도움이 된다. 로그는 문제를 디버깅하고 클러스터 활동을 모니터링하는 데 특히 유용하다. 대부분의 최신 애플리케이션에는 일종의 로깅 메커니즘이 있다. 마찬가지로, 컨테이너 엔진들도 로깅을 지원하도록 설계되었다. 컨테이너화된 애플리케이션에 가장 쉽고 가장 널리 사용되는 로깅 방법은 표준 출력과 표준 에러 스트림에 작성하는 것이다.</p><p>그러나, 일반적으로 컨테이너 엔진이나 런타임에서 제공하는 기본 기능은 완전한 로깅 솔루션으로 충분하지 않다.</p><p>예를 들어, 컨테이너가 크래시되거나, 파드가 축출되거나, 노드가 종료된 경우에도 애플리케이션의 로그에 접근하고 싶을 것이다.</p><p>클러스터에서 로그는 노드, 파드 또는 컨테이너와는 독립적으로 별도의 스토리지와 라이프사이클을 가져야 한다. 이 개념을 <em>클러스터-레벨-로깅</em> 이라고 한다.</p><p>클러스터-레벨 로깅은 로그를 저장, 분석, 쿼리하기 위해서는 별도의 백엔드가 필요하다. 쿠버네티스가
로그 데이터를 위한 네이티브 스토리지 솔루션을 제공하지는 않지만,
쿠버네티스에 통합될 수 있는 기존의 로깅 솔루션이 많이 있다.</p><h2 id=쿠버네티스의-기본-로깅>쿠버네티스의 기본 로깅</h2><p>이 예시는 텍스트를 초당 한 번씩 표준 출력에 쓰는
컨테이너에 대한 <code>Pod</code> 명세를 사용한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/debug/counter-pod.yaml download=debug/counter-pod.yaml><code>debug/counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("debug-counter-pod-yaml")' title="Copy debug/counter-pod.yaml to clipboard"></img></div><div class=includecode id=debug-counter-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#39;i=0; while true; do echo &#34;$i: $(date)&#34;; i=$((i+1)); sleep 1; done&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이 파드를 실행하려면, 다음의 명령을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/debug/counter-pod.yaml
</span></span></code></pre></div><p>출력은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>pod/counter created
</span></span></span></code></pre></div><p>로그를 가져오려면, 다음과 같이 <code>kubectl logs</code> 명령을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter
</span></span></code></pre></div><p>출력은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>0: Mon Jan  1 00:00:00 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>1: Mon Jan  1 00:00:01 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>2: Mon Jan  1 00:00:02 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span></code></pre></div><p><code>kubectl logs --previous</code> 를 사용해서 컨테이너의 이전 인스턴스에 대한 로그를 검색할 수 있다.
파드에 여러 컨테이너가 있는 경우,
다음과 같이 명령에 <code>-c</code> 플래그와 컨테이너 이름을 추가하여 접근하려는 컨테이너 로그를 지정해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl logs counter -c count
</span></span></span></code></pre></div><p>자세한 내용은 <a href=/docs/reference/generated/kubectl/kubectl-commands#logs><code>kubectl logs</code> 문서</a>를 참조한다.</p><h2 id=노드-레벨에서의-로깅>노드 레벨에서의 로깅</h2><p><img src=/images/docs/user-guide/logging/logging-node-level.png alt="노드 레벨 로깅"></p><p>컨테이너화된 애플리케이션의 <code>stdout(표준 출력)</code> 및 <code>stderr(표준 에러)</code> 스트림에 의해 생성된 모든 출력은 컨테이너 엔진이 처리 및 리디렉션 한다.
예를 들어, 도커 컨테이너 엔진은 이 두 스트림을 <a href=https://docs.docker.com/engine/admin/logging/overview>로깅 드라이버</a>로 리디렉션 한다. 이 드라이버는 쿠버네티스에서 JSON 형식의 파일에 작성하도록 구성된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 도커 JSON 로깅 드라이버는 각 라인을 별도의 메시지로 취급한다. 도커 로깅 드라이버를 사용하는 경우, 멀티-라인 메시지를 직접 지원하지 않는다. 로깅 에이전트 레벨 이상에서 멀티-라인 메시지를 처리해야 한다.</div><p>기본적으로, 컨테이너가 다시 시작되면, kubelet은 종료된 컨테이너 하나를 로그와 함께 유지한다. 파드가 노드에서 축출되면, 해당하는 모든 컨테이너도 로그와 함께 축출된다.</p><p>노드-레벨 로깅에서 중요한 고려 사항은 로그 로테이션을 구현하여,
로그가 노드에서 사용 가능한 모든 스토리지를 사용하지 않도록 하는 것이다. 쿠버네티스는
로그 로테이션에 대한 의무는 없지만, 디플로이먼트 도구로
이를 해결하기 위한 솔루션을 설정해야 한다.
예를 들어, <code>kube-up.sh</code> 스크립트에 의해 배포된 쿠버네티스 클러스터에는,
매시간 실행되도록 구성된 <a href=https://linux.die.net/man/8/logrotate><code>logrotate</code></a>
도구가 있다. 애플리케이션의 로그를 자동으로
로테이션하도록 컨테이너 런타임을 설정할 수도 있다.</p><p>예를 들어, <code>kube-up.sh</code> 가 GCP의 COS 이미지 로깅을 설정하는 방법은
<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh><code>configure-helper</code> 스크립트</a>를 통해
자세히 알 수 있다.</p><p><strong>CRI 컨테이너 런타임</strong> 을 사용할 때, kubelet은 로그를 로테이션하고 로깅 디렉터리 구조를 관리한다.
kubelet은 이 정보를 CRI 컨테이너 런타임에 전송하고 런타임은 컨테이너 로그를 지정된 위치에 기록한다.
<a href=/docs/tasks/administer-cluster/kubelet-config-file/>kubelet config file</a>에 있는
두 개의 kubelet 파라미터 <a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>containerLogMaxSize</code> 및 <code>containerLogMaxFiles</code></a>를
사용하여 각 로그 파일의 최대 크기와 각 컨테이너에 허용되는 최대 파일 수를 각각 구성할 수 있다.</p><p>기본 로깅 예제에서와 같이 <a href=/docs/reference/generated/kubectl/kubectl-commands#logs><code>kubectl logs</code></a>를
실행하면, 노드의 kubelet이 요청을 처리하고
로그 파일에서 직접 읽는다. kubelet은 로그 파일의 내용을 반환한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 만약, 일부 외부 시스템이 로테이션을 수행했거나 CRI 컨테이너 런타임이 사용된 경우,
<code>kubectl logs</code> 를 통해 최신 로그 파일의 내용만
사용할 수 있다. 예를 들어, 10MB 파일이 있으면, <code>logrotate</code> 가
로테이션을 수행하고 두 개의 파일이 생긴다. (크기가 10MB인 파일 하나와 비어있는 파일)
<code>kubectl logs</code> 는 이 예시에서는 빈 응답에 해당하는 최신 로그 파일을 반환한다.</div><h3 id=시스템-컴포넌트-로그>시스템 컴포넌트 로그</h3><p>시스템 컴포넌트에는 컨테이너에서 실행되는 것과 컨테이너에서 실행되지 않는 두 가지 유형이 있다.
예를 들면 다음과 같다.</p><ul><li>쿠버네티스 스케줄러와 kube-proxy는 컨테이너에서 실행된다.</li><li>Kubelet과 컨테이너 런타임은 컨테이너에서 실행되지 않는다.</li></ul><p>systemd를 사용하는 시스템에서는, kubelet과 컨테이너 런타임은 journald에 작성한다.
systemd를 사용하지 않으면, kubelet과 컨테이너 런타임은 <code>/var/log</code> 디렉터리의
<code>.log</code> 파일에 작성한다. 컨테이너 내부의 시스템 컴포넌트는 기본 로깅 메커니즘을 무시하고,
항상 <code>/var/log</code> 디렉터리에 기록한다.
시스템 컴포넌트는 <a href=https://github.com/kubernetes/klog>klog</a>
로깅 라이브러리를 사용한다. <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>로깅에 대한 개발 문서</a>에서
해당 컴포넌트의 로깅 심각도(severity)에 대한 규칙을 찾을 수 있다.</p><p>컨테이너 로그와 마찬가지로, <code>/var/log</code> 디렉터리의 시스템 컴포넌트 로그를
로테이트해야 한다. <code>kube-up.sh</code> 스크립트로 구축한 쿠버네티스 클러스터에서
로그는 매일 또는 크기가 100MB를 초과하면
<code>logrotate</code> 도구에 의해 로테이트가 되도록 구성된다.</p><h2 id=클러스터-레벨-로깅-아키텍처>클러스터 레벨 로깅 아키텍처</h2><p>쿠버네티스는 클러스터-레벨 로깅을 위한 네이티브 솔루션을 제공하지 않지만, 고려해야 할 몇 가지 일반적인 접근 방법을 고려할 수 있다. 여기 몇 가지 옵션이 있다.</p><ul><li>모든 노드에서 실행되는 노드-레벨 로깅 에이전트를 사용한다.</li><li>애플리케이션 파드에 로깅을 위한 전용 사이드카 컨테이너를 포함한다.</li><li>애플리케이션 내에서 로그를 백엔드로 직접 푸시한다.</li></ul><h3 id=노드-로깅-에이전트-사용>노드 로깅 에이전트 사용</h3><p><img src=/images/docs/user-guide/logging/logging-with-node-agent.png alt="노드 레벨 로깅 에이전트 사용"></p><p>각 노드에 <em>노드-레벨 로깅 에이전트</em> 를 포함시켜 클러스터-레벨 로깅을 구현할 수 있다. 로깅 에이전트는 로그를 노출하거나 로그를 백엔드로 푸시하는 전용 도구이다. 일반적으로, 로깅 에이전트는 해당 노드의 모든 애플리케이션 컨테이너에서 로그 파일이 있는 디렉터리에 접근할 수 있는 컨테이너이다.</p><p>로깅 에이전트는 모든 노드에서 실행되어야 하므로, 에이전트를
<code>DaemonSet</code> 으로 동작시키는 것을 추천한다.</p><p>노드-레벨 로깅은 노드별 하나의 에이전트만 생성하며, 노드에서 실행되는 애플리케이션에 대한 변경은 필요로 하지 않는다.</p><p>컨테이너는 로그를 stdout과 stderr로 출력하며, 합의된 형식은 없다. 노드-레벨 에이전트는 이러한 로그를 수집하고 취합을 위해 전달한다.</p><h3 id=sidecar-container-with-logging-agent>로깅 에이전트와 함께 사이드카 컨테이너 사용</h3><p>다음 중 한 가지 방법으로 사이드카 컨테이너를 사용할 수 있다.</p><ul><li>사이드카 컨테이너는 애플리케이션 로그를 자체 <code>stdout</code> 으로 스트리밍한다.</li><li>사이드카 컨테이너는 로깅 에이전트를 실행하며, 애플리케이션 컨테이너에서 로그를 가져오도록 구성된다.</li></ul><h4 id=사이드카-컨테이너-스트리밍>사이드카 컨테이너 스트리밍</h4><p><img src=/images/docs/user-guide/logging/logging-with-streaming-sidecar.png alt="스트리밍 컨테이너가 있는 사이드카 컨테이너"></p><p>사이드카 컨테이너가 자체 <code>stdout</code> 및 <code>stderr</code> 스트림으로
쓰도록 하면, 각 노드에서 이미 실행 중인 kubelet과 로깅 에이전트를
활용할 수 있다. 사이드카 컨테이너는 파일, 소켓 또는 journald에서 로그를 읽는다.
각 사이드카 컨테이너는 자체 <code>stdout</code> 또는 <code>stderr</code> 스트림에 로그를 출력한다.</p><p>이 방법을 사용하면 애플리케이션의 다른 부분에서 여러 로그 스트림을
분리할 수 있고, 이 중 일부는 <code>stdout</code> 또는 <code>stderr</code> 에
작성하기 위한 지원이 부족할 수 있다. 로그를 리디렉션하는 로직은
최소화되어 있기 때문에, 심각한 오버헤드가 아니다. 또한,
<code>stdout</code> 및 <code>stderr</code> 가 kubelet에서 처리되므로, <code>kubectl logs</code> 와 같은
빌트인 도구를 사용할 수 있다.</p><p>예를 들어, 파드는 단일 컨테이너를 실행하고, 컨테이너는
서로 다른 두 가지 형식을 사용하여 서로 다른 두 개의 로그 파일에 기록한다. 파드에 대한
구성 파일은 다음과 같다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/logging/two-files-counter-pod.yaml download=admin/logging/two-files-counter-pod.yaml><code>admin/logging/two-files-counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-yaml")' title="Copy admin/logging/two-files-counter-pod.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>두 컴포넌트를 컨테이너의 <code>stdout</code> 스트림으로 리디렉션한 경우에도, 동일한 로그
스트림에 서로 다른 형식의 로그 항목을 작성하는 것은
추천하지 않는다. 대신, 두 개의 사이드카 컨테이너를 생성할 수 있다. 각 사이드카
컨테이너는 공유 볼륨에서 특정 로그 파일을 테일(tail)한 다음 로그를
자체 <code>stdout</code> 스트림으로 리디렉션할 수 있다.</p><p>다음은 사이드카 컨테이너가 두 개인 파드에 대한 구성 파일이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/logging/two-files-counter-pod-streaming-sidecar.yaml download=admin/logging/two-files-counter-pod-streaming-sidecar.yaml><code>admin/logging/two-files-counter-pod-streaming-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-streaming-sidecar-yaml")' title="Copy admin/logging/two-files-counter-pod-streaming-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-streaming-sidecar-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -F /var/log/1.log&#39;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -F /var/log/2.log&#39;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이제 이 파드를 실행하면, 다음의 명령을 실행하여 각 로그 스트림에
개별적으로 접근할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter count-log-1
</span></span></code></pre></div><p>출력은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>0: Mon Jan  1 00:00:00 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>1: Mon Jan  1 00:00:01 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>2: Mon Jan  1 00:00:02 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter count-log-2
</span></span></code></pre></div><p>출력은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>Mon Jan  1 00:00:00 UTC 2001 INFO 0
</span></span></span><span style=display:flex><span><span style=color:#888>Mon Jan  1 00:00:01 UTC 2001 INFO 1
</span></span></span><span style=display:flex><span><span style=color:#888>Mon Jan  1 00:00:02 UTC 2001 INFO 2
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span></code></pre></div><p>클러스터에 설치된 노드-레벨 에이전트는 추가 구성없이
자동으로 해당 로그 스트림을 선택한다. 원한다면, 소스 컨테이너에
따라 로그 라인을 파싱(parse)하도록 에이전트를 구성할 수 있다.</p><p>참고로, CPU 및 메모리 사용량이 낮음에도 불구하고(cpu에 대한 몇 밀리코어의
요구와 메모리에 대한 몇 메가바이트의 요구), 로그를 파일에 기록한 다음
<code>stdout</code> 으로 스트리밍하면 디스크 사용량은 두 배가 될 수 있다. 단일 파일에
쓰는 애플리케이션이 있는 경우, 일반적으로 스트리밍
사이드카 컨테이너 방식을 구현하는 대신 <code>/dev/stdout</code> 을 대상으로
설정하는 것을 추천한다.</p><p>사이드카 컨테이너를 사용하여 애플리케이션 자체에서 로테이션할 수 없는
로그 파일을 로테이션할 수도 있다. 이 방법의 예시는 정기적으로 <code>logrotate</code> 를 실행하는 작은 컨테이너를 두는 것이다.
그러나, <code>stdout</code> 및 <code>stderr</code> 을 직접 사용하고 로테이션과
유지 정책을 kubelet에 두는 것이 권장된다.</p><h4 id=로깅-에이전트가-있는-사이드카-컨테이너>로깅 에이전트가 있는 사이드카 컨테이너</h4><p><img src=/images/docs/user-guide/logging/logging-with-sidecar-agent.png alt="로깅 에이전트가 있는 사이드카 컨테이너"></p><p>노드-레벨 로깅 에이전트가 상황에 맞게 충분히 유연하지 않은 경우,
애플리케이션과 함께 실행하도록 특별히 구성된 별도의 로깅 에이전트를 사용하여
사이드카 컨테이너를 생성할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 사이드카 컨테이너에서 로깅 에이전트를 사용하면
상당한 리소스 소비로 이어질 수 있다. 게다가, kubelet에 의해
제어되지 않기 때문에, <code>kubectl logs</code> 를 사용하여 해당 로그에
접근할 수 없다.</div><p>여기에 로깅 에이전트가 포함된 사이드카 컨테이너를 구현하는 데 사용할 수 있는 두 가지 구성 파일이 있다. 첫 번째 파일에는
fluentd를 구성하기 위한 <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/><code>ConfigMap</code></a>이 포함되어 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/logging/fluentd-sidecar-config.yaml download=admin/logging/fluentd-sidecar-config.yaml><code>admin/logging/fluentd-sidecar-config.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-fluentd-sidecar-config-yaml")' title="Copy admin/logging/fluentd-sidecar-config.yaml to clipboard"></img></div><div class=includecode id=admin-logging-fluentd-sidecar-config-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fluentd.conf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type tail
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      format none
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      path /var/log/1.log
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      pos_file /var/log/1.log.pos
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      tag count.format1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type tail
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      format none
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      path /var/log/2.log
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      pos_file /var/log/2.log.pos
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      tag count.format2
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;match **&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type google_cloud
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/match&gt;</span><span style=color:#bbb>    
</span></span></span></code></pre></div></div></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> fluentd를 구성하는 것에 대한 자세한 내용은, <a href=https://docs.fluentd.org/>fluentd 문서</a>를 참고한다.</div><p>두 번째 파일은 fluentd가 실행되는 사이드카 컨테이너가 있는 파드를 설명한다.
파드는 fluentd가 구성 데이터를 가져올 수 있는 볼륨을 마운트한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/admin/logging/two-files-counter-pod-agent-sidecar.yaml download=admin/logging/two-files-counter-pod-agent-sidecar.yaml><code>admin/logging/two-files-counter-pod-agent-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-agent-sidecar-yaml")' title="Copy admin/logging/two-files-counter-pod-agent-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-agent-sidecar-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/fluentd-gcp:1.30<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>FLUENTD_ARGS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>-c /etc/fluentd-config/fluentd.conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/fluentd-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이 예시 구성에서, 사용자는 애플리케이션 컨테이너 내의 모든 소스을 읽는 fluentd를 다른 로깅 에이전트로 대체할 수 있다.</p><h3 id=애플리케이션에서-직접-로그-노출>애플리케이션에서 직접 로그 노출</h3><p><img src=/images/docs/user-guide/logging/logging-from-application.png alt="애플리케이션에서 직접 로그 노출"></p><p>애플리케이션에서 직접 로그를 노출하거나 푸시하는 클러스터-로깅은 쿠버네티스의 범위를 벗어난다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5cc31ecfba86467f8884856412cfb6b2>5 - 시스템 로그</h1><p>시스템 컴포넌트 로그는 클러스터에서 발생하는 이벤트를 기록하며, 이는 디버깅에 아주 유용하다.
더 많거나 적은 세부 정보를 표시하도록 다양하게 로그를 설정할 수 있다.
로그는 컴포넌트 내에서 오류를 표시하는 것 처럼 간단하거나, 이벤트의 단계적 추적(예: HTTP 엑세스 로그, 파드의 상태 변경, 컨트롤러 작업 또는 스케줄러의 결정)을 표시하는 것처럼 세밀할 수 있다.</p><h2 id=klog>Klog</h2><p>klog는 쿠버네티스의 로깅 라이브러리다. <a href=https://github.com/kubernetes/klog>klog</a>는
쿠버네티스 시스템 컴포넌트의 로그 메시지를 생성한다.</p><p>klog 설정에 대한 더 많은 정보는, <a href=/ko/docs/reference/command-line-tools-reference/>커맨드라인 툴</a>을 참고한다.</p><p>쿠버네티스는 각 컴포넌트의 로깅을 간소화하는 중에 있다.
다음 klog 명령줄 플래그는 쿠버네티스 1.23에서
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>사용 중단</a>되었으며
이후 릴리스에서 제거될 것이다.</p><ul><li><code>--add-dir-header</code></li><li><code>--alsologtostderr</code></li><li><code>--log-backtrace-at</code></li><li><code>--log-dir</code></li><li><code>--log-file</code></li><li><code>--log-file-max-size</code></li><li><code>--logtostderr</code></li><li><code>--one-output</code></li><li><code>--skip-headers</code></li><li><code>--skip-log-headers</code></li><li><code>--stderrthreshold</code></li></ul><p>출력은 출력 형식에 관계없이 항상 표준 에러(stderr)에 기록될 것이다.
출력 리다이렉션은 쿠버네티스 컴포넌트를 호출하는 컴포넌트가 담당할 것으로 기대된다.
이는 POSIX 셸 또는 systemd와 같은 도구일 수
있다.</p><p>배포판과 무관한(distroless) 컨테이너 또는 윈도우 시스템 서비스와 같은 몇몇 경우에서,
위의 옵션은 사용할 수 없다.
그런 경우 출력을 리다이렉트하기 위해
<a href=https://github.com/kubernetes/kubernetes/blob/d2a8a81639fcff8d1221b900f66d28361a170654/staging/src/k8s.io/component-base/logs/kube-log-runner/README.md><code>kube-log-runner</code></a>
바이너리를 쿠버네티스 컴포넌트의 래퍼(wrapper)로 사용할 수 있다.
미리 빌드된 바이너리가 몇몇 쿠버네티스 베이스 이미지에 기본 이름 <code>/go-runner</code> 와
서버 및 노드 릴리스 아카이브에는 <code>kube-log-runner</code>라는 이름으로 포함되어 있다.</p><p>다음 표는 각 <code>kube-log-runner</code> 실행법이 어떤 셸 리다이렉션에 해당되는지 보여준다.</p><table><thead><tr><th>사용법</th><th>POSIX 셸 (예:) bash)</th><th><code>kube-log-runner &lt;options> &lt;cmd></code></th></tr></thead><tbody><tr><td>stderr와 stdout을 합치고, stdout으로 출력</td><td><code>2>&1</code></td><td><code>kube-log-runner</code> (기본 동작))</td></tr><tr><td>stderr와 stdout을 로그 파일에 기록</td><td><code>1>>/tmp/log 2>&1</code></td><td><code>kube-log-runner -log-file=/tmp/log</code></td></tr><tr><td>로그 파일에 기록하면서 stdout으로 출력</td><td><code>2>&1 | tee -a /tmp/log</code></td><td><code>kube-log-runner -log-file=/tmp/log -also-stdout</code></td></tr><tr><td>stdout만 로그 파일에 기록</td><td><code>>/tmp/log</code></td><td><code>kube-log-runner -log-file=/tmp/log -redirect-stderr=false</code></td></tr></tbody></table><h3 id=klog-출력>Klog 출력</h3><p>klog 네이티브 형식 예 :</p><pre tabindex=0><code>I1025 00:15:15.525108       1 httplog.go:79] GET /api/v1/namespaces/kube-system/pods/metrics-server-v0.3.1-57c75779f-9p8wg: (1.512ms) 200 [pod_nanny/v0.0.0 (linux/amd64) kubernetes/$Format 10.56.1.19:51756]
</code></pre><p>메시지 문자열은 줄바꿈을 포함하고 있을 수도 있다.</p><pre tabindex=0><code>I1025 00:15:15.525108       1 example.go:79] This is a message
which has a line break.
</code></pre><h3 id=구조화된-로깅>구조화된 로깅</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [beta]</code></div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong><p>구조화된 로그메시지로 마이그레이션은 진행중인 작업이다. 이 버전에서는 모든 로그 메시지가 구조화되지 않는다. 로그 파일을 파싱할 때, 구조화되지 않은 로그 메시지도 처리해야 한다.</p><p>로그 형식 및 값 직렬화는 변경될 수 있다.</p></div><p>구조화된 로깅은 로그 메시지에 통일된 구조를 적용하여 정보를 쉽게 추출하고,
로그를 보다 쉽고 저렴하게 저장하고 처리하는 작업이다.
새로운 메시지 형식은 이전 버전과 호환되며 기본적으로 활성화 된다.</p><p>구조화된 로그 메시지의 기본 형식은 텍스트이며,
기존 klog와 하위 호환되는 형식이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#b44>&lt;klog header&gt; &#34;&lt;message&gt;&#34; &lt;key1&gt;</span><span style=color:#666>=</span><span style=color:#b44>&#34;&lt;value1&gt;&#34; &lt;key2&gt;=&#34;&lt;value2&gt;&#34; ...</span>
</span></span></code></pre></div><p>예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#b44>I1025 00:15:15.525108       1 controller_utils.go:116] &#34;Pod status updated&#34; pod</span><span style=color:#666>=</span><span style=color:#b44>&#34;kube-system/kubedns&#34; status=&#34;ready&#34;</span>
</span></span></code></pre></div><p>문자열은 따옴표로 감싸진다. 다른 값들은
<a href=https://pkg.go.dev/fmt#hdr-Printing><code>%+v</code></a>로 포맷팅되며, 이로 인해
<a href=https://github.com/kubernetes/kubernetes/issues/106428>데이터에 따라</a> 로그 메시지가 다음 줄로 이어질 수 있다.</p><pre tabindex=0><code>I1025 00:15:15.525108       1 example.go:116] &#34;Example&#34; data=&#34;This is text with a line break\nand \&#34;quotation marks\&#34;.&#34; someInt=1 someFloat=0.1 someStruct={StringField: First line,
second line.}
</code></pre><h3 id=컨텍스츄얼-로깅-contextual-logging>컨텍스츄얼 로깅(Contextual Logging)</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [alpha]</code></div><p>컨텍스츄얼 로깅은 구조화된 로깅을 기반으로 한다.
컨텍스츄얼 로깅은 주로 개발자가 로깅 호출을 사용하는 방법에 관한 것이다.
해당 개념을 기반으로 하는 코드는 좀 더 유연하며,
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/3077-contextual-logging>컨텍스츄얼 로깅 KEP</a>에 기술된 추가적인 사용 사례를 지원한다.</p><p>개발자가 자신의 구성 요소에서
<code>WithValues</code> 또는 <code>WithName</code>과 같은 추가 기능을 사용하는 경우,
로그 항목에는 호출자가 함수로 전달하는 추가 정보가 포함된다.</p><p>현재 이 기능은 <code>StructuredLogging</code> 기능 게이트 뒤에 있으며
기본적으로 비활성화되어 있다.
이 기능을 위한 인프라는 구성 요소를 수정하지 않고 1.24에 추가되었다.
<a href=https://github.com/kubernetes/kubernetes/blob/v1.24.0-beta.0/staging/src/k8s.io/component-base/logs/example/cmd/logger.go><code>component-base/logs/example</code></a>
명령은 새 로깅 호출을 사용하는 방법과
컨텍스츄얼 로깅을 지원하는 구성 요소가 어떻게 작동하는지 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> <span style=color:#a2f>cd</span> <span style=color:#b8860b>$GOPATH</span>/src/k8s.io/kubernetes/staging/src/k8s.io/component-base/logs/example/cmd/
</span></span><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> go run . --help
</span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span><span style=display:flex><span><span style=color:#888>      --feature-gates mapStringBool  A set of key=value pairs that describe feature gates for alpha/experimental features. Options are:
</span></span></span><span style=display:flex><span><span style=color:#888>                                     AllAlpha=true|false (ALPHA - default=false)
</span></span></span><span style=display:flex><span><span style=color:#888>                                     AllBeta=true|false (BETA - default=false)
</span></span></span><span style=display:flex><span><span style=color:#888>                                     ContextualLogging=true|false (ALPHA - default=false)
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:navy;font-weight:700>$</span> go run . --feature-gates <span style=color:#b8860b>ContextualLogging</span><span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span><span style=display:flex><span><span style=color:#888>I0404 18:00:02.916429  451895 logger.go:94] &#34;example/myname: runtime&#34; foo=&#34;bar&#34; duration=&#34;1m0s&#34;
</span></span></span><span style=display:flex><span><span style=color:#888>I0404 18:00:02.916447  451895 logger.go:95] &#34;example: another runtime&#34; foo=&#34;bar&#34; duration=&#34;1m0s&#34;
</span></span></span></code></pre></div><p><code>runtime</code> 메시지 및 <code>duration="1m0s"</code> 값을 로깅하는
기존 로깅 함수를 수정하지 않고도,
이 함수의 호출자에 의해 <code>example</code> 접두사 및 <code>foo="bar"</code> 문자열이 로그에 추가되었다.</p><p>컨텍스츄얼 로깅이 비활성화되어 있으면, <code>WithValues</code> 및 <code>WithName</code> 은 아무 효과가 없으며,
로그 호출은 전역 klog 로거를 통과한다.
따라서 이 추가 정보는 더 이상 로그 출력에 포함되지 않는다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> go run . --feature-gates <span style=color:#b8860b>ContextualLogging</span><span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span><span style=display:flex><span><span style=color:#888>I0404 18:03:31.171945  452150 logger.go:94] &#34;runtime&#34; duration=&#34;1m0s&#34;
</span></span></span><span style=display:flex><span><span style=color:#888>I0404 18:03:31.171962  452150 logger.go:95] &#34;another runtime&#34; duration=&#34;1m0s&#34;
</span></span></span></code></pre></div><h3 id=json-로그-형식>JSON 로그 형식</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.19 [alpha]</code></div><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong><p>JSON 출력은 많은 표준 klog 플래그를 지원하지 않는다. 지원하지 않는 klog 플래그 목록은, <a href=/ko/docs/reference/command-line-tools-reference/>커맨드라인 툴</a>을 참고한다.</p><p>모든 로그가 JSON 형식으로 작성되는 것은 아니다(예: 프로세스 시작 중). 로그를 파싱하려는 경우 JSON 형식이 아닌 로그 행을 처리할 수 있는지 확인해야 한다.</p><p>필드 이름과 JSON 직렬화는 변경될 수 있다.</p></div><p><code>--logging-format=json</code> 플래그는 로그 형식을 klog 기본 형식에서 JSON 형식으로 변경한다.
JSON 로그 형식 예시(보기좋게 출력된 형태)는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;ts&#34;</span>: <span style=color:#666>1580306777.04728</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;v&#34;</span>: <span style=color:#666>4</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;msg&#34;</span>: <span style=color:#b44>&#34;Pod status updated&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;pod&#34;</span>:{
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>
</span></span><span style=display:flex><span>   },
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;ready&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>특별한 의미가 있는 키:</p><ul><li><code>ts</code> - Unix 시간의 타임스탬프 (필수, 부동 소수점)</li><li><code>v</code> - 자세한 정도 (필수, 정수, 기본 값 0)</li><li><code>err</code> - 오류 문자열 (선택 사항, 문자열)</li><li><code>msg</code> - 메시지 (필수, 문자열)</li></ul><p>현재 JSON 형식을 지원하는 컴포넌트 목록:</p><ul><li><a class=glossary-tooltip title='컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a></li><li><a class=glossary-tooltip title='쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a></li><li><a class=glossary-tooltip title='노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li><li><a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a></li></ul><h3 id=로그-상세-레벨-verbosity>로그 상세 레벨(verbosity)</h3><p><code>-v</code> 플래그로 로그 상세 레벨(verbosity)을 제어한다. 값을 늘리면 기록된 이벤트 수가 증가한다. 값을 줄이면 기록된 이벤트 수가 줄어든다.
로그 상세 레벨(verbosity)를 높이면 점점 덜 심각한 이벤트가 기록된다. 로그 상세 레벨(verbosity)을 0으로 설정하면 중요한 이벤트만 기록된다.</p><h3 id=로그-위치>로그 위치</h3><p>시스템 컴포넌트에는 컨테이너에서 실행되는 것과 컨테이너에서 실행되지 않는 두 가지 유형이 있다.
예를 들면 다음과 같다.</p><ul><li>쿠버네티스 스케줄러와 kube-proxy는 컨테이너에서 실행된다.</li><li>kubelet과 <a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>은
컨테이너에서 실행되지 않는다.</li></ul><p>systemd를 사용하는 시스템에서는, kubelet과 컨테이너 런타임은 jounald에 기록한다.
그 외 시스템에서는, <code>/var/log</code> 디렉터리의 <code>.log</code> 파일에 기록한다.
컨테이너 내부의 시스템 컴포넌트들은 기본 로깅 메커니즘을 무시하고,
항상 <code>/var/log</code> 디렉터리의 <code>.log</code> 파일에 기록한다.
컨테이너 로그와 마찬가지로, <code>/var/log</code> 디렉터리의 시스템 컴포넌트 로그들은 로테이트해야 한다.
<code>kube-up.sh</code> 스크립트로 생성된 쿠버네티스 클러스터에서는, <code>logrotate</code> 도구로 로그가 로테이트되도록 설정된다.
<code>logrotate</code> 도구는 로그가 매일 또는 크기가 100MB 보다 클 때 로테이트된다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/cluster-administration/logging/>쿠버네티스 로깅 아키텍처</a> 알아보기</li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/1602-structured-logging>구조화된 로깅</a> 알아보기</li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/3077-contextual-logging>컨텍스츄얼 로깅</a> 알아보기</li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/2845-deprecate-klog-specific-flags-in-k8s-components>klog 플래그 사용 중단</a> 알아보기</li><li><a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>로깅 심각도(serverity) 규칙</a> 알아보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-cbfd3654996eae9fcdef009f70fa83f0>6 - 쿠버네티스 시스템 컴포넌트에 대한 메트릭</h1><p>시스템 컴포넌트 메트릭으로 내부에서 발생하는 상황을 더 잘 파악할 수 있다. 메트릭은 대시보드와 경고를 만드는 데 특히 유용하다.</p><p>쿠버네티스 컴포넌트의 메트릭은 <a href=https://prometheus.io/docs/instrumenting/exposition_formats/>프로메테우스 형식</a>으로 출력된다.
이 형식은 구조화된 평문으로 디자인되어 있으므로 사람과 기계 모두가 쉽게 읽을 수 있다.</p><h2 id=쿠버네티스의-메트릭>쿠버네티스의 메트릭</h2><p>대부분의 경우 메트릭은 HTTP 서버의 <code>/metrics</code> 엔드포인트에서 사용할 수 있다. 기본적으로 엔드포인트를 노출하지 않는 컴포넌트의 경우 <code>--bind-address</code> 플래그를 사용하여 활성화할 수 있다.</p><p>해당 컴포넌트의 예는 다음과 같다.</p><ul><li><a class=glossary-tooltip title='컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a></li><li><a class=glossary-tooltip title='kube-proxy는 클러스터의 각 노드에서 실행되는 네트워크 프록시이다.' data-toggle=tooltip data-placement=top href=/ko/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a></li><li><a class=glossary-tooltip title='쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a></li><li><a class=glossary-tooltip title='노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li><li><a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a></li></ul><p>프로덕션 환경에서는 이러한 메트릭을 주기적으로 수집하고 시계열 데이터베이스에서 사용할 수 있도록
<a href=https://prometheus.io/>프로메테우스 서버</a> 또는 다른 메트릭 수집기(scraper)를 구성할 수 있다.</p><p>참고로 <a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>도 <code>/metrics/cadvisor</code>, <code>/metrics/resource</code> 그리고 <code>/metrics/probes</code> 엔드포인트에서 메트릭을 노출한다. 이러한 메트릭은 동일한 라이프사이클을 가지지 않는다.</p><p>클러스터가 <a class=glossary-tooltip title='인가 결정을 관리하며, 운영자가 쿠버네티스 API를 통해서 동적으로 엑세스 정책을 설정하게 한다.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a>을 사용하는 경우, 메트릭을 읽으려면 <code>/metrics</code> 에 접근을 허용하는 클러스터롤(ClusterRole)을 가지는 사용자, 그룹 또는 서비스어카운트(ServiceAccount)를 통한 권한이 필요하다.
예를 들면, 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prometheus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;/metrics&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- get<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=메트릭-라이프사이클>메트릭 라이프사이클</h2><p>알파(Alpha) 메트릭 → 안정적인(Stable) 메트릭 → 사용 중단된(Deprecated) 메트릭 → 히든(Hidden) 메트릭 → 삭제된(Deleted) 메트릭</p><p>알파 메트릭은 안정성을 보장하지 않는다. 따라서 언제든지 수정되거나 삭제될 수 있다.</p><p>안정적인 메트릭은 변경되지 않는다는 것을 보장한다. 이것은 다음을 의미한다.</p><ul><li>사용 중단 표기가 없는 안정적인 메트릭은, 이름이 변경되거나 삭제되지 않는다.</li><li>안정적인 메트릭의 유형(type)은 수정되지 않는다.</li></ul><p>사용 중단된 메트릭은 해당 메트릭이 결국 삭제된다는 것을 나타내지만, 아직은 사용 가능하다는 뜻이다.
이 메트릭은 어느 버전에서부터 사용 중단된 것인지를 표시하는 어노테이션을 포함한다.</p><p>예를 들면,</p><ul><li>사용 중단 이전에는 다음과 같다.</li></ul><pre tabindex=0><code># HELP some_counter this counts things
# TYPE some_counter counter
some_counter 0
</code></pre><ul><li>사용 중단 이후에는 다음과 같다.</li></ul><pre tabindex=0><code># HELP some_counter (Deprecated since 1.15.0) this counts things
# TYPE some_counter counter
some_counter 0
</code></pre><p>히든 메트릭은 깔끔함(scraping)을 위해 더 이상 게시되지는 않지만, 여전히 사용은 가능하다. 히든 메트릭을 사용하려면, <a href=#%ED%9E%88%EB%93%A0-%EB%A9%94%ED%8A%B8%EB%A6%AD-%ED%91%9C%EC%8B%9C>히든 메트릭 표시</a> 섹션을 참고한다.</p><p>삭제된 메트릭은 더 이상 게시되거나 사용할 수 없다.</p><h2 id=히든-메트릭-표시>히든 메트릭 표시</h2><p>위에서 설명한 것처럼, 관리자는 특정 바이너리의 커맨드 라인 플래그를 통해 히든 메트릭을 활성화할 수 있다. 관리자가 지난 릴리스에서 사용 중단된 메트릭의 마이그레이션을 놓친 경우 관리자를 위한 임시방편으로 사용된다.</p><p><code>show-hidden-metrics-for-version</code> 플래그는 해당 릴리스에서 사용 중단된 메트릭을 보여주려는 버전을 사용한다. 버전은 xy로 표시되며, 여기서 x는 메이저(major) 버전이고, y는 마이너(minor) 버전이다. 패치 릴리스에서 메트릭이 사용 중단될 수 있지만, 패치 버전은 필요하지 않다. 그 이유는 메트릭 사용 중단 정책이 마이너 릴리스에 대해 실행되기 때문이다.</p><p>플래그는 그 값으로 이전의 마이너 버전만 사용할 수 있다. 관리자가 이전 버전을 <code>show-hidden-metrics-for-version</code> 에 설정하면 이전 버전의 모든 히든 메트릭이 생성된다. 사용 중단 메트릭 정책을 위반하기 때문에 너무 오래된 버전은 허용되지 않는다.</p><p>1.n 버전에서 사용 중단되었다고 가정한 메트릭 <code>A</code> 를 예로 들어보겠다. 메트릭 사용 중단 정책에 따르면, 다음과 같은 결론에 도달할 수 있다.</p><ul><li><code>1.n</code> 릴리스에서는 메트릭이 사용 중단되었으며, 기본적으로 생성될 수 있다.</li><li><code>1.n+1</code> 릴리스에서는 기본적으로 메트릭이 숨겨져 있으며, <code>show-hidden-metrics-for-version=1.n</code> 커맨드 라인에 의해서 생성될 수 있다.</li><li><code>1.n+2</code> 릴리스에서는 코드베이스에서 메트릭이 제거되어야 한다. 더이상 임시방편은 존재하지 않는다.</li></ul><p>릴리스 <code>1.12</code> 에서 <code>1.13</code> 으로 업그레이드 중이지만, <code>1.12</code> 에서 사용 중단된 메트릭 <code>A</code> 를 사용하고 있다면, 커맨드 라인에서 <code>--show-hidden-metrics=1.12</code> 플래그로 히든 메트릭을 설정해야 하고, <code>1.14</code> 로 업그레이드하기 전에 이 메트릭을 사용하지 않도록 의존성을 제거하는 것을 기억해야 한다.</p><h2 id=액셀러레이터-메트릭-비활성화>액셀러레이터 메트릭 비활성화</h2><p>kubelet은 cAdvisor를 통해 액셀러레이터 메트릭을 수집한다. NVIDIA GPU와 같은 액셀러레이터의 경우, 이러한 메트릭을 수집하기 위해 kubelet은 드라이버에 열린 핸들을 가진다. 이는 인프라 변경(예: 드라이버 업데이트)을 수행하기 위해 클러스터 관리자가 kubelet 에이전트를 중지해야 함을 의미한다.</p><p>액셀러레이터 메트릭을 수집하는 책임은 이제 kubelet이 아닌 공급 업체에 있다. 공급 업체는 메트릭을 수집하여 메트릭 서비스(예: 프로메테우스)에 노출할 컨테이너를 제공해야 한다.</p><p>[<code>DisableAcceleratorUsageMetrics</code> 기능 게이트](/ko/docs/reference/command-line-tools-reference/feature-gates/#알파-또는-베타-기능을-위한-기능-게이트:~:text= DisableAcceleratorUsageMetrics,-false)는 <a href=https://github.com/kubernetes/enhancements/tree/411e51027db842355bd489691af897afc1a41a5e/keps/sig-node/1867-disable-accelerator-usage-metrics#graduation-criteria>이 기능을 기본적으로 사용하도록 설정하는 타임라인</a>를 사용하여 kubelet에서 수집한 메트릭을 비활성화한다.</p><h2 id=컴포넌트-메트릭>컴포넌트 메트릭</h2><h3 id=kube-controller-manager-메트릭>kube-controller-manager 메트릭</h3><p>컨트롤러 관리자 메트릭은 컨트롤러 관리자의 성능과 상태에 대한 중요한 인사이트를 제공한다.
이러한 메트릭에는 go_routine 수와 같은 일반적인 Go 언어 런타임 메트릭과
etcd 요청 대기 시간 또는 Cloudprovider(AWS, GCE, OpenStack) API 대기 시간과 같은 컨트롤러 특정 메트릭이 포함되어
클러스터의 상태를 측정하는 데 사용할 수 있다.</p><p>쿠버네티스 1.7부터 GCE, AWS, Vsphere 및 OpenStack의 스토리지 운영에 대한 상세한 Cloudprovider 메트릭을 사용할 수 있다.
이 메트릭은 퍼시스턴트 볼륨 동작의 상태를 모니터링하는 데 사용할 수 있다.</p><p>예를 들어, GCE의 경우 이러한 메트릭을 다음과 같이 호출한다.</p><pre tabindex=0><code>cloudprovider_gce_api_request_duration_seconds { request = &#34;instance_list&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;disk_insert&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;disk_delete&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;attach_disk&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;detach_disk&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;list_disk&#34;}
</code></pre><h3 id=kube-scheduler-메트릭>kube-scheduler 메트릭</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [beta]</code></div><p>스케줄러는 실행 중인 모든 파드의 요청(request)된 리소스와 요구되는 제한(limit)을 보고하는 선택적 메트릭을 노출한다. 이러한 메트릭은 용량 계획(capacity planning) 대시보드를 구축하고, 현재 또는 과거 스케줄링 제한을 평가하고, 리소스 부족으로 스케줄할 수 없는 워크로드를 빠르게 식별하고, 실제 사용량을 파드의 요청과 비교하는 데 사용할 수 있다.</p><p>kube-scheduler는 각 파드에 대해 구성된 리소스 <a href=/ko/docs/concepts/configuration/manage-resources-containers/>요청과 제한</a>을 식별한다. 요청 또는 제한이 0이 아닌 경우 kube-scheduler는 메트릭 시계열을 보고한다. 시계열에는 다음과 같은 레이블이 지정된다.</p><ul><li>네임스페이스</li><li>파드 이름</li><li>파드가 스케줄된 노드 또는 아직 스케줄되지 않은 경우 빈 문자열</li><li>우선순위</li><li>해당 파드에 할당된 스케줄러</li><li>리소스 이름 (예: <code>cpu</code>)</li><li>알려진 경우 리소스 단위 (예: <code>cores</code>)</li></ul><p>파드가 완료되면 (<code>Never</code> 또는 <code>OnFailure</code>의 <code>restartPolicy</code>가 있고 <code>Succeeded</code> 또는 <code>Failed</code> 파드 단계에 있거나, 삭제되고 모든 컨테이너가 종료된 상태에 있음) 스케줄러가 이제 다른 파드를 실행하도록 스케줄할 수 있으므로 시리즈가 더 이상 보고되지 않는다. 두 메트릭을 <code>kube_pod_resource_request</code> 및 <code>kube_pod_resource_limit</code> 라고 한다.</p><p>메트릭은 HTTP 엔드포인트 <code>/metrics/resources</code>에 노출되며 스케줄러의 <code>/metrics</code> 엔드포인트
와 동일한 인증이 필요하다. 이러한 알파 수준의 메트릭을 노출시키려면 <code>--show-hidden-metrics-for-version=1.20</code> 플래그를 사용해야 한다.</p><h2 id=메트릭-비활성화>메트릭 비활성화</h2><p>커맨드 라인 플래그 <code>--disabled-metrics</code> 를 통해 메트릭을 명시적으로 끌 수 있다. 이 방법이 필요한 이유는 메트릭이 성능 문제를 일으키는 경우을 예로 들 수 있다. 입력값은 비활성화되는 메트릭 목록이다(예: <code>--disabled-metrics=metric1,metric2</code>).</p><h2 id=메트릭-카디널리티-cardinality-적용>메트릭 카디널리티(cardinality) 적용</h2><p>제한되지 않은 차원의 메트릭은 계측하는 컴포넌트에서 메모리 문제를 일으킬 수 있다. 리소스 사용을 제한하려면, <code>--allow-label-value</code> 커맨드 라인 옵션을 사용하여 메트릭 항목에 대한 레이블 값의 허용 목록(allow-list)을 동적으로 구성한다.</p><p>알파 단계에서, 플래그는 메트릭 레이블 허용 목록으로 일련의 매핑만 가져올 수 있다.
각 매핑은 <code>&lt;metric_name>,&lt;label_name>=&lt;allowed_labels></code> 형식이다. 여기서
<code>&lt;allowed_labels></code> 는 허용되는 레이블 이름의 쉼표로 구분된 목록이다.</p><p>전체 형식은 다음과 같다.
<code>--allow-label-value &lt;metric_name>,&lt;label_name>='&lt;allow_value1>, &lt;allow_value2>...', &lt;metric_name2>,&lt;label_name>='&lt;allow_value1>, &lt;allow_value2>...', ...</code>.</p><p>예시는 다음과 같다.
<code>--allow-label-value number_count_metric,odd_number='1,3,5', number_count_metric,even_number='2,4,6', date_gauge_metric,weekend='Saturday,Sunday'</code></p><h2 id=다음-내용>다음 내용</h2><ul><li>메트릭에 대한 <a href=https://github.com/prometheus/docs/blob/master/content/docs/instrumenting/exposition_formats.md#text-based-format>프로메테우스 텍스트 형식</a>에 대해 읽어본다</li><li><a href=https://github.com/kubernetes/kubernetes/blob/master/test/instrumentation/testdata/stable-metrics-list.yaml>안정 버전의 쿠버네티스 메트릭</a> 목록을 살펴본다</li><li><a href=/docs/reference/using-api/deprecation-policy/#deprecating-a-feature-or-behavior>쿠버네티스 사용 중단 정책</a>에 대해 읽어본다</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3da54ad355f6fe6574d67bd9a9a42bcb>7 - 쿠버네티스 시스템 컴포넌트에 대한 추적(trace)</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.22 [alpha]</code></div><p>시스템 컴포넌트 추적은 클러스터 내에서 수행된 동작들 간의 지연(latency)과 관계(relationship)를 기록한다.</p><p>쿠버네티스 컴포넌트들은 <a href=https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md#opentelemetry-protocol-specification>OpenTelemetry 프로토콜</a>과
gRPC exporter를 이용하여 추적을 생성하고
<a href=https://github.com/open-telemetry/opentelemetry-collector#-opentelemetry-collector>OpenTelemetry 수집기</a>를
통해 추적 백엔드(tracing backends)로 라우팅되거나 수집될 수 있다.</p><h2 id=추적-수집>추적 수집</h2><p>추적 수집 및 수집기에 대한 전반적인 가이드는
<a href=https://opentelemetry.io/docs/collector/getting-started/>OpenTelemetry 수집기 시작하기</a>에서 제공한다.
그러나, 쿠버네티스 컴포넌트에 관련된 몇 가지 사항에 대해서는 특별히 살펴볼 필요가 있다.</p><p>기본적으로, 쿠버네티스 컴포넌트들은 <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=opentelemetry">IANA OpenTelemetry 포트</a>인
4317 포트로 OTLP에 대한 grpc exporter를 이용하여 추적를 내보낸다.
예를 들면, 수집기가 쿠버네티스 컴포넌트에 대해 사이드카(sidecar)로 동작한다면,
다음과 같은 리시버 설정을 통해 스팬(span)을 수집하고 그 로그를 표준 출력(standard output)으로 내보낼 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>receivers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>otlp</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocols</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>grpc</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>exporters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 이 exporter를 사용자의 백엔드를 위한 exporter로 변경</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>logging</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>logLevel</span>:<span style=color:#bbb> </span>debug<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pipelines</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>traces</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>receivers</span>:<span style=color:#bbb> </span>[otlp]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>exporters</span>:<span style=color:#bbb> </span>[logging]<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=컴포넌트-추적>컴포넌트 추적</h2><h3 id=kube-apiserver-추적>kube-apiserver 추적</h3><p>kube-apiserver는 들어오는 HTTP 요청들과
webhook, etcd 로 나가는 요청들, 그리고 재진입 요청들에 대해 span을 생성한다.
kube-apiserver는 자주 퍼블릭 엔드포인트로 이용되기 때문에,
들어오는 요청들에 첨부된 추적 컨택스트를 사용하지 않고,
나가는 요청들을 통해 <a href=https://www.w3.org/TR/trace-context/>W3C Trace Context</a>를 전파한다.</p><h4 id=kube-apiserver-에서의-추적-활성화>kube-apiserver 에서의 추적 활성화</h4><p>추적을 활성화하기 위해서는, kube-apiserve에서 <code>APIServerTracing</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화한다.
또한, kube-apiserver의 추적 설정 파일에
<code>--tracing-config-file=&lt;path-to-config></code>을 추가한다.
다음은 10000개 요청 당 1개에 대한 span을 기록하는 설정에 대한 예시이고, 이는 기본 OpenTelemetry 엔드포인트를 이용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>TracingConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 기본값</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#endpoint: localhost:4317</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>samplingRatePerMillion</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>TracingConfiguration</code> 구조체에 대해 더 많은 정보를 얻고 싶다면
<a href=/docs/reference/config-api/apiserver-config.v1alpha1/#apiserver-k8s-io-v1alpha1-TracingConfiguration>API server config API (v1alpha1)</a>를 참고한다.</p><h3 id=kubelet-추적>kubelet 추적</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [alpha]</code></div><p>kubelet CRI 인터페이스와 인증된 http 서버는 추적(trace) 스팬(span)을 생성하도록 설정 할수 있다.
apiserver와 마찬가지로 해당 엔드포인트 및 샘플링률을 구성할 수 있다.
추적 컨텍스트 전파(trace context propagation)도 구성할 수 있다. 상위 스팬(span)의 샘플링 설정이 항상 적용된다.
제공되는 설정의 샘플링률은 상위가 없는 스팬(span)에 기본 적용된다.
엔드포인트를 구성하지 않고 추적을 활성화로 설정하면, 기본 OpenTelemetry Collector receiver 주소는 "localhost:4317"으로 기본 설정된다.</p><h4 id=kubelet-tracing-활성화>kubelet tracing 활성화</h4><p>추적을 활성화하려면 kubelet에서 <code>KubeletTracing</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트(feature gate)</a>을 활성화한다.
또한 kubelet에서
<a href=https://github.com/kubernetes/component-base/blob/release-1.25/tracing/api/v1/types.go>tracing configuration</a>을 제공한다.
<a href=https://github.com/kubernetes/component-base/blob/release-1.25/tracing/api/v1/types.go>tracing 구성</a>을 참조한다.
다음은 10000개 요청 중 1개에 대하여 스팬(span)을 기록하고, 기본 OpenTelemetry 앤드포인트를 사용하도록 한 kubelet 구성 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>featureGates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>KubeletTracing</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>tracing</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 기본값</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#endpoint: localhost:4317</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>samplingRatePerMillion</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=안정성>안정성</h2><p>추적의 계측화(tracing instrumentation)는 여전히 활발히 개발되는 중이어서 다양한 형태로 변경될 수 있다.
스팬(span)의 이름, 첨부되는 속성, 계측될 엔드포인트(instrumented endpoints)들 등이 그렇다.
이 속성이 안정화(graduates to stable)되기 전까지는
이전 버전과의 호환성은 보장되지 않는다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=https://opentelemetry.io/docs/collector/getting-started/>OpenTelemetry 수집기 시작하기</a>을 참고</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-08e94e6a480e0d6b2de72d84a1b97617>8 - 쿠버네티스에서 프락시(Proxy)</h1><p>이 페이지는 쿠버네티스에서 함께 사용되는 프락시(Proxy)를 설명한다.</p><h2 id=프락시>프락시</h2><p>쿠버네티스를 이용할 때에 사용할 수 있는 여러 프락시가 있다.</p><ol><li><p><a href=/ko/docs/tasks/access-application-cluster/access-cluster/#rest-api%EC%97%90-%EC%A7%81%EC%A0%91-%EC%95%A1%EC%84%B8%EC%8A%A4>kubectl proxy</a>:</p><ul><li>사용자의 데스크탑이나 파드 안에서 실행한다.</li><li>로컬 호스트 주소에서 쿠버네티스의 API 서버로 프락시한다.</li><li>클라이언트로 프락시는 HTTP를 사용한다.</li><li>API 서버로 프락시는 HTTPS를 사용한다.</li><li>API 서버를 찾는다.</li><li>인증 헤더를 추가한다.</li></ul></li><li><p><a href=/ko/docs/tasks/access-application-cluster/access-cluster-services/#discovering-builtin-services>apiserver proxy</a>:</p><ul><li>API 서버에 내장된 요새(bastion)이다.</li><li>클러스터 외부의 사용자가 도달할 수 없는 클러스터 IP 주소로 연결한다.</li><li>API 서버 프로세스에서 실행한다.</li><li>클라이언트로 프락시는 HTTPS(또는 API서버에서 HTTP로 구성된 경우는 HTTP)를 사용한다.</li><li>사용 가능한 정보를 이용하여 프락시에 의해 선택한 HTTP나 HTTPS를 사용할 수 있는 대상이다.</li><li>노드, 파드, 서비스에 도달하는데 사용할 수 있다.</li><li>서비스에 도달할 때에는 로드 밸런싱을 수행한다.</li></ul></li><li><p><a href=/ko/docs/concepts/services-networking/service/#ips-and-vips>kube proxy</a>:</p><ul><li>각 노드에서 실행한다.</li><li>UDP, TCP, SCTP를 이용하여 프락시 한다.</li><li>HTTP는 이해하지 못한다.</li><li>로드 밸런싱을 제공한다.</li><li>서비스에 도달하는데만 사용한다.</li></ul></li><li><p>API 서버 앞단의 프락시/로드밸런서</p><ul><li>존재 및 구현은 클러스터 마다 다르다. (예: nginx)</li><li>모든 클라이언트와 하나 이상의 API 서버에 위치한다.</li><li>여러 API 서버가 있는 경우 로드 밸런서로서 작동한다.</li></ul></li><li><p>외부 서비스의 클라우드 로드 밸런서</p><ul><li>일부 클라우드 제공자는 제공한다. (예: AWS ELB, 구글 클라우드 로드 밸런서)</li><li>쿠버네티스 서비스로 <code>LoadBalancer</code> 유형이 있으면 자동으로 생성된다.</li><li>일반적으로 UDP/TCP만 지원한다.</li><li>SCTP 지원은 클라우드 제공자의 구현에 달려 있다.</li><li>구현은 클라우드 제공자에 따라 다양하다.</li></ul></li></ol><p>쿠버네티스 사용자는 보통 처음 두 가지 유형 외의 것은 걱정할 필요없다.
클러스터 관리자는 일반적으로 후자의 유형이 올바르게 구성되었는지 확인한다.</p><h2 id=요청을-리다이렉트하기>요청을 리다이렉트하기</h2><p>프락시는 리다이렉트 기능을 대체했다. 리다이렉트는 더 이상 사용하지 않는다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-85d633ae590aa20ec024f1b7af1d74fc>9 - 애드온 설치</h1><div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div><p>애드온은 쿠버네티스의 기능을 확장한다.</p><p>이 페이지는 사용 가능한 일부 애드온과 관련 설치 지침 링크를 나열한다. 이 목차에서 전체를 다루지는 않는다.</p><h2 id=네트워킹과-네트워크-폴리시>네트워킹과 네트워크 폴리시</h2><ul><li><a href=https://www.github.com/noironetworks/aci-containers>ACI</a>는 Cisco ACI로 통합 컨테이너 네트워킹 및 네트워크 보안을 제공한다.</li><li><a href=https://antrea.io/>Antrea</a>는 레이어 3/4에서 작동하여 쿠버네티스를 위한 네트워킹 및 보안 서비스를 제공하며, Open vSwitch를 네트워킹 데이터 플레인으로 활용한다.</li><li><a href=https://docs.projectcalico.org/latest/introduction/>Calico</a>는 네트워킹 및 네트워크 폴리시 제공자이다. Calico는 유연한 네트워킹 옵션을 지원하므로 BGP 유무에 관계없이 비-오버레이 및 오버레이 네트워크를 포함하여 가장 상황에 맞는 옵션을 선택할 수 있다. Calico는 동일한 엔진을 사용하여 서비스 메시 계층(service mesh layer)에서 호스트, 파드 및 (이스티오(istio)와 Envoy를 사용하는 경우) 애플리케이션에 대한 네트워크 폴리시를 적용한다.</li><li><a href=https://projectcalico.docs.tigera.io/getting-started/kubernetes/flannel/flannel>Canal</a>은 Flannel과 Calico를 통합하여 네트워킹 및 네트워크 폴리시를 제공한다.</li><li><a href=https://github.com/cilium/cilium>Cilium</a>은 네트워킹, 관측 용의성(Observability), 보안 특징을 지닌 eBPF 기반 데이터 플레인을 갖춘 솔루션입니다. Cilium은 기본 라우팅 및 오버레이/캡슐화 모드를 모두 지원하며, 여러 클러스터를 포괄할 수 있는 단순한 플랫(flat) Layer 3 네트워크를 제공합니다. 또한, Cilium은 (네트워크 주소 지정 방식에서 분리된) 신원 기반 보안 모델(identity-based security model)을 사용하여 L3-L7에서 네트워크 정책을 시행할 수 있습니다. Cilium은 kube-proxy를 대체하는 역할을 할 수 있습니다. 또한 부가적으로, 옵트인(opt-in) 형태로 관측 용의성(Observability) 및 보안 기능을 제공합니다.</li><li><a href=https://github.com/cni-genie/CNI-Genie>CNI-Genie</a>를 사용하면 쿠버네티스는 Calico, Canal, Flannel, Romana 또는 Weave와 같은 CNI 플러그인을 완벽하게 연결할 수 있다.</li><li><a href=https://contivpp.io/>Contiv</a>는 다양한 유스케이스와 풍부한 폴리시 프레임워크를 위해 구성 가능한 네트워킹(BGP를 사용하는 네이티브 L3, vxlan을 사용하는 오버레이, 클래식 L2 그리고 Cisco-SDN/ACI)을 제공한다. Contiv 프로젝트는 완전히 <a href=https://github.com/contiv>오픈소스</a>이다. <a href=https://github.com/contiv/install>인스톨러</a>는 kubeadm을 이용하거나, 그렇지 않은 경우에 대해서도 설치 옵션을 모두 제공한다.</li><li><a href=https://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a>은 <a href=https://tungsten.io>Tungsten Fabric</a>을 기반으로 하며, 오픈소스이고, 멀티 클라우드 네트워크 가상화 및 폴리시 관리 플랫폼이다. Contrail과 Tungsten Fabric은 쿠버네티스, OpenShift, OpenStack 및 Mesos와 같은 오케스트레이션 시스템과 통합되어 있으며, 가상 머신, 컨테이너/파드 및 베어 메탈 워크로드에 대한 격리 모드를 제공한다.</li><li><a href=https://github.com/flannel-io/flannel#deploying-flannel-manually>Flannel</a>은 쿠버네티스와 함께 사용할 수 있는 오버레이 네트워크 제공자이다.</li><li><a href=https://github.com/ZTE/Knitter/>Knitter</a>는 쿠버네티스 파드에서 여러 네트워크 인터페이스를 지원하는 플러그인이다.</li><li><a href=https://github.com/k8snetworkplumbingwg/multus-cni>Multus</a>는 쿠버네티스의 다중 네트워크 지원을 위한 멀티 플러그인이며, 모든 CNI 플러그인(예: Calico, Cilium, Contiv, Flannel)과 쿠버네티스 상의 SRIOV, DPDK, OVS-DPDK 및 VPP 기반 워크로드를 지원한다.</li><li><a href=https://github.com/ovn-org/ovn-kubernetes/>OVN-Kubernetes</a>는 Open vSwitch(OVS) 프로젝트에서 나온 가상 네트워킹 구현인 <a href=https://github.com/ovn-org/ovn/>OVN(Open Virtual Network)</a>을 기반으로 하는 쿠버네티스용 네트워킹 제공자이다. OVN-Kubernetes는 OVS 기반 로드 밸런싱과 네트워크 폴리시 구현을 포함하여 쿠버네티스용 오버레이 기반 네트워킹 구현을 제공한다.</li><li><a href=https://github.com/akraino-edge-stack/icn-nodus>Nodus</a>는 클라우드 네이티브 기반 서비스 기능 체인(SFC)을 제공하는 OVN 기반 CNI 컨트롤러 플러그인이다.</li><li><a href=https://docs.vmware.com/en/VMware-NSX-T-Data-Center/index.html>NSX-T</a> 컨테이너 플러그인(NCP)은 VMware NSX-T와 쿠버네티스와 같은 컨테이너 오케스트레이터 간의 통합은 물론 NSX-T와 PKS(Pivotal 컨테이너 서비스) 및 OpenShift와 같은 컨테이너 기반 CaaS/PaaS 플랫폼 간의 통합을 제공한다.</li><li><a href=https://github.com/nuagenetworks/nuage-kubernetes/blob/v5.1.1-1/docs/kubernetes-1-installation.rst>Nuage</a>는 가시성과 보안 모니터링 기능을 통해 쿠버네티스 파드와 비-쿠버네티스 환경 간에 폴리시 기반 네트워킹을 제공하는 SDN 플랫폼이다.</li><li><a href=https://github.com/romana>Romana</a>는 <a href=/ko/docs/concepts/services-networking/network-policies/>네트워크폴리시 API</a>도 지원하는 파드 네트워크용 Layer 3 네트워킹 솔루션이다.</li><li><a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/>Weave Net</a>은 네트워킹 및 네트워크 폴리시를 제공하고, 네트워크 파티션의 양면에서 작업을 수행하며, 외부 데이터베이스는 필요하지 않다.</li></ul><h2 id=서비스-검색>서비스 검색</h2><ul><li><a href=https://coredns.io>CoreDNS</a>는 유연하고 확장 가능한 DNS 서버로, 파드를 위한 클러스터 내 DNS로 <a href=https://github.com/coredns/deployment/tree/master/kubernetes>설치</a>할 수 있다.</li></ul><h2 id=시각화-amp-제어>시각화 & 제어</h2><ul><li><a href=https://github.com/kubernetes/dashboard#kubernetes-dashboard>대시보드</a>는 쿠버네티스를 위한 대시보드 웹 인터페이스이다.</li><li><a href=https://www.weave.works/documentation/scope-latest-installing/#k8s>Weave Scope</a>는 컨테이너, 파드, 서비스 등을 그래픽으로 시각화하는 도구이다. <a href=https://cloud.weave.works/>Weave Cloud 어카운트</a>와 함께 사용하거나 UI를 직접 호스팅한다.</li></ul><h2 id=인프라스트럭처>인프라스트럭처</h2><ul><li><a href=https://kubevirt.io/user-guide/#/installation/installation>KubeVirt</a>는 쿠버네티스에서 가상 머신을 실행하기 위한 애드온이다. 일반적으로 베어 메탈 클러스터에서 실행한다.</li><li><a href=https://github.com/kubernetes/node-problem-detector>node problem detector</a>는
리눅스 노드에서 실행되며,
시스템 이슈를
<a href=/docs/reference/kubernetes-api/cluster-resources/event-v1/>이벤트</a> 또는
<a href=/ko/docs/concepts/architecture/nodes/#condition>노드 컨디션</a> 형태로 보고한다.</li></ul><h2 id=레거시-애드온>레거시 애드온</h2><p>더 이상 사용되지 않는 <a href=https://git.k8s.io/kubernetes/cluster/addons>cluster/addons</a> 디렉터리에 다른 여러 애드온이 문서화되어 있다.</p><p>잘 관리된 것들이 여기에 연결되어 있어야 한다. PR을 환영한다!</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>