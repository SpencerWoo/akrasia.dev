<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/storage/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/storage/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/storage/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/storage/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/storage/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/storage/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/storage/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/storage/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/storage/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/storage/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>스토리지 | Kubernetes</title><meta property="og:title" content="스토리지"><meta property="og:description" content="클러스터의 파드에 장기(long-term) 및 임시 스토리지를 모두 제공하는 방법
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/storage/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="스토리지"><meta itemprop=description content="클러스터의 파드에 장기(long-term) 및 임시 스토리지를 모두 제공하는 방법
"><meta name=twitter:card content="summary"><meta name=twitter:title content="스토리지"><meta name=twitter:description content="클러스터의 파드에 장기(long-term) 및 임시 스토리지를 모두 제공하는 방법
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="클러스터의 파드에 장기(long-term) 및 임시 스토리지를 모두 제공하는 방법
"><meta property="og:description" content="클러스터의 파드에 장기(long-term) 및 임시 스토리지를 모두 제공하는 방법
"><meta name=twitter:description content="클러스터의 파드에 장기(long-term) 및 임시 스토리지를 모두 제공하는 방법
"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/storage/"><meta property="og:title" content="스토리지"><meta name=twitter:title content="스토리지"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/storage/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/storage/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/storage/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/concepts/storage/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/concepts/storage/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/storage/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/storage/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/concepts/storage/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/storage/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/storage/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/storage/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/storage/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/storage/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/storage/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/concepts/storage/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>스토리지</h1><div class=lead>클러스터의 파드에 장기(long-term) 및 임시 스토리지를 모두 제공하는 방법</div><ul><li>1: <a href=#pg-27795584640a03bd2024f1fe3b3ab754>볼륨</a></li><li>2: <a href=#pg-ffd12528a12882b282e1bd19e29f9e75>퍼시스턴트 볼륨</a></li><li>3: <a href=#pg-2db414b26d4daec3ebed19dd837830c3>프로젝티드 볼륨</a></li><li>4: <a href=#pg-f0276d05eef111249272a1c932a91e2c>스토리지 클래스</a></li><li>5: <a href=#pg-df33eab51202c17bb0fe551d1d5cc5d2>임시 볼륨</a></li><li>6: <a href=#pg-018f0a7fc6e2f6d16da37702fc39b4f3>동적 볼륨 프로비저닝</a></li><li>7: <a href=#pg-c262af210c6828dec445d2f55a1d877a>볼륨 스냅샷</a></li><li>8: <a href=#pg-4d00116c86dade62bdd5be7dc2afa1ca>볼륨 스냅샷 클래스</a></li><li>9: <a href=#pg-707ca81a34eb1ca202f34692e9917d1e>CSI 볼륨 복제하기</a></li><li>10: <a href=#pg-00cd24f4570b7acaac75c2551c948bc7>스토리지 용량</a></li><li>11: <a href=#pg-b2e4b16ac37988c678a3312a4a6639f8>노드 별 볼륨 한도</a></li><li>12: <a href=#pg-4f40cb95a671e51b4f0156a409d95c6d>볼륨 헬스 모니터링</a></li><li>13: <a href=#pg-055a8df536f8ba8f3aa0217bd2db5437>윈도우 스토리지</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-27795584640a03bd2024f1fe3b3ab754>1 - 볼륨</h1><p>컨테이너 내의 디스크에 있는 파일은 임시적이며, 컨테이너에서 실행될 때
애플리케이션에 적지 않은 몇 가지 문제가 발생한다. 한 가지 문제는
컨테이너가 크래시될 때 파일이 손실된다는 것이다. kubelet은 컨테이너를 다시 시작하지만
초기화된 상태이다. 두 번째 문제는 <code>Pod</code>에서 같이 실행되는 컨테이너간에
파일을 공유할 때 발생한다.
쿠버네티스 <a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a> 추상화는
이러한 문제를 모두 해결한다.
<a href=/ko/docs/concepts/workloads/pods/>파드</a>에 대해 익숙해지는 것을 추천한다.</p><h2 id=배경>배경</h2><p>도커는 다소 느슨하고, 덜 관리되지만
<a href=https://docs.docker.com/storage/>볼륨</a>이라는
개념을 가지고 있다. 도커 볼륨은 디스크에 있는 디렉터리이거나
다른 컨테이너에 있다. 도커는 볼륨
드라이버를 제공하지만, 기능이 다소 제한된다.</p><p>쿠버네티스는 다양한 유형의 볼륨을 지원한다. <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>는
여러 볼륨 유형을 동시에 사용할 수 있다.
임시 볼륨 유형은 파드의 수명을 갖지만, 퍼시스턴트 볼륨은
파드의 수명을 넘어 존재한다. 파드가 더 이상 존재하지 않으면, 쿠버네티스는 임시(ephemeral) 볼륨을 삭제하지만,
퍼시스턴트(persistent) 볼륨은 삭제하지 않는다.
볼륨의 종류와 상관없이, 파드 내의 컨테이너가 재시작되어도 데이터는 보존된다.</p><p>기본적으로 볼륨은 디렉터리이며, 일부 데이터가 있을 수 있으며, 파드
내 컨테이너에서 접근할 수 있다. 디렉터리의 생성 방식, 이를 지원하는
매체와 내용은 사용된 특정 볼륨의 유형에 따라
결정된다.</p><p>볼륨을 사용하려면, <code>.spec.volumes</code> 에서 파드에 제공할 볼륨을 지정하고
<code>.spec.containers[*].volumeMounts</code> 의 컨테이너에 해당 볼륨을 마운트할 위치를 선언한다.
컨테이너의 프로세스는
<a class=glossary-tooltip title='컨테이너의 저장된 인스턴스이며, 애플리케이션 구동에 필요한 소프트웨어 집합을 가지고 있다.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='컨테이너 이미지'>컨테이너 이미지</a>의 최초 내용물과
컨테이너 안에 마운트된 볼륨(정의된 경우에 한함)으로 구성된 파일시스템을 보게 된다.
프로세스는 컨테이너 이미지의 최초 내용물에 해당되는 루트 파일시스템을
보게 된다.
쓰기가 허용된 경우, 해당 파일시스템에 쓰기 작업을 하면
추후 파일시스템에 접근할 때 변경된 내용을 보게 될 것이다.
볼륨은 이미지의 <a href=#using-subpath>특정 경로</a>에
마운트된다.
파드에 정의된 각 컨테이너에 대해,
컨테이너가 사용할 각 볼륨을 어디에 마운트할지 명시해야 한다.</p><p>볼륨은 다른 볼륨 안에 마운트될 수 없다
(하지만, <a href=#using-subpath>서브패스 사용</a>에서 관련 메커니즘을 확인한다).
또한, 볼륨은 다른 볼륨에 있는 내용물을 가리키는 하드 링크를 포함할 수 없다.</p><h2 id=volume-types>볼륨 유형들</h2><p>쿠버네티스는 여러 유형의 볼륨을 지원한다.</p><h3 id=awselasticblockstore>awsElasticBlockStore (사용 중단됨)</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.17 [deprecated]</code></div><p><code>awsElasticBlockStore</code> 볼륨은 아마존 웹 서비스 (AWS)
<a href=https://aws.amazon.com/ebs/>EBS 볼륨</a>을 파드에 마운트 한다. 파드를
제거할 때 지워지는 <code>emptyDir</code> 와는 다르게 EBS 볼륨의
내용은 유지되고, 볼륨은 마운트 해제만 된다. 이 의미는 EBS 볼륨에
데이터를 미리 채울 수 있으며, 파드 간에 데이터를 "전달(handed off)"할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이를 사용하려면 먼저 <code>aws ec2 create-volume</code> 또는 AWS API를 사용해서 EBS 볼륨을 생성해야 한다.</div><p><code>awsElasticBlockStore</code> 볼륨을 사용할 때 몇 가지 제한이 있다.</p><ul><li>파드가 실행 중인 노드는 AWS EC2 인스턴스여야 함</li><li>이러한 인스턴스는 EBS 볼륨과 동일한 지역과 가용성 영역에 있어야 함</li><li>EBS는 볼륨을 마운트하는 단일 EC2 인스턴스만 지원함</li></ul><h4 id=aws-ebs-볼륨-생성하기>AWS EBS 볼륨 생성하기</h4><p>파드와 함께 EBS 볼륨을 사용하려면, 먼저 EBS 볼륨을 생성해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>aws ec2 create-volume --availability-zone<span style=color:#666>=</span>eu-west-1a --size<span style=color:#666>=</span><span style=color:#666>10</span> --volume-type<span style=color:#666>=</span>gp2
</span></span></code></pre></div><p>클러스터를 띄운 영역과 생성하는 영역이 일치하는지 확인한다. 크기와 EBS 볼륨 유형이
사용에 적합한지 확인한다.</p><h4 id=aws-ebs-구성-예시>AWS EBS 구성 예시</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 AWS EBS 볼륨은 이미 존재해야 한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>awsElasticBlockStore</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume-id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>EBS 볼륨이 파티션된 경우, 선택적 필드인 <code>partition: "&lt;partition number>"</code> 를 제공하여 마운트할 파티션을 지정할 수 있다.</p><h4 id=aws-ebs-csi-마이그레이션>AWS EBS CSI 마이그레이션</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><p><code>awsElasticBlockStore</code> 의 <code>CSIMigration</code> 기능이 활성화된 경우, 기존 인-트리 플러그인의
모든 플러그인 작업을 <code>ebs.csi.aws.com</code> 컨테이너 스토리지 인터페이스(CSI)
드라이버로 리디렉션한다. 이 기능을 사용하려면, 클러스터에 <a href=https://github.com/kubernetes-sigs/aws-ebs-csi-driver>AWS EBS CSI
드라이버</a>를
설치해야 한다.</p><h4 id=aws-ebs-csi-마이그레이션-완료>AWS EBS CSI 마이그레이션 완료</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.17 [alpha]</code></div><p>컨트롤러 관리자와 kubelet에 의해 로드되지 않도록 <code>awsElasticBlockStore</code> 스토리지
플러그인을 끄려면, <code>InTreePluginAWSUnregister</code> 플래그를 <code>true</code> 로 설정한다.</p><h3 id=azuredisk>azureDisk (사용 중단됨)</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.19 [deprecated]</code></div><p><code>azureDisk</code> 볼륨 유형은 Microsoft Azure <a href=https://docs.microsoft.com/en-us/azure/aks/csi-storage-drivers>데이터 디스크</a>를 파드에 마운트한다.</p><p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_disk/README.md><code>azureDisk</code> 볼륨 플러그인</a>을 참고한다.</p><h4 id=azuredisk-csi-마이그레이션>azureDisk CSI 마이그레이션</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [stable]</code></div><p><code>azureDisk</code> 의 <code>CSIMigration</code> 기능이 활성화된 경우,
기존 인-트리 플러그인의 모든 플러그인 작업을
<code>disk.csi.azure.com</code> 컨테이너 스토리지 인터페이스(CSI) 드라이버로 리다이렉트한다.
이 기능을 사용하려면, 클러스터에 <a href=https://github.com/kubernetes-sigs/azuredisk-csi-driver>Azure 디스크 CSI 드라이버</a> 를
설치해야 한다.</p><h4 id=azuredisk-csi-마이그레이션-완료>azureDisk CSI 마이그레이션 완료</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [alpha]</code></div><p>컨트롤러 매니저 및 kubelet이 <code>azureDisk</code> 스토리지 플러그인을 로드하지 않도록 하려면,
<code>InTreePluginAzureDiskUnregister</code> 플래그를 <code>true</code>로 설정한다.</p><h3 id=azurefile>azureFile (사용 중단됨)</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [deprecated]</code></div><p><code>azureFile</code> 볼륨 유형은 Microsoft Azure 파일 볼륨(SMB 2.1과 3.0)을 파드에
마운트한다.</p><p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_file/README.md><code>azureFile</code> 볼륨 플러그인</a>을 참고한다.</p><h4 id=azurefile-csi-마이그레이션>azureFile CSI 마이그레이션</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [beta]</code></div><p><code>azureFile</code> 의 <code>CSIMigration</code> 기능이 활성화된 경우, 기존 트리 내 플러그인에서
<code>file.csi.azure.com</code> 컨테이너 스토리지 인터페이스(CSI)
드라이버로 모든 플러그인 작업을 수행한다. 이 기능을 사용하려면, 클러스터에 <a href=https://github.com/kubernetes-sigs/azurefile-csi-driver>Azure 파일 CSI
드라이버</a>
를 설치하고 <code>CSIMigrationAzureFile</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.</p><p>Azure File CSI 드라이버는 동일한 볼륨을 다른 fsgroup에서 사용하는 것을 지원하지 않는다.
Azurefile CSI 마이그레이션이 활성화된 경우, 다른 fsgroup에서 동일한 볼륨을 사용하는 것은 전혀 지원되지 않는다.</p><h4 id=azurefile-csi-마이그레이션-완료>azureFile CSI 마이그레이션 완료</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [alpha]</code></div><p>컨트롤러 매니저 및 kubelet이 <code>azureFile</code> 스토리지 플러그인을 로드하지 않도록 하려면,
<code>InTreePluginAzureFileUnregister</code> 플래그를 <code>true</code>로 설정한다.</p><h3 id=cephfs>cephfs</h3><p><code>cephfs</code> 볼륨은 기존 CephFS 볼륨을
파드에 마운트 할 수 있다. 파드를 제거할 때 지워지는 <code>emptyDir</code>
와는 다르게 cephfs 볼륨의 내용은 유지되고, 볼륨은 그저 마운트
해제만 된다. 이 의미는 <code>cephfs</code> 볼륨에 데이터를 미리 채울 수 있으며,
해당 데이터는 파드 간에 공유될 수 있다. <code>cephfs</code> 볼륨은 여러 작성자가
동시에 마운트할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> CephFS를 사용하기 위해선 먼저 Ceph 서버를 실행하고 공유를 내보내야 한다.</div><p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/volumes/cephfs/>CephFS 예시</a>를 참조한다.</p><h3 id=cinder-사용-중단됨>cinder (사용 중단됨)</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [deprecated]</code></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 쿠버네티스는 오픈스택 클라우드 공급자로 구성되어야 한다.</div><p><code>cinder</code> 볼륨 유형은 오픈스택 Cinder 볼륨을 파드에 마운트하는데 사용된다.</p><h4 id=cinder-볼륨-구성-예시>Cinder 볼륨 구성 예시</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 오픈스택 볼륨은 이미 존재해야 한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cinder</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=오픈스택-csi-마이그레이션>오픈스택 CSI 마이그레이션</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [stable]</code></div><p>Cinder의<code>CSIMigration</code> 기능은 Kubernetes 1.21부터 기본적으로 활성화되어 있다.
기존 트리 내 플러그인에서 <code>cinder.csi.openstack.org</code> 컨테이너 스토리지 인터페이스(CSI)
드라이버로 모든 플러그인 작업을 수행한다.
<a href=https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/cinder-csi-plugin/using-cinder-csi-plugin.md>오픈스택 Cinder CSI 드라이버</a>가
클러스터에 설치되어 있어야 한다.</p><p>컨트롤러 매니저 및 kubelet이 인-트리 Cinder 플러그인을 로드하지 않도록 하려면,
<code>InTreePluginOpenStackUnregister</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화한다.</p><h3 id=configmap>컨피그맵(configMap)</h3><p><a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그맵</a>은
구성 데이터를 파드에 주입하는 방법을 제공한다.
컨피그맵에 저장된 데이터는 <code>configMap</code> 유형의 볼륨에서 참조되고
그런 다음에 파드에서 실행되는 컨테이너화된 애플리케이션이 소비한다.</p><p>컨피그맵을 참조할 때, 볼륨에 컨피그맵의 이름을
제공한다. 컨피그맵의 특정 항목에 사용할 경로를
사용자 정의할 수 있다. 다음 구성은 <code>log-config</code> 컨피그맵을
<code>configmap-pod</code> 라 부르는 파드에 마운트하는 방법을 보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>log-config</code> 컨피그맵은 볼륨으로 마운트되며, <code>log_level</code> 항목에
저장된 모든 컨텐츠는 파드의 <code>/etc/config/log_level</code> 경로에 마운트된다.
이 경로는 볼륨의 <code>mountPath</code> 와 <code>log_level</code> 로 키가 지정된
<code>path</code> 에서 파생된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><ul><li><p><a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>컨피그맵</a>을 사용하기 위해서는
먼저 컨피그맵을 생성해야 한다.</p></li><li><p>컨피그맵을 <a href=#using-subpath><code>subPath</code></a> 볼륨 마운트로 사용하는 컨테이너는 컨피그맵
업데이트를 수신하지 않는다.</p></li><li><p>텍스트 데이터는 UTF-8 문자 인코딩을 사용하는 파일로 노출된다. 다른 문자 인코딩의 경우, <code>binaryData</code> 를 사용한다.</p></li></ul></div><h3 id=downwardapi>downwardAPI</h3><p><code>downwardAPI</code> 볼륨은 애플리케이션에서 <a class=glossary-tooltip title='A mechanism to expose Pod and container field values to code running in a container.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/downward-api/ target=_blank aria-label='다운워드(downward) API'>다운워드(downward) API</a>
데이터를 사용할 수 있도록 한다. 볼륨 내에서 노출된 데이터를
일반 텍스트 형식의 읽기 전용 파일로 찾을 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 다운워드 API를 <a href=#using-subpath><code>subPath</code></a> 볼륨 마운트로 사용하는 컨테이너는 다운워드 API
업데이트를 수신하지 않는다.</div><p>더 자세한 내용은 <a href=/ko/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>다운워드 API 예시</a>
를 참고한다.</p><h3 id=emptydir>emptyDir</h3><p><code>emptyDir</code> 볼륨은 파드가 노드에 할당될 때 처음 생성되며,
해당 노드에서 파드가 실행되는 동안에만 존재한다. 이름에서 알 수 있듯이
<code>emptyDir</code> 볼륨은 처음에는 비어있다. 파드 내 모든 컨테이너는 <code>emptyDir</code> 볼륨에서 동일한
파일을 읽고 쓸 수 있지만, 해당 볼륨은 각각의 컨테이너에서 동일하거나
다른 경로에 마운트될 수 있다. 어떤 이유로든 노드에서 파드가 제거되면
<code>emptyDir</code> 의 데이터가 영구적으로 삭제된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 컨테이너가 크래시되는 것은 노드에서 파드를 제거하지 <em>않는다</em>. <code>emptyDir</code> 볼륨의 데이터는
컨테이너 크래시로부터 안전하다.</div><p><code>emptyDir</code> 의 일부 용도는 다음과 같다.</p><ul><li>디스크 기반의 병합 종류와 같은 스크레치 공간</li><li>충돌로부터 복구하기위해 긴 계산을 검사점으로 지정</li><li>웹 서버 컨테이너가 데이터를 처리하는 동안 컨텐츠 매니저
컨테이너가 가져오는 파일을 보관</li></ul><p>환경에 따라, <code>emptyDir</code> 볼륨은 디스크, SSD 또는 네트워크 스토리지와
같이 노드를 지원하는 모든 매체에 저장된다. 그러나, <code>emptyDir.medium</code> 필드를
<code>"Memory"</code>로 설정하면, 쿠버네티스에 tmpfs(RAM 기반 파일시스템)를 마운트하도록 할 수 있다.
tmpfs는 매우 빠르지만, 디스크와 다르게 노드 재부팅시 tmpfs가 지워지고,
작성하는 모든 파일이 컨테이너 메모리
제한에 포함된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>SizeMemoryBackedVolumes</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화된 경우,
메모리 기반 볼륨의 크기를 지정할 수 있다. 크기를 지정하지 않으면, 메모리
기반 볼륨의 크기는 리눅스 호스트 메모리의 50%로 조정된다.</div><h4 id=emptydir-구성-예시>emptyDir 구성 예시</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/cache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=fc>fc (파이버 채널)</h3><p><code>fc</code> 볼륨 유형은 기존 파이버 채널 블록 스토리지 볼륨을
파드에 마운트할 수 있게 한다. 볼륨 구성에서 <code>targetWWNs</code> 파라미터를 사용하여
단일 또는 다중 대상 월드 와이드 이름(WWN)을 지정할 수 있다. 만약 여러 WWN이 지정된 경우,
targetWWN은 해당 WWN이 다중 경로 연결에서 온 것으로 예상한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이러한 LUN (볼륨)을 할당하고 대상 WWN에 마스킹하도록 FC SAN Zoning을 구성해야만
쿠버네티스 호스트가 해당 LUN에 접근할 수 있다.</div><p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/fibre_channel>파이버 채널 예시</a>를 참고한다.</p><h3 id=gcepersistentdisk>gcePersistentDisk (사용 중단됨)</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.17 [deprecated]</code></div><p><code>gcePersistentDisk</code> 볼륨은 구글 컴퓨트 엔진(GCE)
<a href=https://cloud.google.com/compute/docs/disks>영구 디스크</a>(PD)를 파드에 마운트한다.
파드를 제거할 때 지워지는 <code>emptyDir</code> 와는 다르게, PD의 내용은 유지되고,
볼륨은 마운트 해제만 된다. 이는 PD에 데이터를
미리 채울 수 있으며, 파드 간에 데이터를 공유할 수 있다는 것을 의미한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>gcePersistentDisk</code> 를 사용하려면 먼저 PD를 <code>gcloud</code>, GCE API 또는 UI를 사용해서 생성해야 한다.</div><p><code>gcePersistentDisk</code> 를 사용할 때 몇 가지 제한이 있다.</p><ul><li>파드가 실행 중인 노드는 GCE VM이어야 함</li><li>이러한 VM은 영구 디스크와 동일한 GCE 프로젝트와 영역에 있어야 함</li></ul><p>GCE 영구 디스크의 한 가지 기능은 영구 디스크에 대한 동시 읽기 전용 접근이다.
<code>gcePersistentDisk</code> 볼륨을 사용하면 여러 사용자가 영구 디스크를 읽기 전용으로
동시에 마운트할 수 있다. 즉, PD를 데이터 세트로 미리 채운 다음
필요한 만큼 많은 파드에서 병렬로 제공할 수 있다. 불행히도,
PD는 읽기-쓰기 모드에서 단일 사용자만 마운트할 수 있다. 동시
쓰기는 허용되지 않는다.</p><p>PD가 읽기 전용이거나 레플리카의 수가 0 또는 1이 아니라면 레플리카셋(ReplicaSet)으로 제어되는
파드가 있는 GCE 영구 디스크를 사용할 수 없다.</p><h4 id=gce-create-persistent-disk>GCE 영구 디스크 생성하기</h4><p>GCE 영구 디스크를 파드와 함께 사용하려면, 디스크를 먼저 생성해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB --zone<span style=color:#666>=</span>us-central1-a my-data-disk
</span></span></code></pre></div><h4 id=gce-영구-디스크-구성-예시>GCE 영구 디스크 구성 예시</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 GCE PD는 이미 존재해야 한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=리전-영구-디스크>리전 영구 디스크</h4><p><a href=https://cloud.google.com/compute/docs/disks/#repds>리전 영구 디스크</a>
기능을 사용하면 동일한 영역 내의 두 영역에서 사용할 수 있는 영구 디스크를
생성할 수 있다. 이 기능을 사용하려면 볼륨을 퍼시스턴트볼륨(PersistentVolume)으로
프로비저닝해야 한다. 파드에서 직접 볼륨을 참조하는 것은 지원되지 않는다.</p><h4 id=리전-pd-퍼시스턴트볼륨을-수동으로-프로비저닝하기>리전 PD 퍼시스턴트볼륨을 수동으로 프로비저닝하기</h4><p><a href=/ko/docs/concepts/storage/storage-classes/#gce-pd>GCE PD용 스토리지클래스</a>를
사용해서 동적 프로비저닝이 가능하다.
퍼시스턴트볼륨을 생성하기 전에 영구 디스크를 생성해야만 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB my-data-disk
</span></span><span style=display:flex><span>  --region us-central1
</span></span><span style=display:flex><span>  --replica-zones us-central1-a,us-central1-b
</span></span></code></pre></div><h4 id=리전-영구-디스크-구성-예시>리전 영구 디스크 구성 예시</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>400Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 1.21 이전 버전에서는 failure-domain.beta.kubernetes.io/zone 키를 사용해야 한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- us-central1-a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- us-central1-b<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=gce-csi-마이그레이션>GCE CSI 마이그레이션</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><p>GCE PD의 <code>CSIMigration</code> 기능이 활성화된 경우 기존 인-트리 플러그인에서
<code>pd.csi.storage.gke.io</code> 컨테이너 스토리지 인터페이스(CSI)
드라이버로 모든 플러그인 작업을 리디렉션한다. 이 기능을 사용하려면, 클러스터에 <a href=https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver>GCE PD CSI
드라이버</a>
를 설치해야 한다.</p><h4 id=gce-csi-마이그레이션-완료>GCE CSI 마이그레이션 완료</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [alpha]</code></div><p>컨트롤러 매니저와 kubelet이 <code>gcePersistentDisk</code> 스토리지 플러그인을 로드하는 것을 방지하려면,
<code>InTreePluginGCEUnregister</code> 플래그를 <code>true</code>로 설정한다.</p><h3 id=gitrepo>gitRepo (사용 중단됨)</h3><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> <code>gitRepo</code> 볼륨 유형은 사용 중단되었다. git repo가 있는 컨테이너를 프로비전 하려면 초기화 컨테이너(InitContainer)에 <a href=#emptydir>EmptyDir</a>을 마운트하고, 여기에 git을 사용해서 repo를 복제하고, <a href=#emptydir>EmptyDir</a>을 파드 컨테이너에 마운트 한다.</div><p><code>gitRepo</code> 볼륨은 볼륨 플러그인의 예시이다. 이 플러그인은
빈 디렉터리를 마운트하고 파드가 사용할 수 있도록 이 디렉터리에 git 리포지터리를
복제한다.</p><p>여기 <code>gitRepo</code> 볼륨의 예시가 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mypath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gitRepo</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>repository</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;git@somewhere:me/my-git-repository.git&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>revision</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;22f1d8406d464b0c0874075539c1f2e96c253775&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=glusterfs-사용-중단됨>glusterfs (사용 중단됨)</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [deprecated]</code></div><p><code>glusterfs</code> 볼륨을 사용하면 <a href=https://www.gluster.org>Glusterfs</a> (오픈
소스 네트워크 파일시스템) 볼륨을 파드에 마운트할 수 있다. 파드를
제거할 때 지워지는 <code>emptyDir</code> 와는 다르게 <code>glusterfs</code>
볼륨의 내용은 유지되고, 볼륨은 마운트 해제만 된다. 이 의미는
glusterfs 볼륨에 데이터를 미리 채울 수 있으며, 파드 간에 데이터를
공유할 수 있다. GlusterFS는 여러 작성자가 동시에
마운트할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 사용하려면 먼저 GlusterFS를 설치하고 실행해야 한다.</div><p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/volumes/glusterfs>GlusterFS 예시</a>를 본다.</p><h3 id=hostpath>hostPath</h3><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong><p>HostPath 볼륨에는 많은 보안 위험이 있으며, 가능하면 HostPath를 사용하지 않는
것이 좋다. HostPath 볼륨을 사용해야 하는 경우, 필요한 파일 또는 디렉터리로만
범위를 지정하고 ReadOnly로 마운트해야 한다.</p><p>AdmissionPolicy를 사용하여 특정 디렉터리로의 HostPath 액세스를 제한하는 경우,
<code>readOnly</code> 마운트를 사용하는 정책이 유효하려면 <code>volumeMounts</code> 가 반드시 지정되어야 한다.</p></div><p><code>hostPath</code> 볼륨은 호스트 노드의 파일시스템에 있는 파일이나 디렉터리를
파드에 마운트 한다. 이것은 대부분의 파드들이 필요한 것은 아니지만, 일부
애플리케이션에 강력한 탈출구를 제공한다.</p><p>예를 들어, <code>hostPath</code> 의 일부 용도는 다음과 같다.</p><ul><li>도커 내부에 접근할 필요가 있는 실행중인 컨테이너. <code>/var/lib/docker</code> 를
<code>hostPath</code> 로 이용함</li><li>컨테이너에서 cAdvisor의 실행. <code>/sys</code> 를 <code>hostPath</code> 로 이용함</li><li>파드는 주어진 <code>hostPath</code> 를 파드가 실행되기 이전에 있어야 하거나,
생성해야 하는지 그리고 존재해야 하는 대상을 지정할 수 있도록 허용함</li></ul><p>필요한 <code>path</code> 속성 외에도, <code>hostPath</code> 볼륨에 대한 <code>type</code> 을 마음대로 지정할 수 있다.</p><p>필드가 <code>type</code> 에 지원되는 값은 다음과 같다.</p><table><thead><tr><th style=text-align:left>값</th><th style=text-align:left>행동</th></tr></thead><tbody><tr><td style=text-align:left></td><td style=text-align:left>빈 문자열 (기본값)은 이전 버전과의 호환성을 위한 것으로, hostPath 볼륨은 마운트 하기 전에 아무런 검사도 수행되지 않는다.</td></tr><tr><td style=text-align:left><code>DirectoryOrCreate</code></td><td style=text-align:left>만약 주어진 경로에 아무것도 없다면, 필요에 따라 Kubelet이 가지고 있는 동일한 그룹과 소유권, 권한을 0755로 설정한 빈 디렉터리를 생성한다.</td></tr><tr><td style=text-align:left><code>Directory</code></td><td style=text-align:left>주어진 경로에 디렉터리가 있어야 함</td></tr><tr><td style=text-align:left><code>FileOrCreate</code></td><td style=text-align:left>만약 주어진 경로에 아무것도 없다면, 필요에 따라 Kubelet이 가지고 있는 동일한 그룹과 소유권, 권한을 0644로 설정한 빈 파일을 생성한다.</td></tr><tr><td style=text-align:left><code>File</code></td><td style=text-align:left>주어진 경로에 파일이 있어야 함</td></tr><tr><td style=text-align:left><code>Socket</code></td><td style=text-align:left>주어진 경로에 UNIX 소캣이 있어야 함</td></tr><tr><td style=text-align:left><code>CharDevice</code></td><td style=text-align:left>주어진 경로에 문자 디바이스가 있어야 함</td></tr><tr><td style=text-align:left><code>BlockDevice</code></td><td style=text-align:left>주어진 경로에 블록 디바이스가 있어야 함</td></tr></tbody></table><p>다음과 같은 이유로 이 유형의 볼륨 사용시 주의해야 한다.</p><ul><li>HostPath는 권한있는 시스템 자격 증명 (예 : Kubelet 용) 또는 권한있는 API
(예 : 컨테이너 런타임 소켓)를 노출 할 수 있으며, 이는 컨테이너 이스케이프 또는
클러스터의 다른 부분을 공격하는 데 사용될 수 있다.</li><li>동일한 구성(파드템플릿으로 생성한 것과 같은)을
가진 파드는 노드에 있는 파일이 다르기 때문에 노드마다 다르게 동작할 수 있다.</li><li>기본 호스트에 생성된 파일 또는 디렉터리는 root만 쓸 수 있다.
프로세스를 <a href=/docs/tasks/configure-pod-container/security-context/>특권을 가진(privileged) 컨테이너</a>에서
루트로 실행하거나
<code>hostPath</code> 볼륨에 쓸 수 있도록 호스트의 파일 권한을 수정해야 한다.</li></ul><h4 id=hostpath-구성-예시>hostPath 구성 예시</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 호스트의 디렉터리 위치</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 이 필드는 선택 사항이다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Directory<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> <code>FileOrCreate</code> 모드는 파일의 상위 디렉터리를 생성하지 않는다. 마운트된 파일의 상위 디렉터리가
없으면 파드가 시작되지 않는다. 이 모드가 작동하는지 확인하려면,
<a href=#hostpath-fileorcreate-example><code>FileOrCreate</code> 구성</a>에 표시된대로
디렉터리와 파일을 별도로 마운트할 수 있다.</div><h4 id=hostpath-fileorcreate-example>hostPath FileOrCreate 구성 예시</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver:latest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 파일 디렉터리가 생성되었는지 확인한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>FileOrCreate<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=iscsi>iscsi</h3><p><code>iscsi</code> 볼륨을 사용하면 기존 iSCSI (SCSI over IP) 볼륨을 파드에 마운트
할수 있다. 파드를 제거할 때 지워지는 <code>emptyDir</code> 와는
다르게 <code>iscsi</code> 볼륨의 내용은 유지되고, 볼륨은 그저 마운트
해제만 된다. 이 의미는 iscsi 볼륨에 데이터를 미리 채울 수 있으며,
파드간에 데이터를 공유할 수 있다는 것이다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 사용하려면 먼저 iSCSI 서버를 실행하고 볼륨을 생성해야 한다.</div><p>iSCSI 특징은 여러 고객이 읽기 전용으로 마운트할 수
있다는 것이다. 즉, 데이터셋으로 사전에 볼륨을 채운다음,
필요한 만큼 많은 파드에서 병렬로 제공할 수 있다. 불행하게도,
iSCSI 볼륨은 읽기-쓰기 모드에서는 단일 고객만 마운트할 수 있다.
동시 쓰기는 허용되지 않는다.</p><p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/volumes/iscsi>iSCSI 예시</a>를 본다.</p><h3 id=local>local</h3><p><code>local</code> 볼륨은 디스크, 파티션 또는 디렉터리 같은 마운트된 로컬 스토리지
장치를 나타낸다.</p><p>로컬 볼륨은 정적으로 생성된 퍼시스턴트볼륨으로만 사용할 수 있다. 동적으로
프로비저닝된 것은 지원되지 않는다.</p><p><code>hostPath</code> 볼륨에 비해 <code>local</code> 볼륨은 수동으로 파드를 노드에 예약하지 않고도
내구성과 휴대성을 갖춘 방식으로 사용된다. 시스템은
퍼시스턴트볼륨의 노드 어피니티를 확인하여 볼륨의 노드 제약 조건을 인식한다.</p><p>그러나 <code>local</code> 볼륨은 여전히 기본 노드의 가용성을 따르며
모든 애플리케이션에 적합하지는 않는다. 만약 노드가 비정상 상태가
되면 <code>local</code> 볼륨도 접근할 수 없게 되고, 파드를 실행할 수
없게 된다. <code>local</code> 볼륨을 사용하는 애플리케이션은 기본 디스크의
내구 특성에 따라 이러한 감소되는 가용성과 데이터
손실 가능성도 허용할 수 있어야 한다.</p><p>다음의 예시는 <code>local</code> 볼륨과 <code>nodeAffinity</code> 를 사용하는 퍼시스턴트볼륨을
보여준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>100Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>local</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/mnt/disks/ssd1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/hostname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- example-node<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>local</code> 볼륨을 사용하는 경우 퍼시스턴트볼륨 <code>nodeAffinity</code> 를 설정해야 합니다.
쿠버네티스 스케줄러는 퍼시스턴트볼륨 <code>nodeAffinity</code> 를 사용하여
파드를 올바른 노드로 스케줄한다.</p><p>퍼시스턴트볼륨의 <code>volumeMode</code> 을 "Block" (기본값인 "Filesystem"을
대신해서)으로 설정하면 로컬 볼륨을 원시 블록 장치로 노출할 수 있다.</p><p>로컬 볼륨을 사용할 때는 <code>volumeBindingMode</code> 가 <code>WaitForFirstConsumer</code> 로 설정된
스토리지클래스(StorageClass)를 생성하는 것을 권장한다. 자세한 내용은
local <a href=/ko/docs/concepts/storage/storage-classes/#local>스토리지클래스(StorageClas)</a> 예제를 참고한다.
볼륨 바인딩을 지연시키는 것은 퍼시스턴트볼륨클래임 바인딩 결정도
노드 리소스 요구사항, 노드 셀렉터, 파드 어피니티 그리고 파드 안티 어피니티와
같이 파드가 가질 수 있는 다른 노드 제약 조건으로 평가되도록 만든다.</p><p>로컬 볼륨 라이프사이클의 향상된 관리를 위해 외부 정적
프로비저너를 별도로 실행할 수 있다. 이 프로비저너는 아직 동적
프로비저닝을 지원하지 않는 것을 참고한다. 외부 로컬 프로비저너를 실행하는 방법에 대한
예시는 <a href=https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner>로컬 볼륨 프로비저너 사용자
가이드</a>를 본다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 로컬 정적 프로비저너를 사용해서 볼륨 라이프사이클을 관리하지 않는
경우 로컬 퍼시스턴트볼륨을 수동으로 정리하고 삭제하는 것이
필요하다.</div><h3 id=nfs>nfs</h3><p><code>nfs</code> 볼륨을 사용하면 기존 NFS (네트워크 파일 시스템) 볼륨을 파드에 마운트
할수 있다. 파드를 제거할 때 지워지는 <code>emptyDir</code> 와는
다르게 <code>nfs</code> 볼륨의 내용은 유지되고, 볼륨은 그저 마운트
해제만 된다. 이 의미는 NFS 볼륨에 데이터를 미리 채울 수 있으며,
파드 간에 데이터를 공유할 수 있다는 뜻이다. NFS는 여러 작성자가
동시에 마운트할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 사용하려면 먼저 NFS 서버를 실행하고 공유를 내보내야 한다.</div><p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/nfs>NFS 예시</a>를 본다.</p><h3 id=persistentvolumeclaim>persistentVolumeClaim</h3><p><code>persistentVolumeClaim</code> 볼륨은
<a href=/ko/docs/concepts/storage/persistent-volumes>퍼시스턴트볼륨</a>을 파드에 마운트하는데 사용한다. 퍼시스턴트볼륨클레임은
사용자가 특정 클라우드 환경의 세부 내용을 몰라도 내구성이있는 스토리지 (GCE 퍼시스턴트디스크 또는
iSCSI 볼륨와 같은)를 "클레임" 할 수 있는 방법이다.</p><p>더 자세한 내용은 <a href=/ko/docs/concepts/storage/persistent-volumes>퍼시스턴트볼륨 예시</a>를
본다.</p><h3 id=portworxvolume>portworxVolume (사용 중단됨)</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [deprecated]</code></div><p><code>portworxVolume</code> 은 쿠버네티스와 하이퍼컨버지드(hyperconverged)를 실행하는 탄력적인 블록 스토리지
계층이다. <a href=https://portworx.com/use-case/kubernetes-storage/>Portworx</a>는 서버의
스토리지를 핑거프린팅하고(fingerprints), 기능에 기반하여 계층화하고, 그리고 여러 서버에 걸쳐 용량을 집계한다.
Portworx는 가상 머신 내 게스트 또는 베어 메탈 리눅스 노드 위에서 실행된다.</p><p><code>portworxVolume</code> 은 쿠버네티스를 통해 동적으로 생성되거나
사전에 프로비전할 수 있으며 쿠버네티스 파드 내에서 참조할 수 있다.
다음은 사전에 프로비저닝된 Portworx 볼륨을 참조하는 파드의 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-portworx-volume-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 이 Portworx 볼륨은 이미 존재해야 한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>portworxVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pxvol&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;fs-type&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드에서 사용하기 이전에 먼저 이름이 <code>pxvol</code> 인 PortworxVolume이
있는지 확인한다.</div><p>자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/portworx/README.md>Portworx 볼륨</a> 예제를 참고한다.</p><h4 id=portworx-csi-마이그레이션>Portworx CSI 마이그레이션</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [beta]</code></div><p>Portworx를 위한 <code>CSIMigration</code> 기능이 쿠버네티스 1.23에 추가되었지만 알파 상태이기 때문에 기본적으로는 비활성화되어 있었다.
v1.25 이후 이 기능은 베타 상태가 되었지만 여전히 기본적으로는 비활성화되어 있다.
이 기능은 사용 중인 트리 내(in-tree) 플러그인의 모든 동작을
<code>pxd.portworx.com</code> CSI 드라이버로 리다이렉트한다.
이 기능을 사용하려면, 클러스터에 <a href=https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/csi/>Portworx CSI 드라이버</a>가
설치되어 있어야 한다.
이 기능을 활성화시키기 위해서는 kube-controller-manager와 kubelet에 <code>CSIMigrationPortworx=true</code>를 설정해야 한다.</p><h3 id=projected>projected</h3><p><code>Projected</code> 볼륨은 여러 기존 볼륨 소스를 동일한 디렉터리에 매핑한다.
더 자세한 사항은 <a href=/ko/docs/concepts/storage/projected-volumes/>projected volumes</a>를 참고한다.</p><h3 id=rbd>rbd</h3><p><code>rbd</code> 볼륨을 사용하면
<a href=https://docs.ceph.com/en/latest/rbd/>Rados Block Device</a>(RBD) 볼륨을 파드에 마운트할 수
있다. 파드를 제거할 때 지워지는 <code>emptyDir</code> 와는 다르게 <code>rbd</code> 볼륨의
내용은 유지되고, 볼륨은 마운트 해제만 된다. 이
의미는 RBD 볼륨에 데이터를 미리 채울 수 있으며, 데이터를
공유할 수 있다는 것이다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> RBD를 사용하기 위해선 먼저 Ceph를 설치하고 실행해야 한다.</div><p>RBD의 특징은 여러 고객이 동시에 읽기 전용으로 마운트할 수
있다는 것이다. 즉, 데이터셋으로 볼륨을 미리 채운 다음, 필요한
만큼 많은 파드에서 병렬로 제공할수 있다. 불행하게도,
RBD는 읽기-쓰기 모드에서 단일 고객만 마운트할 수 있다.
동시 쓰기는 허용되지 않는다.</p><p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/volumes/rbd>RBD 예시</a>를
참고한다.</p><h4 id=rbd-csi-migration>RBD CSI 마이그레이션</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [alpha]</code></div><p><code>RBD</code>를 위한 <code>CSIMigration</code> 기능이 활성화되어 있으면,
사용 중이 트리 내(in-tree) 플러그인의 모든 플러그인 동작을
<code>rbd.csi.ceph.com</code> <a class=glossary-tooltip title='컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>
드라이버로 리다이렉트한다.
이 기능을 사용하려면, 클러스터에
<a href=https://github.com/ceph/ceph-csi>Ceph CSI 드라이버</a>가 설치되어 있고
<code>csiMigrationRBD</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가
활성화되어 있어야 한다. (v1.24 릴리즈에서 <code>csiMigrationRBD</code> 플래그는 삭제되었으며
<code>CSIMigrationRBD</code>로 대체되었음에 주의한다.)</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>스토리지를 관리하는 쿠버네티스 클러스터 관리자는,
RBD CSI 드라이버로의 마이그레이션을 시도하기 전에
다음의 선행 사항을 완료해야 한다.</p><ul><li>쿠버네티스 클러스터에 Ceph CSI 드라이버 (<code>rbd.csi.ceph.com</code>) v3.5.0
이상을 설치해야 한다.</li><li>CSI 드라이버가 동작하기 위해 <code>clusterID</code> 필드가 필수이지만
트리 내(in-tree) 스토리지클래스는 <code>monitors</code> 필드가 필수임을 감안하여,
쿠버네티스 저장소 관리자는 monitors 값의
해시(예: <code>#echo -n '&lt;monitors_string>' | md5sum</code>)
기반으로 clusterID를 CSI 컨피그맵 내에 만들고
이 clusterID 환경 설정 아래에 monitors 필드를 유지해야 한다.</li><li>또한, 트리 내(in-tree) 스토리지클래스의
<code>adminId</code> 값이 <code>admin</code>이 아니면, 트리 내(in-tree) 스토리지클래스의
<code>adminSecretName</code> 값이 <code>adminId</code> 파라미터 값의
base64 값으로 패치되어야 하며, 아니면 이 단계를 건너뛸 수 있다.</li></ul></div><h3 id=secret>secret</h3><p><code>secret</code> 볼륨은 암호와 같은 민감한 정보를 파드에 전달하는데
사용된다. 쿠버네티스 API에 시크릿을 저장하고 쿠버네티스에 직접적으로 연결하지 않고도
파드에서 사용할 수 있도록 파일로 마운트 할 수 있다. <code>secret</code> 볼륨은
tmpfs(RAM 기반 파일시스템)로 지원되기 때문에 비 휘발성 스토리지에 절대
기록되지 않는다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 사용하기 위해선 먼저 쿠버네티스 API에서 시크릿을 생성해야 한다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 시크릿을 <a href=#using-subpath><code>subPath</code></a> 볼륨 마운트로 사용하는 컨테이너는 시크릿
업데이트를 수신하지 못한다.</div><p>더 자세한 내용은 <a href=/ko/docs/concepts/configuration/secret/>시크릿 구성하기</a>를 참고한다.</p><h3 id=vspherevolume>vsphereVolume (사용 중단됨)</h3><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 드라이버 대신 외부(out-of-tree) vSphere CSI 드라이버를 사용하는 것을 권장한다.</div><p><code>vsphereVolume</code> 은 vSphere VMDK 볼륨을 파드에 마운트하는데 사용된다. 볼륨을
마운트 해제해도 볼륨의 내용이 유지된다. VMFS와 VSAM 데이터스토어를 모두 지원한다.</p><p>더 자세한 내용은 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>vSphere 볼륨</a> 예제를 참고한다.</p><h4 id=vsphere-csi-migration>vSphere CSI 마이그레이션</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.19 [beta]</code></div><p><code>vsphereVolume</code> 용 <code>CSIMigrationvSphere</code> 기능은 쿠버네티스 v1.25부터 기본적으로 활성화되어 있다.
인-트리 <code>vspherevolume</code>의 모든 플러그인 작업은 <code>CSIMigrationvSphere</code> 기능 게이트가 비활성화된 경우를 제외하고 <code>csi.vsphere.vmware.com</code> <a class=glossary-tooltip title='컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>로 리다이렉트된다.</p><p><a href=https://github.com/kubernetes-sigs/vsphere-csi-driver>vSphere CSI 드라이버</a>가
클러스터에 설치되어 있어야 한다. 인-트리 <code>vsphereVolume</code> 마이그레이션에 대한 추가 조언은 VMware의 문서 페이지
<a href=https://docs.vmware.com/en/VMware-vSphere-Container-Storage-Plug-in/2.0/vmware-vsphere-csp-getting-started/GUID-968D421F-D464-4E22-8127-6CB9FF54423F.html>인-트리 vSphere 볼륨을 vSphere 컨테이너 스토리지 플러그인으로 마이그레이션하기</a>를 참고한다.</p><p>쿠버네티스 v1.25 현재, 7.0u2 이하의 vSphere는
(사용 중단된) 인-트리 vSphere 스토리지 드라이버가 지원되지 않는다.
사용 중단된 드라이버를 계속 사용하거나, 교체된 CSI 드라이버로
마이그레이션하기 위해서는 vSphere 7.0u2 이상을 사용해야 한다.</p><p>v1.25 외의 쿠버네티스 버전을 사용 중인 경우,
해당 쿠버네티스 버전의 문서를 참고한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>빌트인 <code>vsphereVolume</code> 플러그인의 다음 스토리지클래스 파라미터는 vSphere CSI 드라이버에서 지원되지 않는다.</p><ul><li><code>diskformat</code></li><li><code>hostfailurestotolerate</code></li><li><code>forceprovisioning</code></li><li><code>cachereservation</code></li><li><code>diskstripes</code></li><li><code>objectspacereservation</code></li><li><code>iopslimit</code></li></ul><p>이러한 파라미터를 사용하여 생성된 기존 볼륨은 vSphere CSI 드라이버로 마이그레이션되지만,
vSphere CSI 드라이버에서 생성된 새 볼륨은 이러한 파라미터를 따르지 않는다.</p></div><h4 id=vsphere-csi-migration-complete>vSphere CSI 마이그레이션 완료</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.19 [beta]</code></div><p><code>vsphereVolume</code> 플러그인이 컨트롤러 관리자와 kubelet에 의해 로드되지 않도록 기능을 비활성화하려면, <code>InTreePluginvSphereUnregister</code> 기능 플래그를 <code>true</code> 로 설정해야 한다. 이를 위해서는 모든 워커 노드에 <code>csi.vsphere.vmware.com</code> <a class=glossary-tooltip title='컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 드라이버를 설치해야 한다.</p><h2 id=using-subpath>subPath 사용하기</h2><p>때로는 단일 파드에서 여러 용도의 한 볼륨을 공유하는 것이 유용하다.
<code>volumeMounts.subPath</code> 속성을 사용해서 root 대신 참조하는 볼륨 내의 하위 경로를
지정할 수 있다.</p><p>다음의 예시는 단일 공유 볼륨을 사용하여 LAMP 스택(리눅스 Apache MySQL PHP)이
있는 파드를 구성하는 방법을 보여준다. 이 샘플 <code>subPath</code> 구성은 프로덕션 용도로
권장되지 않는다.</p><p>PHP 애플리케이션의 코드와 자산은 볼륨의 <code>html</code> 폴더에 매핑되고
MySQL 데이터베이스는 볼륨의 <code>mysql</code> 폴더에 저장된다. 예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-lamp-site<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;rootpasswd&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>php:7.0-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/www/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>my-lamp-site-data<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=using-subpath-expanded-environment>subPath를 확장된 환경 변수와 함께 사용하기</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.17 [stable]</code></div><p><code>subPathExpr</code> 필드를 사용해서 다운워드 API 환경 변수로부터
<code>subPath</code> 디렉터리 이름을 구성한다.
<code>subPath</code> 와 <code>subPathExpr</code> 속성은 상호 배타적이다.</p><p>이 예제는 <code>Pod</code> 가 <code>subPathExpr</code> 을 사용해서 <code>hostPath</code> 볼륨
<code>/var/log/pods</code> 내에 <code>pod1</code> 디렉터리를 만든다.
<code>hostPath</code> 볼륨은 <code>downwardAPI</code> 에서 <code>Pod</code> 이름을 사용한다.
호스트 디렉토리 <code>/var/log/pods/pod1</code> 은 컨테이너의 <code>/logs</code> 에 마운트된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>POD_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while [ true ]; do echo &#39;Hello&#39;; sleep 10; done | tee -a /logs/hello.txt&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/logs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 변수 확장에는 괄호를 사용한다(중괄호 아님).</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>subPathExpr</span>:<span style=color:#bbb> </span>$(POD_NAME)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/pods<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=리소스>리소스</h2><p><code>emptyDir</code> 볼륨의 스토리지 매체(디스크나 SSD와 같은)는 kubelet root
디렉터리(보통 <code>/var/lib/kubelet</code>)를 보유한 파일시스템의
매체에 의해 결정 된다. <code>emptyDir</code> 또는 <code>hostPath</code> 볼륨이
사용할 수 있는 공간의 크기는 제한이 없으며, 컨테이너 간 또는 파드 간 격리는
없다.</p><p>리소스 사양을 사용한 공간 요청에 대한 자세한 내용은
<a href=/ko/docs/concepts/configuration/manage-resources-containers/>리소스 관리 방법</a>을 참고한다.</p><h2 id=아웃-오브-트리-out-of-tree-볼륨-플러그인>아웃-오브-트리(out-of-tree) 볼륨 플러그인</h2><p>아웃-오브-트리 볼륨 플러그인에는
<a class=glossary-tooltip title='컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label='컨테이너 스토리지 인터페이스'>컨테이너 스토리지 인터페이스</a>(CSI) 그리고 FlexVolume(사용 중단됨)이 포함된다. 이러한 플러그인을 사용하면 스토리지 벤더들은 플러그인 소스 코드를 쿠버네티스 리포지터리에
추가하지 않고도 사용자 정의 스토리지 플러그인을 만들 수 있다.</p><p>이전에는 모든 볼륨 플러그인이 "인-트리(in-tree)"에 있었다. "인-트리" 플러그인은 쿠버네티스 핵심 바이너리와
함께 빌드, 링크, 컴파일 및 배포되었다. 즉, 쿠버네티스(볼륨 플러그인)에
새로운 스토리지 시스템을 추가하려면 쿠버네티스 핵심 코드 리포지토리의 코드 확인이 필요했음을 의미한다.</p><p>CSI와 FlexVolume을 통해 쿠버네티스 코드 베이스와는
독립적으로 볼륨 플러그인을 개발하고, 쿠버네티스 클러스터의 확장으로 배포(설치)
할 수 있다.</p><p>아웃 오브 트리(out-of-tree) 볼륨 플러그인을 생성하려는 스토리지 벤더는
<a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>볼륨 플러그인 FAQ</a>를 참조한다.</p><h3 id=csi>csi</h3><p><a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>컨테이너 스토리지 인터페이스</a>(CSI)는
컨테이너 오케스트레이션 시스템(쿠버네티스와 같은)을 위한 표준 인터페이스를
정의하여 임의의 스토리지 시스템을 컨테이너 워크로드에 노출시킨다.</p><p>더 자세한 정보는 <a href=https://git.k8s.io/design-proposals-archive/storage/container-storage-interface.md>CSI 디자인 제안</a>을 읽어본다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> CSI 규격 버전 0.2와 0.3에 대한 지원은 쿠버네티스 v1.13에서 사용중단(deprecated)
되었고, 향후 릴리스에서 제거될 예정이다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> CSI 드라이버는 일부 쿠버네티스 릴리스에서 호환되지 않을 수 있다.
각각의 쿠버네티스 릴리스와 호환성 매트릭스에 대해 지원되는
배포 단계는 특정 CSI 드라이버 문서를 참조한다.</div><p>CSI 호환 볼륨 드라이버가 쿠버네티스 클러스터에 배포되면
사용자는 <code>csi</code> 볼륨 유형을 사용해서 CSI 드라이버에 의해 노출된 볼륨에 연결하거나
마운트할 수 있다.</p><p><code>csi</code> 볼륨은 세 가지 방법으로 파드에서 사용할 수 있다.</p><ul><li><a href=#persistentvolumeclaim>퍼시스턴트볼륨클레임</a>에 대한 참조를 통해서</li><li><a href=/ko/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes>일반 임시 볼륨</a>과 함께</li><li>드라이버가 지원하는 경우 <a href=/ko/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>CSI 임시 볼륨</a>과 함께</li></ul><p>스토리지 관리자가 다음 필드를 사용해서 CSI 퍼시스턴트 볼륨을
구성할 수 있다.</p><ul><li><code>driver</code>: 사용할 볼륨 드라이버의 이름을 지정하는 문자열 값.
이 값은 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#getplugininfo>CSI 사양</a>에
정의된 CSI 드라이버가 <code>GetPluginInfoResponse</code> 에 반환하는 값과 일치해야 한다.
쿠버네티스에서 호출할 CSI 드라이버를 식별하고, CSI 드라이버 컴포넌트에서
CSI 드라이버에 속하는 PV 오브젝트를 식별하는데 사용한다.</li><li><code>volumeHandle</code>: 볼륨을 식별하게 하는 고유한 문자열 값.
이 값은 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI 사양</a>에
정의된 CSI 드라이버가 <code>CreateVolumeResponse</code> 의 <code>volume.id</code> 필드에 반환하는 값과 일치해야 한다.
이 값은 볼륨을 참조할 때 CSI 볼륨 드라이버에 대한 모든 호출에
<code>volume_id</code> 값을 전달한다.</li><li><code>readOnly</code>: 볼륨을 읽기 전용으로 "ControllerPublished" (연결)할지
여부를 나타내는 선택적인 불리언(boolean) 값. 기본적으로 false 이다. 이 값은
<code>ControllerPublishVolumeRequest</code> 의 <code>readonly</code> 필드를
통해 CSI 드라이버로 전달된다.</li><li><code>fsType</code>: 만약 PV의 <code>VolumeMode</code> 가 <code>Filesystem</code> 인 경우에 이 필드는
볼륨을 마운트하는 데 사용해야 하는 파일시스템을 지정하는 데 사용될 수 있다. 만약
볼륨이 포맷되지 않았고 포맷이 지원되는 경우, 이 값은
볼륨을 포맷하는데 사용된다.
이 값은 <code>ControllerPublishVolumeRequest</code>, <code>NodeStageVolumeRequest</code>
그리고 <code>NodePublishVolumeRequest</code> 의 <code>VolumeCapability</code>
필드를 통해 CSI 드라이버로 전달된다.</li><li><code>volumeAttributes</code>: 볼륨의 정적 속성을 지정하는 문자열과 문자열을
매핑한다. 이 매핑은 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI 사양</a>에
정의된 대로 CSI 드라이버의 <code>CreateVolumeResponse</code> 와 <code>volume.attributes</code>
필드에서 반환되는 매핑과 일치해야 한다.
이 매핑은 <code>ControllerPublishVolumeRequest</code>, <code>NodeStageVolumeRequest</code>,
그리고 <code>NodePublishVolumeRequest</code> 의 <code>volume_context</code> 필드를
통해 CSI 드라이버로 전달된다.</li><li><code>controllerPublishSecretRef</code>: CSI의 <code>ControllerPublishVolume</code>
그리고 <code>ControllerUnpublishVolume</code> 호출을 완료하기 위해 CSI 드라이버에 전달하려는
민감한 정보가 포함된 시크릿 오브젝트에 대한 참조이다. 이 필드는
선택 사항이며, 시크릿이 필요하지 않은 경우 비어있을 수 있다. 만약 시크릿에
둘 이상의 시크릿이 포함된 경우에도 모든 시크릿이 전달된다.
<code>nodeExpandSecretRef</code>: CSI <code>NodeExpandVolume</code> 호출을 완료하기 위해
CSI 드라이버에 전달하려는 민감한 정보를 포함하고 있는 시크릿에 대한
참조이다. 이 필드는 선택 사항이며, 시크릿이 필요하지 않은 경우
비어있을 수 있다. 오브젝트에 둘 이상의 시크릿이 포함된 경우에도, 모든
시크릿이 전달된다. 노드에 의해 시작된 볼륨 확장을 위한
시크릿 정보를 설정하면, kubelet은 <code>NodeExpandVolume()</code> 호출을 통해 CSI 드라이버에
해당 데이터를 전달한다. <code>nodeExpandSecretRef</code> 필드를 사용하기 위해,
클러스터는 쿠버네티스 버전 1.25 이상을 실행 중이어야 하며
모든 노드의 모든 kube-apiserver와 kubelet을 대상으로 <code>CSINodeExpandSecret</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
활성화해야 한다. 또한 노드에 의해 시작된 스토리지 크기 조정 작업 시 시크릿 정보를 지원하거나 필요로 하는
CSI 드라이버를 사용해야 한다.</li><li><code>nodePublishSecretRef</code>: CSI의 <code>NodePublishVolume</code> 호출을 완료하기 위해
CSI 드라이버에 전달하려는 민감한 정보가 포함 된 시크릿
오브젝트에 대한 참조이다. 이 필드는 선택 사항이며, 시크릿이 필요하지 않은
경우 비어있을 수 있다. 만약 시크릿 오브젝트에 둘 이상의 시크릿이 포함된 경우에도
모든 시크릿이 전달된다.</li><li><code>nodeStageSecretRef</code>: CSI의 <code>NodeStageVolume</code> 호출을 완료하기위해
CSI 드라이버에 전달하려는 민감한 정보가 포함 된 시크릿
오브젝트에 대한 참조이다. 이 필드는 선택 사항이며, 시크릿이 필요하지 않은
경우 비어있을 수 있다. 만약 시크릿에 둘 이상의 시크릿이 포함된 경우에도
모든 시크릿이 전달된다.</li></ul><h4 id=csi-원시-raw-블록-볼륨-지원>CSI 원시(raw) 블록 볼륨 지원</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [stable]</code></div><p>외부 CSI 드라이버가 있는 벤더들은 쿠버네티스 워크로드에서 원시(raw) 블록 볼륨
지원을 구현할 수 있다.</p><p>CSI 설정 변경 없이 평소와 같이
<a href=/ko/docs/concepts/storage/persistent-volumes/#%EC%9B%90%EC%8B%9C-%EB%B8%94%EB%A1%9D-%EB%B3%BC%EB%A5%A8-%EC%A7%80%EC%9B%90>원시 블록 볼륨 지원으로 퍼시스턴트볼륨/퍼시스턴트볼륨클레임</a> 설정을 할 수 있다.</p><h4 id=csi-임시-ephemeral-볼륨>CSI 임시(ephemeral) 볼륨</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><p>파드 명세 내에서 CSI 볼륨을 직접 구성할 수 있다.
이 방식으로 지정된 볼륨은 임시 볼륨이며
파드가 다시 시작할 때 지속되지 않는다.
자세한 내용은
<a href=/ko/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>임시 볼륨</a>을 참고한다.</p><p>CSI 드라이버의 개발 방법에 대한 더 자세한 정보는
<a href=https://kubernetes-csi.github.io/docs/>쿠버네티스-csi 문서</a>를 참조한다.</p><h4 id=윈도우-csi-프록시>윈도우 CSI 프록시</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.22 [stable]</code></div><p>CSI 노드 플러그인은 디스크 장치 검색 및 파일 시스템 마운트 같은
다양한 권한이 부여된 작업을 수행해야 한다. 이러한 작업은
호스트 운영 체제마다 다르다. 리눅스 워커 노드의 경우, 일반적으로 컨테이너형
CSI 노드 플러그인은 권한 있는 컨테이너로 배포된다. 윈도우 워커 노드의 경우,
각 윈도우 노드에 미리 설치해야 하는 커뮤니티판 스탠드얼론(stand-alone) 바이너리인
<a href=https://github.com/kubernetes-csi/csi-proxy>csi-proxy</a>를 이용하여
컨테이너형 CSI 노드 플러그인에 대한 권한 있는 작업을 지원한다.</p><p>자세한 내용은 배포할 CSI 플러그인의 배포 가이드를 참고한다.</p><h4 id=인-트리-플러그인으로부터-csi-드라이버로-마이그레이션하기>인-트리 플러그인으로부터 CSI 드라이버로 마이그레이션하기</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><p><code>CSIMigration</code> 기능은 기존의 인-트리 플러그인에
대한 작업을 해당 CSI 플러그인(설치와 구성이 될 것으로 예상한)으로 유도한다.
결과적으로, 운영자는 인-트리 플러그인을 대체하는
CSI 드라이버로 전환할 때 기존 스토리지 클래스, 퍼시스턴트볼륨 또는 퍼시스턴트볼륨클레임(인-트리 플러그인 참조)에
대한 구성 변경을 수행할 필요가 없다.</p><p>지원되는 작업 및 기능은 프로비저닝/삭제,
연결/분리, 마운트/마운트 해제 그리고 볼륨 크기 재조정이 포함된다.</p><p><code>CSIMigration</code> 을 지원하고 해당 CSI 드라이버가 구현된 인-트리 플러그인은
<a href=#volume-types>볼륨 유형들</a>에 나열되어 있다.</p><p>다음 인-트리 플러그인은 윈도우 노드에서 퍼시스턴트볼륨을 지원한다.</p><ul><li><a href=#awselasticblockstore><code>awsElasticBlockStore</code></a></li><li><a href=#azuredisk><code>azureDisk</code></a></li><li><a href=#azurefile><code>azureFile</code></a></li><li><a href=#gcepersistentdisk><code>gcePersistentDisk</code></a></li><li><a href=#vspherevolume><code>vsphereVolume</code></a></li></ul><h3 id=flexvolume-deprecated>flexVolume (사용 중단됨)</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [deprecated]</code></div><p>FlexVolume은 스토리지 드라이버와 인터페이싱하기 위해 exec 기반 모델을 사용하는 아웃-오브-트리 플러그인 인터페이스이다.
FlexVolume 드라이버 바이너리 파일은 각 노드의 미리 정의된 볼륨 플러그인 경로에 설치되어야 하며,
일부 경우에는 컨트롤 플레인 노드에도 설치되어야 한다.</p><p>파드는 <code>flexvolume</code> 인-트리 볼륨 플러그인을 통해 FlexVolume 드라이버와 상호 작용한다.
더 자세한 내용은 FlexVolume <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md#readme>README</a> 문서를 참고한다.</p><p>호스트에 PowerShell 스크립트로 배포된 다음과 같은
FlexVolume <a href=https://github.com/Microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows>플러그인</a>은 윈도우 노드를 지원한다.</p><ul><li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~smb.cmd>SMB</a></li><li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~iscsi.cmd>iSCSI</a></li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>FlexVolume은 사용 중단되었다. 쿠버네티스에 외부 스토리지를 연결하려면 아웃-오브-트리 CSI 드라이버를 사용하는 것을 권장한다.</p><p>FlexVolume 드라이버 메인테이너는 CSI 드라이버를 구현하고 사용자들이 FlexVolume 드라이버에서 CSI로 마이그레이트할 수 있도록 지원해야 한다.
FlexVolume 사용자는 워크로드가 동등한 CSI 드라이버를 사용하도록 이전해야 한다.</p></div><h2 id=마운트-전파-propagation>마운트 전파(propagation)</h2><p>마운트 전파를 통해 컨테이너가 마운트한 볼륨을 동일한 파드의
다른 컨테이너 또는 동일한 노드의 다른 파드로 공유할 수 있다.</p><p>볼륨 마운트 전파는 <code>Container.volumeMounts</code> 의 <code>mountPropagation</code> 필드에
의해 제어된다. 그 값은 다음과 같다.</p><ul><li><p><code>None</code> - 이 볼륨 마운트는 호스트의 볼륨 또는 해당 서브디렉터리에
마운트된 것을 마운트 이후에 수신하지 않는다.
비슷한 방식으로, 컨테이너가 생성한 마운트는 호스트에서 볼 수 없다.
이것이 기본 모드이다.</p><p>이 모드는 <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>리눅스 커널 문서</a>에
설명된 <code>rshared</code> 마운트 전파와 같다.</p></li><li><p><code>HostToContainer</code> - 이 볼륨 마운트는 볼륨 또는 해당
서브디렉터리를 마운트한 정보를 수신한다.</p><p>다시 말하면, 만약 호스트가 볼륨 마운트 내부에 다른 것을 마운트
하더라도 컨테이너가 마운트된 것을 볼 수 있다.</p><p>마찬가지로 <code>Bidirectional</code> 마운트 전파가 있는 파드가 동일한 마운트가 된 경우에
파드에 <code>HostToContainer</code> 마운트 전파가 있는
컨테이너가 이를 볼 수 있다.</p><p>이 모드는 <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>리눅스 커널 문서</a>에
설명된 <code>rshared</code> 마운트 전파와 같다.</p></li><li><p><code>Bidirectional</code> - 이 볼륨 마운트는 <code>HostToContainer</code> 마운트와 동일하게 작동한다.
추가로 컨테이너에서 생성된 모든 볼륨 마운트는 동일한 볼륨을
사용하는 모든 파드의 모든 컨테이너와 호스트로 다시 전파된다.</p><p>이 모드의 일반적인 유스 케이스로는 FlexVolume 또는 CSI 드라이버를 사용하는 파드 또는
<code>hostPath</code> 볼륨을 사용하는 호스트에 무언가를 마운트해야 하는 파드이다.</p><p>이 모드는 <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>리눅스 커널 문서</a>에
설명된 <code>rshared</code> 마운트 전파와 같다.</p></li></ul><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> <code>Bidirectional</code> 마운트 전파는 위험할 수 있다. 이것은
호스트 운영체제를 손상시킬 수 있기에 권한이 있는 컨테이너에서만
허용된다. 리눅스 커널 동작을 숙지하는 것을 권장한다.
또한 파드 내 컨테이너에 의해 생성된 볼륨 마운트는 종료 시
컨테이너에 의해 파괴(마운트 해제)되어야 한다.</div><h3 id=구성>구성</h3><p>일부 배포판(CoreOS, RedHat/Centos, Ubuntu)에서 마운트 전파가
제대로 작동하려면 아래와 같이 도커에서의 마운트 공유를
올바르게 구성해야 한다.</p><p>도커의 <code>systemd</code> 서비스 파일을 편집한다. <code>MountFlags</code> 를 다음과 같이 설정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>MountFlags</span><span style=color:#666>=</span>shared
</span></span></code></pre></div><p>또는 <code>MountFlags=slave</code> 가 있으면 제거한다. 이후 도커 데몬을 재시작 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart docker
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><p><a href=/ko/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>퍼시스턴트 볼륨과 함께 워드프레스와 MySQL 배포하기</a>의 예시를 따른다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ffd12528a12882b282e1bd19e29f9e75>2 - 퍼시스턴트 볼륨</h1><p>이 페이지에서는 쿠버네티스의 <em>퍼시스턴트 볼륨</em> 에 대해 설명한다. <a href=/ko/docs/concepts/storage/volumes/>볼륨</a>에 대해 익숙해지는 것을 추천한다.</p><h2 id=소개>소개</h2><p>스토리지 관리는 컴퓨트 인스턴스 관리와는 별개의 문제다. 퍼시스턴트볼륨 서브시스템은 사용자 및 관리자에게 스토리지 사용 방법에서부터 스토리지가 제공되는 방법에 대한 세부 사항을 추상화하는 API를 제공한다. 이를 위해 퍼시스턴트볼륨 및 퍼시스턴트볼륨클레임이라는 두 가지 새로운 API 리소스를 소개한다.</p><p><em>퍼시스턴트볼륨</em> (PV)은 관리자가 프로비저닝하거나 <a href=/ko/docs/concepts/storage/storage-classes/>스토리지 클래스</a>를 사용하여 동적으로 프로비저닝한 클러스터의 스토리지이다. 노드가 클러스터 리소스인 것처럼 PV는 클러스터 리소스이다. PV는 Volumes와 같은 볼륨 플러그인이지만, PV를 사용하는 개별 파드와는 별개의 라이프사이클을 가진다. 이 API 오브젝트는 NFS, iSCSI 또는 클라우드 공급자별 스토리지 시스템 등 스토리지 구현에 대한 세부 정보를 담아낸다.</p><p><em>퍼시스턴트볼륨클레임</em> (PVC)은 사용자의 스토리지에 대한 요청이다. 파드와 비슷하다. 파드는 노드 리소스를 사용하고 PVC는 PV 리소스를 사용한다. 파드는 특정 수준의 리소스(CPU 및 메모리)를 요청할 수 있다. 클레임은 특정 크기 및 접근 모드를 요청할 수 있다(예: ReadWriteOnce, ReadOnlyMany 또는 ReadWriteMany로 마운트 할 수 있음. <a href=#%EC%A0%91%EA%B7%BC-%EB%AA%A8%EB%93%9C>AccessModes</a> 참고).</p><p>퍼시스턴트볼륨클레임을 사용하면 사용자가 추상화된 스토리지 리소스를 사용할 수 있지만, 다른 문제들 때문에 성능과 같은 다양한 속성을 가진 퍼시스턴트볼륨이 필요한 경우가 일반적이다. 클러스터 관리자는 사용자에게 해당 볼륨의 구현 방법에 대한 세부 정보를 제공하지 않고 크기와 접근 모드와는 다른 방식으로 다양한 퍼시스턴트볼륨을 제공할 수 있어야 한다. 이러한 요구에는 <em>스토리지클래스</em> 리소스가 있다.</p><p><a href=/ko/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>실습 예제와 함께 상세한 내용</a>을 참고하길 바란다.</p><h2 id=볼륨과-클레임-라이프사이클>볼륨과 클레임 라이프사이클</h2><p>PV는 클러스터 리소스이다. PVC는 해당 리소스에 대한 요청이며 리소스에 대한 클레임 검사 역할을 한다. PV와 PVC 간의 상호 작용은 다음 라이프사이클을 따른다.</p><h3 id=프로비저닝>프로비저닝</h3><p>PV를 프로비저닝 할 수 있는 두 가지 방법이 있다: 정적(static) 프로비저닝과 동적(dynamic) 프로비저닝</p><h4 id=정적-프로비저닝>정적 프로비저닝</h4><p>클러스터 관리자는 여러 PV를 만든다. 클러스터 사용자가 사용할 수 있는 실제 스토리지의 세부 사항을 제공한다. 이 PV들은 쿠버네티스 API에 존재하며 사용할 수 있다.</p><h4 id=동적-프로비저닝>동적 프로비저닝</h4><p>관리자가 생성한 정적 PV가 사용자의 퍼시스턴트볼륨클레임과 일치하지 않으면
클러스터는 PVC를 위해 특별히 볼륨을 동적으로 프로비저닝 하려고 시도할 수 있다.
이 프로비저닝은 스토리지클래스를 기반으로 한다. PVC는
<a href=/ko/docs/concepts/storage/storage-classes/>스토리지 클래스</a>를
요청해야 하며 관리자는 동적 프로비저닝이 발생하도록 해당 클래스를 생성하고 구성해야 한다.
<code>""</code> 클래스를 요청하는 클레임은 동적 프로비저닝을 효과적으로
비활성화한다.</p><p>스토리지 클래스를 기반으로 동적 스토리지 프로비저닝을 사용하려면 클러스터 관리자가 API 서버에서
<code>DefaultStorageClass</code> <a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass>어드미션 컨트롤러</a>를 사용하도록 설정해야 한다.
예를 들어 API 서버 컴포넌트의 <code>--enable-admission-plugins</code> 플래그에 대한 쉼표로 구분되어
정렬된 값들의 목록 중에 <code>DefaultStorageClass</code>가 포함되어 있는지 확인하여 설정할 수 있다.
API 서버 커맨드라인 플래그에 대한 자세한 정보는
<a href=/docs/admin/kube-apiserver/>kube-apiserver</a> 문서를 확인하면 된다.</p><h3 id=바인딩>바인딩</h3><p>사용자는 원하는 특정 용량의 스토리지와 특정 접근 모드로 퍼시스턴트볼륨클레임을 생성하거나 동적 프로비저닝의 경우 이미 생성한 상태다. 마스터의 컨트롤 루프는 새로운 PVC를 감시하고 일치하는 PV(가능한 경우)를 찾아 서로 바인딩한다. PV가 새 PVC에 대해 동적으로 프로비저닝된 경우 루프는 항상 해당 PV를 PVC에 바인딩한다. 그렇지 않으면 사용자는 항상 최소한 그들이 요청한 것을 얻지만 볼륨은 요청된 것을 초과할 수 있다. 일단 바인딩되면 퍼시스턴트볼륨클레임은 어떻게 바인딩되었는지 상관없이 배타적으로 바인딩된다. PVC 대 PV 바인딩은 일대일 매핑으로, 퍼시스턴트볼륨과 퍼시스턴트볼륨클레임 사이의 양방향 바인딩인 ClaimRef를 사용한다.</p><p>일치하는 볼륨이 없는 경우 클레임은 무한정 바인딩되지 않은 상태로 남아 있다. 일치하는 볼륨이 제공되면 클레임이 바인딩된다. 예를 들어 많은 수의 50Gi PV로 프로비저닝된 클러스터는 100Gi를 요청하는 PVC와 일치하지 않는다. 100Gi PV가 클러스터에 추가되면 PVC를 바인딩할 수 있다.</p><h3 id=사용-중>사용 중</h3><p>파드는 클레임을 볼륨으로 사용한다. 클러스터는 클레임을 검사하여 바인딩된 볼륨을 찾고 해당 볼륨을 파드에 마운트한다. 여러 접근 모드를 지원하는 볼륨의 경우 사용자는 자신의 클레임을 파드에서 볼륨으로 사용할 때 원하는 접근 모드를 지정한다.</p><p>일단 사용자에게 클레임이 있고 그 클레임이 바인딩되면, 바인딩된 PV는 사용자가 필요로 하는 한 사용자에게 속한다. 사용자는 파드의 <code>volumes</code> 블록에 <code>persistentVolumeClaim</code>을 포함하여 파드를 스케줄링하고 클레임한 PV에 접근한다. 이에 대한 자세한 내용은 <a href=#%EB%B3%BC%EB%A5%A8%EC%9C%BC%EB%A1%9C-%ED%81%B4%EB%A0%88%EC%9E%84%ED%95%98%EA%B8%B0>볼륨으로 클레임하기</a>를 참고하길 바란다.</p><h3 id=사용-중인-스토리지-오브젝트-보호>사용 중인 스토리지 오브젝트 보호</h3><p>사용 중인 스토리지 오브젝트 보호 기능의 목적은 PVC에 바인딩된 파드와 퍼시스턴트볼륨(PV)이 사용 중인 퍼시스턴트볼륨클레임(PVC)을 시스템에서 삭제되지 않도록 하는 것이다. 삭제되면 이로 인해 데이터의 손실이 발생할 수 있기 때문이다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> PVC를 사용하는 파드 오브젝트가 존재하면 파드가 PVC를 사용하고 있는 상태이다.</div><p>사용자가 파드에서 활발하게 사용 중인 PVC를 삭제하면 PVC는 즉시 삭제되지 않는다. PVC가 더 이상 파드에서 적극적으로 사용되지 않을 때까지 PVC 삭제가 연기된다. 또한 관리자가 PVC에 바인딩된 PV를 삭제하면 PV는 즉시 삭제되지 않는다. PV가 더 이상 PVC에 바인딩되지 않을 때까지 PV 삭제가 연기된다.</p><p>PVC의 상태가 <code>Terminating</code>이고 <code>Finalizers</code> 목록에 <code>kubernetes.io/pvc-protection</code>이 포함되어 있으면 PVC가 보호된 것으로 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pvc hostpath
</span></span><span style=display:flex><span>Name:          hostpath
</span></span><span style=display:flex><span>Namespace:     default
</span></span><span style=display:flex><span>StorageClass:  example-hostpath
</span></span><span style=display:flex><span>Status:        Terminating
</span></span><span style=display:flex><span>Volume:
</span></span><span style=display:flex><span>Labels:        &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:   volume.beta.kubernetes.io/storage-class<span style=color:#666>=</span>example-hostpath
</span></span><span style=display:flex><span>               volume.beta.kubernetes.io/storage-provisioner<span style=color:#666>=</span>example.com/hostpath
</span></span><span style=display:flex><span>Finalizers:    <span style=color:#666>[</span>kubernetes.io/pvc-protection<span style=color:#666>]</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>마찬가지로 PV 상태가 <code>Terminating</code>이고 <code>Finalizers</code> 목록에 <code>kubernetes.io/pv-protection</code>이 포함되어 있으면 PV가 보호된 것으로 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pv task-pv-volume
</span></span><span style=display:flex><span>Name:            task-pv-volume
</span></span><span style=display:flex><span>Labels:          <span style=color:#b8860b>type</span><span style=color:#666>=</span><span style=color:#a2f>local</span>
</span></span><span style=display:flex><span>Annotations:     &lt;none&gt;
</span></span><span style=display:flex><span>Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection<span style=color:#666>]</span>
</span></span><span style=display:flex><span>StorageClass:    standard
</span></span><span style=display:flex><span>Status:          Terminating
</span></span><span style=display:flex><span>Claim:
</span></span><span style=display:flex><span>Reclaim Policy:  Delete
</span></span><span style=display:flex><span>Access Modes:    RWO
</span></span><span style=display:flex><span>Capacity:        1Gi
</span></span><span style=display:flex><span>Message:
</span></span><span style=display:flex><span>Source:
</span></span><span style=display:flex><span>    Type:          HostPath <span style=color:#666>(</span>bare host directory volume<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    Path:          /tmp/data
</span></span><span style=display:flex><span>    HostPathType:
</span></span><span style=display:flex><span>Events:            &lt;none&gt;
</span></span></code></pre></div><h3 id=반환-reclaiming>반환(Reclaiming)</h3><p>사용자가 볼륨을 다 사용하고나면 리소스를 반환할 수 있는 API를 사용하여 PVC 오브젝트를 삭제할 수 있다. 퍼시스턴트볼륨의 반환 정책은 볼륨에서 클레임을 해제한 후 볼륨에 수행할 작업을 클러스터에 알려준다. 현재 볼륨에 대한 반환 정책은 Retain, Recycle, 그리고 Delete가 있다.</p><h4 id=retain-보존>Retain(보존)</h4><p><code>Retain</code> 반환 정책은 리소스를 수동으로 반환할 수 있게 한다. 퍼시스턴트볼륨클레임이 삭제되면 퍼시스턴트볼륨은 여전히 존재하며 볼륨은 "릴리스 된" 것으로 간주된다. 그러나 이전 요청자의 데이터가 여전히 볼륨에 남아 있기 때문에 다른 요청에 대해서는 아직 사용할 수 없다. 관리자는 다음 단계에 따라 볼륨을 수동으로 반환할 수 있다.</p><ol><li>퍼시스턴트볼륨을 삭제한다. PV가 삭제된 후에도 외부 인프라(예: AWS EBS, GCE PD, Azure Disk 또는 Cinder 볼륨)의 관련 스토리지 자산이 존재한다.</li><li>관련 스토리지 자산의 데이터를 수동으로 삭제한다.</li><li>연결된 스토리지 자산을 수동으로 삭제한다.</li></ol><p>동일한 스토리지 자산을 재사용하려는 경우, 동일한 스토리지 자산 정의로 새 퍼시스턴트볼륨을 생성한다.</p><h4 id=delete-삭제>Delete(삭제)</h4><p><code>Delete</code> 반환 정책을 지원하는 볼륨 플러그인의 경우, 삭제는 쿠버네티스에서 퍼시스턴트볼륨 오브젝트와 외부 인프라(예: AWS EBS, GCE PD, Azure Disk 또는 Cinder 볼륨)의 관련 스토리지 자산을 모두 삭제한다. 동적으로 프로비저닝된 볼륨은 <a href=#%EB%B0%98%ED%99%98-%EC%A0%95%EC%B1%85>스토리지클래스의 반환 정책</a>을 상속하며 기본값은 <code>Delete</code>이다. 관리자는 사용자의 기대에 따라 스토리지클래스를 구성해야 한다. 그렇지 않으면 PV를 생성한 후 PV를 수정하거나 패치해야 한다. <a href=/ko/docs/tasks/administer-cluster/change-pv-reclaim-policy/>퍼시스턴트볼륨의 반환 정책 변경</a>을 참고하길 바란다.</p><h4 id=recycle-재활용>Recycle(재활용)</h4><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> <code>Recycle</code> 반환 정책은 더 이상 사용하지 않는다. 대신 권장되는 방식은 동적 프로비저닝을 사용하는 것이다.</div><p>기본 볼륨 플러그인에서 지원하는 경우 <code>Recycle</code> 반환 정책은 볼륨에서 기본 스크럽(<code>rm -rf /thevolume/*</code>)을 수행하고 새 클레임에 다시 사용할 수 있도록 한다.</p><p>그러나 관리자는 <a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>레퍼런스</a>에
설명된 대로 쿠버네티스 컨트롤러 관리자 커맨드라인 인자(command line arguments)를
사용하여 사용자 정의 재활용 파드 템플릿을 구성할 수 있다.
사용자 정의 재활용 파드 템플릿에는 아래 예와 같이 <code>volumes</code> 명세가
포함되어야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/any/path/it/will/be/replaced<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;registry.k8s.io/busybox&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/scrub<span style=color:#bbb>
</span></span></span></code></pre></div><p>그러나 <code>volumes</code> 부분의 사용자 정의 재활용 파드 템플릿에 지정된 특정 경로는 재활용되는 볼륨의 특정 경로로 바뀐다.</p><h3 id=persistentvolume-deletion-protection-finalizer>퍼시스턴트볼륨 삭제 보호 파이널라이저(finalizer)</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [alpha]</code></div><p>퍼시스턴트볼륨에 파이널라이저를 추가하여, <code>Delete</code> 반환 정책을 갖는 퍼시스턴트볼륨이
기반 스토리지(backing storage)가 삭제된 이후에만 삭제되도록 할 수 있다.</p><p>새롭게 도입된 <code>kubernetes.io/pv-controller</code> 및 <code>external-provisioner.volume.kubernetes.io/finalizer</code> 파이널라이저는
동적으로 프로비전된 볼륨에만 추가된다.</p><p><code>kubernetes.io/pv-controller</code> 파이널라이저는 인-트리 플러그인 볼륨에 추가된다. 다음은 이에 대한 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pv pvc-74a498d6-3929-47e8-8c02-078c1ece4d78
</span></span><span style=display:flex><span>Name:            pvc-74a498d6-3929-47e8-8c02-078c1ece4d78
</span></span><span style=display:flex><span>Labels:          &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:     kubernetes.io/createdby: vsphere-volume-dynamic-provisioner
</span></span><span style=display:flex><span>                 pv.kubernetes.io/bound-by-controller: yes
</span></span><span style=display:flex><span>                 pv.kubernetes.io/provisioned-by: kubernetes.io/vsphere-volume
</span></span><span style=display:flex><span>Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection kubernetes.io/pv-controller<span style=color:#666>]</span>
</span></span><span style=display:flex><span>StorageClass:    vcp-sc
</span></span><span style=display:flex><span>Status:          Bound
</span></span><span style=display:flex><span>Claim:           default/vcp-pvc-1
</span></span><span style=display:flex><span>Reclaim Policy:  Delete
</span></span><span style=display:flex><span>Access Modes:    RWO
</span></span><span style=display:flex><span>VolumeMode:      Filesystem
</span></span><span style=display:flex><span>Capacity:        1Gi
</span></span><span style=display:flex><span>Node Affinity:   &lt;none&gt;
</span></span><span style=display:flex><span>Message:         
</span></span><span style=display:flex><span>Source:
</span></span><span style=display:flex><span>    Type:               vSphereVolume <span style=color:#666>(</span>a Persistent Disk resource in vSphere<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    VolumePath:         <span style=color:#666>[</span>vsanDatastore<span style=color:#666>]</span> d49c4a62-166f-ce12-c464-020077ba5d46/kubernetes-dynamic-pvc-74a498d6-3929-47e8-8c02-078c1ece4d78.vmdk
</span></span><span style=display:flex><span>    FSType:             ext4
</span></span><span style=display:flex><span>    StoragePolicyName:  vSAN Default Storage Policy
</span></span><span style=display:flex><span>Events:                 &lt;none&gt;
</span></span></code></pre></div><p><code>external-provisioner.volume.kubernetes.io/finalizer</code> 파이널라이저는 CSI 볼륨에 추가된다.
다음은 이에 대한 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:            pvc-2f0bab97-85a8-4552-8044-eb8be45cf48d
</span></span><span style=display:flex><span>Labels:          &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:     pv.kubernetes.io/provisioned-by: csi.vsphere.vmware.com
</span></span><span style=display:flex><span>Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection external-provisioner.volume.kubernetes.io/finalizer<span style=color:#666>]</span>
</span></span><span style=display:flex><span>StorageClass:    fast
</span></span><span style=display:flex><span>Status:          Bound
</span></span><span style=display:flex><span>Claim:           demo-app/nginx-logs
</span></span><span style=display:flex><span>Reclaim Policy:  Delete
</span></span><span style=display:flex><span>Access Modes:    RWO
</span></span><span style=display:flex><span>VolumeMode:      Filesystem
</span></span><span style=display:flex><span>Capacity:        200Mi
</span></span><span style=display:flex><span>Node Affinity:   &lt;none&gt;
</span></span><span style=display:flex><span>Message:         
</span></span><span style=display:flex><span>Source:
</span></span><span style=display:flex><span>    Type:              CSI <span style=color:#666>(</span>a Container Storage Interface <span style=color:#666>(</span>CSI<span style=color:#666>)</span> volume <span style=color:#a2f>source</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>    Driver:            csi.vsphere.vmware.com
</span></span><span style=display:flex><span>    FSType:            ext4
</span></span><span style=display:flex><span>    VolumeHandle:      44830fa8-79b4-406b-8b58-621ba25353fd
</span></span><span style=display:flex><span>    ReadOnly:          <span style=color:#a2f>false</span>
</span></span><span style=display:flex><span>    VolumeAttributes:      storage.kubernetes.io/csiProvisionerIdentity<span style=color:#666>=</span>1648442357185-8081-csi.vsphere.vmware.com
</span></span><span style=display:flex><span>                           <span style=color:#b8860b>type</span><span style=color:#666>=</span>vSphere CNS Block Volume
</span></span><span style=display:flex><span>Events:                &lt;none&gt;
</span></span></code></pre></div><p>특정 인-트리 볼륨 플러그인에 대해 <code>CSIMigration{provider}</code> 기능 플래그가 활성화되어 있을 때,
<code>kubernetes.io/pv-controller</code> 파이널라이저는
<code>external-provisioner.volume.kubernetes.io/finalizer</code> 파이널라이저로 대체된다.</p><h3 id=퍼시스턴트볼륨-예약>퍼시스턴트볼륨 예약</h3><p>컨트롤 플레인은 클러스터에서 <a href=#%EB%B0%94%EC%9D%B8%EB%94%A9>퍼시스턴트볼륨클레임을 일치하는 퍼시스턴트볼륨에 바인딩</a>할
수 있다. 그러나, PVC를 특정 PV에 바인딩하려면, 미리 바인딩해야 한다.</p><p>퍼시스턴트볼륨클레임에서 퍼시스턴트볼륨을 지정하여, 특정 PV와 PVC 간의 바인딩을 선언한다.
퍼시스턴트볼륨이 존재하고 <code>claimRef</code> 필드를 통해 퍼시스턴트볼륨클레임을 예약하지 않은 경우, 퍼시스턴트볼륨 및 퍼시스턴트볼륨클레임이 바인딩된다.</p><p>바인딩은 노드 선호도(affinity)를 포함하여 일부 볼륨 일치(matching) 기준과 관계없이 발생한다.
컨트롤 플레인은 여전히 <a href=/ko/docs/concepts/storage/storage-classes/>스토리지 클래스</a>, 접근 모드 및 요청된 스토리지 크기가 유효한지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 빈 문자열은 명시적으로 설정해야 하며 그렇지 않으면 기본 스토리지클래스가 설정됨</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>이 메서드는 퍼시스턴트볼륨에 대한 바인딩 권한을 보장하지 않는다. 다른 퍼시스턴트볼륨클레임에서 지정한 PV를 사용할 수 있는 경우, 먼저 해당 스토리지 볼륨을 예약해야 한다. PV의 <code>claimRef</code> 필드에 관련 퍼시스턴트볼륨클레임을 지정하여 다른 PVC가 바인딩할 수 없도록 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>claimRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>이는 기존 PV를 재사용하는 경우를 포함하여 <code>claimPolicy</code> 가
<code>Retain</code> 으로 설정된 퍼시스턴트볼륨을 사용하려는 경우에 유용하다.</p><h3 id=퍼시스턴트-볼륨-클레임-확장>퍼시스턴트 볼륨 클레임 확장</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [stable]</code></div><p>퍼시스턴트볼륨클레임(PVC) 확장 지원은 기본적으로 활성화되어 있다. 다음 유형의
볼륨을 확장할 수 있다.</p><ul><li>azureDisk</li><li>azureFile</li><li>awsElasticBlockStore</li><li>cinder (deprecated)</li><li><a class=glossary-tooltip title='컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=csi>csi</a></li><li>flexVolume (deprecated)</li><li>gcePersistentDisk</li><li>glusterfs</li><li>rbd</li><li>portworxVolume</li></ul><p>스토리지 클래스의 <code>allowVolumeExpansion</code> 필드가 true로 설정된 경우에만 PVC를 확장할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>PVC에 대해 더 큰 볼륨을 요청하려면 PVC 오브젝트를 수정하여 더 큰 용량을
지정한다. 이는 기본 퍼시스턴트볼륨을 지원하는 볼륨의 확장을 트리거한다. 클레임을 만족시키기 위해
새로운 퍼시스턴트볼륨이 생성되지 않고 기존 볼륨의 크기가 조정된다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 퍼시스턴트볼륨의 크기를 직접 변경하면 자동 볼륨 리사이즈 기능을 이용할 수 없게 된다.
퍼시스턴트볼륨의 크기를 변경하고,
퍼시스턴트볼륨에 해당되는 퍼시스턴트볼륨클레임의 <code>.spec</code>에 적혀 있는 크기를 동일하게 변경하면,
스토리지 리사이즈가 발생하지 않는다.
쿠버네티스 컨트롤 플레인은
두 리소스의 목표 상태(desired state)가 일치하는 것을 확인하고,
배후(backing) 볼륨 크기가 수동으로 증가되어 리사이즈가 필요하지 않다고 판단할 것이다.</div><h4 id=csi-볼륨-확장>CSI 볼륨 확장</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.16 [beta]</code></div><p>CSI 볼륨 확장 지원은 기본적으로 활성화되어 있지만 볼륨 확장을 지원하려면 특정 CSI 드라이버도 필요하다. 자세한 내용은 특정 CSI 드라이버 문서를 참고한다.</p><h4 id=파일시스템을-포함하는-볼륨-크기-조정>파일시스템을 포함하는 볼륨 크기 조정</h4><p>파일시스템이 XFS, Ext3 또는 Ext4 인 경우에만 파일시스템을 포함하는 볼륨의 크기를 조정할 수 있다.</p><p>볼륨에 파일시스템이 포함된 경우 새 파드가 <code>ReadWrite</code> 모드에서 퍼시스턴트볼륨클레임을 사용하는
경우에만 파일시스템의 크기가 조정된다. 파일시스템 확장은 파드가 시작되거나
파드가 실행 중이고 기본 파일시스템이 온라인 확장을 지원할 때 수행된다.</p><p>FlexVolumes(쿠버네티스 v1.23부터 사용 중단됨)는 드라이버의 <code>RequiresFSResize</code> 기능이 <code>true</code>로 설정된 경우 크기 조정을 허용한다.
FlexVolume은 파드 재시작 시 크기를 조정할 수 있다.</p><h4 id=사용-중인-퍼시스턴트볼륨클레임-크기-조정>사용 중인 퍼시스턴트볼륨클레임 크기 조정</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [stable]</code></div><p>이 경우 기존 PVC를 사용하는 파드 또는 디플로이먼트를 삭제하고 다시 만들 필요가 없다.
파일시스템이 확장되자마자 사용 중인 PVC가 파드에서 자동으로 사용 가능하다.
이 기능은 파드나 디플로이먼트에서 사용하지 않는 PVC에는 영향을 미치지 않는다. 확장을 완료하기 전에
PVC를 사용하는 파드를 만들어야 한다.</p><p>다른 볼륨 유형과 비슷하게 FlexVolume 볼륨도 파드에서 사용 중인 경우 확장할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> FlexVolume의 크기 조정은 기본 드라이버가 크기 조정을 지원하는 경우에만 가능하다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> EBS 볼륨 확장은 시간이 많이 걸리는 작업이다. 또한 6시간마다 한 번의 수정을 할 수 있는 볼륨별 쿼터가 있다.</div><h4 id=볼륨-확장-시-오류-복구>볼륨 확장 시 오류 복구</h4><p>사용자가 기반 스토리지 시스템이 제공할 수 있는 것보다 더 큰 사이즈를 지정하면, 사용자 또는 클러스터 관리자가 조치를 취하기 전까지 PVC 확장을 계속 시도한다. 이는 바람직하지 않으며 따라서 쿠버네티스는 이러한 오류 상황에서 벗어나기 위해 다음과 같은 방법을 제공한다.</p><ul class="nav nav-tabs" id=recovery-methods role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#recovery-methods-0 role=tab aria-controls=recovery-methods-0 aria-selected=true>클러스터 관리자 접근 권한을 이용하여 수동으로</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#recovery-methods-1 role=tab aria-controls=recovery-methods-1>더 작은 크기로의 확장을 요청하여</a></li></ul><div class=tab-content id=recovery-methods><div id=recovery-methods-0 class="tab-pane show active" role=tabpanel aria-labelledby=recovery-methods-0><p><p>기본 스토리지 확장에 실패하면, 클러스터 관리자가 수동으로 퍼시스턴트 볼륨 클레임(PVC) 상태를 복구하고 크기 조정 요청을 취소할 수 있다. 그렇지 않으면, 컨트롤러가 관리자 개입 없이 크기 조정 요청을 계속해서 재시도한다.</p><ol><li>퍼시스턴트볼륨클레임(PVC)에 바인딩된 퍼시스턴트볼륨(PV)을 <code>Retain</code> 반환 정책으로 표시한다.</li><li>PVC를 삭제한다. PV에는 <code>Retain</code> 반환 정책이 있으므로 PVC를 재생성할 때 데이터가 손실되지 않는다.</li><li>새 PVC를 바인딩할 수 있도록 PV 명세에서 <code>claimRef</code> 항목을 삭제한다. 그러면 PV가 <code>Available</code> 상태가 된다.</li><li>PV 보다 작은 크기로 PVC를 다시 만들고 PVC의 <code>volumeName</code> 필드를 PV 이름으로 설정한다. 이것은 새 PVC를 기존 PV에 바인딩해야 한다.</li><li>PV의 반환 정책을 복원하는 것을 잊지 않는다.</li></ol></div><div id=recovery-methods-1 class=tab-pane role=tabpanel aria-labelledby=recovery-methods-1><p><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [alpha]</code></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> PVC 확장 실패의 사용자에 의한 복구는 쿠버네티스 1.23부터 제공되는 알파 기능이다. 이 기능이 작동하려면 <code>RecoverVolumeExpansionFailure</code> 기능이 활성화되어 있어야 한다. 더 많은 정보는 <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a> 문서를 참조한다.</div><p>클러스터에 <code>RecoverVolumeExpansionFailure</code>
기능 게이트가 활성화되어 있는 상태에서 PVC 확장이 실패하면
이전에 요청했던 값보다 작은 크기로의 확장을 재시도할 수 있다.
더 작은 크기를 지정하여 확장 시도를 요청하려면,
이전에 요청했던 값보다 작은 크기로 PVC의 <code>.spec.resources</code> 값을 수정한다.
이는 총 용량 제한(capacity constraint)으로 인해 큰 값으로의 확장이 실패한 경우에 유용하다.
만약 확장이 실패했다면, 또는 실패한 것 같다면, 기반 스토리지 공급자의 용량 제한보다 작은 값으로 확장을 재시도할 수 있다.
<code>.status.resizeStatus</code>와 PVC의 이벤트를 감시하여 리사이즈 작업의 상태를 모니터할 수 있다.</p><p>참고:
이전에 요청했던 값보다 작은 크기를 요청했더라도,
새로운 값이 여전히 <code>.status.capacity</code>보다 클 수 있다.
쿠버네티스는 PVC를 현재 크기보다 더 작게 축소하는 것은 지원하지 않는다.</p></div></div><h2 id=퍼시스턴트-볼륨의-유형>퍼시스턴트 볼륨의 유형</h2><p>퍼시스턴트볼륨 유형은 플러그인으로 구현된다. 쿠버네티스는 현재 다음의 플러그인을 지원한다.</p><ul><li><a href=/ko/docs/concepts/storage/volumes/#cephfs><code>cephfs</code></a> - CephFS 볼륨</li><li><a href=/ko/docs/concepts/storage/volumes/#csi><code>csi</code></a> - 컨테이너 스토리지 인터페이스 (CSI)</li><li><a href=/ko/docs/concepts/storage/volumes/#fc><code>fc</code></a> - Fibre Channel (FC) 스토리지</li><li><a href=/ko/docs/concepts/storage/volumes/#hostpath><code>hostPath</code></a> - HostPath 볼륨
(단일 노드 테스트 전용. 다중-노드 클러스터에서 작동하지 않음.
대신 <code>로컬</code> 볼륨 사용 고려)</li><li><a href=/ko/docs/concepts/storage/volumes/#iscsi><code>iscsi</code></a> - iSCSI (SCSI over IP) 스토리지</li><li><a href=/ko/docs/concepts/storage/volumes/#local><code>local</code></a> - 노드에 마운트된
로컬 스토리지 디바이스</li><li><a href=/ko/docs/concepts/storage/volumes/#nfs><code>nfs</code></a> - 네트워크 파일 시스템 (NFS) 스토리지</li><li><a href=/ko/docs/concepts/storage/volumes/#rbd><code>rbd</code></a> - Rados Block Device (RBD) 볼륨</li></ul><p>아래의 PersistentVolume 타입은 사용 중단되었다. 이 말인 즉슨, 지원은 여전히 제공되지만 추후 쿠버네티스 릴리스에서는 삭제될 예정이라는 것이다.</p><ul><li><a href=/ko/docs/concepts/storage/volumes/#awselasticblockstore><code>awsElasticBlockStore</code></a> - AWS Elastic Block Store (EBS)
(v1.17에서 <strong>사용 중단</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#azuredisk><code>azureDisk</code></a> - Azure Disk
(v1.19에서 <strong>사용 중단</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#azurefile><code>azureFile</code></a> - Azure File
(v1.21에서 <strong>사용 중단</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#cinder><code>cinder</code></a> - Cinder (오픈스택 블록 스토리지)
(v1.18에서 <strong>사용 중단</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#flexvolume><code>flexVolume</code></a> - FlexVolume
(v1.23에서 <strong>사용 중단</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#gcepersistentdisk><code>gcePersistentDisk</code></a> - GCE Persistent Disk
(v1.17에서 <strong>사용 중단</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#glusterfs><code>glusterfs</code></a> - Glusterfs 볼륨
(v1.25에서 <strong>사용 중단</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#portworxvolume><code>portworxVolume</code></a> - Portworx 볼륨
(v1.25에서 <strong>사용 중단</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#vspherevolume><code>vsphereVolume</code></a> - vSphere VMDK 볼륨
(v1.19에서 <strong>사용 중단</strong>)</li></ul><p>이전 쿠버네티스 버전은 아래의 인-트리 PersistentVolume 타입도 지원했었다.</p><ul><li><code>photonPersistentDisk</code> - Photon 컨트롤러 퍼시스턴트 디스크.
(v1.15부터 <strong>사용 불가</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#scaleio><code>scaleIO</code></a> - ScaleIO 볼륨
(v1.21부터 <strong>사용 불가</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#flocker><code>flocker</code></a> - Flocker 스토리지
(v1.25부터 <strong>사용 불가</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#quobyte><code>quobyte</code></a> - Quobyte 볼륨
(v1.25부터 <strong>사용 불가</strong>)</li><li><a href=/ko/docs/concepts/storage/volumes/#storageos><code>storageos</code></a> - StorageOS 볼륨
(v1.25부터 <strong>사용 불가</strong>)</li></ul><h2 id=퍼시스턴트-볼륨>퍼시스턴트 볼륨</h2><p>각 PV에는 스펙과 상태(볼륨의 명세와 상태)가 포함된다.
퍼시스턴트볼륨 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0003<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Recycle<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- hard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- nfsvers=4.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nfs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/tmp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.2</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 클러스터 내에서 퍼시스턴트볼륨을 사용하려면 볼륨 유형과 관련된 헬퍼(Helper) 프로그램이 필요할 수 있다. 이 예에서 퍼시스턴트볼륨은 NFS 유형이며 NFS 파일시스템 마운트를 지원하려면 헬퍼 프로그램인 /sbin/mount.nfs가 필요하다.</div><h3 id=용량>용량</h3><p>일반적으로 PV는 특정 저장 용량을 가진다. 이것은 PV의 <code>capacity</code> 속성을 사용하여 설정된다. <code>capacity</code>가 사용하는 단위를 이해하려면 용어집에 있는 <a href="/ko/docs/reference/glossary/?all=true#term-quantity">수량</a> 항목을 참고한다.</p><p>현재 스토리지 용량 크기는 설정하거나 요청할 수 있는 유일한 리소스이다. 향후 속성에 IOPS, 처리량 등이 포함될 수 있다.</p><h3 id=볼륨-모드>볼륨 모드</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [stable]</code></div><p>쿠버네티스는 퍼시스턴트볼륨의 두 가지 <code>volumeModes</code>인 <code>Filesystem</code>과 <code>Block</code>을 지원한다.</p><p><code>volumeMode</code>는 선택적 API 파라미터이다.
<code>Filesystem</code>은 <code>volumeMode</code> 파라미터가 생략될 때 사용되는 기본 모드이다.</p><p><code>volumeMode: Filesystem</code>이 있는 볼륨은 파드의 디렉터리에 <em>마운트</em> 된다. 볼륨이 장치에
의해 지원되고 그 장치가 비어 있으면 쿠버네티스는 장치를
처음 마운트하기 전에 장치에 파일시스템을 만든다.</p><p>볼륨을 원시 블록 장치로 사용하려면 <code>volumeMode</code>의 값을 <code>Block</code>으로 설정할 수 있다.
이러한 볼륨은 파일시스템이 없는 블록 장치로 파드에 제공된다.
이 모드는 파드와 볼륨 사이에 파일시스템 계층 없이도 볼륨에 액세스하는
가장 빠른 방법을 파드에 제공하는 데 유용하다. 반면에 파드에서 실행되는 애플리케이션은
원시 블록 장치를 처리하는 방법을 알아야 한다.
파드에서 <code>volumeMode: Block</code>으로 볼륨을 사용하는 방법에 대한 예는
<a href=#%EC%9B%90%EC%8B%9C-%EB%B8%94%EB%A1%9D-%EB%B3%BC%EB%A5%A8-%EC%A7%80%EC%9B%90>원시 블록 볼륨 지원</a>를 참조하십시오.</p><h3 id=접근-모드>접근 모드</h3><p>리소스 제공자가 지원하는 방식으로 호스트에 퍼시스턴트볼륨을 마운트할 수 있다. 아래 표에서 볼 수 있듯이 제공자들은 서로 다른 기능을 가지며 각 PV의 접근 모드는 해당 볼륨에서 지원하는 특정 모드로 설정된다. 예를 들어 NFS는 다중 읽기/쓰기 클라이언트를 지원할 수 있지만 특정 NFS PV는 서버에서 읽기 전용으로 export할 수 있다. 각 PV는 특정 PV의 기능을 설명하는 자체 접근 모드 셋을 갖는다.</p><p>접근 모드는 다음과 같다.</p><dl><dt><code>ReadWriteOnce</code></dt><dd>하나의 노드에서 해당 볼륨이 읽기-쓰기로 마운트 될 수 있다. ReadWriteOnce 접근 모드에서도 파드가 동일 노드에서 구동되는 경우에는 복수의 파드에서 볼륨에 접근할 수 있다.</dd><dt><code>ReadOnlyMany</code></dt><dd>볼륨이 다수의 노드에서 읽기 전용으로 마운트 될 수 있다.</dd><dt><code>ReadWriteMany</code></dt><dd>볼륨이 다수의 노드에서 읽기-쓰기로 마운트 될 수 있다.</dd><dt><code>ReadWriteOncePod</code></dt><dd>볼륨이 단일 파드에서 읽기-쓰기로 마운트될 수 있다. 전체 클러스터에서 단 하나의 파드만 해당 PVC를 읽거나 쓸 수 있어야하는 경우 ReadWriteOncePod 접근 모드를 사용한다. 이 기능은 CSI 볼륨과 쿠버네티스 버전 1.22+ 에서만 지원된다.</dd></dl><p><a href=/blog/2021/09/13/read-write-once-pod-access-mode-alpha/>퍼시스턴트 볼륨에 대한 단일 파드 접근 모드 소개</a> 블로그 기사에서 이에 대해 보다 자세한 내용을 다룬다.</p><p>CLI에서 접근 모드는 다음과 같이 약어로 표시된다.</p><ul><li>RWO - ReadWriteOnce</li><li>ROX - ReadOnlyMany</li><li>RWX - ReadWriteMany</li><li>RWOP - ReadWriteOncePod</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 쿠버네티스는 볼륨 접근 모드를 이용해 퍼시스턴트볼륨클레임과 퍼시스턴트볼륨을 연결한다.
경우에 따라 볼륨 접근 모드는 퍼시스턴트볼륨을 탑재할 수 있는 위치도 제한한다.
볼륨 접근 모드는 스토리지를 마운트 한 후에는 쓰기 보호를 적용하지 않는다.
접근 모드가 ReadWriteOnce, ReadOnlyMany 혹은 ReadWriteMany로 지정된 경우에도 접근 모드는 볼륨에 제약 조건을 설정하지 않는다.
예를 들어 퍼시스턴트볼륨이 ReadOnlyMany로 생성되었다 하더라도, 해당 퍼시스턴트 볼륨이 읽기 전용이라는 것을 보장하지 않는다.
만약 접근 모드가 ReadWriteOncePod로 지정된 경우, 볼륨에 제한이 설정되어 단일 파드에만 마운트 할 수 있게 된다.</div><blockquote><p><strong>중요!</strong> 볼륨이 여러 접근 모드를 지원하더라도 한 번에 하나의 접근 모드를 사용하여 마운트할 수 있다. 예를 들어 GCEPersistentDisk는 하나의 노드가 ReadWriteOnce로 마운트하거나 여러 노드가 ReadOnlyMany로 마운트할 수 있지만 동시에는 불가능하다.</p></blockquote><table><thead><tr><th style=text-align:left>Volume Plugin</th><th style=text-align:center>ReadWriteOnce</th><th style=text-align:center>ReadOnlyMany</th><th style=text-align:center>ReadWriteMany</th><th>ReadWriteOncePod</th></tr></thead><tbody><tr><td style=text-align:left>AWSElasticBlockStore</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>AzureFile</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td>-</td></tr><tr><td style=text-align:left>AzureDisk</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>CephFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td>-</td></tr><tr><td style=text-align:left>Cinder</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>(<a href=https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/cinder-csi-plugin/features.md#multi-attach-volumes>다중 부착(multi-attached)이 가능한 볼륨이라면</a>)</td><td>-</td></tr><tr><td style=text-align:left>CSI</td><td style=text-align:center>드라이버에 의존</td><td style=text-align:center>드라이버에 의존</td><td style=text-align:center>드라이버에 의존</td><td>드라이버에 의존</td></tr><tr><td style=text-align:left>FC</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>FlexVolume</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>드라이버에 의존</td><td>-</td></tr><tr><td style=text-align:left>GCEPersistentDisk</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>Glusterfs</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td>-</td></tr><tr><td style=text-align:left>HostPath</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>iSCSI</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>NFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td>-</td></tr><tr><td style=text-align:left>RBD</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>VsphereVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>- (파드를 배치할(collocated) 때 동작한다)</td><td>-</td></tr><tr><td style=text-align:left>PortworxVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>✓</td><td>-</td></tr></tbody></table><h3 id=클래스>클래스</h3><p>PV는 <code>storageClassName</code> 속성을
<a href=/ko/docs/concepts/storage/storage-classes/>스토리지클래스</a>의
이름으로 설정하여 지정하는 클래스를 가질 수 있다.
특정 클래스의 PV는 해당 클래스를 요청하는 PVC에만 바인딩될 수 있다.
<code>storageClassName</code>이 없는 PV에는 클래스가 없으며 특정 클래스를 요청하지 않는 PVC에만
바인딩할 수 있다.</p><p>이전에는 <code>volume.beta.kubernetes.io/storage-class</code> 어노테이션이
<code>storageClassName</code> 속성 대신 사용되었다. 이 어노테이션은 아직까지는 사용할 수 있지만,
향후 쿠버네티스 릴리스에서 완전히 사용 중단(deprecated)이 될 예정이다.</p><h3 id=반환-정책>반환 정책</h3><p>현재 반환 정책은 다음과 같다.</p><ul><li>Retain(보존) -- 수동 반환</li><li>Recycle(재활용) -- 기본 스크럽 (<code>rm -rf /thevolume/*</code>)</li><li>Delete(삭제) -- AWS EBS, GCE PD, Azure Disk 또는 OpenStack Cinder 볼륨과 같은 관련 스토리지 자산이 삭제됨</li></ul><p>현재 NFS 및 HostPath만 재활용을 지원한다. AWS EBS, GCE PD, Azure Disk 및 Cinder 볼륨은 삭제를 지원한다.</p><h3 id=마운트-옵션>마운트 옵션</h3><p>쿠버네티스 관리자는 퍼시스턴트 볼륨이 노드에 마운트될 때 추가 마운트 옵션을 지정할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 모든 퍼시스턴트 볼륨 유형이 마운트 옵션을 지원하는 것은 아니다.</div><p>다음 볼륨 유형은 마운트 옵션을 지원한다.</p><ul><li><code>awsElasticBlockStore</code></li><li><code>azureDisk</code></li><li><code>azureFile</code></li><li><code>cephfs</code></li><li><code>cinder</code> (v1.18에서 <strong>사용 중단됨</strong>)</li><li><code>gcePersistentDisk</code></li><li><code>glusterfs</code></li><li><code>iscsi</code></li><li><code>nfs</code></li><li><code>rbd</code></li><li><code>vsphereVolume</code></li></ul><p>마운트 옵션의 유효성이 검사되지 않는다. 마운트 옵션이 유효하지 않으면, 마운트가 실패한다.</p><p>이전에는 <code>mountOptions</code> 속성 대신 <code>volume.beta.kubernetes.io/mount-options</code> 어노테이션이
사용되었다. 이 어노테이션은 아직까지는 사용할 수 있지만,
향후 쿠버네티스 릴리스에서 완전히 사용 중단(deprecated)이 될 예정이다.</p><h3 id=노드-어피니티-affinity>노드 어피니티(affinity)</h3><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 대부분의 볼륨 유형의 경우 이 필드를 설정할 필요가 없다. <a href=/ko/docs/concepts/storage/volumes/#awselasticblockstore>AWS EBS</a>, <a href=/ko/docs/concepts/storage/volumes/#gcepersistentdisk>GCE PD</a> 및 <a href=/ko/docs/concepts/storage/volumes/#azuredisk>Azure Disk</a> 볼륨 블록 유형에 자동으로 채워진다. <a href=/ko/docs/concepts/storage/volumes/#local>로컬</a> 볼륨에 대해서는 이를 명시적으로 설정해야 한다.</div><p>PV는 <a href=/docs/reference/generated/kubernetes-api/v1.25/#volumenodeaffinity-v1-core>노드 어피니티</a>를 지정하여 이 볼륨에 접근할 수 있는 노드를 제한하는 제약 조건을 정의할 수 있다. PV를 사용하는 파드는 노드 어피니티에 의해 선택된 노드로만 스케줄링된다. 노드 어피니티를 명기하기 위해서는, PV의 <code>.spec</code>에 <code>nodeAffinity</code>를 설정한다. <a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/#PersistentVolumeSpec>퍼시스턴트볼륨</a> API 레퍼런스에 해당 필드에 대해 보다 자세한 내용이 있다.</p><h3 id=단계-phase>단계(Phase)</h3><p>볼륨은 다음 단계 중 하나이다.</p><ul><li>Available(사용 가능) -– 아직 클레임에 바인딩되지 않은 사용할 수 있는 리소스</li><li>Bound(바인딩) –- 볼륨이 클레임에 바인딩됨</li><li>Released(릴리스) –- 클레임이 삭제되었지만 클러스터에서 아직 리소스를 반환하지 않음</li><li>Failed(실패) –- 볼륨이 자동 반환에 실패함</li></ul><p>CLI는 PV에 바인딩된 PVC의 이름을 표시한다.</p><h2 id=퍼시스턴트볼륨클레임>퍼시스턴트볼륨클레임</h2><p>각 PVC에는 스펙과 상태(클레임의 명세와 상태)가 포함된다.
퍼시스턴트볼륨클레임 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>8Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>release</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: environment, operator: In, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=접근-모드-1>접근 모드</h3><p>클레임은 특정 접근 모드로 저장소를 요청할 때 <a href=#%EC%A0%91%EA%B7%BC-%EB%AA%A8%EB%93%9C>볼륨과 동일한 규칙</a>을 사용한다.</p><h3 id=볼륨-모드-1>볼륨 모드</h3><p>클레임은 <a href=#%EB%B3%BC%EB%A5%A8-%EB%AA%A8%EB%93%9C>볼륨과 동일한 규칙</a>을 사용하여 파일시스템 또는 블록 장치로 볼륨을 사용함을 나타낸다.</p><h3 id=리소스>리소스</h3><p>파드처럼 클레임은 특정 수량의 리소스를 요청할 수 있다. 이 경우는 스토리지에 대한 요청이다. 동일한 <a href=https://git.k8s.io/design-proposals-archive/scheduling/resources.md>리소스 모델</a>이 볼륨과 클레임 모두에 적용된다.</p><h3 id=셀렉터>셀렉터</h3><p>클레임은 볼륨 셋을 추가로 필터링하기 위해 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%85%80%EB%A0%89%ED%84%B0>레이블 셀렉터</a>를 지정할 수 있다. 레이블이 셀렉터와 일치하는 볼륨만 클레임에 바인딩할 수 있다. 셀렉터는 두 개의 필드로 구성될 수 있다.</p><ul><li><code>matchLabels</code> - 볼륨에 이 값의 레이블이 있어야함</li><li><code>matchExpressions</code> - 키, 값의 목록, 그리고 키와 값에 관련된 연산자를 지정하여 만든 요구 사항 목록. 유효한 연산자에는 In, NotIn, Exists 및 DoesNotExist가 있다.</li></ul><p><code>matchLabels</code> 및 <code>matchExpressions</code>의 모든 요구 사항이 AND 조건이다. 일치하려면 모두 충족해야 한다.</p><h3 id=클래스-1>클래스</h3><p>클레임은 <code>storageClassName</code> 속성을 사용하여
<a href=/ko/docs/concepts/storage/storage-classes/>스토리지클래스</a>의 이름을 지정하여
특정 클래스를 요청할 수 있다.
요청된 클래스의 PV(PVC와 동일한 <code>storageClassName</code>을 갖는 PV)만 PVC에
바인딩될 수 있다.</p><p>PVC는 반드시 클래스를 요청할 필요는 없다. <code>storageClassName</code>이 <code>""</code>로 설정된
PVC는 항상 클래스가 없는 PV를 요청하는 것으로 해석되므로
클래스가 없는 PV(어노테이션이 없거나 <code>""</code>와 같은 하나의 셋)에만 바인딩될 수
있다. <code>storageClassName</code>이 없는 PVC는
<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code> 어드미션 플러그인</a>이
켜져 있는지 여부에 따라 동일하지 않으며
클러스터에 따라 다르게 처리된다.</p><ul><li>어드미션 플러그인이 켜져 있으면 관리자가 기본 스토리지클래스를 지정할 수 있다.
<code>storageClassName</code>이 없는 모든 PVC는 해당 기본값의 PV에만 바인딩할 수 있다. 기본
스토리지클래스 지정은 스토리지클래스 오브젝트에서 어노테이션
<code>storageclass.kubernetes.io/is-default-class</code>를 <code>true</code>로
설정하여 수행된다. 관리자가 기본값을 지정하지 않으면 어드미션 플러그인이 꺼져 있는 것처럼
클러스터가 PVC 생성에 응답한다. 둘 이상의 기본값이 지정된 경우 어드미션
플러그인은 모든 PVC 생성을
금지한다.</li><li>어드미션 플러그인이 꺼져 있으면 기본 스토리지클래스에 대한 기본값 자체가 없다.
<code>storageClassName</code>이 <code>""</code>으로 설정된 모든 PVC는
<code>storageClassName</code>이 마찬가지로 <code>""</code>로 설정된 PV에만 바인딩할 수 있다.
하지만, <code>storageClassName</code>이 없는 PVC는
기본 스토리지클래스가 사용 가능해지면 갱신될 수 있다. PVC가 갱신되면
해당 PVC는 더 이상 <code>storageClassName</code>이 <code>""</code>로 설정된 PV와 바인딩되어있지 않게 된다.</li></ul><p>더 자세한 정보는 <a href=#retroactive-default-storageclass-assignment>retroactive default StorageClass assignment</a>를 참조한다.</p><p>설치 방법에 따라 설치 중에 애드온 관리자가 기본 스토리지클래스를 쿠버네티스 클러스터에
배포할 수 있다.</p><p>PVC가 스토리지클래스를 요청하는 것 외에도 <code>selector</code>를 지정하면 요구 사항들이
AND 조건으로 동작한다. 요청된 클래스와 요청된 레이블이 있는 PV만 PVC에
바인딩될 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 현재 비어 있지 않은 <code>selector</code>가 있는 PVC에는 PV를 동적으로 프로비저닝할 수 없다.</div><p>이전에는 <code>volume.beta.kubernetes.io/storage-class</code> 어노테이션이 <code>storageClassName</code>
속성 대신 사용되었다. 이 어노테이션은 아직까지는 사용할 수 있지만,
향후 쿠버네티스 릴리스에서는 지원되지 않는다.</p><h4 id=retroactive-default-storageclass-assignment>기본 스토리지클래스 할당 소급 적용하기</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [alpha]</code></div><p>새로운 PVC를 위한 <code>storageClassName</code>을 설정하지 않고 퍼시스턴트볼륨클레임을 생성할 수 있으며, 이는 클러스터에 기본 스토리지클래스가 존재하지 않을 때에도 가능하다. 이 경우, 새로운 PVC는 정의된 대로 생성되며, 해당 PVC의 <code>storageClassName</code>은 기본값이 사용 가능해질 때까지 미설정 상태로 남는다.
하지만, <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/><code>RetroactiveDefaultStorageClass</code> 기능 게이트</a>를 활성화하면 쿠버네티스는 다르게 동작하여, 기존에 존재하는 PVC 중 <code>storageClassName</code>가 설정되지 않은 PVC는 새로운 기본 스토리지클래스를 사용하도록 갱신된다.</p><p>기본 스토리지클래스가 사용 가능해지면, 컨트롤플레인은 <code>storageClassName</code>가 없는 PVC를 찾는다. <code>storageClassName</code>의 값이 비어있거나 해당 키 자체가 없는 PVC라면, 컨트롤플레인은 해당 PVC의 <code>storageClassName</code>가 새로운 기본 스토리지클래스와 일치하도록 설정하여 갱신한다. <code>storageClassName</code>가 <code>""</code>인 PVC가 있고, 기본 스토리지클래스를 설정한다면, 해당 PVC는 갱신되지 않는다.</p><p>기본 스토리지클래스가 존재할 때 <code>storageClassName</code>가 <code>""</code>로 설정된 PV와의 바인딩을 유지하고싶다면, 연결된 PVC의 <code>storageClassName</code>를 <code>""</code>로 설정해야 한다.</p><p>이 행동은 관리자가 오래된 기본 스토리지클래스를 삭제하고 새로운 기본 스토리지클래스를 생성하거나 설정하여 기본 스토리지클래스를 변경하는 데 도움이 된다. 기본값이 설정되어있지 않을 때의 이 작은 틈새로 인해 이 때 생성된 <code>storageClassName</code>가 없는 PVC는 아무런 기본값도 없이 생성될 수 있지만, 기본 스토리지클래스 할당 소급 적용에 의해 이러한 방식으로 기본값을 변경하는 것은 안전하다.</p><h2 id=볼륨으로-클레임하기>볼륨으로 클레임하기</h2><p>클레임을 볼륨으로 사용해서 파드가 스토리지에 접근한다. 클레임은 클레임을 사용하는 파드와 동일한 네임스페이스에 있어야 한다. 클러스터는 파드의 네임스페이스에서 클레임을 찾고 이를 사용하여 클레임과 관련된 퍼시스턴트볼륨을 얻는다. 그런 다음 볼륨이 호스트와 파드에 마운트된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=네임스페이스에-대한-참고-사항>네임스페이스에 대한 참고 사항</h3><p>퍼시스턴트볼륨 바인딩은 배타적이며, 퍼시스턴트볼륨클레임은 네임스페이스 오브젝트이므로 "다중" 모드(<code>ROX</code>, <code>RWX</code>)를 사용한 클레임은 하나의 네임스페이스 내에서만 가능하다.</p><h3 id=hostpath-유형의-퍼시스턴트볼륨><code>hostPath</code> 유형의 퍼시스턴트볼륨</h3><p><code>hostPath</code> 퍼시스턴트볼륨은 노드의 파일이나 디렉터리를 사용하여 네트워크 연결 스토리지를 에뮬레이션한다.
<a href=/ko/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0><code>hostPath</code> 유형 볼륨의 예</a>를 참고한다.</p><h2 id=원시-블록-볼륨-지원>원시 블록 볼륨 지원</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [stable]</code></div><p>다음 볼륨 플러그인에 해당되는 경우 동적 프로비저닝을 포함하여 원시 블록 볼륨을
지원한다.</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>CSI</li><li>FC (파이버 채널)</li><li>GCEPersistentDisk</li><li>iSCSI</li><li>Local volume</li><li>OpenStack Cinder</li><li>RBD (Ceph Block Device)</li><li>VsphereVolume</li></ul><h3 id=persistent-volume-using-a-raw-block-volume>원시 블록 볼륨을 사용하는 퍼시스턴트볼륨</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fc</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetWWNs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;50060e801049cfd1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lun</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=persistent-volume-claim-requesting-a-raw-block-volume>원시 블록 볼륨을 요청하는 퍼시스턴트볼륨클레임</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=컨테이너에-원시-블록-장치-경로를-추가하는-파드-명세>컨테이너에 원시 블록 장치 경로를 추가하는 파드 명세</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-block-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fc-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:26<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;tail -f /dev/null&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeDevices</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>devicePath</span>:<span style=color:#bbb> </span>/dev/xvda<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드에 대한 원시 블록 장치를 추가할 때 마운트 경로 대신 컨테이너에 장치 경로를 지정한다.</div><h3 id=블록-볼륨-바인딩>블록 볼륨 바인딩</h3><p>사용자가 퍼시스턴트볼륨클레임 스펙에서 <code>volumeMode</code> 필드를 사용하여 이를 나타내는 원시 블록 볼륨을 요청하는 경우 바인딩 규칙은 스펙의 일부분으로 이 모드를 고려하지 않은 이전 릴리스에 비해 약간 다르다.
사용자와 관리자가 원시 블록 장치를 요청하기 위해 지정할 수 있는 가능한 조합의 표가 아래 나열되어 있다. 이 테이블은 볼륨이 바인딩되는지 여부를 나타낸다.
정적 프로비저닝된 볼륨에 대한 볼륨 바인딩 매트릭스이다.</p><table><thead><tr><th>PV volumeMode</th><th style=text-align:center>PVC volumeMode</th><th style=text-align:right>Result</th></tr></thead><tbody><tr><td>지정되지 않음</td><td style=text-align:center>지정되지 않음</td><td style=text-align:right>BIND</td></tr><tr><td>지정되지 않음</td><td style=text-align:center>Block</td><td style=text-align:right>NO BIND</td></tr><tr><td>지정되지 않음</td><td style=text-align:center>Filesystem</td><td style=text-align:right>BIND</td></tr><tr><td>Block</td><td style=text-align:center>지정되지 않음</td><td style=text-align:right>NO BIND</td></tr><tr><td>Block</td><td style=text-align:center>Block</td><td style=text-align:right>BIND</td></tr><tr><td>Block</td><td style=text-align:center>Filesystem</td><td style=text-align:right>NO BIND</td></tr><tr><td>Filesystem</td><td style=text-align:center>Filesystem</td><td style=text-align:right>BIND</td></tr><tr><td>Filesystem</td><td style=text-align:center>Block</td><td style=text-align:right>NO BIND</td></tr><tr><td>Filesystem</td><td style=text-align:center>지정되지 않음</td><td style=text-align:right>BIND</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 알파 릴리스에서는 정적으로 프로비저닝된 볼륨만 지원된다. 관리자는 원시 블록 장치로 작업할 때 이러한 값을 고려해야 한다.</div><h2 id=볼륨-스냅샷-및-스냅샷-지원에서-볼륨-복원>볼륨 스냅샷 및 스냅샷 지원에서 볼륨 복원</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.20 [stable]</code></div><p>볼륨 스냅 샷은 아웃-오브-트리 CSI 볼륨 플러그인만 지원한다. 자세한 내용은 <a href=/ko/docs/concepts/storage/volume-snapshots/>볼륨 스냅샷</a>을 참조한다.
인-트리 볼륨 플러그인은 사용 중단 되었다. <a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>볼륨 플러그인 FAQ</a>에서 사용 중단된 볼륨 플러그인에 대해 확인할 수 있다.</p><h3 id=create-persistent-volume-claim-from-volume-snapshot>볼륨 스냅샷에서 퍼시스턴트볼륨클레임 생성</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restore-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>csi-hostpath-sc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=볼륨-복제>볼륨 복제</h2><p><a href=/ko/docs/concepts/storage/volume-pvc-datasource/>볼륨 복제</a>는 CSI 볼륨 플러그인만 사용할 수 있다.</p><h3 id=create-persistent-volume-claim-from-an-existing-pvc>기존 pvc에서 퍼시스턴트볼륨클레임 생성</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloned-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>my-csi-plugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>existing-src-pvc-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=볼륨-파퓰레이터-volume-populator-와-데이터-소스>볼륨 파퓰레이터(Volume populator)와 데이터 소스</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [beta]</code></div><p>쿠버네티스는 커스텀 볼륨 파퓰레이터를 지원한다.
커스텀 볼륨 파퓰레이터를 사용하려면,
kube-apiserver와 kube-controller-manager에 대해 <code>AnyVolumeDataSource</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.</p><p>볼륨 파퓰레이터는 <code>dataSourceRef</code>라는 PVC 스펙 필드를 활용한다.
다른 PersistentVolumeClaim 또는 VolumeSnapshot을 가리키는 참조만 명시할 수 있는
<code>dataSource</code> 필드와는 다르게, <code>dataSourceRef</code> 필드는 동일 네임스페이스에 있는
어떠한 오브젝트에 대한 참조도 명시할 수 있다(단, PVC 외의 다른 코어 오브젝트는 제외).
기능 게이트가 활성화된 클러스터에서는 <code>dataSource</code>보다 <code>dataSourceRef</code>를 사용하는 것을 권장한다.</p><h2 id=데이터-소스-참조>데이터 소스 참조</h2><p><code>dataSourceRef</code> 필드는 <code>dataSource</code> 필드와 거의 동일하게 동작한다.
둘 중 하나만 명시되어 있으면, API 서버는 두 필드에 같은 값을 할당할 것이다.
두 필드 모두 생성 이후에는 변경될 수 없으며,
두 필드에 다른 값을 넣으려고 시도하면 검증 에러가 발생할 것이다.
따라서 두 필드는 항상 같은 값을 갖게 된다.</p><p><code>dataSourceRef</code> 필드와 <code>dataSource</code> 필드 사이에는
사용자가 알고 있어야 할 두 가지 차이점이 있다.</p><ul><li><code>dataSource</code> 필드는 유효하지 않은 값(예를 들면, 빈 값)을 무시하지만,
<code>dataSourceRef</code> 필드는 어떠한 값도 무시하지 않으며 유효하지 않은 값이 들어오면 에러를 발생할 것이다.
유효하지 않은 값은 PVC를 제외한 모든 코어 오브젝트(apiGroup이 없는 오브젝트)이다.</li><li><code>dataSourceRef</code> 필드는 여러 타입의 오브젝트를 포함할 수 있지만, <code>dataSource</code> 필드는
PVC와 VolumeSnapshot만 포함할 수 있다.</li></ul><p>기능 게이트가 활성화된 클러스터에서는 <code>dataSourceRef</code>를 사용해야 하고, 그렇지 않은
클러스터에서는 <code>dataSource</code>를 사용해야 한다. 어떤 경우에서든 두 필드 모두를 확인해야
할 필요는 없다. 이렇게 약간의 차이만 있는 중복된 값은 이전 버전 호환성을 위해서만
존재하는 것이다. 상세히 설명하면, 이전 버전과 새로운 버전의 컨트롤러가 함께 동작할
수 있는데, 이는 두 필드가 동일하기 때문이다.</p><h3 id=볼륨-파퓰레이터-사용하기>볼륨 파퓰레이터 사용하기</h3><p>볼륨 파퓰레이터는 비어 있지 않은 볼륨(non-empty volume)을 생성할 수 있는 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>이며,
이 볼륨의 내용물은 커스텀 리소스(Custom Resource)에 의해 결정된다.
파퓰레이티드 볼륨(populated volume)을 생성하려면 <code>dataSourceRef</code> 필드에 커스텀 리소스를 기재한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>populated-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSourceRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ExampleDataSource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>example.storage.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>볼륨 파퓰레이터는 외부 컴포넌트이기 때문에,
만약 적합한 컴포넌트가 설치되어 있지 않다면 볼륨 파퓰레이터를 사용하는 PVC에 대한 생성 요청이 실패할 수 있다.
외부 컨트롤러는 '컴포넌트가 없어서 PVC를 생성할 수 없음' 경고와 같은
PVC 생성 상태에 대한 피드백을 제공하기 위해, PVC에 대한 이벤트를 생성해야 한다.</p><p>알파 버전의 <a href=https://github.com/kubernetes-csi/volume-data-source-validator>볼륨 데이터 소스 검증기</a>를
클러스터에 설치할 수 있다.
해당 데이터 소스를 다루는 파퓰레이터가 등록되어 있지 않다면 이 컨트롤러가 PVC에 경고 이벤트를 생성한다.
PVC를 위한 적절한 파퓰레이터가 설치되어 있다면,
볼륨 생성과 그 과정에서 발생하는 이슈에 대한 이벤트를 생성하는 것은 파퓰레이터 컨트롤러의 몫이다.</p><h2 id=포터블-구성-작성>포터블 구성 작성</h2><p>광범위한 클러스터에서 실행되고 퍼시스턴트 스토리지가 필요한
구성 템플릿 또는 예제를 작성하는 경우 다음 패턴을 사용하는 것이 좋다.</p><ul><li>구성 번들(디플로이먼트, 컨피그맵 등)에 퍼시스턴트볼륨클레임
오브젝트를 포함시킨다.</li><li>구성을 인스턴스화 하는 사용자에게 퍼시스턴트볼륨을 생성할 권한이 없을 수 있으므로
퍼시스턴트볼륨 오브젝트를 구성에 포함하지 않는다.</li><li>템플릿을 인스턴스화 할 때 스토리지 클래스 이름을 제공하는 옵션을
사용자에게 제공한다.<ul><li>사용자가 스토리지 클래스 이름을 제공하는 경우 해당 값을
<code>permanentVolumeClaim.storageClassName</code> 필드에 입력한다.
클러스터에서 관리자가 스토리지클래스를 활성화한 경우
PVC가 올바른 스토리지 클래스와 일치하게 된다.</li><li>사용자가 스토리지 클래스 이름을 제공하지 않으면
<code>permanentVolumeClaim.storageClassName</code> 필드를 nil로 남겨둔다.
그러면 클러스터에 기본 스토리지클래스가 있는 사용자에 대해 PV가 자동으로 프로비저닝된다.
많은 클러스터 환경에 기본 스토리지클래스가 설치되어 있거나 관리자가
고유한 기본 스토리지클래스를 생성할 수 있다.</li></ul></li><li>도구(tooling)에서 일정 시간이 지나도 바인딩되지 않는 PVC를 관찰하여 사용자에게
노출시킨다. 이는 클러스터가 동적 스토리지를 지원하지
않거나(이 경우 사용자가 일치하는 PV를 생성해야 함),
클러스터에 스토리지 시스템이 없음을 나타낸다(이 경우
사용자는 PVC가 필요한 구성을 배포할 수 없음).</li></ul><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0>퍼시스턴트볼륨 생성</a>에 대해 자세히 알아보기</li><li><a href=/ko/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8%ED%81%B4%EB%A0%88%EC%9E%84-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0>퍼시스턴트볼륨클레임 생성</a>에 대해 자세히 알아보기</li><li><a href=https://git.k8s.io/design-proposals-archive/storage/persistent-storage.md>퍼시스턴트 스토리지 설계 문서</a> 읽어보기</li></ul><h3 id=reference>API 레퍼런스</h3><p>본 페이지에 기술된 API에 대해서 다음을 읽어본다.</p><ul><li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/><code>PersistentVolume</code></a></li><li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/><code>PersistentVolumeClaim</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2db414b26d4daec3ebed19dd837830c3>3 - 프로젝티드 볼륨</h1><p>이 페이지에서는 쿠버네티스의 <em>프로젝티드 볼륨(projected volume)</em> 에 대해 설명한다. <a href=/ko/docs/concepts/storage/volumes/>볼륨</a>에 대해 익숙해지는 것을 추천한다.</p><h2 id=들어가며>들어가며</h2><p><code>프로젝티드 볼륨</code>은 여러 기존 볼륨 소스(sources)를 동일한 디렉토리에 매핑한다.</p><p>현재, 아래와 같은 볼륨 유형 소스를 프로젝트(project)할 수 있다.</p><ul><li><a href=/ko/docs/concepts/storage/volumes/#secret><code>시크릿(secret)</code></a></li><li><a href=/ko/docs/concepts/storage/volumes/#downwardapi><code>downwardAPI</code></a></li><li><a href=/ko/docs/concepts/storage/volumes/#configmap><code>컨피그맵(configMap)</code></a></li><li><a href=#serviceaccounttoken><code>서비스어카운트토큰(serviceAccountToken)</code></a></li></ul><p>모든 소스는 파드와 같은 네임스페이스에 있어야 한다.
자세한 내용은 <a href=https://git.k8s.io/design-proposals-archive/node/all-in-one-volume.md>올인원(all-in-one) 볼륨</a> 문서를 참고한다.</p><h3 id=example-configuration-secret-downwardapi-configmap>시크릿, downwardAPI, 컨피그맵 구성 예시</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/storage/projected-secret-downwardapi-configmap.yaml download=pods/storage/projected-secret-downwardapi-configmap.yaml><code>pods/storage/projected-secret-downwardapi-configmap.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-secret-downwardapi-configmap-yaml")' title="Copy pods/storage/projected-secret-downwardapi-configmap.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-secret-downwardapi-configmap-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;labels&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.labels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cpu_limit&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-config<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=example-configuration-secrets-nondefault-permission-mode>기본 권한이 아닌 모드 설정의 시크릿 구성 예시</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/storage/projected-secrets-nondefault-permission-mode.yaml download=pods/storage/projected-secrets-nondefault-permission-mode.yaml><code>pods/storage/projected-secrets-nondefault-permission-mode.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-secrets-nondefault-permission-mode-yaml")' title="Copy pods/storage/projected-secrets-nondefault-permission-mode.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-secrets-nondefault-permission-mode-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>511</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>각 프로젝티드 볼륨 소스는 <code>sources</code> 아래의 스펙에 나열된다.
파라미터는 두 가지 예외를 제외하고 동일하다.</p><ul><li>시크릿의 경우 컨피그맵 명명법과 동일하도록
<code>secretName</code> 필드가 <code>name</code>으로 변경되었다.</li><li><code>defaultMode</code>의 경우 볼륨 소스별 각각 명시할 수 없고
프로젝티드 수준에서만 명시할 수 있다. 그러나 위의 그림처럼 각 개별 프로젝션에 대해
<code>mode</code>를 명시적으로 지정할 수 있다.</li></ul><h2 id=serviceaccounttoken>서비스어카운트토큰 프로젝티드 볼륨</h2><p><code>TokenRequestProjection</code> 기능이 활성화 된 경우
파드의 지정된 경로에 <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>서비스어카운트토큰</a>을
주입할 수 있다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/storage/projected-service-account-token.yaml download=pods/storage/projected-service-account-token.yaml><code>pods/storage/projected-service-account-token.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-service-account-token-yaml")' title="Copy pods/storage/projected-service-account-token.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-service-account-token-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sa-token-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/service-account&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>api<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>위 예시에는 파드에 주입된 서비스어카운트토큰이 포함된 프로젝티드 볼륨이 있다.
이 파드의 컨테이너는 서비스어카운트토큰을 사용하여 쿠버네티스 API 서버에 접근하고,
파드의 <a href=/docs/tasks/configure-pod-container/configure-service-account/>서비스어카운트</a>로 인증할 수 있다.
<code>audience</code> 필드는 토큰의 의도된 대상을 포함한다.
토큰 수신자는 토큰의 대상으로 지정된 식별자로 자신을 식별해야 하며,
그렇지 않으면 토큰을 거부해야 한다.
이 필드는 선택 사항으로, API 서버의 식별자로 기본 설정된다.</p><p><code>expirationSeconds</code>는 서비스어카운트토큰의 예상 유효 기간이다.
기본값은 1시간이며 최소 10분 (600초) 이상이어야 한다.
관리자는 API 서버 옵션 <code>--service-account-max-token-expiration</code>으로
값을 지정하여 최대값을 제한할 수 있다.
<code>path</code> 필드는 프로젝티드 볼륨의 마운트 지점에 대한 상대 경로를 지정한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <a href=/ko/docs/concepts/storage/volumes/#using-subpath><code>하위 경로</code></a> 볼륨 마운트로 프로젝티드 볼륨 소스를 사용하는 컨테이너는
해당 볼륨 소스에 대한 업데이트를 수신하지 않는다.</div><h2 id=시큐리티컨텍스트-securitycontext-상호작용>시큐리티컨텍스트(SecurityContext) 상호작용</h2><p>프로젝티드 서비스 어카운트 볼륨 내에서의 파일 퍼미션 처리에 대한 개선 <a href=https://git.k8s.io/enhancements/keps/sig-storage/2451-service-account-token-volumes#proposal>제안</a>을 통해, 프로젝티드 파일의 소유자 및 퍼미션이 올바르게 설정되도록 변경되었다.</p><h3 id=리눅스>리눅스</h3><p>프로젝티드 볼륨과 파드
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context><code>보안 컨텍스트</code></a>에
<code>RunAsUser</code>가 설정된 리눅스 파드에서는
프로젝티드파일이 컨테이너 사용자 소유권을 포함한 올바른 소유권 집합을 가진다.</p><h3 id=윈도우>윈도우</h3><p>윈도우 파드에서 프로젝티드 볼륨과 파드 <code>SecurityContext</code>에 <code>RunAsUsername</code>이 설정된 경우,
윈도우에서 사용자 계정을 관리하는 방법으로 인하여 소유권이 적용되지 않는다.
윈도우는 보안 계정 관리자 (Security Account Manager)라는 데이터베이스 파일에
로컬 사용자 및 그룹 계정을 저장하고 관리한다.
컨테이너가 실행되는 동안 각 컨테이너는
호스트가 볼 수 없는 SAM 데이터베이스의 자체 인스턴스를 유지한다.
윈도우 컨테이너는 OS의 사용자 모드 부분을 호스트와 분리하여 실행하도록 설계되어 가상 SAM 데이터베이스를 유지 관리한다.
따라서 호스트에서 실행 중인 kubelet은 가상화된 컨테이너 계정에 대한
호스트 파일 소유권을 동적으로 구성할 수 없다.
호스트 머신의 파일을 컨테이너와 공유하려는 경우
<code>C:\</code> 외부에 있는 자체 볼륨 마운트에 배치하는 것을
권장한다.</p><p>기본적으로, 프로젝티드 파일은 예제의 프로젝티드 볼륨 파일처럼
아래와 같은 소유권을 가진다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>PS </span>C:\&gt; <span style=color:#a2f>Get-Acl</span> C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.<span style=color:#666>318230061</span>\ca.crt | <span style=color:#a2f>Format-List</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Path   <span>:</span> Microsoft.PowerShell.Core\FileSystem::C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.<span style=color:#666>318230061</span>\ca.crt
</span></span><span style=display:flex><span>Owner  <span>:</span> BUILTIN\Administrators
</span></span><span style=display:flex><span><span style=color:#a2f>Group </span> <span>:</span> NT AUTHORITY\SYSTEM
</span></span><span style=display:flex><span>Access <span>:</span> NT AUTHORITY\SYSTEM Allow  FullControl
</span></span><span style=display:flex><span>         BUILTIN\Administrators Allow  FullControl
</span></span><span style=display:flex><span>         BUILTIN\Users Allow  ReadAndExecute, Synchronize
</span></span><span style=display:flex><span>Audit  <span>:</span>
</span></span><span style=display:flex><span>Sddl   <span>:</span> O:BAG<span>:</span>SYD<span>:</span>AI(A;ID;FA;;;SY)(A;ID;FA;;;BA)(A;ID;0x1200a9;;;BU)
</span></span></code></pre></div><p><code>ContainerAdministrator</code>와 같은
모든 관리자인 사용자는 읽기, 쓰기 그리고 실행 권한을 갖게 되지만
관리자가 아닌 사용자는 읽기 및 실행 권한을 갖게 된다는 것을 의미한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>일반적으로 호스트에게 컨테이너 액세스를 승인하는 것은
잠재적인 보안 악용에 대한 문을 열 수 있기 때문에 권장되지 않는다.</p><p>윈도우 파드에서 <code>SecurityContext</code>를 <code>RunAsUser</code>로 생성하면,
파드는 영원히 <code>ContainerCreating</code> 상태에 머물게 된다.
따라서 리눅스 전용 <code>RunAsUser</code> 옵션은 윈도우 파드와 함께 사용하지 않는 것이 좋다.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-f0276d05eef111249272a1c932a91e2c>4 - 스토리지 클래스</h1><p>이 문서는 쿠버네티스의 스토리지클래스의 개념을 설명한다.
<a href=/ko/docs/concepts/storage/volumes/>볼륨</a>과
<a href=/ko/docs/concepts/storage/persistent-volumes>퍼시스턴트 볼륨</a>에 익숙해지는 것을 권장한다.</p><h2 id=소개>소개</h2><p>스토리지클래스는 관리자가 제공하는 스토리지의 "classes"를 설명할 수 있는
방법을 제공한다. 다른 클래스는 서비스의 품질 수준 또는
백업 정책, 클러스터 관리자가 정한 임의의 정책에
매핑될 수 있다. 쿠버네티스 자체는 클래스가 무엇을 나타내는지에
대해 상관하지 않는다. 다른 스토리지 시스템에서는 이 개념을
"프로파일"이라고도 한다.</p><h2 id=스토리지클래스-리소스>스토리지클래스 리소스</h2><p>각 스토리지클래스에는 해당 스토리지클래스에 속하는 퍼시스턴트볼륨을 동적으로 프로비저닝
할 때 사용되는 <code>provisioner</code>, <code>parameters</code> 와
<code>reclaimPolicy</code> 필드가 포함된다.</p><p>스토리지클래스 오브젝트의 이름은 중요하며, 사용자가 특정
클래스를 요청할 수 있는 방법이다. 관리자는 스토리지클래스 오브젝트를
처음 생성할 때 클래스의 이름과 기타 파라미터를 설정하며,
일단 생성된 오브젝트는 업데이트할 수 없다.</p><p>관리자는 특정 클래스에 바인딩을 요청하지 않는 PVC에 대해서만 기본
스토리지클래스를 지정할 수 있다. 자세한 내용은
<a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8%ED%81%B4%EB%A0%88%EC%9E%84>퍼시스턴트볼륨클레임 섹션</a>을
본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/aws-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>gp2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>reclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- debug<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>Immediate<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=프로비저너>프로비저너</h3><p>각 스토리지클래스에는 PV 프로비저닝에 사용되는 볼륨 플러그인을 결정하는
프로비저너가 있다. 이 필드는 반드시 지정해야 한다.</p><table><thead><tr><th style=text-align:left>볼륨 플러그인</th><th style=text-align:center>내부 프로비저너</th><th style=text-align:center>설정 예시</th></tr></thead><tbody><tr><td style=text-align:left>AWSElasticBlockStore</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#aws-ebs>AWS EBS</a></td></tr><tr><td style=text-align:left>AzureFile</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#azure-%ED%8C%8C%EC%9D%BC>Azure 파일</a></td></tr><tr><td style=text-align:left>AzureDisk</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#azure-%EB%94%94%EC%8A%A4%ED%81%AC>Azure 디스크</a></td></tr><tr><td style=text-align:left>CephFS</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Cinder</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#openstack-cinder>OpenStack Cinder</a></td></tr><tr><td style=text-align:left>FC</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>FlexVolume</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>GCEPersistentDisk</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#gce-pd>GCE PD</a></td></tr><tr><td style=text-align:left>Glusterfs</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#glusterfs>Glusterfs</a></td></tr><tr><td style=text-align:left>iSCSI</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>NFS</td><td style=text-align:center>-</td><td style=text-align:center><a href=#nfs>NFS</a></td></tr><tr><td style=text-align:left>RBD</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#ceph-rbd>Ceph RBD</a></td></tr><tr><td style=text-align:left>VsphereVolume</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#vsphere>vSphere</a></td></tr><tr><td style=text-align:left>PortworxVolume</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#portworx-%EB%B3%BC%EB%A5%A8>Portworx 볼륨</a></td></tr><tr><td style=text-align:left>Local</td><td style=text-align:center>-</td><td style=text-align:center><a href=#local>Local</a></td></tr></tbody></table><p>여기 목록에서 "내부" 프로비저너를 지정할 수 있다(이
이름은 "kubernetes.io" 가 접두사로 시작하고, 쿠버네티스와
함께 제공된다). 또한, 쿠버네티스에서 정의한
<a href=https://git.k8s.io/design-proposals-archive/storage/volume-provisioning.md>사양</a>을
따르는 독립적인 프로그램인 외부 프로비저너를 실행하고 지정할 수 있다.
외부 프로비저너의 작성자는 코드의 수명, 프로비저너의
배송 방법, 실행 방법, (Flex를 포함한)볼륨 플러그인
등에 대한 완전한 재량권을 가진다. <a href=https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner>kubernetes-sigs/sig-storage-lib-external-provisioner</a>
리포지터리에는 대량의 사양을 구현하는 외부 프로비저너를 작성하기
위한 라이브러리가 있다. 일부 외부 프로비저너의 목록은
<a href=https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner>kubernetes-sigs/sig-storage-lib-external-provisioner</a> 리포지터리에 있다.</p><p>예를 들어, NFS는 내부 프로비저너를 제공하지 않지만, 외부
프로비저너를 사용할 수 있다. 타사 스토리지 업체가 자체 외부
프로비저너를 제공하는 경우도 있다.</p><h3 id=리클레임-정책>리클레임 정책</h3><p>스토리지클래스에 의해 동적으로 생성된 퍼시스턴트볼륨은 클래스의
<code>reclaimPolicy</code> 필드에 지정된 리클레임 정책을 가지는데,
이는 <code>Delete</code> 또는 <code>Retain</code> 이 될 수 있다. 스토리지클래스 오브젝트가
생성될 때 <code>reclaimPolicy</code> 가 지정되지 않으면 기본값은 <code>Delete</code> 이다.</p><p>수동으로 생성되고 스토리지클래스를 통해 관리되는 퍼시스턴트볼륨에는
생성 시 할당된 리클레임 정책이 있다.</p><h3 id=볼륨-확장-허용>볼륨 확장 허용</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.11 [beta]</code></div><p>퍼시스턴트볼륨은 확장이 가능하도록 구성할 수 있다. 이 기능을 <code>true</code> 로 설정하면
해당 PVC 오브젝트를 편집하여 볼륨 크기를 조정할 수 있다.</p><p>다음 볼륨 유형은 기본 스토리지클래스에서 <code>allowVolumeExpansion</code> 필드가
true로 설정된 경우 볼륨 확장을 지원한다.</p><table><caption style=display:none>Table of Volume types and the version of Kubernetes they require</caption><thead><tr><th style=text-align:left>볼륨 유형</th><th style=text-align:left>요구되는 쿠버네티스 버전</th></tr></thead><tbody><tr><td style=text-align:left>gcePersistentDisk</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>awsElasticBlockStore</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>Cinder</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>glusterfs</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>rbd</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>Azure File</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>Azure Disk</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>Portworx</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>FlexVolume</td><td style=text-align:left>1.13</td></tr><tr><td style=text-align:left>CSI</td><td style=text-align:left>1.14 (alpha), 1.16 (beta)</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 볼륨 확장 기능을 사용해서 볼륨을 확장할 수 있지만, 볼륨을 축소할 수는 없다.</div><h3 id=마운트-옵션>마운트 옵션</h3><p>스토리지클래스에 의해 동적으로 생성된 퍼시스턴트볼륨은
클래스의 <code>mountOptions</code> 필드에 지정된 마운트 옵션을 가진다.</p><p>만약 볼륨 플러그인이 마운트 옵션을 지원하지 않는데, 마운트
옵션을 지정하면 프로비저닝은 실패한다. 마운트 옵션은 클래스 또는 PV에서
검증되지 않는다. PV 마운트가 유효하지 않으면, 마운트가 실패하게 된다.</p><h3 id=볼륨-바인딩-모드>볼륨 바인딩 모드</h3><p><code>volumeBindingMode</code> 필드는 <a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%94%84%EB%A1%9C%EB%B9%84%EC%A0%80%EB%8B%9D>볼륨 바인딩과 동적
프로비저닝</a>의 시작 시기를 제어한다. 설정되어 있지 않으면, <code>Immediate</code> 모드가 기본으로 사용된다.</p><p><code>Immediate</code> 모드는 퍼시스턴트볼륨클레임이 생성되면 볼륨
바인딩과 동적 프로비저닝이 즉시 발생하는 것을 나타낸다. 토폴로지 제약이
있고 클러스터의 모든 노드에서 전역적으로 접근할 수 없는 스토리지
백엔드의 경우, 파드의 스케줄링 요구 사항에 대한 지식 없이 퍼시스턴트볼륨이
바인딩되거나 프로비저닝된다. 이로 인해 스케줄되지 않은 파드가 발생할 수 있다.</p><p>클러스터 관리자는 <code>WaitForFirstConsumer</code> 모드를 지정해서 이 문제를 해결할 수 있는데
이 모드는 퍼시스턴트볼륨클레임을 사용하는 파드가 생성될 때까지 퍼시스턴트볼륨의 바인딩과 프로비저닝을 지연시킨다.
퍼시스턴트볼륨은 파드의 스케줄링 제약 조건에 의해 지정된 토폴로지에
따라 선택되거나 프로비전된다. 여기에는
<a href=/ko/docs/concepts/configuration/manage-resources-containers/>리소스 요구 사항</a>,
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EB%85%B8%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0-nodeselector>노드 셀렉터</a>,
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-affinity-%EC%99%80-%EC%95%88%ED%8B%B0-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-anti-affinity>파드 어피니티(affinity)와
안티-어피니티(anti-affinity)</a>
그리고 <a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트(taint)와 톨러레이션(toleration)</a>이 포함된다.</p><p>다음 플러그인은 동적 프로비저닝과 <code>WaitForFirstConsumer</code> 를 지원한다.</p><ul><li><a href=#aws-ebs>AWSElasticBlockStore</a></li><li><a href=#gce-pd>GCEPersistentDisk</a></li><li><a href=#azure-%EB%94%94%EC%8A%A4%ED%81%AC>Azure디스크</a></li></ul><p>다음 플러그인은 사전에 생성된 퍼시스턴트볼륨 바인딩으로 <code>WaitForFirstConsumer</code> 를 지원한다.</p><ul><li>위에서 언급한 모든 플러그인</li><li><a href=#local>Local</a></li></ul><p><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.17 [stable]</code></div><a href=/ko/docs/concepts/storage/volumes/#csi>CSI 볼륨</a>은 동적 프로비저닝과
사전에 생성된 PV에서도 지원되지만, 지원되는 토폴로지 키와 예시를 보려면 해당
CSI 드라이버에 대한 문서를 본다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p><code>WaitForFirstConsumer</code>를 사용한다면, 노드 어피니티를 지정하기 위해서 파드 스펙에 <code>nodeName</code>을 사용하지는 않아야 한다.
만약 <code>nodeName</code>을 사용한다면, 스케줄러가 바이패스되고 PVC가 <code>pending</code> 상태로 있을 것이다.</p><p>대신, 아래와 같이 호스트네임을 이용하는 노드셀렉터를 사용할 수 있다.</p></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>kube-01<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http-server&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/usr/share/nginx/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=허용된-토폴로지>허용된 토폴로지</h3><p>클러스터 운영자가 <code>WaitForFirstConsumer</code> 볼륨 바인딩 모드를 지정하면, 대부분의 상황에서
더 이상 특정 토폴로지로 프로비저닝을 제한할 필요가 없다. 그러나
여전히 필요한 경우에는 <code>allowedTopologies</code> 를 지정할 수 있다.</p><p>이 예시는 프로비전된 볼륨의 토폴로지를 특정 영역으로 제한하는 방법을
보여 주며 지원되는 플러그인의 <code>zone</code> 과 <code>zones</code> 파라미터를 대체하는
데 사용해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>WaitForFirstConsumer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowedTopologies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>matchLabelExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>failure-domain.beta.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- us-central-1a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- us-central-1b<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=파라미터>파라미터</h2><p>스토리지 클래스에는 스토리지 클래스에 속하는 볼륨을 설명하는 파라미터가
있다. <code>provisioner</code> 에 따라 다른 파라미터를 사용할 수 있다. 예를 들어,
파라미터 <code>type</code> 에 대한 값 <code>io1</code> 과 파라미터 <code>iopsPerGB</code> 는
EBS에만 사용할 수 있다. 파라미터 생략 시 일부 기본값이
사용된다.</p><p>스토리지클래스에 대해 최대 512개의 파라미터를 정의할 수 있다.
키와 값을 포함하여 파라미터 오브젝터의 총 길이는 256 KiB를
초과할 수 없다.</p><h3 id=aws-ebs>AWS EBS</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/aws-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>io1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>iopsPerGB</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>type</code>: <code>io1</code>, <code>gp2</code>, <code>sc1</code>, <code>st1</code>. 자세한 내용은
<a href=https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-volume-types.html>AWS 문서</a>를
본다. 기본값: <code>gp2</code>.</li><li><code>zone</code> (사용 중단(deprecated)): AWS 영역. <code>zone</code> 과 <code>zones</code> 를 지정하지 않으면, 일반적으로
쿠버네티스 클러스터의 노드가 있는 모든 활성화된 영역에 걸쳐 볼륨이
라운드 로빈으로 조정된다. <code>zone</code> 과 <code>zones</code> 파라미터를 동시에 사용해서는 안된다.</li><li><code>zones</code> (사용 중단): 쉼표로 구분된 AWS 영역의 목록. <code>zone</code> 과 <code>zones</code> 를
지정하지 않으면, 일반적으로 쿠버네티스 클러스터의 노드가 있는 모든 활성화된 영역에 걸쳐
볼륨이 라운드 로빈으로 조정된다. <code>zone</code> 과 <code>zones</code> 파라미터를
동시에 사용해서는 안된다.</li><li><code>iopsPerGB</code>: <code>io1</code> 볼륨 전용이다. 1초당 GiB에 대한 I/O 작업 수이다. AWS
볼륨 플러그인은 요청된 볼륨 크기에 곱셈하여 볼륨의 IOPS를
계산하고 이를 20,000 IOPS로 제한한다(AWS에서 지원하는 최대값으로,
<a href=https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-volume-types.html>AWS 문서</a>를 본다).
여기에는 문자열, 즉 <code>10</code> 이 아닌, <code>"10"</code> 이 필요하다.</li><li><code>fsType</code>: fsType은 쿠버네티스에서 지원된다. 기본값: <code>"ext4"</code>.</li><li><code>encrypted</code>: EBS 볼륨의 암호화 여부를 나타낸다.
유효한 값은 <code>"ture"</code> 또는 <code>"false"</code> 이다. 여기에는 문자열,
즉 <code>true</code> 가 아닌, <code>"true"</code> 가 필요하다.</li><li><code>kmsKeyId</code>: 선택 사항. 볼륨을 암호화할 때 사용할 키의 전체 Amazon
리소스 이름이다. 아무것도 제공되지 않지만, <code>encrypted</code> 가 true라면
AWS에 의해 키가 생성된다. 유효한 ARN 값은 AWS 문서를 본다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>zone</code> 과 <code>zones</code> 파라미터는 사용 중단 되었으며,
<a href=#allowed-topologies>allowedTopologies</a>로 대체되었다.</div><h3 id=gce-pd>GCE PD</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fstype</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replication-type</span>:<span style=color:#bbb> </span>none<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><p><code>type</code>: <code>pd-standard</code> 또는 <code>pd-ssd</code>. 기본값: <code>pd-standard</code></p></li><li><p><code>zone</code> (사용 중단): GCE 영역. <code>zone</code> 과 <code>zones</code> 를 모두 지정하지 않으면, 쿠버네티스 클러스터의
노드가 있는 모든 활성화된 영역에 걸쳐 볼륨이 라운드 로빈으로
조정된다. <code>zone</code> 과 <code>zones</code> 파라미터를 동시에 사용해서는 안된다.</p></li><li><p><code>zones</code> (사용 중단): 쉼표로 구분되는 GCE 영역의 목록. <code>zone</code> 과 <code>zones</code> 를 모두
지정하지 않으면, 쿠버네티스 클러스터의 노드가 있는 모든 활성화된 영역에
걸쳐 볼륨이 라운드 로빈으로 조정된다. <code>zone</code> 과 <code>zones</code> 파라미터를
동시에 사용해서는 안된다.</p></li><li><p><code>fstype</code>: <code>ext4</code> 또는 <code>xfs</code>. 기본값: <code>ext4</code>. 정의된 파일시스템 유형은 호스트 운영체제에서 지원되어야 한다.</p></li><li><p><code>replication-type</code>: <code>none</code> 또는 <code>regional-pd</code>. 기본값: <code>none</code>.</p></li></ul><p><code>replication-type</code> 을 <code>none</code> 으로 설정하면 (영역) PD가 프로비전된다.</p><p><code>replication-type</code> 이 <code>regional-pd</code> 로 설정되면,
<a href=https://cloud.google.com/compute/docs/disks/#repds>지역 퍼시스턴트 디스크</a>
가 프로비전된다. 이는 퍼시스턴트볼륨클레임과 스토리지클래스를 소모하는 파드를
생성할 때 지역 퍼시스턴트 디스크는 두개의 영역으로
프로비전되기에 <code>volumeBindingMode: WaitForFirstConsumer</code> 를
설정하는 것을 강력히 권장한다. 하나의 영역은 파드가 스케줄된
영역과 동일하다. 다른 영역은 클러스터에서 사용할 수
있는 영역에서 임의로 선택된다. 디스크 영역은 <code>allowedTopologies</code> 를
사용하면 더 제한할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>zone</code> 과 <code>zones</code> 파라미터는 사용 중단 되었으며,
<a href=#allowed-topologies>allowedTopologies</a>로 대체되었다.</div><h3 id=glusterfs>Glusterfs</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://127.0.0.1:8081&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;630372ccdc720a92c681fb928f27b53f&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restauthenabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;admin&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;heketi-secret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gidMin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;40000&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gidMax</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50000&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumetype</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;replicate:3&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><p><code>resturl</code>: 필요에 따라 gluster 볼륨을 프로비전하는 Gluster REST 서비스/Heketi
서비스 url 이다. 일반적인 형식은 <code>IPaddress:Port</code> 이어야 하며 이는 GlusterFS
동적 프로비저너의 필수 파라미터이다. Heketi 서비스가 openshift/kubernetes
설정에서 라우팅이 가능한 서비스로 노출이 되는 경우 이것은 fqdn이 해석할 수 있는
Heketi 서비스 url인 <code>http://heketi-storage-project.cloudapps.mystorage.com</code> 과
유사한 형식을 가질 수 있다.</p></li><li><p><code>restauthenabled</code> : REST 서버에 대한 인증을 가능하게 하는 Gluster REST 서비스
인증 부울이다. 이 값이 <code>"true"</code> 이면, <code>restuser</code> 와 <code>restuserkey</code>
또는 <code>secretNamespace</code> + <code>secretName</code> 을 채워야 한다. 이 옵션은
사용 중단이며, <code>restuser</code>, <code>restuserkey</code>, <code>secretName</code> 또는
<code>secretNamespace</code> 중 하나를 지정하면 인증이 활성화된다.</p></li><li><p><code>restuser</code> : Gluster REST 서비스/Heketi 사용자로 Gluster Trusted Pool에서
볼륨을 생성할 수 있다.</p></li><li><p><code>restuserkey</code> : REST 서버에 대한 인증에 사용될 Gluster REST 서비스/Heketi
사용자의 암호이다. 이 파라미터는 <code>secretNamespace</code> + <code>secretName</code> 을 위해
사용 중단 되었다.</p></li><li><p><code>secretNamespace</code>, <code>secretName</code> : Gluster REST 서비스와 통신할 때 사용할
사용자 암호가 포함된 시크릿 인스턴스를 식별한다. 이 파라미터는
선택 사항으로 <code>secretNamespace</code> 와 <code>secretName</code> 을 모두 생략하면
빈 암호가 사용된다. 제공된 시크릿은 <code>"kubernetes.io/glusterfs"</code> 유형이어야
하며, 예를 들어 다음과 같이 생성한다.</p><pre tabindex=0><code>kubectl create secret generic heketi-secret \
  --type=&#34;kubernetes.io/glusterfs&#34; --from-literal=key=&#39;opensesame&#39; \
  --namespace=default
</code></pre><p>시크릿의 예시는
<a href=https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/glusterfs/glusterfs-secret.yaml>glusterfs-provisioning-secret.yaml</a>에서 찾을 수 있다.</p></li><li><p><code>clusterid</code>: <code>630372ccdc720a92c681fb928f27b53f</code> 는 볼륨을 프로비저닝할
때 Heketi가 사용할 클러스터의 ID이다. 또한, 예시와 같이 클러스터
ID 목록이 될 수 있다. 예:
<code>"8452344e2becec931ece4e33c4674e4e,42982310de6c63381718ccfa6d8cf397"</code>. 이것은
선택적 파라미터이다.</p></li><li><p><code>gidMin</code>, <code>gidMax</code> : 스토리지클래스에 대한 GID 범위의 최소값과
최대값이다. 이 범위( gidMin-gidMax )의 고유한 값(GID)은 동적으로
프로비전된 볼륨에 사용된다. 이것은 선택적인 값이다. 지정하지 않으면,
볼륨은 각각 gidMin과 gidMax의 기본값인 2000-2147483647
사이의 값으로 프로비전된다.</p></li><li><p><code>volumetype</code> : 볼륨 유형과 파라미터는 이 선택적 값으로 구성할
수 있다. 볼륨 유형을 언급하지 않는 경우, 볼륨 유형을 결정하는 것은
프로비저너의 책임이다.</p><p>예를 들어:</p><ul><li>레플리카 볼륨: <code>volumetype: replicate:3</code> 여기서 '3'은 레플리카의 수이다.</li><li>Disperse/EC 볼륨: <code>volumetype: disperse:4:2</code> 여기서 '4'는 데이터이고 '2'는 중복 횟수이다.</li><li>Distribute 볼륨: <code>volumetype: none</code></li></ul><p>사용 가능한 볼륨 유형과 관리 옵션에 대해서는
<a href=https://access.redhat.com/documentation/en-us/red_hat_gluster_storage/>관리 가이드</a>를 참조한다.</p><p>자세한 정보는
<a href=https://github.com/heketi/heketi/wiki/Setting-up-the-topology>Heketi 구성 방법</a>을 참조한다.</p><p>퍼시스턴트 볼륨이 동적으로 프로비전되면 Gluster 플러그인은
<code>gluster-dynamic-&lt;claimname></code> 이라는 이름으로 엔드포인트와
헤드리스 서비스를 자동으로 생성한다. 퍼시스턴트 볼륨 클레임을
삭제하면 동적 엔드포인트와 서비스가 자동으로 삭제된다.</p></li></ul><h3 id=nfs>NFS</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-nfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>example.com/external-nfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>nfs-server.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/share<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;false&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>server</code>: NFS 서버의 호스트네임 또는 IP 주소.</li><li><code>path</code>: NFS 서버가 익스포트(export)한 경로.</li><li><code>readOnly</code>: 스토리지를 읽기 전용으로 마운트할지 나타내는 플래그(기본값: false).</li></ul><p>쿠버네티스에는 내장 NFS 프로비저너가 없다. NFS를 위한 스토리지클래스를 생성하려면 외부 프로비저너를 사용해야 한다.
예시는 다음과 같다.</p><ul><li><a href=https://github.com/kubernetes-sigs/nfs-ganesha-server-and-external-provisioner>NFS Ganesha server and external provisioner</a></li><li><a href=https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner>NFS subdir external provisioner</a></li></ul><h3 id=openstack-cinder>OpenStack Cinder</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gold<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>availability</span>:<span style=color:#bbb> </span>nova<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>availability</code>: 가용성 영역. 지정하지 않으면, 일반적으로 쿠버네티스 클러스터의
노드가 있는 모든 활성화된 영역에 걸쳐 볼륨이 라운드 로빈으로 조정된다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.11 [deprecated]</code></div><p>이 OpenStack 내부 프로비저너는 사용 중단 되었다. <a href=https://github.com/kubernetes/cloud-provider-openstack>OpenStack용 외부 클라우드 공급자</a>를 사용한다.</div><h3 id=vsphere>vSphere</h3><p>vSphere 스토리지 클래스에는 두 가지 유형의 프로비저닝 도구가 있다.</p><ul><li><a href=#vsphere-provisioner-csi>CSI 프로비저닝 도구</a>: <code>csi.vsphere.vmware.com</code></li><li><a href=#vcp-%ED%94%84%EB%A1%9C%EB%B9%84%EC%A0%80%EB%8B%9D-%EB%8F%84%EA%B5%AC>vCP 프로비저닝 도구</a>: <code>kubernetes.io/vsphere-volume</code></li></ul><p>인-트리 프로비저닝 도구는 <a href=/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/#why-are-we-migrating-in-tree-plugins-to-csi>사용 중단</a>되었다. CSI 프로비저닝 도구에 대한 자세한 내용은 <a href=https://vsphere-csi-driver.sigs.k8s.io/>쿠버네티스 vSphere CSI 드라이버</a> 및 <a href=/ko/docs/concepts/storage/volumes/#vsphere-csi-migration>vSphereVolume CSI 마이그레이션</a>을 참고한다.</p><h4 id=vsphere-provisioner-csi>CSI 프로비저닝 도구</h4><p>vSphere CSI 스토리지클래스 프로비저닝 도구는 Tanzu 쿠버네티스 클러스터에서 작동한다. 예시는 <a href=https://github.com/kubernetes-sigs/vsphere-csi-driver/blob/master/example/vanilla-k8s-RWM-filesystem-volumes/example-sc.yaml>vSphere CSI 리포지터리</a>를 참조한다.</p><h4 id=vcp-프로비저닝-도구>vCP 프로비저닝 도구</h4><p>다음 예시에서는 VMware 클라우드 공급자(vCP) 스토리지클래스 프로비저닝 도구를 사용한다.</p><ol><li><p>사용자 지정 디스크 형식으로 스토리지클래스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/vsphere-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>diskformat</span>:<span style=color:#bbb> </span>zeroedthick<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>diskformat</code>: <code>thin</code>, <code>zeroedthick</code> 와 <code>eagerzeroedthick</code>. 기본값: <code>"thin"</code>.</p></li><li><p>사용자 지정 데이터스토어에 디스크 형식으로 스토리지클래스를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/vsphere-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>diskformat</span>:<span style=color:#bbb> </span>zeroedthick<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>datastore</span>:<span style=color:#bbb> </span>VSANDatastore<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>datastore</code>: 또한, 사용자는 스토리지클래스에서 데이터스토어를 지정할 수 있다.
볼륨은 스토리지클래스에 지정된 데이터스토어에 생성되며,
이 경우 <code>VSANDatastore</code> 이다. 이 필드는 선택 사항이다. 데이터스토어를
지정하지 않으면, vSphere 클라우드 공급자를 초기화하는데 사용되는 vSphere
설정 파일에 지정된 데이터스토어에 볼륨이
생성된다.</p></li><li><p>쿠버네티스 내부 스토리지 정책을 관리한다.</p><ul><li><p>기존 vCenter SPBM 정책을 사용한다.</p><p>vSphere 스토리지 관리의 가장 중요한 기능 중 하나는
정책 기반 관리이다. 스토리지 정책 기반 관리(Storage Policy Based Management (SPBM))는
광범위한 데이터 서비스와 스토리지 솔루션에서 단일 통합 컨트롤 플레인을
제공하는 스토리지 정책 프레임워크이다. SPBM을 통해 vSphere 관리자는 용량 계획,
차별화된 서비스 수준과 용량의 헤드룸(headroom) 관리와 같은
선행 스토리지 프로비저닝 문제를
극복할 수 있다.</p><p>SPBM 정책은 <code>storagePolicyName</code> 파라미터를 사용하면
스토리지클래스에서 지정할 수 있다.</p></li><li><p>쿠버네티스 내부의 가상 SAN 정책 지원</p><p>Vsphere 인프라스트럭처(Vsphere Infrastructure (VI)) 관리자는
동적 볼륨 프로비저닝 중에 사용자 정의 가상 SAN 스토리지
기능을 지정할 수 있다. 이제 동적 볼륨 프로비저닝 중에 스토리지
기능의 형태로 성능 및 가용성과 같은 스토리지 요구 사항을 정의할
수 있다. 스토리지 기능 요구 사항은 가상 SAN 정책으로 변환된
퍼시스턴트 볼륨(가상 디스크)을 생성할 때
가상 SAN 계층으로 푸시된다. 가상 디스크는 가상 SAN 데이터
스토어에 분산되어 요구 사항을 충족시키게 된다.</p><p>퍼시스턴트 볼륨 관리에 스토리지 정책을 사용하는 방법에 대한 자세한 내용은
<a href=https://github.com/vmware-archive/vsphere-storage-for-kubernetes/blob/fa4c8b8ad46a85b6555d715dd9d27ff69839df53/documentation/policy-based-mgmt.md>볼륨의 동적 프로비저닝을 위한 스토리지 정책 기반 관리(SPBM)</a>를
참조한다.</p></li></ul></li></ol><p>vSphere용 쿠버네티스 내에서 퍼시스턴트 볼륨 관리를 시도하는
<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>vSphere 예시</a>는
거의 없다.</p><h3 id=ceph-rbd>Ceph RBD</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/rbd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>monitors</span>:<span style=color:#bbb> </span><span style=color:#666>10.16.153.105</span>:<span style=color:#666>6789</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminId</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretName</span>:<span style=color:#bbb> </span>ceph-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretNamespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pool</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userId</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userSecretName</span>:<span style=color:#bbb> </span>ceph-secret-user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userSecretNamespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imageFormat</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imageFeatures</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;layering&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><p><code>monitors</code>: 쉼표로 구분된 Ceph 모니터. 이 파라미터는 필수이다.</p></li><li><p><code>adminId</code>: 풀에 이미지를 생성할 수 있는 Ceph 클라이언트 ID.
기본값은 "admin".</p></li><li><p><code>adminSecretName</code>: <code>adminId</code> 의 시크릿 이름. 이 파라미터는 필수이다.
제공된 시크릿은 "kubernetes.io/rbd" 유형이어야 한다.</p></li><li><p><code>adminSecretNamespace</code>: <code>adminSecretName</code> 의 네임스페이스. 기본값은 "default".</p></li><li><p><code>pool</code>: Ceph RBD 풀. 기본값은 "rbd".</p></li><li><p><code>userId</code>: RBD 이미지를 매핑하는 데 사용하는 Ceph 클라이언트 ID. 기본값은
<code>adminId</code> 와 동일하다.</p></li><li><p><code>userSecretName</code>: RDB 이미지를 매핑하기 위한 <code>userId</code> 에 대한 Ceph 시크릿 이름. PVC와
동일한 네임스페이스에 존재해야 한다. 이 파라미터는 필수이다.
제공된 시크릿은 "kubernetes.io/rbd" 유형이어야 하며, 다음의 예시와 같이
생성되어야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ceph-secret --type<span style=color:#666>=</span><span style=color:#b44>&#34;kubernetes.io/rbd&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>key</span><span style=color:#666>=</span><span style=color:#b44>&#39;QVFEQ1pMdFhPUnQrSmhBQUFYaERWNHJsZ3BsMmNjcDR6RFZST0E9PQ==&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div></li><li><p><code>userSecretNamespace</code>: <code>userSecretName</code> 의 네임스페이스.</p></li><li><p><code>fsType</code>: 쿠버네티스가 지원하는 fsType. 기본값: <code>"ext4"</code>.</p></li><li><p><code>imageFormat</code>: Ceph RBD 이미지 형식, "1" 또는 "2". 기본값은 "2".</p></li><li><p><code>imageFeatures</code>: 이 파라미터는 선택 사항이며, <code>imageFormat</code> 을 "2"로 설정한
경우에만 사용해야 한다. 현재 <code>layering</code> 에서만 기능이 지원된다.
기본값은 ""이며, 기능이 설정되어 있지 않다.</p></li></ul><h3 id=azure-디스크>Azure 디스크</h3><h4 id=azure-unmanaged-disk-storage-class>Azure 비관리 디스크 스토리지 클래스</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>skuName</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>location</span>:<span style=color:#bbb> </span>eastus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageAccount</span>:<span style=color:#bbb> </span>azure_storage_account_name<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>skuName</code>: Azure 스토리지 계정 Sku 계층. 기본값은 없음.</li><li><code>location</code>: Azure 스토리지 계정 지역. 기본값은 없음.</li><li><code>storageAccount</code>: Azure 스토리지 계정 이름. 스토리지 계정이 제공되면, 클러스터와 동일한
리소스 그룹에 있어야 하며, <code>location</code> 은 무시된다. 스토리지 계정이
제공되지 않으면, 클러스터와 동일한 리소스
그룹에 새 스토리지 계정이 생성된다.</li></ul><h4 id=azure-disk-storage-class>Azure 디스크 스토리지 클래스(v1.7.2부터 제공)</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageaccounttype</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>managed<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>storageaccounttype</code>: Azure 스토리지 계정 Sku 계층. 기본값은 없음.</li><li><code>kind</code>: 가능한 값은 <code>shared</code>, <code>dedicated</code>, 그리고 <code>managed</code> (기본값) 이다.
<code>kind</code> 가 <code>shared</code> 인 경우, 모든 비관리 디스크는 클러스터와
동일한 리소스 그룹에 있는 몇 개의 공유 스토리지 계정에 생성된다. <code>kind</code> 가
<code>dedicated</code> 인 경우, 클러스터와 동일한 리소스 그룹에서 새로운
비관리 디스크에 대해 새로운 전용 스토리지 계정이 생성된다. <code>kind</code> 가
<code>managed</code> 인 경우, 모든 관리 디스크는 클러스터와 동일한 리소스
그룹에 생성된다.</li><li><code>resourceGroup</code>: Azure 디스크를 만들 리소스 그룹을 지정한다.
기존에 있는 리소스 그룹 이름이어야 한다. 지정되지 않는 경우, 디스크는
현재 쿠버네티스 클러스터와 동일한 리소스 그룹에 배치된다.</li></ul><ul><li>프리미엄 VM은 표준 LRS(Standard_LRS)와 프리미엄 LRS(Premium_LRS) 디스크를 모두 연결할 수 있는 반면에,
표준 VM은 표준 LRS(Standard_LRS) 디스크만 연결할 수 있다.</li><li>관리되는 VM은 관리되는 디스크만 연결할 수 있고,
비관리 VM은 비관리 디스크만 연결할 수 있다.</li></ul><h3 id=azure-파일>Azure 파일</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>azurefile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>skuName</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>location</span>:<span style=color:#bbb> </span>eastus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageAccount</span>:<span style=color:#bbb> </span>azure_storage_account_name<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>skuName</code>: Azure 스토리지 계정 Sku 계층. 기본값은 없음.</li><li><code>location</code>: Azure 스토리지 계정 지역. 기본값은 없음.</li><li><code>storageAccount</code>: Azure 스토리지 계정 이름. 기본값은 없음. 스토리지 계정이
제공되지 않으면, 리소스 그룹과 관련된 모든 스토리지 계정이
검색되어 <code>skuName</code> 과 <code>location</code> 이 일치하는 것을 찾는다. 스토리지 계정이
제공되면, 클러스터와 동일한 리소스 그룹에 있어야
하며 <code>skuName</code> 과 <code>location</code> 은 무시된다.</li><li><code>secretNamespace</code>: Azure 스토리지 계정 이름과 키가 포함된 시크릿
네임스페이스. 기본값은 파드와 동일하다.</li><li><code>secretName</code>: Azure 스토리지 계정 이름과 키가 포함된 시크릿 이름.
기본값은 <code>azure-storage-account-&lt;accountName>-secret</code></li><li><code>readOnly</code>: 스토리지가 읽기 전용으로 마운트되어야 하는지 여부를 나타내는 플래그.
읽기/쓰기 마운트를 의미하는 기본값은 false. 이 설정은
볼륨마운트(VolumeMounts)의 <code>ReadOnly</code> 설정에도 영향을 준다.</li></ul><p>스토리지 프로비저닝 중에 마운트 자격증명에 대해 <code>secretName</code>
이라는 시크릿이 생성된다. 클러스터에
<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>과
<a href=/docs/reference/access-authn-authz/rbac/#controller-roles>컨트롤러의 롤(role)들</a>을
모두 활성화한 경우, clusterrole <code>system:controller:persistent-volume-binder</code>
에 대한 <code>secret</code> 리소스에 <code>create</code> 권한을 추가한다.</p><p>다중 테넌시 컨텍스트에서 <code>secretNamespace</code> 의 값을 명시적으로 설정하는
것을 권장하며, 그렇지 않으면 다른 사용자가 스토리지 계정 자격증명을
읽을 수 있기 때문이다.</p><h3 id=portworx-볼륨>Portworx 볼륨</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>portworx-io-priority-high<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/portworx-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>repl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>snap_interval</span>:<span style=color:#bbb>   </span><span style=color:#b44>&#34;70&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priority_io</span>:<span style=color:#bbb>  </span><span style=color:#b44>&#34;high&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>fs</code>: 배치할 파일 시스템: <code>none/xfs/ext4</code> (기본값: <code>ext4</code>)</li><li><code>block_size</code>: Kbytes 단위의 블록 크기(기본값: <code>32</code>).</li><li><code>repl</code>: 레플리케이션 팩터 <code>1..3</code> (기본값: <code>1</code>)의 형태로 제공될
동기 레플리카의 수. 여기에는 문자열,
즉 <code>0</code> 이 아닌, <code>"0"</code> 이 필요하다.</li><li><code>priority_io</code>: 볼륨이 고성능 또는 우선 순위가 낮은 스토리지에서
생성될 것인지를 결정한다 <code>high/medium/low</code> (기본값: <code>low</code>).</li><li><code>snap_interval</code>: 스냅샷을 트리거할 때의 시각/시간 간격(분).
스냅샷은 이전 스냅샷과의 차이에 따라 증분되며, 0은 스냅을
비활성화 한다(기본값: <code>0</code>). 여기에는 문자열,
즉 <code>70</code> 이 아닌, <code>"70"</code> 이 필요하다.</li><li><code>aggregation_level</code>: 볼륨이 분배될 청크 수를 지정하며, 0은 집계되지 않은
볼륨을 나타낸다(기본값: <code>0</code>). 여기에는 문자열,
즉 <code>0</code> 이 아닌, <code>"0"</code> 이 필요하다.</li><li><code>ephemeral</code>: 마운트 해제 후 볼륨을 정리해야 하는지 혹은 지속적이어야
하는지를 지정한다. <code>emptyDir</code> 에 대한 유스케이스는 이 값을 true로
설정할 수 있으며, <code>persistent volumes</code> 에 대한 유스케이스인
카산드라와 같은 데이터베이스는 false로 설정해야 한다. <code>true/false</code> (기본값 <code>false</code>)
여기에는 문자열, 즉 <code>true</code> 가 아닌, <code>"true"</code> 가 필요하다.</li></ul><h3 id=local>Local</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.14 [stable]</code></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/no-provisioner<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>WaitForFirstConsumer<span style=color:#bbb>
</span></span></span></code></pre></div><p>로컬 볼륨은 현재 동적 프로비저닝을 지원하지 않지만, 파드 스케줄링까지
볼륨 바인딩을 지연시키기 위해서는 스토리지클래스가 여전히 생성되어야 한다. 이것은
<code>WaitForFirstConsumer</code> 볼륨 바인딩 모드에 의해 지정된다.</p><p>볼륨 바인딩을 지연시키면 스케줄러가 퍼시스턴트볼륨클레임에
적절한 퍼시스턴트볼륨을 선택할 때 파드의 모든 스케줄링
제약 조건을 고려할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-df33eab51202c17bb0fe551d1d5cc5d2>5 - 임시 볼륨</h1><p>이 문서는 쿠버네티스의 <em>임시(ephemeral) 볼륨</em> 에 대해 설명한다.
쿠버네티스 <a href=/ko/docs/concepts/storage/volumes/>볼륨</a>,
특히 퍼시스턴트볼륨클레임(PersistentVolumeClaim) 및 퍼시스턴트볼륨(PersistentVolume)에 대해 잘 알고 있는 것이 좋다.</p><p>일부 애플리케이션은 추가적인 저장소를 필요로 하면서도
재시작 시 데이터의 영구적 보존 여부는 신경쓰지 않을 수도 있다.
예를 들어, 캐싱 서비스는 종종 메모리 사이즈에 제약을 받으며
이에 따라 전반적인 성능에 적은 영향을 미치면서도
사용 데이터를 메모리보다는 느린 저장소에 간헐적으로 옮길 수도 있다.</p><p>또 다른 애플리케이션은 읽기 전용 입력 데이터를 파일에서 읽도록 되어 있으며,
이러한 데이터의 예시로는 구성 데이터 또는 비밀 키 등이 있다.</p><p><em>임시 볼륨</em> 은 이러한 사용 사례를 위해 설계되었다.
임시 볼륨은 파드의 수명을 따르며 파드와 함께 생성 및 삭제되기 때문에,
일부 퍼시스턴트 볼륨이 어디에서 사용 가능한지에 제약되는 일 없이
파드가 중지 및 재시작될 수 있다.</p><p>임시 볼륨은 파드 명세에 <em>인라인</em> 으로 명시되며,
이로 인해 애플리케이션 배포 및 관리가 간편해진다.</p><h3 id=임시-볼륨의-종류>임시 볼륨의 종류</h3><p>쿠버네티스는 각 목적에 맞는
몇 가지의 임시 볼륨을 지원한다.</p><ul><li><a href=/ko/docs/concepts/storage/volumes/#emptydir>emptyDir</a>:
파드가 시작될 때 빈 상태로 시작되며,
저장소는 로컬의 kubelet 베이스 디렉터리(보통 루트 디스크) 또는 램에서 제공된다</li><li><a href=/ko/docs/concepts/storage/volumes/#configmap>configMap</a>,
<a href=/ko/docs/concepts/storage/volumes/#downwardapi>downwardAPI</a>,
<a href=/ko/docs/concepts/storage/volumes/#secret>secret</a>:
각 종류의 쿠버네티스 데이터를 파드에 주입한다</li><li><a href=#csi-ephemeral-volumes>CSI 임시 볼륨</a>:
앞의 볼륨 종류와 비슷하지만,
특히 <a href=https://kubernetes-csi.github.io/docs/drivers.html>이 기능을 지원</a>하는 특수한
<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>CSI 드라이버</a>에 의해 제공된다</li><li><a href=#generic-ephemeral-volumes>일반(generic) 임시 볼륨</a>:
퍼시스턴트 볼륨도 지원하는 모든 스토리지 드라이버에 의해 제공될 수 있다</li></ul><p><code>emptyDir</code>, <code>configMap</code>, <code>downwardAPI</code>, <code>secret</code>은
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EB%A1%9C%EC%BB%AC-%EC%9E%84%EC%8B%9C-ephemeral-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80>로컬 임시 스토리지</a>로서
제공된다.
이들은 각 노드의 kubelet에 의해 관리된다.</p><p>CSI 임시 볼륨은
써드파티 CSI 스토리지 드라이버에 의해 제공 <em>되어야 한다</em>.</p><p>일반 임시 볼륨은 써드파티 CSI 스토리지 드라이버에 의해 제공 <em>될 수 있지만</em>,
동적 프로비저닝을 지원하는 다른 스토리지 드라이버에 의해서도 제공될 수 있다.
일부 CSI 드라이버는 특히 CSI 임시 볼륨을 위해 만들어져서
동적 프로비저닝을 지원하지 않는데,
이러한 경우에는 일반 임시 볼륨 용으로는 사용할 수 없다.</p><p>써드파티 드라이버 사용의 장점은
쿠버네티스 자체적으로는 지원하지 않는 기능(예:
kubelet에서 관리하는 디스크와 성능 특성이 다른 스토리지, 또는 다른 데이터 주입)을
제공할 수 있다는 것이다.</p><h3 id=csi-ephemeral-volumes>CSI 임시 볼륨</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> CSI 드라이버 중 일부만 CSI 임시 볼륨을 지원한다.
쿠버네티스 CSI <a href=https://kubernetes-csi.github.io/docs/drivers.html>드라이버 목록</a>에서
어떤 드라이버가 임시 볼륨을 지원하는지 보여 준다.</div><p>개념적으로, CSI 임시 볼륨은 <code>configMap</code>, <code>downwardAPI</code>, <code>secret</code> 볼륨 유형과 비슷하다.
즉, 스토리지는 각 노드에서 로컬하게 관리되며,
파드가 노드에 스케줄링된 이후에 다른 로컬 리소스와 함께 생성된다.
쿠버네티스에는 지금 단계에서는 파드를 재스케줄링하는 개념이 없다.
볼륨 생성은 실패하는 일이 거의 없어야 하며,
만약 실패할 경우 파드 시작 과정이 중단될 것이다.
특히, <a href=/ko/docs/concepts/storage/storage-capacity/>스토리지 용량 인지 파드 스케줄링</a>은
이러한 볼륨에 대해서는 지원되지 <em>않는다</em>.
또한 이러한 볼륨은 파드의 스토리지 자원 사용 상한에 제한받지 않는데,
이는 kubelet 자신이 관리하는 스토리지에만 강제할 수 있는 것이기 때문이다.</p><p>다음은 CSI 임시 스토리지를 사용하는 파드에 대한 예시 매니페스트이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/data&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-inline-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1000000&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-inline-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>csi</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>inline.storage.kubernetes.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeAttributes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>volumeAttributes</code>은 드라이버에 의해 어떤 볼륨이 준비되는지를 결정한다.
이러한 속성은 각 드라이버별로 다르며 표준화되지 않았다.
더 자세한 사항은 각 CSI 드라이버 문서를
참고한다.</p><h3 id=csi-드라이버-제한-사항>CSI 드라이버 제한 사항</h3><p>CSI 임시 볼륨은 사용자로 하여금 <code>volumeAttributes</code>를
파드 스펙의 일부로서 CSI 드라이버에 직접 제공할 수 있도록 한다.
보통은 관리자만 사용할 수 있는 <code>volumeAttributes</code>를 허용하는 CSI 드라이버는
내장(inline) 임시 볼륨 내에서 사용하는 것이 적합하지 않다.
예를 들어, 일반적으로 스토리지클래스 내에 정의되어 있는 파라미터들은
내장 임시 볼륨 사용을 통해 사용자에게 노출되어서는 안 된다.</p><p>클러스터 관리자가 이처럼 파드 스펙 내장 임시 볼륨 사용이 가능한 CSI 드라이버를 제한하려면
다음을 수행할 수 있다.</p><ul><li>CSIDriver 스펙의 <code>volumeLifecycleModes</code>에서 <code>Ephemeral</code>을 제거하여,
해당 드라이버가 내장 임시 볼륨으로 사용되는 것을 막는다.</li><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>어드미션 웹훅</a>을 사용하여
드라이버를 활용하는 방법을 제한한다.</li></ul><h3 id=generic-ephemeral-volumes>일반 임시 볼륨</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [stable]</code></div><p>일반 임시 볼륨은
프로비저닝 후 일반적으로 비어 있는 스크래치 데이터에 대해 파드 별 디렉터리를 제공한다는 점에서
<code>emptyDir</code> 볼륨과 유사하다.
하지만 다음과 같은 추가 기능도 제공한다.</p><ul><li>스토리지는 로컬이거나 네트워크 연결형(network-attached)일 수 있다.</li><li>볼륨의 크기를 고정할 수 있으며 파드는 이 크기를 초과할 수 없다.</li><li>드라이버와 파라미터에 따라
볼륨이 초기 데이터를 가질 수도 있다.</li><li>볼륨에 대한 일반적인 작업은 드라이버가 지원하는 범위 내에서 지원된다.
이와 같은 작업은 다음을 포함한다.
<a href=/ko/docs/concepts/storage/volume-snapshots/>스냅샷</a>,
<a href=/ko/docs/concepts/storage/volume-pvc-datasource/>복제</a>,
<a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8-%EB%B3%BC%EB%A5%A8-%ED%81%B4%EB%A0%88%EC%9E%84-%ED%99%95%EC%9E%A5>크기 조정</a>,
및 <a href=/ko/docs/concepts/storage/storage-capacity/>스토리지 용량 추적</a>.</li></ul><p>다음은 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/scratch&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1000000&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ephemeral</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeClaimTemplate</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>my-frontend-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;scratch-storage-class&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=라이프사이클-및-퍼시스턴트볼륨클레임>라이프사이클 및 퍼시스턴트볼륨클레임</h3><p>핵심 설계 아이디어는
<a href=/docs/reference/generated/kubernetes-api/v1.25/#ephemeralvolumesource-v1alpha1-core>볼륨 클레임을 위한 파라미터</a>는
파드의 볼륨 소스 내부에서 허용된다는 점이다.
레이블, 어노테이션 및 퍼시스턴트볼륨클레임을 위한 모든 필드가 지원된다.
이러한 파드가 생성되면, 임시 볼륨 컨트롤러는 파드가 속한 동일한 네임스페이스에
퍼시스턴트볼륨클레임 오브젝트를 생성하고
파드가 삭제될 때에는 퍼시스턴트볼륨클레임도 삭제되도록 만든다.</p><p>이는 볼륨 바인딩 및/또는 프로비저닝을 유발하는데,
<a class=glossary-tooltip title='스토리지클래스는 관리자가 사용 가능한 다양한 스토리지 유형을 설명할 수 있는 방법을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/storage-classes target=_blank aria-label=스토리지클래스>스토리지클래스</a>가
즉각적인(immediate) 볼륨 바인딩을 사용하는 경우에는 즉시,
또는 파드가 노드에 잠정적으로 스케줄링되었을 때 발생한다(<code>WaitForFirstConsumer</code> 볼륨 바인딩 모드).
일반 임시 볼륨에는 후자가 추천되는데, 이 경우 스케줄러가 파드를 할당하기에 적합한 노드를 선택하기가 쉬워지기 때문이다.
즉각적인 바인딩을 사용하는 경우,
스케줄러는 볼륨이 사용 가능해지는 즉시 해당 볼륨에 접근 가능한 노드를 선택하도록 강요받는다.</p><p><a href=/ko/docs/concepts/architecture/garbage-collection/#owners-dependents>리소스 소유권</a> 관점에서,
일반 임시 스토리지를 갖는 파드는
해당 임시 스토리지를 제공하는 퍼시스턴트볼륨클레임의 소유자이다.
파드가 삭제되면, 쿠버네티스 가비지 콜렉터는 해당 PVC를 삭제하는데,
스토리지 클래스의 기본 회수 정책이 볼륨을 삭제하는 것이기 때문에 PVC의 삭제는 보통 볼륨의 삭제를 유발한다.
회수 정책을 <code>retain</code>으로 설정한 스토리지클래스를 사용하여 준 임시(quasi-ephemeral) 로컬 스토리지를 생성할 수도 있는데,
이렇게 하면 스토리지의 수명이 파드의 수명보다 길어지며,
이러한 경우 볼륨 정리를 별도로 수행해야 함을 명심해야 한다.</p><p>이러한 PVC가 존재하는 동안은, 다른 PVC와 동일하게 사용될 수 있다.
특히, 볼륨 복제 또는 스냅샷 시에 데이터 소스로 참조될 수 있다.
또한 해당 PVC 오브젝트는 해당 볼륨의 현재 상태도
가지고 있다.</p><h3 id=퍼시스턴트볼륨클레임-이름-정하기>퍼시스턴트볼륨클레임 이름 정하기</h3><p>자동으로 생성된 PVC의 이름은 규칙에 따라 정해진다.
PVC의 이름은 파드 이름과 볼륨 이름의 사이를 하이픈(<code>-</code>)으로 결합한 형태이다.
위의 예시에서, PVC 이름은 <code>my-app-scratch-volume</code>가 된다.
이렇게 규칙에 의해 정해진 이름은 PVC와의 상호작용을 더 쉽게 만드는데,
이는 파드 이름과 볼륨 이름을 알면
PVC 이름을 별도로 검색할 필요가 없기 때문이다.</p><p>PVC 이름 규칙에 따라 서로 다른 파드 간 이름 충돌이 발생할 수
있으며("pod-a" 파드 + "scratch" 볼륨 vs. "pod" 파드 + "a-scratch" 볼륨 -
두 경우 모두 PVC 이름은 "pod-a-scratch")
또한 파드와 수동으로 생성한 PVC 간에도 이름 충돌이 발생할 수 있다.</p><p>이러한 충돌은 감지될 수 있는데, 이는 PVC가 파드를 위해 생성된 경우에만 임시 볼륨으로 사용되기 때문이다.
이러한 체크는 소유권 관계를 기반으로 한다.
기존에 존재하던 PVC는 덮어써지거나 수정되지 않는다.
대신에 충돌을 해결해주지는 않는데,
이는 적합한 PVC가 없이는 파드가 시작될 수 없기 때문이다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 이러한 충돌이 발생하지 않도록
동일한 네임스페이스 내에서는 파드와 볼륨의 이름을 정할 때 주의해야 한다.</div><h3 id=보안>보안</h3><p>GenericEphemeralVolume 기능을 활성화하면
사용자가 파드를 생성할 수 있는 경우 PVC를 간접적으로 생성할 수 있도록 허용하며,
심지어 사용자가 PVC를 직접적으로 만들 수 있는 권한이 없는 경우에도 이를 허용한다.
클러스터 관리자는 이를 명심해야 한다. 이것이 보안 모델에 부합하지 않는다면,
<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>어드미션 웹훅</a>을 사용하여
일반 임시 볼륨을 갖는 파드와 같은 오브젝트를 거부해야 한다.</p><p>일반적인 <a href=/ko/docs/concepts/policy/resource-quotas/#%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EC%BF%BC%ED%84%B0>PVC의 네임스페이스 쿼터</a>는 여전히 적용되므로,
사용자가 이 새로운 메카니즘을 사용할 수 있도록 허용되었어도,
다른 정책을 우회하는 데에는 사용할 수 없다.</p><h2 id=다음-내용>다음 내용</h2><h3 id=kubelet이-관리하는-임시-볼륨>kubelet이 관리하는 임시 볼륨</h3><p><a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EB%A1%9C%EC%BB%AC-%EC%9E%84%EC%8B%9C-ephemeral-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80>로컬 임시 스토리지</a>를 참고한다.</p><h3 id=csi-임시-볼륨>CSI 임시 볼륨</h3><ul><li>설계에 대한 더 자세한 정보는
<a href=https://github.com/kubernetes/enhancements/blob/ad6021b3d61a49040a3f835e12c8bb5424db2bbb/keps/sig-storage/20190122-csi-inline-volumes.md>임시 인라인 CSI 볼륨 KEP</a>를 참고한다.</li><li>이 기능의 추가 개발에 대한 자세한 정보는 <a href=https://github.com/kubernetes/enhancements/issues/596>enhancement 저장소의 이슈 #596</a>을 참고한다.</li></ul><h3 id=일반-임시-볼륨>일반 임시 볼륨</h3><ul><li>설계에 대한 더 자세한 정보는
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1698-generic-ephemeral-volumes/README.md>일반 임시 인라인 볼륨 KEP</a>를 참고한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-018f0a7fc6e2f6d16da37702fc39b4f3>6 - 동적 볼륨 프로비저닝</h1><p>동적 볼륨 프로비저닝을 통해 온-디맨드 방식으로 스토리지 볼륨을 생성할 수 있다.
동적 프로비저닝이 없으면 클러스터 관리자는 클라우드 또는 스토리지
공급자에게 수동으로 요청해서 새 스토리지 볼륨을 생성한 다음, 쿠버네티스에
표시하기 위해 <a href=/ko/docs/concepts/storage/persistent-volumes/><code>PersistentVolume</code> 오브젝트</a>를
생성해야 한다. 동적 프로비저닝 기능을 사용하면 클러스터 관리자가
스토리지를 사전 프로비저닝 할 필요가 없다. 대신 사용자가
스토리지를 요청하면 자동으로 프로비저닝 한다.</p><h2 id=배경>배경</h2><p>동적 볼륨 프로비저닝의 구현은 <code>storage.k8s.io</code> API 그룹의 <code>StorageClass</code>
API 오브젝트를 기반으로 한다. 클러스터 관리자는 볼륨을 프로비전하는
<em>볼륨 플러그인</em> (프로비저너라고도 알려짐)과 프로비저닝시에 프로비저너에게
전달할 파라미터 집합을 지정하는 <code>StorageClass</code>
오브젝트를 필요한 만큼 정의할 수 있다.
클러스터 관리자는 클러스터 내에서 사용자 정의 파라미터 집합을
사용해서 여러 가지 유형의 스토리지 (같거나 다른 스토리지 시스템들)를
정의하고 노출시킬 수 있다. 또한 이 디자인을 통해 최종 사용자는
스토리지 프로비전 방식의 복잡성과 뉘앙스에 대해 걱정할 필요가 없다. 하지만,
여전히 여러 스토리지 옵션들을 선택할 수 있다.</p><p>스토리지 클래스에 대한 자세한 정보는
<a href=/ko/docs/concepts/storage/storage-classes/>여기</a>에서 찾을 수 있다.</p><h2 id=동적-프로비저닝-활성화하기>동적 프로비저닝 활성화하기</h2><p>동적 프로비저닝을 활성화하려면 클러스터 관리자가 사용자를 위해 하나 이상의 스토리지클래스(StorageClass)
오브젝트를 사전 생성해야 한다.
스토리지클래스 오브젝트는 동적 프로비저닝이 호출될 때 사용할 프로비저너와
해당 프로비저너에게 전달할 파라미터를 정의한다.
스토리지클래스 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><p>다음 매니페스트는 표준 디스크와 같은 퍼시스턴트 디스크를 프로비전하는
스토리지 클래스 "slow"를 만든다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></span></span></code></pre></div><p>다음 매니페스트는 SSD와 같은 퍼시스턴트 디스크를 프로비전하는
스토리지 클래스 "fast"를 만든다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-ssd<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=동적-프로비저닝-사용하기>동적 프로비저닝 사용하기</h2><p>사용자는 <code>PersistentVolumeClaim</code> 에 스토리지 클래스를 포함시켜 동적으로 프로비전된
스토리지를 요청한다. 쿠버네티스 v1.6 이전에는 <code>volume.beta.kubernetes.io/storage-class</code>
어노테이션을 통해 수행되었다. 그러나 이 어노테이션은
v1.9부터는 더 이상 사용하지 않는다. 사용자는 이제 <code>PersistentVolumeClaim</code> 오브젝트의
<code>storageClassName</code> 필드를 사용해야 한다. 이 필드의 값은
관리자가 구성한 <code>StorageClass</code> 의 이름과
일치해야 한다. (<a href=#%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EB%B9%84%EC%A0%80%EB%8B%9D-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%98%EA%B8%B0>아래</a>를 참고)</p><p>예를 들어 "fast" 스토리지 클래스를 선택하려면 다음과
같은 <code>PersistentVolumeClaim</code> 을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>claim1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>30Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>이 클레임의 결과로 SSD와 같은 퍼시스턴트 디스크가 자동으로
프로비전 된다. 클레임이 삭제되면 볼륨이 삭제된다.</p><h2 id=기본-동작>기본 동작</h2><p>스토리지 클래스가 지정되지 않은 경우 모든 클레임이 동적으로
프로비전이 되도록 클러스터에서 동적 프로비저닝을 활성화 할 수 있다. 클러스터 관리자는
이 방법으로 활성화 할 수 있다.</p><ul><li>하나의 <code>StorageClass</code> 오브젝트를 <em>default</em> 로 표시한다.</li><li>API 서버에서 <a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code> 어드미션 컨트롤러</a>를
사용하도록 설정한다.</li></ul><p>관리자는 <code>storageclass.kubernetes.io/is-default-class</code> <a href=/ko/docs/reference/labels-annotations-taints/#storageclass-kubernetes-io-is-default-class>어노테이션</a>을
추가해서 특정 <code>StorageClass</code> 를 기본으로 표시할 수 있다.
기본 <code>StorageClass</code> 가 클러스터에 존재하고 사용자가
<code>storageClassName</code> 를 지정하지 않은 <code>PersistentVolumeClaim</code> 을
작성하면, <code>DefaultStorageClass</code> 어드미션 컨트롤러가 디폴트
스토리지 클래스를 가리키는 <code>storageClassName</code> 필드를 자동으로 추가한다.</p><p>클러스터에는 최대 하나의 <em>default</em> 스토리지 클래스가 있을 수 있다. 그렇지 않은 경우
<code>storageClassName</code> 을 명시적으로 지정하지 않은 <code>PersistentVolumeClaim</code> 을
생성할 수 없다.</p><h2 id=토폴로지-인식>토폴로지 인식</h2><p><a href=/ko/docs/setup/best-practices/multiple-zones/>다중 영역</a> 클러스터에서 파드는 한 지역 내
여러 영역에 걸쳐 분산될 수 있다. 파드가 예약된 영역에서 단일 영역 스토리지 백엔드를
프로비전해야 한다. <a href=/ko/docs/concepts/storage/storage-classes/#%EB%B3%BC%EB%A5%A8-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%AA%A8%EB%93%9C>볼륨 바인딩 모드</a>를
설정해서 수행할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c262af210c6828dec445d2f55a1d877a>7 - 볼륨 스냅샷</h1><p>쿠버네티스에서 스토리지 시스템 볼륨 스냅샷은 <em>VolumeSnapshot</em> 을 나타낸다. 이 문서는 이미 쿠버네티스 <a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트 볼륨</a>에 대해 잘 알고 있다고 가정한다.</p><h2 id=소개>소개</h2><p>API 리소스 <code>PersistentVolume</code> 및 <code>PersistentVolumeClaim</code> 가 사용자 및 관리자가 볼륨을 프로비전할 때의 방법과 유사하게, <code>VolumeSnapshotContent</code> 및 <code>VolumeSnapshot</code> API 리소스는 볼륨 스냅샷을 생성하기 위해 제공된다.</p><p><code>VolumeSnapshotContent</code> 는 관리자가 프로버져닝한 클러스터 볼륨에서의 스냅샷이다. 퍼시스턴트볼륨이 클러스터 리소스인 것처럼 이것 또한 클러스터 리소스이다.</p><p><code>VolumeSnapshot</code> 은 사용자가 볼륨의 스냅샷을 요청할 수 있는 방법이다. 이는 퍼시스턴트볼륨클레임과 유사하다.</p><p><code>VolumeSnapshotClass</code> 을 사용하면 <code>VolumeSnapshot</code> 에 속한 다른 속성을 지정할 수 있다. 이러한 속성은 스토리지 시스템에의 동일한 볼륨에서 가져온 스냅샷마다 다를 수 있으므로 <code>PersistentVolumeClaim</code> 의 <code>StorageClass</code> 를 사용하여 표현할 수는 없다.</p><p>볼륨 스냅샷은 쿠버네티스 사용자에게 완전히 새로운 볼륨을 생성하지 않고도 특정 시점에 볼륨의 콘텐츠를 복사하는 표준화된 방법을 제공한다. 예를 들어, 데이터베이스 관리자는 이 기능을 사용하여 수정 사항을 편집 또는 삭제하기 전에 데이터베이스를 백업할 수 있다.</p><p>사용자는 이 기능을 사용할 때 다음 사항을 알고 있어야 한다.</p><ul><li>API 오브젝트인 <code>VolumeSnapshot</code>, <code>VolumeSnapshotContent</code>, <code>VolumeSnapshotClass</code> 는 핵심 API가 아닌, <a class=glossary-tooltip title='사용자 정의 서버를 완전히 새로 구축할 필요가 없도록 쿠버네티스 API 서버에 추가할 리소스를 정의하는 사용자 정의 코드.' data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CRDs>CRDs</a>이다.</li><li><code>VolumeSnapshot</code> 은 CSI 드라이버에서만 사용할 수 있다.</li><li>쿠버네티스 팀은 <code>VolumeSnapshot</code> 의 배포 프로세스 일부로써, 컨트롤 플레인에 배포할 스냅샷 컨트롤러와 CSI 드라이버와 함께 배포할 csi-snapshotter라는 사이드카 헬퍼(helper) 컨테이너를 제공한다. 스냅샷 컨트롤러는 <code>VolumeSnapshot</code> 및 <code>VolumeSnapshotContent</code> 오브젝트를 관찰하고 동적 프로비저닝에서 <code>VolumeSnapshotContent</code> 오브젝트의 생성 및 삭제를 할 수 있다.사이드카 csi-snapshotter는 <code>VolumeSnapshotContent</code> 오브젝트를 관찰하고 CSI 엔드포인트에 대해 <code>CreateSnapshot</code> 및 <code>DeleteSnapshot</code> 을 트리거(trigger)한다.</li><li>스냅샷 오브젝트에 대한 강화된 검증을 제공하는 검증 웹훅 서버도 있다. 이는 CSI 드라이버가 아닌 스냅샷 컨트롤러 및 CRD와 함께 쿠버네티스 배포판에 의해 설치되어야 한다. 스냅샷 기능이 활성화된 모든 쿠버네티스 클러스터에 설치해야 한다.</li><li>CSI 드라이버에서의 볼륨 스냅샷 기능 유무는 확실하지 않다. 볼륨 스냅샷 서포트를 제공하는 CSI 드라이버는 csi-snapshotter를 사용할 가능성이 높다. 자세한 사항은 <a href=https://kubernetes-csi.github.io/docs/>CSI 드라이버 문서</a>를 확인하면 된다.</li><li>CRDs 및 스냅샷 컨트롤러는 쿠버네티스 배포 시 설치된다.</li></ul><h2 id=볼륨-스냅샷-및-볼륨-스냅샷-컨텐츠의-라이프사이클>볼륨 스냅샷 및 볼륨 스냅샷 컨텐츠의 라이프사이클</h2><p><code>VolumeSnapshotContents</code> 은 클러스터 리소스이다. <code>VolumeSnapshots</code> 은 이러한 리소스의 요청이다. <code>VolumeSnapshotContents</code> 과 <code>VolumeSnapshots</code>의 상호 작용은 다음과 같은 라이프사이클을 따른다.</p><h3 id=프로비저닝-볼륨-스냅샷>프로비저닝 볼륨 스냅샷</h3><p>스냅샷을 프로비저닝할 수 있는 방법에는 사전 프로비저닝 혹은 동적 프로비저닝의 두 가지가 있다: .</p><h4 id=static>사전 프로비전</h4><p>클러스터 관리자는 많은 <code>VolumeSnapshotContents</code> 을 생성한다. 그들은 클러스터 사용자들이 사용 가능한 스토리지 시스템의 실제 볼륨 스냅샷 세부 정보를 제공한다. 이것은 쿠버네티스 API에 있고 사용 가능하다.</p><h4 id=동적>동적</h4><p>사전 프로비저닝을 사용하는 대신 퍼시스턴트볼륨클레임에서 스냅샷을 동적으로 가져오도록 요청할 수 있다. <a href=/ko/docs/concepts/storage/volume-snapshot-classes/>볼륨스냅샷클래스</a>는 스냅샷 사용 시 스토리지 제공자의 특정 파라미터를 명세한다.</p><h3 id=바인딩>바인딩</h3><p>스냅샷 컨트롤러는 사전 프로비저닝과 동적 프로비저닝된 시나리오에서 <code>VolumeSnapshot</code> 오브젝트와 적절한 <code>VolumeSnapshotContent</code> 오브젝트와의 바인딩을 처리한다. 바인딩은 1:1 매핑이다.</p><p>사전 프로비저닝된 경우, 볼륨스냅샷은 볼륨스냅샷컨텐츠 오브젝트 생성이 요청될 때까지 바인드되지 않은 상태로 유지된다.</p><h3 id=스냅샷-소스-보호로서의-퍼시스턴트-볼륨-클레임>스냅샷 소스 보호로서의 퍼시스턴트 볼륨 클레임</h3><p>이 보호의 목적은 스냅샷이 생성되는 동안 사용 중인
<a class=glossary-tooltip title='컨테이너의 볼륨으로 마운트될 수 있도록 퍼시스턴트볼륨(PersistentVolume)에 정의된 스토리지 리소스를 요청한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=퍼시스턴트볼륨클레임>퍼시스턴트볼륨클레임</a>
API 오브젝트가 시스템에서 지워지지 않게 하는 것이다(데이터 손실이 발생할 수 있기 때문에).</p><p>퍼시스턴트볼륨클레임이 스냅샷을 생성할 동안에는 해당 퍼시스턴트볼륨클레임은 사용 중인 상태이다. 스냅샷 소스로 사용 중인 퍼시스턴트볼륨클레임 API 오브젝트를 삭제한다면, 퍼시스턴트볼륨클레임 오브젝트는 즉시 삭제되지 않는다. 대신, 퍼시스턴트볼륨클레임 오브젝트 삭제는 스냅샷이 준비(readyToUse) 혹은 중단(aborted) 상태가 될 때까지 연기된다.</p><h3 id=삭제>삭제</h3><p>삭제는 <code>VolumeSnapshot</code> 를 삭제 시 트리거로 <code>DeletionPolicy</code> 가 실행된다. <code>DeletionPolicy</code> 가 <code>Delete</code> 라면, 기본 스토리지 스냅샷이 <code>VolumeSnapshotContent</code> 오브젝트와 함께 삭제될 것이다. <code>DeletionPolicy</code> 이 <code>Retain</code> 이라면, 기본 스트리지 스냅샷과 <code>VolumeSnapshotContent</code> 둘 다 유지된다.</p><h2 id=볼륨-스냅샷>볼륨 스냅샷</h2><p>각각의 볼륨 스냅샷은 스펙과 상태를 포함한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotClassName</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>persistentVolumeClaimName</span>:<span style=color:#bbb> </span>pvc-test<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>persistentVolumeClaimName</code> 은 스냅샷을 위한 퍼시스턴트볼륨클레임 데이터 소스의 이름이다. 이 필드는 동적 프로비저닝 스냅샷이 필요하다.</p><p>볼륨 스냅샷은 <code>volumeSnapshotClassName</code> 속성을 사용하여
<a href=/ko/docs/concepts/storage/volume-snapshot-classes/>볼륨스냅샷클래스</a>의 이름을 지정하여
특정 클래스를 요청할 수 있다. 아무것도 설정하지 않으면, 사용 가능한 경우 기본 클래스가 사용될 것이다.</p><p>사전 프로비저닝된 스냅샷의 경우, 다음 예와 같이 <code>volumeSnapshotContentName</code>을 스냅샷 소스로 지정해야 한다. 사전 프로비저닝된 스냅샷에는 <code>volumeSnapshotContentName</code> 소스 필드가 필요하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-snapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeSnapshotContentName</span>:<span style=color:#bbb> </span>test-content<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=볼륨-스냅샷-컨텐츠>볼륨 스냅샷 컨텐츠</h2><p>각각의 볼륨스냅샷컨텐츠는 스펙과 상태를 포함한다. 동적 프로비저닝에서는, 스냅샷 공통 컨트롤러는 <code>VolumeSnapshotContent</code> 오브젝트를 생성한다. 예시는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotContent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>snapcontent-72d9a349-aacd-42d2-a240-d775650d2455<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeHandle</span>:<span style=color:#bbb> </span>ee0cfb94-f8d4-11e9-b2d8-0242ac110002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sourceVolumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotClassName</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>72d9a349-aacd-42d2-a240-d775650d2455<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>volumeHandle</code> 은 스토리지 백엔드에서 생성되고 볼륨 생성 중에 CSI 드라이버가 반환하는 볼륨의 고유 식별자이다. 이 필드는 스냅샷을 동적 프로비저닝하는 데 필요하다. 이것은 스냅샷의 볼륨 소스를 지정한다.</p><p>사전 프로비저닝된 스냅샷의 경우, (클러스터 관리자로서) 다음과 같이 <code>VolumeSnapshotContent</code> 오브젝트를 작성해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotContent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-content-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>snapshotHandle</span>:<span style=color:#bbb> </span>7bdd0de3-aaeb-11e8-9aae-0242ac110002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sourceVolumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>snapshotHandle</code> 은 스토리지 백엔드에서 생성된 볼륨 스냅샷의 고유 식별자이다. 이 필드는 사전 프로비저닝된 스냅샷에 필요하다. <code>VolumeSnapshotContent</code> 가 나타내는 스토리지 시스템의 CSI 스냅샷 id를 지정한다.</p><p><code>sourceVolumeMode</code> 은 스냅샷이 생성된 볼륨의 모드를 나타낸다.
<code>sourceVolumeMode</code> 필드의 값은 <code>Filesystem</code> 또는 <code>Block</code> 일 수 있다.
소스 볼륨 모드가 명시되어 있지 않으면,
쿠버네티스는 해당 스냅샷의 소스 볼륨 모드를 알려지지 않은 상태(unknown)로 간주하여 스냅샷을 처리한다.</p><p><code>volumeSnapshotRef</code>은 상응하는 <code>VolumeSnapshot</code>의 참조이다. <code>VolumeSnapshotContent</code>이 이전에 프로비전된 스냅샷으로 생성된 경우, <code>volumeSnapshotRef</code>에서 참조하는 <code>VolumeSnapshot</code>은 아직 존재하지 않을 수도 있음에 주의한다.</p><h2 id=convert-volume-mode>스냅샷의 볼륨 모드 변환하기</h2><p>클러스터에 설치된 <code>VolumeSnapshots</code> API가 <code>sourceVolumeMode</code> 필드를 지원한다면,
인증되지 않은 사용자가 볼륨의 모드를 변경하는 것을 금지하는 기능이
API에 있는 것이다.</p><p>클러스터가 이 기능을 지원하는지 확인하려면, 다음 명령어를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>$ kubectl get crd volumesnapshotcontent -o yaml<span style=color:#bbb>
</span></span></span></code></pre></div><p>사용자가 기존 <code>VolumeSnapshot</code>으로부터 <code>PersistentVolumeClaim</code>을 생성할 때
기존 소스와 다른 볼륨 모드를 지정할 수 있도록 하려면,
<code>VolumeSnapshot</code>와 연관된 <code>VolumeSnapshotContent</code>에
<code>snapshot.storage.kubernetes.io/allowVolumeModeChange: "true"</code> 어노테이션을 추가해야 한다.</p><p>이전에 프로비전된 스냅샷의 경우에는,
클러스터 관리자가 <code>Spec.SourceVolumeMode</code>를 추가해야 한다.</p><p>이 기능이 활성화된 예시 <code>VolumeSnapshotContent</code> 리소스는 다음과 같을 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotContent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-content-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>snapshot.storage.kubernetes.io/allowVolumeModeChange</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>snapshotHandle</span>:<span style=color:#bbb> </span>7bdd0de3-aaeb-11e8-9aae-0242ac110002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sourceVolumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=스냅샷을-위한-프로비저닝-볼륨>스냅샷을 위한 프로비저닝 볼륨</h2><p><code>PersistentVolumeClaim</code> 오브젝트의 <em>dataSource</em> 필드를 사용하여
스냅샷 데이터로 미리 채워진 새 볼륨을 프로비저닝할 수 있다.</p><p>보다 자세한 사항은
<a href=/ko/docs/concepts/storage/persistent-volumes/#%EB%B3%BC%EB%A5%A8-%EC%8A%A4%EB%83%85%EC%83%B7-%EB%B0%8F-%EC%8A%A4%EB%83%85%EC%83%B7-%EC%A7%80%EC%9B%90%EC%97%90%EC%84%9C-%EB%B3%BC%EB%A5%A8-%EB%B3%B5%EC%9B%90>볼륨 스냅샷 및 스냅샷에서 볼륨 복원</a>에서 확인할 수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4d00116c86dade62bdd5be7dc2afa1ca>8 - 볼륨 스냅샷 클래스</h1><p>이 문서는 쿠버네티스의 볼륨스냅샷클래스(VolumeSnapshotClass) 개요를 설명한다.
<a href=/ko/docs/concepts/storage/volume-snapshots/>볼륨 스냅샷</a>과
<a href=/ko/docs/concepts/storage/storage-classes>스토리지 클래스</a>의 숙지를 추천한다.</p><h2 id=소개>소개</h2><p>스토리지클래스(StorageClass)는 관리자가 볼륨을 프로비저닝할 때 제공하는 스토리지의 "클래스"를
설명하는 방법을 제공하는 것처럼, 볼륨스냅샷클래스는 볼륨 스냅샷을
프로비저닝할 때 스토리지의 "클래스"를 설명하는 방법을 제공한다.</p><h2 id=volumesnapshotclass-리소스>VolumeSnapshotClass 리소스</h2><p>각 볼륨스냅샷클래스에는 클래스에 속하는 볼륨스냅샷을
동적으로 프로비전 할 때 사용되는 <code>driver</code>, <code>deletionPolicy</code> 그리고 <code>parameters</code>
필드를 포함한다.</p><p>볼륨스냅샷클래스 오브젝트의 이름은 중요하며, 사용자가 특정
클래스를 요청할 수 있는 방법이다. 관리자는 볼륨스냅샷클래스 오브젝트를
처음 생성할 때 클래스의 이름과 기타 파라미터를 설정하고, 오브젝트가
생성된 이후에는 업데이트할 수 없다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> CRD의 설치는 쿠버네티스 배포판의 책임이다. 필요한 CRD가 존재하지 않는다면, 볼륨스냅샷클래스 생성이 실패할 것이다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span></code></pre></div><p>관리자는<code>snapshot.storage.kubernetes.io/is-default-class: "true"</code> 어노테이션을 추가하여
바인딩할 특정 클래스를 요청하지 않는 볼륨스냅샷에 대한
기본 볼륨스냅샷클래스를 지정할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>snapshot.storage.kubernetes.io/is-default-class</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=드라이버>드라이버</h3><p>볼륨 스냅샷 클래스에는 볼륨스냅샷의 프로비저닝에 사용되는 CSI 볼륨 플러그인을
결정하는 드라이버를 가지고 있다. 이 필드는 반드시 지정해야 한다.</p><h3 id=삭제정책-deletionpolicy>삭제정책(DeletionPolicy)</h3><p>볼륨 스냅샷 클래스는 삭제정책을 가지고 있다. 바인딩된 볼륨스냅샷 오브젝트를 삭제할 때 VolumeSnapshotContent의 상황을 구성할 수 있다. 볼륨 스냅샷 클래스의 삭제정책은 <code>Retain</code> 또는 <code>Delete</code> 일 수 있다. 이 필드는 반드시 지정해야 한다.</p><p>삭제정책이 <code>Delete</code> 인 경우 기본 스토리지 스냅샷이 VolumeSnapshotContent 오브젝트와 함께 삭제된다. 삭제정책이 <code>Retain</code> 인 경우 기본 스냅샷과 VolumeSnapshotContent 모두 유지된다.</p><h2 id=파라미터>파라미터</h2><p>볼륨 스냅샷 클래스에는 볼륨 스냅샷 클래스에 속하는 볼륨 스냅샷을
설명하는 파라미터를 가지고 있다. <code>driver</code> 에 따라 다른 파라미터를 사용할
수 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-707ca81a34eb1ca202f34692e9917d1e>9 - CSI 볼륨 복제하기</h1><p>이 문서에서는 쿠버네티스의 기존 CSI 볼륨 복제의 개념을 설명한다. <a href=/ko/docs/concepts/storage/volumes>볼륨</a>을 숙지하는 것을 추천한다.</p><h2 id=소개>소개</h2><p><a class=glossary-tooltip title='컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 볼륨 복제 기능은 <code>dataSource</code> 필드에 기존 <a class=glossary-tooltip title='컨테이너의 볼륨으로 마운트될 수 있도록 퍼시스턴트볼륨(PersistentVolume)에 정의된 스토리지 리소스를 요청한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=PVC>PVC</a>를 지정하는 지원을 추가해서 사용자가 <a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨(Volume)>볼륨(Volume)</a>을 복제하려는 것을 나타낸다.</p><p>복제는 표준 볼륨처럼 소비할 수 있는 쿠버네티스 볼륨의 복제본으로 정의된다. 유일한 차이점은 프로비저닝할 때 "새" 빈 볼륨을 생성하는 대신에 백엔드 장치가 지정된 볼륨의 정확한 복제본을 생성한다는 것이다.</p><p>쿠버네티스 API의 관점에서 복제를 구현하면 새로운 PVC 생성 중에 기존 PVC를 데이터 소스로 지정할 수 있는 기능이 추가된다. 소스 PVC는 바인딩되어 있고, 사용 가능해야 한다(사용 중이 아니어야 함).</p><p>사용자는 이 기능을 사용할 때 다음 사항을 알고 있어야 한다.</p><ul><li>복제 지원(<code>VolumePVCDataSource</code>)은 CSI 드라이버에서만 사용할 수 있다.</li><li>복제 지원은 동적 프로비저너만 사용할 수 있다.</li><li>CSI 드라이버는 볼륨 복제 기능을 구현했거나 구현하지 않았을 수 있다.</li><li>PVC는 대상 PVC와 동일한 네임스페이스에 있는 경우에만 복제할 수 있다(소스와 대상은 동일한 네임스페이스에 있어야 함).</li><li>복제는 서로 다른 스토리지 클래스에 대해서도 지원된다.<ul><li>대상 볼륨은 소스와 동일하거나 다른 스토리지 클래스여도 된다.</li><li>기본 스토리지 클래스를 사용할 수 있으며, 사양에 storageClassName을 생략할 수 있다.</li></ul></li><li>동일한 VolumeMode 설정을 사용하는 두 볼륨에만 복제를 수행할 수 있다(블록 모드 볼륨을 요청하는 경우에는 반드시 소스도 블록 모드여야 한다).</li></ul><h2 id=프로비저닝>프로비저닝</h2><p>동일한 네임스페이스에서 기존 PVC를 참조하는 dataSource를 추가하는 것을 제외하고는 다른 PVC와 마찬가지로 복제가 프로비전된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-of-pvc-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>myns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>cloning<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-1<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>spec.resources.requests.storage</code> 에 용량 값을 지정해야 하며, 지정한 값은 소스 볼륨의 용량과 같거나 또는 더 커야 한다.</div><p>그 결과로 지정된 소스 <code>pvc-1</code> 과 동일한 내용을 가진 <code>clone-of-pvc-1</code> 이라는 이름을 가지는 새로운 PVC가 생겨난다.</p><h2 id=사용>사용</h2><p>새 PVC를 사용할 수 있게 되면, 복제된 PVC는 다른 PVC와 동일하게 소비된다. 또한, 이 시점에서 새롭게 생성된 PVC는 독립된 오브젝트이다. 원본 dataSource PVC와는 무관하게 독립적으로 소비하고, 복제하고, 스냅샷의 생성 또는 삭제를 할 수 있다. 이는 소스가 새롭게 생성된 복제본에 어떤 방식으로든 연결되어 있지 않으며, 새롭게 생성된 복제본에 영향 없이 수정하거나, 삭제할 수도 있는 것을 의미한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-00cd24f4570b7acaac75c2551c948bc7>10 - 스토리지 용량</h1><p>스토리지 용량은 제한이 있으며, 파드가 실행되는 노드의 상황에 따라 달라질 수 있다.
예를 들어, 일부 노드에서 NAS(Network Attached Storage)에 접근할 수 없는 경우가 있을 수 있으며,
또는 각 노드에 종속적인 로컬 스토리지를 사용하는 경우일 수도 있다.</p><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [stable]</code></div><p>이 페이지에서는 쿠버네티스가 어떻게 스토리지 용량을 추적하고
스케줄러가 남아 있는 볼륨을 제공하기 위해 스토리지 용량이 충분한 노드에
<a href=/ko/docs/concepts/scheduling-eviction/>파드를 스케줄링</a>하기 위해 이 정보를 어떻게 사용하는지 설명한다.
스토리지 용량을 추적하지 않으면, 스케줄러는
볼륨을 제공할 충분한 용량이 없는 노드를 선정할 수 있으며,
스케줄링을 여러 번 다시 시도해야 한다.</p><h2 id=시작하기-전에>시작하기 전에</h2><p>쿠버네티스 v1.25 버전은 스토리지 용량 추적을 위한 클러스터-수준 API를 지원한다.
이를 사용하려면, 스토리지 용량 추적을 지원하는 CSI 드라이버를 사용하고 있어야 한다.
사용 중인 CSI 드라이버가 이를 지원하는지, 지원한다면 어떻게 사용하는지를 알아보려면
해당 CSI 드라이버의 문서를 참고한다.
쿠버네티스 v1.25 버전을 사용하고 있지 않다면,
해당 버전 쿠버네티스 문서를 참고한다.</p><h2 id=api>API</h2><p>이 기능에는 다음 두 가지 API 확장이 있다.</p><ul><li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/csi-storage-capacity-v1/>CSIStorageCapacity</a> 오브젝트:
CSI 드라이버가 설치된 네임스페이스에
CSI 드라이버가 이 오브젝트를 생성한다. 각 오브젝트는
하나의 스토리지 클래스에 대한 용량 정보를 담고 있으며,
어떤 노드가 해당 스토리지에 접근할 수 있는지를 정의한다.</li><li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/csi-driver-v1/#CSIDriverSpec><code>CSIDriverSpec.StorageCapacity</code> 필드</a>:
<code>true</code>로 설정하면, 쿠버네티스 스케줄러가
CSI 드라이버를 사용하는 볼륨의 스토리지 용량을 고려하게 된다.</li></ul><h2 id=스케줄링>스케줄링</h2><p>다음과 같은 경우 쿠버네티스 스케줄러에서 스토리지 용량 정보를 사용한다.</p><ul><li>파드가 아직 생성되지 않은 볼륨을 사용하고,</li><li>해당 볼륨은 CSI 드라이버를 참조하고
<code>WaitForFirstConsumer</code>
<a href=/ko/docs/concepts/storage/storage-classes/#%EB%B3%BC%EB%A5%A8-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%AA%A8%EB%93%9C>볼륨 바인딩 모드</a>를 사용하는
<a class=glossary-tooltip title='스토리지클래스는 관리자가 사용 가능한 다양한 스토리지 유형을 설명할 수 있는 방법을 제공한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/storage-classes target=_blank aria-label=스토리지클래스(StorageClass)>스토리지클래스(StorageClass)</a>를 사용하고,</li><li>드라이버의 <code>CSIDriver</code> 오브젝트에 <code>StorageCapacity</code> 속성이
true로 설정되어 있다.</li></ul><p>이 경우 스케줄러는 파드에 제공할
충분한 스토리지가 있는 노드만 고려한다.
이 검사는 아주 간단한데,
볼륨의 크기를 노드를 포함하는 토폴로지를 가진 <code>CSIStorageCapacity</code> 오브젝트에
나열된 용량과 비교한다.</p><p>볼륨 바인딩 모드가 <code>Immediate</code> 인 볼륨의 경우에는 스토리지 드라이버는
볼륨을 사용하는 파드와 관계없이 볼륨을 생성할 위치를 정한다.
볼륨을 생성한 후에, 스케줄러는
볼륨을 사용할 수 있는 노드에 파드를 스케줄링한다.</p><p><a href=/ko/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>CSI 임시 볼륨</a>의 경우에는
볼륨 유형이 로컬 볼륨이고
큰 자원이 필요하지 않은 특정 CSI 드라이버에서만 사용된다는 가정하에,
항상 스토리지 용량을 고려하지 않고
스케줄링한다.</p><h2 id=리스케줄링>리스케줄링</h2><p><code>WaitForFirstConsumer</code> 볼륨을 가진 파드에 대해
노드가 선정되었더라도 아직은 잠정적인 결정이다. 다음 단계에서
선정한 노드에서 볼륨을 사용할 수 있어야 한다는 힌트를 주고
CSI 스토리지 드라이버에 볼륨 생성을 요청한다</p><p>쿠버네티스는 시간이 지난 스토리지 용량 정보를 기반으로
노드를 선정할 수도 있으므로, 볼륨을 실제로 생성하지 않을 수도 있다.
그런 다음 노드 선정이 재설정되고 쿠버네티스 스케줄러가
파드를 위한 노드를 찾는 것을 재시도한다.</p><h2 id=제한사항>제한사항</h2><p>스토리지 용량 추적은 첫 시도에 스케줄링이 성공할 가능성을 높이지만,
스케줄러가 시간이 지난 정보를 기반으로
결정해야 할 수도 있기 때문에 이를 보장하지는 않는다.
일반적으로 스토리지 용량 정보가 없는 스케줄링과
동일한 재시도 메커니즘으로 스케줄링 실패를 처리한다.</p><p>스케줄링이 영구적으로 실패할 수 있는 한 가지 상황은
파드가 여러 볼륨을 사용하는 경우이다.
토폴로지 세그먼트에 하나의 볼륨이 이미 생성되어
다른 볼륨에 충분한 용량이 남아 있지 않을 수 있다.
이러한 상황을 복구하려면
용량을 늘리거나 이미 생성된 볼륨을 삭제하는 등의 수작업이 필요하다.</p><h2 id=다음-내용>다음 내용</h2><ul><li>설계에 대한 자세한 내용은
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1472-storage-capacity-tracking/README.md>파드 스케줄링 스토리지 용량 제약 조건</a>을 참조한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b2e4b16ac37988c678a3312a4a6639f8>11 - 노드 별 볼륨 한도</h1><p>이 페이지는 다양한 클라우드 공급자들이 제공하는 노드에 연결할 수 있는
최대 볼륨 수를 설명한다.</p><p>Google, Amazon 그리고 Microsoft와 같은 클라우드 공급자는 일반적으로 노드에
연결할 수 있는 볼륨 수에 제한이 있다. 쿠버네티스가 이러한 제한을
준수하는 것은 중요하다. 그렇지 않으면, 노드에서 예약된 파드가 볼륨이
연결될 때까지 멈추고 기다릴 수 있다.</p><h2 id=쿠버네티스-기본-한도>쿠버네티스 기본 한도</h2><p>쿠버네티스 스케줄러에는 노드에 연결될 수 있는 볼륨 수에 대한
기본 한도가 있다.</p><table><tr><th>클라우드 서비스</th><th>노드 당 최대 볼륨</th></tr><tr><td><a href=https://aws.amazon.com/ebs/>Amazon Elastic Block Store (EBS)</a></td><td>39</td></tr><tr><td><a href=https://cloud.google.com/persistent-disk/>Google Persistent Disk</a></td><td>16</td></tr><tr><td><a href=https://azure.microsoft.com/ko-kr/services/storage/main-disks/>Microsoft Azure Disk Storage</a></td><td>16</td></tr></table><h2 id=사용자-정의-한도>사용자 정의 한도</h2><p><code>KUBE_MAX_PD_VOLS</code> 환경 변수의 값을 설정한 후,
스케줄러를 시작하여 이러한 한도를 변경할 수 있다.
CSI 드라이버는 절차가 다를 수 있으므로, 한도를 사용자 정의하는
방법에 대한 문서를 참고한다.</p><p>기본 한도보다 높은 한도를 설정한 경우 주의한다. 클라우드
공급자의 문서를 참조하여 노드가 실제로 사용자가 설정한 한도를
지원할 수 있는지 확인한다.</p><p>한도는 전체 클러스터에 적용되므로, 모든 노드에 영향을 준다.</p><h2 id=동적-볼륨-한도>동적 볼륨 한도</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.17 [stable]</code></div><p>다음 볼륨 유형에 대해 동적 볼륨 한도가 지원된다.</p><ul><li>Amazon EBS</li><li>Google Persistent Disk</li><li>Azure Disk</li><li>CSI</li></ul><p>인-트리(in-tree) 볼륨 플러그인으로 관리되는 볼륨의 경우, 쿠버네티스는 자동으로 노드 유형을
결정하고 노드에 적절한 최대 볼륨 수를 적용한다. 예를 들면, 다음과 같다.</p><ul><li><p><a href=https://cloud.google.com/compute/>Google Compute Engine</a>에서는,
<a href=https://cloud.google.com/compute/docs/disks/#pdnumberlimits>노드 유형에 따라</a>
최대 127개의 볼륨까지
노드에 연결할 수 있다.</p></li><li><p>M5, C5, R5, T3와 Z1D 인스턴스 유형의 Amazon EBS 디스크의 경우, 쿠버네티스는 25개의 볼륨만 노드에
연결할 수 있도록 허용한다.
<a href=https://aws.amazon.com/ec2/>Amazon Elastic Compute Cloud (EC2)</a>의
다른 인스턴스 유형의 경우, 쿠버네티스는 노드에 39개의 볼륨을 연결할 수 있도록 허용한다.</p></li><li><p>Azure에서는, 노드 유형에 따라 최대 64개의 디스크를 노드에 연결할 수 있다. 더 자세한 내용은 <a href=https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/sizes>Azure의 가상 머신 크기</a>를 참고한다.</p></li><li><p>CSI 스토리지 드라이버가 <code>NodeGetInfo</code> 를 사용해서 노드에 대한 최대 볼륨 수를 알린다면, <a class=glossary-tooltip title='노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>는 그 한도를 따른다.</p></li></ul><p>자세한 내용은 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#nodegetinfo>CSI 명세</a>를 참고한다.</p><ul><li>CSI 드라이버로 마이그레이션된 인-트리 플러그인으로 관리되는 볼륨의 경우, 최대 볼륨 수는 CSI 드라이버가 보고한 개수이다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4f40cb95a671e51b4f0156a409d95c6d>12 - 볼륨 헬스 모니터링</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [alpha]</code></div><p><a class=glossary-tooltip title='컨테이너 스토리지 인터페이스(CSI)는 컨테이너에 스토리지 시스템을 노출하는 표준 인터페이스를 정의한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 볼륨 헬스 모니터링을 통해 CSI 드라이버는 기본 스토리지 시스템에서 비정상적인 볼륨 상태를 감지하고 이를 <a class=glossary-tooltip title='컨테이너의 볼륨으로 마운트될 수 있도록 퍼시스턴트볼륨(PersistentVolume)에 정의된 스토리지 리소스를 요청한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=PVC>PVC</a> 또는 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>의 이벤트로 보고한다.</p><h2 id=볼륨-헬스-모니터링>볼륨 헬스 모니터링</h2><p>쿠버네티스 <em>볼륨 헬스 모니터링</em> 은 쿠버네티스가 CSI(Container Storage Interface)를 구현하는 방법의 일부다. 볼륨 헬스 모니터링 기능은 외부 헬스 모니터 컨트롤러와 <a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>, 2가지 컴포넌트로 구현된다.</p><p>CSI 드라이버가 컨트롤러 측의 볼륨 헬스 모니터링 기능을 지원하는 경우, CSI 볼륨에서 비정상적인 볼륨 상태가 감지될 때 관련 <a class=glossary-tooltip title='컨테이너의 볼륨으로 마운트될 수 있도록 퍼시스턴트볼륨(PersistentVolume)에 정의된 스토리지 리소스를 요청한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=퍼시스턴트볼륨클레임>퍼시스턴트볼륨클레임</a>(PersistentVolumeClaim, PVC) 이벤트가 보고된다.</p><p>외부 헬스 모니터 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는 노드 장애 이벤트도 감시한다. <code>enable-node-watcher</code> 플래그를 true로 설정하여 노드 장애 모니터링을 활성화할 수 있다. 외부 헬스 모니터가 노드 장애 이벤트를 감지하면, 컨트롤러는 이 PVC를 사용하는 파드가 장애 상태인 노드에 있음을 나타내는 이벤트가 PVC에 보고된다고 알린다.</p><p>CSI 드라이버가 노드 측에서 볼륨 헬스 모니터링 기능을 지원하는 경우, CSI 볼륨에서 비정상적인 볼륨 상태가 감지되면 PVC를 사용하는 모든 파드에서 이벤트가 보고된다. 그리고, 볼륨 헬스 정보는 kubelet VolumeStats 메트릭 형태로 노출된다. 새로운 kubelet_volume_stats_health_status_abnormal 메트릭이 추가되었다. 이 메트릭은 <code>namespace</code> 및 <code>persistentvolumeclaim</code> 2개의 레이블을 포함한다. 카운터는 1 또는 0이다. 카운터가 1이면 볼륨이 정상적이지 않음을, 0이면 정상적임을 의미한다. 더 많은 정보는 <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1432-volume-health-monitor#kubelet-metrics-changes>KEP</a>를 참고한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 노드 측에서 이 기능을 사용하려면 <code>CSIVolumeHealth</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.</div><h2 id=다음-내용>다음 내용</h2><p>이 기능을 구현한 CSI 드라이버를 확인하려면 <a href=https://kubernetes-csi.github.io/docs/drivers.html>CSI 드라이버 문서</a>를 참고한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-055a8df536f8ba8f3aa0217bd2db5437>13 - 윈도우 스토리지</h1><p>이 페이지는 윈도우 운영 체제에서의 스토리지 개요를 제공한다.</p><h2 id=storage>퍼시스턴트 스토리지</h2><p>윈도우는 계층 구조의 파일시스템 드라이버를 사용하여
컨테이너 레이어를 마운트하고 NTFS 기반 파일시스템의 복제본을 생성한다.
컨테이너 내의 모든 파일 경로는 해당 컨테이너 컨텍스트 내에서만 인식 가능하다.</p><ul><li>도커를 사용할 때, 볼륨 마운트는 컨테이너 내의 디렉토리로만 지정할 수 있으며, 개별 파일로는 지정할 수 없다.
이 제약 사항은 containerd에는 적용되지 않는다.</li><li>볼륨 마운트는 파일 또는 디렉토리를 호스트 파일시스템으로 투영(project)할 수 없다.</li><li>윈도우 레지스트리와 SAM 데이터케이스에 쓰기 권한이 항상 필요하기 때문에,
읽기 전용 파일시스템은 지원되지 않는다. 다만, 읽기 전용 볼륨은 지원된다.</li><li>볼륨 사용자-마스크 및 퍼미션은 사용할 수 있다.
호스트와 컨테이너 간에 SAM이 공유되지 않기 때문에, 둘 간의 매핑이 존재하지 않는다.
모든 퍼미션은 해당 컨테이너 컨텍스트 내에서만 처리된다.</li></ul><p>결과적으로, 윈도우 노드에서는 다음 스토리지 기능이 지원되지 않는다.</p><ul><li>볼륨 서브패스(subpath) 마운트: 윈도우 컨테이너에는 전체 볼륨만 마운트할 수 있다.</li><li>시크릿을 위한 서브패스 볼륨 마운팅</li><li>호스트 마운트 투영(projection)</li><li>읽기 전용 루트 파일시스템 (매핑된 볼륨은 여전히 <code>readOnly</code>를 지원한다)</li><li>블록 디바이스 매핑</li><li>메모리를 스토리지 미디어로 사용하기 (예를 들어, <code>emptyDir.medium</code>를 <code>Memory</code>로 설정하는 경우)</li><li>uid/gid, 사용자 별 리눅스 파일시스템 권한과 같은 파일시스템 기능</li><li><a href=/ko/docs/concepts/configuration/secret/#%EC%8B%9C%ED%81%AC%EB%A6%BF-%ED%8C%8C%EC%9D%BC-%ED%8D%BC%EB%AF%B8%EC%85%98>DefaultMode을 이용하여 시크릿 퍼미션</a> 설정하기 (UID/GID 의존성 때문에)</li><li>NFS 기반 스토리지/볼륨 지원</li><li>마운트된 볼륨 확장하기 (resizefs)</li></ul><p>쿠버네티스 <a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>을 사용하여
데이터 지속성(persistence) 및 파드 볼륨 공유 요구 사항이 있는
복잡한 애플리케이션을 쿠버네티스에 배포할 수 있다.
특정 스토리지 백엔드 또는 프로토콜과 연관된 퍼시스턴트 볼륨의 관리는
볼륨 프로비저닝/디프로비저닝/리사이징,
쿠버네티스 노드로의 볼륨 연결(attaching) 및 해제(detaching),
데이터를 보존해야 하는 파드 내 개별 컨테이너로의 볼륨 마운트 및 해제 같은 동작을 포함한다.</p><p>볼륨 관리 구성 요소는 쿠버네티스 볼륨
<a href=/ko/docs/concepts/storage/volumes/#volume-types>플러그인</a> 형태로 제공된다.
윈도우는 다음의 광역 쿠버네티스 볼륨 플러그인 클래스를 지원한다.</p><ul><li><a href=/ko/docs/concepts/storage/volumes/#flexvolume-deprecated><code>FlexVolume 플러그인</code></a><ul><li>FlexVolumes은 1.23부터 사용 중단되었음에 유의한다.</li></ul></li><li><a href=/ko/docs/concepts/storage/volumes/#csi><code>CSI 플러그인</code></a></li></ul><h5 id=인-트리-in-tree-볼륨-플러그인>인-트리(In-tree) 볼륨 플러그인</h5><p>다음의 인-트리 플러그인은 윈도우 노드에서의 퍼시스턴트 스토리지를 지원한다.</p><ul><li><a href=/ko/docs/concepts/storage/volumes/#awselasticblockstore><code>awsElasticBlockStore</code></a></li><li><a href=/ko/docs/concepts/storage/volumes/#azuredisk><code>azureDisk</code></a></li><li><a href=/ko/docs/concepts/storage/volumes/#azurefile><code>azureFile</code></a></li><li><a href=/ko/docs/concepts/storage/volumes/#gcepersistentdisk><code>gcePersistentDisk</code></a></li><li><a href=/ko/docs/concepts/storage/volumes/#vspherevolume><code>vsphereVolume</code></a></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>