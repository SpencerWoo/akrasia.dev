<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/extend-kubernetes/compute-storage-net/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/extend-kubernetes/compute-storage-net/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/extend-kubernetes/compute-storage-net/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/compute-storage-net/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/extend-kubernetes/compute-storage-net/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>컴퓨트, 스토리지 및 네트워킹 익스텐션 | Kubernetes</title><meta property="og:title" content="컴퓨트, 스토리지 및 네트워킹 익스텐션"><meta property="og:description" content="운영 수준의 컨테이너 오케스트레이션"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/extend-kubernetes/compute-storage-net/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="컴퓨트, 스토리지 및 네트워킹 익스텐션"><meta itemprop=description content="운영 수준의 컨테이너 오케스트레이션"><meta name=twitter:card content="summary"><meta name=twitter:title content="컴퓨트, 스토리지 및 네트워킹 익스텐션"><meta name=twitter:description content="운영 수준의 컨테이너 오케스트레이션"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/extend-kubernetes/compute-storage-net/"><meta property="og:title" content="컴퓨트, 스토리지 및 네트워킹 익스텐션"><meta name=twitter:title content="컴퓨트, 스토리지 및 네트워킹 익스텐션"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/extend-kubernetes/compute-storage-net/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/extend-kubernetes/compute-storage-net/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/extend-kubernetes/compute-storage-net/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/concepts/extend-kubernetes/compute-storage-net/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/concepts/extend-kubernetes/compute-storage-net/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/extend-kubernetes/compute-storage-net/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/>中文 (Chinese)</a>
<a class=dropdown-item href=/fr/docs/concepts/extend-kubernetes/compute-storage-net/>Français (French)</a>
<a class=dropdown-item href=/es/docs/concepts/extend-kubernetes/compute-storage-net/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/extend-kubernetes/compute-storage-net/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/extend-kubernetes/compute-storage-net/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>컴퓨트, 스토리지 및 네트워킹 익스텐션</h1><ul><li>1: <a href=#pg-1ac2260db9ecccbf0303a899bc27ce6d>네트워크 플러그인</a></li><li>2: <a href=#pg-53e1ea8892ceca307ba19e8d6a7b8d32>장치 플러그인</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-1ac2260db9ecccbf0303a899bc27ce6d>1 - 네트워크 플러그인</h1><p>쿠버네티스 1.25 버전은 클러스터 네트워킹을 위해 <a href=https://github.com/containernetworking/cni>컨테이너 네트워크 인터페이스</a>(CNI) 플러그인을 지원한다.
클러스터와 호환되며 사용자의 요구 사항을 충족하는 CNI 플러그인을 사용해야 한다. 더 넓은 쿠버네티스 생태계에 다양한 플러그인이 존재한다(오픈소스 및 클로즈드 소스).</p><p>CNI 플러그인은 <a href=/ko/docs/concepts/services-networking/#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%AA%A8%EB%8D%B8>쿠버네티스 네트워크 모델</a>을 구현해야 한다.</p><p><a href=https://github.com/containernetworking/cni/blob/spec-v0.4.0/SPEC.md>v0.4.0</a> 이상의
CNI 스펙과 호환되는 CNI 플러그인을 사용해야 한다.
쿠버네티스 플러그인은
CNI 스펙 <a href=https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md>v1.0.0</a>과 호환되는
플러그인의 사용을 권장한다(플러그인은 여러 스펙 버전과 호환 가능).</p><h2 id=설치>설치</h2><p>네트워킹 컨텍스트에서 컨테이너 런타임은 kubelet을 위한 CRI 서비스를 제공하도록 구성된 노드의 데몬이다. 특히, 컨테이너 런타임은 쿠버네티스 네트워크 모델을 구현하는 데 필요한 CNI 플러그인을 로드하도록 구성되어야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>쿠버네티스 1.24 이전까지는 <code>cni-bin-dir</code>과 <code>network-plugin</code> 커맨드 라인 파라미터를 사용해 kubelet이 CNI 플러그인을 관리하게 할 수도 있었다.
이 커맨드 라인 파라미터들은 쿠버네티스 1.24에서 제거되었으며, CNI 관리는 더 이상 kubelet 범위에 포함되지 않는다.</p><p>도커심 제거 후 문제가 발생하는 경우
<a href=/docs/tasks/administer-cluster/migrating-from-dockershim/troubleshooting-cni-plugin-related-errors/>CNI 플러그인 관련 오류 문제 해결</a>을 참조하자.</p></div><p>컨테이너 런타임에서 CNI 플러그인을 관리하는 방법에 관한 자세한 내용은 아래 예시와 같은 컨테이너 런타임에 대한 문서를 참조하자.</p><ul><li><a href=https://github.com/containerd/containerd/blob/main/script/setup/install-cni>containerd</a></li><li><a href=https://github.com/cri-o/cri-o/blob/main/contrib/cni/README.md>CRI-O</a></li></ul><p>CNI 플러그인을 설치하고 관리하는 방법에 관한 자세한 내용은 해당 플러그인 또는 <a href=/ko/docs/concepts/cluster-administration/networking/#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95>네트워킹 프로바이더</a> 문서를 참조한다.</p><h2 id=네트워크-플러그인-요구-사항>네트워크 플러그인 요구 사항</h2><p>쿠버네티스를 빌드하거나 배포하는 플러그인 개발자와 사용자들을 위해, 플러그인은 kube-proxy를 지원하기 위한 특정 설정이 필요할 수도 있다.
iptables 프록시는 iptables에 의존하며, 플러그인은 컨테이너 트래픽이 iptables에 사용 가능하도록 해야 한다.
예를 들어, 플러그인이 컨테이너를 리눅스 브릿지에 연결하는 경우, 플러그인은 <code>net/bridge/bridge-nf-call-iptables</code> sysctl을 <code>1</code> 로 설정하여 iptables 프록시가 올바르게 작동하는지 확인해야 한다.
플러그인이 Linux 브리지를 사용하지 않고 대신 Open vSwitch나 다른 메커니즘을 사용하는 경우, 컨테이너 트래픽이 프록시에 대해 적절하게 라우팅되도록 해야 한다.</p><p>kubelet 네트워크 플러그인이 지정되지 않은 경우, 기본적으로 <code>noop</code> 플러그인이 사용되며, <code>net/bridge/bridge-nf-call-iptables=1</code> 을 설정하여 간단한 구성(브릿지가 있는 도커 등)이 iptables 프록시에서 올바르게 작동하도록 한다.</p><h3 id=루프백-cni>루프백 CNI</h3><p>쿠버네티스 네트워크 모델을 구현하기 위해 노드에 설치된 CNI 플러그인 외에도, 쿠버네티스는 각 샌드박스(파드 샌드박스, VM 샌드박스 등)에 사용되는 루프백 인터페이스 <code>lo</code>를 제공하기 위한 컨테이너 런타임도 요구한다.
루프백 인터페이스 구현은 <a href=https://github.com/containernetworking/plugins/blob/master/plugins/main/loopback/loopback.go>CNI 루프백 플러그인</a>을 재사용하거나 자체 코드를 개발하여 수행할 수 있다. (<a href=https://github.com/cri-o/ocicni/blob/release-1.24/pkg/ocicni/util_linux.go#L91>CRI-O 예시 참조</a>)</p><h3 id=hostport-지원>hostPort 지원</h3><p>CNI 네트워킹 플러그인은 <code>hostPort</code> 를 지원한다. CNI 플러그인 팀이 제공하는 공식 <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/portmap>포트맵(portmap)</a>
플러그인을 사용하거나 portMapping 기능이 있는 자체 플러그인을 사용할 수 있다.</p><p><code>hostPort</code> 지원을 사용하려면, <code>cni-conf-dir</code> 에 <code>portMappings capability</code> 를 지정해야 한다.
예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;portmap&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;portMappings&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=트래픽-셰이핑-shaping-지원>트래픽 셰이핑(shaping) 지원</h3><p><strong>실험적인 기능입니다</strong></p><p>CNI 네트워킹 플러그인은 파드 수신 및 송신 트래픽 셰이핑도 지원한다. CNI 플러그인 팀에서 제공하는 공식 <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/bandwidth>대역폭(bandwidth)</a>
플러그인을 사용하거나 대역폭 제어 기능이 있는 자체 플러그인을 사용할 수 있다.</p><p>트래픽 셰이핑 지원을 활성화하려면, CNI 구성 파일 (기본값 <code>/etc/cni/net.d</code>)에 <code>bandwidth</code> 플러그인을
추가하고, 바이너리가 CNI 실행 파일 디렉터리(기본값: <code>/opt/cni/bin</code>)에 포함되어 있는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;bandwidth&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;bandwidth&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이제 파드에 <code>kubernetes.io/ingress-bandwidth</code> 와 <code>kubernetes.io/egress-bandwidth</code> 어노테이션을 추가할 수 있다.
예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/ingress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/egress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-53e1ea8892ceca307ba19e8d6a7b8d32>2 - 장치 플러그인</h1><div class=lead>장치 플러그인을 사용하여 GPU, NIC, FPGA, 또는 비휘발성 주 메모리와 같이 공급 업체별 설정이 필요한 장치 또는 리소스를 클러스터에서 지원하도록 설정할 수 있다.</div><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.10 [beta]</code></div><p>쿠버네티스는 시스템 하드웨어 리소스를 <a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>에 알리는 데 사용할 수 있는
<a href=https://git.k8s.io/design-proposals-archive/resource-management/device-plugin.md>장치 플러그인 프레임워크</a>를
제공한다.</p><p>공급 업체는 쿠버네티스 자체의 코드를 커스터마이징하는 대신, 수동 또는
<a class=glossary-tooltip title='파드의 복제본을 클러스터 노드 집합에서 동작하게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋>데몬셋</a>으로 배포하는 장치 플러그인을 구현할 수 있다.
대상이 되는 장치에는 GPU, 고성능 NIC, FPGA, InfiniBand 어댑터
및 공급 업체별 초기화 및 설정이 필요할 수 있는 기타 유사한 컴퓨팅 리소스가
포함된다.</p><h2 id=장치-플러그인-등록>장치 플러그인 등록</h2><p>kubelet은 <code>Registration</code> gRPC 서비스를 노출시킨다.</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>service Registration {
	rpc Register(RegisterRequest) returns (Empty) {}
}
</code></pre><p>장치 플러그인은 이 gRPC 서비스를 통해 kubelet에 자체 등록할 수 있다.
등록하는 동안, 장치 플러그인은 다음을 보내야 한다.</p><ul><li>유닉스 소켓의 이름.</li><li>빌드된 장치 플러그인 API 버전.</li><li>알리려는 <code>ResourceName</code>. 여기서 <code>ResourceName</code> 은
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#%ED%99%95%EC%9E%A5%EB%90%9C-%EB%A6%AC%EC%86%8C%EC%8A%A4>확장된 리소스 네이밍 체계</a>를
<code>vendor-domain/resourcetype</code> 의 형식으로 따라야 한다.
(예를 들어, NVIDIA GPU는 <code>nvidia.com/gpu</code> 로 알려진다.)</li></ul><p>성공적으로 등록하고 나면, 장치 플러그인은 kubelet이 관리하는
장치 목록을 전송한 다음, kubelet은 kubelet 노드 상태 업데이트의 일부로
해당 자원을 API 서버에 알리는 역할을 한다.
예를 들어, 장치 플러그인이 kubelet에 <code>hardware-vendor.example/foo</code> 를 등록하고
노드에 두 개의 정상 장치를 보고하고 나면, 노드 상태가 업데이트되어
노드에 2개의 "Foo" 장치가 설치되어 사용 가능함을 알릴 수 있다.</p><p>그러고 나면, 사용자가 장치를 파드 스펙의 일부로 요청할 수
있다(<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container><code>container</code></a> 참조).
확장 리소스를 요청하는 것은 다른 자원의 요청 및 제한을 관리하는 것과 비슷하지만,
다음과 같은 차이점이 존재한다.</p><ul><li>확장된 리소스는 정수(integer) 형태만 지원되며 오버커밋(overcommit) 될 수 없다.</li><li>컨테이너간에 장치를 공유할 수 없다.</li></ul><h3 id=example-pod>예제</h3><p>쿠버네티스 클러스터가 특정 노드에서 <code>hardware-vendor.example/foo</code> 리소스를 알리는 장치 플러그인을 실행한다고
가정해 보자. 다음은 데모 워크로드를 실행하기 위해 이 리소스를 요청하는 파드의 예이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-container-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/pause:2.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>hardware-vendor.example/foo</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 이 파드는 2개의 hardware-vendor.example/foo 장치가 필요하며</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 해당 요구를 충족할 수 있는 노드에만</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 예약될 수 있다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 노드에 2개 이상의 사용 가능한 장치가 있는 경우</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 나머지는 다른 파드에서 사용할 수 있다.</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=장치-플러그인-구현>장치 플러그인 구현</h2><p>장치 플러그인의 일반적인 워크플로우에는 다음 단계가 포함된다.</p><ul><li><p>초기화. 이 단계에서, 장치 플러그인은 공급 업체별 초기화 및 설정을 수행하여
장치가 준비 상태에 있는지 확인한다.</p></li><li><p>플러그인은 다음의 인터페이스를 구현하는 호스트 경로 <code>/var/lib/kubelet/device-plugins/</code>
아래에 유닉스 소켓과 함께 gRPC 서비스를 시작한다.</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>service DevicePlugin {
  	    // GetDevicePluginOptions는 장치 관리자와 통신할 옵션을 반환한다.
      rpc GetDevicePluginOptions(Empty) returns (DevicePluginOptions) {}

  		// ListAndWatch는 장치 목록 스트림을 반환한다.
  	    // 장치 상태가 변경되거나 장치가 사라질 때마다, ListAndWatch는
  	    // 새 목록을 반환한다.
      rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) {}

  			// 컨테이너를 생성하는 동안 Allocate가 호출되어 장치
  			// 플러그인이 장치별 작업을 실행하고 Kubelet에 장치를
  			// 컨테이너에서 사용할 수 있도록 하는 단계를 지시할 수 있다.
      rpc Allocate(AllocateRequest) returns (AllocateResponse) {}

      // GetPreferredAllocation은 사용 가능한 장치 목록에서 할당할
  			// 기본 장치 집합을 반환한다. 그 결과로 반환된 선호하는 할당은
  			// devicemanager가 궁극적으로 수행하는 할당이 되는 것을 보장하지
  			// 않는다. 가능한 경우 devicemanager가 정보에 입각한 할당 결정을
  			// 내릴 수 있도록 설계되었다.
      rpc GetPreferredAllocation(PreferredAllocationRequest) returns (PreferredAllocationResponse) {}

      // PreStartContainer는 등록 단계에서 장치 플러그인에 의해 표시되면 각 컨테이너가
  			// 시작되기 전에 호출된다. 장치 플러그인은 장치를 컨테이너에서 사용할 수 있도록 하기 전에
  			// 장치 재설정과 같은 장치별 작업을 실행할 수 있다.
      rpc PreStartContainer(PreStartContainerRequest) returns (PreStartContainerResponse) {}
}
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>GetPreferredAllocation()</code> 또는 <code>PreStartContainer()</code> 에 대한 유용한 구현을
제공하기 위해 플러그인이 필요하지 않다. 이러한 호출(있는 경우) 중
사용할 수 있는 경우를 나타내는 플래그는 <code>GetDevicePluginOptions()</code>
호출에 의해 다시 전송된 <code>DevicePluginOptions</code> 메시지에 설정되어야 한다. <code>kubelet</code> 은
항상 <code>GetDevicePluginOptions()</code> 를 호출하여 사용할 수 있는
선택적 함수를 확인한 후 직접 호출한다.</div></li><li><p>플러그인은 호스트 경로 <code>/var/lib/kubelet/device-plugins/kubelet.sock</code> 에서
유닉스 소켓을 통해 kubelet에 직접 등록한다.</p></li><li><p>성공적으로 등록하고 나면, 장치 플러그인은 서빙(serving) 모드에서 실행되며, 그 동안 플러그인은 장치 상태를
모니터링하고 장치 상태 변경 시 kubelet에 다시 보고한다.
또한 gRPC 요청 <code>Allocate</code> 를 담당한다. <code>Allocate</code> 하는 동안, 장치 플러그인은
GPU 정리 또는 QRNG 초기화와 같은 장치별 준비를 수행할 수 있다.
작업이 성공하면, 장치 플러그인은 할당된 장치에 접근하기 위한 컨테이너 런타임 구성이 포함된
<code>AllocateResponse</code> 를 반환한다. kubelet은 이 정보를
컨테이너 런타임에 전달한다.</p></li></ul><h3 id=kubelet-재시작-처리>kubelet 재시작 처리</h3><p>장치 플러그인은 일반적으로 kubelet의 재시작을 감지하고 새로운
kubelet 인스턴스에 자신을 다시 등록할 것으로 기대된다. 현재의 구현에서, 새 kubelet 인스턴스는 시작될 때
<code>/var/lib/kubelet/device-plugins</code> 아래에 있는 모든 기존의 유닉스 소켓을 삭제한다. 장치 플러그인은 유닉스 소켓의
삭제를 모니터링하고 이러한 이벤트가 발생하면 다시 자신을 등록할 수 있다.</p><h2 id=장치-플러그인-배포>장치 플러그인 배포</h2><p>장치 플러그인을 데몬셋, 노드 운영 체제의 패키지
또는 수동으로 배포할 수 있다.</p><p>표준 디렉터리 <code>/var/lib/kubelet/device-plugins</code> 에는 특권을 가진 접근이 필요하므로,
장치 플러그인은 특권을 가진 보안 컨텍스트에서 실행해야 한다.
장치 플러그인을 데몬셋으로 배포하는 경우, 플러그인의
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>에서
<code>/var/lib/kubelet/device-plugins</code> 를
<a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>으로 마운트해야 한다.</p><p>데몬셋 접근 방식을 선택하면 쿠버네티스를 사용하여 장치 플러그인의 파드를 노드에 배치하고,
장애 후 데몬 파드를 다시 시작하고, 업그레이드를 자동화할 수 있다.</p><h2 id=api-호환성>API 호환성</h2><p>쿠버네티스 장치 플러그인 지원은 베타 버전이다. 호환되지 않는 방식으로 안정화 전에 API가
변경될 수 있다. 프로젝트로서, 쿠버네티스는 장치 플러그인 개발자에게 다음 사항을 권장한다.</p><ul><li>향후 릴리스에서 변경 사항을 확인하자.</li><li>이전/이후 버전과의 호환성을 위해 여러 버전의 장치 플러그인 API를 지원한다.</li></ul><p>최신 장치 플러그인 API 버전의 쿠버네티스 릴리스로 업그레이드해야 하는 노드에서 DevicePlugins 기능을 활성화하고
장치 플러그인을 실행하는 경우, 이 노드를 업그레이드하기 전에
두 버전을 모두 지원하도록 장치 플러그인을 업그레이드한다. 이 방법을 사용하면
업그레이드 중에 장치 할당이 지속적으로 작동한다.</p><h2 id=장치-플러그인-리소스-모니터링>장치 플러그인 리소스 모니터링</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.15 [beta]</code></div><p>장치 플러그인에서 제공하는 리소스를 모니터링하려면, 모니터링 에이전트가
노드에서 사용 중인 장치 셋을 검색하고 메트릭과 연관될 컨테이너를 설명하는
메타데이터를 얻을 수 있어야 한다. 장치 모니터링 에이전트에 의해 노출된
<a href=https://prometheus.io/>프로메테우스</a> 지표는
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/instrumentation.md>쿠버네티스 Instrumentation 가이드라인</a>을 따라
<code>pod</code>, <code>namespace</code> 및 <code>container</code> 프로메테우스 레이블을 사용하여 컨테이너를 식별해야 한다.</p><p>kubelet은 gRPC 서비스를 제공하여 사용 중인 장치를 검색하고, 이러한 장치에 대한 메타데이터를
제공한다.</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>// PodResourcesLister는 kubelet에서 제공하는 서비스로, 노드의 포드 및 컨테이너가
// 사용한 노드 리소스에 대한 정보를 제공한다.
service PodResourcesLister {
    rpc List(ListPodResourcesRequest) returns (ListPodResourcesResponse) {}
    rpc GetAllocatableResources(AllocatableResourcesRequest) returns (AllocatableResourcesResponse) {}
}
</code></pre><h3 id=grpc-endpoint-list><code>List</code> gRPC 엔드포인트</h3><p><code>List</code> 엔드포인트는 실행 중인 파드의 리소스에 대한 정보를 제공하며,
독점적으로 할당된 CPU의 ID, 장치 플러그인에 의해 보고된 장치 ID,
이러한 장치가 할당된 NUMA 노드의 ID와 같은 세부 정보를 함께 제공한다. 또한, NUMA 기반 머신의 경우, 컨테이너를 위해 예약된 메모리와 hugepage에 대한 정보를 포함한다.</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>// ListPodResourcesResponse는 List 함수가 반환하는 응답이다.
message ListPodResourcesResponse {
    repeated PodResources pod_resources = 1;
}

// PodResources에는 파드에 할당된 노드 리소스에 대한 정보가 포함된다.
message PodResources {
    string name = 1;
    string namespace = 2;
    repeated ContainerResources containers = 3;
}

// ContainerResources는 컨테이너에 할당된 리소스에 대한 정보를 포함한다.
message ContainerResources {
    string name = 1;
    repeated ContainerDevices devices = 2;
    repeated int64 cpu_ids = 3;
    repeated ContainerMemory memory = 4;
}

// ContainerMemory는 컨테이너에 할당된 메모리와 hugepage에 대한 정보를 포함한다.
message ContainerMemory {
    string memory_type = 1;
    uint64 size = 2;
    TopologyInfo topology = 3;
}

// 토폴로지는 리소스의 하드웨어 토폴로지를 설명한다.
message TopologyInfo {
        repeated NUMANode nodes = 1;
}

// NUMA 노드의 NUMA 표현
message NUMANode {
        int64 ID = 1;
}

// ContainerDevices는 컨테이너에 할당된 장치에 대한 정보를 포함한다.
message ContainerDevices {
    string resource_name = 1;
    repeated string device_ids = 2;
    TopologyInfo topology = 3;
}
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p><code>List</code> 엔드포인트의 <code>ContainerResources</code> 내부에 있는 cpu_ids은 특정 컨테이너에 할당된
독점 CPU들에 해당한다. 만약 공유 풀(shared pool)에 있는 CPU들을 확인(evaluate)하는 것이 목적이라면, 해당 <code>List</code>
엔드포인트는 다음에 설명된 것과 같이, <code>GetAllocatableResources</code> 엔드포인트와 함께 사용되어야
한다.</p><ol><li><code>GetAllocatableResources</code>를 호출하여 할당 가능한 모든 CPU 목록을 조회</li><li>시스템의 모든 <code>ContainerResources</code>에서 <code>GetCpuIds</code>를 호출</li><li><code>GetAllocateableResources</code> 호출에서 <code>GetCpuIds</code> 호출로 얻은 모든 CPU를 빼기</li></ol></div><h3 id=grpc-endpoint-getallocatableresources><code>GetAllocatableResources</code> gRPC 엔드포인트</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [beta]</code></div><p>GetAllocatableResources는 워커 노드에서 처음 사용할 수 있는 리소스에 대한 정보를 제공한다.
kubelet이 APIServer로 내보내는 것보다 더 많은 정보를 제공한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>GetAllocatableResources</code>는 <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>할당 가능(allocatable)</a> 리소스를 확인(evaluate)하기 위해서만
사용해야 한다. 만약 목적이 free/unallocated 리소스를 확인하기 위한 것이라면
List() 엔드포인트와 함께 사용되어야 한다. <code>GetAllocableResources</code>로 얻은 결과는 kubelet에
노출된 기본 리소스가 변경되지 않는 한 동일하게 유지된다. 이러한 변경은 드물지만, 발생하게 된다면
(예를 들면: hotplug/hotunplug, 장치 상태 변경) 클라이언트가 <code>GetAlloctableResources</code> 엔드포인트를
호출할 것으로 가정한다.
그러나 CPU 및/또는 메모리가 갱신된 경우 <code>GetAllocateableResources</code> 엔드포인트를 호출하는 것만으로는
충분하지 않으며, Kubelet을 다시 시작하여 올바른 리소스 용량과 할당 가능(allocatable) 리소스를 반영해야 한다.</div><pre tabindex=0><code class=language-gRPC data-lang=gRPC>// AllocatableResourcesResponses에는 kubelet이 알고 있는 모든 장치에 대한 정보가 포함된다.
message AllocatableResourcesResponse {
    repeated ContainerDevices devices = 1;
    repeated int64 cpu_ids = 2;
    repeated ContainerMemory memory = 3;
}
</code></pre><p>쿠버네티스 v1.23부터, <code>GetAllocatableResources</code>가 기본으로 활성화된다.
이를 비활성화하려면 <code>KubeletPodResourcesGetAllocatable</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트(feature gate)</a>를
끄면 된다.</p><p>쿠버네티스 v1.23 이전 버전에서 이 기능을 활성화하려면 <code>kubelet</code>이 다음 플래그를 가지고 시작되어야 한다.</p><p><code>--feature-gates=KubeletPodResourcesGetAllocatable=true</code></p><p><code>ContainerDevices</code> 는 장치가 어떤 NUMA 셀과 연관되는지를 선언하는 토폴로지 정보를 노출한다.
NUMA 셀은 불분명한(opaque) 정수 ID를 사용하여 식별되며, 이 값은
<a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#%ED%86%A0%ED%8F%B4%EB%A1%9C%EC%A7%80-%EA%B4%80%EB%A6%AC%EC%9E%90%EB%A1%9C-%EC%9E%A5%EC%B9%98-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%ED%86%B5%ED%95%A9>kubelet에 등록할 때</a> 장치 플러그인이 보고하는 것과 일치한다.</p><p>gRPC 서비스는 <code>/var/lib/kubelet/pod-resources/kubelet.sock</code> 의 유닉스 소켓을 통해 제공된다.
장치 플러그인 리소스에 대한 모니터링 에이전트는 데몬 또는 데몬셋으로 배포할 수 있다.
표준 디렉터리 <code>/var/lib/kubelet/pod-resources</code> 에는 특권을 가진 접근이 필요하므로, 모니터링
에이전트는 특권을 가진 보안 컨텍스트에서 실행해야 한다. 장치 모니터링 에이전트가
데몬셋으로 실행 중인 경우, 해당 장치 모니터링 에이전트의 <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>에서
<code>/var/lib/kubelet/pod-resources</code> 를
<a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>으로 마운트해야 한다.</p><p><code>PodResourcesLister service</code> 를 지원하려면 <code>KubeletPodResources</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.
이것은 쿠버네티스 1.15부터 기본으로 활성화되어 있으며, 쿠버네티스 1.20부터는 v1 상태이다.</p><h2 id=토폴로지-관리자로-장치-플러그인-통합>토폴로지 관리자로 장치 플러그인 통합</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [beta]</code></div><p>토폴로지 관리자는 Kubelet 컴포넌트로, 리소스를 토폴로지 정렬 방식으로 조정할 수 있다. 이를 위해, 장치 플러그인 API가 <code>TopologyInfo</code> 구조체를 포함하도록 확장되었다.</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>message TopologyInfo {
	repeated NUMANode nodes = 1;
}

message NUMANode {
    int64 ID = 1;
}
</code></pre><p>토폴로지 관리자를 활용하려는 장치 플러그인은 장치 ID 및 장치의 정상 상태와 함께 장치 등록의 일부로 채워진 TopologyInfo 구조체를 다시 보낼 수 있다. 그런 다음 장치 관리자는 이 정보를 사용하여 토폴로지 관리자와 상의하고 리소스 할당 결정을 내린다.</p><p><code>TopologyInfo</code> 는 <code>nil</code>(기본값) 또는 NUMA 노드 목록인 <code>nodes</code> 필드를 지원한다. 이를 통해 NUMA 노드에 걸쳐있을 수 있는 장치 플러그인을 게시할 수 있다.</p><p>장치 플러그인으로 장치에 대해 채워진 <code>TopologyInfo</code> 구조체의 예는 다음과 같다.</p><pre tabindex=0><code>pluginapi.Device{ID: &#34;25102017&#34;, Health: pluginapi.Healthy, Topology:&amp;pluginapi.TopologyInfo{Nodes: []*pluginapi.NUMANode{&amp;pluginapi.NUMANode{ID: 0,},}}}
</code></pre><h2 id=examples>장치 플러그인 예시</h2><div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div><p>다음은 장치 플러그인 구현의 예이다.</p><ul><li><a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>AMD GPU 장치 플러그인</a></li><li>인텔 GPU, FPGA, QAT, VPU, SGX, DSA, DLB 및 IAA 장치용 <a href=https://github.com/intel/intel-device-plugins-for-kubernetes>인텔 장치 플러그인</a></li><li>하드웨어 지원 가상화를 위한 <a href=https://github.com/kubevirt/kubernetes-device-plugins>KubeVirt 장치 플러그인</a></li><li><a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu>컨테이너에 최적화된 OS를 위한 NVIDIA GPU 장치 플러그인</a></li><li><a href=https://github.com/hustcat/k8s-rdma-device-plugin>RDMA 장치 플러그인</a></li><li><a href=https://github.com/collabora/k8s-socketcan>SocketCAN 장치 플러그인</a></li><li><a href=https://github.com/vikaschoudhary16/sfc-device-plugin>Solarflare 장치 플러그인</a></li><li><a href=https://github.com/intel/sriov-network-device-plugin>SR-IOV 네트워크 장치 플러그인</a></li><li>Xilinx FPGA 장치용 <a href=https://github.com/Xilinx/FPGA_as_a_Service/tree/master/k8s-fpga-device-plugin>Xilinx FPGA 장치 플러그인</a></li></ul><h2 id=다음-내용>다음 내용</h2><ul><li>장치 플러그인을 사용한 <a href=/ko/docs/tasks/manage-gpus/scheduling-gpus/>GPU 리소스 스케줄링</a>에 대해 알아보기</li><li>노드에서의 <a href=/ko/docs/tasks/administer-cluster/extended-resource-node/>확장 리소스 알리기</a>에 대해 배우기</li><li><a href=/docs/tasks/administer-cluster/topology-manager/>토폴로지 관리자</a>에 대해 알아보기</li><li>쿠버네티스에서 <a href=/blog/2019/04/24/hardware-accelerated-ssl/tls-termination-in-ingress-controllers-using-kubernetes-device-plugins-and-runtimeclass/>TLS 인그레스에 하드웨어 가속</a> 사용에 대해 읽기</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>