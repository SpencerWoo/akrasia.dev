<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/containers/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/containers/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/containers/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/containers/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/containers/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/containers/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/containers/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/containers/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/containers/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/containers/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/containers/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>컨테이너 | Kubernetes</title><meta property="og:title" content="컨테이너"><meta property="og:description" content="런타임 의존성과 함께 애플리케이션을 패키징하는 기술"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/containers/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="컨테이너"><meta itemprop=description content="런타임 의존성과 함께 애플리케이션을 패키징하는 기술"><meta name=twitter:card content="summary"><meta name=twitter:title content="컨테이너"><meta name=twitter:description content="런타임 의존성과 함께 애플리케이션을 패키징하는 기술"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="런타임 의존성과 함께 애플리케이션을 패키징하는 기술"><meta property="og:description" content="런타임 의존성과 함께 애플리케이션을 패키징하는 기술"><meta name=twitter:description content="런타임 의존성과 함께 애플리케이션을 패키징하는 기술"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/containers/"><meta property="og:title" content="컨테이너"><meta name=twitter:title content="컨테이너"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/containers/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/containers/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/containers/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/concepts/containers/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/concepts/containers/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/containers/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/containers/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/concepts/containers/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/containers/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/containers/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/containers/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/containers/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/containers/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/containers/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/containers/>Tiếng Việt (Vietnamese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/concepts/containers/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>컨테이너</h1><div class=lead>런타임 의존성과 함께 애플리케이션을 패키징하는 기술</div><ul><li>1: <a href=#pg-16042b4652ad19e565c7263824029a43>이미지</a></li><li>2: <a href=#pg-a858027489648786a3b16264e451272b>런타임클래스(RuntimeClass)</a></li><li>3: <a href=#pg-643212488f778acf04bebed65ba34441>컨테이너 환경 변수</a></li><li>4: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>컨테이너 라이프사이클 훅(Hook)</a></li></ul><div class=content><p>실행하는 각 컨테이너는 반복 가능하다. 의존성이 포함된 표준화는
어디에서 실행하던지 동일한 동작을 얻는다는 것을
의미한다.</p><p>컨테이너는 기본 호스트 인프라에서 애플리케이션을 분리한다.
따라서 다양한 클라우드 또는 OS 환경에서 보다 쉽게 배포할 수 있다.</p><h2 id=컨테이너-이미지>컨테이너 이미지</h2><p><a href=/ko/docs/concepts/containers/images/>컨테이너 이미지</a>는 애플리케이션을
실행하는 데 필요한 모든 것이 포함된 실행할 준비가 되어 있는(ready-to-run) 소프트웨어 패키지이다.
여기에는 실행하는 데 필요한 코드와 모든 런타임, 애플리케이션 및 시스템 라이브러리,
그리고 모든 필수 설정에 대한 기본값이 포함된다.</p><p>설계 상, 컨테이너는 변경할 수 없다. 이미 실행 중인 컨테이너의 코드를
변경할 수 없다. 컨테이너화된 애플리케이션이 있고
변경하려는 경우, 변경 사항이 포함된 새 이미지를 빌드한
다음, 업데이트된 이미지에서 시작하도록 컨테이너를 다시 생성해야 한다.</p><h2 id=컨테이너-런타임>컨테이너 런타임</h2><p>컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.</p><p>쿠버네티스는 <a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>,
<a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>와 같은 컨테이너 런타임 및
모든 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (컨테이너 런타임 인터페이스)</a>
구현체를 지원한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/containers/images/>컨테이너 이미지</a>에 대해 읽어보기</li><li><a href=/ko/docs/concepts/workloads/pods/>파드</a>에 대해 읽어보기</li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-16042b4652ad19e565c7263824029a43>1 - 이미지</h1><p>컨테이너 이미지는 애플리케이션과 모든 소프트웨어 의존성을 캡슐화하는 바이너리 데이터를
나타낸다. 컨테이너 이미지는 독립적으로 실행할 수 있고 런타임 환경에 대해
잘 정의된 가정을 만드는 실행 가능한 소프트웨어 번들이다.</p><p>일반적으로 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>에서
참조하기 전에 애플리케이션의 컨테이너 이미지를
생성해서 레지스트리로 푸시한다.</p><p>이 페이지는 컨테이너 이미지 개념의 개요를 제공한다.</p><h2 id=이미지-이름>이미지 이름</h2><p>컨테이너 이미지는 일반적으로 <code>pause</code>, <code>example/mycontainer</code> 또는 <code>kube-apiserver</code> 와 같은 이름을 부여한다.
이미지는 또한 레지스트리 호스트 이름을 포함할 수 있다. 예를 들어 <code>fictional.registry.example/imagename</code>
와 같다. 그리고 <code>fictional.registry.example:10443/imagename</code> 와 같이 포트 번호도 포함할 수 있다.</p><p>레지스트리 호스트 이름을 지정하지 않으면, 쿠버네티스는 도커 퍼블릭 레지스트리를 의미한다고 가정한다.</p><p>이미지 이름 부분 다음에 <em>tag</em> 를 추가할 수 있다(<code>docker</code> 또는 <code>podman</code> 과 같은 명령을 사용할 때와 동일한 방식으로).
태그를 사용하면 동일한 시리즈 이미지의 다른 버전을 식별할 수 있다.</p><p>이미지 태그는 소문자와 대문자, 숫자, 밑줄(<code>_</code>),
마침표(<code>.</code>) 및 대시(<code>-</code>)로 구성된다.
이미지 태그 안에서 구분 문자(<code>_</code>, <code>-</code> 그리고 <code>.</code>)를
배치할 수 있는 위치에 대한 추가 규칙이 있다.
태그를 지정하지 않으면, 쿠버네티스는 태그 <code>latest</code> 를 의미한다고 가정한다.</p><h2 id=이미지-업데이트>이미지 업데이트</h2><p><a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>,
<a class=glossary-tooltip title='내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a>, 파드 또는 파드
템플릿은 포함하는 다른 오브젝트를 처음 만들 때 특별히 명시하지 않은 경우
기본적으로 해당 파드에 있는 모든 컨테이너의 풀(pull)
정책은 <code>IfNotPresent</code>로 설정된다. 이 정책은
<a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>이 이미 존재하는
이미지에 대한 풀을 생략하게 한다.</p><h3 id=이미지-풀-pull-정책>이미지 풀(pull) 정책</h3><p>컨테이너에 대한 <code>imagePullPolicy</code>와 이미지의 태그는
<a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>이 특정 이미지를 풀(다운로드)하려고 할 때 영향을 준다.</p><p>다음은 <code>imagePullPolicy</code>에 설정할 수 있는 값의 목록과
효과이다.</p><dl><dt><code>IfNotPresent</code></dt><dd>이미지가 로컬에 없는 경우에만 내려받는다.</dd><dt><code>Always</code></dt><dd>kubelet이 컨테이너를 기동할 때마다, kubelet이 컨테이너
이미지 레지스트리에 이름과 이미지의
<a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>다이제스트</a>가 있는지 질의한다.
일치하는 다이제스트를 가진 컨테이너 이미지가 로컬에 있는 경우, kubelet은 캐시된 이미지를 사용한다.
이외의 경우, kubelet은 검색된 다이제스트를 가진 이미지를 내려받아서
컨테이너를 기동할 때 사용한다.</dd><dt><code>Never</code></dt><dd>kubelet은 이미지를 가져오려고 시도하지 않는다. 이미지가 어쨌든 이미 로컬에 존재하는
경우, kubelet은 컨테이너 기동을 시도한다. 이외의 경우 기동은 실패한다.
보다 자세한 내용은 <a href=#pre-pulled-images>미리 내려받은 이미지</a>를 참조한다.</dd></dl><p>이미지 제공자에 앞서 깔린 캐시의 의미 체계는 레지스트리에 안정적으로 접근할 수 있는 한,
<code>imagePullPolicy: Always</code>인 경우 조차도 효율적이다.
컨테이너 런타임은 노드에 이미 존재하는 이미지 레이어를 알고
다시 내려받지 않는다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>프로덕션 환경에서 컨테이너를 배포하는 경우 <code>:latest</code> 태그 사용을 지양해야 하는데,
이미지의 어떤 버전이 기동되고 있는지 추적이 어렵고
제대로 롤백하기 어렵게 되기 때문이다.</p><p>대신, <code>v1.42.0</code>과 같이 의미있는 태그를 명기한다.</p></div><p>파드가 항상 컨테이너 이미지의 같은 버전을 사용하는 것을 확실히 하려면,
이미지의 다이제스트를 명기할 수 있다.
<code>&lt;image-name>:&lt;tag></code>를 <code>&lt;image-name>@&lt;digest></code>로 교체한다.
(예를 들어, <code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>).</p><p>이미지 태그를 사용하는 경우, 이미지 레지스트리에서 한 이미지를 나타내는 태그에 코드를 변경하게 되면, 기존 코드와 신규 코드를 구동하는 파드가 섞이게 되고 만다. 이미지 다이제스트를 통해 이미지의 특정 버전을 유일하게 식별할 수 있기 때문에, 쿠버네티스는 매번 해당 이미지 이름과 다이제스트가 명시된 컨테이너를 기동해서 같은 코드를 구동한다. 이미지를 다이제스트로 명시하면 구동할 코드를 고정시켜서 레지스트리에서의 변경으로 인해 버전이 섞이는 일이 발생하지 않도록 해 준다.</p><p>파드(및 파드 템플릿)가 생성될 때 구동 중인 워크로드가
태그가 아닌 이미지 다이제스트를 통해 정의되도록 조작해주는
서드-파티 <a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러</a>가 있다.
이는 레지스트리에서 태그가 변경되는 일이 발생해도
구동 중인 워크로드가 모두 같은 코드를 사용하고 있다는 것을 보장하기를 원하는 경우 유용할 것이다.</p><h4 id=imagepullpolicy-defaulting>기본 이미지 풀 정책</h4><p>사용자(또는 컨트롤러)가 신규 파드를 API 서버에 요청할 때,
특정 조건에 부합하면 클러스터가 <code>imagePullPolicy</code> 필드를 설정한다.</p><ul><li><code>imagePullPolicy</code> 필드를 생략하고 컨테이너 이미지의 태그가
<code>:latest</code>인 경우, <code>imagePullPolicy</code>는 자동으로 <code>Always</code>로 설정된다.</li><li><code>imagePullPolicy</code> 필드를 생략하고 컨테이너 이미지의 태그를 명기하지 않은 경우,
<code>imagePullPolicy</code>는 자동으로 <code>Always</code>로 설정된다.</li><li><code>imagePullPolicy</code> 필드를 생략하고,
명기한 컨테이너 이미지의 태그가 <code>:latest</code>가 아니면,
<code>imagePullPolicy</code>는 자동으로 <code>IfNotPresent</code>로 설정된다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>컨테이너의 <code>imagePullPolicy</code> 값은 오브젝트가 처음 <em>created</em> 일 때 항상
설정되고 나중에 이미지 태그가 변경되더라도 업데이트되지 않는다.</p><p>예를 들어, 태그가 <code>:latest</code>가 아닌 이미지로 디플로이먼트를 생성하고,
나중에 해당 디플로이먼트의 이미지를 <code>:latest</code> 태그로 업데이트하면
<code>imagePullPolicy</code> 필드가 <code>Always</code> 로 변경되지 않는다. 오브젝트를
처음 생성 한 후 모든 오브젝트의 풀 정책을 수동으로 변경해야 한다.</p></div><h4 id=이미지-풀-강제>이미지 풀 강제</h4><p>이미지를 내려받도록 강제하려면, 다음 중 한가지 방법을 사용한다.</p><ul><li>컨테이너의 <code>imagePullPolicy</code>를 <code>Always</code>로 설정한다.</li><li><code>imagePullPolicy</code>를 생략하고 사용할 이미지 태그로 <code>:latest</code>를 사용한다.
그러면 사용자가 파드를 요청할 때 쿠버네티스가 정책을 <code>Always</code>로 설정한다.</li><li><code>imagePullPolicy</code>와 사용할 이미지의 태그를 생략한다.
그러면 사용자가 파드를 요청할 때 쿠버네티스가 정책을 <code>Always</code>로 설정한다.</li><li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> 어드미션 컨트롤러를 활성화 한다.</li></ul><h3 id=이미지풀백오프-imagepullbackoff>이미지풀백오프(ImagePullBackOff)</h3><p>kubelet이 컨테이너 런타임을 사용하여 파드의 컨테이너 생성을 시작할 때,
<code>ImagePullBackOff</code>로 인해 컨테이너가
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting>Waiting</a> 상태에 있을 수 있다.</p><p><code>ImagePullBackOff</code>라는 상태는 (이미지 이름이 잘못됨, 또는 <code>imagePullSecret</code> 없이
비공개 레지스트리에서 풀링 시도 등의 이유로) 쿠버네티스가 컨테이너 이미지를
가져올 수 없기 때문에 컨테이너를 실행할 수 없음을 의미한다. <code>BackOff</code>라는 단어는
쿠버네티스가 백오프 딜레이를 증가시키면서 이미지 풀링을 계속 시도할 것임을 나타낸다.</p><p>쿠버네티스는 시간 간격을 늘려가면서 시도를 계속하며, 시간 간격의 상한은 쿠버네티스 코드에
300초(5분)로 정해져 있다.</p><h2 id=이미지-인덱스가-있는-다중-아키텍처-이미지>이미지 인덱스가 있는 다중 아키텍처 이미지</h2><p>바이너리 이미지를 제공할 뿐만 아니라, 컨테이너 레지스트리는 <a href=https://github.com/opencontainers/image-spec/blob/master/image-index.md>컨테이너 이미지 인덱스</a>를 제공할 수도 있다. 이미지 인덱스는 컨테이너의 아키텍처별 버전에 대한 여러 <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>이미지 매니페스트</a>를 가리킬 수 있다. 아이디어는 이미지의 이름(예를 들어, <code>pause</code>, <code>example/mycontainer</code>, <code>kube-apiserver</code>)을 가질 수 있다는 것이다. 그래서 다른 시스템들이 사용하고 있는 컴퓨터 아키텍처에 적합한 바이너리 이미지를 가져올 수 있다.</p><p>쿠버네티스 자체는 일반적으로 <code>-$(ARCH)</code> 접미사로 컨테이너 이미지의 이름을 지정한다. 이전 버전과의 호환성을 위해, 접미사가 있는 오래된 이미지를 생성한다. 아이디어는 모든 아키텍처에 대한 매니페스트가 있는 <code>pause</code> 이미지와 이전 구성 또는 이전에 접미사로 이미지를 하드 코딩한 YAML 파일과 호환되는 <code>pause-amd64</code> 라고 하는 이미지를 생성한다.</p><h2 id=프라이빗-레지스트리-사용>프라이빗 레지스트리 사용</h2><p>프라이빗 레지스트리는 해당 레지스트리에서 이미지를 읽을 수 있는 키를 요구할 것이다.
자격 증명(credential)은 여러 가지 방법으로 제공될 수 있다.</p><ul><li>프라이빗 레지스트리에 대한 인증을 위한 노드 구성<ul><li>모든 파드는 구성된 프라이빗 레지스트리를 읽을 수 있음</li><li>클러스터 관리자에 의한 노드 구성 필요</li></ul></li><li>미리 내려받은(pre-pulled) 이미지<ul><li>모든 파드는 노드에 캐시된 모든 이미지를 사용 가능</li><li>셋업을 위해서는 모든 노드에 대해서 root 접근이 필요</li></ul></li><li>파드에 ImagePullSecrets을 명시<ul><li>자신의 키를 제공하는 파드만 프라이빗 레지스트리에 접근 가능</li></ul></li><li>공급 업체별 또는 로컬 확장<ul><li>사용자 정의 노드 구성을 사용하는 경우, 사용자(또는 클라우드
제공자)가 컨테이너 레지스트리에 대한 노드 인증 메커니즘을
구현할 수 있다.</li></ul></li></ul><p>이들 옵션은 아래에서 더 자세히 설명한다.</p><h3 id=프라이빗-레지스트리에-인증하도록-노드-구성>프라이빗 레지스트리에 인증하도록 노드 구성</h3><p>크리덴셜 설정에 대한 상세 지침은 사용하는 컨테이너 런타임 및 레지스트리에 따라 다르다. 가장 정확한 정보는 솔루션 설명서를 참조해야 한다.</p><p>프라이빗 컨테이너 이미지 레지스트리 구성 예시를 보려면,
<a href=/ko/docs/tasks/configure-pod-container/pull-image-private-registry/>프라이빗 레지스트리에서 이미지 가져오기</a>를 참조한다.
해당 예시는 도커 허브에서 제공하는 프라이빗 레지스트리를 사용한다.</p><h3 id=config-json>config.json 파일 해석</h3><p><code>config.json</code> 파일의 해석에 있어서, 기존 도커의 구현과 쿠버네티스의 구현에 차이가 있다.
도커에서는 <code>auths</code> 키에 특정 루트 URL만 기재할 수 있으나,
쿠버네티스에서는 glob URL과 접두사-매칭 경로도 기재할 수 있다.
이는 곧 다음과 같은 <code>config.json</code>도 유효하다는 뜻이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;*my-registry.io/images&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>루트 URL(<code>*my-registry.io</code>)은 다음 문법을 사용하여 매치된다.</p><pre tabindex=0><code>pattern:
    { term }

term:
    &#39;*&#39;         구분자가 아닌 모든 문자와 매치됨
    &#39;?&#39;         구분자가 아닌 문자 1개와 매치됨
    &#39;[&#39; [ &#39;^&#39; ] { character-range } &#39;]&#39;
                문자 클래스 (비어 있으면 안 됨))
    c           문자 c에 매치됨 (c != &#39;*&#39;, &#39;?&#39;, &#39;\\&#39;, &#39;[&#39;)
    &#39;\\&#39; c      문자 c에 매치됨

character-range:
    c           문자 c에 매치됨 (c != &#39;\\&#39;, &#39;-&#39;, &#39;]&#39;)
    &#39;\\&#39; c      문자 c에 매치됨
    lo &#39;-&#39; hi   lo &lt;= c &lt;= hi 인 문자 c에 매치됨
</code></pre><p>이미지 풀 작업 시, 모든 유효한 패턴에 대해 크리덴셜을 CRI 컨테이너 런타임에 제공할 것이다.
예를 들어 다음과 같은 컨테이너 이미지 이름은
성공적으로 매치될 것이다.</p><ul><li><code>my-registry.io/images</code></li><li><code>my-registry.io/images/my-image</code></li><li><code>my-registry.io/images/another-image</code></li><li><code>sub.my-registry.io/images/my-image</code></li><li><code>a.sub.my-registry.io/images/my-image</code></li></ul><p>kubelet은 인식된 모든 크리덴셜을 순차적으로 이용하여 이미지 풀을 수행한다. 즉,
<code>config.json</code>에 다음과 같이 여러 항목을 기재할 수도 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;my-registry.io/images&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;my-registry.io/images/subpath&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이제 컨테이너가 <code>my-registry.io/images/subpath/my-image</code>
이미지를 풀 해야 한다고 명시하면,
kubelet은 크리덴셜을 순차적으로 사용하여 풀을 시도한다.</p><h3 id=pre-pulled-images>미리 내려받은 이미지</h3><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 방법은 노드의 구성을 제어할 수 있는 경우에만 적합하다. 이 방법은
클라우드 제공자가 노드를 관리하고 자동으로 교체한다면 안정적으로
작동하지 않을 것이다.</div><p>기본적으로, kubelet은 지정된 레지스트리에서 각 이미지를 풀 하려고 한다.
그러나, 컨테이너의 <code>imagePullPolicy</code> 속성이 <code>IfNotPresent</code> 또는 <code>Never</code>으로 설정되어 있다면,
로컬 이미지가 사용된다(우선적으로 또는 배타적으로).</p><p>레지스트리 인증의 대안으로 미리 풀 된 이미지에 의존하고 싶다면,
클러스터의 모든 노드가 동일한 미리 내려받은 이미지를 가지고 있는지 확인해야 한다.</p><p>이것은 특정 이미지를 속도를 위해 미리 로드하거나 프라이빗 레지스트리에 대한 인증의 대안으로 사용될 수 있다.</p><p>모든 파드는 미리 내려받은 이미지에 대해 읽기 접근 권한을 가질 것이다.</p><h3 id=파드에-imagepullsecrets-명시>파드에 ImagePullSecrets 명시</h3><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 방법은 프라이빗 레지스트리의 이미지를 기반으로 컨테이너를 실행하는 데
권장된다.</div><p>쿠버네티스는 파드에 컨테이너 이미지 레지스트리 키를 명시하는 것을 지원한다.
<code>imagePullSecrets</code>은 모두 파드와 동일한 네임스페이스에 있어야 한다.
참조되는 시크릿의 타입은 <code>kubernetes.io/dockercfg</code> 이거나 <code>kubernetes.io/dockerconfigjson</code> 이어야 한다.</p><h4 id=도커-구성으로-시크릿-생성>도커 구성으로 시크릿 생성</h4><p>레지스트리에 인증하기 위해서는, 레지스트리 호스트네임 뿐만 아니라,
사용자 이름, 비밀번호 및 클라이언트 이메일 주소를 알아야 한다.
대문자 값을 적절히 대체하여, 다음 커맨드를 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</span></span></code></pre></div><p>만약 도커 자격 증명 파일이 이미 존재한다면, 위의 명령을 사용하지 않고,
자격 증명 파일을 쿠버네티스 <a class=glossary-tooltip title='비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿>시크릿</a>으로
가져올 수 있다.
<a href=/ko/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>기존 도커 자격 증명으로 시크릿 생성</a>에서 관련 방법을 설명하고 있다.</p><p><code>kubectl create secret docker-registry</code>는
하나의 프라이빗 레지스트리에서만 작동하는 시크릿을 생성하기 때문에,
여러 프라이빗 컨테이너 레지스트리를 사용하는 경우 특히 유용하다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드는 이미지 풀 시크릿을 자신의 네임스페이스에서만 참조할 수 있다.
따라서 이 과정은 네임스페이스 당 한 번만 수행될 필요가 있다.</div><h4 id=파드의-imagepullsecrets-참조>파드의 imagePullSecrets 참조</h4><p>이제, <code>imagePullSecrets</code> 섹션을 파드의 정의에 추가함으로써 해당 시크릿을
참조하는 파드를 생성할 수 있다.</p><p>예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>이것은 프라이빗 레지스트리를 사용하는 각 파드에 대해서 수행될 필요가 있다.</p><p>그러나, 이 필드의 셋팅은 <a href=/docs/tasks/configure-pod-container/configure-service-account/>서비스 어카운트</a> 리소스에
imagePullSecrets을 셋팅하여 자동화할 수 있다.</p><p>자세한 지침을 위해서는 <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>서비스 어카운트에 ImagePullSecrets 추가</a>를 확인한다.</p><p>이것은 노드 당 <code>.docker/config.json</code>와 함께 사용할 수 있다. 자격 증명은
병합될 것이다.</p><h2 id=유스케이스>유스케이스</h2><p>프라이빗 레지스트리를 구성하기 위한 많은 솔루션이 있다. 다음은 여러 가지
일반적인 유스케이스와 제안된 솔루션이다.</p><ol><li>비소유 이미지(예를 들어, 오픈소스)만 실행하는 클러스터의 경우. 이미지를 숨길 필요가 없다.<ul><li>퍼블릭 레지스트리의 퍼블릭 이미지를 사용한다.<ul><li>설정이 필요 없다.</li><li>일부 클라우드 제공자는 퍼블릭 이미지를 자동으로 캐시하거나 미러링하므로, 가용성이 향상되고 이미지를 가져오는 시간이 줄어든다.</li></ul></li></ul></li><li>모든 클러스터 사용자에게는 보이지만, 회사 외부에는 숨겨야하는 일부 독점 이미지를
실행하는 클러스터의 경우.<ul><li>호스트된 프라이빗 레지스트리를 사용한다.<ul><li>프라이빗 레지스트리에 접근해야 하는 노드에 수동 설정이 필요할 수 있다</li></ul></li><li>또는, 방화벽 뒤에서 읽기 접근 권한을 가진 내부 프라이빗 레지스트리를 실행한다.<ul><li>쿠버네티스 구성은 필요하지 않다.</li></ul></li><li>이미지 접근을 제어하는 호스팅된 컨테이너 이미지 레지스트리 서비스를 사용한다.<ul><li>그것은 수동 노드 구성에 비해서 클러스터 오토스케일링과 더 잘 동작할 것이다.</li></ul></li><li>또는, 노드의 구성 변경이 불편한 클러스터에서는, <code>imagePullSecrets</code>를 사용한다.</li></ul></li><li>독점 이미지를 가진 클러스터로, 그 중 일부가 더 엄격한 접근 제어를 필요로 하는 경우.<ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages 어드미션 컨트롤러</a>가 활성화되어 있는지 확인한다. 그렇지 않으면, 모든 파드가 잠재적으로 모든 이미지에 접근 권한을 가진다.</li><li>민감한 데이터는 이미지 안에 포장하는 대신, "시크릿" 리소스로 이동한다.</li></ul></li><li>멀티-테넌트 클러스터에서 각 테넌트가 자신의 프라이빗 레지스트리를 필요로 하는 경우.<ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages 어드미션 컨트롤러</a>가 활성화되어 있는지 확인한다. 그렇지 않으면, 모든 파드가 잠재적으로 모든 이미지에 접근 권한을 가진다.</li><li>인가가 요구되도록 프라이빗 레지스트리를 실행한다.</li><li>각 테넌트에 대한 레지스트리 자격 증명을 생성하고, 시크릿에 넣고, 각 테넌트 네임스페이스에 시크릿을 채운다.</li><li>테넌트는 해당 시크릿을 각 네임스페이스의 imagePullSecrets에 추가한다.</li></ul></li></ol><p>다중 레지스트리에 접근해야 하는 경우, 각 레지스트리에 대해 하나의 시크릿을 생성할 수 있다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>OCI 이미지 매니페스트 명세</a> 읽어보기.</li><li><a href=/ko/docs/concepts/architecture/garbage-collection/#container-image-garbage-collection>컨테이너 이미지 가비지 수집(garbage collection)</a>에 대해 배우기.</li><li><a href=/ko/docs/tasks/configure-pod-container/pull-image-private-registry>프라이빗 레지스트리에서 이미지 받아오기</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a858027489648786a3b16264e451272b>2 - 런타임클래스(RuntimeClass)</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.20 [stable]</code></div><p>이 페이지는 런타임클래스 리소스와 런타임 선택 메커니즘에 대해서 설명한다.</p><p>런타임클래스는 컨테이너 런타임을 구성을 선택하는 기능이다. 컨테이너 런타임
구성은 파드의 컨테이너를 실행하는 데 사용된다.</p><h2 id=동기>동기</h2><p>서로 다른 파드간에 런타임클래스를 설정하여
성능과 보안의 균형을 유지할 수 있다.
예를 들어, 일부 작업에서 높은 수준의 정보 보안 보증이 요구되는 경우,
하드웨어 가상화를 이용하는 컨테이너 런타임으로 파드를 실행하도록 예약하는 선택을 할 수 있다.
그러면 몇가지 추가적인 오버헤드는 있지만
대체 런타임을 추가 분리하는 유익이 있다.</p><p>또한 런타임클래스를 사용하여 컨테이너 런타임이 같으나 설정이 다른
여러 파드를 실행할 수 있다.</p><h2 id=셋업>셋업</h2><ol><li>CRI 구현(implementation)을 노드에 설정(런타임에 따라서).</li><li>상응하는 런타임클래스 리소스 생성.</li></ol><h3 id=1-cri-구현을-노드에-설정>1. CRI 구현을 노드에 설정</h3><p>런타임클래스를 통한 가능한 구성은 컨테이너 런타임 인터페이스(CRI) 구현에 의존적이다.
사용자의 CRI 구현에 따른 설정 방법은
연관된 문서를 통해서 확인한다(<a href=#cri-configuration>아래</a>).</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 런타임클래스는 기본적으로 클러스터 전체에 걸쳐 동질의 노드 설정
(모든 노드가 컨테이너 런타임에 준하는 동일한 방식으로 설정되었음을 의미)을 가정한다.
이종의(heterogeneous) 노드 설정을 지원하기 위해서는, 아래 <a href=#%EC%8A%A4%EC%BC%80%EC%A4%84>스케줄</a>을 참고한다.</div><p>해당 설정은 상응하는 <code>handler</code> 이름을 가지며, 이는 런타임클래스에 의해서 참조된다.
런타임 핸들러는 유효한 DNS 1123 서브도메인(알파-숫자 + <code>-</code>와 <code>.</code>문자)을 가져야 한다.</p><h3 id=2-상응하는-런타임클래스-리소스-생성>2. 상응하는 런타임클래스 리소스 생성</h3><p>1단계에서 셋업 한 설정은 연관된 <code>handler</code> 이름을 가져야 하며, 이를 통해서 설정을 식별할 수 있다.
각 런타임 핸들러(그리고 선택적으로 비어있는 <code>""</code> 핸들러)에 대해서, 상응하는 런타임클래스 오브젝트를 생성한다.</p><p>현재 런타임클래스 리소스는 런타임클래스 이름(<code>metadata.name</code>)과 런타임 핸들러
(<code>handler</code>)로 단 2개의 중요 필드만 가지고 있다. 오브젝트 정의는 다음과 같은 형태이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 런타임클래스는 node.k8s.io API 그룹에 정의되어 있음</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 런타임클래스 참조에 사용될 이름</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 런타임클래스는 네임스페이스가 없는 리소스임</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 상응하는 CRI 설정의 이름</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>myconfiguration<span style=color:#bbb>
</span></span></span></code></pre></div><p>런타임클래스 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%9D%B4%EB%A6%84>DNS 레이블 이름</a>어이야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 런타임클래스 쓰기 작업(create/update/patch/delete)은
클러스터 관리자로 제한할 것을 권장한다. 이것은 일반적으로 기본 설정이다.
더 자세한 정보는 <a href=/ko/docs/reference/access-authn-authz/authorization/>권한 개요</a>를 참고한다.</div><h2 id=사용>사용</h2><p>클러스터에 런타임클래스를 설정하고 나면,
다음과 같이 파드 스펙에 <code>runtimeClassName</code>를 명시하여 해당 런타임클래스를 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이것은 kubelet이 지명된 런타임클래스를 사용하여 해당 파드를 실행하도록 지시할 것이다.
만약 지명된 런타임클래스가 없거나, CRI가 상응하는 핸들러를 실행할 수 없는 경우, 파드는
<code>Failed</code> 터미널 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EB%8B%A8%EA%B3%84-phase>단계</a>로 들어간다.
에러 메시지에 상응하는 <a href=/ko/docs/tasks/debug/debug-application/debug-running-pod/>이벤트</a>를
확인한다.</p><p>만약 명시된 <code>runtimeClassName</code>가 없다면, 기본 런타임 핸들러가 사용되며,
런타임클래스 기능이 비활성화되었을 때와 동일하게 동작한다.</p><h3 id=cri-configuration>CRI 구성</h3><p>CRI 런타임 설치에 대한 자세한 내용은 <a href=/ko/docs/setup/production-environment/container-runtimes/>CRI 설치</a>를 확인한다.</p><h4 id=hahahugoshortcode-s3-hbhb><a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></h4><p>런타임 핸들러는 containerd의 구성 파일인 <code>/etc/containerd/config.toml</code> 통해 설정한다.
유효한 핸들러는 runtimes 단락 아래에서 설정한다.</p><pre tabindex=0><code>[plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.${HANDLER_NAME}]
</code></pre><p>더 자세한 내용은 containerd의 <a href=https://github.com/containerd/cri/blob/master/docs/config.md>구성 문서</a>를
살펴본다.</p><h4 id=hahahugoshortcode-s4-hbhb><a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></h4><p>런타임 핸들러는 CRI-O의 구성파일인 <code>/etc/crio/crio.conf</code>을 통해 설정한다.
<a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table>crio.runtime 테이블</a> 아래에
유효한 핸들러를 설정한다.</p><pre tabindex=0><code>[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = &#34;${PATH_TO_BINARY}&#34;
</code></pre><p>더 자세한 것은 CRI-O의 <a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md>설정 문서</a>를 본다.</p><h2 id=스케줄>스케줄</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.16 [beta]</code></div><p>RuntimeClass에 <code>scheduling</code> 필드를 지정하면, 이 RuntimeClass로 실행되는 파드가
이를 지원하는 노드로 예약되도록 제약 조건을 설정할 수 있다.
<code>scheduling</code>이 설정되지 않은 경우 이 RuntimeClass는 모든 노드에서 지원되는 것으로 간주된다.</p><p>파드가 지정된 런타임클래스를 지원하는 노드에 안착한다는 것을 보장하려면,
해당 노드들은 <code>runtimeClass.scheduling.nodeSelector</code> 필드에서 선택되는 공통 레이블을 가져야한다.
런타임 클래스의 nodeSelector는 파드의 nodeSelector와 어드미션 시 병합되어서, 실질적으로
각각에 의해 선택된 노드의 교집합을 취한다. 충돌이 있는 경우,
파드는 거부된다.</p><p>지원되는 노드가 테인트(taint)되어서 다른 런타임클래스 파드가 노드에서 구동되는 것을 막고 있다면,
<code>tolerations</code>를 런타임클래스에 추가할 수 있다. <code>nodeSelector</code>를 사용하면, 어드미션 시
해당 톨러레이션(toleration)이 파드의 톨러레이션과 병합되어, 실질적으로 각각에 의해 선택된
노드의 합집합을 취한다.</p><p>노드 셀렉터와 톨러레이션 설정에 대해 더 배우려면
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/>노드에 파드 할당</a>을 참고한다.</p><h3 id=파드-오버헤드>파드 오버헤드</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [stable]</code></div><p>파드 실행과 연관되는 <em>오버헤드</em> 리소스를 지정할 수 있다. 오버헤드를 선언하면
클러스터(스케줄러 포함)가 파드와 리소스에 대한 결정을 내릴 때 처리를 할 수 있다.</p><p>파드 오버헤드는 런타임 클래스에서 <code>overhead</code> 필드를 통해 정의된다. 이 필드를 사용하면,
해당 런타임 클래스를 사용해서 구동 중인 파드의 오버헤드를 특정할 수 있고 이 오버헤드가
쿠버네티스 내에서 처리된다는 것을 보장할 수 있다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md>런타임클래스 설계</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md#runtimeclass-scheduling>런타임클래스 스케줄링 설계</a></li><li><a href=/ko/docs/concepts/scheduling-eviction/pod-overhead/>파드 오버헤드</a> 개념에 대해 읽기</li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/688-pod-overhead>파드 오버헤드 기능 설계</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-643212488f778acf04bebed65ba34441>3 - 컨테이너 환경 변수</h1><p>이 페이지는 컨테이너 환경에서 컨테이너에 가용한 리소스에 대해 설명한다.</p><h2 id=컨테이너-환경>컨테이너 환경</h2><p>쿠버네티스 컨테이너 환경은 컨테이너에 몇 가지 중요한 리소스를 제공한다.</p><ul><li>하나의 <a href=/ko/docs/concepts/containers/images/>이미지</a>와 하나 이상의 <a href=/ko/docs/concepts/storage/volumes/>볼륨</a>이 결합된 파일 시스템.</li><li>컨테이너 자신에 대한 정보.</li><li>클러스터 내의 다른 오브젝트에 대한 정보.</li></ul><h3 id=컨테이너-정보>컨테이너 정보</h3><p>컨테이너의 <em>호스트네임</em> 은 컨테이너가 동작 중인 파드의 이름과 같다.
그것은 <code>hostname</code> 커맨드 또는 libc의
<a href=https://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a>
함수 호출을 통해서 구할 수 있다.</p><p>파드 이름과 네임스페이스는
<a href=/ko/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>다운워드(Downward) API</a>를 통해 환경 변수로 구할 수 있다.</p><p>컨테이너 이미지에 정적으로 명시된 환경 변수와 마찬가지로,
파드 정의에서의 사용자 정의 환경 변수도 컨테이너가 사용할 수 있다.</p><h3 id=클러스터-정보>클러스터 정보</h3><p>컨테이너가 생성될 때 실행 중이던 모든 서비스의 목록은 환경 변수로 해당 컨테이너에서 사용할 수
있다.
이 목록은 새로운 컨테이너의 파드 및 쿠버네티스 컨트롤 플레인 서비스와 동일한 네임스페이스 내에 있는 서비스로 한정된다.</p><p><em>bar</em> 라는 이름의 컨테이너에 매핑되는 <em>foo</em> 라는 이름의 서비스에 대해서는,
다음의 형태로 변수가 정의된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;서비스가 동작 중인 호스트&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;서비스가 동작 중인 포트&gt;
</span></span></code></pre></div><p>서비스에 지정된 IP 주소가 있고 <a href=https://releases.k8s.io/v1.25.0/cluster/addons/dns/>DNS 애드온</a>이 활성화된 경우, DNS를 통해서 컨테이너가 서비스를 사용할 수 있다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/containers/container-lifecycle-hooks/>컨테이너 라이프사이클 훅(hooks)</a>에 대해 더 배워 보기.</li><li><a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>컨테이너 라이프사이클 이벤트에 핸들러 부착</a>
실제 경험 얻기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e6941d969d81540208a3e78bc56f43bc>4 - 컨테이너 라이프사이클 훅(Hook)</h1><p>이 페이지는 kubelet이 관리하는 컨테이너가 관리 라이프사이클 동안의 이벤트에 의해 발동되는 코드를 실행하기 위해서
컨테이너 라이프사이클 훅 프레임워크를 사용하는 방법에 대해서 설명한다.</p><h2 id=개요>개요</h2><p>Angular와 같이, 컴포넌트 라이프사이클 훅을 가진 많은 프로그래밍 언어 프레임워크와 유사하게,
쿠버네티스도 컨테이너에 라이프사이클 훅을 제공한다.
훅은 컨테이너가 관리 라이프사이클의 이벤트를 인지하고 상응하는
라이프사이클 훅이 실행될 때 핸들러에 구현된 코드를 실행할 수 있게 한다.</p><h2 id=컨테이너-훅>컨테이너 훅</h2><p>컨테이너에 노출되는 훅은 두 가지가 있다.</p><p><code>PostStart</code></p><p>이 훅은 컨테이너가 생성된 직후에 실행된다.
그러나, 훅이 컨테이너 엔트리포인트에 앞서서 실행된다는 보장은 없다.
파라미터는 핸들러에 전달되지 않는다.</p><p><code>PreStop</code></p><p>이 훅은 API 요청이나 활성 프로브(liveness probe) 실패, 선점, 자원 경합
등의 관리 이벤트로 인해 컨테이너가 종료되기 직전에 호출된다. 컨테이너가 이미
terminated 또는 completed 상태인 경우에는 <code>PreStop</code> 훅 요청이 실패하며,
훅은 컨테이너를 중지하기 위한 TERM 신호가 보내지기 이전에 완료되어야 한다. 파드의 그레이스 종료
기간(termination grace period)의 초읽기는 <code>PreStop</code> 훅이 실행되기 전에 시작되어,
핸들러의 결과에 상관없이 컨테이너가 파드의 그레이스 종료 기간 내에 결국 종료되도록 한다.
어떠한 파라미터도 핸들러에게 전달되지 않는다.</p><p>종료 동작에 더 자세한 대한 설명은
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%A2%85%EB%A3%8C>파드의 종료</a>에서 찾을 수 있다.</p><h3 id=훅-핸들러-구현>훅 핸들러 구현</h3><p>컨테이너는 훅의 핸들러를 구현하고 등록함으로써 해당 훅에 접근할 수 있다.
구현될 수 있는 컨테이너의 훅 핸들러에는 두 가지 유형이 있다.</p><ul><li>Exec - 컨테이너의 cgroups와 네임스페이스 안에서, <code>pre-stop.sh</code>와 같은, 특정 커맨드를 실행.
커맨드에 의해 소비된 리소스는 해당 컨테이너에 대해 계산된다.</li><li>HTTP - 컨테이너의 특정 엔드포인트에 대해서 HTTP 요청을 실행.</li></ul><h3 id=훅-핸들러-실행>훅 핸들러 실행</h3><p>컨테이너 라이프사이클 관리 훅이 호출되면,
쿠버네티스 관리 시스템은 훅 동작에 따라 핸들러를 실행하고,
<code>httpGet</code> 와 <code>tcpSocket</code> 은 kubelet 프로세스에 의해 실행되고, <code>exec</code> 은 컨테이너에서 실행된다.</p><p>훅 핸들러 호출은 해당 컨테이너를 포함하고 있는 파드의 컨텍스트와 동기적으로 동작한다.
이것은 <code>PostStart</code> 훅에 대해서,
훅이 컨테이너 엔트리포인트와는 비동기적으로 동작함을 의미한다.
그러나, 만약 해당 훅이 너무 오래 동작하거나 어딘가에 걸려 있다면,
컨테이너는 <code>running</code> 상태에 이르지 못한다.</p><p><code>PreStop</code> 훅은 컨테이너 중지 신호에서 비동기적으로 실행되지 않는다. 훅은
TERM 신호를 보내기 전에 실행을 완료해야 한다. 실행 중에 <code>PreStop</code> 훅이 중단되면,
파드의 단계는 <code>Terminating</code> 이며 <code>terminationGracePeriodSeconds</code> 가
만료된 후 파드가 종료될 때까지 남아 있다. 이 유예 기간은 <code>PreStop</code> 훅이
실행되고 컨테이너가 정상적으로 중지되는 데 걸리는 총 시간에 적용된다. 예를 들어,
<code>terminationGracePeriodSeconds</code> 가 60이고, 훅이 완료되는 데 55초가 걸리고,
컨테이너가 신호를 수신한 후 정상적으로 중지하는 데 10초가 걸리면, <code>terminationGracePeriodSeconds</code> 이후
컨테이너가 정상적으로 중지되기 전에 종료된다. 이 두 가지 일이 발생하는 데
걸리는 총 시간(55+10)보다 적다.</p><p>만약 <code>PostStart</code> 또는 <code>PreStop</code> 훅이 실패하면,
그것은 컨테이너를 종료시킨다.</p><p>사용자는 훅 핸들러를 가능한 한 가볍게 만들어야 한다.
그러나, 컨테이너가 멈추기 전 상태를 저장하는 것과 같이,
오래 동작하는 커맨드가 의미 있는 경우도 있다.</p><h3 id=훅-전달-보장>훅 전달 보장</h3><p>훅 전달은 <em>한 번 이상</em> 으로 의도되어 있는데,
이는 <code>PostStart</code> 또는 <code>PreStop</code>와 같은 특정 이벤트에 대해서,
훅이 여러 번 호출될 수 있다는 것을 의미한다.
이것을 올바르게 처리하는 것은 훅의 구현에 달려 있다.</p><p>일반적으로, 전달은 단 한 번만 이루어진다.
예를 들어, HTTP 훅 수신기가 다운되어 트래픽을 받을 수 없는 경우에도,
재전송을 시도하지 않는다.
그러나, 드문 경우로, 이중 전달이 발생할 수 있다.
예를 들어, 훅을 전송하는 도중에 kubelet이 재시작된다면,
Kubelet이 구동된 후에 해당 훅은 재전송될 것이다.</p><h3 id=훅-핸들러-디버깅>훅 핸들러 디버깅</h3><p>훅 핸들러의 로그는 파드 이벤트로 노출되지 않는다.
만약 핸들러가 어떠한 이유로 실패하면, 핸들러는 이벤트를 방송한다.
<code>PostStart</code>의 경우 <code>FailedPostStartHook</code> 이벤트이며,
<code>PreStop</code>의 경우 <code>FailedPreStopHook</code> 이벤트이다.
실패한 <code>FailedPostStartHook</code> 이벤트를 직접 생성하려면, <a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/lifecycle-events.yaml>lifecycle-events.yaml</a> 파일을 수정하여 postStart 명령을 "badcommand"로 변경하고 이를 적용한다.
다음은 <code>kubectl describe pod lifecycle-demo</code> 를 실행하여 볼 수 있는 이벤트 출력 예시이다.</p><pre tabindex=0><code>Events:
  Type     Reason               Age              From               Message
  ----     ------               ----             ----               -------
  Normal   Scheduled            7s               default-scheduler  Successfully assigned default/lifecycle-demo to ip-XXX-XXX-XX-XX.us-east-2...
  Normal   Pulled               6s               kubelet            Successfully pulled image &#34;nginx&#34; in 229.604315ms
  Normal   Pulling              4s (x2 over 6s)  kubelet            Pulling image &#34;nginx&#34;
  Normal   Created              4s (x2 over 5s)  kubelet            Created container lifecycle-demo-container
  Normal   Started              4s (x2 over 5s)  kubelet            Started container lifecycle-demo-container
  Warning  FailedPostStartHook  4s (x2 over 5s)  kubelet            Exec lifecycle hook ([badcommand]) for Container &#34;lifecycle-demo-container&#34; in Pod &#34;lifecycle-demo_default(30229739-9651-4e5a-9a32-a8f1688862db)&#34; failed - error: command &#39;badcommand&#39; exited with 126: , message: &#34;OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: \&#34;badcommand\&#34;: executable file not found in $PATH: unknown\r\n&#34;
  Normal   Killing              4s (x2 over 5s)  kubelet            FailedPostStartHook
  Normal   Pulled               4s               kubelet            Successfully pulled image &#34;nginx&#34; in 215.66395ms
  Warning  BackOff              2s (x2 over 3s)  kubelet            Back-off restarting failed container
</code></pre><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/containers/container-environment/>컨테이너 환경</a>에 대해 더 배우기.</li><li><a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>컨테이너 라이프사이클 이벤트에 핸들러 부착</a>
실습 경험하기.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>