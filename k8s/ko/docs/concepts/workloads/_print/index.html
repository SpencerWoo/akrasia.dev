<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/workloads/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/workloads/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/workloads/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/workloads/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/workloads/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/workloads/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/workloads/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/workloads/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/concepts/workloads/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>워크로드 | Kubernetes</title><meta property="og:title" content="워크로드"><meta property="og:description" content="쿠버네티스에서 배포할 수 있는 가장 작은 컴퓨트 오브젝트인 파드와, 이를 실행하는 데 도움이 되는 하이-레벨(higher-level) 추상화
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/workloads/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="워크로드"><meta itemprop=description content="쿠버네티스에서 배포할 수 있는 가장 작은 컴퓨트 오브젝트인 파드와, 이를 실행하는 데 도움이 되는 하이-레벨(higher-level) 추상화
"><meta name=twitter:card content="summary"><meta name=twitter:title content="워크로드"><meta name=twitter:description content="쿠버네티스에서 배포할 수 있는 가장 작은 컴퓨트 오브젝트인 파드와, 이를 실행하는 데 도움이 되는 하이-레벨(higher-level) 추상화
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="쿠버네티스에서 배포할 수 있는 가장 작은 컴퓨트 오브젝트인 파드와, 이를 실행하는 데 도움이 되는 하이-레벨(higher-level) 추상화
"><meta property="og:description" content="쿠버네티스에서 배포할 수 있는 가장 작은 컴퓨트 오브젝트인 파드와, 이를 실행하는 데 도움이 되는 하이-레벨(higher-level) 추상화
"><meta name=twitter:description content="쿠버네티스에서 배포할 수 있는 가장 작은 컴퓨트 오브젝트인 파드와, 이를 실행하는 데 도움이 되는 하이-레벨(higher-level) 추상화
"><meta property="og:url" content="https://kubernetes.io/ko/docs/concepts/workloads/"><meta property="og:title" content="워크로드"><meta name=twitter:title content="워크로드"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/concepts/workloads/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/concepts/workloads/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/concepts/workloads/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/concepts/workloads/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/concepts/workloads/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/workloads/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/workloads/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/concepts/workloads/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/workloads/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/workloads/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/workloads/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/concepts/workloads/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/workloads/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/concepts/workloads/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>워크로드</h1><div class=lead>쿠버네티스에서 배포할 수 있는 가장 작은 컴퓨트 오브젝트인 파드와, 이를 실행하는 데 도움이 되는 하이-레벨(higher-level) 추상화</div><ul><li>1: <a href=#pg-4d68b0ccf9c683e6368ffdcc40c838d4>파드</a></li><ul><li>1.1: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>파드 라이프사이클</a></li><li>1.2: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>초기화 컨테이너</a></li><li>1.3: <a href=#pg-4aaf43c715cd764bc8ed4436f3537e68>중단(disruption)</a></li><li>1.4: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>임시(Ephemeral) 컨테이너</a></li><li>1.5: <a href=#pg-868be91dc02aab6dc768102e4abf5eff>사용자 네임스페이스</a></li><li>1.6: <a href=#pg-420713565efe2f940e277f6b4824ad9a>다운워드(Downward) API</a></li></ul><li>2: <a href=#pg-89637410cacae45a36ab1cc278c482eb>워크로드 리소스</a></li><ul><li>2.1: <a href=#pg-a2dc0393e0c4079e1c504b6429844e86>디플로이먼트</a></li><li>2.2: <a href=#pg-d459b930218774655fa7fd1620625539>레플리카셋</a></li><li>2.3: <a href=#pg-6d72299952c37ca8cc61b416e5bdbcd4>스테이트풀셋</a></li><li>2.4: <a href=#pg-41600eb8b6631c88848156f381e9d588>데몬셋</a></li><li>2.5: <a href=#pg-cc7cc3c4907039d9f863162e20bfbbef>잡</a></li><li>2.6: <a href=#pg-4de50a37ebb6f2340484192126cb7a04>완료된 잡 자동 정리</a></li><li>2.7: <a href=#pg-2e4cec01c525b45eccd6010e21cc76d9>크론잡</a></li><li>2.8: <a href=#pg-27f1331d515d95f76aa1156088b4ad91>레플리케이션 컨트롤러</a></li></ul></ul><div class=content><p>워크로드는 쿠버네티스에서 구동되는 애플리케이션이다.
워크로드가 단일 컴포넌트이거나 함께 작동하는 여러 컴포넌트이든 관계없이, 쿠버네티스에서는 워크로드를 일련의
<a href=/ko/docs/concepts/workloads/pods><em>파드</em></a> 집합 내에서 실행한다.
쿠버네티스에서 <code>Pod</code> 는 클러스터에서 실행 중인 <a class=glossary-tooltip title='소프트웨어와 그것에 종속된 모든 것을 포함한 가볍고 휴대성이 높은 실행 가능 이미지.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/containers/ target=_blank aria-label=컨테이너>컨테이너</a>
집합을 나타낸다.</p><p>쿠버네티스 파드에는 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/>정의된 라이프사이클</a>이 있다.
예를 들어, 일단 파드가 클러스터에서 실행되고 나서
해당 파드가 동작 중인 <a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에
심각한 오류가 발생하면 해당 노드의 모든 파드가 실패한다. 쿠버네티스는 이 수준의 실패를
최종(final)으로 취급한다. 사용자는 향후 노드가 복구되는 것과 상관 없이 <code>Pod</code> 를 새로 생성해야 한다.</p><p>그러나, 작업이 훨씬 쉽도록, 각 <code>Pod</code> 를 직접 관리할 필요는 없도록 만들었다.
대신, 사용자를 대신하여 파드 집합을 관리하는 <em>워크로드 리소스</em> 를 사용할 수 있다.
이러한 리소스는 지정한 상태와 일치하도록 올바른 수의 올바른 파드 유형이
실행되고 있는지 확인하는 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>를
구성한다.</p><p>쿠버네티스는 다음과 같이 여러 가지 빌트인(built-in) 워크로드 리소스를 제공한다.</p><ul><li><a href=/ko/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a> 및 <a href=/ko/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>
(레거시 리소스
<a class=glossary-tooltip title='(사용 중단된) 복제된 애플리케이션을 관리하는 API 오브젝트' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-replication-controller' target=_blank aria-label=레플리케이션컨트롤러(ReplicationController)>레플리케이션컨트롤러(ReplicationController)</a>를 대체).
<code>Deployment</code> 는 <code>Deployment</code> 의 모든 <code>Pod</code> 가 필요 시 교체 또는 상호 교체 가능한 경우,
클러스터의 스테이트리스 애플리케이션 워크로드를 관리하기에 적합하다.</li><li><a href=/ko/docs/concepts/workloads/controllers/statefulset/><code>StatefulSet</code></a>는
어떻게든 스테이트(state)를 추적하는 하나 이상의 파드를 동작하게 해준다. 예를 들면, 워크로드가
데이터를 지속적으로 기록하는 경우, 사용자는 <code>Pod</code> 와
<a href=/ko/docs/concepts/storage/persistent-volumes/><code>PersistentVolume</code></a>을 연계하는 <code>StatefulSet</code> 을 실행할 수 있다.
전체적인 회복력 향상을 위해서, <code>StatefulSet</code> 의 <code>Pods</code> 에서 동작 중인 코드는 동일한 <code>StatefulSet</code> 의
다른 <code>Pods</code> 로 데이터를 복제할 수 있다.</li><li><a href=/ko/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>은 노드-로컬 기능(node-local facilities)을 제공하는 <code>Pods</code> 를 정의한다.
이러한 기능들은 클러스터를 운용하는 데 기본적인 것일 것이다.
예를 들면, 네트워킹 지원 도구 또는
<a class=glossary-tooltip title='쿠버네티스의 기능을 확장하는 리소스.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/cluster-administration/addons/ target=_blank aria-label=add-on>add-on</a> 등이 있다.
<code>DaemonSet</code> 의 명세에 맞는 노드를 클러스터에 추가할 때마다,
컨트롤 플레인은 해당 신규 노드에 <code>DaemonSet</code> 을 위한 <code>Pod</code> 를 스케줄한다.</li><li><a href=/ko/docs/concepts/workloads/controllers/job/><code>Job</code></a> 및
<a href=/ko/docs/concepts/workloads/controllers/cron-jobs/><code>CronJob</code></a>은
실행 완료 후 중단되는 작업을 정의한다. <code>CronJobs</code> 이 스케줄에 따라 반복되는 반면,
잡은 단 한 번의 작업을 나타낸다.</li></ul><p>더 넓은 쿠버네티스 에코시스템 내에서는 추가적인 동작을 제공하는 제 3자의 워크로드
리소스도 찾을 수 있다.
<a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>커스텀 리소스 데피니션</a>을 사용하면,
쿠버네티스 코어에서 제공하지 않는 특별한 동작을 원하는 경우 제 3자의 워크로드 리소스를
추가할 수 있다. 예를 들어, 사용자 애플리케이션을 위한 <code>Pods</code> 의 그룹을 실행하되
<em>모든</em> 파드가 가용한 경우가 아닌 경우 멈추고 싶다면(아마도 높은 처리량의 분산 처리를 하는 상황 같은),
사용자는 해당 기능을 제공하는 확장을 구현하거나 설치할 수 있다.</p><h2 id=다음-내용>다음 내용</h2><p>각 리소스에 대해 읽을 수 있을 뿐만 아니라, 리소스와 관련된 특정 작업에 대해서도 알아볼 수 있다.</p><ul><li><a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/><code>Deployment</code> 를 사용하여 스테이트리스(stateless) 애플리케이션 실행</a></li><li>스테이트풀(stateful) 애플리케이션을 <a href=/ko/docs/tasks/run-application/run-single-instance-stateful-application/>단일 인스턴스</a>
또는 <a href=/docs/tasks/run-application/run-replicated-stateful-application/>복제된 세트</a>로 실행</li><li><a href=/ko/docs/tasks/job/automated-tasks-with-cron-jobs/><code>CronJob</code> 을 사용하여 자동화된 작업 실행</a></li></ul><p>코드를 구성(configuration)에서 분리하는 쿠버네티스의 메커니즘을 배우기 위해서는,
<a href=/ko/docs/concepts/configuration/>구성</a>을 참고하길 바란다.</p><p>다음은 쿠버네티스가 애플리케이션의 파드를 어떻게 관리하는지를 알 수 있게 해주는
두 가지 개념이다.</p><ul><li><a href=/ko/docs/concepts/architecture/garbage-collection/>가비지(Garbage) 수집</a>은 <em>소유하는 리소스</em> 가
제거된 후 클러스터에서 오브젝트를 정리한다.</li><li><a href=/ko/docs/concepts/workloads/controllers/ttlafterfinished/><em>time-to-live after finished</em> 컨트롤러</a>는
잡이 완료된 이후에 정의된 시간이 경과되면 잡을 제거한다.</li></ul><p>일단 애플리케이션이 실행되면, 인터넷에서 <a href=/ko/docs/concepts/services-networking/service/>서비스</a>로
사용하거나, 웹 애플리케이션의 경우에만
<a href=/ko/docs/concepts/services-networking/ingress>인그레스(Ingress)</a>를 이용하여 사용할 수 있다.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-4d68b0ccf9c683e6368ffdcc40c838d4>1 - 파드</h1><p><em>파드(Pod)</em> 는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.</p><p><em>파드</em> (고래 떼(pod of whales)나 콩꼬투리(pea pod)와 마찬가지로)는 하나 이상의
<a href=/ko/docs/concepts/containers/>컨테이너</a>의 그룹이다. 이 그룹은 스토리지 및 네트워크를 공유하고, 해당 컨테이너를 구동하는 방식에 대한 명세를 갖는다. 파드의 콘텐츠는 항상 함께 배치되고,
함께 스케줄되며, 공유 콘텍스트에서 실행된다. 파드는
애플리케이션 별 "논리 호스트"를 모델링한다. 여기에는 상대적으로 밀접하게 결합된 하나 이상의
애플리케이션 컨테이너가 포함된다.
클라우드가 아닌 콘텍스트에서, 동일한 물리 또는 가상 머신에서 실행되는 애플리케이션은 동일한 논리 호스트에서 실행되는 클라우드 애플리케이션과 비슷하다.</p><p>애플리케이션 컨테이너와 마찬가지로, 파드에는
파드 시작 중에 실행되는 <a href=/ko/docs/concepts/workloads/pods/init-containers/>초기화 컨테이너</a>가
포함될 수 있다. 클러스터가 제공하는 경우, 디버깅을 위해
<a href=/ko/docs/concepts/workloads/pods/ephemeral-containers/>임시 컨테이너</a>를
삽입할 수도 있다.</p><h2 id=파드란-무엇인가>파드란 무엇인가?</h2><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <a href=https://www.docker.com/>도커</a>가 가장 일반적으로 잘 알려진
<a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>이지만,
쿠버네티스는 도커 외에도 다양한 컨테이너 런타임을 지원하며,
파드를 설명할 때 도커 관련 용어를 사용하면 더 쉽게 설명할 수 있다.</div><p>파드의 공유 콘텍스트는 리눅스 네임스페이스, 컨트롤 그룹(cgroup) 및
도커 컨테이너를 격리하는 것과 같이 잠재적으로 다른 격리 요소들이다.
파드의 콘텍스트 내에서 개별 애플리케이션은
추가적으로 하위 격리가 적용된다.</p><p>도커 개념 측면에서, 파드는 공유 네임스페이스와 공유 파일시스템 볼륨이
있는 도커 컨테이너 그룹과 비슷하다.</p><h2 id=파드의-사용>파드의 사용</h2><p>다음은 <code>nginx:1.14.2</code> 이미지를 실행하는 컨테이너로 구성되는 파드의 예시이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/simple-pod.yaml download=pods/simple-pod.yaml><code>pods/simple-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-simple-pod-yaml")' title="Copy pods/simple-pod.yaml to clipboard"></img></div><div class=includecode id=pods-simple-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>위에서 설명한 파드를 생성하려면, 다음 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
</span></span></code></pre></div><p>일반적으로 파드는 직접 생성하지는 않으며, 대신 워크로드 리소스를 사용하여 생성한다.
<a href=#%ED%8C%8C%EB%93%9C-%EC%9E%91%EC%97%85>파드 작업</a> 섹션에서 파드와 워크로드 리소스의 관계에 대한
더 많은 정보를 확인한다.</p><h3 id=workload-resources-for-managing-pods>Workload resources for managing pods</h3><p>일반적으로 싱글톤(singleton) 파드를 포함하여 파드를 직접 만들 필요가 없다. 대신, <a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트(Deployment)>디플로이먼트(Deployment)</a> 또는 <a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡(Job)>잡(Job)</a>과 같은 워크로드 리소스를 사용하여 생성한다.
파드가 상태를 추적해야 한다면,
<a class=glossary-tooltip title='내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋(StatefulSet)>스테이트풀셋(StatefulSet)</a> 리소스를 고려한다.</p><p>쿠버네티스 클러스터의 파드는 두 가지 주요 방식으로 사용된다.</p><ul><li><p><strong>단일 컨테이너를 실행하는 파드</strong>. "파드 당 하나의 컨테이너" 모델은
가장 일반적인 쿠버네티스 유스케이스이다. 이 경우, 파드를 단일 컨테이너를 둘러싼
래퍼(wrapper)로 생각할 수 있다. 쿠버네티스는 컨테이너를 직접 관리하는 대신
파드를 관리한다.</p></li><li><p><strong>함께 작동해야 하는 여러 컨테이너를 실행하는 파드</strong>. 파드는
밀접하게 결합되어 있고 리소스를 공유해야 하는 함께 배치된 여러 개의 컨테이너로
구성된 애플리케이션을 캡슐화할 수 있다. 이런 함께 배치된 컨테이너는
하나의 결합된 서비스 단위를 형성한다. 예를 들어, 하나의 컨테이너는 공유 볼륨에
저장된 데이터를 퍼블릭에 제공하는 반면, 별도의 <em>사이드카</em> 컨테이너는
해당 파일을 새로 고치거나 업데이트한다.
파드는 이러한 컨테이너, 스토리지 리소스, 임시 네트워크 ID를
단일 단위로 함께 래핑한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 단일 파드에서 함께 배치된 또는 함께 관리되는 여러 컨테이너를 그룹화하는 것은
비교적 고급 유스케이스이다. 이 패턴은 컨테이너가 밀접하게 결합된
특정 인스턴스에서만 사용해야 한다.</div></li></ul><p>각 파드는 특정 애플리케이션의 단일 인스턴스를 실행하기 위한 것이다. 더 많은
인스턴스를 실행하여 더 많은 전체 리소스를 제공하기 위해 애플리케이션을
수평적으로 확장하려면, 각 인스턴스에 하나씩, 여러 파드를 사용해야 한다.
쿠버네티스에서는 이를 일반적으로 <em>레플리케이션</em> 이라고 한다.
복제된 파드는 일반적으로 워크로드 리소스와
해당 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>에 의해 그룹으로 생성되고 관리된다.</p><p>쿠버네티스가 워크로드 리소스와 해당 컨트롤러를 사용하여 애플리케이션 스케일링과
자동 복구를 구현하는 방법에 대한 자세한 내용은
<a href=#%ED%8C%8C%EB%93%9C%EC%99%80-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC>파드와 컨트롤러</a>를 참고한다.</p><h3 id=파드가-여러-컨테이너를-관리하는-방법>파드가 여러 컨테이너를 관리하는 방법</h3><p>파드는 응집력있는 서비스 단위를 형성하는 여러 협력 프로세스(컨테이너)를
지원하도록 설계되었다. 파드의 컨테이너는 클러스터의 동일한 물리 또는 가상 머신에서
자동으로 같은 위치에 배치되고 함께 스케줄된다. 컨테이너는
리소스와 의존성을 공유하고, 서로 통신하고, 종료 시기와 방법을
조정할 수 있다.</p><p>예를 들어, 다음 다이어그램에서와 같이
공유 볼륨의 파일에 대한 웹 서버 역할을 하는 컨테이너와, 원격 소스에서 해당 파일을 업데이트하는
별도의 "사이드카" 컨테이너가 있을 수 있다.</p><figure class=diagram-medium><img src=/images/docs/pod.svg alt="파드 생성 다이어그램"></figure><p>일부 파드에는 <a class=glossary-tooltip title='워크로드의 일부를 실행하는데 사용되는 컨테이너. 초기화 컨테이너와 비교된다.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-app-container' target=_blank aria-label='앱 컨테이너'>앱 컨테이너</a> 뿐만 아니라 <a class=glossary-tooltip title='앱 컨테이너가 동작하기 전에 완료되기 위해 실행되는 하나 이상의 초기화 컨테이너.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-init-container' target=_blank aria-label='초기화 컨테이너'>초기화 컨테이너</a>를 갖고 있다. 초기화 컨테이너는 앱 컨테이너가 시작되기 전에 실행되고 완료된다.</p><p>파드는 기본적으로 파드에 속한 컨테이너에 <a href=#%ED%8C%8C%EB%93%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9>네트워킹</a>과 <a href=#pod-storage>스토리지</a>라는
두 가지 종류의 공유 리소스를 제공한다.</p><h2 id=파드-작업>파드 작업</h2><p>사용자가 쿠버네티스에서 직접 개별 파드를 만드는 경우는 거의 없다. 싱글톤 파드도 마찬가지이다. 이는
파드가 상대적으로 일시적인, 일회용 엔티티로 설계되었기 때문이다. 파드가
생성될 때(사용자가 직접 또는
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>가 간접적으로), 새 파드는
클러스터의 <a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에서 실행되도록 스케줄된다.
파드는 파드 실행이 완료되거나, 파드 오브젝트가 삭제되거나,
리소스 부족으로 인해 파드가 <em>축출</em> 되거나, 노드가 실패할 때까지 해당 노드에 남아있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드에서 컨테이너를 다시 시작하는 것과 파드를 다시 시작하는 것을 혼동해서는 안된다. 파드는
프로세스가 아니라 컨테이너를 실행하기 위한 환경이다. 파드는
삭제될 때까지 유지된다.</div><p>파드 오브젝트에 대한 매니페스트를 만들 때, 지정된 이름이 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>인지 확인한다.</p><h3 id=파드-os>파드 OS</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><p>파드를 실행할 때 OS를 표시하려면 <code>.spec.os.name</code> 필드를 <code>windows</code> 또는
<code>linux</code>로 설정해야 한다. 이 두 가지 운영체제는 현재 쿠버네티스에서 지원되는
유일한 운영체제이다. 앞으로 이 목록이 확장될 수 있다.</p><p>쿠버네티스 v1.25에서, 이 필드에 대해 설정한 값은
파드의 <a class=glossary-tooltip title='노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=스케줄링>스케줄링</a>에 영향을 미치지 않는다.
<code>.spec.os.name</code>을 설정하면 파드 검증 시
OS를 식별하는 데 도움이 된다.
kubelet은
자신이 실행되고 있는 노드의 운영체제와
동일하지 않은 파드 OS가 명시된 파드의 실행을 거부한다.
<a href=/ko/docs/concepts/security/pod-security-standards/>파드 시큐리티 스탠다드</a>도 이 필드를 사용하여 해당 운영체제와 관련이 없는 정책을 시행하지 않도록 한다.</p><h3 id=파드와-컨트롤러>파드와 컨트롤러</h3><p>워크로드 리소스를 사용하여 여러 파드를 만들고 관리할 수 있다. 리소스에 대한 컨트롤러는
파드 장애 시 복제 및 롤아웃과 자동 복구를
처리한다. 예를 들어, 노드가 실패하면, 컨트롤러는 해당 노드의 파드가 작동을 중지했음을
인식하고 대체 파드를 생성한다. 스케줄러는
대체 파드를 정상 노드에 배치한다.</p><p>다음은 하나 이상의 파드를 관리하는 워크로드 리소스의 몇 가지 예시이다.</p><ul><li><a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a></li><li><a class=glossary-tooltip title='내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a></li><li><a class=glossary-tooltip title='파드의 복제본을 클러스터 노드 집합에서 동작하게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=데몬셋(DaemonSet)>데몬셋(DaemonSet)</a></li></ul><h3 id=파드-템플릿>파드 템플릿</h3><p><a class=glossary-tooltip title='워크로드는 클러스터의 컨테이너를 동작시키고 관리하기 위해 사용하는 오브젝트이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/ target=_blank aria-label=워크로드>워크로드</a> 리소스에 대한 컨트롤러는
<em>파드 템플릿</em> 에서 파드를 생성하고 사용자 대신 해당 파드를 관리한다.</p><p>파드템플릿(PodTemplate)은 파드를 생성하기 위한 명세이며,
<a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>,
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a> 및
<a href=/ko/docs/concepts/workloads/controllers/daemonset/>데몬셋</a>과 같은 워크로드 리소스에 포함된다.</p><p>워크로드 리소스의 각 컨트롤러는 워크로드 오브젝트 내부의 <code>PodTemplate</code> 을
사용하여 실제 파드를 생성한다. <code>PodTemplate</code> 은 앱을 실행하는 데 사용되는 워크로드 리소스가
무엇이든지 원하는 상태의 일부이다.</p><p>아래 샘플은 하나의 컨테이너를 시작하는 <code>template</code> 이 있는 간단한 잡의
매니페스트이다. 해당 파드의 컨테이너는 메시지를 출력한 다음 일시 중지한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 여기서부터 파드 템플릿이다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo &#34;Hello, Kubernetes!&#34; &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 여기까지 파드 템플릿이다</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>파드 템플릿을 수정하거나 새로운 파드 템플릿으로 바꿔도 이미 존재하는
파드에는 직접적인 영향을 주지 않는다. 워크로드 리소스의 파드 템플릿을
변경하는 경우, 해당 리소스는 수정된 템플릿을 사용하는 대체 파드를 생성해야 한다.</p><p>예를 들어, 스테이트풀셋 컨트롤러는 실행 중인 파드가 각 스테이트풀셋 오브젝트에 대한 현재
파드 템플릿과 일치하는지 확인한다. 스테이트풀셋을 수정하여 파드 템플릿을
변경하면, 스테이트풀셋이 업데이트된 템플릿을 기반으로 새로운 파드를 생성하기 시작한다.
결국, 모든 이전의 파드가 새로운 파드로 교체되고, 업데이트가 완료된다.</p><p>각 워크로드 리소스는 파드 템플릿의 변경 사항을 처리하기 위한 자체 규칙을 구현한다.
스테이트풀셋에 대해 자세히 알아 보려면,
스테이트풀셋 기본 튜토리얼에서 <a href=/ko/docs/tutorials/stateful-application/basic-stateful-set/#%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%8A%B8%ED%92%80%EC%85%8B-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EA%B8%B0>업데이트 전략</a>을 읽어본다.</p><p>노드에서 <a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>은
파드 템플릿과 업데이트에 대한 상세 정보를 직접 관찰하거나 관리하지 않는다. 이러한
상세 내용은 추상화된다. 이러한 추상화와 관심사 분리(separation of concerns)는
시스템 시맨틱을 단순화하고, 기존 코드를 변경하지 않고도 클러스터의 동작을
확장할 수 있게 한다.</p><h2 id=파드-갱신-및-교체>파드 갱신 및 교체</h2><p>이전 섹션에서 언급한 바와 같이, 워크로드 리소스의 파드
템플릿이 바뀌면, 컨트롤러는 기존의 파드를 갱신하거나 패치하는 대신
갱신된 템플릿을 기반으로 신규 파드를 생성한다.</p><p>쿠버네티스는 사용자가 파드를 직접 관리하는 것을 막지는 않는다.
동작 중인 파드의 필드를 갱신하는 것도 가능하다.
그러나,
<a href=/docs/reference/generated/kubernetes-api/v1.25/#patch-pod-v1-core><code>patch</code></a> 및
<a href=/docs/reference/generated/kubernetes-api/v1.25/#replace-pod-v1-core><code>replace</code></a>와 같은
파드 갱신 작업에는 다음과 같은 제약이 있다.</p><ul><li><p>파드에 대한 대부분의 메타데이터는 불변(immutable)이다. 예를 들면, 사용자는
<code>namespace</code>, <code>name</code>, <code>uid</code>, 또는 <code>creationTimestamp</code> 필드를 변경할 수 없다.
그리고 <code>generation</code> 필드는 고유하다. 이 필드는 필드의 현재 값을 증가시키는
갱신만 허용한다.</p></li><li><p><code>metadata.deletionTimestamp</code> 가 설정된 경우,
<code>metadata.finalizers</code> 리스트에 새로운 항목이 추가될 수 없다.</p></li><li><p>파드 갱신은 <code>spec.containers[*].image</code>, <code>spec.initContainers[*].image</code>,
<code>spec.activeDeadlineSeconds</code>, 또는 <code>spec.tolerations</code> 이외의 필드는
변경하지 않을 것이다. <code>spec.tolerations</code> 에 대해서만 새로운 항목을 추가할 수 있다.</p></li><li><p><code>spec.activeDeadlineSeconds</code> 필드를 추가할 때는, 다음의 두 가지 형태의 갱신만
허용한다.</p><ol><li>지정되지 않은 필드를 양수로 설정;</li><li>필드의 양수를 음수가 아닌 더 작은 숫자로
갱신.</li></ol></li></ul><h2 id=리소스-공유와-통신>리소스 공유와 통신</h2><p>파드는 파드에 속한 컨테이너 간의 데이터 공유와 통신을
지원한다.</p><h3 id=pod-storage>파드 스토리지</h3><p>파드는 공유 스토리지 <a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>의
집합을 지정할 수 있다. 파드의 모든 컨테이너는
공유 볼륨에 접근할 수 있으므로, 해당 컨테이너가 데이터를 공유할 수
있다. 또한 볼륨은 내부 컨테이너 중 하나를 다시
시작해야 하는 경우 파드의 영구 데이터를 유지하도록 허용한다.
쿠버네티스가 공유 스토리지를 구현하고 파드에서 사용할 수 있도록 하는 방법에 대한
자세한 내용은 <a href=/ko/docs/concepts/storage/>스토리지</a>를 참고한다.</p><h3 id=파드-네트워킹>파드 네트워킹</h3><p>각 파드에는 각 주소 패밀리에 대해 고유한 IP 주소가 할당된다.
파드의 모든 컨테이너는 네트워크 네임스페이스를 공유하며,
여기에는 IP 주소와 네트워크 포트가 포함된다.
파드 내부(이 경우에 <strong>만</strong> 해당)에서, 파드에 속한 컨테이너는
<code>localhost</code> 를 사용하여 서로 통신할 수 있다.
파드의 컨테이너가 <em>파드 외부의</em> 엔티티와 통신할 때,
공유 네트워크 리소스(포트와 같은)를 사용하는 방법을 조정해야 한다.
파드 내에서 컨테이너는 IP 주소와 포트 공간을 공유하며,
<code>localhost</code> 를 통해 서로를 찾을 수 있다.
파드의 컨테이너는 SystemV 세마포어 또는 POSIX 공유 메모리와 같은
표준 프로세스 간 통신을 사용하여 서로 통신할 수도 있다.
다른 파드의 컨테이너는 고유한 IP 주소를 가지며 특별한 구성 없이 OS 수준의 IPC로 통신할 수 없다.
다른 파드에서 실행되는 컨테이너와 상호 작용하려는 컨테이너는 IP 네트워킹을 사용하여 통신할 수 있다.</p><p>파드 내의 컨테이너는 시스템 호스트명이 파드에 대해 구성된
<code>name</code> 과 동일한 것으로 간주한다. <a href=/ko/docs/concepts/cluster-administration/networking/>네트워킹</a> 섹션에 이에 대한
자세한 내용이 있다.</p><h2 id=컨테이너에-대한-특권-모드>컨테이너에 대한 특권 모드</h2><p>리눅스에서, 파드의 모든 컨테이너는 컨테이너 명세의 <a href=/docs/tasks/configure-pod-container/security-context/>보안 컨텍스트</a>에 있는 <code>privileged</code> (리눅스) 플래그를 사용하여 특권 모드를 활성화할 수 있다. 이는 네트워크 스택 조작이나 하드웨어 장치 접근과 같은 운영 체제 관리 기능을 사용하려는 컨테이너에 유용하다.</p><p>클러스터가 <code>WindowsHostProcessContainers</code> 기능을 활성화하였다면, 파드 스펙의 보안 컨텍스트의 <code>windowsOptions.hostProcess</code> 에 의해 <a href=/docs/tasks/configure-pod-container/create-hostprocess-pod>윈도우 HostProcess 파드</a>를 생성할 수 있다. 이러한 모든 컨테이너는 윈도우 HostProcess 컨테이너로 실행해야 한다. HostProcess 파드는 직접적으로 호스트에서 실행하는 것으로, 리눅스 특권있는 컨테이너에서 수행되는 관리 태스크 수행에도 사용할 수 있다. 파드의 모든 컨테이너는 윈도우 HostProcess 컨테이너로 반드시 실행해야 한다. HostProcess 파드는 호스트에서 직접 실행되며 리눅스 특권있는 컨테이너에서 수행되는 것과 같은 관리 작업을 수행하는데도 사용할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 설정을 사용하려면 사용자의 <a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>이 특권이 있는 컨테이너의 개념을 지원해야 한다.</div><h2 id=정적-파드>정적 파드</h2><p><em>정적 파드</em> 는 <a class=glossary-tooltip title='쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 서버'>API 서버</a>가
관찰하는 대신 특정 노드의 kubelet 데몬에 의해 직접
관리된다.
대부분의 파드는 컨트롤 플레인(예를 들어,
<a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>)에 의해 관리되고, 정적 파드의
경우, kubelet이 각 정적 파드를 직접 감독한다(실패하면 다시 시작한다).</p><p>정적 파드는 항상 특정 노드의 <a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a> 하나에 바인딩된다.
정적 파드의 주요 용도는 자체 호스팅 컨트롤 플레인을 실행하는 것이다. 즉,
kubelet을 사용하여 개별 <a href=/ko/docs/concepts/overview/components/#%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%94%8C%EB%A0%88%EC%9D%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8>컨트롤 플레인 컴포넌트</a>를 감독한다.</p><p>kubelet은 자동으로 각 정적 파드에 대한 쿠버네티스 API 서버에서 <a class=glossary-tooltip title='Kubelet의 스태틱 파드(Static Pod)를 추적하는 API 서버 내부의 오브젝트.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-mirror-pod' target=_blank aria-label='미러 파드'>미러 파드</a>를
생성하려고 한다.
즉, 노드에서 실행되는 파드는 API 서버에서 보이지만,
여기에서 제어할 수는 없다는 의미이다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 스태틱 파드의 <code>스펙(spec)</code>은 다른 API 오브젝트
(예를 들면, <a class=glossary-tooltip title='파드에서 실행 중인 프로세스를 위한 신원(identity)을 제공한다.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=서비스어카운트>서비스어카운트</a>,
<a class=glossary-tooltip title='키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>,
<a class=glossary-tooltip title='비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿>시크릿</a>, 등)가 참조할 수 없다.</div><h2 id=컨테이너-프로브>컨테이너 프로브</h2><p>_프로브_는 컨테이너의 kubelet에 의해 주기적으로 실행되는 진단이다. 진단을 수행하기 위하여 kubelet은 다음과 같은 작업을 호출할 수 있다.</p><ul><li><code>ExecAction</code> (컨테이너 런타임의 도움을 받아 수행)</li><li><code>TCPSocketAction</code> (kubelet에 의해 직접 검사)</li><li><code>HTTPGetAction</code> (kubelet에 의해 직접 검사)</li></ul><p><a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%94%84%EB%A1%9C%EB%B8%8C-probe>프로브</a>에 대한 자세한 내용은
파드 라이프사이클 문서를 참고한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/>파드의 라이프사이클</a>에 대해 알아본다.</li><li><a href=/ko/docs/concepts/containers/runtime-class/>런타임클래스(RuntimeClass)</a>와 이를 사용하여
다양한 컨테이너 런타임 구성으로 다양한 파드를 설정하는 방법에 대해 알아본다.</li><li><a href=/ko/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>과 이를 사용하여 서비스 중단 중에 애플리케이션 가용성을 관리하는 방법에 대해 읽어본다.</li><li>파드는 쿠버네티스 REST API의 최상위 리소스이다.
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/>Pod</a>
오브젝트 정의는 오브젝트를 상세히 설명한다.</li><li><a href=/blog/2015/06/the-distributed-system-toolkit-patterns/>분산 시스템 툴킷: 컴포지트 컨테이너에 대한 패턴</a>은 둘 이상의 컨테이너가 있는 파드의 일반적인 레이아웃을 설명한다.</li><li><a href=/ko/docs/concepts/scheduling-eviction/topology-spread-constraints/>파드 토폴로지 분배 제약 조건</a>에 대해 읽어본다.</li></ul><p>쿠버네티스가 다른 리소스(<a class=glossary-tooltip title='내구성이 있는 스토리지와 파드별로 지속성 식별자를 사용해서 파드 집합의 디플로이먼트와 스케일링을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=스테이트풀셋>스테이트풀셋</a>이나 <a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>와 같은)에서 공통 파드 API를 래핑하는 이유에 대한 콘텍스트를 이해하기 위해서, 다음과 같은 선행 기술에 대해 읽어볼 수 있다.</p><ul><li><a href=https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a></li><li><a href=https://research.google.com/pubs/pub43438.html>Borg</a></li><li><a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a></li><li><a href=https://research.google/pubs/pub41684/>Omega</a></li><li><a href=https://engineering.fb.com/data-center-engineering/tupperware/>Tupperware</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c3c2b9cf30915ec9d46c147201da3332>1.1 - 파드 라이프사이클</h1><p>이 페이지에서는 파드의 라이프사이클을 설명한다. 파드는 정의된 라이프사이클을 따른다.
<code>Pending</code> <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EB%8B%A8%EA%B3%84>단계</a>에서 시작해서, 기본 컨테이너 중 적어도 하나
이상이 OK로 시작하면 <code>Running</code> 단계를 통과하고, 그런 다음 파드의 컨테이너가
실패로 종료되었는지 여부에 따라 <code>Succeeded</code> 또는 <code>Failed</code> 단계로 이동한다.</p><p>파드가 실행되는 동안, kubelet은 일종의 오류를 처리하기 위해 컨테이너를 다시
시작할 수 있다. 파드 내에서, 쿠버네티스는 다양한 컨테이너
<a href=#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%83%81%ED%83%9C>상태</a>를 추적하고 파드를 다시 정상 상태로 만들기 위해 취할 조치를
결정한다.</p><p>쿠버네티스 API에서 파드는 명세와 실제 상태를 모두 가진다.
파드 오브젝트의 상태는 일련의 <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%BB%A8%EB%94%94%EC%85%98>파드 컨디션</a>으로 구성된다.
사용자의 애플리케이션에 유용한 경우, 파드의 컨디션 데이터에
<a href=#pod-readiness-gate>사용자 정의 준비성 정보</a>를 삽입할 수도 있다.</p><p>파드는 파드의 수명 중 한 번만 <a href=/ko/docs/concepts/scheduling-eviction/>스케줄</a>된다.
파드가 노드에 스케줄(할당)되면, 파드는 중지되거나 <a href=#pod-termination>종료</a>될 때까지
해당 노드에서 실행된다.</p><h2 id=파드의-수명>파드의 수명</h2><p>개별 애플리케이션 컨테이너와 마찬가지로, 파드는 비교적
임시(계속 이어지는 것이 아닌) 엔티티로 간주된다. 파드가 생성되고, 고유
ID(<a href=/ko/docs/concepts/overview/working-with-objects/names/#uids>UID</a>)가
할당되고, 종료(재시작 정책에 따라) 또는 삭제될 때까지 남아있는 노드에
스케줄된다.
만약 <a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>가 종료되면, 해당 노드에 스케줄된 파드는
타임아웃 기간 후에 <a href=#pod-garbage-collection>삭제되도록 스케줄된다</a>.</p><p>파드는 자체적으로 자가 치유되지 않는다. 파드가
<a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>에 스케줄된 후에 해당 노드가 실패하면, 파드는 삭제된다. 마찬가지로, 파드는
리소스 부족 또는 노드 유지 관리 작업으로 인한 축출에서 살아남지 못한다. 쿠버네티스는
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>라
부르는 하이-레벨 추상화를 사용하여
상대적으로 일회용인 파드 인스턴스를 관리하는 작업을 처리한다.</p><p>UID로 정의된 특정 파드는 다른 노드로 절대 "다시 스케줄"되지 않는다. 대신,
해당 파드는 사용자가 원한다면 이름은 같지만, UID가 다른, 거의 동일한 새 파드로
대체될 수 있다.</p><p><a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>과
같은 어떤 것이 파드와 동일한 수명을 갖는다는 것은,
특정 파드(정확한 UID 포함)가 존재하는 한 그것이 존재함을
의미한다. 어떤 이유로든 해당 파드가 삭제되고, 동일한 대체 파드가
생성되더라도, 관련된 그것(이 예에서는 볼륨)도 폐기되고
새로 생성된다.</p><figure class=diagram-medium><img src=/images/docs/pod.svg><figcaption><h4>Pod diagram</h4></figcaption></figure><p><em>컨테이너 간의 공유 스토리지에 퍼시스턴트 볼륨을 사용하는 웹 서버와
파일 풀러(puller)가 포함된 다중 컨테이너 파드이다.</em></p><h2 id=파드의-단계>파드의 단계</h2><p>파드의 <code>status</code> 필드는
<code>phase</code> 필드를 포함하는
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a> 오브젝트로 정의된다.</p><p>파드의 phase는 파드가 라이프사이클 중 어느 단계에 해당하는지 표현하는 간단한
고수준의 요약이다. Phase는 컨테이너나 파드의 관측 정보에 대한 포괄적인
롤업이나, 포괄적인 상태 머신을 표현하도록 의도되지는 않았다.</p><p>파드 phase 값에서 숫자와 의미는 엄격하게 지켜진다.
여기에 문서화된 내용 이외에는, 파드와 파드에 주어진 <code>phase</code> 값에 대해서
어떤 사항도 가정되어서는 안 된다.</p><p><code>phase</code>에 가능한 값은 다음과 같다.</p><table><thead><tr><th style=text-align:left>값</th><th style=text-align:left>의미</th></tr></thead><tbody><tr><td style=text-align:left><code>Pending</code></td><td style=text-align:left>파드가 쿠버네티스 클러스터에서 승인되었지만, 하나 이상의 컨테이너가 설정되지 않았고 실행할 준비가 되지 않았다. 여기에는 파드가 스케줄되기 이전까지의 시간 뿐만 아니라 네트워크를 통한 컨테이너 이미지 다운로드 시간도 포함된다.</td></tr><tr><td style=text-align:left><code>Running</code></td><td style=text-align:left>파드가 노드에 바인딩되었고, 모든 컨테이너가 생성되었다. 적어도 하나의 컨테이너가 아직 실행 중이거나, 시작 또는 재시작 중에 있다.</td></tr><tr><td style=text-align:left><code>Succeeded</code></td><td style=text-align:left>파드에 있는 모든 컨테이너들이 성공적으로 종료되었고, 재시작되지 않을 것이다.</td></tr><tr><td style=text-align:left><code>Failed</code></td><td style=text-align:left>파드에 있는 모든 컨테이너가 종료되었고, 적어도 하나 이상의 컨테이너가 실패로 종료되었다. 즉, 해당 컨테이너는 non-zero 상태로 빠져나왔거나(exited) 시스템에 의해서 종료(terminated)되었다.</td></tr><tr><td style=text-align:left><code>Unknown</code></td><td style=text-align:left>어떤 이유에 의해서 파드의 상태를 얻을 수 없다. 이 단계는 일반적으로 파드가 실행되어야 하는 노드와의 통신 오류로 인해 발생한다.</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드가 삭제될 때, 일부 kubectl 커맨드에서 <code>Terminating</code> 이 표시된다.
이 <code>Terminating</code> 상태는 파드의 단계에 해당하지 않는다.
파드에는 그레이스풀하게(gracefully) 종료되도록 기간이 부여되며, 그 기본값은 30초이다.
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination-forced>강제로 파드를 종료</a>하려면 <code>--force</code> 플래그를 설정하면 된다.</div><p>노드가 죽거나 클러스터의 나머지와의 연결이 끊어지면, 쿠버네티스는
손실된 노드의 모든 파드의 <code>phase</code> 를 Failed로 설정하는 정책을 적용한다.</p><h2 id=컨테이너-상태>컨테이너 상태</h2><p>전체 파드의 <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EB%8B%A8%EA%B3%84>단계</a>뿐 아니라, 쿠버네티스는 파드 내부의
각 컨테이너 상태를 추적한다.
<a href=/ko/docs/concepts/containers/container-lifecycle-hooks/>컨테이너 라이프사이클 훅(hook)</a>을
사용하여 컨테이너 라이프사이클의 특정 지점에서 실행할 이벤트를 트리거할 수 있다.</p><p>일단 <a class=glossary-tooltip title='노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=스케줄러>스케줄러</a>가
노드에 파드를 할당하면, kubelet은 <a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>을
사용하여 해당 파드에 대한 컨테이너 생성을 시작한다.
표시될 수 있는 세 가지 컨테이너 상태는 <code>Waiting</code>, <code>Running</code> 그리고 <code>Terminated</code> 이다.</p><p>파드의 컨테이너 상태를 확인하려면, <code>kubectl describe pod &lt;name-of-pod></code> 를
사용할 수 있다. 출력 결과는 해당 파드 내의 각 컨테이너 상태가
표시된다.</p><p>각 상태에는 특정한 의미가 있다.</p><h3 id=container-state-waiting><code>Waiting</code></h3><p>만약 컨테이너가 <code>Running</code> 또는 <code>Terminated</code> 상태가 아니면, <code>Waiting</code> 상태이다.
<code>Waiting</code> 상태의 컨테이너는 시작을 완료하는 데 필요한
작업(예를 들어, 컨테이너 이미지 레지스트리에서 컨테이너 이미지 가져오거나,
<a class=glossary-tooltip title='비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿(Secret)>시크릿(Secret)</a> 데이터를 적용하는 작업)을
계속 실행하고 있는 중이다.
<code>kubectl</code> 을 사용하여 컨테이너가 <code>Waiting</code> 인 파드를 쿼리하면, 컨테이너가
해당 상태에 있는 이유를 요약하는 Reason 필드도 표시된다.</p><h3 id=container-state-running><code>Running</code></h3><p><code>Running</code> 상태는 컨테이너가 문제없이 실행되고 있음을 나타낸다. <code>postStart</code> 훅이
구성되어 있었다면, 이미 실행되고 완료되었다. <code>kubectl</code> 을
사용하여 컨테이너가 <code>Running</code> 인 파드를 쿼리하면, 컨테이너가 <code>Running</code> 상태에 진입한 시기에 대한
정보도 볼 수 있다.</p><h3 id=container-state-terminated><code>Terminated</code></h3><p><code>Terminated</code> 상태의 컨테이너는 실행을 시작한 다음 완료될 때까지
실행되었거나 어떤 이유로 실패했다. <code>kubectl</code> 을 사용하여 컨테이너가 <code>Terminated</code> 인 파드를
쿼리하면, 이유와 종료 코드 그리고 해당 컨테이너의 실행 기간에 대한 시작과
종료 시간이 표시된다.</p><p>컨테이너에 구성된 <code>preStop</code> 훅이 있는 경우,
이 혹은 컨테이너가 <code>Terminated</code> 상태에 들어가기 전에 실행된다.</p><h2 id=restart-policy>컨테이너 재시작 정책</h2><p>파드의 <code>spec</code> 에는 <code>restartPolicy</code> 필드가 있다. 사용 가능한 값은 Always, OnFailure 그리고
Never이다. 기본값은 Always이다.</p><p><code>restartPolicy</code> 는 파드의 모든 컨테이너에 적용된다. <code>restartPolicy</code> 는
동일한 노드에서 kubelet에 의한 컨테이너 재시작만을 의미한다. 파드의 컨테이너가
종료된 후, kubelet은 5분으로 제한되는 지수 백오프 지연(10초, 20초, 40초, …)으로
컨테이너를 재시작한다. 컨테이너가 10분 동안 아무런 문제없이 실행되면,
kubelet은 해당 컨테이너의 재시작 백오프 타이머를 재설정한다.</p><h2 id=파드의-컨디션>파드의 컨디션</h2><p>파드는 하나의 PodStatus를 가지며,
그것은 파드가 통과했거나 통과하지 못한
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podcondition-v1-core>PodConditions</a> 배열을 가진다. kubelet은 다음
PodConditions를 관리한다.</p><ul><li><code>PodScheduled</code>: 파드가 노드에 스케줄되었다.</li><li><code>PodHasNetwork</code>: (알파 기능; 반드시 <a href=#pod-has-network>명시적으로 활성화</a>해야 함)
샌드박스가 성공적으로 생성되고 네트워킹이 구성되었다.</li><li><code>ContainersReady</code>: 파드의 모든 컨테이너가 준비되었다.</li><li><code>Initialized</code>: 모든 <a href=/ko/docs/concepts/workloads/pods/init-containers/>초기화 컨테이너</a>가
성공적으로 완료(completed)되었다.</li><li><code>Ready</code>: 파드는 요청을 처리할 수 있으며 일치하는 모든 서비스의 로드
밸런싱 풀에 추가되어야 한다.</li></ul><table><thead><tr><th style=text-align:left>필드 이름</th><th style=text-align:left>설명</th></tr></thead><tbody><tr><td style=text-align:left><code>type</code></td><td style=text-align:left>이 파드 컨디션의 이름이다.</td></tr><tr><td style=text-align:left><code>status</code></td><td style=text-align:left>가능한 값이 "<code>True</code>", "<code>False</code>", 또는 "<code>Unknown</code>"으로, 해당 컨디션이 적용 가능한지 여부를 나타낸다.</td></tr><tr><td style=text-align:left><code>lastProbeTime</code></td><td style=text-align:left>파드 컨디션이 마지막으로 프로브된 시간의 타임스탬프이다.</td></tr><tr><td style=text-align:left><code>lastTransitionTime</code></td><td style=text-align:left>파드가 한 상태에서 다른 상태로 전환된 마지막 시간에 대한 타임스탬프이다.</td></tr><tr><td style=text-align:left><code>reason</code></td><td style=text-align:left>컨디션의 마지막 전환에 대한 이유를 나타내는 기계가 판독 가능한 UpperCamelCase 텍스트이다.</td></tr><tr><td style=text-align:left><code>message</code></td><td style=text-align:left>마지막 상태 전환에 대한 세부 정보를 나타내는 사람이 읽을 수 있는 메시지이다.</td></tr></tbody></table><h2 id=pod-readiness-gate>파드의 준비성(readiness)</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.14 [stable]</code></div><p>애플리케이션은 추가 피드백 또는 신호를 PodStatus: <em>Pod readiness</em>
와 같이 주입할 수 있다. 이를 사용하기 위해, kubelet이 파드의 준비성을 평가하기
위한 추가적인 컨디션들을 파드의 <code>spec</code> 내 <code>readinessGate</code> 필드를 통해서 지정할 수 있다.</p><p>준비성 게이트는 파드에 대한 <code>status.condition</code> 필드의 현재
상태에 따라 결정된다. 만약 쿠버네티스가 <code>status.conditions</code> 필드에서 해당하는
컨디션을 찾지 못한다면, 그 컨디션의 상태는
기본 값인 "<code>False</code>"가 된다.</p><p>여기 예제가 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readinessGates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>conditionType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready                             <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 내장된 PodCondition이다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 추가적인 PodCondition</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://abcd...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>추가하는 파드 상태에는 쿠버네티스 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EA%B5%AC%EB%AC%B8%EA%B3%BC-%EC%BA%90%EB%A6%AD%ED%84%B0-%EC%85%8B>레이블 키 포맷</a>을 충족하는 이름이 있어야 한다.</p><h3 id=pod-readiness-status>파드 준비성 상태</h3><p><code>kubectl patch</code> 명령어는 아직 오브젝트 상태 패치(patching)를 지원하지 않는다.
이러한 <code>status.conditions</code> 을 파드에 설정하려면 애플리케이션과
<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=오퍼레이터>오퍼레이터</a>의
<code>PATCH</code> 액션을 필요로 한다.
<a href=/ko/docs/reference/using-api/client-libraries/>쿠버네티스 클라이언트 라이브러리</a>를
사용해서 파드 준비성에 대한 사용자 지정 파드 컨디션을 설정하는 코드를 작성할 수 있다.</p><p>사용자 지정 컨디션을 사용하는 파드의 경우, 다음 두 컨디션이 모두 적용되는
경우에 <strong>만</strong> 해당 파드가 준비된 것으로 평가된다.</p><ul><li>파드 내의 모든 컨테이너들이 준비 상태이다.</li><li><code>readinessGates</code>에 지정된 모든 컨디션들이 <code>True</code> 이다.</li></ul><p>파드의 컨테이너가 Ready 이나 적어도 한 개의 사용자 지정 컨디션이 빠졌거나 <code>False</code> 이면,
kubelet은 파드의 <a href=#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%BB%A8%EB%94%94%EC%85%98>컨디션</a>을 <code>ContainerReady</code> 로 설정한다.</p><h3 id=pod-has-network>파드 네트워크 준비성(readiness)</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [alpha]</code></div><p>파드가 노드에 스케줄링되면, kubelet이 이 파드를 승인해야 하고
모든 볼륨이 마운트되어야 한다. 이러한 단계가 완료되면 kubelet은
(<a class=glossary-tooltip title='Kubelet과 컨테이너 런타임을 통합시키기 위한 API' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%9f%b0%ed%83%80%ec%9e%84 target=_blank aria-label='컨테이너 런타임 인터페이스(Container runtime interface, CRI)'>컨테이너 런타임 인터페이스(Container runtime interface, CRI)</a>를 사용하여) 컨테이너 런타임과
통신하여 런타임 샌드박스를 설정하고 파드에 대한 네트워킹을 구성한다. 만약
<code>PodHasNetworkCondition</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화되면,
Kubelet은 파드의 <code>status.conditions</code> 필드에 있는 <code>PodHasNetwork</code> 컨디션을 통해
파드가 초기화 마일스톤에 도달했는지 여부를 보고한다.</p><p>Kubelet이 파드에 네트워킹이 구성된 런타임 샌드박스가
없음을 탐지했을 때 <code>PodHasNetwork</code> 컨디션은 <code>False</code>로 설정된다. 이것은 다음
시나리오에서 발생한다.</p><ul><li>파드 라이프사이클 초기에, kubelet이 컨테이너 런타임을 사용하여 파드를 위한 샌드박스 생성을 아직 ​​시작하지 않은 때.</li><li>파드 라이프사이클 후기에, 파드 샌드박스가 다음중 하나의 이유로
파괴되었을 때.<ul><li>파드 축출 없이, 노드가 재부팅됨</li><li>격리를 위해 가상 머신을 사용하는 컨테이너 런타임을 사용하는 경우,
파드 샌드박스 가상 머신이 재부팅됨(이후, 새로운 샌드박스 및 새로운 컨테이너 네트워크 구성 생성이 필요함)</li></ul></li></ul><p>런타임 플러그인이 파드를 위한 샌드박스 생성 및 네트워크 구성을 성공적으로 완료하면
kubelet이 <code>PodHasNetwork</code> 컨디션을 <code>True</code>로 설정한다.
<code>PodHasNetwork</code> 컨디션이 <code>True</code>로 설정되면 kubelet이 컨테이너 이미지를 풀링하고 컨테이너를 생성할 수 있다.</p><p>초기화 컨테이너가 있는 파드의 경우, kubelet은 초기화 컨테이너가 성공적으로 완료(런타임 플러그인에 의한 성공적인 샌드박스 생성 및 네트워크 구성이 완료되었음을 의미)된 후 <code>Initialized</code> 컨디션을 <code>True</code>로 설정한다.
초기화 컨테이너가 없는 파드의 경우, kubelet은 샌드박스 생성 및 네트워크 구성이 시작되기 전에 <code>Initialized</code> 컨디션을 <code>True</code>로 설정한다.</p><h2 id=컨테이너-프로브-probe>컨테이너 프로브(probe)</h2><p><em>프로브</em> 는
컨테이너에서 <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>에 의해
주기적으로 수행되는 진단(diagnostic)이다.
진단을 수행하기 위해서,
kubelet은 컨테이너 안에서 코드를 실행하거나,
또는 네트워크 요청을 전송한다.</p><h3 id=probe-check-methods>체크 메커니즘</h3><p>프로브를 사용하여 컨테이너를 체크하는 방법에는 4가지가 있다.
각 프로브는 다음의 4가지 메커니즘 중 단 하나만을 정의해야 한다.</p><dl><dt><code>exec</code></dt><dd>컨테이너 내에서 지정된 명령어를 실행한다.
명령어가 상태 코드 0으로 종료되면 진단이 성공한 것으로 간주한다.</dd><dt><code>grpc</code></dt><dd><a href=https://grpc.io/>gRPC</a>를 사용하여
원격 프로시저 호출을 수행한다.
체크 대상이 <a href=https://grpc.io/grpc/core/md_doc_health-checking.html>gRPC 헬스 체크</a>를 구현해야 한다.
응답의 <code>status</code> 가 <code>SERVING</code> 이면
진단이 성공했다고 간주한다.
gRPC 프로브는 알파 기능이며
<code>GRPCContainerProbe</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
활성화해야 사용할 수 있다.</dd><dt><code>httpGet</code></dt><dd>지정한 포트 및 경로에서 컨테이너의 IP주소에 대한
HTTP <code>GET</code> 요청을 수행한다.
응답의 상태 코드가 200 이상 400 미만이면
진단이 성공한 것으로 간주한다.</dd><dt><code>tcpSocket</code></dt><dd>지정된 포트에서 컨테이너의 IP주소에 대해 TCP 검사를 수행한다.
포트가 활성화되어 있다면 진단이 성공한 것으로 간주한다.
원격 시스템(컨테이너)가 연결을 연 이후 즉시 닫는다면,
이 또한 진단이 성공한 것으로 간주한다.</dd></dl><h3 id=프로브-결과>프로브 결과</h3><p>각 probe는 다음 세 가지 결과 중 하나를 가진다.</p><dl><dt><code>Success</code></dt><dd>컨테이너가 진단을 통과함.</dd><dt><code>Failure</code></dt><dd>컨테이너가 진단에 실패함.</dd><dt><code>Unknown</code></dt><dd>진단 자체가 실패함(아무런 조치를 수행해서는 안 되며, kubelet이
추가 체크를 수행할 것이다)</dd></dl><h3 id=프로브-종류>프로브 종류</h3><p>kubelet은 실행 중인 컨테이너들에 대해서 선택적으로 세 가지 종류의 프로브를 수행하고
그에 반응할 수 있다.</p><dl><dt><code>livenessProbe</code></dt><dd>컨테이너가 동작 중인지 여부를 나타낸다. 만약
활성 프로브(liveness probe)에 실패한다면, kubelet은 컨테이너를 죽이고, 해당 컨테이너는
<a href=#restart-policy>재시작 정책</a>의 대상이 된다. 만약 컨테이너가
활성 프로브를 제공하지 않는 경우, 기본 상태는 <code>Success</code> 이다.</dd><dt><code>readinessProbe</code></dt><dd>컨테이너가 요청을 처리할 준비가 되었는지 여부를 나타낸다.
만약 준비성 프로브(readiness probe)가 실패한다면, 엔드포인트 컨트롤러는
파드에 연관된 모든 서비스들의 엔드포인트에서 파드의 IP주소를 제거한다. 준비성 프로브의
초기 지연 이전의 기본 상태는 <code>Failure</code> 이다. 만약 컨테이너가 준비성 프로브를
지원하지 않는다면, 기본 상태는 <code>Success</code> 이다.</dd><dt><code>startupProbe</code></dt><dd>컨테이너 내의 애플리케이션이 시작되었는지를 나타낸다.
스타트업 프로브(startup probe)가 주어진 경우, 성공할 때까지 다른 나머지 프로브는
활성화되지 않는다. 만약 스타트업 프로브가 실패하면, kubelet이 컨테이너를 죽이고,
컨테이너는 <a href=#restart-policy>재시작 정책</a>에 따라 처리된다. 컨테이너에 스타트업
프로브가 없는 경우, 기본 상태는 <code>Success</code> 이다.</dd></dl><p>활성, 준비성 및 스타트업 프로브를 설정하는 방법에 대한 추가적인 정보는,
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>활성, 준비성 및 스타트업 프로브 설정하기</a>를 참조하면 된다.</p><h4 id=언제-활성-프로브를-사용해야-하는가>언제 활성 프로브를 사용해야 하는가?</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.0 [stable]</code></div><p>만약 컨테이너 속 프로세스가 어떠한 이슈에 직면하거나 건강하지 못한
상태(unhealthy)가 되는 등 프로세스 자체의 문제로 중단될 수 있더라도, 활성 프로브가
반드시 필요한 것은 아니다. 그 경우에는 kubelet이 파드의 <code>restartPolicy</code>에
따라서 올바른 대처를 자동적으로 수행할 것이다.</p><p>프로브가 실패한 후 컨테이너가 종료되거나 재시작되길 원한다면, 활성 프로브를
지정하고, <code>restartPolicy</code>를 항상(Always) 또는 실패 시(OnFailure)로 지정한다.</p><h4 id=언제-준비성-프로브를-사용해야-하는가>언제 준비성 프로브를 사용해야 하는가?</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.0 [stable]</code></div><p>프로브가 성공한 경우에만 파드에 트래픽 전송을 시작하려고 한다면,
준비성 프로브를 지정하길 바란다. 이 경우에서는, 준비성 프로브가 활성 프로브와 유사해
보일 수도 있지만, 스팩에 준비성 프로브가 존재한다는 것은 파드가
트래픽을 받지 않는 상태에서 시작되고 프로브가 성공하기 시작한 이후에만
트래픽을 받는다는 뜻이다.</p><p>만약 컨테이너가 유지 관리를 위해서 자체 중단되게 하려면,
준비성 프로브를 지정하길 바란다.
준비성 프로브는 활성 프로브와는 다르게 준비성에 특정된 엔드포인트를 확인한다.</p><p>만약 애플리케이션이 백엔드 서비스에 엄격한 의존성이 있다면,
활성 프로브와 준비성 프로브 모두 활용할 수도 있다. 활성 프로브는 애플리케이션 스스로가 건강한 상태면
통과하지만, 준비성 프로브는 추가적으로 요구되는 각 백-엔드 서비스가 가용한지 확인한다. 이를 이용하여,
오류 메시지만 응답하는 파드로
트래픽이 가는 것을 막을 수 있다.</p><p>만약 컨테이너가 시동 시 대량 데이터의 로딩, 구성 파일, 또는
마이그레이션에 대한 작업을
수행해야 한다면, <a href=#%EC%96%B8%EC%A0%9C-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%ED%94%84%EB%A1%9C%EB%B8%8C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80>스타트업 프로브</a>를 사용하면 된다. 그러나, 만약
failed 애플리케이션과 시동 중에 아직 데이터를 처리하고 있는 애플리케이션을 구분하여 탐지하고
싶다면, 준비성 프로브를 사용하는 것이 더 적합할 것이다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드가 삭제될 때 요청들을 흘려 보내기(drain) 위해
준비성 프로브가 꼭 필요한 것은 아니다. 삭제 시에, 파드는
프로브의 존재 여부와 무관하게 자동으로 스스로를 준비되지 않은 상태(unready)로 변경한다.
파드는 파드 내의 모든 컨테이너들이 중지될 때까지 준비되지 않은 상태로
남아 있다.</div><h4 id=언제-스타트업-프로브를-사용해야-하는가>언제 스타트업 프로브를 사용해야 하는가?</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.20 [stable]</code></div><p>스타트업 프로브는 서비스를 시작하는 데 오랜 시간이 걸리는 컨테이너가 있는
파드에 유용하다. 긴 활성 간격을 설정하는 대신, 컨테이너가 시작될 때
프로브를 위한 별도의 구성을 설정하여, 활성 간격보다
긴 시간을 허용할 수 있다.</p><p>컨테이너가 보통 <code>initialDelaySeconds + failureThreshold × periodSeconds</code>
이후에 기동된다면, 스타트업 프로브가
활성화 프로브와 같은 엔드포인트를 확인하도록 지정해야 한다.
<code>periodSeconds</code>의 기본값은 10s 이다. 이 때 컨테이너가 활성화 프로브의
기본값 변경 없이 기동되도록 하려면, <code>failureThreshold</code> 를 충분히 높게 설정해주어야
한다. 그래야 데드락(deadlocks)을 방지하는데 도움이 된다.</p><h2 id=pod-termination>파드의 종료</h2><p>파드는 클러스터의 노드에서 실행되는 프로세스를 나타내므로, 해당 프로세스가
더 이상 필요하지 않을 때 정상적으로 종료되도록 하는 것이 중요하다(<code>KILL</code>
시그널로 갑자기 중지되고 정리할 기회가 없는 것 보다).</p><p>디자인 목표는 삭제를 요청하고 프로세스가 종료되는 시기를 알 수
있을 뿐만 아니라, 삭제가 결국 완료되도록 하는 것이다.
사용자가 파드의 삭제를 요청하면, 클러스터는 파드가 강제로 종료되기 전에
의도한 유예 기간을 기록하고 추적한다. 강제 종료 추적이
적용되면, <a class=glossary-tooltip title='클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>은 정상
종료를 시도한다.</p><p>일반적으로, 컨테이너 런타임은 각 컨테이너의 기본 프로세스에 TERM 신호를
전송한다. 많은 컨테이너 런타임은 컨테이너 이미지에 정의된 <code>STOPSIGNAL</code> 값을 존중하며
TERM 대신 이 값을 보낸다.
일단 유예 기간이 만료되면, KILL 시그널이 나머지 프로세스로
전송되고, 그런 다음 파드는
<a class=glossary-tooltip title='쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 서버'>API 서버</a>로부터 삭제된다. 프로세스가
종료될 때까지 기다리는 동안 kubelet 또는 컨테이너 런타임의 관리 서비스가 다시 시작되면, 클러스터는
전체 원래 유예 기간을 포함하여 처음부터 다시 시도한다.</p><p>플로우의 예는 다음과 같다.</p><ol><li>이 <code>kubectl</code> 도구를 사용하여 기본 유예 기간(30초)으로 특정 파드를 수동으로
삭제한다.</li><li>API 서버의 파드는 유예 기간과 함께 파드가 "dead"로 간주되는
시간으로 업데이트된다.
<code>kubectl describe</code> 를 사용하여 삭제하려는 파드를 확인하면, 해당 파드가 "Terminating"으로
표시된다.
파드가 실행 중인 노드에서, kubelet이 파드가 종료된 것(terminating)으로 표시되었음을
확인하는 즉시(정상적인 종료 기간이 설정됨), kubelet은 로컬 파드의 종료
프로세스를 시작한다.<ol><li>파드의 컨테이너 중 하나가 <code>preStop</code>
<a href=/ko/docs/concepts/containers/container-lifecycle-hooks>훅</a>을 정의한 경우, kubelet은
컨테이너 내부에서 해당 훅을 실행한다. 유예 기간이 만료된 후 <code>preStop</code> 훅이
계속 실행되면, kubelet은 2초의 작은 일회성 유예 기간 연장을
요청한다.<div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>preStop</code> 훅을 완료하는 데 기본 유예 기간이 허용하는 것보다 오랜 시간이 필요한 경우,
이에 맞게 <code>terminationGracePeriodSeconds</code> 를 수정해야 한다.</div></li><li>kubelet은 컨테이너 런타임을 트리거하여 각 컨테이너 내부의 프로세스 1에 TERM 시그널을
보낸다.<div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드의 컨테이너는 서로 다른 시간에 임의의 순서로 TERM 시그널을
수신한다. 종료 순서가 중요한 경우, <code>preStop</code> 훅을 사용하여 동기화하는 것이 좋다.</div></li></ol></li><li>kubelet이 정상 종료를 시작하는 동시에, 컨트롤 플레인은
구성된 <a class=glossary-tooltip title='사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=셀렉터>셀렉터</a>가 있는
<a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를 나타내는
엔드포인트(Endpoint)(그리고, 활성화된 경우, 엔드포인트슬라이스(EndpointSlice)) 오브젝트에서 종료된 파드를 제거한다.
<a class=glossary-tooltip title='레플리카셋은 지정된 수의 파드 레플리카가 동시에 실행이 되도록 보장한다' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=레플리카셋(ReplicaSet)>레플리카셋(ReplicaSet)</a>과 기타 워크로드 리소스는
더 이상 종료된 파드를 유효한 서비스 내 복제본으로 취급하지 않는다. 로드 밸런서(서비스 프록시와 같은)가
종료 유예 기간이 <em>시작되는</em> 즉시 엔드포인트 목록에서 파드를 제거하므로 느리게 종료되는
파드는 트래픽을 계속 제공할 수 없다.</li><li>유예 기간이 만료되면, kubelet은 강제 종료를 트리거한다. 컨테이너 런타임은
<code>SIGKILL</code> 을 파드의 모든 컨테이너에서 여전히 실행 중인 모든 프로세스로 전송한다.
kubelet은 해당 컨테이너 런타임이 하나를 사용하는 경우 숨겨진 <code>pause</code> 컨테이너도 정리한다.</li><li>kubelet은 유예 기간을 0(즉시 삭제)으로 설정하여, API 서버에서 파드 오브젝트의
강제 삭제를 트리거한다.</li><li>API 서버가 파드의 API 오브젝트를 삭제하면, 더 이상 클라이언트에서 볼 수 없다.</li></ol><h3 id=pod-termination-forced>강제 파드 종료</h3><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 강제 삭제는 일부 워크로드와 해당 파드에 대해서 잠재적으로 중단될 수 있다.</div><p>기본적으로, 모든 삭제는 30초 이내에는 정상적으로 수행된다. <code>kubectl delete</code> 명령은
기본값을 재정의하고 사용자의 고유한 값을 지정할 수 있는 <code>--grace-period=&lt;seconds></code> 옵션을
지원한다.</p><p>유예 기간을 <code>0</code> 로 강제로 즉시 설정하면 API 서버에서 파드가
삭제된다. 파드가 노드에서 계속 실행 중인 경우, 강제 삭제는 kubelet을 트리거하여
즉시 정리를 시작한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 강제 삭제를 수행하려면 <code>--grace-period=0</code> 와 함께 추가 플래그 <code>--force</code> 를 지정해야 한다.</div><p>강제 삭제가 수행되면, API 서버는 실행 중인 노드에서
파드가 종료되었다는 kubelet의 확인을 기다리지 않는다.
API에서 즉시 파드를 제거하므로 동일한 이름으로 새로운 파드를 생성할 수
있다. 노드에서 즉시 종료되도록 설정된 파드는 강제 종료되기 전에
작은 유예 기간이 계속 제공된다.</p><p>스테이트풀셋(StatefulSet)의 일부인 파드를 강제 삭제해야 하는 경우,
<a href=/ko/docs/tasks/run-application/force-delete-stateful-set-pod/>스테이트풀셋에서 파드를 삭제하기</a>에 대한
태스크 문서를 참고한다.</p><h3 id=pod-garbage-collection>종료된 파드의 가비지 콜렉션</h3><p>실패한 파드의 경우, API 오브젝트는 사람이나
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 프로세스가
명시적으로 파드를 제거할 때까지 클러스터의 API에 남아 있다.</p><p>컨트롤 플레인은 파드 수가 구성된 임계값(kube-controller-manager에서
<code>terminated-pod-gc-threshold</code> 에 의해 결정됨)을 초과할 때 종료된 파드(<code>Succeeded</code> 또는
<code>Failed</code> 단계 포함)를 정리한다.
이렇게 하면 시간이 지남에 따라 파드가 생성되고 종료될 때 리소스 유출이 방지된다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><p><a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>컨테이너 라이프사이클 이벤트에 핸들러를 연결</a>하는
핸즈온 연습을 해보자.</p></li><li><p><a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>활성, 준비성 및 스타트업 프로브 설정</a>하는
핸즈온 연습을 해보자.</p></li><li><p><a href=/ko/docs/concepts/containers/container-lifecycle-hooks/>컨테이너 라이프사이클 훅</a>에 대해 자세히 알아보자.</p></li><li><p>API의 파드와 컨테이너 상태에 대한 자세한 내용은
파드의 <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodStatus><code>.status</code></a>에 대해 다루는
API 레퍼런스 문서를 참고한다.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>1.2 - 초기화 컨테이너</h1><p>이 페이지는 초기화 컨테이너에 대한 개요를 제공한다. 초기화 컨테이너는
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>의 앱 컨테이너들이 실행되기 전에 실행되는 특수한 컨테이너이다. 초기화 컨테이너는 앱 이미지에는 없는
유틸리티 또는 설정 스크립트 등을 포함할 수 있다.</p><p>초기화 컨테이너는 <code>containers</code> 배열(앱 컨테이너를 기술하는)과 나란히
파드 스펙에 명시할 수 있다.</p><h2 id=초기화-컨테이너-이해하기>초기화 컨테이너 이해하기</h2><p><a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>는 앱들을 실행하는 다수의 컨테이너를
포함할 수 있고, 또한 앱 컨테이너 실행 전에 동작되는 하나 이상의
초기화 컨테이너도 포함할 수 있다.</p><p>다음의 경우를 제외하면, 초기화 컨테이너는 일반적인 컨테이너와 매우 유사하다.</p><ul><li>초기화 컨테이너는 항상 완료를 목표로 실행된다.</li><li>각 초기화 컨테이너는 다음 초기화 컨테이너가 시작되기 전에 성공적으로 완료되어야 한다.</li></ul><p>만약 파드의 초기화 컨테이너가 실패하면, kubelet은 초기화 컨테이너가 성공할 때까지 반복적으로 재시작한다.
그러나, 만약 파드의 <code>restartPolicy</code> 를 절대 하지 않음(Never)으로 설정하고, 해당 파드를 시작하는 동안 초기화 컨테이너가 실패하면, 쿠버네티스는 전체 파드를 실패한 것으로 처리한다.</p><p>컨테이너를 초기화 컨테이너로 지정하기 위해서는,
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>파드 스펙</a>에 <code>initContainers</code> 필드를
<code>container</code> 항목(앱 <code>container</code> 필드 및 내용과 유사한)들의 배열로서 추가한다.
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>컨테이너</a>에 대한 더 상세한 사항은
API 레퍼런스를 참고한다.</p><p>초기화 컨테이너의 상태는 컨테이너
상태의 배열(<code>.status.containerStatuses</code> 필드와 유사)로 <code>.status.initContainerStatuses</code>
필드에 반환된다.</p><h3 id=일반적인-컨테이너와의-차이점>일반적인 컨테이너와의 차이점</h3><p>초기화 컨테이너는 앱 컨테이너의 리소스 상한(limit), 볼륨, 보안 세팅을 포함한
모든 필드와 기능을 지원한다.
그러나, 초기화 컨테이너를 위한 리소스 요청량과 상한은
<a href=#%EB%A6%AC%EC%86%8C%EC%8A%A4>리소스</a>에 문서화된 것처럼 다르게 처리된다.</p><p>또한, 초기화 컨테이너는 <code>lifecycle</code>, <code>livenessProbe</code>, <code>readinessProbe</code> 또는 <code>startupProbe</code> 를 지원하지 않는다.
왜냐하면 초기화 컨테이너는 파드가 준비 상태가 되기 전에 완료를 목표로 실행되어야 하기 때문이다.</p><p>만약 다수의 초기화 컨테이너가 파드에 지정되어 있다면, kubelet은 해당 초기화 컨테이너들을
한 번에 하나씩 실행한다. 각 초기화 컨테이너는 다음 컨테이너를 실행하기 전에 꼭 성공해야 한다.
모든 초기화 컨테이너들이 실행 완료되었을 때, kubelet은 파드의 애플리케이션 컨테이너들을
초기화하고 평소와 같이 실행한다.</p><h2 id=초기화-컨테이너-사용하기>초기화 컨테이너 사용하기</h2><p>초기화 컨테이너는 앱 컨테이너와는 별도의 이미지를 가지고 있기 때문에, 시동(start-up)에
관련된 코드로서 몇 가지 이점을 가진다.</p><ul><li>앱 이미지에는 없는 셋업을 위한 유틸리티 또는 맞춤 코드를 포함할 수 있다.
예를 들어, 셋업 중에 단지 <code>sed</code>, <code>awk</code>, <code>python</code>, 또는 <code>dig</code>와 같은 도구를 사용하기 위해서
다른 이미지로부터(<code>FROM</code>) 새로운 이미지를 만들 필요가 없다.</li><li>애플리케이션 이미지 빌더와 디플로이어 역할은 독립적으로 동작될 수 있어서
공동의 단일 앱 이미지 형태로 빌드될 필요가 없다.</li><li>초기화 컨테이너는 앱 컨테이너와 다른 파일 시스템 뷰를 가지도록 리눅스 네임스페이스를 사용한다.
결과적으로, 초기화 컨테이너에는 앱 컨테이너가 가질 수 없는
<a class=glossary-tooltip title='비밀번호, OAuth 토큰 및 ssh 키와 같은 민감한 정보를 저장한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/secret/ target=_blank aria-label=시크릿>시크릿</a>에 접근 권한이 주어질 수 있다.</li><li>앱 컨테이너들은 병렬로 실행되는 반면, 초기화 컨테이너들은 어떠한 앱
컨테이너라도 시작되기 전에 실행 완료되어야 하므로, 초기화 컨테이너는 사전 조건들이
충족될 때까지 앱 컨테이너가 시동되는 것을 막거나 지연시키는 간편한 방법을 제공한다.</li><li>초기화 컨테이너는 앱 컨테이너 이미지의 보안성을 떨어뜨릴 수도 있는 유틸리티 혹은 커스텀 코드를 안전하게
실행할 수 있다. 불필요한 툴들을 분리한 채로 유지함으로써 앱 컨테이너 이미지의 공격에 대한
노출을 제한할 수 있다.</li></ul><h3 id=예제>예제</h3><p>초기화 컨테이너를 사용하는 방법에 대한 몇 가지 아이디어는 다음과 같다.</p><ul><li><p>다음과 같은 셸 커맨드로,
<a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>가 생성될 때까지 기다리기.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>{</span>1..100<span style=color:#666>}</span>; <span style=color:#a2f;font-weight:700>do</span> sleep 1; <span style=color:#a2f;font-weight:700>if</span> dig myservice; <span style=color:#a2f;font-weight:700>then</span> <span style=color:#a2f>exit</span> 0; <span style=color:#a2f;font-weight:700>fi</span>; <span style=color:#a2f;font-weight:700>done</span>; <span style=color:#a2f>exit</span> <span style=color:#666>1</span>
</span></span></code></pre></div></li><li><p>다음과 같은 커맨드로, 다운워드 API(Downward API)를 통한 원격 서버에 해당 파드를 등록하기.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X POST http://<span style=color:#b8860b>$MANAGEMENT_SERVICE_HOST</span>:<span style=color:#b8860b>$MANAGEMENT_SERVICE_PORT</span>/register -d <span style=color:#b44>&#39;instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)&#39;</span>
</span></span></code></pre></div></li><li><p>다음과 같은 커맨드로 앱 컨테이너가 시작되기 전에 일정 시간 기다리기.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sleep <span style=color:#666>60</span>
</span></span></code></pre></div></li><li><p>Git 저장소를 <a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a> 안에 클론하기.</p></li><li><p>설정 파일에 값을 지정하고
메인 앱 컨테이너를 위한 설정 파일을 동적으로 생성하기 위한 템플릿 도구를 실행하기.
예를 들어, 설정에 <code>POD_IP</code> 값을 지정하고
메인 앱 설정 파일을 Jinja를 통해서 생성.</p></li></ul><h3 id=사용-중인-초기화-컨테이너>사용 중인 초기화 컨테이너</h3><p>쿠버네티스 1.5에 대한 다음의 yaml 파일은 두 개의 초기화 컨테이너를 포함한 간단한 파드에 대한 개요를 보여준다.
첫 번째는 <code>myservice</code> 를 기다리고 두 번째는 <code>mydb</code> 를 기다린다. 두 컨테이너들이
완료되면, 파드가 시작될 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo The app is running! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>다음 커맨드들을 이용하여 파드를 시작하거나 디버깅할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f myapp.yaml
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><pre tabindex=0><code>pod/myapp-pod created
</code></pre><p>그리고 파드의 상태를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><pre tabindex=0><code>NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre><p>혹은 좀 더 자세히 살펴본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe -f myapp.yaml
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><pre tabindex=0><code>Name:          myapp-pod
Namespace:     default
[...]
Labels:        app.kubernetes.io/name=MyApp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634
</code></pre><p>파드의 초기화 컨테이너의 상태를 보기 위해, 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># Inspect the first init container</span>
</span></span><span style=display:flex><span>kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># Inspect the second init container</span>
</span></span></code></pre></div><p><code>mydb</code> 및 <code>myservice</code> 서비스를 시작하고 나면, 초기화 컨테이너가 완료되고
<code>myapp-pod</code> 가 생성된 것을 볼 수 있다.</p><p>여기에 이 서비스를 보이기 위해 사용할 수 있는 구성이 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>mydb</code> 와 <code>myservice</code> 서비스 생성하기.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f services.yaml
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><pre tabindex=0><code>service/myservice created
service/mydb created
</code></pre><p>초기화 컨테이너들이 완료되는 것과 <code>myapp-pod</code> 파드가 Running 상태로
변경되는 것을 볼 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><pre tabindex=0><code>NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          9m
</code></pre><p>이 간단한 예제는 사용자만의 초기화 컨테이너를 생성하는데
영감을 줄 것이다. <a href=#%EB%8B%A4%EC%9D%8C-%EB%82%B4%EC%9A%A9>다음 순서</a>에는 더 자세한 예제의 링크가 있다.</p><h2 id=자세한-동작>자세한 동작</h2><p>파드 시작 시에 kubelet은 네트워크와 스토리지가 준비될 때까지
초기화 컨테이너의 실행을 지연시킨다. 그런 다음 kubelet은 파드 사양에
나와있는 순서대로 파드의 초기화 컨테이너를 실행한다.</p><p>각 초기화 컨테이너는 다음 컨테이너가 시작되기 전에 성공적으로
종료되어야 한다. 만약 런타임 문제나 실패 상태로 종료되는 문제로인하여 초기화 컨테이너의 시작이
실패된다면, 초기화 컨테이너는 파드의 <code>restartPolicy</code> 에 따라서 재시도 된다. 다만,
파드의 <code>restartPolicy</code> 가 항상(Always)으로 설정된 경우, 해당 초기화 컨테이너는
<code>restartPolicy</code> 를 실패 시(OnFailure)로 사용한다.</p><p>파드는 모든 초기화 컨테이너가 성공되기 전까지 <code>Ready</code> 될 수 없다. 초기화 컨테이너의 포트는
서비스 하에 합쳐지지 않는다. 초기화 중인 파드는 <code>Pending</code> 상태이지만
<code>Initialized</code> 가 거짓이 되는 조건을 가져야 한다.</p><p>만약 파드가 <a href=#%ED%8C%8C%EB%93%9C-%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%9D%B4%EC%9C%A0>재시작</a>되었다면, 모든 초기화 컨테이너는
반드시 다시 실행된다.</p><p>초기화 컨테이너 스펙 변경은 컨테이너 이미지 필드에서만 한정적으로 가능하다.
초기화 컨테이너 이미지 필드를 변경하는 것은 파드를 재시작하는 것과 같다.</p><p>초기화 컨테이너는 재시작되거나, 재시도, 또는 재실행 될 수 있기 때문에, 초기화 컨테이너
코드는 멱등성(idempotent)을 유지해야 한다. 특히, <code>EmptyDirs</code> 에 있는 파일에 쓰기를 수행하는 코드는
출력 파일이 이미 존재할 가능성에 대비해야 한다.</p><p>초기화 컨테이너는 앱 컨테이너의 필드를 모두 가지고 있다. 그러나, 쿠버네티스는
<code>readinessProbe</code> 가 사용되는 것을 금지한다. 초기화 컨테이너가 완료 상태와 준비성을
구분해서 정의할 수 없기 때문이다. 이것은 유효성 검사 중에 시행된다.</p><p>초기화 컨테이너들이 실패를 영원히 지속하는 상황을 방지하기 위해서
파드의 <code>activeDeadlineSeconds</code>를 사용한다.
Active deadline은 초기화 컨테이너를 포함한다.
그러나 팀에서 애플리케이션을 잡(job)으로 배포한 경우에만 <code>activeDeadlineSeconds</code>를 사용하길 추천한다. 왜냐하면, <code>activeDeadlineSeconds</code>는 초기화 컨테이너가 완료된 이후에도 영향을 주기 때문이다.
이미 정상적으로 동작하고 있는 파드도 <code>activeDeadlineSeconds</code>를 설정한 경우 종료(killed)될 수 있다.</p><p>파드 내의 각 앱과 초기화 컨테이너의 이름은 유일해야 한다. 어떤
컨테이너가 다른 컨테이너와 같은 이름을 공유하는 경우 유효성 오류가 발생한다.</p><h3 id=리소스>리소스</h3><p>초기화 컨테이너에게 명령과 실행이 주어진 경우, 리소스 사용에 대한
다음의 규칙이 적용된다.</p><ul><li>모든 컨테이너에 정의된 특정 리소스 요청량 또는 상한 중
가장 높은 것은 <em>유효 초기화 요청량/상한</em> 이다. 리소스 제한이 지정되지 않은 리소스는
이 <em>유효 초기화 요청량/상한</em>을 가장 높은 요청량/상한으로 간주한다.</li><li>리소스를 위한 파드의 <em>유효한 초기화 요청량/상한</em> 은 다음 보다 더 높다.<ul><li>모든 앱 컨테이너의 리소스에 대한 요청량/상한의 합계</li><li>리소스에 대한 유효한 초기화 요청량/상한</li></ul></li><li>스케줄링은 유효한 요청/상한에 따라 이루어진다. 즉,
초기화 컨테이너는 파드의 삶에서는 사용되지 않는 초기화를 위한 리소스를
예약할 수 있다.</li><li>파드의 <em>유효한 QoS 계층</em> 에서 QoS(서비스의 품질) 계층은 초기화 컨테이너들과
앱 컨테이너들의 QoS 계층과 같다.</li></ul><p>쿼터 및 상한은 유효한 파드의 요청량 및 상한에 따라
적용된다.</p><p>파드 레벨 cgroup은 유효한 파드 요청량 및 상한을 기반으로 한다.
이는 스케줄러와 같다.</p><h3 id=파드-재시작-이유>파드 재시작 이유</h3><p>파드는 다음과 같은 사유로, 초기화 컨테이너들의 재-실행을 일으키는, 재시작을 수행할 수
있다.</p><ul><li>파드 인프라스트럭처 컨테이너가 재시작된 상황. 이는 일반적인 상황이 아니며 노드에
대해서 root 접근 권한을 가진 누군가에 의해서 수행됐을 것이다.</li><li>초기화 컨테이너의 완료 기록이 가비지 수집 때문에 유실된 상태에서,
<code>restartPolicy</code>가 Always로 설정된 파드의 모든 컨테이너가 종료되어
모든 컨테이너를 재시작해야 하는 상황</li></ul><p>초기화 컨테이너 이미지가 변경되거나 초기화 컨테이너의 완료 기록이 가비지 수집
때문에 유실된 상태이면 파드는 재시작되지 않는다. 이는 쿠버네티스 버전 1.20 이상에
적용된다. 이전 버전의 쿠버네티스를 사용하는 경우 해당 쿠버네티스 버전의 문서를
참고한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/configure-pod-container/configure-pod-initialization/#%EC%B4%88%EA%B8%B0%ED%99%94-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%A5%BC-%EA%B0%96%EB%8A%94-%ED%8C%8C%EB%93%9C-%EC%83%9D%EC%84%B1>초기화 컨테이너를 가진 파드 생성하기</a></li><li><a href=/ko/docs/tasks/debug/debug-application/debug-init-containers/>초기화 컨테이너 디버깅</a> 알아보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4aaf43c715cd764bc8ed4436f3537e68>1.3 - 중단(disruption)</h1><p>이 가이드는 고가용성 애플리케이션을 구성하려는 소유자와
파드에서 발생하는 장애 유형을 이해하기
원하는 애플리케이션 소유자를 위한 것이다.</p><p>또한 클러스터의 업그레이드와 오토스케일링과 같은
클러스터의 자동화 작업을 하려는 관리자를 위한 것이다.</p><h2 id=자발적-중단과-비자발적-중단>자발적 중단과 비자발적 중단</h2><p>파드는 누군가(사람 또는 컨트롤러)가 파괴하거나
불가피한 하드웨어 오류 또는 시스템 소프트웨어 오류가 아니면 사라지지 않는다.</p><p>우리는 이런 불가피한 상황을 애플리케이션의 <em>비자발적 중단</em> 으로 부른다.
예시:</p><ul><li>노드를 지원하는 물리 머신의 하드웨어 오류</li><li>클러스터 관리자의 실수로 VM(인스턴스) 삭제</li><li>클라우드 공급자 또는 하이퍼바이저의 오류로 인한 VM 장애</li><li>커널 패닉</li><li>클러스터 네트워크 파티션의 발생으로 클러스터에서 노드가 사라짐</li><li>노드의 <a href=/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/>리소스 부족</a>으로 파드가 축출됨</li></ul><p>리소스 부족을 제외한 나머지 조건은 대부분의 사용자가 익숙할 것이다.
왜냐하면
그 조건은 쿠버네티스에 국한되지 않기 때문이다.</p><p>우리는 다른 상황을 <em>자발적인 중단</em> 으로 부른다.
여기에는 애플리케이션 소유자의 작업과 클러스터 관리자의 작업이 모두 포함된다.
다음은 대표적인 애플리케이션 소유자의 작업이다.</p><ul><li>디플로이먼트 제거 또는 다른 파드를 관리하는 컨트롤러의 제거</li><li>재시작을 유발하는 디플로이먼트의 파드 템플릿 업데이트</li><li>파드를 직접 삭제(예: 우연히)</li></ul><p>클러스터 관리자의 작업은 다음을 포함한다.</p><ul><li>복구 또는 업그레이드를 위한 <a href=/docs/tasks/administer-cluster/safely-drain-node/>노드 드레이닝</a>.</li><li>클러스터의 스케일 축소를 위한
노드 드레이닝(<a href=https://github.com/kubernetes/autoscaler/#readme>클러스터 오토스케일링</a>에 대해 알아보기
).</li><li>노드에 다른 무언가를 추가하기 위해 파드를 제거.</li></ul><p>위 작업은 클러스터 관리자가 직접 수행하거나 자동화를 통해 수행하며,
클러스터 호스팅 공급자에 의해서도 수행된다.</p><p>클러스터에 자발적인 중단을 일으킬 수 있는 어떤 원인이 있는지
클러스터 관리자에게 문의하거나 클라우드 공급자에게 문의하고, 배포 문서를 참조해서 확인해야 한다.
만약 자발적인 중단을 일으킬 수 있는 원인이 없다면 Pod Disruption Budget의 생성을 넘길 수 있다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 모든 자발적인 중단이 Pod Disruption Budget에 연관되는 것은 아니다.
예를 들어 디플로이먼트 또는 파드의 삭제는 Pod Disruption Budget을 무시한다.</div><h2 id=중단-다루기>중단 다루기</h2><p>비자발적인 중단으로 인한 영향을 경감하기 위한 몇 가지 방법은 다음과 같다.</p><ul><li>파드가 필요로 하는 <a href=/ko/docs/tasks/configure-pod-container/assign-memory-resource/>리소스를 요청</a>하는지 확인한다.</li><li>고가용성이 필요한 경우 애플리케이션을 복제한다.
(복제된 <a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>스테이트리스</a> 및
<a href=/docs/tasks/run-application/run-replicated-stateful-application/>스테이트풀</a> 애플리케이션에 대해 알아보기.)</li><li>복제된 애플리케이션의 구동 시 훨씬 더 높은 가용성을 위해 랙 전체
(<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%ED%8C%8C%EB%93%9C%EA%B0%84-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0%EC%99%80-%EC%95%88%ED%8B%B0-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0>안티-어피니티</a> 이용)
또는 영역 간
(<a href=/ko/docs/setup/best-practices/multiple-zones/>다중 영역 클러스터</a>를 이용한다면)에
애플리케이션을 분산해야 한다.</li></ul><p>자발적 중단의 빈도는 다양하다. 기본적인 쿠버네티스 클러스터에서는 자동화된 자발적 중단은 발생하지 않는다(사용자가 지시한 자발적 중단만 발생한다).
그러나 클러스터 관리자 또는 호스팅 공급자가 자발적 중단이 발생할 수 있는 일부 부가 서비스를 운영할 수 있다.
예를 들어 노드 소프트웨어의 업데이트를 출시하는 경우 자발적 중단이 발생할 수 있다.
또한 클러스터(노드) 오토스케일링의 일부 구현에서는
단편화를 제거하고 노드의 효율을 높이는 과정에서 자발적 중단을 야기할 수 있다.
클러스터 관리자 또는 호스팅 공급자는
예측 가능한 자발적 중단 수준에 대해 문서화해야 한다.
파드 스펙 안에 <a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>프라이어리티클래스 사용하기</a>와 같은 특정 환경설정 옵션
또한 자발적(+ 비자발적) 중단을 유발할 수 있다.</p><h2 id=파드-disruption-budgets>파드 disruption budgets</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [stable]</code></div><p>쿠버네티스는 자발적인 중단이 자주 발생하는 경우에도 고 가용성 애플리케이션을
실행하는 데 도움이 되는 기능을 제공한다.</p><p>애플리케이션 소유자로써, 사용자는 각 애플리케이션에 대해 PodDisruptionBudget(PDB)을 만들 수 있다.
PDB는 자발적 중단으로
일시에 중지되는 복제된 애플리케이션 파드의 수를 제한한다.
예를 들어, 정족수 기반의 애플리케이션이
실행 중인 레플리카의 수가 정족수 이하로 떨어지지 않도록 한다.
웹 프런트 엔드는 부하를 처리하는 레플리카의 수가
일정 비율 이하로 떨어지지 않도록 보장할 수 있다.</p><p>클러스터 관리자와 호스팅 공급자는 직접적으로 파드나 디플로이먼트를 제거하는 대신
<a href=/docs/tasks/administer-cluster/safely-drain-node/#eviction-api>Eviction API</a>로
불리는 PodDisruptionBudget을 준수하는 도구를 이용해야 한다.</p><p>예를 들어, <code>kubectl drain</code> 하위 명령을 사용하면 노드를 서비스 중단으로 표시할 수
있다. <code>kubectl drain</code> 을 실행하면, 도구는 사용자가 서비스를 중단하는 노드의
모든 파드를 축출하려고 한다. <code>kubectl</code> 이 사용자를 대신하여 수행하는
축출 요청은 일시적으로 거부될 수 있으며,
도구는 대상 노드의 모든 파드가 종료되거나
설정 가능한 타임아웃이 도래할 때까지 주기적으로 모든 실패된 요청을 다시 시도한다.</p><p>PDB는 애플리케이션이 필요로 하는 레플리카의 수에 상대적으로, 용인할 수 있는 레플리카의 수를 지정한다.
예를 들어 <code>.spec.replicas: 5</code> 의 값을 갖는 디플로이먼트는 어느 시점에든 5개의 파드를 가져야 한다.
만약 해당 디플로이먼트의 PDB가 특정 시점에 파드를 4개 허용한다면,
Eviction API는 한 번에 1개(2개의 파드가 아닌)의 파드의 자발적인 중단을 허용한다.</p><p>파드 그룹은 레이블 셀렉터를 사용해서 지정한 애플리케이션으로 구성되며
애플리케이션 컨트롤러(디플로이먼트, 스테이트풀셋 등)를 사용한 것과 같다.</p><p>파드의 "의도"하는 수량은 해당 파드를 관리하는 워크로드 리소스의 <code>.spec.replicas</code> 를
기반으로 계산한다. 컨트롤 플레인은 파드의 <code>.metadata.ownerReferences</code> 를 검사하여
소유하는 워크로드 리소스를 발견한다.</p><p><a href=#%EC%9E%90%EB%B0%9C%EC%A0%81-%EC%A4%91%EB%8B%A8%EA%B3%BC-%EB%B9%84%EC%9E%90%EB%B0%9C%EC%A0%81-%EC%A4%91%EB%8B%A8>비자발적 중단</a>은 PDB로는 막을 수 없지만,
버짓은 차감된다.</p><p>애플리케이션의 롤링 업그레이드로 파드가 삭제되거나 사용할 수 없는 경우 중단 버짓에 영향을 준다.
그러나 워크로드 리소스(디플로이먼트, 스테이트풀셋과 같은)는
롤링 업데이트 시 PDB의 제한을 받지 않는다. 대신, 애플리케이션 업데이트 중
실패 처리는 특정 워크로드 리소스에 대한 명세에서 구성된다.</p><p>Eviction API를 사용하여 파드를 축출하면,
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>의
<code>terminationGracePeriodSeconds</code> 설정을 준수하여 정상적으로 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%A2%85%EB%A3%8C>종료됨</a> 상태가 된다.</p><h2 id=pdb-example>PodDisruptionBudget 예시</h2><p><code>node-1</code> 부터 <code>node-3</code> 까지 3개의 노드가 있는 클러스터가 있다고 하자.
클러스터에는 여러 애플리케이션을 실행하고 있다.
여러 애플리케이션 중 하나는 <code>pod-a</code>, <code>pod-b</code>, <code>pod-c</code> 로 부르는 3개의 레플리카가 있다. 여기에 <code>pod-x</code> 라고 부르는 PDB와 무관한 파드가 보인다.
초기에 파드는 다음과 같이 배치된다.</p><table><thead><tr><th style=text-align:center>node-1</th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>pod-a <em>available</em></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center>pod-x <em>available</em></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>전체 3개 파드는 디플로이먼트의 일부분으로
전체적으로 항상 3개의 파드 중 최소 2개의 파드를 사용할 수 있도록 하는 PDB를 가지고 있다.</p><p>예를 들어, 클러스터 관리자가 커널 버그를 수정하기위해 새 커널 버전으로 재부팅하려는 경우를 가정해보자.
클러스터 관리자는 첫째로 <code>node-1</code> 을 <code>kubectl drain</code> 명령어를 사용해서 비우려 한다.
<code>kubectl</code> 은 <code>pod-a</code> 과 <code>pod-x</code> 를 축출하려고 한다. 이는 즉시 성공한다.
두 파드는 동시에 <code>terminating</code> 상태로 진입한다.
이렇게 하면 클러스터는 다음의 상태가 된다.</p><table><thead><tr><th style=text-align:center>node-1 <em>draining</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>pod-a <em>terminating</em></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center>pod-x <em>terminating</em></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>디플로이먼트는 한 개의 파드가 중지되는 것을 알게되고, <code>pod-d</code> 라는 대체 파드를 생성한다.
<code>node-1</code> 은 차단되어 있어 다른 노드에 위치한다.
무언가가 <code>pod-x</code> 의 대체 파드로 <code>pod-y</code> 도 생성했다.</p><p>(참고: 스테이트풀셋은 <code>pod-0</code> 처럼 불릴, <code>pod-a</code> 를
교체하기 전에 완전히 중지해야 하며, <code>pod-0</code> 로 불리지만, 다른 UID로 생성된다.
그렇지 않으면 이 예시는 스테이트풀셋에도 적용된다.)</p><p>이제 클러스터는 다음과 같은 상태이다.</p><table><thead><tr><th style=text-align:center>node-1 <em>draining</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>pod-a <em>terminating</em></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center>pod-x <em>terminating</em></td><td style=text-align:center>pod-d <em>starting</em></td><td style=text-align:center>pod-y</td></tr></tbody></table><p>어느 순간 파드가 종료되고, 클러스터는 다음과 같은 상태가 된다.</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>pod-d <em>starting</em></td><td style=text-align:center>pod-y</td></tr></tbody></table><p>이 시점에서 만약 성급한 클러스터 관리자가 <code>node-2</code> 또는 <code>node-3</code> 을
비우려고 하는 경우 디플로이먼트에 available 상태의 파드가 2개 뿐이고,
PDB에 필요한 최소 파드는 2개이기 때문에 drain 명령이 차단된다. 약간의 시간이 지나면 <code>pod-d</code> 가 available 상태가 된다.</p><p>이제 클러스터는 다음과 같은 상태이다.</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>pod-d <em>available</em></td><td style=text-align:center>pod-y</td></tr></tbody></table><p>이제 클러스터 관리자는 <code>node-2</code> 를 비우려고 한다.
drain 커멘드는 <code>pod-b</code> 에서 <code>pod-d</code> 와 같이 어떤 순서대로 두 파드를 축출하려 할 것이다.
drain 커멘드는 <code>pod-b</code> 를 축출하는데 성공했다.
그러나 drain 커멘드가 <code>pod-d</code> 를 축출하려 하는 경우
디플로이먼트에 available 상태의 파드는 1개로 축출이 거부된다.</p><p>디플로이먼트는<code>pod-b</code> 를 대체할 <code>pod-e</code> 라는 파드를 생성한다.
클러스터에 <code>pod-e</code> 를 스케줄하기 위한 충분한 리소스가 없기 때문에
드레이닝 명령어는 차단된다.
클러스터는 다음 상태로 끝나게 된다.</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th><th style=text-align:center><em>no node</em></th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>pod-b <em>terminating</em></td><td style=text-align:center>pod-c <em>available</em></td><td style=text-align:center>pod-e <em>pending</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>pod-d <em>available</em></td><td style=text-align:center>pod-y</td><td style=text-align:center></td></tr></tbody></table><p>이 시점에서 클러스터 관리자는
클러스터에 노드를 추가해서 업그레이드를 진행해야 한다.</p><p>쿠버네티스에 중단이 발생할 수 있는 비율을 어떻게 변화시키는지
다음의 사례를 통해 알 수 있다.</p><ul><li>애플리케이션에 필요한 레플리카의 수</li><li>인스턴스를 정상적으로 종료하는데 소요되는 시간</li><li>새 인스턴스를 시작하는데 소요되는 시간</li><li>컨트롤러의 유형</li><li>클러스터의 리소스 용량</li></ul><h2 id=pod-disruption-conditions>파드 중단 조건</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [alpha]</code></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 클러스터에서 이 동작을 사용하려면 <code>PodDisruptionConditions</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를
활성화해야 한다.</div><p>이 기능이 활성화되면, 파드 전용 <code>DisruptionTarget</code> <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%BB%A8%EB%94%94%EC%85%98>컨디션</a>이 추가되어
<a class=glossary-tooltip title='파드의 서비스 중단으로 이어지는 이벤트' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/disruptions/ target=_blank aria-label=중단(disruption)>중단(disruption)</a>으로 인해 파드가 삭제될 예정임을 나타낸다.
추가로 컨디션의 <code>reason</code> 필드는
파드 종료에 대한 다음 원인 중 하나를 나타낸다.</p><dl><dt><code>PreemptionByKubeScheduler</code></dt><dd>파드는 더 높은 우선순위를 가진 새 파드를 수용하기 위해 스케줄러에 의해 <a class=glossary-tooltip title='쿠버네티스에서 선점(preemption)은 노드에서 낮은 우선 순위를 가지는 파드를 축출함으로써 보류 중인 파드가 적절한 노드를 찾을 수 있도록 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/#%ec%84%a0%ec%a0%90 target=_blank aria-label=선점(preempted)>선점(preempted)</a>된다. 자세한 내용은 <a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>파드 우선순위(priority)와 선점(preemption)</a>을 참조해보자.</dd><dt><code>DeletionByTaintManager</code></dt><dd>허용하지 않는 <code>NoExecute</code> 테인트(taint) 때문에 파드가 테인트 매니저(<code>kube-controller-manager</code> 내의 노드 라이프사이클 컨트롤러의 일부)에 의해 삭제될 예정이다. <a class=glossary-tooltip title='세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 테인트는 파드가 노드나 노드 그룹에 스케줄링되는 것을 방지한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taint>taint</a> 기반 축출을 참조해보자.</dd><dt><code>EvictionByEvictionAPI</code></dt><dd>파드에 <a class=glossary-tooltip title='API를 이용한 축출은 축출 API를 사용하여 파드의 정상 종료를 트리거하는 축출 오브젝트를 만드는 프로세스이다' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/api-eviction/ target=_blank aria-label='쿠버네티스 API를 이용한 축출'>쿠버네티스 API를 이용한 축출</a>이 표시되었다.</dd><dt><code>DeletionByPodGC</code></dt><dd>더 이상 존재하지 않는 노드에 바인딩된 파드는 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>파드의 가비지 콜렉션</a>에 의해 삭제될 예정이다.</dd></dl><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드 중단은 중단될 수 있다. 컨트롤 플레인은 동일한 파드의 중단을
계속 다시 시도하지만, 파드의 중단이 보장되지는 않는다. 결과적으로,
<code>DisruptionTarget</code> 컨디션이 파드에 추가될 수 있지만, 해당 파드는 사실상
삭제되지 않았을 수 있다. 이러한 상황에서는, 일정 시간이 지난 뒤에
파드 중단 상태가 해제된다.</div><p>잡(또는 크론잡(CronJob))을 사용할 때, 이러한 파드 중단 조건을 잡의
<a href=/ko/docs/concepts/workloads/controllers/job#pod-failure-policy>파드 실패 정책</a>의 일부로 사용할 수 있다.</p><h2 id=클러스터-소유자와-애플리케이션-소유자의-역할-분리>클러스터 소유자와 애플리케이션 소유자의 역할 분리</h2><p>보통 클러스터 매니저와 애플리케이션 소유자는
서로에 대한 지식이 부족한 별도의 역할로 생각하는 것이 유용하다.
이와 같은 책임의 분리는
다음의 시나리오에서 타당할 수 있다.</p><ul><li>쿠버네티스 클러스터를 공유하는 애플리케이션 팀이 많고, 자연스럽게 역할이 나누어진 경우</li><li>타사 도구 또는 타사 서비스를 이용해서
클러스터 관리를 자동화 하는 경우</li></ul><p>Pod Disruption Budget은 역할 분리에 따라
역할에 맞는 인터페이스를 제공한다.</p><p>만약 조직에 역할 분리에 따른 책임의 분리가 없다면
Pod Disruption Budget을 사용할 필요가 없다.</p><h2 id=클러스터에서-중단이-발생할-수-있는-작업을-하는-방법>클러스터에서 중단이 발생할 수 있는 작업을 하는 방법</h2><p>만약 클러스터 관리자라면, 그리고 클러스터 전체 노드에 노드 또는 시스템 소프트웨어 업그레이드와 같은
중단이 발생할 수 있는 작업을 수행하는 경우 다음과 같은 옵션을 선택한다.</p><ul><li>업그레이드 하는 동안 다운타임을 허용한다.</li><li>다른 레플리카 클러스터로 장애조치를 한다.<ul><li>다운타임은 없지만, 노드 사본과
전환 작업을 조정하기 위한 인력 비용이 많이 발생할 수 있다.</li></ul></li><li>PDB를 이용해서 애플리케이션의 중단에 견디도록 작성한다.<ul><li>다운타임 없음</li><li>최소한의 리소스 중복</li><li>클러스터 관리의 자동화 확대 적용</li><li>내결함성이 있는 애플리케이션의 작성은 까다롭지만
자발적 중단를 허용하는 작업의 대부분은 오토스케일링과
비자발적 중단를 지원하는 작업과 겹친다.</li></ul></li></ul><h2 id=다음-내용>다음 내용</h2><ul><li><p><a href=/docs/tasks/run-application/configure-pdb/>Pod Disruption Budget 설정하기</a>의 단계를 따라서 애플리케이션을 보호한다.</p></li><li><p><a href=/docs/tasks/administer-cluster/safely-drain-node/>노드 비우기</a>에 대해 자세히 알아보기</p></li><li><p>롤아웃 중에 가용성을 유지하는 단계를 포함하여
<a href=/ko/docs/concepts/workloads/controllers/deployment/#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>디플로이먼트 업데이트</a>에 대해 알아보기</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>1.4 - 임시(Ephemeral) 컨테이너</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><p>이 페이지는 임시 컨테이너에 대한 개요를 제공한다.
이 특별한 유형의 컨테이너는 트러블슈팅과 같은 사용자가 시작한 작업을 완료하기 위해
기존 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>에서 임시적으로 실행된다.
임시 컨테이너는 애플리케이션을 빌드하는 경우보다는 서비스 점검과 같은 경우에 더 적합하다.</p><h2 id=임시-컨테이너-이해하기>임시 컨테이너 이해하기</h2><p><a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 는 쿠버네티스 애플리케이션의
기본 구성 요소이다. 파드는 일회용이고, 교체 가능한 것으로 의도되었기
때문에, 사용자는 파드가 한번 생성되면, 컨테이너를 추가할 수 없다.
대신, 사용자는 보통 <a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a> 를
사용해서 제어하는 방식으로 파드를 삭제하고 교체한다.</p><p>그러나 때때로 재현하기 어려운 버그의 문제 해결을 위해
기존 파드의 상태를 검사해야 할 수 있다. 이 경우 사용자는
기존 파드에서 임시 컨테이너를 실행해서 상태를 검사하고, 임의의 명령을
실행할 수 있다.</p><h3 id=임시-컨테이너는-무엇인가>임시 컨테이너는 무엇인가?</h3><p>임시 컨테이너는 리소스 또는 실행에 대한 보증이 없다는 점에서
다른 컨테이너와 다르며, 결코 자동으로 재시작되지 않는다. 그래서
애플리케이션을 만드는데 적합하지 않다. 임시 컨테이너는
일반 컨테이너와 동일한 <code>ContainerSpec</code> 을 사용해서 명시하지만, 많은 필드가
호환되지 않으며 임시 컨테이너에는 허용되지 않는다.</p><ul><li>임시 컨테이너는 포트를 가지지 않을 수 있으므로, <code>ports</code>,
<code>livenessProbe</code>, <code>readinessProbe</code> 와 같은 필드는 허용되지 않는다.</li><li>파드에 할당된 리소스는 변경할 수 없으므로, <code>resources</code> 설정이 허용되지 않는다.</li><li>허용되는 필드의 전체 목록은 <a href=/docs/reference/generated/kubernetes-api/v1.25/#ephemeralcontainer-v1-core>임시컨테이너 참조
문서</a>를 본다.</li></ul><p>임시 컨테이너는 <code>pod.spec</code> 에 직접 추가하는 대신
API에서 특별한 <code>ephemeralcontainers</code> 핸들러를 사용해서 만들어지기 때문에
<code>kubectl edit</code>을 사용해서 임시 컨테이너를 추가할 수 없다.</p><p>일반 컨테이너와 마찬가지로, 사용자는 임시 컨테이너를 파드에 추가한
이후에 변경하거나 제거할 수 없다.</p><h2 id=임시-컨테이너의-사용>임시 컨테이너의 사용</h2><p>임시 컨테이너는 컨테이너가 충돌 되거나 또는 컨테이너 이미지에
디버깅 도구가 포함되지 않은 이유로 <code>kubectl exec</code> 이 불충분할 때
대화형 문제 해결에 유용하다.</p><p>특히, <a href=https://github.com/GoogleContainerTools/distroless>distroless 이미지</a>
를 사용하면 공격 표면(attack surface)과 버그 및 취약점의 노출을 줄이는 최소한의
컨테이너 이미지를 배포할 수 있다. distroless 이미지는 셸 또는 어떤 디버깅 도구를
포함하지 않기 때문에, <code>kubectl exec</code> 만으로는 distroless
이미지의 문제 해결이 어렵다.</p><p>임시 컨테이너 사용 시 <a href=/docs/tasks/configure-pod-container/share-process-namespace/>프로세스 네임스페이스
공유</a>를
활성화하면 다른 컨테이너 안의 프로세스를 보는 데 도움이 된다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container>임시 컨테이너 디버깅하기</a>에 대해 알아보기.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-868be91dc02aab6dc768102e4abf5eff>1.5 - 사용자 네임스페이스</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [alpha]</code></div><p>이 페이지에서는 사용자 네임스페이스가 쿠버네티스 파드에서 사용되는 방법에 대해 설명한다.
사용자 네임스페이스는 컨테이너 내에서 실행 중인 사용자와
호스트의 사용자를 분리할 수 있도록 한다.</p><p>컨테이너에서 루트(root)로 실행되는 프로세스는
호스트에서 다른 (루트가 아닌) 사용자로 실행될 수 있다.
즉, 프로세스는 사용자 네임스페이스 내부 작업에 대해 특권을 갖지만(privileged)
네임스페이스 외부의 작업에서는 특권을 갖지 않는다.</p><p>이러한 기능을 사용하여 훼손(compromised)된 컨테이너가
호스트나 동일한 노드의 다른 파드에 미칠 수 있는 손상을 줄일 수 있다.
<strong>HIGH</strong> 또는 <strong>CRITICAL</strong> 등급의 일부 <a href=https://github.com/kubernetes/enhancements/tree/217d790720c5aef09b8bd4d6ca96284a0affe6c2/keps/sig-node/127-user-namespaces#motivation>보안 취약점</a>은
사용자 네임스페이스가 Active 상태일 때 사용할 수 없다.
사용자 네임스페이스는 일부 미래의 취약점들도 완화시킬 수 있을 것으로 기대된다.</p><h2 id=시작하기-전에>시작하기 전에</h2><div class="alert alert-secondary callout third-party-content" role=alert>&#128711; 이 항목은 쿠버네티스에 속하지 않는 써드파티 프로젝트 또는 제품의 링크로 연결됩니다. <a class=alert-more-info href=#third-party-content-disclaimer>추가 정보</a></div><p>이것은 리눅스 전용 기능이다. 또한
<a class=glossary-tooltip title='컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/setup/production-environment/container-runtimes/ target=_blank aria-label='컨테이너 런타임'>컨테이너 런타임</a>에서
이 기능을 쿠버네티스 스테이트리스(stateless) 파드와 함께 사용하려면 지원이 필요하다.</p><ul><li><p>CRI-O: v1.25에는 사용자 네임스페이스가 지원된다.</p></li><li><p>containerd: 1.7 릴리즈에서 지원이 계획돼 있다.
자세한 내용은 containerd 이슈 <a href=https://github.com/containerd/containerd/issues/7063>#7063</a>를 참조한다.</p></li></ul><p><a href=https://github.com/Mirantis/cri-dockerd/issues/74>cri-dockerd에서의 지원</a>은 아직 계획되지 않았다.</p><h2 id=개요>개요</h2><p>사용자 네임스페이스는 컨테이너의 사용자를
호스트의 다른 사용자에게 매핑할 수 있는 리눅스 기능이다.
또한 사용자 네임스페이스의 파드에 부여된 기능은 네임스페이스 내부에서만 유효하고 외부에서는 무효하다.</p><p>파드는 <code>pod.spec.hostUsers</code> 필드를 <code>false</code>로 설정해
사용자 네임스페이스를 사용하도록 선택할 수 있다.</p><p>kubelet은 동일 노드에 있는 두 개의 스테이트리스 파드가 동일한 매핑을
사용하지 않도록 보장하는 방식으로 파드가 매핑된 호스트 UID나 GID를 선택한다.</p><p><code>pod.spec</code>의 <code>runAsUser</code>, <code>runAsGroup</code>, <code>fsGroup</code> 등의 필드는 항상
컨테이너 내의 사용자를 가리킨다.</p><p>이 기능을 활성화한 경우 유효한 UID/GID의 범위는 0부터 65535까지이다.
이는 파일 및 프로세스(<code>runAsUser</code>, <code>runAsGroup</code> 등)에 적용된다.</p><p>이 범위를 벗어나는 UID/GID를 사용하는 파일은 오버플로 ID,
주로 65534(<code>/proc/sys/kernel/overflowuid</code>와 <code>/proc/sys/kernel/overflowgid</code>에서 설정됨)에
속하는 것으로 간주된다.
그러나 65534 사용자/그룹으로 실행하더라도 이러한 파일을 수정할 수 없다.</p><p>루트로 실행돼야 하지만 다른 호스트 네임스페이스나 리소스에 접근하지 않는
대부분의 애플리케이션은 사용자 네임스페이스를 활성화한 경우
변경할 필요 없이 계속 정상적으로 실행돼야 한다.</p><h2 id=스테이트리스-파드의-사용자-네임스페이스-이해하기>스테이트리스 파드의 사용자 네임스페이스 이해하기</h2><p>기본 설정의 여러 컨테이너 런타임(Docker Engine, containerd, CRI-O 등)은
격리를 위해 리눅스 네임스페이스를 사용한다.
다른 기술도 존재하며 위와 같은 런타임에도 사용할 수 있다.
(예를 들어, Kata Container는 리눅스 네임스페이스 대신 VM을 사용한다.)
이 페이지는 격리를 위해 리눅스 네임스페이스를 사용하는 컨테이너 런타임에 주안을 둔다.</p><p>파드를 생성할 때 기본적으로 컨테이너의 네트워크를 분리하는 네임스페이스,
프로세스 보기를 분리하는 PID 네임스페이스 등
여러 새로운 네임스페이스가 격리에 사용된다.
사용자 네임스페이스를 사용하면 컨테이너의 사용자와 노드의 사용자가 격리된다.</p><p>이는 컨테이너가 루트로 실행될 수 있고 호스트의 루트가 아닌 사용자에게 매핑될 수 있다는 것을 의미한다.
컨테이너 내부에서 프로세스는 자신이 루트로 실행된다고 생각하지만
(따라서 <code>apt</code>, <code>yum</code> 등과 같은 도구가 정상적으로 작동)
실제로 프로세스는 호스트에 대한 권한이 없다.
예를 들어, 컨테이너 프로세스가 호스트에서 <code>ps</code>를 실행하고
있는 사용자를 확인하는 경우 이를 확인 할 수 있다.
사용자 <code>ps</code>는 컨테이너 안에서 명령 <code>id</code>를 실행하면 나타나는 사용자와 동일하지 않다.</p><p>이 추상화는 컨테이너가 호스트로 탈출하는 것과 같은 상황을 제한한다.
컨테이너가 호스트에서 권한이 없는 사용자로 실행 중이기 때문에
호스트에게 수행할 수 있는 작업은 제한된다.</p><p>또한, 각 파드의 사용자는 호스트의 서로 겹치지 않는 다른 사용자에게 매핑되므로
다른 파드에 대해서도 수행할 수 있는 작업이 제한된다.</p><p>파드에 부여된 기능 또한 파드 사용자 네임스페이스로 제한되는데
대부분 유효하지 않고 심지어 일부는 완전히 무효하다. 다음은 두 가지 예시이다.</p><ul><li><code>CAP_SYS_MODULE</code>은 사용자 네임스페이스를 사용하여 파드에 부여돼도
아무런 효과가 없으며 파드는 커널 모듈을 로드할 수 없다.</li><li><code>CAP_SYS_ADMIN</code>은 파드의 사용자 네임스페이스로 제한되며
네임스페이스 외부에서는 유효하지 않다.</li></ul><p>사용자 네임스페이스를 사용하지 않고 루트로 실행되는 컨테이너는
컨테이너 브레이크아웃(container breakout)의 경우 노드에 대한 루트 권한을 가진다.
컨테이너에 일부 기능이 부여된 경우 호스트에서도 해당 기능이 유효하다.
사용자 네임스페이스를 사용할 경우 이 중 어느 것도 사실이 아니다.</p><p>사용자 네임스페이스 사용 시 변경사항에 대한 자세한 내용은
<code>man 7 user_namespace</code>를 참조한다.</p><h2 id=사용자-네임스페이스를-지원하도록-노드-설정하기>사용자 네임스페이스를 지원하도록 노드 설정하기</h2><p>호스트의 파일 및 프로세스에서 0 ~ 65535 범위의
UID/GID를 사용하는 것이 좋다.</p><p>kubelet은 파드에 그것보다 더 높은 UID/GID를 할당한다.
따라서 가능한 많은 격리를 보장하려면 호스트의 파일 및 호스트의 프로세스에 사용되는
UID/GID가 0-65535 범위여야 한다.</p><p>이 권장 사항은 파드가 호스트의 임의의 파일을
잠재적으로 읽을 수 있는 <a href=https://github.com/kubernetes/kubernetes/issues/104980>CVE-2021-25741</a>과
같은 CVE의 영향을 완화하기 위해 중요하다.
파드와 호스트의 UID/GID가 겹치지 않으면 파드가 수행할 수 있는 작업이 제한된다.
즉, 파드 UID/GID가 호스트의 파일 소유자/그룹과 일치하지 않게 된다.</p><h2 id=제약-사항>제약 사항</h2><p>파드에 사용자 네임스페이스를 사용하는 경우
다른 호스트 네임스페이스를 사용할 수 없다.
특히 <code>hostUsers: false</code>를 설정하면 다음 중 하나를 설정할 수 없다.</p><ul><li><code>hostNetwork: true</code></li><li><code>hostIPC: true</code></li><li><code>hostPID: true</code></li></ul><p>파드는 볼륨을 전혀 사용하지 않거나
볼륨을 사용하는 경우에는 다음 볼륨 유형만 사용할 수 있다.</p><ul><li>configmap</li><li>secret</li><li>projected</li><li>downwardAPI</li><li>emptyDir</li></ul><p>파드가 이러한 볼륨의 파일을 읽을 수 있도록 하기 위해
파드에 <code>.spec.securityContext.fsGroup</code>을
<code>0</code>으로 지정한 것처럼 볼륨이 생성된다.
이 값이 다른 값으로 지정되면 당연히 이 다른 값이 대신 적용된다.</p><p>이로 인해 볼륨의 특정 항목에 대한 <code>defaultMode</code>나 <code>mode</code>가
그룹에 대한 권한 없이 지정되었더라도
이러한 볼륨에 대한 폴더와 파일은 그룹에 대한 권한을 갖는다.
예를 들어 파일에 소유자에 대한 권한만 있는 방식으로
이러한 볼륨을 마운트할 수 없다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-420713565efe2f940e277f6b4824ad9a>1.6 - 다운워드(Downward) API</h1><div class=lead>실행 중인 컨테이너에 파드 및 컨테이너 필드를 노출하는 두 가지 방법이 있다. 환경 변수를 활용하거나, 그리고 특수한 볼륨 타입으로 채워진 파일을 이용한다. 파드 및 컨테이너 필드를 노출하는 이 두 가지 방법을 다운워드 API라고 한다.</div><p>컨테이너가 쿠버네티스에 지나치게 종속되지 않으면서도
자기 자신에 대한 정보를 알고 있으면 유용할 때가 있다.
<em>다운워드 API</em>는 컨테이너가 자기 자신 혹은 클러스터에 대한 정보를,
쿠버네티스 클라이언트나 API 서버 없이도 사용할 수 있게 한다.</p><p>예를 들어, 잘 알려진 특정 환경 변수에다가 고유한 식별자를 넣어 사용하는 애플리케이션이 있다고 하자.
해당 애플리케이션에 맞게 작업할 수도 있겠지만,
이는 지루하고 오류가 나기 쉬울뿐더러, 낮은 결합이라는 원칙에도 위배된다.
대신, 파드의 이름을 식별자로 사용하고
잘 알려진 환경 변수에 파드의 이름을 넣는 것도 괜찮은 방법이다.</p><p>쿠버네티스에는 실행 중인 컨테이너에 파드 및 컨테이너 필드를 노출하는 두 가지 방법이 있다.</p><ul><li><a href=/ko/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>환경 변수</a></li><li><a href=/ko/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>볼륨 파일</a></li></ul><p>파드 및 컨테이너 필드를 노출하는 이 두 가지 방법을
<em>다운워드 API</em>라고 한다.</p><h2 id=사용-가능한-필드>사용 가능한 필드</h2><p>쿠버네티스 API 필드 중 일부만이 다운워드 API를 통해 접근 가능하다.
이 페이지에서는 사용 가능한 필드를 나열한다.</p><p>사용 가능한 파드 필드에 대한 정보는 <code>fieldRef</code>를 통해 넘겨줄 수 있다.
API 레벨에서, 파드의 <code>spec</code>은 항상 하나 이상의
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>컨테이너</a>를 정의한다.
사용 가능한 컨테이너 필드에 대한 정보는
<code>resourceFiledRef</code>를 통해 넘겨줄 수 있다.</p><h3 id=downwardapi-fieldRef><code>fieldRef</code>를 통해 접근 가능한 정보</h3><p>대부분의 파드 필드는 환경 변수로써,
또는 <code>다운워드 API</code> 볼륨을 사용하여 컨테이너에 제공할 수 있다.
이런 두 가지 방법을 통해 사용 가능한 필드는 다음과 같다.</p><dl><dt><code>metadata.name</code></dt><dd>파드의 이름</dd><dt><code>metadata.namespace</code></dt><dd>파드가 속한 <a class=glossary-tooltip title='쿠버네티스에서, 하나의 클러스터 내에서 리소스 그룹의 격리를 지원하기 위해 사용하는 추상화.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=네임스페이스>네임스페이스</a></dd><dt><code>metadata.uid</code></dt><dd>파드의 고유 ID</dd><dt><code>metadata.annotations['&lt;KEY>']</code></dt><dd>파드의 <a class=glossary-tooltip title='임의의 식별되지 않는 메타데이터를 오브젝트에 첨부할 때 이용하는 키-밸류 쌍.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/annotations target=_blank aria-label=어노테이션>어노테이션</a>에서 <code>&lt;KEY></code>에 해당하는 값 (예를 들어, <code>metadata.annotations['myannotation']</code>)</dd><dt><code>metadata.labels['&lt;KEY>']</code></dt><dd>파드의 <a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a>에서 <code>&lt;KEY></code>에 해당하는 문자열 (예를 들어, <code>metadata.labels['mylabel']</code>)</dd><dt><code>spec.serviceAccountName</code></dt><dd>파드의 <a class=glossary-tooltip title='파드에서 실행 중인 프로세스를 위한 신원(identity)을 제공한다.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label='서비스 어카운트'>서비스 어카운트</a></dd><dt><code>spec.nodeName</code></dt><dd>파드가 실행중인 <a class=glossary-tooltip title='노드는 쿠버네티스의 작업 장비(worker machine)이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/nodes/ target=_blank aria-label=노드>노드</a>명</dd><dt><code>status.hostIP</code></dt><dd>파드가 할당된 노드의 기본 IP 주소</dd><dt><code>status.podIP</code></dt><dd>파드의 기본 IP 주소 (일반적으로 IPv4 주소)</dd></dl><p>추가적으로 아래 필드는 <strong>환경 변수가 아닌</strong>,
<code>다운워드 API</code> 볼륨의 <code>fieldRef</code>로만 접근 가능하다.</p><dl><dt><code>metadata.labels</code></dt><dd>파드의 모든 레이블로, 한 줄마다 하나의 레이블을 갖는(<code>label-key="escaped-label-value"</code>) 형식을 취함</dd><dt><code>metadata.annotations</code></dt><dd>파드의 모든 어노테이션으로, 한 줄마다 하나의 어노테이션을 갖는(<code>annotation-key="escaped-annotation-value"</code>) 형식을 취함</dd></dl><h3 id=downwardapi-resourceFieldRef><code>resourceFieldRef</code>를 통해 접근 가능한 정보</h3><p>컨테이너 필드는 CPU와 메모리 같은 리소스에 대한
<a href=/ko/docs/concepts/configuration/manage-resources-containers/#%EC%9A%94%EC%B2%AD-%EB%B0%8F-%EC%A0%9C%ED%95%9C>요청 및 제한</a>
값을 제공한다.</p><dl><dt><code>resource: limits.cpu</code></dt><dd>컨테이너의 CPU 제한</dd><dt><code>resource: requests.cpu</code></dt><dd>컨테이너의 CPU 요청</dd><dt><code>resource: limits.memory</code></dt><dd>컨테이너의 메모리 제한</dd><dt><code>resource: requests.memory</code></dt><dd>컨테이너의 메모리 요청</dd><dt><code>resource: limits.hugepages-*</code></dt><dd>컨테이너의 hugepage 제한 (<code>DownwardAPIHugePages</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화 된 경우)</dd><dt><code>resource: requests.hugepages-*</code></dt><dd>컨테이너의 hugepage 요청 (<code>DownwardAPIHugePages</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화 된 경우)</dd><dt><code>resource: limits.ephemeral-storage</code></dt><dd>컨테이너의 임시 스토리지 제한</dd><dt><code>resource: requests.ephemeral-storage</code></dt><dd>컨테이너의 임시 스토리지 요청</dd></dl><h4 id=리소스-제한에-대한-참고-정보>리소스 제한에 대한 참고 정보</h4><p>컨테이너의 CPU와 메모리 제한을 명시하지 않고
다운워드 API로 이 정보들을 제공하려고 할 경우,
kubelet은 기본적으로
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>노드의 할당 가능량</a>에 기반하여
CPU와 메모리에 할당 가능한 최댓값을 노출시킨다.</p><h2 id=다음-내용>다음 내용</h2><p>자세한 정보는 <a href=/ko/docs/concepts/storage/volumes/#downwardapi><code>다운워드API</code> 볼륨</a>를 참고한다.</p><p>다운워드 API를 사용하여 파드 및 컨테이너 정보를 노출시켜보자.</p><ul><li><a href=/ko/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>환경 변수</a></li><li><a href=/ko/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>볼륨 파일</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-89637410cacae45a36ab1cc278c482eb>2 - 워크로드 리소스</h1></div><div class=td-content><h1 id=pg-a2dc0393e0c4079e1c504b6429844e86>2.1 - 디플로이먼트</h1><p><em>디플로이먼트(Deployment)</em> 는 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>와
<a class=glossary-tooltip title='레플리카셋은 지정된 수의 파드 레플리카가 동시에 실행이 되도록 보장한다' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=레플리카셋(ReplicaSet)>레플리카셋(ReplicaSet)</a>에 대한 선언적 업데이트를 제공한다.</p><p>디플로이먼트에서 <em>의도하는 상태</em> 를 설명하고, 디플로이먼트 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러(Controller)>컨트롤러(Controller)</a>는 현재 상태에서 의도하는 상태로 비율을 조정하며 변경한다. 새 레플리카셋을 생성하는 디플로이먼트를 정의하거나 기존 디플로이먼트를 제거하고, 모든 리소스를 새 디플로이먼트에 적용할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 디플로이먼트가 소유하는 레플리카셋은 관리하지 말아야 한다. 사용자의 유스케이스가 다음에 포함되지 않는 경우 쿠버네티스 리포지터리에 이슈를 올릴 수 있다.</div><h2 id=유스케이스>유스케이스</h2><p>다음은 디플로이먼트의 일반적인 유스케이스이다.</p><ul><li><a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%9D%EC%84%B1>레플리카셋을 롤아웃 할 디플로이먼트 생성</a>. 레플리카셋은 백그라운드에서 파드를 생성한다. 롤아웃 상태를 체크해서 성공 여부를 확인한다.</li><li>디플로이먼트의 PodTemplateSpec을 업데이트해서 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>파드의 새로운 상태를 선언한다</a>. 새 레플리카셋이 생성되면, 디플로이먼트는 파드를 기존 레플리카셋에서 새로운 레플리카셋으로 속도를 제어하며 이동하는 것을 관리한다. 각각의 새로운 레플리카셋은 디플로이먼트의 수정 버전에 따라 업데이트한다.</li><li>만약 디플로이먼트의 현재 상태가 안정적이지 않은 경우 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EB%A1%A4%EB%B0%B1>디플로이먼트의 이전 버전으로 롤백</a>한다. 각 롤백은 디플로이먼트의 수정 버전에 따라 업데이트한다.</li><li><a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81>더 많은 로드를 위해 디플로이먼트의 스케일 업</a>.</li><li><a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8%EC%9D%98-%EC%9D%BC%EC%8B%9C-%EC%A4%91%EC%A7%80%EC%99%80-%EC%9E%AC%EA%B0%9C>디플로이먼트 롤아웃 일시 중지</a>로 PodTemplateSpec에 여러 수정 사항을 적용하고, 재개하여 새로운 롤아웃을 시작한다.</li><li>롤아웃이 막혀있는지를 나타내는 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%81%ED%83%9C>디플로이먼트 상태를 이용</a>.</li><li>더 이상 필요 없는 <a href=#%EC%A0%95%EC%B1%85-%EC%B4%88%EA%B8%B0%ED%99%94>이전 레플리카셋 정리</a>.</li></ul><h2 id=디플로이먼트-생성>디플로이먼트 생성</h2><p>다음은 디플로이먼트의 예시이다. 예시는 3개의 <code>nginx</code> 파드를 불러오기 위한 레플리카셋을 생성한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/controllers/nginx-deployment.yaml download=controllers/nginx-deployment.yaml><code>controllers/nginx-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-nginx-deployment-yaml")' title="Copy controllers/nginx-deployment.yaml to clipboard"></img></div><div class=includecode id=controllers-nginx-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이 예시에 대한 설명은 다음과 같다.</p><ul><li><p><code>.metadata.name</code> 필드에 따라 <code>nginx-deployment</code> 이름으로 디플로이먼트가 생성된다.</p></li><li><p><code>.spec.replicas</code> 필드에 따라 디플로이먼트는 3개의 레플리카 파드를 생성한다.</p></li><li><p><code>.spec.selector</code> 필드는 디플로이먼트가 관리할 파드를 찾는 방법을 정의한다.
이 사례에서는 파드 템플릿에 정의된 레이블(<code>app: nginx</code>)을 선택한다.
그러나 파드 템플릿 자체의 규칙이 만족되는 한,
보다 정교한 선택 규칙의 적용이 가능하다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>.spec.selector.matchLabels</code> 필드는 {key,value}의 쌍으로 매핑되어 있다. <code>matchLabels</code> 에 매핑된
단일 {key,value}은 <code>matchExpressions</code> 의 요소에 해당하며, <code>key</code> 필드는 "key"에 그리고 <code>operator</code>는 "In"에 대응되며
<code>value</code> 배열은 "value"만 포함한다.
매칭을 위해서는 <code>matchLabels</code> 와 <code>matchExpressions</code> 의 모든 요건이 충족되어야 한다.</div></li><li><p><code>template</code> 필드에는 다음 하위 필드가 포함되어 있다.</p><ul><li>파드는 <code>.metadata.labels</code> 필드를 사용해서 <code>app: nginx</code> 라는 레이블을 붙인다.</li><li>파드 템플릿의 사양 또는 <code>.template.spec</code> 필드는
파드가 <a href=https://hub.docker.com/>도커 허브</a>의 <code>nginx</code> 1.14.2 버전 이미지를 실행하는
<code>nginx</code> 컨테이너 1개를 실행하는 것을 나타낸다.</li><li>컨테이너 1개를 생성하고, <code>.spec.template.spec.containers[0].name</code> 필드를 사용해서 <code>nginx</code> 이름을 붙인다.</li></ul></li></ul><p>시작하기 전에, 쿠버네티스 클러스터가 시작되고 실행 중인지 확인한다.
위의 디플로이먼트를 생성하려면 다음 단계를 따른다.</p><ol><li>다음 명령어를 실행해서 디플로이먼트를 생성한다.</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml
</span></span></code></pre></div><ol start=2><li><code>kubectl get deployments</code> 을 실행해서 디플로이먼트가 생성되었는지 확인한다.</li></ol><p>만약 디플로이먼트가 여전히 생성 중이면, 다음과 유사하게 출력된다.</p><pre tabindex=0><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   0/3     0            0           1s
</code></pre><p>클러스터에서 디플로이먼트를 점검할 때, 다음 필드가 표시된다.</p><ul><li><code>NAME</code> 은 네임스페이스에 있는 디플로이먼트 이름의 목록이다.</li><li><code>READY</code> 는 사용자가 사용할 수 있는 애플리케이션의 레플리카의 수를 표시한다. ready/desired 패턴을 따른다.</li><li><code>UP-TO-DATE</code> 는 의도한 상태를 얻기 위해 업데이트된 레플리카의 수를 표시한다.</li><li><code>AVAILABLE</code> 은 사용자가 사용할 수 있는 애플리케이션 레플리카의 수를 표시한다.</li><li><code>AGE</code> 는 애플리케이션의 실행된 시간을 표시한다.</li></ul><p><code>.spec.replicas</code> 필드에 따라 의도한 레플리카의 수가 3개인지 알 수 있다.</p><ol start=3><li><p>디플로이먼트의 롤아웃 상태를 보려면, <code>kubectl rollout status deployment/nginx-deployment</code> 를 실행한다.</p><p>다음과 유사하게 출력된다.</p><pre tabindex=0><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
deployment &#34;nginx-deployment&#34; successfully rolled out
</code></pre></li><li><p>몇 초 후 <code>kubectl get deployments</code> 를 다시 실행한다.
다음과 유사하게 출력된다.</p><pre tabindex=0><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           18s
</code></pre><p>디플로이먼트에서 3개의 레플리카가 생성되었고, 모든 레플리카는 최신 상태(최신 파드 템플릿을 포함)이며 사용 가능한 것을 알 수 있다.</p></li><li><p>디플로이먼트로 생성된 레플리카셋(<code>rs</code>)을 보려면, <code>kubectl get rs</code> 를 실행한다. 다음과 유사하게 출력된다.</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-75675f5897   3         3         3       18s
</code></pre><p>레플리카셋의 출력에는 다음 필드가 표시된다.</p><ul><li><code>NAME</code> 은 네임스페이스에 있는 레플리카셋 이름의 목록이다.</li><li><code>DESIRED</code> 는 디플로이먼트의 생성 시 정의된 의도한 애플리케이션 <em>레플리카</em> 의 수를 표시한다. 이것이 <em>의도한 상태</em> 이다.</li><li><code>CURRENT</code> 는 현재 실행 중인 레플리카의 수를 표시한다.</li><li><code>READY</code> 는 사용자가 사용할 수 있는 애플리케이션의 레플리카의 수를 표시한다.</li><li><code>AGE</code> 는 애플리케이션의 실행된 시간을 표시한다.</li></ul><p>레플리카셋의 이름은 항상 <code>[DEPLOYMENT-NAME]-[HASH]</code> 형식으로 된 것을 알 수 있다.
<code>HASH</code> 문자열은 레플리카셋의 <code>pod-template-hash</code> 레이블과 같다.</p></li><li><p>각 파드에 자동으로 생성된 레이블을 보려면, <code>kubectl get pods --show-labels</code> 를 실행한다.
다음과 유사하게 출력된다.</p><pre tabindex=0><code>NAME                                READY     STATUS    RESTARTS   AGE       LABELS
nginx-deployment-75675f5897-7ci7o   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
nginx-deployment-75675f5897-kzszj   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
nginx-deployment-75675f5897-qqcnn   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
</code></pre><p>만들어진 레플리카셋은 실행 중인 3개의 <code>nginx</code> 파드를 보장한다.</p></li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>디플로이먼트에는 파드 템플릿 레이블과 적절한 셀렉터를 반드시 명시해야 한다
(이 예시에서는 <code>app: nginx</code>).</p><p>레이블 또는 셀렉터는 다른 컨트롤러(다른 디플로이먼트와 스테이트풀셋(StatefulSet) 포함)와 겹치지 않아야 한다. 쿠버네티스는 겹치는 것을 막지 않으며, 만약 다중 컨트롤러가 겹치는 셀렉터를 가지는 경우 해당 컨트롤러의 충돌 또는 예기치 않은 동작을 야기할 수 있다.</p></div><h3 id=pod-template-hash-레이블>Pod-template-hash 레이블</h3><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 이 레이블은 변경하면 안 된다.</div><p><code>pod-template-hash</code> 레이블은 디플로이먼트 컨트롤러에 의해서 디플로이먼트가 생성 또는 채택한 모든 레플리카셋에 추가된다.</p><p>이 레이블은 디플로이먼트의 자식 레플리카셋이 겹치지 않도록 보장한다. 레플리카셋의 <code>PodTemplate</code> 을 해싱하고, 해시 결과를 레플리카셋 셀렉터,
파드 템플릿 레이블 및 레플리카셋 이 가질 수 있는 기존의 모든 파드에 레이블 값으로 추가해서 사용하도록 생성한다.</p><h2 id=디플로이먼트-업데이트>디플로이먼트 업데이트</h2><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 디플로이먼트의 파드 템플릿(즉, <code>.spec.template</code>)이 변경된 경우에만 디플로이먼트의 롤아웃이 트리거(trigger) 된다.
예를 들면 템플릿의 레이블이나 컨테이너 이미지가 업데이트된 경우이다. 디플로이먼트의 스케일링과 같은 다른 업데이트는 롤아웃을 트리거하지 말아야 한다.</div><p>다음 단계에 따라 디플로이먼트를 업데이트한다.</p><ol><li><p><code>nginx:1.14.2</code> 이미지 대신 <code>nginx:1.16.1</code> 이미지를 사용하도록 nginx 파드를 업데이트 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</span></span></code></pre></div><p>또는 다음의 명령어를 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</span></span></code></pre></div><p>다음과 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre><p>대안으로 디플로이먼트를 <code>edit</code> 해서 <code>.spec.template.spec.containers[0].image</code> 를 <code>nginx:1.14.2</code> 에서 <code>nginx:1.16.1</code> 로 변경한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment/nginx-deployment
</span></span></code></pre></div><p>다음과 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment edited
</code></pre></li><li><p>롤아웃 상태를 보려면 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment/nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
</code></pre><p>또는</p><pre tabindex=0><code>deployment &#34;nginx-deployment&#34; successfully rolled out
</code></pre></li></ol><p>업데이트된 디플로이먼트에 대해 자세한 정보 보기</p><ul><li><p>롤아웃이 성공하면 <code>kubectl get deployments</code> 를 실행해서 디플로이먼트를 볼 수 있다.
이와 유사하게 출력된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#b44>NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span>
</span></span><span style=display:flex><span><span style=color:#b44>nginx-deployment   3/3     3            3           36s</span>
</span></span></code></pre></div></li><li><p><code>kubectl get rs</code> 를 실행해서 디플로이먼트가 새 레플리카셋을 생성해서 파드를 업데이트 했는지 볼 수 있고,
새 레플리카셋을 최대 3개의 레플리카로 스케일 업, 이전 레플리카셋을 0개의 레플리카로 스케일 다운한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       6s
nginx-deployment-2035384211   0         0         0       36s
</code></pre></li><li><p><code>get pods</code> 를 실행하면 새 파드만 표시된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1564180365-khku8   1/1       Running   0          14s
nginx-deployment-1564180365-nacti   1/1       Running   0          14s
nginx-deployment-1564180365-z9gth   1/1       Running   0          14s
</code></pre><p>다음에 이러한 파드를 업데이트 하려면 디플로이먼트의 파드 템플릿만 다시 업데이트 하면 된다.</p><p>디플로이먼트는 업데이트되는 동안 일정한 수의 파드만 중단되도록 보장한다. 기본적으로
적어도 의도한 파드 수의 75% 이상이 동작하도록 보장한다(최대 25% 불가).</p><p>또한 디플로이먼트는 의도한 파드 수 보다 더 많이 생성되는 파드의 수를 제한한다.
기본적으로, 의도한 파드의 수 기준 최대 125%까지만 추가 파드가 동작할 수 있도록 제한한다(최대 25% 까지).</p><p>예를 들어, 위 디플로이먼트를 자세히 살펴보면 먼저 새로운 파드를 생성한 다음,
이전 파드를 삭제하고, 또 다른 새로운 파드를 만든 것을 볼 수 있다.
충분한 수의 새로운 파드가 나올 때까지 이전 파드를 죽이지 않으며, 충분한 수의 이전 파드들이 죽기 전까지 새로운 파드를 만들지 않는다.
이것은 최소 3개의 파드를 사용할 수 있게 하고, 최대 4개의 파드를 사용할 수 있게 한다.
디플로이먼트의 레플리카 크기가 4인 경우, 파드 숫자는 3개에서 5개 사이이다.</p></li><li><p>디플로이먼트의 세부 정보 가져오기</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployments
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=2
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
   Containers:
    nginx:
      Image:        nginx:1.16.1
      Port:         80/TCP
      Environment:  &lt;none&gt;
      Mounts:       &lt;none&gt;
    Volumes:        &lt;none&gt;
  Conditions:
    Type           Status  Reason
    ----           ------  ------
    Available      True    MinimumReplicasAvailable
    Progressing    True    NewReplicaSetAvailable
  OldReplicaSets:  &lt;none&gt;
  NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)
  Events:
    Type    Reason             Age   From                   Message
    ----    ------             ----  ----                   -------
    Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
    Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
    Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
</code></pre><p>처음 디플로이먼트를 생성했을 때, 디플로이먼트가 레플리카셋(nginx-deployment-2035384211)을 생성하고
3개의 레플리카로 직접 스케일 업한 것을 볼 수 있다.
디플로이먼트를 업데이트하자, 새 레플리카셋(nginx-deployment-1564180365)을 생성하고, 1개로 스케일 업한 다음 모두 실행될 때까지 대기하였다.
그 뒤 이전 레플리카셋을 2개로 스케일 다운하고 새 레플리카셋을 2개로 스케일 업하여 모든 시점에 대해 최소 3개 / 최대 3개의 파드가 존재하도록 하였다.
이후 지속해서 같은 롤링 업데이트 정책으로 새 레플리카셋은 스케일 업하고 이전 레플리카셋은 스케일 다운한다.
마지막으로 새로운 레플리카셋에 3개의 사용 가능한 레플리카가 구성되며, 이전 레플리카셋은 0개로 스케일 다운된다.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 쿠버네티스가 <code>availableReplicas</code> 수를 계산할 때 종료 중인(terminating) 파드는 포함하지 않으며,
이 수는 <code>replicas - maxUnavailable</code> 와 <code>replicas + maxSurge</code> 사이에 존재한다.
그 결과, 롤아웃 중에는 파드의 수가 예상보다 많을 수 있으며,
종료 중인 파드의 <code>terminationGracePeriodSeconds</code>가 만료될 때까지는 디플로이먼트가 소비하는 총 리소스가 <code>replicas + maxSurge</code> 이상일 수 있다.</div><h3 id=롤오버-일명-인-플라이트-다중-업데이트>롤오버(일명 인-플라이트 다중 업데이트)</h3><p>디플로이먼트 컨트롤러는 각 시간마다 새로운 디플로이먼트에서 레플리카셋이
의도한 파드를 생성하고 띄우는 것을 주시한다. 만약 디플로이먼트가 업데이트되면, 기존 레플리카셋에서
<code>.spec.selector</code> 레이블과 일치하는 파드를 컨트롤 하지만, 템플릿과 <code>.spec.template</code> 이 불일치하면 스케일 다운이 된다.
결국 새로운 레플리카셋은 <code>.spec.replicas</code> 로 스케일되고, 모든 기존 레플리카셋은 0개로 스케일된다.</p><p>만약 기존 롤아웃이 진행되는 중에 디플로이먼트를 업데이트하는 경우 디플로이먼트가 업데이트에 따라 새 레플리카셋을 생성하고,
스케일 업하기 시작한다. 그리고 이전에 스케일 업 하던 레플리카셋에 롤오버 한다.
--이것은 기존 레플리카셋 목록에 추가하고 스케일 다운을 할 것이다.</p><p>예를 들어 디플로이먼트로 <code>nginx:1.14.2</code> 레플리카를 5개 생성을 한다.
하지만 <code>nginx:1.14.2</code> 레플리카 3개가 생성되었을 때 디플로이먼트를 업데이트해서 <code>nginx:1.16.1</code>
레플리카 5개를 생성성하도록 업데이트를 한다고 가정한다. 이 경우 디플로이먼트는 즉시 생성된 3개의
<code>nginx:1.14.2</code> 파드 3개를 죽이기 시작하고 <code>nginx:1.16.1</code> 파드를 생성하기 시작한다.
이것은 과정이 변경되기 전 <code>nginx:1.14.2</code> 레플리카 5개가
생성되는 것을 기다리지 않는다.</p><h3 id=레이블-셀렉터-업데이트>레이블 셀렉터 업데이트</h3><p>일반적으로 레이블 셀렉터를 업데이트 하는 것을 권장하지 않으며 셀렉터를 미리 계획하는 것을 권장한다.
어떤 경우든 레이블 셀렉터의 업데이트를 해야하는 경우 매우 주의하고,
모든 영향을 파악했는지 확인해야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> API 버전 <code>apps/v1</code> 에서 디플로이먼트의 레이블 셀렉터는 생성 이후에는 변경할 수 없다.</div><ul><li>셀렉터 추가 시 디플로이먼트의 사양에 있는 파드 템플릿 레이블도 새 레이블로 업데이트해야 한다.
그렇지 않으면 유효성 검사 오류가 반환된다. 이 변경은 겹치지 않는 변경으로 새 셀렉터가
이전 셀렉터로 만든 레플리카셋과 파드를 선택하지 않게 되고, 그 결과로 모든 기존 레플리카셋은 고아가 되며,
새로운 레플리카셋을 생성하게 된다.</li><li>셀렉터 업데이트는 기존 셀렉터 키 값을 변경하며, 결과적으로 추가와 동일한 동작을 한다.</li><li>셀렉터 삭제는 디플로이먼트 셀렉터의 기존 키를 삭제하며 파드 템플릿 레이블의 변경을 필요로 하지 않는다.
기존 레플리카셋은 고아가 아니고, 새 레플리카셋은 생성되지 않는다.
그러나 제거된 레이블은 기존 파드와 레플리카셋에 여전히 존재한다는 점을 참고해야 한다.</li></ul><h2 id=디플로이먼트-롤백>디플로이먼트 롤백</h2><p>때때로 디플로이먼트의 롤백을 원할 수도 있다. 예를 들어 디플로이먼트가 지속적인 충돌로 안정적이지 않은 경우.
기본적으로 모든 디플로이먼트의 롤아웃 기록은 시스템에 남아있어 언제든지 원할 때 롤백이 가능하다
(이 사항은 수정 기록에 대한 상한 수정을 통해서 변경할 수 있다).</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 디플로이먼트의 수정 버전은 디플로이먼트 롤아웃시 생성된다. 이는 디플로이먼트 파드 템플릿
(<code>.spec.template</code>)이 변경되는 경우에만 새로운 수정 버전이 생성된다는 것을 의미한다.
예를 들어 템플릿의 레이블 또는 컨테이너 이미지를 업데이트 하는 경우.
디플로이먼트의 스케일링과 같은 다른 업데이트시 디플로이먼트 수정 버전은 생성되지 않으며 수동-스케일링 또는 자동-스케일링을 동시에 수행할 수 있다.
이는 이전 수정 버전으로 롤백을 하는 경우에 디플로이먼트 파드 템플릿 부분만
롤백된다는 것을 의미한다.</div><ul><li><p>디플로이먼트를 업데이트하는 동안 이미지 이름을 <code>nginx:1.16.1</code> 이 아닌 <code>nginx:1.161</code> 로 입력해서 오타를 냈다고 가정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.161 
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>롤아웃이 고착 된다. 고착된 롤아웃 상태를 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment/nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
</code></pre></li><li><p>Ctrl-C 를 눌러 위의 롤아웃 상태 보기를 중지한다. 고착된 롤아웃 상태에 대한 자세한 정보는 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%81%ED%83%9C>이 것을 더 읽어본다</a>.</p></li><li><p>이전 레플리카는 2개(<code>nginx-deployment-1564180365</code> 과 <code>nginx-deployment-2035384211</code>), 새 레플리카는 1개(nginx-deployment-3066724191)임을 알 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       25s
nginx-deployment-2035384211   0         0         0       36s
nginx-deployment-3066724191   1         1         0       6s
</code></pre></li><li><p>생성된 파드를 보면, 새로운 레플리카셋에 생성된 1개의 파드가 이미지 풀 루프(pull loop)에서 고착된 것을 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME                                READY     STATUS             RESTARTS   AGE
nginx-deployment-1564180365-70iae   1/1       Running            0          25s
nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 디플로이먼트 컨트롤러가 잘못된 롤아웃을 자동으로 중지하고, 새로운 레플리카셋의 스케일 업을 중지한다. 이는 지정한 롤링 업데이트의 파라미터(구체적으로 <code>maxUnavailable</code>)에 따라 달라진다. 쿠버네티스는 기본값으로 25%를 설정한다.</div></li><li><p>디플로이먼트에 대한 설명 보기</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>Name:           nginx-deployment
Namespace:      default
CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
Labels:         app=nginx
Selector:       app=nginx
Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable
StrategyType:       RollingUpdate
MinReadySeconds:    0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.161
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    ReplicaSetUpdated
OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)
NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)
Events:
  FirstSeen LastSeen    Count   From                    SubObjectPath   Type        Reason              Message
  --------- --------    -----   ----                    -------------   --------    ------              -------
  1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
</code></pre><p>이 문제를 해결하려면 디플로이먼트를 안정적인 이전 수정 버전으로 롤백해야 한다.</p></li></ul><h3 id=디플로이먼트의-롤아웃-기록-확인>디플로이먼트의 롤아웃 기록 확인</h3><p>다음 순서에 따라 롤아웃 기록을 확인한다.</p><ol><li><p>먼저 이 디플로이먼트의 수정 사항을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment/nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployments &#34;nginx-deployment&#34;
REVISION    CHANGE-CAUSE
1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml
2           kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
3           kubectl set image deployment/nginx-deployment nginx=nginx:1.161
</code></pre><p><code>CHANGE-CAUSE</code> 는 수정 생성시 디플로이먼트 주석인 <code>kubernetes.io/change-cause</code> 에서 복사한다. 다음에 대해 <code>CHANGE-CAUSE</code> 메시지를 지정할 수 있다.</p><ul><li>디플로이먼트에 <code>kubectl annotate deployment/nginx-deployment kubernetes.io/change-cause="image updated to 1.16.1"</code> 로 주석을 단다.</li><li>수동으로 리소스 매니페스트 편집.</li></ul></li><li><p>각 수정 버전의 세부 정보를 보려면 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment/nginx-deployment --revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployments &#34;nginx-deployment&#34; revision 2
  Labels:       app=nginx
          pod-template-hash=1159050644
  Annotations:  kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
  Containers:
   nginx:
    Image:      nginx:1.16.1
    Port:       80/TCP
     QoS Tier:
        cpu:      BestEffort
        memory:   BestEffort
    Environment Variables:      &lt;none&gt;
  No volumes.
</code></pre></li></ol><h3 id=이전-수정-버전으로-롤백>이전 수정 버전으로 롤백</h3><p>다음 단계에 따라 디플로이먼트를 현재 버전에서 이전 버전인 버전 2로 롤백한다.</p><ol><li><p>이제 현재 롤아웃의 실행 취소 및 이전 수정 버전으로 롤백 하기로 결정했다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment/nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>또는 특정 수정 버전으로 롤백하려면 <code>--to-revision</code> 옵션에 해당 수정 버전을 명시한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment/nginx-deployment --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>롤아웃 관련 명령에 대한 자세한 내용은 <a href=/docs/reference/generated/kubectl/kubectl-commands#rollout><code>kubectl rollout</code></a>을 참조한다.</p><p>이제 디플로이먼트가 이전 안정 수정 버전으로 롤백 된다. 버전 2로 롤백하기 위해 <code>DeploymentRollback</code> 이벤트가
디플로이먼트 컨트롤러에서 생성되는 것을 볼 수 있다.</p></li><li><p>만약 롤백에 성공하고, 디플로이먼트가 예상대로 실행되는지 확인하려면 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           30m
</code></pre></li><li><p>디플로이먼트의 설명 가져오기.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=4
                        kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.16.1
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)
Events:
  Type    Reason              Age   From                   Message
  ----    ------              ----  ----                   -------
  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment &#34;nginx-deployment&#34; to revision 2
  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
</code></pre></li></ol><h2 id=디플로이먼트-스케일링>디플로이먼트 스케일링</h2><p>다음 명령어를 사용해서 디플로이먼트의 스케일을 할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment scaled
</code></pre><p>가령 클러스터에서 <a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>horizontal Pod autoscaling</a>를 설정
한 경우 디플로이먼트에 대한 오토스케일러를 설정할 수 있다. 그리고 기존 파드의 CPU 사용률을 기준으로
실행할 최소 파드 및 최대 파드의 수를 선택할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment/nginx-deployment --min<span style=color:#666>=</span><span style=color:#666>10</span> --max<span style=color:#666>=</span><span style=color:#666>15</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>80</span>
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment scaled
</code></pre><h3 id=비례적-스케일링-proportional-scaling>비례적 스케일링(Proportional Scaling)</h3><p>디플로이먼트 롤링업데이트는 여러 버전의 애플리케이션을 동시에 실행할 수 있도록 지원한다.
사용자 또는 오토스케일러가 롤아웃 중에 있는 디플로이먼트 롤링 업데이트를 스케일링 하는 경우(진행중 또는 일시 중지 중),
디플로이먼트 컨트롤러는 위험을 줄이기 위해 기존 활성화된 레플리카셋(파드와 레플리카셋)의 추가 레플리카의 균형을 조절 한다.
이것을 <em>proportional scaling</em> 라 부른다.</p><p>예를 들어, 10개의 레플리카를 디플로이먼트로 <a href=#%EC%B5%9C%EB%8C%80-%EC%84%9C%EC%A7%80-max-surge>maxSurge</a>=3, 그리고 <a href=#%EC%B5%9C%EB%8C%80-%EB%B6%88%EA%B0%80-max-unavailable>maxUnavailable</a>=2 로 실행 한다.</p><ul><li><p>디플로이먼트에 있는 10개의 레플리카가 실행되는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment     10        10        10           10          50s
</code></pre></li><li><p>클러스터 내부에서 확인할 수 없는 새 이미지로 업데이트 된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:sometag
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>이미지 업데이트는 레플리카셋 nginx-deployment-1989198191 으로 새로운 롤 아웃이 시작하지만,
위에서 언급한 <code>maxUnavailable</code> 의 요구 사항으로 인해 차단된다. 롤아웃 상태를 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><pre><code>이와 유사하게 출력된다.
</code></pre><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY     AGE
nginx-deployment-1989198191   5         5         0         9s
nginx-deployment-618515232    8         8         8         1m
</code></pre></li><li><p>그 다음 디플로이먼트에 대한 새로운 스케일링 요청이 함께 따라온다. 오토스케일러는 디플로이먼트 레플리카를 15로 증가시킨다.
디플로이먼트 컨트롤러는 새로운 5개의 레플리카의 추가를 위한 위치를 결정해야 한다.
만약 비례적 스케일링을 사용하지 않으면 5개 모두 새 레플리카셋에 추가된다.
비례적 스케일링으로 추가 레플리카를 모든 레플리카셋에 걸쳐 분산할 수 있다.
비율이 높을수록 가장 많은 레플리카가 있는 레플리카셋으로 이동하고, 비율이 낮을 수록 적은 레플리카가 있는 레플리카셋으로 이동한다.
남은 것들은 대부분의 레플리카가 있는 레플리카셋에 추가된다. 0개의 레플리카가 있는 레플리카셋은 스케일 업 되지 않는다.</p></li></ul><p>위의 예시에서 기존 레플리카셋에 3개의 레플리카가 추가되고, 2개의 레플리카는 새 레플리카에 추가된다.
결국 롤아웃 프로세스는 새 레플리카가 정상이라고 가정하면 모든 레플리카를 새 레플리카셋으로 이동시킨다.
이를 확인하려면 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment     15        18        7            8           7m
</code></pre><p>롤아웃 상태는 레플리카가 각 레플리카셋에 어떻게 추가되었는지 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY     AGE
nginx-deployment-1989198191   7         7         0         7m
nginx-deployment-618515232    11        11        11        7m
</code></pre><h2 id=pausing-and-resuming-a-deployment>디플로이먼트 롤아웃 일시 중지와 재개</h2><p>디플로이먼트를 업데이트할 때 (또는 계획할 때),
하나 이상의 업데이트를 트리거하기 전에 해당 디플로이먼트에 대한 롤아웃을 일시 중지할 수 있다.
변경 사항을 적용할 준비가 되면, 디플로이먼트 롤아웃을 재개한다.
이러한 방법으로, 불필요한 롤아웃을 트리거하지 않고
롤아웃 일시 중지와 재개 사이에 여러 수정 사항을 적용할 수 있다.</p><ul><li><p>예를 들어, 생성된 디플로이먼트의 경우</p><p>디플로이먼트 상세 정보를 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx     3         3         3            3           1m
</code></pre><p>롤아웃 상태를 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         1m
</code></pre></li><li><p>다음 명령을 사용해서 일시 중지한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout pause deployment/nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment paused
</code></pre></li><li><p>그런 다음 디플로이먼트의 이미지를 업데이트 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>새로운 롤아웃이 시작되지 않는다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment/nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployments &#34;nginx&#34;
REVISION  CHANGE-CAUSE
1   &lt;none&gt;
</code></pre></li><li><p>기존 레플리카셋이 변경되지 않았는지 확인하기 위해 롤아웃 상태를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         2m
</code></pre></li><li><p>예를 들어 사용할 리소스를 업데이트하는 것처럼 원하는 만큼 업데이트할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> resources deployment/nginx-deployment -c<span style=color:#666>=</span>nginx --limits<span style=color:#666>=</span><span style=color:#b8860b>cpu</span><span style=color:#666>=</span>200m,memory<span style=color:#666>=</span>512Mi
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment resource requirements updated
</code></pre><p>디플로이먼트 롤아웃을 일시 중지하기 전 디플로이먼트의 초기 상태는 해당 기능을 지속한다.
그러나 디플로이먼트 롤아웃이 일시 중지한 상태에서는 디플로이먼트의 새 업데이트에 영향을 주지 않는다.</p></li><li><p>결국, 디플로이먼트 롤아웃을 재개하고 새로운 레플리카셋이 새로운 업데이트를 제공하는 것을 관찰한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout resume deployment/nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment resumed
</code></pre></li><li><p>롤아웃이 완료될 때까지 상태를 관찰한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs -w
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   2         2         2         2m
nginx-3926361531   2         2         0         6s
nginx-3926361531   2         2         1         18s
nginx-2142116321   1         2         2         2m
nginx-2142116321   1         2         2         2m
nginx-3926361531   3         2         1         18s
nginx-3926361531   3         2         1         18s
nginx-2142116321   1         1         1         2m
nginx-3926361531   3         3         1         18s
nginx-3926361531   3         3         2         19s
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         20s
</code></pre></li><li><p>롤아웃 최신 상태를 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         28s
</code></pre></li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 일시 중지된 디플로이먼트를 재개할 때까지 롤백할 수 없다.</div><h2 id=디플로이먼트-상태>디플로이먼트 상태</h2><p>디플로이먼트는 라이프사이클 동안 다양한 상태로 전환된다.
이는 새 레플리카셋을 롤아웃하는 동안 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%A7%84%ED%96%89-%EC%A4%91>진행 중</a>이 될 수 있고, <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%99%84%EB%A3%8C>완료</a>이거나 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%8B%A4%ED%8C%A8>진행 실패</a>일 수 있다.</p><h3 id=디플로이먼트-진행-중>디플로이먼트 진행 중</h3><p>쿠버네티스는 다음 작업중 하나를 수행할 때 디플로이먼트를 <em>진행 중</em> 으로 표시한다.</p><ul><li>디플로이먼트로 새 레플리카셋을 생성.</li><li>디플로이먼트로 새로운 레플리카셋을 스케일 업.</li><li>디플로이먼트로 기존 레플리카셋을 스케일 다운.</li><li>새 파드가 준비되거나 이용할 수 있음(최소 <a href=#%EC%B5%9C%EC%86%8C-%EB%8C%80%EA%B8%B0-%EC%8B%9C%EA%B0%84-%EC%B4%88>준비 시간(초)</a> 동안 준비됨).</li></ul><p>롤아웃이 "진행 중" 상태가 되면,
디플로이먼트 컨트롤러는 디플로이먼트의 <code>.status.conditions</code>에 다음 속성을 포함하는 컨디션을 추가한다.</p><ul><li><code>type: Progressing</code></li><li><code>status: "True"</code></li><li><code>reason: NewReplicaSetCreated</code> | <code>reason: FoundNewReplicaSet</code> | <code>reason: ReplicaSetUpdated</code></li></ul><p><code>kubectl rollout status</code> 를 사용해서 디플로이먼트의 진행사황을 모니터할 수 있다.</p><h3 id=디플로이먼트-완료>디플로이먼트 완료</h3><p>쿠버네티스는 다음과 같은 특성을 가지게 되면 디플로이먼트를 <em>완료</em> 로 표시한다.</p><ul><li>디플로이먼트과 관련된 모든 레플리카가 지정된 최신 버전으로 업데이트 되었을 때.
즉, 요청한 모든 업데이트가 완료되었을 때.</li><li>디플로이먼트와 관련한 모든 레플리카를 사용할 수 있을 때.</li><li>디플로이먼트에 대해 이전 복제본이 실행되고 있지 않을 때.</li></ul><p>롤아웃이 "완료" 상태가 되면,
디플로이먼트 컨트롤러는 디플로이먼트의 <code>.status.conditions</code>에 다음 속성을 포함하는 컨디션을 추가한다.</p><ul><li><code>type: Progressing</code></li><li><code>status: "True"</code></li><li><code>reason: NewReplicaSetAvailable</code></li></ul><p>이 <code>Progressing</code> 컨디션은 새로운 롤아웃이 시작되기 전까지는 <code>"True"</code> 상태값을 유지할 것이다.
레플리카의 가용성이 변경되는 경우에도(이 경우 <code>Available</code> 컨디션에 영향을 미침)
컨디션은 유지된다.</p><p><code>kubectl rollout status</code> 를 사용해서 디플로이먼트가 완료되었는지 확인할 수 있다.
만약 롤아웃이 성공적으로 완료되면 <code>kubectl rollout status</code> 는 종료 코드로 0이 반환된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment/nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>Waiting for rollout to finish: 2 of 3 updated replicas are available...
deployment &#34;nginx-deployment&#34; successfully rolled out
</code></pre><p>그리고 <code>kubectl rollout</code> 의 종료 상태는 0(success)이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</span></span></code></pre></div><pre tabindex=0><code>0
</code></pre><h3 id=디플로이먼트-실패>디플로이먼트 실패</h3><p>디플로이먼트시 새 레플리카셋인 완료되지 않은 상태에서는 배포를 시도하면 고착될 수 있다.
이 문제는 다음 몇 가지 요인으로 인해 발생한다.</p><ul><li>할당량 부족</li><li>준비성 프로브(readiness probe)의 실패</li><li>이미지 풀 에러</li><li>권한 부족</li><li>범위 제한</li><li>애플리케이션 런타임의 잘못된 구성</li></ul><p>이 조건을 찾을 수 있는 한 가지 방법은 디플로이먼트 스펙에서 데드라인 파라미터를 지정하는 것이다
(<a href=#%EC%A7%84%ED%96%89-%EA%B8%B0%ED%95%9C-%EC%8B%9C%EA%B0%84-%EC%B4%88><code>.spec.progressDeadlineSeconds</code></a>). <code>.spec.progressDeadlineSeconds</code> 는
(디플로이먼트 상태에서) 디플로이먼트의 진행이 정지되었음을 나타내는 디플로이먼트 컨트롤러가
대기하는 시간(초)를 나타낸다.</p><p>다음 <code>kubectl</code> 명령어로 <code>progressDeadlineSeconds</code> 를 설정해서 컨트롤러가
10분 후 디플로이먼트 롤아웃에 대한 진행 상태의 부족에 대한 리포트를 수행하게 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch deployment/nginx-deployment -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;progressDeadlineSeconds&#34;:600}}&#39;</span>
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>deployment.apps/nginx-deployment patched
</code></pre><p>만약 데드라인을 넘어서면 디플로이먼트 컨트롤러는 디플로이먼트의 <code>.status.conditions</code> 속성에 다음의
디플로이먼트 컨디션(DeploymentCondition)을 추가한다.</p><ul><li><code>type: Progressing</code></li><li><code>status: "False"</code></li><li><code>reason: ProgressDeadlineExceeded</code></li></ul><p>이 컨디션은 일찍 실패할 수도 있으며 이러한 경우 <code>ReplicaSetCreateError</code>를 이유로 상태값을 <code>"False"</code>로 설정한다.
또한, 디플로이먼트 롤아웃이 완료되면 데드라인은 더 이상 고려되지 않는다.</p><p>컨디션 상태에 대한 자세한 내용은 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties>쿠버네티스 API 규칙</a>을 참고한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 쿠버네티스는 <code>reason: ProgressDeadlineExceeded</code> 과 같은 상태 조건을
보고하는 것 이외에 정지된 디플로이먼트에 대해 조치를 취하지 않는다. 더 높은 수준의 오케스트레이터는 이를 활용할 수 있으며,
예를 들어 디플로이먼트를 이전 버전으로 롤백할 수 있다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 만약 디플로이먼트 롤아웃을 일시 중지하면 쿠버네티스는 지정된 데드라인과 비교하여 진행 상황을 확인하지 않는다.
롤아웃 중에 디플로이먼트 롤아웃을 안전하게 일시 중지하고, 데드라인을 넘기도록 하는 조건을 트리거하지 않고
재개할 수 있다.</div><p>설정한 타임아웃이 낮거나 일시적으로 처리될 수 있는 다른 종료의 에러로 인해 디플로이먼트에 일시적인 에러가 발생할 수 있다.
예를 들어, 할당량이 부족하다고 가정해보자.
만약 디플로이먼트를 설명하려면 다음 섹션을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>&lt;...&gt;
Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     True    ReplicaSetUpdated
  ReplicaFailure  True    FailedCreate
&lt;...&gt;
</code></pre><p>만약 <code>kubectl get deployment nginx-deployment -o yaml</code> 을 실행하면 디플로이먼트 상태는 다음과 유사하다.</p><pre tabindex=0><code>status:
  availableReplicas: 2
  conditions:
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: Replica set &#34;nginx-deployment-4262182780&#34; is progressing.
    reason: ReplicaSetUpdated
    status: &#34;True&#34;
    type: Progressing
  - lastTransitionTime: 2016-10-04T12:25:42Z
    lastUpdateTime: 2016-10-04T12:25:42Z
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: &#34;True&#34;
    type: Available
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: &#39;Error creating: pods &#34;nginx-deployment-4262182780-&#34; is forbidden: exceeded quota:
      object-counts, requested: pods=1, used: pods=3, limited: pods=2&#39;
    reason: FailedCreate
    status: &#34;True&#34;
    type: ReplicaFailure
  observedGeneration: 3
  replicas: 2
  unavailableReplicas: 2
</code></pre><p>결국, 디플로이먼트 진행 데드라인을 넘어서면, 쿠버네티스는 진행 컨디션의
상태와 이유를 업데이트한다.</p><pre tabindex=0><code>Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     False   ProgressDeadlineExceeded
  ReplicaFailure  True    FailedCreate
</code></pre><p>디플로이먼트를 스케일 다운하거나, 실행 중인 다른 컨트롤러를 스케일 다운하거나,
네임스페이스에서 할당량을 늘려서 할당량이 부족한 문제를 해결할 수 있다.
만약 할당량 컨디션과 디플로이먼트 롤아웃이 완료되어 디플로이먼트 컨트롤러를 만족한다면
성공한 컨디션의 디플로이먼트 상태가 업데이트를 볼 수 있다(<code>status: "True"</code> 와 <code>reason: NewReplicaSetAvailable</code>).</p><pre tabindex=0><code>Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
</code></pre><p><code>type: Available</code> 과 <code>status: "True"</code> 는 디플로이먼트가 최소한의 가용성을 가지고 있는 것을 의미한다.
최소한의 가용성은 디플로이먼트 계획에 명시된 파라미터에 의해 결정된다. <code>type: Progressing</code> 과 <code>status: "True"</code> 는 디플로이먼트가
롤아웃 도중에 진행 중 이거나, 성공적으로 완료되었으며, 진행 중 최소한으로 필요한 새로운 레플리카를 이용 가능하다는 것이다.
(자세한 내용은 특정 조건의 이유를 참조한다.
이 경우 <code>reason: NewReplicaSetAvailable</code> 는 배포가 완료되었음을 의미한다.)</p><p><code>kubectl rollout status</code> 를 사용해서 디플로이먼트의 진행이 실패되었는지 확인할 수 있다.
<code>kubectl rollout status</code> 는 디플로이먼트의 진행 데드라인을 초과하면 0이 아닌 종료 코드를 반환한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment/nginx-deployment
</span></span></code></pre></div><p>이와 유사하게 출력된다.</p><pre tabindex=0><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
error: deployment &#34;nginx&#34; exceeded its progress deadline
</code></pre><p>그리고 <code>kubectl rollout</code> 의 종료 상태는 1(error를 의미함)이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</span></span></code></pre></div><pre tabindex=0><code>1
</code></pre><h3 id=실패한-디플로이먼트에서의-운영>실패한 디플로이먼트에서의 운영</h3><p>완료된 디플로이먼트에 적용되는 모든 행동은 실패한 디플로이먼트에도 적용된다.
디플로이먼트 파드 템플릿에서 여러 개의 수정사항을 적용해야하는 경우 스케일 업/다운 하거나, 이전 수정 버전으로 롤백하거나, 일시 중지할 수 있다.</p><h2 id=정책-초기화>정책 초기화</h2><p>디플로이먼트의 <code>.spec.revisionHistoryLimit</code> 필드를 설정해서
디플로이먼트에서 유지해야 하는 이전 레플리카셋의 수를 명시할 수 있다. 나머지는 백그라운드에서 가비지-수집이 진행된다.
기본적으로 10으로 되어 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 명시적으로 이 필드를 0으로 설정하면 그 결과로 디플로이먼트의 기록을 전부 초기화를 하고,
디플로이먼트는 롤백할 수 없게 된다.</div><h2 id=카나리-디플로이먼트>카나리 디플로이먼트</h2><p>만약 디플로이먼트를 이용해서 일부 사용자 또는 서버에 릴리스를 롤아웃 하기 위해서는
<a href=/ko/docs/concepts/cluster-administration/manage-deployment/#%EC%B9%B4%EB%82%98%EB%A6%AC-canary-%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8>리소스 관리</a>에
설명된 카나리 패던에 따라 각 릴리스 마다 하나씩 여러 디플로이먼트를 생성할 수 있다.</p><h2 id=디플로이먼트-사양-작성>디플로이먼트 사양 작성</h2><p>다른 모든 쿠버네티스 설정과 마찬가지로 디플로이먼트에는 <code>.apiVersion</code>, <code>.kind</code> 그리고 <code>.metadata</code> 필드가 필요하다.
설정 파일 작업에 대한 일반적인 내용은
<a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>애플리케이션 배포하기</a>,
컨테이너 구성하기 그리고 <a href=/ko/docs/concepts/overview/working-with-objects/object-management/>kubectl을 사용해서 리소스 관리하기</a> 문서를 참조한다.
디플로이먼트 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><p>디플로이먼트에는 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> 섹션</a>도 필요하다.</p><h3 id=파드-템플릿>파드 템플릿</h3><p><code>.spec.template</code> 과 <code>.spec.selector</code> 은 <code>.spec</code> 에서 유일한 필수 필드이다.</p><p><code>.spec.template</code> 는 <a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>파드 템플릿</a>이다. 이것은 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>와 정확하게 동일한 스키마를 가지고 있고, 중첩된 것을 제외하면 <code>apiVersion</code> 과 <code>kind</code> 를 가지고 있지 않는다.</p><p>파드에 필요한 필드 외에 디플로이먼트 파드 템플릿은 적절한 레이블과 적절한 재시작 정책을 명시해야 한다.
레이블의 경우 다른 컨트롤러와 겹치지 않도록 해야 한다. 자세한 것은 <a href=#%EC%85%80%EB%A0%89%ED%84%B0>셀렉터</a>를 참조한다.</p><p><a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%A0%95%EC%B1%85><code>.spec.template.spec.restartPolicy</code></a> 에는 오직 <code>Always</code> 만 허용되고,
명시되지 않으면 기본값이 된다.</p><h3 id=레플리카>레플리카</h3><p><code>.spec.replicas</code> 은 필요한 파드의 수를 지정하는 선택적 필드이다. 이것의 기본값은 1이다.</p><p>예를 들어 <code>kubectl scale deployment deployment --replicas=X</code> 명령으로
디플로이먼트의 크기를 수동으로 조정한 뒤,
매니페스트를 이용하여 디플로이먼트를 업데이트하면(예: <code>kubectl apply -f deployment.yaml</code> 실행),
수동으로 설정했던 디플로이먼트의 크기가 오버라이드된다.</p><p><a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/>HorizontalPodAutoscaler</a>(또는 수평 스케일링을 위한 유사 API)가
디플로이먼트 크기를 관리하고 있다면, <code>.spec.replicas</code> 를 설정해서는 안 된다.</p><p>대신, 쿠버네티스
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>이
<code>.spec.replicas</code> 필드를 자동으로 관리한다.</p><h3 id=셀렉터>셀렉터</h3><p><code>.spec.selector</code> 는 디플로이먼트의 대상이 되는 파드에 대해 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블 셀렉터</a>를
지정하는 필수 필드이다.</p><p><code>.spec.selector</code> 는 <code>.spec.template.metadata.labels</code> 과 일치해야 하며, 그렇지 않으면 API에 의해 거부된다.</p><p>API 버전 <code>apps/v1</code> 에서는 <code>.spec.selector</code> 와 <code>.metadata.labels</code> 이 설정되지 않으면 <code>.spec.template.metadata.labels</code> 은 기본 설정되지 않는다. 그래서 이것들은 명시적으로 설정되어야 한다. 또한 <code>apps/v1</code> 에서는 디플로이먼트를 생성한 후에는 <code>.spec.selector</code> 이 변경되지 않는 점을 참고한다.</p><p>디플로이먼트는 템플릿의 <code>.spec.template</code> 와 다르거나 파드의 수가 <code>.spec.replicas</code> 를 초과할 경우
셀렉터와 일치하는 레이블을 가진 파드를 종료할 수 있다.
파드의 수가 의도한 수량보다 적을 경우 <code>.spec.template</code> 에 맞는 새 파드를 띄운다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 다른 디플로이먼트를 생성하거나, 레플리카셋 또는 레플리케이션컨트롤러와 같은 다른 컨트롤러를 사용해서 직접적으로 레이블과 셀렉터가 일치하는 다른 파드를 생성하지 말아야 한다.
만약 이렇게 하면 첫 번째 디플로이먼트는 다른 파드를 만들었다고 생각한다.
쿠버네티스는 이 일을 막지 않는다.</div><p>만약 셀렉터가 겹치는 컨트롤러가 어러 개 있는 경우, 컨트롤러는 서로 싸우고
올바르게 작동하지 않는다.</p><h3 id=전략>전략</h3><p><code>.spec.strategy</code> 는 이전 파드를 새로운 파드로 대체하는 전략을 명시한다.
<code>.spec.strategy.type</code> 은 "재생성" 또는 "롤링업데이트"가 될 수 있다.
"롤링업데이트"가 기본값이다.</p><h4 id=디플로이먼트-재생성>디플로이먼트 재생성</h4><p>기존의 모든 파드는 <code>.spec.strategy.type==Recreate</code> 이면 새 파드가 생성되기 전에 죽는다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이렇게 하면 업그레이드를 생성하기 전에 파드 종료를 보장할 수 있다. 디플로이먼트를 업그레이드하면,
이전 버전의 모든 파드가 즉시 종료된다. 신규 버전의 파드가 생성되기 전에 성공적으로 제거가
완료되기를 대기한다. 파드를 수동으로 삭제하면, 라이프사이클은 레플리카셋에 의해
제어되며(이전 파드가 여전히 종료 상태에 있는 경우에도) 교체용 파드가 즉시 생성된다. 파드에
대해 "최대" 보장이 필요한 경우
<a href=/ko/docs/concepts/workloads/controllers/statefulset/>스테이트풀셋</a>의 사용을 고려해야 한다.</div><h4 id=디플로이먼트-롤링-업데이트>디플로이먼트 롤링 업데이트</h4><p>디플로이먼트는 <code>.spec.strategy.type==RollingUpdate</code> 이면 파드를 롤링 업데이트
방식으로 업데이트 한다. <code>maxUnavailable</code> 와 <code>maxSurge</code> 를 명시해서
롤링 업데이트 프로세스를 제어할 수 있다.</p><h5 id=최대-불가-max-unavailable>최대 불가(Max Unavailable)</h5><p><code>.spec.strategy.rollingUpdate.maxUnavailable</code> 은 업데이트 프로세스 중에 사용할 수 없는 최대 파드의 수를 지정하는 선택적 필드이다.
이 값은 절대 숫자(예: 5) 또는 의도한 파드 비율(예: 10%)이 될 수 있다.
절대 값은 내림해서 백분율로 계산한다.
만약 <code>.spec.strategy.rollingUpdate.maxSurge</code> 가 0이면 값이 0이 될 수 없다. 기본 값은 25% 이다.</p><p>예를 들어 이 값을 30%로 설정하면 롤링업데이트 시작시 즉각 이전 레플리카셋의 크기를
의도한 파드 중 70%를 스케일 다운할 수 있다. 새 파드가 준비되면 기존 레플리카셋을 스케일 다운할 수 있으며,
업데이트 중에 항상 사용 가능한 전체 파드의 수는
의도한 파드의 수의 70% 이상이 되도록 새 레플리카셋을 스케일 업할 수 있다.</p><h5 id=최대-서지-max-surge>최대 서지(Max Surge)</h5><p><code>.spec.strategy.rollingUpdate.maxSurge</code> 는 의도한 파드의 수에 대해 생성할 수 있는 최대 파드의 수를 지정하는 선택적 필드이다.
이 값은 절대 숫자(예: 5) 또는 의도한 파드 비율(예: 10%)이 될 수 있다.
<code>MaxUnavailable</code> 값이 0이면 이 값은 0이 될 수 없다.
절대 값은 올림해서 백분율로 계산한다. 기본 값은 25% 이다.</p><p>예를 들어 이 값을 30%로 설정하면 롤링업데이트 시작시 새 레플리카셋의 크기를 즉시 조정해서
기존 및 새 파드의 전체 갯수를 의도한 파드의 130%를 넘지 않도록 한다.
기존 파드가 죽으면 새로운 래플리카셋은 스케일 업할 수 있으며,
업데이트하는 동안 항상 실행하는 총 파드의 수는 최대 의도한 파드의 수의 130%가 되도록 보장한다.</p><h3 id=진행-기한-시간-초>진행 기한 시간(초)</h3><p><code>.spec.progressDeadlineSeconds</code> 는 디플로어먼트가 표면적으로 <code>type: Progressing</code>, <code>status: "False"</code>의
상태 그리고 리소스가 <code>reason: ProgressDeadlineExceeded</code> 상태로 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%8B%A4%ED%8C%A8>진행 실패</a>를 보고하기 전에
디플로이먼트가 진행되는 것을 대기시키는 시간(초)를 명시하는 선택적 필드이다.
디플로이먼트 컨트롤러는 디플로이먼트를 계속 재시도 한다. 기본값은 600(초)이다.
미래에 자동화된 롤백이 구현된다면 디플로이먼트 컨트롤러는 상태를 관찰하고,
그 즉시 디플로이먼트를 롤백할 것이다.</p><p>만약 명시된다면 이 필드는 <code>.spec.minReadySeconds</code> 보다 커야 한다.</p><h3 id=최소-대기-시간-초>최소 대기 시간(초)</h3><p><code>.spec.minReadySeconds</code> 는 새롭게 생성된 파드의 컨테이너가 어떤 것과도 충돌하지 않고 사
용할 수 있도록 준비되어야 하는 최소 시간(초)을 지정하는 선택적 필드이다.
이 기본 값은 0이다(파드는 준비되는 즉시 사용할 수 있는 것으로 간주됨).
파드가 준비되었다고 간주되는 시기에 대한 자세한 내용은 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%94%84%EB%A1%9C%EB%B8%8C-probe>컨테이너 프로브</a>를 참조한다.</p><h3 id=수정-버전-기록-제한>수정 버전 기록 제한</h3><p>디플로이먼트의 수정 버전 기록은 자신이 컨트롤하는 레플리카셋에 저장된다.</p><p><code>.spec.revisionHistoryLimit</code> 은 롤백을 허용하기 위해 보존할 이전 레플리카셋의 수를 지정하는 선택적 필드이다.
이 이전 레플리카셋은 <code>etcd</code> 의 리소스를 소비하고, <code>kubectl get rs</code> 의 결과를 가득차게 만든다. 각 디플로이먼트의 구성은 디플로이먼트의 레플리카셋에 저장된다. 이전 레플리카셋이 삭제되면 해당 디플로이먼트 수정 버전으로 롤백할 수 있는 기능이 사라진다. 기본적으로 10개의 기존 레플리카셋이 유지되지만 이상적인 값은 새로운 디플로이먼트의 빈도와 안정성에 따라 달라진다.</p><p>더욱 구체적으로 이 필드를 0으로 설정하면 레플리카가 0이 되며 이전 레플리카셋이 정리된다.
이 경우, 새로운 디플로이먼트 롤아웃을 취소할 수 없다. 새로운 디플로이먼트 롤아웃은 수정 버전 이력이 정리되기 때문이다.</p><h3 id=일시-정지>일시 정지</h3><p><code>.spec.paused</code> 는 디플로이먼트를 일시 중지나 재개하기 위한 선택적 부울 필드이다.
일시 중지 된 디플로이먼트와 일시 중지 되지 않은 디플로이먼트 사이의 유일한 차이점은
일시 중지된 디플로이먼트는 PodTemplateSpec에 대한 변경 사항이 일시중지 된 경우 새 롤아웃을 트리거 하지 않는다.
디플로이먼트는 생성시 기본적으로 일시 중지되지 않는다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/workloads/pods>파드</a>에 대해 배운다.</li><li><a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>디플로이먼트를 사용해서 상태를 유지하지 않는 애플리케이션을 구동한다</a>.</li><li><code>Deployment</code>는 쿠버네티스 REST API에서 상위-수준 리소스이다.
디플로이먼트 API를 이해하기 위해서
<a href=/docs/reference/kubernetes-api/workload-resources/deployment-v1/>Deployment</a>
오브젝트 정의를 읽는다.</li><li><a href=/ko/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>과
이를 사용해서 어떻게 중단 중에 애플리케이션 가용성을 관리할 수 있는지에 대해 읽는다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d459b930218774655fa7fd1620625539>2.2 - 레플리카셋</h1><p>레플리카셋의 목적은 레플리카 파드 집합의 실행을 항상 안정적으로 유지하는 것이다.
이처럼 레플리카셋은 보통 명시된 동일 파드 개수에 대한 가용성을 보증하는데 사용한다.</p><h2 id=레플리카셋의-작동-방식>레플리카셋의 작동 방식</h2><p>레플리카셋을 정의하는 필드는 획득 가능한 파드를 식별하는 방법이 명시된 셀렉터, 유지해야 하는 파드 개수를 명시하는 레플리카의 개수,
그리고 레플리카 수 유지를 위해 생성하는 신규 파드에 대한 데이터를 명시하는 파드 템플릿을 포함한다.
그러면 레플리카셋은 필드에 지정된 설정을 충족하기 위해 필요한 만큼 파드를 만들고 삭제한다.
레플리카셋이 새로운 파드를 생성해야 할 경우, 명시된 파드 템플릿을
사용한다.</p><p>레플리카셋은 파드의 <a href=/ko/docs/concepts/architecture/garbage-collection/#%EC%86%8C%EC%9C%A0%EC%9E%90-owner-%EC%99%80-%EC%A2%85%EC%86%8D-dependent>metadata.ownerReferences</a>
필드를 통해 파드에 연결되며, 이는 현재 오브젝트가 소유한 리소스를 명시한다.
레플리카셋이 가지고 있는 모든 파드의 ownerReferences 필드는 해당 파드를 소유한 레플리카셋을 식별하기 위한 소유자 정보를 가진다.
이 링크를 통해 레플리카셋은 자신이 유지하는 파드의 상태를 확인하고 이에 따라 관리 한다.</p><p>레플리카셋은 셀렉터를 이용해서 필요한 새 파드를 식별한다. 만약 파드에
OwnerReference가 없거나, OwnerReference가 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러(Controller)>컨트롤러(Controller)</a> 가 아니고
레플리카셋의 셀렉터와 일치한다면 레플리카셋이 즉각 파드를 가지게 될 것이다.</p><h2 id=레플리카셋을-사용하는-시기>레플리카셋을 사용하는 시기</h2><p>레플리카셋은 지정된 수의 파드 레플리카가 항상 실행되도록 보장한다.
그러나 디플로이먼트는 레플리카셋을 관리하고 다른 유용한 기능과 함께
파드에 대한 선언적 업데이트를 제공하는 상위 개념이다.
따라서 우리는 사용자 지정 오케스트레이션이 필요하거나 업데이트가 전혀 필요하지 않은 경우라면
레플리카셋을 직접적으로 사용하기 보다는 디플로이먼트를 사용하는 것을 권장한다.</p><p>이는 레플리카셋 오브젝트를 직접 조작할 필요가 없다는 것을 의미한다.
대신 디플로이먼트를 이용하고 사양 부분에서 애플리케이션을 정의하면 된다.</p><h2 id=예시>예시</h2><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/controllers/frontend.yaml download=controllers/frontend.yaml><code>controllers/frontend.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-frontend-yaml")' title="Copy controllers/frontend.yaml to clipboard"></img></div><div class=includecode id=controllers-frontend-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 케이스에 따라 레플리카를 수정한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-frontend:v3<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이 매니페스트를 <code>frontend.yaml</code>에 저장하고 쿠버네티스 클러스터에 적용하면 정의되어 있는 레플리카셋이
생성되고 레플리카셋이 관리하는 파드가 생성된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>현재 배포된 레플리카셋을 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>그리고 생성된 프런트엔드를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME       DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>frontend   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       6s
</span></span></code></pre></div><p>또한 레플리카셋의 상태를 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe rs/frontend
</span></span></code></pre></div><p>출력은 다음과 유사할 것이다.</p><pre tabindex=0><code>Name:         frontend
Namespace:    default
Selector:     tier=frontend
Labels:       app=guestbook
              tier=frontend
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;ReplicaSet&#34;,&#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;labels&#34;:{&#34;app&#34;:&#34;guestbook&#34;,&#34;tier&#34;:&#34;frontend&#34;},&#34;name&#34;:&#34;frontend&#34;,...
Replicas:     3 current / 3 desired
Pods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:  tier=frontend
  Containers:
   php-redis:
    Image:        gcr.io/google_samples/gb-frontend:v3
    Port:         &lt;none&gt;
    Host Port:    &lt;none&gt;
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Events:
  Type    Reason            Age   From                   Message
  ----    ------            ----  ----                   -------
  Normal  SuccessfulCreate  117s  replicaset-controller  Created pod: frontend-wtsmm
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-b2zdv
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-vcmts
</code></pre><p>마지막으로 파드가 올라왔는지 확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>다음과 유사한 파드 정보를 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY   STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-b2zdv   1/1     Running   <span style=color:#666>0</span>          6m36s
</span></span><span style=display:flex><span>frontend-vcmts   1/1     Running   <span style=color:#666>0</span>          6m36s
</span></span><span style=display:flex><span>frontend-wtsmm   1/1     Running   <span style=color:#666>0</span>          6m36s
</span></span></code></pre></div><p>또한 파드들의 소유자 참조 정보가 해당 프런트엔드 레플리카셋으로 설정되어 있는지 확인할 수 있다.
확인을 위해서는 실행 중인 파드 중 하나의 yaml을 확인한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods frontend-b2zdv -o yaml
</span></span></code></pre></div><p>메타데이터의 ownerReferences 필드에 설정되어 있는 프런트엔드 레플리카셋의 정보가 다음과 유사하게 나오는 것을 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-12T07:06:16Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>generateName</span>:<span style=color:#bbb> </span>frontend-<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-b2zdv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ownerReferences</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>blockOwnerDeletion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>f391f6db-bb9b-4c09-ae74-6a1f77f3d5cf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=템플릿을-사용하지-않는-파드의-획득>템플릿을 사용하지 않는 파드의 획득</h2><p>단독(bare) 파드를 생성하는 것에는 문제가 없지만, 단독 파드가 레플리카셋의 셀렉터와 일치하는 레이블을 가지지
않도록 하는 것을 강력하게 권장한다. 그 이유는 레플리카셋이 소유하는 파드가 템플릿에 명시된 파드에만 국한되지 않고,
이전 섹션에서 명시된 방식에 의해서도 다른 파드의 획득이 가능하기 때문이다.</p><p>이전 프런트엔드 레플리카셋 예제와 다음의 매니페스트에 명시된 파드를 가져와 참조한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/pods/pod-rs.yaml download=pods/pod-rs.yaml><code>pods/pod-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-rs-yaml")' title="Copy pods/pod-rs.yaml to clipboard"></img></div><div class=includecode id=pods-pod-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:2.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:1.0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>기본 파드는 소유자 관련 정보에 컨트롤러(또는 오브젝트)를 가지지 않기 때문에 프런트엔드
레플리카셋의 셀렉터와 일치하면 즉시 레플리카셋에 소유된다.</p><p>프런트엔드 레플리카셋이 배치되고 초기 파드 레플리카가 셋업된 이후에, 레플리카 수 요구 사항을 충족시키기 위해서
신규 파드를 생성한다고 가정해보자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>새로운 파드는 레플리카셋에 의해 인식되며 레플리카셋이 필요한 수량을 초과하면
즉시 종료된다.</p><p>파드를 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>결과에는 새로운 파드가 이미 종료되었거나 종료가 진행 중인 것을 보여준다.</p><pre tabindex=0><code>NAME             READY   STATUS        RESTARTS   AGE
frontend-b2zdv   1/1     Running       0          10m
frontend-vcmts   1/1     Running       0          10m
frontend-wtsmm   1/1     Running       0          10m
pod1             0/1     Terminating   0          1s
pod2             0/1     Terminating   0          1s
</code></pre><p>파드를 먼저 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>그 다음 레플리카셋을 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>레플리카셋이 해당 파드를 소유한 것을 볼 수 있으며 새 파드 및 기존 파드의 수가
레플리카셋이 필요로 하는 수와 일치할 때까지 사양에 따라 신규 파드만 생성한다. 파드를 가져온다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>다음 출력에서 볼 수 있다.</p><pre tabindex=0><code>NAME             READY   STATUS    RESTARTS   AGE
frontend-hmmj2   1/1     Running   0          9s
pod1             1/1     Running   0          36s
pod2             1/1     Running   0          36s
</code></pre><p>이러한 방식으로 레플리카셋은 템플릿을 사용하지 않는 파드를 소유하게 된다.</p><h2 id=레플리카셋-매니페스트-작성하기>레플리카셋 매니페스트 작성하기</h2><p>레플리카셋은 모든 쿠버네티스 API 오브젝트와 마찬가지로 <code>apiVersion</code>, <code>kind</code>, <code>metadata</code> 필드가 필요하다.
레플리카셋에 대한 <code>kind</code> 필드의 값은 항상 레플리카셋이다.</p><p>레플리카셋 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><p>레플리카셋도 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> 섹션</a>이 필요하다.</p><h3 id=파드-템플릿>파드 템플릿</h3><p><code>.spec.template</code>은 레이블을 붙이도록 되어 있는 <a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>파드 템플릿</a>이다.
우리는 <code>frontend.yaml</code> 예제에서 <code>tier: frontend</code>이라는 레이블을 하나 가지고 있다.
이 파드를 다른 컨트롤러가 취하지 않도록 다른 컨트롤러의 셀렉터와 겹치지 않도록 주의해야 한다.</p><p>템플릿의 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy>재시작 정책</a> 필드인
<code>.spec.template.spec.restartPolicy</code>는 기본값인 <code>Always</code>만 허용된다.</p><h3 id=파드-셀렉터>파드 셀렉터</h3><p><code>.spec.selector</code> 필드는 <a href=/ko/docs/concepts/overview/working-with-objects/labels/>레이블 셀렉터</a>이다.
<a href=#%EB%A0%88%ED%94%8C%EB%A6%AC%EC%B9%B4-%EC%85%8B%EC%9D%98-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D>앞서</a> 논의한 것처럼 이 레이블은 소유될 가능성이 있는 파드를 식별하는데 사용된다.
우리 <code>frontend.yaml</code> 예제에서의 셀렉터는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span></code></pre></div><p>레플리카셋에서 <code>.spec.template.metadata.labels</code>는 <code>spec.selector</code>과 일치해야 하며
그렇지 않으면 API에 의해 거부된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 2개의 레플리카셋이 동일한 <code>.spec.selector</code>필드를 지정한 반면, 다른
<code>.spec.template.metadata.labels</code>와 <code>.spec.template.spec</code> 필드를 명시한 경우, 각 레플리카셋은
다른 레플리카셋이 생성한 파드를 무시한다.</div><h3 id=레플리카>레플리카</h3><p><code>.spec.replicas</code>를 설정해서 동시에 동작하는 파드의 수를 지정할 수 있다.
레플리카셋은 파드의 수가 일치하도록 생성 및 삭제한다.</p><p>만약 <code>.spec.replicas</code>를 지정하지 않으면 기본값은 1이다.</p><h2 id=레플리카셋-작업>레플리카셋 작업</h2><h3 id=레플리카셋과-해당-파드-삭제>레플리카셋과 해당 파드 삭제</h3><p>레플리카셋 및 모든 파드를 삭제하려면
<a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>를 사용한다.
<a href=/ko/docs/concepts/architecture/garbage-collection/>가비지 수집기</a>는
기본적으로 종속되어 있는 모든 파드를 자동으로 삭제한다.</p><p>REST API 또는 <code>client-go</code> 라이브러리를 이용할 때는 -d 옵션으로 <code>propagationPolicy</code>를
<code>Background</code>또는 <code>Foreground</code>로 설정해야 한다. 예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><h3 id=레플리카셋만-삭제하기>레플리카셋만 삭제하기</h3><p><a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>에
<code>--cascade=orphan</code> 옵션을 사용하여
연관 파드에 영향을 주지 않고 레플리카셋을 삭제할 수 있다.
REST API 또는 <code>client-go</code> 라이브러리를 이용할 때는 <code>propagationPolicy</code>에 <code>Orphan</code>을 설정해야 한다.
예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>원본이 삭제되면 새 레플리카셋을 생성해서 대체할 수 있다.
기존 <code>.spec.selector</code>와 신규 <code>.spec.selector</code>가 같으면 새 레플리카셋은 기존 파드를 선택한다.
하지만 신규 레플리카셋은 기존 파드를 신규 레플리카셋의 새롭고 다른 파드 템플릿에 일치시키는 작업을 수행하지는 않는다.
컨트롤 방식으로 파드를 새로운 사양으로 업데이트 하기 위해서는
<a href=/ko/docs/concepts/workloads/controllers/deployment/#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8-%EC%83%9D%EC%84%B1>디플로이먼트</a>를 이용하면 된다.
이는 레플리카셋이 롤링 업데이트를 직접적으로 지원하지 않기 때문이다.</p><h3 id=레플리카셋에서-파드-격리>레플리카셋에서 파드 격리</h3><p>레이블을 변경하면 레플리카셋에서 파드를 제거할 수 있다. 이 방식은 디버깅과 데이터 복구 등을
위해 서비스에서 파드를 제거하는 데 사용할 수 있다. 이 방식으로 제거된 파드는 자동으로 교체된다(
레플리카의 수가 변경되지 않는다고 가정한다).</p><h3 id=레플리카셋의-스케일링>레플리카셋의 스케일링</h3><p>레플리카셋을 손쉽게 스케일 업 또는 다운하는 방법은 단순히 <code>.spec.replicas</code> 필드를 업데이트하면 된다.
레플리카셋 컨트롤러는 일치하는 레이블 셀렉터가 있는 파드가 의도한 수 만큼 가용하고 운영 가능하도록 보장한다.</p><p>스케일 다운할 때, 레플리카셋 컨트롤러는 스케일 다운할 파드의
우선순위를 정하기 위해 다음의 기준으로 가용 파드를 정렬하여 삭제할 파드를 결정한다.</p><ol><li>Pending 상태인 (+ 스케줄링할 수 없는) 파드가 먼저 스케일 다운된다.</li><li><code>controller.kubernetes.io/pod-deletion-cost</code> 어노테이션이 설정되어 있는
파드에 대해서는, 낮은 값을 갖는 파드가 먼저 스케일 다운된다.</li><li>더 많은 레플리카가 있는 노드의 파드가 더 적은 레플리카가 있는 노드의 파드보다 먼저 스케일 다운된다.</li><li>파드 생성 시간이 다르면, 더 최근에 생성된 파드가
이전에 생성된 파드보다 먼저 스케일 다운된다.
(<code>LogarithmicScaleDown</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화되어 있으면 생성 시간이 정수 로그 스케일로 버킷화된다)</li></ol><p>모든 기준에 대해 동등하다면, 스케일 다운할 파드가 임의로 선택된다.</p><h3 id=파드-삭제-비용>파드 삭제 비용</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.22 [beta]</code></div><p><a href=/ko/docs/reference/labels-annotations-taints/#pod-deletion-cost><code>controller.kubernetes.io/pod-deletion-cost</code></a> 어노테이션을 이용하여,
레플리카셋을 스케일 다운할 때 어떤 파드부터 먼저 삭제할지에 대한 우선순위를 설정할 수 있다.</p><p>이 어노테이션은 파드에 설정되어야 하며, [-2147483647, 2147483647] 범위를 갖는다.
이 어노테이션은 하나의 레플리카셋에 있는 다른 파드와의 상대적 삭제 비용을 나타낸다.
삭제 비용이 낮은 파드는 삭제 비용이 높은 파드보다 삭제 우선순위가 높다.</p><p>파드에 대해 이 값을 명시하지 않으면 기본값은 0이다. 음수로도 설정할 수 있다.
유효하지 않은 값은 API 서버가 거부한다.</p><p>이 기능은 베타 상태이며 기본적으로 활성화되어 있다.
kube-apiserver와 kube-controller-manager에 대해 <code>PodDeletionCost</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 이용하여 비활성화할 수 있다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><ul><li>이 기능은 best-effort 방식으로 동작하므로, 파드 삭제 순서를 보장하지는 않는다.</li><li>이 값을 자주 바꾸는 것은 피해야 한다 (예: 메트릭 값에 따라 변경).
apiserver에서 많은 양의 파드 업데이트를 동반하기 때문이다.</li></ul></div><h4 id=사용-예시>사용 예시</h4><p>한 애플리케이션 내의 여러 파드는 각각 사용률이 다를 수 있다. 스케일 다운 시,
애플리케이션은 사용률이 낮은 파드를 먼저 삭제하고 싶을 수 있다. 파드를 자주
업데이트하는 것을 피하기 위해, 애플리케이션은 <code>controller.kubernetes.io/pod-deletion-cost</code> 값을
스케일 다운하기 전에 1회만 업데이트해야 한다 (파드 사용률에 비례하는 값으로 설정).
이 방식은 Spark 애플리케이션의 드라이버 파드처럼 애플리케이션이 스스로 다운스케일링을 수행하는 경우에 유효하다.</p><h3 id=레플리카셋을-horizontal-pod-autoscaler-대상으로-설정>레플리카셋을 Horizontal Pod Autoscaler 대상으로 설정</h3><p>레플리카셋은
<a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscalers (HPA)</a>의 대상이 될 수 있다.
즉, 레플리카셋은 HPA에 의해 오토스케일될 수 있다.
다음은 이전에 만든 예시에서 만든 레플리카셋을 대상으로 하는 HPA 예시이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/controllers/hpa-rs.yaml download=controllers/hpa-rs.yaml><code>controllers/hpa-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-hpa-rs-yaml")' title="Copy controllers/hpa-rs.yaml to clipboard"></img></div><div class=includecode id=controllers-hpa-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-scaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이 매니페스트를 <code>hpa-rs.yaml</code>로 저장한 다음 쿠버네티스
클러스터에 적용하면 CPU 사용량에 따라 파드가 복제되는
오토스케일 레플리카셋 HPA가 생성된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/hpa-rs.yaml
</span></span></code></pre></div><p>또는 <code>kubectl autoscale</code> 커맨드을 사용해서 동일한 작업을 할 수 있다.
(그리고 더 쉽다!)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale rs frontend --max<span style=color:#666>=</span><span style=color:#666>10</span> --min<span style=color:#666>=</span><span style=color:#666>3</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span>
</span></span></code></pre></div><h2 id=레플리카셋의-대안>레플리카셋의 대안</h2><h3 id=디플로이먼트-권장>디플로이먼트(권장)</h3><p><a href=/ko/docs/concepts/workloads/controllers/deployment/><code>디플로이먼트</code></a>는 레플리카셋을 소유하거나 업데이트를 하고,
파드의 선언적인 업데이트와 서버측 롤링 업데이트를 할 수 있는 오브젝트이다.
레플리카셋은 단독으로 사용할 수 있지만, 오늘날에는 주로 디플로이먼트로 파드의 생성과 삭제 그리고 업데이트를 오케스트레이션하는 메커니즘으로 사용한다.
디플로이먼트를 이용해서 배포할 때 생성되는 레플리카셋을 관리하는 것에 대해 걱정하지 않아도 된다.
디플로이먼트는 레플리카셋을 소유하거나 관리한다.
따라서 레플리카셋을 원한다면 디플로이먼트를 사용하는 것을 권장한다.</p><h3 id=기본-파드>기본 파드</h3><p>사용자가 직접 파드를 생성하는 경우와는 다르게, 레플리카셋은 노드 장애 또는
노드의 커널 업그레이드와 같은 관리 목적의 중단 등 어떤 이유로든
종료되거나 삭제된 파드를 교체한다. 이런 이유로 애플리케이션이 단일 파드가 필요하더라도
레플리카셋을 이용하는 것을 권장한다. 레플리카셋을 프로세스 관리자와 비교해서 생각해본다면,
레플리카셋은 단일 노드에서의 개별 프로세스들이 아닌 다수의 노드에 걸쳐있는 다수의 파드를 관리하는 것이다.
레플리카셋은 로컬 컨테이너의 재시작을 노드에 있는 Kubelet과 같은 에이전트에게 위임한다.</p><h3 id=잡>잡</h3><p>스스로 종료되는 것이 예상되는 파드의 경우에는 레플리카셋 대신
<a href=/ko/docs/concepts/workloads/controllers/job/><code>잡</code></a>을 이용한다 (즉, 배치 잡).</p><h3 id=데몬셋>데몬셋</h3><p>머신 모니터링 또는 머신 로깅과 같은 머신-레벨의 기능을 제공하는 파드를 위해서는 레플리카셋 대신
<a href=/ko/docs/concepts/workloads/controllers/daemonset/><code>데몬셋</code></a>을 사용한다.
이러한 파드의 수명은 머신의 수명과 연관되어 있고, 머신에서 다른 파드가 시작하기 전에 실행되어야 하며,
머신의 재부팅/종료가 준비되었을 때, 해당 파드를 종료하는 것이 안전하다.</p><h3 id=레플리케이션-컨트롤러>레플리케이션 컨트롤러</h3><p>레플리카셋은 <a href=/ko/docs/concepts/workloads/controllers/replicationcontroller/>레플리케이션 컨트롤러</a>를 계승하였다.
이 두 개의 용도는 동일하고, 유사하게 동작하며, 레플리케이션 컨트롤러가 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%85%80%EB%A0%89%ED%84%B0>레이블 사용자 가이드</a>에
설명된 설정-기반의 셀렉터의 요건을 지원하지 않는다는 점을 제외하면 유사하다.
따라서 레플리카셋이 레플리케이션 컨트롤러보다 선호된다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/workloads/pods>파드</a>에 대해 배운다.</li><li><a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>에 대해 배운다.</li><li>레플리카셋에 의존해서 동작하는 <a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>디플로이먼트로 스테이트리스 애플리케이션을 실행한다</a>.</li><li><code>ReplicaSet</code>는 쿠버네티스 REST API의 상위-수준 리소스이다.
레플리카셋 API에 대해 이해하기 위해
<a href=/docs/reference/kubernetes-api/workload-resources/replica-set-v1/>ReplicaSet</a>
오브젝트 정의를 읽는다.</li><li><a href=/ko/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>과
이를 사용해서 어떻게 중단 중에 애플리케이션 가용성을 관리할 수 있는지에 대해 읽는다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6d72299952c37ca8cc61b416e5bdbcd4>2.3 - 스테이트풀셋</h1><p>스테이트풀셋은 애플리케이션의 스테이트풀을 관리하는데 사용하는 워크로드 API 오브젝트이다.</p><p><a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 집합의 디플로이먼트와 스케일링을 관리하며, 파드들의 <em>순서 및 고유성을 보장한다</em> .</p><p><a class=glossary-tooltip title='클러스터에서 복제된 애플리케이션을 관리한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=디플로이먼트>디플로이먼트</a>와 유사하게, 스테이트풀셋은 동일한 컨테이너 스펙을 기반으로 둔 파드들을 관리한다. 디플로이먼트와는 다르게, 스테이트풀셋은 각 파드의 독자성을 유지한다. 이 파드들은 동일한 스팩으로 생성되었지만, 서로 교체는 불가능하다. 다시 말해, 각각은 재스케줄링 간에도 지속적으로 유지되는 식별자를 가진다.</p><p>스토리지 볼륨을 사용해서 워크로드에 지속성을 제공하려는 경우, 솔루션의 일부로 스테이트풀셋을 사용할 수 있다. 스테이트풀셋의 개별 파드는 장애에 취약하지만, 퍼시스턴트 파드 식별자는 기존 볼륨을 실패한 볼륨을 대체하는 새 파드에 더 쉽게 일치시킬 수 있다.</p><h2 id=스테이트풀셋-사용>스테이트풀셋 사용</h2><p>스테이트풀셋은 다음 중 하나 또는 이상이 필요한 애플리케이션에
유용하다.</p><ul><li>안정된, 고유한 네트워크 식별자.</li><li>안정된, 지속성을 갖는 스토리지.</li><li>순차적인, 정상 배포(graceful deployment)와 스케일링.</li><li>순차적인, 자동 롤링 업데이트.</li></ul><p>위의 안정은 파드의 (재)스케줄링 전반에 걸친 지속성과 같은 의미이다.
만약 애플리케이션이 안정적인 식별자 또는 순차적인 배포,
삭제 또는 스케일링이 필요하지 않으면, 스테이트리스 레플리카셋(ReplicaSet)을
제공하는 워크로드 오브젝트를 사용해서 애플리케이션을 배포해야 한다.
<a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a> 또는
<a href=/ko/docs/concepts/workloads/controllers/replicaset/>레플리카셋</a>과 같은 컨트롤러가 스테이트리스 요구에 더 적합할 수 있다.</p><h2 id=제한사항>제한사항</h2><ul><li>파드에 지정된 스토리지는 관리자에 의해
<a href=https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/README.md>퍼시스턴트 볼륨 프로비저너</a>
를 기반으로 하는 <code>storage class</code> 를 요청해서 프로비전하거나 사전에 프로비전이 되어야 한다.</li><li>스테이트풀셋을 삭제 또는 스케일 다운해도 스테이트풀셋과 연관된 볼륨이 <em>삭제되지 않는다</em>.
이는 일반적으로 스테이트풀셋과 연관된 모든 리소스를 자동으로 제거하는 것보다 더 중요한
데이터의 안전을 보장하기 위함이다.</li><li>스테이트풀셋은 현재 파드의 네트워크 신원을 책임지고 있는 <a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>
가 필요하다. 사용자가 이 서비스를 생성할 책임이
있다.</li><li>스테이트풀셋은 스테이트풀셋의 삭제 시 파드의 종료에 대해 어떠한 보증을 제공하지
않는다. 스테이트풀셋에서는 파드가 순차적이고 정상적으로 종료(graceful termination)되도록 하려면,
삭제 전 스테이트풀셋의 스케일을 0으로 축소할 수 있다.</li><li><a href=#%EB%A1%A4%EB%A7%81-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>롤링 업데이트</a>와 기본
<a href=#%ED%8C%8C%EB%93%9C-%EB%A7%A4%EB%8B%88%EC%A7%80%EB%A8%BC%ED%8A%B8-%ED%8F%B4%EB%A6%AC%EC%8B%9C>파드 매니지먼트 폴리시</a> (<code>OrderedReady</code>)를
함께 사용시 <a href=#%EA%B0%95%EC%A0%9C-%EB%A1%A4%EB%B0%B1>복구를 위한 수동 개입</a>이
필요한 파손 상태로 빠질 수 있다.</li></ul><h2 id=구성-요소>구성 요소</h2><p>아래의 예시에서는 스테이트풀셋의 구성요소를 보여 준다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.template.metadata.labels 와 일치해야 한다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 기본값은 1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 기본값은 0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.selector.matchLabels 와 일치해야 한다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/nginx-slim:0.8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-storage-class&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>위의 예시에서:</p><ul><li>이름이 nginx라는 헤드리스 서비스는 네트워크 도메인을 컨트롤하는데 사용 한다.</li><li>이름이 web인 스테이트풀셋은 3개의 nginx 컨테이너의 레플리카가 고유의 파드에서 구동될 것이라 지시하는 Spec을 갖는다.</li><li>volumeClaimTemplates은 퍼시스턴트 볼륨 프로비저너에서 프로비전한
<a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트 볼륨</a>을 사용해서
안정적인 스토리지를 제공한다.</li></ul><p>스테이트풀셋 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><h3 id=파드-셀렉터>파드 셀렉터</h3><p>스테이트풀셋의 <code>.spec.selector</code> 필드는
<code>.spec.template.metadata.labels</code> 레이블과 일치하도록 설정해야 한다. 해당되는 파드 셀렉터를 찾지 못하면
스테이트풀셋 생성 과정에서 검증 오류가 발생한다.</p><h3 id=볼륨-클레임-템플릿>볼륨 클레임 템플릿</h3><p><code>.spec.volumeClaimTemplates</code> 를 설정하여, 퍼시스턴트볼륨 프로비저너에 의해 프로비전된
<a href=/ko/docs/concepts/storage/persistent-volumes/>퍼시스턴트볼륨</a>을 이용하는 안정적인 스토리지를
제공할 수 있다.</p><h3 id=minimum-ready-seconds>최소 준비 시간 초</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><p><code>.spec.minReadySeconds</code> 는 파드가 '사용 가능(available)'이라고 간주될 수 있도록 파드의 모든 컨테이너가
문제 없이 실행되고 준비되는 최소 시간(초)을 나타내는 선택적인 필드이다.
<a href=#%EB%A1%A4%EB%A7%81-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>롤링 업데이트</a> 전략을 사용할 때 롤아웃 진행 상황을 확인하는 데 사용된다.
이 필드의 기본값은 0이다(이 경우, 파드가 Ready 상태가 되면 바로 사용 가능하다고 간주된다.)
파드가 언제 사용 가능하다고 간주되는지에 대한 자세한 정보는
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%94%84%EB%A1%9C%EB%B8%8C-probe>컨테이너 프로브(probe)</a>를 참고한다.</p><h2 id=파드-신원>파드 신원</h2><p>스테이트풀셋 파드는 순서, 안정적인 네트워크 신원
그리고 안정적인 스토리지로 구성되는 고유한 신원을 가진다.
신원은 파드가 어떤 노드에 있고, (재)스케줄과도 상관없이 파드에 붙어있다.</p><h3 id=순서-색인>순서 색인</h3><p>N개의 레플리카가 있는 스테이트풀셋은 스테이트풀셋에 있는
각 파드에 0에서 N-1 까지의 정수가 순서대로 할당되며 해당 스테이트풀셋 내에서 고유 하다.</p><h3 id=안정적인-네트워크-신원>안정적인 네트워크 신원</h3><p>스테이트풀셋의 각 파드는 스테이트풀셋의 이름과 파드의 순번에서
호스트 이름을 얻는다. 호스트 이름을 구성하는 패턴은
<code>$(statefulset name)-$(ordinal)</code> 이다. 위의 예시에서 생성된 3개 파드의 이름은
<code>web-0,web-1,web-2</code> 이다.
스테이트풀셋은 스테이트풀셋에 있는 파드의 도메인을 제어하기위해
<a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>를 사용할 수 있다.
이 서비스가 관리하는 도메인은 <code>$(service name).$(namespace).svc.cluster.local</code> 의 형식을 가지며,
여기서 "cluster.local"은 클러스터 도메인이다.
각 파드는 생성되면 <code>$(podname).$(governing service domain)</code> 형식을 가지고
일치되는 DNS 서브도메인을 가지며, 여기서 거버닝 서비스(governing service)는
스테이트풀셋의 <code>serviceName</code> 필드에 의해 정의된다.</p><p>클러스터에서 DNS가 구성된 방식에 따라, 새로 실행된 파드의 DNS 이름을
즉시 찾지 못할 수 있다. 이 동작은 클러스터의 다른 클라이언트가
파드가 생성되기 전에 파드의 호스트 이름에 대한 쿼리를 이미 보낸 경우에 발생할 수 있다.
네거티브 캐싱(DNS에서 일반적)은 이전에 실패한 조회 결과가
파드가 실행된 후에도 적어도 몇 초 동안 기억되고 재사용됨을 의미한다.</p><p>파드를 생성한 후 즉시 파드를 검색해야 하는 경우, 몇 가지 옵션이 있다.</p><ul><li>DNS 조회에 의존하지 않고 쿠버네티스 API를 직접(예를 들어 watch 사용) 쿼리한다.</li><li>쿠버네티스 DNS 공급자의 캐싱 시간(일반적으로 CoreDNS의 컨피그맵을
편집하는 것을 의미하며, 현재 30초 동안 캐시함)을 줄인다.</li></ul><p><a href=#%EC%A0%9C%ED%95%9C%EC%82%AC%ED%95%AD>제한사항</a> 섹션에서 언급한 것처럼 사용자는
파드의 네트워크 신원을 책임지는
<a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>를 생성할 책임이 있다.</p><p>여기 클러스터 도메인, 서비스 이름, 스테이트풀셋 이름을 선택을 하고,
그 선택이 스테이트풀셋 파드의 DNS이름에 어떻게 영향을 주는지에 대한 약간의 예시가 있다.</p><table><thead><tr><th>클러스터 도메인</th><th>서비스 (ns/이름)</th><th>스테이트풀셋 (ns/이름)</th><th>스테이트풀셋 도메인</th><th>파드 DNS</th><th>파드 호스트 이름</th></tr></thead><tbody><tr><td>cluster.local</td><td>default/nginx</td><td>default/web</td><td>nginx.default.svc.cluster.local</td><td>web-{0..N-1}.nginx.default.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>cluster.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.cluster.local</td><td>web-{0..N-1}.nginx.foo.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>kube.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.kube.local</td><td>web-{0..N-1}.nginx.foo.svc.kube.local</td><td>web-{0..N-1}</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 클러스터 도메인이 달리 <a href=/ko/docs/concepts/services-networking/dns-pod-service/>구성된 경우</a>가
아니라면 <code>cluster.local</code>로 설정된다.</div><h3 id=안정된-스토리지>안정된 스토리지</h3><p>스테이트풀셋에 정의된 VolumeClaimTemplate 항목마다, 각 파드는 하나의
PersistentVolumeClaim을 받는다. 위의 nginx 예시에서 각 파드는 <code>my-storage-class</code> 라는 스토리지 클래스와
1 Gib의 프로비전된 스토리지를 가지는 단일 퍼시스턴트 볼륨을 받게 된다. 만약 스토리지 클래스가
명시되지 않은 경우, 기본 스토리지 클래스가 사용된다. 파드가 노드에서 스케줄 혹은 재스케줄이 되면
파드의 <code>volumeMounts</code> 는 퍼시스턴트 볼륨 클레임과 관련된 퍼시스턴트 볼륨이 마운트 된다.
참고로, 파드 퍼시스턴트 볼륨 클레임과 관련된 퍼시스턴트 볼륨은
파드 또는 스테이트풀셋이 삭제되더라도 삭제되지 않는다.
이것은 반드시 수동으로 해야 한다.</p><h3 id=파드-이름-레이블>파드 이름 레이블</h3><p>스테이트풀셋 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러(Controller)>컨트롤러(Controller)</a>
가 파드를 생성할 때 파드 이름으로 <code>statefulset.kubernetes.io/pod-name</code>
레이블이 추가된다. 이 레이블로 스테이트풀셋의 특정 파드에 서비스를
연결할 수 있다.</p><h2 id=디플로이먼트와-스케일링-보증>디플로이먼트와 스케일링 보증</h2><ul><li>N개의 레플리카가 있는 스테이트풀셋이 파드를 배포할 때 연속해서 {0..N-1}의 순서로 생성한다.</li><li>파드가 삭제될 때는 {N-1..0}의 순서인 역순으로 종료된다.</li><li>파드에 스케일링 작업을 적용하기 전에 모든 선행 파드가 Running 및 Ready 상태여야 한다.</li><li>파드가 종료되기 전에 모든 후속 파드가 완전히 종료 되어야 한다.</li></ul><p>스테이트풀셋은 <code>pod.Spec.TerminationGracePeriodSeconds</code> 을 0으로 명시해서는 안된다. 이 방법은
안전하지 않으며, 사용하지 않기를 강권한다. 자세한 설명은
<a href=/ko/docs/tasks/run-application/force-delete-stateful-set-pod/>스테이트풀셋 파드 강제 삭제</a>를 참고한다.</p><p>위의 nginx 예시가 생성될 때 web-0, web-1, web-2 순서로 3개 파드가
배포된다. web-1은 web-0이
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/>Running 및 Ready</a> 상태가 되기 전에는 배포되지 않으며,
web-2 도 web-1이 Running 및 Ready 상태가 되기 전에는 배포되지 않는다. 만약 web-1이 Running 및 Ready 상태가 된 이후,
web-2가 시작되기 전에 web-0이 실패하게 된다면, web-2는 web-0이 성공적으로 재시작이되고,
Running 및 Ready 상태가 되기 전까지 시작되지 않는다.</p><p>만약 사용자가 배포된 예제의 스테이트풀셋을 <code>replicas=1</code> 으로 패치해서
스케일한 경우 web-2가 먼저 종료된다. web-1은 web-2가 완전히 종료 및 삭제되기
전까지 정지되지 않는다. 만약 web-2의 종료 및 완전히 중지되고, web-1이 종료되기 전에
web-0이 실패할 경우 web-1은 web-0이 Running 및 Ready 상태가
되기 전까지 종료되지 않는다.</p><h3 id=파드-관리-정책>파드 관리 정책</h3><p>스테이트풀셋의 <code>.spec.podManagementPolicy</code> 필드를 통해
고유성 및 신원 보증을 유지하면서 순차 보증을 완화한다.</p><h4 id=orderedready-파드-관리>OrderedReady 파드 관리</h4><p><code>OrderedReady</code> 파드 관리는 스테이트풀셋의 기본이다.
이것은 <a href=#%EB%94%94%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%A8%BC%ED%8A%B8%EC%99%80-%EC%8A%A4%EC%BC%80%EC%9D%BC-%EB%B3%B4%EC%A6%9D>위에서</a> 설명한 행위를 구현한다.</p><h4 id=parallel-파드-관리>Parallel 파드 관리</h4><p><code>Parallel</code> 파드 관리는 스테이트풀셋 컨트롤러에게 모든 파드를
병렬로 실행 또는 종료하게 한다. 그리고 다른 파드의 실행이나
종료에 앞서 파드가 Running 및 Ready 상태가 되거나 완전히 종료되기를 기다리지 않는다.
이 옵션은 오직 스케일링 작업에 대한 동작에만 영향을 미친다. 업데이트는 영향을
받지 않는다.</p><h2 id=업데이트-전략>업데이트 전략</h2><p>스테이트풀셋의 <code>.spec.updateStrategy</code> 필드는 스테이트풀셋의
파드에 대한 컨테이너, 레이블, 리소스의 요청/제한 그리고 주석에 대한 자동화된 롤링 업데이트를
구성하거나 비활성화할 수 있다. 두 가지 가능한 전략이 있다.</p><dl><dt><code>OnDelete</code>(삭제시)</dt><dd>스테이트풀셋의 <code>.spec.updateStrategy.type</code> 은 <code>OnDelete</code> 를 설정하며,
스테이트풀셋 컨트롤러는 스테이트풀셋의 파드를 자동으로 업데이트하지 않는다.
사용자는 컨트롤러가 스테이트풀셋의
<code>.spec.template</code>를 반영하는 수정된 새로운 파드를 생성하도록 수동으로 파드를 삭제해야 한다.</dd><dt><code>RollingUpdate</code>(롤링 업데이트)</dt><dd><code>RollingUpdate</code> 업데이트 전략은 스테이트풀셋의 파드에 대한 롤링 업데이트를
구현한다. 기본 업데이트 전략이다.</dd></dl><h2 id=롤링-업데이트>롤링 업데이트</h2><p>스테이트풀셋에 <code>롤링 업데이트</code> 가 <code>.spec.updateStrategy.type</code> 에 설정되면
스테이트풀셋 컨트롤러는 스테이트풀셋의 각 파드를 삭제 및 재생성한다. 이 과정에서 똑같이
순차적으로 파드가 종료되고(가장 큰 순서 색인에서부터에서 작은 순서 색인쪽으로),
각 파드의 업데이트는 한 번에 하나씩 한다.</p><p>쿠버네티스 컨트롤 플레인은 이전 버전을 업데이트 하기 전에, 업데이트된 파드가 실행 및 준비될 때까지 기다린다.
<code>.spec.minReadySeconds</code>(<a href=#minimum-ready-seconds>최소 준비 시간 초</a> 참조)를
설정한 경우,
컨트롤 플레인은 파드가 준비 상태로 전환된 후 해당 시간을 추가로 기다린 후 이동한다.</p><h3 id=partitions>파티션 롤링 업데이트</h3><p><code>롤링 업데이트</code> 의 업데이트 전략은 <code>.spec.updateStrategy.rollingUpdate.partition</code>
를 명시해서 파티션 할 수 있다. 만약 파티션을 명시하면 스테이트풀셋의 <code>.spec.template</code> 가
업데이트 될 때 부여된 수가 파티션보다 크거나 같은 모든 파드가 업데이트 된다.
파티션보다 작은 수를 가진 모든 파드는 업데이트 되지 않으며,
삭제 된 경우라도 이전 버전에서 재생성된다.
만약 스테이트풀셋의 <code>.spec.updateStrategy.rollingUpdate.partition</code> 이
<code>.spec.replicas</code> 보다 큰 경우 <code>.spec.template</code> 의 업데이트는 해당 파드에 전달하지 않는다.
대부분의 케이스는 파티션을 사용할 필요가 없지만 업데이트를 준비하거나,
카나리의 롤 아웃 또는 단계적인 롤 아웃을 행하려는 경우에는 유용하다.</p><h3 id=최대-사용-불가능-unavailable-파드-수>최대 사용 불가능(unavailable) 파드 수</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [alpha]</code></div><p><code>.spec.updateStrategy.rollingUpdate.maxUnavailable</code> 필드를 명시하여,
업데이트 과정에서 사용 불가능(unavailable) 파드를 최대 몇 개까지 허용할 것인지를 조절할 수 있다.
값은 절대값(예: <code>5</code>) 또는 목표 파드 퍼센티지(예: <code>10%</code>)로 명시할 수 있다.
절대값은 퍼센티지 값으로 계산한 뒤 올림하여 얻는다.
이 필드는 0일 수 없다. 기본값은 1이다.</p><p>이 필드는 <code>0</code> 에서 <code>replicas - 1</code> 사이 범위에 있는 모든 파드에 적용된다.
이 범위 내에 사용 불가능한 파드가 있으면,
<code>maxUnavailable</code>로 집계된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>maxUnavailable</code> 필드는 현재 알파 단계이며
<code>MaxUnavailableStatefulSet</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 활성화된 API 서버에서만
동작한다.</div><h3 id=강제-롤백>강제 롤백</h3><p>기본 <a href=#%ED%8C%8C%EB%93%9C-%EA%B4%80%EB%A6%AC-%EC%A0%95%EC%B1%85>파드 관리 정책</a> (<code>OrderedReady</code>)과
함께 <a href=#%EB%A1%A4%EB%A7%81-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>롤링 업데이트</a>를 사용할 경우
직접 수동으로 복구를 해야하는 고장난 상태가 될 수 있다.</p><p>만약 파드 템플릿을 Running 및 Ready 상태가 되지 않는 구성으로 업데이트하는
경우(예시: 잘못된 바이너리 또는 애플리케이션-레벨 구성 오류로 인한)
스테이트풀셋은 롤아웃을 중지하고 기다린다.</p><p>이 상태에서는 파드 템플릿을 올바른 구성으로 되돌리는 것으로 충분하지 않다.
<a href=https://github.com/kubernetes/kubernetes/issues/67250>알려진 이슈</a>로
인해 스테이트풀셋은 손상된 파드가 준비(절대 되지 않음)될 때까지 기다리며
작동하는 구성으로 되돌아가는 시도를 하기
전까지 기다린다.</p><p>템플릿을 되돌린 이후에는 스테이트풀셋이 이미 잘못된 구성으로
실행하려고 시도한 모든 파드를 삭제해야 한다.
그러면 스테이트풀셋은 되돌린 템플릿을 사용해서 파드를 다시 생성하기 시작한다.</p><h2 id=퍼시스턴트볼륨클레임-유보>퍼시스턴트볼륨클레임 유보</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [alpha]</code></div><p>선택적 필드인 <code>.spec.persistentVolumeClaimRetentionPolicy</code> 는
스테이트풀셋의 생애주기동안 PVC를 삭제할 것인지,
삭제한다면 어떻게 삭제하는지를 관리한다.
이 필드를 사용하려면 <code>StatefulSetAutoDeletePVC</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.
활성화 시, 각 스테이트풀셋에 대해 두 가지 정책을 설정할 수 있다.</p><dl><dt><code>whenDeleted</code></dt><dd>스테이트풀셋이 삭제될 때 적용될 볼륨 유보 동작을 설정한다.</dd><dt><code>whenScaled</code></dt><dd>스테이트풀셋의 레플리카 수가 줄어들 때, 예를 들면 스테이트풀셋을 스케일 다운할 때
적용될 볼륨 유보 동작을 설정한다.</dd></dl><p>설정 가능한 각 정책에 대해, 그 값을 <code>Delete</code> 또는 <code>Retain</code> 으로 설정할 수 있다.</p><dl><dt><code>Delete</code></dt><dd><code>volumeClaimTemplate</code> 스테이트풀셋으로부터 생성된 PVC는 정책에 영향을 받는 각 파드에 대해 삭제된다.
<code>whenDeleted</code> 가 이 값으로 설정되어 있으면
<code>volumeClaimTemplate</code> 으로부터 생성된 모든 PVC는 파드가 삭제된 뒤에 삭제된다.
<code>whenScaled</code> 가 이 값으로 설정되어 있으면
스케일 다운된 파드 레플리카가 삭제된 뒤, 삭제된 파드에 해당되는 PVC만 삭제된다.</dd><dt><code>Retain</code> (기본값)</dt><dd>파드가 삭제되어도 <code>volumeClaimTemplate</code> 으로부터 생성된 PVC는 영향을 받지 않는다.
이는 이 신기능이 도입되기 전의 기본 동작이다.</dd></dl><p>이러한 정책은 파드의 삭제가 스테이트풀셋 삭제 또는 스케일 다운으로 인한 것일 때<strong>에만</strong> 적용됨에 유의한다.
예를 들어, 스테이트풀셋의 파드가 노드 실패로 인해 실패했고,
컨트롤 플레인이 대체 파드를 생성했다면, 스테이트풀셋은 기존 PVC를 유지한다.
기존 볼륨은 영향을 받지 않으며,
새 파드가 실행될 노드에 클러스터가 볼륨을 연결(attach)한다.</p><p>정책의 기본값은 <code>Retain</code> 이며, 이는 이 신기능이 도입되기 전의 스테이트풀셋 기본 동작이다.</p><p>다음은 정책 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeClaimRetentionPolicy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenDeleted</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenScaled</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>스테이트풀셋 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는 자신이 소유한 PVC에
<a href=/docs/concepts/overview/working-with-objects/owners-dependents/#owner-references-in-object-specifications>소유자 정보(reference)</a>를
추가하며, 파드가 종료된 이후에는 <a class=glossary-tooltip title='쿠버네티스가 클러스터 자원을 정리하기 위해 사용하는 다양한 방법을 종합한 용어이다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/garbage-collection/ target=_blank aria-label='가비지 콜렉터'>가비지 콜렉터</a>가 이 정보를 삭제한다.
이로 인해 PVC가 삭제되기 전에
(그리고 유보 정책에 따라, 매칭되는 기반 PV와 볼륨이 삭제되기 전에)
파드가 모든 볼륨을 깨끗하게 언마운트할 수 있다.
<code>whenDeleted</code> 정책을 <code>Delete</code> 로 설정하면,
해당 스테이트풀셋에 연결된 모든 PVC에 스테이트풀셋 인스턴스의 소유자 정보가 기록된다.</p><p><code>whenScaled</code> 정책은 파드가 스케일 다운되었을 때에만 PVC를 삭제하며,
파드가 다른 원인으로 삭제되면 PVC를 삭제하지 않는다.
조정 상황 발생 시, 스테이트풀셋 컨트롤러는 목표 레플리카 수와 클러스터 상의 실제 파드 수를 비교한다.
레플리카 카운트보다 큰 ID를 갖는 스테이트풀셋 파드는 부적격 판정을 받으며 삭제 대상으로 표시된다.
<code>whenScaled</code> 정책이 <code>Delete</code> 이면, 부적격 파드는 삭제되기 전에,
연결된 스테이트풀셋 템플릿 PVC의 소유자로 지정된다.
이로 인해, 부적격 파드가 종료된 이후에만 PVC가 가비지 콜렉트된다.</p><p>이는 곧 만약 컨트롤러가 강제 종료되어 재시작되면,
파드의 소유자 정보가 정책에 적합하게 업데이트되기 전에는 어떤 파드도 삭제되지 않을 것임을 의미한다.
만약 컨트롤러가 다운된 동안 부적격 파드가 강제로 삭제되면,
컨트롤러가 강제 종료된 시점에 따라 소유자 정보가 설정되었을 수도 있고 설정되지 않았을 수도 있다.
소유자 정보가 업데이트되기까지 몇 번의 조정 절차가 필요할 수 있으며,
따라서 일부 부적격 파드는 소유자 정보 설정을 완료하고 나머지는 그러지 못했을 수 있다.
이러한 이유로, 컨트롤러가 다시 켜져서 파드를 종료하기 전에
소유자 정보를 검증할 때까지 기다리는 것을 추천한다.
이것이 불가능하다면, 관리자는 PVC의 소유자 정보를 확인하여 파드가 강제 삭제되었을 때 해당되는 오브젝트가 삭제되도록 해야 한다.</p><h3 id=레플리카>레플리카</h3><p><code>.spec.replicas</code> 은 필요한 파드의 수를 지정하는 선택적 필드이다. 기본값은 1이다.</p><p>예를 들어 <code>kubectl scale deployment deployment --replicas=X</code> 명령으로
디플로이먼트의 크기를 수동으로 조정한 뒤,
매니페스트를 이용하여 디플로이먼트를 업데이트하면(예: <code>kubectl apply -f deployment.yaml</code> 실행),
수동으로 설정했던 디플로이먼트의 크기가
오버라이드된다.</p><p><a href=/ko/docs/tasks/run-application/horizontal-pod-autoscale/>HorizontalPodAutoscaler</a>(또는 수평 스케일링을 위한 유사 API)가
디플로이먼트 크기를 관리하고 있다면, <code>.spec.replicas</code> 를 설정해서는 안 된다.
대신, 쿠버네티스
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>이
<code>.spec.replicas</code> 필드를 자동으로 관리한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/workloads/pods>파드</a>에 대해 배운다.</li><li>스테이트풀셋을 사용하는 방법을 알아본다.<ul><li><a href=/ko/docs/tutorials/stateful-application/basic-stateful-set/>스테이트풀셋 애플리케이션 배포</a> 예제를 따라한다.</li><li><a href=/ko/docs/tutorials/stateful-application/cassandra/>스테이트풀셋으로 카산드라 배포</a> 예제를 따라한다.</li><li><a href=/docs/tasks/run-application/run-replicated-stateful-application/>복제된 스테이트풀셋 애플리케이션 구동하기</a> 예제를 따라한다.</li><li><a href=/ko/docs/tasks/run-application/scale-stateful-set/>스테이트풀셋 확장하기</a>에 대해 배운다.</li><li><a href=/ko/docs/tasks/run-application/delete-stateful-set/>스테이트풀셋을 삭제하면</a> 어떤 일이 수반되는지를 배운다.</li><li><a href=/ko/docs/tasks/configure-pod-container/configure-volume-storage/>스토리지의 볼륨을 사용하는 파드 구성</a>을 하는 방법을 배운다.</li><li><a href=/ko/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>스토리지로 퍼시스턴트볼륨(PersistentVolume)을 사용하도록 파드 설정</a>하는 방법을 배운다.</li></ul></li><li><code>StatefulSet</code>은 쿠버네티스 REST API의 상위-수준 리소스이다.
스테이트풀셋 API에 대해 이해하기 위해
<a href=/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/>StatefulSet</a> 오브젝트 정의를 읽는다.</li><li><a href=/ko/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>과
이를 사용해서 어떻게 중단 중에 애플리케이션 가용성을 관리할 수 있는지에 대해 읽는다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-41600eb8b6631c88848156f381e9d588>2.4 - 데몬셋</h1><p><em>데몬셋</em> 은 모든(또는 일부) 노드가 파드의 사본을 실행하도록 한다. 노드가 클러스터에 추가되면
파드도 추가된다. 노드가 클러스터에서 제거되면 해당 파드는 가비지(garbage)로
수집된다. 데몬셋을 삭제하면 데몬셋이 생성한 파드들이 정리된다.</p><p>데몬셋의 일부 대표적인 용도는 다음과 같다.</p><ul><li>모든 노드에서 클러스터 스토리지 데몬 실행</li><li>모든 노드에서 로그 수집 데몬 실행</li><li>모든 노드에서 노드 모니터링 데몬 실행</li></ul><p>단순한 케이스에서는, 각 데몬 유형의 처리를 위해서 모든 노드를 커버하는 하나의 데몬셋이 사용된다.
더 복잡한 구성에서는 단일 유형의 데몬에 여러 데몬셋을 사용할 수 있지만,
각기 다른 하드웨어 유형에 따라 서로 다른 플래그, 메모리, CPU 요구가 달라진다.</p><h2 id=데몬셋-사양-작성>데몬셋 사양 작성</h2><h3 id=데몬셋-생성>데몬셋 생성</h3><p>YAML 파일에 데몬셋 명세를 작성할 수 있다. 예를 들어 아래 <code>daemonset.yaml</code> 파일은
fluentd-elasticsearch 도커 이미지를 실행하는 데몬셋을 설명한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/controllers/daemonset.yaml download=controllers/daemonset.yaml><code>controllers/daemonset.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-daemonset-yaml")' title="Copy controllers/daemonset.yaml to clipboard"></img></div><div class=includecode id=controllers-daemonset-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>fluentd-logging<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 이 톨러레이션(toleration)은 데몬셋이 컨트롤 플레인 노드에서 실행될 수 있도록 만든다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 컨트롤 플레인 노드가 이 파드를 실행해서는 안 되는 경우, 이 톨러레이션을 제거한다.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/control-plane<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>quay.io/fluentd_elasticsearch/fluentd:v2.5.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>YAML 파일을 기반으로 데몬셋을 생성한다.</p><pre tabindex=0><code>kubectl apply -f https://k8s.io/examples/controllers/daemonset.yaml
</code></pre><h3 id=필수-필드>필수 필드</h3><p>다른 모든 쿠버네티스 설정과 마찬가지로 데몬셋에는 <code>apiVersion</code>, <code>kind</code> 그리고 <code>metadata</code> 필드가 필요하다.
일반적인 설정파일 작업에 대한 정보는
<a href=/ko/docs/tasks/run-application/run-stateless-application-deployment/>스테이트리스 애플리케이션 실행하기</a>와
<a href=/ko/docs/concepts/overview/working-with-objects/object-management/>kubectl을 사용한 오브젝트 관리</a>를 참고한다.</p><p>데몬셋 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><p>데몬셋에는
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code></a>
섹션도 필요하다.</p><h3 id=파드-템플릿>파드 템플릿</h3><p><code>.spec.template</code> 는 <code>.spec</code> 의 필수 필드 중 하나이다.</p><p><code>.spec.template</code> 는 <a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>파드 템플릿</a>이다.
이것은 중첩되어 있다는 점과 <code>apiVersion</code> 또는 <code>kind</code> 를 가지지 않는 것을 제외하면
<a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>와 정확히 같은 스키마를 가진다.</p><p>데몬셋의 파드 템플릿에는 파드의 필수 필드 외에도 적절한 레이블이 명시되어야
한다(<a href=#%ED%8C%8C%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0>파드 셀렉터</a>를 본다).</p><p>데몬셋의 파드 템플릿의 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%A0%95%EC%B1%85><code>RestartPolicy</code></a>는 <code>Always</code> 를 가져야 하며,
명시되지 않은 경우 기본으로 <code>Always</code>가 된다.</p><h3 id=파드-셀렉터>파드 셀렉터</h3><p><code>.spec.selector</code> 필드는 파드 셀렉터이다. 이것은
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a>의 <code>.spec.selector</code> 와 같은 동작을 한다.</p><p><code>.spec.template</code>의 레이블과 매치되는
파드 셀렉터를 명시해야 한다.
또한, 한 번 데몬셋이 만들어지면
<code>.spec.selector</code> 는 바꿀 수 없다.
파드 셀렉터를 변형하면 의도치 않게 파드가 고아가 될 수 있으며, 이는 사용자에게 혼란을 주는 것으로 밝혀졌다.</p><p><code>.spec.selector</code> 는 다음 2개의 필드로 구성된 오브젝트이다.</p><ul><li><code>matchLabels</code> - <a href=/ko/docs/concepts/workloads/controllers/replicationcontroller/>레플리케이션 컨트롤러</a>의
<code>.spec.selector</code> 와 동일하게 작동한다.</li><li><code>matchExpressions</code> - 키, 값 목록 그리고 키 및 값에 관련된 연산자를
명시해서 보다 정교한 셀렉터를 만들 수 있다.</li></ul><p>2개의 필드가 명시되면 두 필드를 모두 만족하는 것(ANDed)이 결과가 된다.</p><p><code>.spec.selector</code> 는 <code>.spec.template.metadata.labels</code> 와 일치해야 한다.
이 둘이 서로 일치하지 않는 구성은 API에 의해 거부된다.</p><h3 id=오직-일부-노드에서만-파드-실행>오직 일부 노드에서만 파드 실행</h3><p>만약 <code>.spec.template.spec.nodeSelector</code> 를 명시하면 데몬셋 컨트롤러는
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EB%85%B8%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0-nodeselector>노드 셀렉터</a>와
일치하는 노드에 파드를 생성한다.
마찬가지로 <code>.spec.template.spec.affinity</code> 를 명시하면
데몬셋 컨트롤러는 <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EB%85%B8%EB%93%9C-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0>노드 어피니티</a>와 일치하는 노드에 파드를 생성한다.
만약 둘 중 하나를 명시하지 않으면 데몬셋 컨트롤러는 모든 노드에서 파드를 생성한다.</p><h2 id=데몬-파드가-스케줄-되는-방법>데몬 파드가 스케줄 되는 방법</h2><h3 id=기본-스케줄러로-스케줄>기본 스케줄러로 스케줄</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes 1.17 [stable]</code></div><p>데몬셋은 자격이 되는 모든 노드에서 파드 사본이 실행하도록 보장한다. 일반적으로
쿠버네티스 스케줄러에 의해 파드가 실행되는 노드가 선택된다. 그러나
데몬셋 파드는 데몬셋 컨트롤러에 의해 생성되고 스케줄된다.
이에 대한 이슈를 소개한다.</p><ul><li>파드 동작의 불일치: 스케줄 되기 위해서 대기 중인 일반 파드는 <code>Pending</code> 상태로 생성된다.
그러나 데몬셋 파드는 <code>Pending</code> 상태로 생성되지 않는다.
이것은 사용자에게 혼란을 준다.</li><li><a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>파드 선점</a>은
기본 스케줄러에서 처리한다. 선점이 활성화되면 데몬셋 컨트롤러는
파드 우선순위와 선점을 고려하지 않고 스케줄 한다.</li></ul><p><code>ScheduleDaemonSetPods</code> 로 데몬셋 파드에 <code>.spec.nodeName</code> 용어 대신
<code>NodeAffinity</code> 용어를 추가해서 데몬셋 컨트롤러 대신 기본
스케줄러를 사용해서 데몬셋을 스케줄할 수 있다. 이후에 기본
스케줄러를 사용해서 대상 호스트에 파드를 바인딩한다. 만약 데몬셋 파드에
이미 노드 선호도가 존재한다면 교체한다(대상 호스트를 선택하기 전에
원래 노드의 어피니티가 고려된다). 데몬셋 컨트롤러는
데몬셋 파드를 만들거나 수정할 때만 이런 작업을 수행하며,
데몬셋의 <code>spec.template</code> 은 변경되지 않는다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>matchFields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- target-host-name<span style=color:#bbb>
</span></span></span></code></pre></div><p>또한, 데몬셋 파드에 <code>node.kubernetes.io/unschedulable:NoSchedule</code> 이 톨러레이션(toleration)으로
자동으로 추가된다. 기본 스케줄러는 데몬셋 파드를
스케줄링시 <code>unschedulable</code> 노드를 무시한다.</p><h3 id=테인트-taints-와-톨러레이션-tolerations>테인트(taints)와 톨러레이션(tolerations)</h3><p>데몬 파드는
<a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트와 톨러레이션</a>을 존중하지만,
다음과 같이 관련 기능에 따라 자동적으로 데몬셋 파드에
톨러레이션을 추가한다.</p><table><thead><tr><th>톨러레이션 키</th><th>영향</th><th>버전</th><th>설명</th></tr></thead><tbody><tr><td><code>node.kubernetes.io/not-ready</code></td><td>NoExecute</td><td>1.13+</td><td>네트워크 파티션과 같은 노드 문제가 발생해도 데몬셋 파드는 축출되지 않는다.</td></tr><tr><td><code>node.kubernetes.io/unreachable</code></td><td>NoExecute</td><td>1.13+</td><td>네트워크 파티션과 같은 노드 문제가 발생해도 데몬셋 파드는 축출되지 않는다.</td></tr><tr><td><code>node.kubernetes.io/disk-pressure</code></td><td>NoSchedule</td><td>1.8+</td><td>데몬셋 파드는 기본 스케줄러에서 디스크-압박(disk-pressure) 속성을 허용한다.</td></tr><tr><td><code>node.kubernetes.io/memory-pressure</code></td><td>NoSchedule</td><td>1.8+</td><td>데몬셋 파드는 기본 스케줄러에서 메모리-압박(memory-pressure) 속성을 허용한다.</td></tr><tr><td><code>node.kubernetes.io/unschedulable</code></td><td>NoSchedule</td><td>1.12+</td><td>데몬셋 파드는 기본 스케줄러의 스케줄할 수 없는(unschedulable) 속성을 극복한다.</td></tr><tr><td><code>node.kubernetes.io/network-unavailable</code></td><td>NoSchedule</td><td>1.12+</td><td>호스트 네트워크를 사용하는 데몬셋 파드는 기본 스케줄러에 의해 이용할 수 없는 네트워크(network-unavailable) 속성을 극복한다.</td></tr></tbody></table><h2 id=데몬-파드와-통신>데몬 파드와 통신</h2><p>데몬셋의 파드와 통신할 수 있는 몇 가지 패턴은 다음과 같다.</p><ul><li><strong>푸시(Push)</strong>: 데몬셋의 파드는 통계 데이터베이스와 같은 다른 서비스로 업데이트를 보내도록
구성되어 있다. 그들은 클라이언트들을 가지지 않는다.</li><li><strong>노드IP와 알려진 포트</strong>: 데몬셋의 파드는 <code>호스트 포트</code>를 사용할 수 있으며,
노드IP를 통해 파드에 접근할 수 있다.
클라이언트는 노드IP를 어떻게든지 알고 있으며, 관례에 따라 포트를 알고 있다.</li><li><strong>DNS</strong>: 동일한 파드 셀렉터로 <a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스 서비스</a>를 만들고,
그 다음에 <code>엔드포인트</code> 리소스를 사용해서 데몬셋을 찾거나
DNS에서 여러 A레코드를 검색한다.</li><li><strong>서비스</strong>: 동일한 파드 셀렉터로 서비스를 생성하고, 서비스를 사용해서
임의의 노드의 데몬에 도달한다(특정 노드에 도달할 방법이 없다).</li></ul><h2 id=데몬셋-업데이트>데몬셋 업데이트</h2><p>만약 노드 레이블이 변경되면, 데몬셋은 새로 일치하는 노드에 즉시 파드를 추가하고, 새로
일치하지 않는 노드에서 파드를 삭제한다.</p><p>사용자는 데몬셋이 생성하는 파드를 수정할 수 있다. 그러나 파드는 모든
필드가 업데이트 되는 것을 허용하지 않는다. 또한 데몬셋 컨트롤러는
다음에 노드(동일한 이름으로)가 생성될 때 원본 템플릿을 사용한다.</p><p>사용자는 데몬셋을 삭제할 수 있다. 만약 <code>kubectl</code> 에서 <code>--cascade=orphan</code> 를 명시하면
파드는 노드에 남게 된다. 이후에 동일한 셀렉터로 새 데몬셋을 생성하면,
새 데몬셋은 기존 파드를 채택한다. 만약 파드를 교체해야 하는 경우 데몬셋은
<code>updateStrategy</code> 에 따라 파드를 교체한다.</p><p>사용자는 데몬셋에서 <a href=/ko/docs/tasks/manage-daemon/update-daemon-set/>롤링 업데이트를 수행</a>할 수 있다.</p><h2 id=데몬셋의-대안>데몬셋의 대안</h2><h3 id=초기화-스크립트>초기화 스크립트</h3><p>데몬 프로세스를 직접 노드에서 시작해서 실행하는 것도 당연히 가능하다.
(예: <code>init</code>, <code>upstartd</code> 또는 <code>systemd</code> 를 사용). 이 방법도 문제는 전혀 없다. 그러나 데몬셋을 통해 데몬
프로세스를 실행하면 몇 가지 이점 있다.</p><ul><li>애플리케이션과 동일한 방법으로 데몬을 모니터링하고 로그 관리를 할 수 있다.</li><li>데몬 및 애플리케이션과 동일한 구성 언어와 도구(예: 파드 템플릿, <code>kubectl</code>).</li><li>리소스 제한이 있는 컨테이너에서 데몬을 실행하면 앱 컨테이너에서
데몬간의 격리를 증가시킨다. 그러나 이것은 파드가 아닌 컨테이너에서 데몬을 실행해서 이루어진다
(예: 도커에서 직접적으로 시작).</li></ul><h3 id=베어-bare-파드>베어(Bare) 파드</h3><p>직접적으로 파드를 실행할 특정한 노드를 명시해서 파드를 생성할 수 있다. 그러나
데몬셋은 노드 장애 또는 커널 업그레이드와 같이 변경사항이 많은 노드 유지보수의 경우를 비롯하여
어떠한 이유로든 삭제되거나 종료된 파드를 교체한다. 따라서 개별 파드를
생성하는 것보다는 데몬 셋을 사용해야 한다.</p><h3 id=static-pods>스태틱(static) 파드</h3><p>Kubelet이 감시하는 특정 디렉터리에 파일을 작성하는 파드를 생성할 수 있다. 이것을
<a href=/ko/docs/tasks/configure-pod-container/static-pod/>스태틱 파드</a>라고 부른다.
데몬셋과는 다르게 스태틱 파드는 kubectl
또는 다른 쿠버네티스 API 클라이언트로 관리할 수 없다. 스태틱 파드는 API 서버에 의존하지
않기 때문에 클러스터 부트스트랩(bootstraping)하는 경우에 유용하다. 또한 스태틱 파드는 향후에 사용 중단될 수 있다.</p><h3 id=디플로이먼트>디플로이먼트</h3><p>데몬셋은 파드를 생성한다는 점에서 <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>와 유사하고,
해당 파드에서는 프로세스가 종료되지 않을 것으로
예상한다(예: 웹 서버).</p><p>파드가 실행되는 호스트를 정확하게 제어하는 것보다 레플리카의 수를 스케일링 업 및 다운 하고,
업데이트 롤아웃이 더 중요한 프런트 엔드와 같은 것은 스테이트리스 서비스의
디플로이먼트를 사용한다. 데몬셋이 특정 노드에서 다른 파드가 올바르게 실행되도록 하는 노드 수준 기능을 제공한다면,
파드 사본이 항상 모든 호스트 또는 특정 호스트에서 실행되는 것이 중요한 경우에 데몬셋을 사용한다.</p><p>예를 들어, <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>네트워크 플러그인</a>은 데몬셋으로 실행되는 컴포넌트를 포함할 수 있다. 데몬셋 컴포넌트는 작동 중인 노드가 정상적인 클러스터 네트워킹을 할 수 있도록 한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/workloads/pods/>파드</a>에 대해 배운다.<ul><li>쿠버네티스 <a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>
컴포넌트를 기동하는데 유용한
<a href=#static-pods>스태틱 파드</a>에 대해 배운다.</li></ul></li><li>데몬셋을 어떻게 사용하는지 알아본다.<ul><li><a href=/ko/docs/tasks/manage-daemon/update-daemon-set/>데몬셋 롤링 업데이트 수행하기</a></li><li><a href=/ko/docs/tasks/manage-daemon/rollback-daemon-set/>데몬셋 롤백하기</a>
(예를 들어, 롤 아웃이 예상대로 동작하지 않은 경우).</li></ul></li><li><a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/>쿠버네티스가 파드를 노드에 할당하는 방법</a>을 이해한다.</li><li>데몬셋으로 구동되곤 하는, <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>디바이스 플러그인</a>과
<a href=/ko/docs/concepts/cluster-administration/addons/>애드온</a>에 대해 배운다.</li><li><code>DaemonSet</code>은 쿠버네티스 REST API에서 상위-수준 리소스이다.
데몬셋 API에 대해 이해하기 위해
<a href=/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/>DaemonSet</a>
오브젝트 정의를 읽는다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-cc7cc3c4907039d9f863162e20bfbbef>2.5 - 잡</h1><p>잡에서 하나 이상의 파드를 생성하고 지정된 수의 파드가 성공적으로 종료될 때까지 계속해서 파드의 실행을 재시도한다.
파드가 성공적으로 완료되면, 성공적으로 완료된 잡을 추적한다. 지정된 수의
성공 완료에 도달하면, 작업(즉, 잡)이 완료된다. 잡을 삭제하면 잡이 생성한
파드가 정리된다. 작업을 일시 중지하면 작업이 다시 재개될 때까지 활성 파드가
삭제된다.</p><p>간단한 사례는 잡 오브젝트를 하나 생성해서 파드 하나를 안정적으로 실행하고 완료하는 것이다.
첫 번째 파드가 실패 또는 삭제된 경우(예로는 노드 하드웨어의 실패 또는
노드 재부팅) 잡 오브젝트는 새로운 파드를 기동시킨다.</p><p>잡을 사용하면 여러 파드를 병렬로 실행할 수도 있다.</p><p>잡을 스케줄에 따라 구동하고 싶은 경우(단일 작업이든, 여러 작업의 병렬 수행이든),
<a href=/ko/docs/concepts/workloads/controllers/cron-jobs/>크론잡(CronJob)</a>을 참고한다.</p><h2 id=예시-잡-실행하기>예시 잡 실행하기</h2><p>다음은 잡 설정 예시이다. 예시는 파이(π)의 2000 자리까지 계산해서 출력한다.
이를 완료하는 데 약 10초가 소요된다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/controllers/job.yaml download=controllers/job.yaml><code>controllers/job.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-job-yaml")' title="Copy controllers/job.yaml to clipboard"></img></div><div class=includecode id=controllers-job-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl:5.34.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backoffLimit</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>이 명령으로 예시를 실행할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/controllers/job.yaml
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><pre tabindex=0><code>job.batch/pi created
</code></pre><p><code>kubectl</code> 을 사용해서 잡 상태를 확인한다.</p><ul class="nav nav-tabs" id=check-status-of-job role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#check-status-of-job-0 role=tab aria-controls=check-status-of-job-0 aria-selected=true>kubectl describe job pi</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#check-status-of-job-1 role=tab aria-controls=check-status-of-job-1>kubectl get job pi -o yaml</a></li></ul><div class=tab-content id=check-status-of-job><div id=check-status-of-job-0 class="tab-pane show active" role=tabpanel aria-labelledby=check-status-of-job-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>Name:           pi
</span></span><span style=display:flex><span>Namespace:      default
</span></span><span style=display:flex><span>Selector:       controller-uid<span style=color:#666>=</span>c9948307-e56d-4b5d-8302-ae2d7b7da67c
</span></span><span style=display:flex><span>Labels:         controller-uid<span style=color:#666>=</span>c9948307-e56d-4b5d-8302-ae2d7b7da67c
</span></span><span style=display:flex><span>                job-name<span style=color:#666>=</span>pi
</span></span><span style=display:flex><span>Annotations:    kubectl.kubernetes.io/last-applied-configuration:
</span></span><span style=display:flex><span>                  <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;batch/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Job&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;annotations&#34;</span>:<span style=color:#666>{}</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;pi&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span><span style=color:#666>}</span>,<span style=color:#b44>&#34;spec&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;backoffLimit&#34;</span>:4,<span style=color:#b44>&#34;template&#34;</span>:...
</span></span><span style=display:flex><span>Parallelism:    <span style=color:#666>1</span>
</span></span><span style=display:flex><span>Completions:    <span style=color:#666>1</span>
</span></span><span style=display:flex><span>Start Time:     Mon, <span style=color:#666>02</span> Dec <span style=color:#666>2019</span> 15:20:11 +0200
</span></span><span style=display:flex><span>Completed At:   Mon, <span style=color:#666>02</span> Dec <span style=color:#666>2019</span> 15:21:16 +0200
</span></span><span style=display:flex><span>Duration:       65s
</span></span><span style=display:flex><span>Pods Statuses:  <span style=color:#666>0</span> Running / <span style=color:#666>1</span> Succeeded / <span style=color:#666>0</span> Failed
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:  controller-uid<span style=color:#666>=</span>c9948307-e56d-4b5d-8302-ae2d7b7da67c
</span></span><span style=display:flex><span>           job-name<span style=color:#666>=</span>pi
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   pi:
</span></span><span style=display:flex><span>    Image:      perl:5.34.0
</span></span><span style=display:flex><span>    Port:       &lt;none&gt;
</span></span><span style=display:flex><span>    Host Port:  &lt;none&gt;
</span></span><span style=display:flex><span>    Command:
</span></span><span style=display:flex><span>      perl
</span></span><span style=display:flex><span>      -Mbignum<span style=color:#666>=</span>bpi
</span></span><span style=display:flex><span>      -wle
</span></span><span style=display:flex><span>      print bpi<span style=color:#666>(</span>2000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    Environment:  &lt;none&gt;
</span></span><span style=display:flex><span>    Mounts:       &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:        &lt;none&gt;
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type    Reason            Age   From            Message
</span></span><span style=display:flex><span>  ----    ------            ----  ----            -------
</span></span><span style=display:flex><span>  Normal  SuccessfulCreate  14m   job-controller  Created pod: pi-5rwd7
</span></span></code></pre></div></div><div id=check-status-of-job-1 class=tab-pane role=tabpanel aria-labelledby=check-status-of-job-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>apiVersion: batch/v1
</span></span><span style=display:flex><span>kind: Job
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    kubectl.kubernetes.io/last-applied-configuration: |
</span></span><span style=display:flex><span>      <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;batch/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Job&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;annotations&#34;</span>:<span style=color:#666>{}</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;pi&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span><span style=color:#666>}</span>,<span style=color:#b44>&#34;spec&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;backoffLimit&#34;</span>:4,<span style=color:#b44>&#34;template&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;spec&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;containers&#34;</span>:<span style=color:#666>[{</span><span style=color:#b44>&#34;command&#34;</span>:<span style=color:#666>[</span><span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#b44>&#34;print bpi(2000)&#34;</span><span style=color:#666>]</span>,<span style=color:#b44>&#34;image&#34;</span>:<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;pi&#34;</span><span style=color:#666>}]</span>,<span style=color:#b44>&#34;restartPolicy&#34;</span>:<span style=color:#b44>&#34;Never&#34;</span><span style=color:#666>}}}}</span>
</span></span><span style=display:flex><span>  creationTimestamp: <span style=color:#b44>&#34;2022-06-15T08:40:15Z&#34;</span>
</span></span><span style=display:flex><span>  generation: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    controller-uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>    job-name: pi
</span></span><span style=display:flex><span>  name: pi
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  resourceVersion: <span style=color:#b44>&#34;987&#34;</span>
</span></span><span style=display:flex><span>  uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  backoffLimit: <span style=color:#666>4</span>
</span></span><span style=display:flex><span>  completionMode: NonIndexed
</span></span><span style=display:flex><span>  completions: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  parallelism: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>      controller-uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>  suspend: <span style=color:#a2f>false</span>
</span></span><span style=display:flex><span>  template:
</span></span><span style=display:flex><span>    metadata:
</span></span><span style=display:flex><span>      creationTimestamp: null
</span></span><span style=display:flex><span>      labels:
</span></span><span style=display:flex><span>        controller-uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>        job-name: pi
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>      containers:
</span></span><span style=display:flex><span>      - command:
</span></span><span style=display:flex><span>        - perl
</span></span><span style=display:flex><span>        - -Mbignum<span style=color:#666>=</span>bpi
</span></span><span style=display:flex><span>        - -wle
</span></span><span style=display:flex><span>        - print bpi<span style=color:#666>(</span>2000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>        image: perl:5.34.0
</span></span><span style=display:flex><span>        imagePullPolicy: Always
</span></span><span style=display:flex><span>        name: pi
</span></span><span style=display:flex><span>        resources: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>        terminationMessagePath: /dev/termination-log
</span></span><span style=display:flex><span>        terminationMessagePolicy: File
</span></span><span style=display:flex><span>      dnsPolicy: ClusterFirst
</span></span><span style=display:flex><span>      restartPolicy: Never
</span></span><span style=display:flex><span>      schedulerName: default-scheduler
</span></span><span style=display:flex><span>      securityContext: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>      terminationGracePeriodSeconds: <span style=color:#666>30</span>
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  active: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  ready: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  startTime: <span style=color:#b44>&#34;2022-06-15T08:40:15Z&#34;</span>
</span></span></code></pre></div></div></div><p><code>kubectl get pods</code> 를 사용해서 잡의 완료된 파드를 본다.</p><p>잡에 속하는 모든 파드를 기계적으로 읽을 수 있는 양식으로 나열하려면, 다음과 같은 명령을 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span>job-name<span style=color:#666>=</span>pi --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><pre tabindex=0><code>pi-5rwd7
</code></pre><p>여기서 셀렉터는 잡의 셀렉터와 동일하다. <code>--output=jsonpath</code> 옵션은 반환된
목록에 있는 각 파드의 이름으로 표현식을 지정한다.</p><p>파드 중 하나를 표준 출력으로 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><pre tabindex=0><code>3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901
</code></pre><h2 id=잡-사양-작성하기>잡 사양 작성하기</h2><p>다른 쿠버네티스의 설정과 마찬가지로 잡에는 <code>apiVersion</code>, <code>kind</code> 그리고 <code>metadata</code> 필드가 필요하다.
잡의 이름은 유효한 <a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.</p><p>잡에는 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> 섹션</a>도 필요하다.</p><h3 id=파드-템플릿>파드 템플릿</h3><p><code>.spec.template</code> 은 <code>.spec</code> 의 유일한 필수 필드이다.</p><p><code>.spec.template</code> 은 <a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>파드 템플릿</a>이다. 이것은 <code>apiVersion</code> 또는 <code>kind</code> 가 없다는 것을 제외한다면 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a>와 정확하게 같은 스키마를 가지고 있다.</p><p>추가로 파드의 필수 필드 외에도 잡의 파드 템플릿은 적절한
레이블(<a href=#%ED%8C%8C%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0>파드 셀렉터</a>를 본다)과 적절한 재시작 정책을 명시해야 한다.</p><p><code>Never</code> 또는 <code>OnFailure</code> 와 같은 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%A0%95%EC%B1%85><code>RestartPolicy</code></a>만 허용된다.</p><h3 id=파드-셀렉터>파드 셀렉터</h3><p><code>.spec.selector</code> 필드는 선택 사항이다. 대부분의 케이스에서 지정해서는 안된다.
<a href=#%EC%9E%90%EC%8B%A0%EC%9D%98-%ED%8C%8C%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0%EB%A5%BC-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0>자신의 파드 셀렉터를 지정하기</a> 섹션을 참고한다.</p><h3 id=parallel-jobs>잡에 대한 병렬 실행</h3><p>잡으로 실행하기에 적합한 작업 유형은 크게 세 가지가 있다.</p><ol><li>비-병렬(Non-parallel) 잡:<ul><li>일반적으로, 파드가 실패하지 않은 한, 하나의 파드만 시작된다.</li><li>파드가 성공적으로 종료하자마자 즉시 잡이 완료된다.</li></ul></li><li><em>고정적(fixed)인 완료 횟수</em> 를 가진 병렬 잡:<ul><li><code>.spec.completions</code> 에 0이 아닌 양수 값을 지정한다.</li><li>잡은 전체 작업을 나타내며, <code>.spec.completions</code> 성공한 파드가 있을 때 완료된다.</li><li><code>.spec.completionMode="Indexed"</code> 를 사용할 때, 각 파드는 0에서 <code>.spec.completions-1</code> 범위 내의 서로 다른 인덱스를 가져온다.</li></ul></li><li><em>작업 큐(queue)</em> 가 있는 병렬 잡:<ul><li><code>.spec.completions</code> 를 지정하지 않고, <code>.spec.parallelism</code> 를 기본으로 한다.</li><li>파드는 각자 또는 외부 서비스 간에 조정을 통해 각각의 작업을 결정해야 한다. 예를 들어 파드는 작업 큐에서 최대 N 개의 항목을 일괄로 가져올(fetch) 수 있다.</li><li>각 파드는 모든 피어들의 작업이 완료되었는지 여부를 독립적으로 판단할 수 있으며, 결과적으로 전체 잡이 완료되게 한다.</li><li>잡의 <em>모든</em> 파드가 성공적으로 종료되면, 새로운 파드는 생성되지 않는다.</li><li>하나 이상의 파드가 성공적으로 종료되고, 모든 파드가 종료되면 잡은 성공적으로 완료된다.</li><li>성공적으로 종료된 파드가 하나라도 생긴 경우, 다른 파드들은 해당 작업을 지속하지 않아야 하며 어떠한 출력도 작성하면 안 된다. 파드들은 모두 종료되는 과정에 있어야 한다.</li></ul></li></ol><p><em>비-병렬</em> 잡은 <code>.spec.completions</code> 와 <code>.spec.parallelism</code> 모두를 설정하지 않은 채로 둘 수 있다. 이때 둘 다
설정하지 않은 경우 1이 기본으로 설정된다.</p><p><em>고정적인 완료 횟수</em> 잡은 <code>.spec.completions</code> 을 필요한 완료 횟수로 설정해야 한다.
<code>.spec.parallelism</code> 을 설정할 수 있고, 설정하지 않으면 1이 기본으로 설정된다.</p><p><em>작업 큐</em> 잡은 <code>.spec.completions</code> 를 설정하지 않은 상태로 두고, <code>.spec.parallelism</code> 을
음수가 아닌 정수로 설정해야 한다.</p><p>다른 유형의 잡을 사용하는 방법에 대한 더 자세한 정보는 <a href=#%EC%9E%A1-%ED%8C%A8%ED%84%B4>잡 패턴</a> 섹션을 본다.</p><h4 id=병렬-처리-제어하기>병렬 처리 제어하기</h4><p>요청된 병렬 처리(<code>.spec.parallelism</code>)는 음수가 아닌 값으로 설정할 수 있다.
만약 지정되지 않은 경우에는 1이 기본이 된다.
만약 0으로 지정되면 병렬 처리가 증가할 때까지 사실상 일시 중지된다.</p><p>실제 병렬 처리(모든 인스턴스에서 실행되는 파드의 수)는 여러가지 이유로 요청된
병렬 처리보다 많거나 적을 수 있다.</p><ul><li><em>고정적인 완료 횟수(fixed completion count)</em> 잡의 경우, 병렬로 실행 중인 파드의 수는 남은 완료 수를
초과하지 않는다. <code>.spec.parallelism</code> 의 더 큰 값은 사실상 무시된다.</li><li><em>작업 큐</em> 잡은 파드가 성공한 이후에 새로운 파드가 시작되지 않는다. 그러나 나머지 파드는 완료될 수 있다.</li><li>만약 잡 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 가 반응할 시간이 없는 경우</li><li>만약 잡 컨트롤러가 어떤 이유(<code>ResourceQuota</code> 의 부족, 권한 부족 등)로든 파드 생성에 실패한 경우,
요청한 것보다 적은 수의 파드가 있을 수 있다.</li><li>잡 컨트롤러는 동일한 잡에서 과도하게 실패한 이전 파드들로 인해 새로운 파드의 생성을 조절할 수 있다.</li><li>파드가 정상적으로(gracefully) 종료되면, 중지하는데 시간이 소요된다.</li></ul><h3 id=완료-모드>완료 모드</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [stable]</code></div><p>완료 횟수가 <em>고정적인 완료 횟수</em> 즉, null이 아닌 <code>.spec.completions</code> 가 있는 잡은
<code>.spec.completionMode</code> 에 지정된 완료 모드를 가질 수 있다.</p><ul><li><p><code>NonIndexed</code> (기본값): <code>.spec.completions</code> 가 성공적으로
완료된 파드가 있는 경우 작업이 완료된 것으로 간주된다. 즉, 각 파드
완료는 서로 상동하다(homologous). null <code>.spec.completions</code> 가 있는
잡은 암시적으로 <code>NonIndexed</code> 이다.</p></li><li><p><code>Indexed</code>: 잡의 파드는 연결된 완료 인덱스를 0에서 <code>.spec.completions-1</code> 까지
가져온다. 이 인덱스는 다음의 세 가지 메카니즘으로 얻을 수 있다.</p><ul><li>파드 어노테이션 <code>batch.kubernetes.io/job-completion-index</code>.</li><li>파드 호스트네임 중 일부(<code>$(job-name)-$(index)</code> 형태). 인덱스된(Indexed) 잡과
<a class=glossary-tooltip title='네트워크 서비스로 파드 집합에서 실행 중인 애플리케이션을 노출하는 방법' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/services-networking/service/ target=_blank aria-label=서비스>서비스</a>를 결합하여 사용하고
있다면, 잡에 속한 파드는 DNS를 이용하여 서로를 디스커버 하기 위해 사전에 결정된
호스트네임을 사용할 수 있다.</li><li>컨테이너화된 태스크의 경우, <code>JOB_COMPLETION_INDEX</code> 환경 변수.</li></ul><p>각 인덱스에 대해 성공적으로 완료된 파드가 하나 있으면 작업이 완료된 것으로
간주된다. 이 모드를 사용하는 방법에 대한 자세한 내용은
<a href=/ko/docs/tasks/job/indexed-parallel-processing-static/>정적 작업 할당을 사용한 병렬 처리를 위해 인덱싱된 잡</a>을 참고한다.
참고로, 드물기는 하지만, 동일한 인덱스에 대해 둘 이상의 파드를 시작할 수
있지만, 그 중 하나만 완료 횟수에 포함된다.</p></li></ul><h2 id=파드와-컨테이너-장애-처리하기>파드와 컨테이너 장애 처리하기</h2><p>파드내 컨테이너의 프로세스가 0이 아닌 종료 코드로 종료되었거나 컨테이너 메모리 제한을
초과해서 죽는 등의 여러가지 이유로 실패할 수 있다. 만약 이런 일이
발생하고 <code>.spec.template.spec.restartPolicy = "OnFailure"</code> 라면 파드는
노드에 그대로 유지되지만, 컨테이너는 다시 실행된다. 따라서 프로그램은 로컬에서 재시작될 때의
케이스를 다루거나 <code>.spec.template.spec.restartPolicy = "Never"</code> 로 지정해야 한다.
더 자세한 정보는 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%83%81%ED%83%9C-%EC%98%88%EC%A0%9C>파드 라이프사이클</a>의 <code>restartPolicy</code> 를 본다.</p><p>파드가 노드에서 내보내지는 경우(노드 업그레이드, 재부팅, 삭제 등) 또는 파드의 컨테이너가 실패
되고 <code>.spec.template.spec.restartPolicy = "Never"</code> 로 설정됨과 같은 여러 이유로
전체 파드가 실패할 수 있다. 파드가 실패하면 잡 컨트롤러는
새 파드를 시작한다. 이 의미는 애플리케이션이 새 파드에서 재시작될 때 이 케이스를 처리해야
한다는 점이다. 특히, 이전 실행으로 인한 임시파일, 잠금, 불완전한 출력 그리고 이와 유사한
것들을 처리해야 한다.</p><p><code>.spec.parallelism = 1</code>, <code>.spec.completions = 1</code> 그리고
<code>.spec.template.spec.restartPolicy = "Never"</code> 를 지정하더라도 같은 프로그램을
두 번 시작하는 경우가 있다는 점을 참고한다.</p><p><code>.spec.parallelism</code> 그리고 <code>.spec.completions</code> 를 모두 1보다 크게 지정한다면 한번에
여러 개의 파드가 실행될 수 있다. 따라서 파드는 동시성에 대해서도 관대(tolerant)해야 한다.</p><h3 id=파드-백오프-backoff-실패-정책>파드 백오프(backoff) 실패 정책</h3><p>구성에 논리적 오류가 포함되어 있어서 몇 회의 재시도 이후에
잡이 실패되도록 만들어야 하는 경우가 있다.
이렇게 하려면 <code>.spec.backoffLimit</code>의 값에
재시도(잡을 실패로 처리하기 이전까지) 횟수를 설정한다. 백오프 제한은 기본적으로 6으로 설정되어 있다.
잡에 연계된 실패 상태 파드는 6분 내에서 지수적으로 증가하는
백-오프 지연(10초, 20초, 40초 ...)을 적용하여, 잡 컨트롤러에 의해 재생성된다.</p><p>재시도 횟수는 다음 두 가지 방법으로 계산된다.</p><ul><li><code>.status.phase = "Failed"</code>인 파드의 수.</li><li><code>restartPolicy = "OnFailure"</code>를 사용하는 경우, <code>.status.phase</code>가
<code>Pending</code>이거나 <code>Running</code>인 파드들이 가지고 있는 모든 컨테이너의 수.</li></ul><p>계산 중 하나가 <code>.spec.backoffLimit</code>에 도달하면, 잡이
실패한 것으로 간주한다.</p><p><a href=#%EC%A2%85%EB%A3%8C%EC%9E%90-finalizers-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9E%A1-%EC%B6%94%EC%A0%81><code>JobTrackingWithFinalizers</code></a> 기능이 비활성화되어
있다면, 실패한 파드의 수는 API에 여전히 표시되고 있는 파드로만
계산된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 만약 잡에 <code>restartPolicy = "OnFailure"</code> 가 있는 경우 잡 백오프 한계에
도달하면 잡을 실행 중인 파드가 종료된다. 이로 인해 잡 실행 파일의 디버깅이
더 어려워질 수 있다. 디버깅하거나 로깅 시스템을 사용해서 실패한 작업의 결과를 실수로 손실되지 않도록
하려면 <code>restartPolicy = "Never"</code> 로 설정하는 것을 권장한다.</div><h2 id=잡의-종료와-정리>잡의 종료와 정리</h2><p>잡이 완료되면 파드가 더 이상 생성되지도 않지만, <a href=#pod-backoff-failure-policy>일반적으로는</a> 삭제되지도 않는다.<br>이를 유지하면
완료된 파드의 로그를 계속 보며 에러, 경고 또는 다른 기타 진단 출력을 확인할 수 있다.
잡 오브젝트는 완료된 후에도 상태를 볼 수 있도록 남아 있다. 상태를 확인한 후 이전 잡을 삭제하는 것은 사용자의 몫이다.
<code>kubectl</code> 로 잡을 삭제할 수 있다 (예: <code>kubectl delete jobs/pi</code> 또는 <code>kubectl delete -f ./job.yaml</code>). <code>kubectl</code> 을 사용해서 잡을 삭제하면 생성된 모든 파드도 함께 삭제된다.</p><p>기본적으로 파드의 실패(<code>restartPolicy=Never</code>) 또는 컨테이너가 오류(<code>restartPolicy=OnFailure</code>)로 종료되지 않는 한, 잡은 중단되지 않고 실행되고
이때 위에서 설명했던 <code>.spec.backoffLimit</code> 까지 연기된다. <code>.spec.backoffLimit</code> 에 도달하면 잡은 실패로 표기되고 실행 중인 모든 파드는 종료된다.</p><p>잡을 종료하는 또 다른 방법은 유효 데드라인을 설정하는 것이다.
잡의 <code>.spec.activeDeadlineSeconds</code> 필드를 초 단위로 설정하면 된다.
<code>activeDeadlineSeconds</code> 는 생성된 파드의 수에 관계 없이 잡의 기간에 적용된다.
잡이 <code>activeDeadlineSeconds</code> 에 도달하면, 실행 중인 모든 파드가 종료되고 잡의 상태는 <code>reason: DeadlineExceeded</code> 와 함께 <code>type: Failed</code> 가 된다.</p><p>잡의 <code>.spec.activeDeadlineSeconds</code> 는 <code>.spec.backoffLimit</code> 보다 우선한다는 점을 참고한다. 따라서 하나 이상 실패한 파드를 재시도하는 잡은 <code>backoffLimit</code> 에 도달하지 않은 경우에도 <code>activeDeadlineSeconds</code> 에 지정된 시간 제한에 도달하면 추가 파드를 배포하지 않는다.</p><p>예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi-with-timeout<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backoffLimit</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>activeDeadlineSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl:5.34.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><p>잡의 사양과 잡의 <a href=/ko/docs/concepts/workloads/pods/init-containers/#%EC%9E%90%EC%84%B8%ED%95%9C-%EB%8F%99%EC%9E%91>파드 템플릿 사양</a>에는 모두 <code>activeDeadlineSeconds</code> 필드가 있다는 점을 참고한다. 이 필드를 적절한 레벨로 설정해야 한다.</p><p><code>restartPolicy</code> 는 잡 자체에 적용되는 것이 아니라 파드에 적용된다는 점을 유념한다. 잡의 상태가 <code>type: Failed</code> 이 되면, 잡의 자동 재시작은 없다.
즉, <code>.spec.activeDeadlineSeconds</code> 와 <code>.spec.backoffLimit</code> 로 활성화된 잡의 종료 메커니즘은 영구적인 잡의 실패를 유발하며 이를 해결하기 위해 수동 개입이 필요하다.</p><h2 id=clean-up-finished-jobs-automatically>완료된 잡을 자동으로 정리</h2><p>완료된 잡은 일반적으로 시스템에서 더 이상 필요로 하지 않는다. 시스템 내에
이를 유지한다면 API 서버에 부담이 된다.
만약 <a href=/ko/docs/concepts/workloads/controllers/cron-jobs/>크론잡</a>과
같은 상위 레벨 컨트롤러가 잡을 직접 관리하는 경우,
지정된 용량 기반 정리 정책에 따라 크론잡이 잡을 정리할 수 있다.</p><h3 id=완료된-잡을-위한-ttl-메커니즘>완료된 잡을 위한 TTL 메커니즘</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [stable]</code></div><p>완료된 잡 (<code>Complete</code> 또는 <code>Failed</code>)을 자동으로 정리하는 또 다른 방법은
잡의 <code>.spec.ttlSecondsAfterFinished</code> 필드를 지정해서 완료된 리소스에 대해
<a href=/ko/docs/concepts/workloads/controllers/ttlafterfinished/>TTL 컨트롤러</a>에서
제공하는 TTL 메커니즘을 사용하는
것이다.</p><p>TTL 컨트롤러는 잡을 정리하면 잡을 계단식으로 삭제한다.
즉, 잡과 함께 파드와 같은 종속 오브젝트를 삭제한다. 잡을
삭제하면 finalizer와 같은 라이프사이클 보증이 보장되는 것을
참고한다.</p><p>예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi-with-ttl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ttlSecondsAfterFinished</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl:5.34.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>pi-with-ttl</code> 잡은 완료 후 <code>100</code> 초 이후에
자동으로 삭제될 수 있다.</p><p>만약 필드를 <code>0</code> 으로 설정하면, 잡이 완료된 직후에 자동으로
삭제되도록 할 수 있다. 만약 필드를 설정하지 않으면, 이 잡이 완료된
후에 TTL 컨트롤러에 의해 정리되지 않는다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p><code>ttlSecondsAfterFinished</code> 필드를 설정하는 것을 권장하는데,
이는 관리되지 않는 잡(직접 생성한,
크론잡 등 다른 워크로드 API를 통해 간접적으로 생성하지 않은 잡)의
기본 삭제 정책이 <code>orphanDependents</code>(관리되지 않는 잡이 완전히 삭제되어도
해당 잡에 의해 생성된 파드를 남겨둠)이기 때문이다.
삭제된 잡의 파드가 실패하거나 완료된 뒤
<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>이 언젠가
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>가비지 콜렉션</a>을 한다고 해도,
이렇게 남아 있는 파드는 클러스터의 성능을 저하시키거나
최악의 경우에는 이 성능 저하로 인해 클러스터가 중단될 수도 있다.</p><p><a href=/ko/docs/concepts/policy/limit-range/>리밋 레인지(Limit Range)</a>와
<a href=/ko/docs/concepts/policy/resource-quotas/>리소스 쿼터</a>를 사용하여
특정 네임스페이스가 사용할 수 있는 자원량을 제한할 수
있다.</p></div><h2 id=잡-패턴>잡 패턴</h2><p>잡 오브젝트를 사용해서 신뢰할 수 있는 파드의 병렬 실행을 지원할 수 있다. 잡 오브젝트는 과학
컴퓨팅(scientific computing)에서 일반적으로 사용되는 밀접하게 통신하는 병렬 프로세스를 지원하도록
설계되지 않았다. 잡 오브젝트는 독립적이지만 관련된 <em>작업 항목</em> 집합의 병렬 처리를 지원한다.
여기에는 전송할 이메일들, 렌더링할 프레임, 코드 변환이 필요한 파일, NoSQL 데이터베이스에서의
키 범위 스캔 등이 있다.</p><p>복잡한 시스템에는 여러 개의 다른 작업 항목 집합이 있을 수 있다. 여기서는 사용자와
함께 관리하려는 하나의 작업 항목 집합 — <em>배치 잡</em> 을 고려하고 있다.</p><p>병렬 계산에는 몇몇 다른 패턴이 있으며 각각의 장단점이 있다.
트레이드오프는 다음과 같다.</p><ul><li>각 작업 항목에 대한 하나의 잡 오브젝트 vs 모든 작업 항목에 대한 단일 잡 오브젝트. 후자는
작업 항목 수가 많은 경우 더 적합하다. 전자는 사용자와 시스템이 많은 수의 잡 오브젝트를
관리해야 하는 약간의 오버헤드를 만든다.</li><li>작업 항목과 동일한 개수의 파드 생성 vs 각 파드에서 다수의 작업 항목을 처리.
전자는 일반적으로 기존 코드와 컨테이너를 거의 수정할 필요가 없다. 후자는
이전 글 머리표(-)와 비슷한 이유로 많은 수의 작업 항목에 적합하다.</li><li>여러 접근 방식이 작업 큐를 사용한다. 이를 위해서는 큐 서비스를 실행하고,
작업 큐를 사용하도록 기존 프로그램이나 컨테이너를 수정해야 한다.
다른 접근 방식들은 기존에 컨테이너화된 애플리케이션에 보다 쉽게 적용할 수 있다.</li></ul><p>여기에 트레이드오프가 요약되어 있고, 2열에서 4열까지가 위의 트레이드오프에 해당한다.
패턴 이름은 예시와 더 자세한 설명을 위한 링크이다.</p><table><thead><tr><th>패턴</th><th style=text-align:center>단일 잡 오브젝트</th><th style=text-align:center>작업 항목보다 파드가 적은가?</th><th style=text-align:center>수정되지 않은 앱을 사용하는가?</th></tr></thead><tbody><tr><td><a href=/ko/docs/tasks/job/coarse-parallel-processing-work-queue/>작업 항목 당 파드가 있는 큐</a></td><td style=text-align:center>✓</td><td style=text-align:center></td><td style=text-align:center>때때로</td></tr><tr><td><a href=/ko/docs/tasks/job/fine-parallel-processing-work-queue/>가변 파드 수를 가진 큐</a></td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center></td></tr><tr><td><a href=/ko/docs/tasks/job/indexed-parallel-processing-static/>정적 작업 할당을 사용한 인덱싱된 잡</a></td><td style=text-align:center>✓</td><td style=text-align:center></td><td style=text-align:center>✓</td></tr><tr><td><a href=/ko/docs/tasks/job/parallel-processing-expansion/>잡 템플릿 확장</a></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>✓</td></tr></tbody></table><p><code>.spec.completions</code> 로 완료를 지정할 때, 잡 컨트롤러에 의해 생성된 각 파드는
동일한 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>사양</code></a>을 갖는다. 이 의미는
작업의 모든 파드는 동일한 명령 줄과 동일한 이미지,
동일한 볼륨, (거의) 동일한 환경 변수를 가진다는 점이다. 이 패턴은
파드가 다른 작업을 수행하도록 배열하는 다른 방법이다.</p><p>이 표는 각 패턴에 필요한 <code>.spec.parallelism</code> 그리고 <code>.spec.completions</code> 설정을 보여준다.
여기서 <code>W</code> 는 작업 항목의 수이다.</p><table><thead><tr><th>패턴</th><th style=text-align:center><code>.spec.completions</code></th><th style=text-align:center><code>.spec.parallelism</code></th></tr></thead><tbody><tr><td><a href=/ko/docs/tasks/job/coarse-parallel-processing-work-queue/>작업 항목 당 파드가 있는 큐</a></td><td style=text-align:center>W</td><td style=text-align:center>any</td></tr><tr><td><a href=/ko/docs/tasks/job/fine-parallel-processing-work-queue/>가변 파드 수를 가진 큐</a></td><td style=text-align:center>null</td><td style=text-align:center>any</td></tr><tr><td><a href=/ko/docs/tasks/job/indexed-parallel-processing-static/>정적 작업 할당을 사용한 인덱싱된 잡</a></td><td style=text-align:center>W</td><td style=text-align:center>any</td></tr><tr><td><a href=/ko/docs/tasks/job/parallel-processing-expansion/>잡 템플릿 확장</a></td><td style=text-align:center>1</td><td style=text-align:center>1이어야 함</td></tr></tbody></table><h2 id=고급-사용법>고급 사용법</h2><h3 id=잡-일시-중지>잡 일시 중지</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.24 [stable]</code></div><p>잡이 생성되면, 잡 컨트롤러는 잡의 요구 사항을 충족하기 위해
즉시 파드 생성을 시작하고 잡이 완료될 때까지
계속한다. 그러나, 잡의 실행을 일시적으로 중단하고 나중에
재개하거나, 잡을 중단 상태로 생성하고 언제 시작할지를
커스텀 컨트롤러가 나중에 결정하도록 하고 싶을 수도 있다.</p><p>잡을 일시 중지하려면, 잡의 <code>.spec.suspend</code> 필드를 true로
업데이트할 수 있다. 이후에, 다시 재개하려면, false로 업데이트한다.
<code>.spec.suspend</code> 로 설정된 잡을 생성하면 일시 중지된 상태로
생성된다.</p><p>잡이 일시 중지에서 재개되면, 해당 <code>.status.startTime</code> 필드가
현재 시간으로 재설정된다. 즉, 잡이 일시 중지 및 재개되면 <code>.spec.activeDeadlineSeconds</code>
타이머가 중지되고 재설정된다.</p><p>잡을 일시 중지하면, <code>Completed</code> 상태가 아닌 모든 실행중인 파드가 SIGTERM 시그널로 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>종료된다</a>.
파드의 정상 종료 기간이 적용되며 사용자의 파드는 이 기간 동안에
이 시그널을 처리해야 한다. 나중에 진행 상황을 저장하거나
변경 사항을 취소하는 작업이 포함될 수 있다. 이 방법으로 종료된 파드는
잡의 <code>completions</code> 수에 포함되지 않는다.</p><p>일시 중지된 상태의 잡 정의 예시는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get job myjob -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myjob<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>suspend</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>명령 줄에서 잡을 패치하여 잡 일시 중지를 전환할 수 있다.</p><p>활성화된 잡 일시 중지</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch job/myjob --type<span style=color:#666>=</span>strategic --patch <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;suspend&#34;:true}}&#39;</span>
</span></span></code></pre></div><p>일시 중지된 잡 재개</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch job/myjob --type<span style=color:#666>=</span>strategic --patch <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;suspend&#34;:false}}&#39;</span>
</span></span></code></pre></div><p>잡의 상태를 사용하여 잡이 일시 중지되었는지 또는 과거에 일시 중지되었는지
확인할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get jobs/myjob -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># .metadata and .spec omitted</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-02-05T13:14:33Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-02-05T13:14:33Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Suspended<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>startTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-02-05T13:13:48Z&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>"True" 상태인 "Suspended" 유형의 잡의 컨디션은 잡이
일시 중지되었음을 의미한다. 이 <code>lastTransitionTime</code> 필드는 잡이 일시 중지된
기간을 결정하는 데 사용할 수 있다. 해당 컨디션의 상태가 "False"이면, 잡이
이전에 일시 중지되었다가 현재 실행 중이다. 이러한 컨디션이
잡의 상태에 없으면, 잡이 중지되지 않은 것이다.</p><p>잡이 일시 중지 및 재개될 때에도 이벤트가 생성된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe jobs/myjob
</span></span></code></pre></div><pre tabindex=0><code>Name:           myjob
...
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  12m   job-controller  Created pod: myjob-hlrpl
  Normal  SuccessfulDelete  11m   job-controller  Deleted pod: myjob-hlrpl
  Normal  Suspended         11m   job-controller  Job suspended
  Normal  SuccessfulCreate  3s    job-controller  Created pod: myjob-jvb44
  Normal  Resumed           3s    job-controller  Job resumed
</code></pre><p>마지막 4개의 이벤트, 특히 "Suspended" 및 "Resumed" 이벤트는
<code>.spec.suspend</code> 필드를 전환한 결과이다. 이 두 이벤트 사이의 시간동안
파드가 생성되지 않았지만, 잡이 재개되자마자 파드 생성이 다시
시작되었음을 알 수 있다.</p><h3 id=가변적-스케줄링-지시>가변적 스케줄링 지시</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 기능을 사용하려면,
<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>API 서버</a>에
<code>JobMutableNodeSchedulingDirectives</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.
이 기능은 기본적으로 활성화되어 있다.</div><p>병렬 잡에서 대부분의 경우 파드를 특정 제약 조건 하에서 실행하고 싶을 것이다.
(예를 들면 동일 존에서 실행하거나, 또는 GPU 모델 x 또는 y를 사용하지만 둘을 혼합하지는 않는 등)</p><p><a href=#suspending-a-job>suspend</a> 필드는 이러한 목적을 달성하기 위한 첫 번째 단계이다.
이 필드를 사용하면 커스텀 큐(queue) 컨트롤러가 잡이 언제 시작될지를 결정할 수 있다.
그러나, 잡이 재개된 이후에는, 커스텀 큐 컨트롤러는 잡의 파드가 실제로 어디에 할당되는지에 대해서는 영향을 주지 않는다.</p><p>이 기능을 이용하여 잡이 실행되기 전에 잡의 스케줄링 지시를 업데이트할 수 있으며,
이를 통해 커스텀 큐 컨트롤러가 파드 배치에 영향을 줌과 동시에
노드로의 파드 실제 할당 작업을 kube-scheduler로부터 경감시켜 줄 수 있도록 한다.
이는 이전에 재개된 적이 없는 중지된 잡에 대해서만 허용된다.</p><p>잡의 파드 템플릿 필드 중, 노드 어피니티(node affinity), 노드 셀렉터(node selector),
톨러레이션(toleration), 레이블(label), 어노테이션(annotation)은 업데이트가 가능하다.</p><h3 id=자신의-파드-셀렉터를-지정하기>자신의 파드 셀렉터를 지정하기</h3><p>일반적으로 잡 오브젝트를 생성할 때 <code>.spec.selector</code> 를 지정하지 않는다.
시스템의 기본적인 로직은 잡이 생성될 때 이 필드를 추가한다.
이것은 다른 잡과 겹치지 않는 셀렉터 값을 선택한다.</p><p>그러나, 일부 케이스에서는 이 자동화된 설정 셀렉터를 재정의해야 할 수도 있다.
이를 위해 잡의 <code>.spec.selector</code> 를 설정할 수 있다.</p><p>이 것을 할 때는 매우 주의해야 한다. 만약 해당 잡의 파드에 고유하지
않고 연관이 없는 파드와 일치하는 레이블 셀렉터를 지정하면, 연관이 없는 잡의 파드가 삭제되거나,
해당 잡이 다른 파드가 완료한 것으로 수를 세거나, 하나 또는
양쪽 잡 모두 파드 생성이나 실행 완료를 거부할 수도 있다. 만약 고유하지 않은 셀렉터가
선택된 경우, 다른 컨트롤러(예: 레플리케이션 컨트롤러)와 해당 파드는
예측할 수 없는 방식으로 작동할 수 있다. 쿠버네티스는 당신이 <code>.spec.selector</code> 를 지정할 때
발생하는 실수를 막을 수 없을 것이다.</p><p>다음은 이 기능을 사용하려는 경우의 예시이다.</p><p>잡 <code>old</code> 가 이미 실행 중이다. 기존 파드가 계속
실행되기를 원하지만, 잡이 생성한 나머지 파드에는 다른
파드 템플릿을 사용하고 잡으로 하여금 새 이름을 부여하기를 원한다.
그러나 관련된 필드들은 업데이트가 불가능하기 때문에 잡을 업데이트할 수 없다.
따라서 <code>kubectl delete jobs/old --cascade=orphan</code> 명령을 사용해서
잡 <code>old</code> 를 삭제하지만, <em>파드를 실행 상태로 둔다</em>.
삭제하기 전에 어떤 셀렉터를 사용하는지 기록한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get job old -o yaml
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>old<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-uid</span>:<span style=color:#bbb> </span>a8f3d00d-c6d2-11e5-9f87-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>그런 이후에 이름이 <code>new</code> 인 새 잡을 생성하고, 동일한 셀렉터를 명시적으로 지정한다.
기존 파드에는 <code>controller-uid=a8f3d00d-c6d2-11e5-9f87-42010af00002</code>
레이블이 있기에 잡 <code>new</code> 에 의해서도 제어된다.</p><p>시스템이 일반적으로 자동 생성하는 셀렉터를 사용하지 않도록 하기 위해
새 잡에서 <code>manualSelector: true</code> 를 지정해야 한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>manualSelector</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-uid</span>:<span style=color:#bbb> </span>a8f3d00d-c6d2-11e5-9f87-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>새 잡 자체는 <code>a8f3d00d-c6d2-11e5-9f87-42010af00002</code> 와 다른 uid 를 가지게 될 것이다.
<code>manualSelector: true</code> 를 설정하면 시스템에게 사용자가 무엇을 하는지 알고 있으며
이런 불일치를 허용한다고 알릴 수 있다.</p><h3 id=pod-failure-policy>파드 실패 정책</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [alpha]</code></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 잡(Job)에 대한 파드 실패 정책은
<code>JobPodFailurePolicy</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가
클러스터에서 활성화됐을 경우에만 구성할 수 있다. 추가적으로,
파드 장애 정책의 파드 중단 조건 (참조:
<a href=/ko/docs/concepts/workloads/pods/disruptions#pod-disruption-conditions>파드 중단 조건</a>)을
감지하고 처리할 수 있도록 <code>PodDisruptionConditions</code> 기능 게이트를 활성화하는 것을 권장한다. 두 기능 게이트 모두
쿠버네티스 v1.25에서 사용할 수 있다.</div><p><code>.spec.podFailurePolicy</code> 필드로 정의되는 파드 실패 정책은, 클러스터가
컨테이너 종료 코드와 파드 상태를 기반으로 파드의 실패를
처리하도록 활성화한다.</p><p>어떤 상황에서는, 파드의 실패를 처리할 때 잡(Job)의 <code>.spec.backoffLimit</code>을 기반으로 하는
<a href=#pod-backoff-failure-policy>파드 백오프(backoff) 실패 정책</a>에서
제공하는 제어보다 더 나은 제어를 원할 수 있다. 다음은 사용 사례의 몇 가지 예시다.</p><ul><li>불필요한 파드 재시작을 방지하여 워크로드 실행 비용을 최적화하려면,
파드 중 하나가 소프트웨어 버그를 나타내는 종료 코드와 함께 실패하는 즉시
잡을 종료할 수 있다.</li><li>중단이 있더라도 잡이 완료되도록 하려면,
중단(예: <a class=glossary-tooltip title='쿠버네티스에서 선점(preemption)은 노드에서 낮은 우선 순위를 가지는 파드를 축출함으로써 보류 중인 파드가 적절한 노드를 찾을 수 있도록 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/#%ec%84%a0%ec%a0%90 target=_blank aria-label=선점(preemption)>선점(preemption)</a>,
<a class=glossary-tooltip title='API를 이용한 축출은 축출 API를 사용하여 파드의 정상 종료를 트리거하는 축출 오브젝트를 만드는 프로세스이다' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/api-eviction/ target=_blank aria-label='API를 이용한 축출(API-initiated Eviction)'>API를 이용한 축출(API-initiated Eviction)</a>
또는 축출 기반 <a class=glossary-tooltip title='세 가지 필수 속성: 키(key), 값(value), 효과(effect)로 구성된 코어 오브젝트. 테인트는 파드가 노드나 노드 그룹에 스케줄링되는 것을 방지한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=테인트(Taints)>테인트(Taints)</a>)으로 인한
파드 실패를 무시하여 <code>.spec.backoffLimit</code> 재시도 한도에 포함되지 않도록 할 수 있다.</li></ul><p>위의 사용 사례를 충족하기 위해
<code>.spec.podFailurePolicy</code> 필드에 파드 실패 정책을 구성할 수 있다.
이 정책은 컨테이너 종료 코드 및 파드 상태를 기반으로 파드 실패를 처리할 수 있다.</p><p>다음은 <code>podFailurePolicy</code>를 정의하는 잡의 매니페스트이다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples//controllers/job-pod-failure-policy-example.yaml download=/controllers/job-pod-failure-policy-example.yaml><code>/controllers/job-pod-failure-policy-example.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-job-pod-failure-policy-example-yaml")' title="Copy /controllers/job-pod-failure-policy-example.yaml to clipboard"></img></div><div class=includecode id=controllers-job-pod-failure-policy-example-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>job-pod-failure-policy-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>12</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>docker.io/library/bash:5<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;bash&#34;</span>]<span style=color:#bbb>        </span><span style=color:#080;font-style:italic># FailJob 액션을 트리거시키는 버그를 만들어내는 예제 명령어</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- echo &#34;Hello world!&#34; &amp;&amp; sleep 5 &amp;&amp; exit 42<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backoffLimit</span>:<span style=color:#bbb> </span><span style=color:#666>6</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podFailurePolicy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>action</span>:<span style=color:#bbb> </span>FailJob<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>onExitCodes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>main     <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 선택 사항</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In            <span style=color:#bbb> </span><span style=color:#080;font-style:italic># [In / NotIn] 중 하나</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#666>42</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>action</span>:<span style=color:#bbb> </span>Ignore            <span style=color:#bbb> </span><span style=color:#080;font-style:italic># [Ignore, FailJob, Count] 중 하나</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>onPodConditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DisruptionTarget  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 파드의 중단을 나타냄</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>위 예시에서, 파드 실패 정책의 첫 번째 규칙은 <code>main</code> 컨테이너가 42 종료코드와
함께 실패하면 잡도 실패로 표시되는 것으로
지정한다. 다음은 구체적으로 <code>main</code> 컨테이너에 대한 규칙이다.</p><ul><li>종료 코드 0은 컨테이너가 성공했음을 의미한다.</li><li>종료 코드 42는 <strong>전체 잡</strong>이 실패했음을 의미한다.</li><li>다른 모든 종료 코드는 컨테이너 및 전체 파드가 실패했음을
나타낸다. 재시작 횟수인 <code>backoffLimit</code>까지 파드가
다시 생성된다. 만약 <code>backoffLimit</code>에 도달하면 <strong>전체 잡</strong>이 실패한다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드 템플릿이 <code>restartPolicy: Never</code>로 지정되었기 때문에,
kubelet은 특정 파드에서 <code>main</code> 컨테이너를 재시작하지 않는다.</div><p><code>DisruptionTarget</code> 컨디션을 갖는 실패한 파드에 대해
<code>Ignore</code> 동작을 하도록 명시하고 있는 파드 실패 정책의 두 번째 규칙으로 인해,
<code>.spec.backoffLimit</code> 재시도 한도 계산 시 파드 중단(disruption)은 횟수에서 제외된다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드 실패 정책 또는 파드 백오프 실패 정책에 의해 잡이 실패하고,
잡이 여러 파드를 실행중이면, 쿠버네티스는 아직 보류(Pending) 또는
실행(Running) 중인 해당 잡의 모든 파드를 종료한다.</div><p>다음은 API의 몇 가지 요구 사항 및 의미이다.</p><ul><li>잡에 <code>.spec.podFailurePolicy</code> 필드를 사용하려면,
<code>.spec.restartPolicy</code>가 <code>Never</code>로 설정된 잡의 파드 템플릿 또한 정의해야 한다.</li><li><code>spec.podFailurePolicy.rules</code>에 기재한 파드 실패 정책 규칙은 기재한 순서대로 평가된다.
파드 실패 정책 규칙이 파드 실패와 매치되면 나머지 규칙은 무시된다.
파드 실패와 매치되는 파드 실패 정책 규칙이 없으면
기본 처리 방식이 적용된다.</li><li><code>spec.podFailurePolicy.rules[*].containerName</code>에 컨테이너 이름을 지정하여 파드 실패 규칙을 특정 컨테이너에게만 제한할 수 있다.
컨테이너 이름을 지정하지 않으면 파드 실패 규칙은 모든 컨테이너에 적용된다.
컨테이너 이름을 지정한 경우,
이는 파드 템플릿의 컨테이너 또는 <code>initContainer</code> 이름 중 하나와 일치해야 한다.</li><li>파드 실패 정책이 <code>spec.podFailurePolicy.rules[*].action</code>과 일치할 때 취할 동작을 지정할 수 있다.
사용 가능한 값은 다음과 같다.<ul><li><code>FailJob</code>: 파드의 잡을 <code>Failed</code>로 표시하고
실행 중인 모든 파드를 종료해야 함을 나타낸다.</li><li><code>Ignore</code>: <code>.spec.backoffLimit</code>에 대한 카운터가 증가하지 않아야 하고
대체 파드가 생성되어야 함을 나타낸다.</li><li><code>Count</code>: 파드가 기본 방식으로 처리되어야 함을 나타낸다.
<code>.spec.backoffLimit</code>에 대한 카운터가 증가해야 한다.</li></ul></li></ul><h3 id=종료자-finalizers-를-이용한-잡-추적>종료자(finalizers)를 이용한 잡 추적</h3><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>이 기능을 이용하기 위해서는
<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>API 서버</a>와
<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>컨트롤러 매니저</a>에 대해
<code>JobTrackingWithFinalizers</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화해야 한다.</p><p>이 기능이 활성화되면, 컨트롤 플레인은 아래에 설명할 동작을 이용하여 새로운 잡이 생성되는지 추적한다.
이 기능이 활성화되기 이전에 생성된 잡은 영향을 받지 않는다.
사용자가 느낄 수 있는 유일한 차이점은
컨트롤 플레인이 잡 종료를 좀 더 정확하게 추적할 수 있다는 것이다.</p></div><p>이 기능이 활성화되지 않으면, 잡
<a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는
<code>succeeded</code>와 <code>failed</code> 파드의 수를 세어 잡 상태를 추적한다.
그런데, 파드는 다음과 같은 이유로 제거될 수 있다.</p><ul><li>노드가 다운되었을 때 가비지 콜렉터가 버려진(orphan) 파드를 제거</li><li>가비지 콜렉터가 (<code>Succeeded</code> 또는 <code>Failed</code> 단계에 있는) 완료된 파드를
일정 임계값 이후에 제거</li><li>잡에 속한 파드를 사용자가 임의로 제거</li><li>(쿠버네티스에 속하지 않는) 외부 컨트롤러가 파드를 제거하거나
교체</li></ul><p>클러스터에서 <code>JobTrackingWithFinalizers</code> 기능을 활성화하면,
컨트롤 플레인은 잡에 속하는 파드의 상태를 추적하고
API 서버에서 파드가 제거되면 이를 알아챈다.
이를 위해, 잡 컨트롤러는 <code>batch.kubernetes.io/job-tracking</code> 종료자를 갖는 파드를 생성한다.
컨트롤러는 파드의 상태 변화가 잡 상태에 반영된 후에만 종료자를 제거하므로,
이후 다른 컨트롤러나 사용자가 파드를 제거할 수 있다.</p><p>잡 컨트롤러는 새로운 잡에 대해서만 새로운 알고리즘을 적용한다.
이 기능이 활성화되기 전에 생성된 잡은 영향을 받지 않는다.
잡에 <code>batch.kubernetes.io/job-tracking</code> 어노테이션이 있는지 확인하여,
잡 컨트롤러가 파드 종료자를 이용하여 잡을 추적하고 있는지 여부를 확인할 수 있다.
이 어노테이션을 잡에 수동으로 추가하거나 제거해서는 <strong>안 된다</strong>.</p><h2 id=대안>대안</h2><h3 id=베어-bare-파드>베어(Bare) 파드</h3><p>파드가 실행 중인 노드가 재부팅되거나 실패하면 파드가 종료되고
재시작되지 않는다. 그러나 잡은 종료된 항목을 대체하기 위해 새 파드를 생성한다.
따라서, 애플리케이션에 단일 파드만 필요한 경우에도 베어 파드 대신
잡을 사용하는 것을 권장한다.</p><h3 id=레플리케이션-컨트롤러>레플리케이션 컨트롤러</h3><p>잡은 <a href=/ko/docs/concepts/workloads/controllers/replicationcontroller/>레플리케이션 컨트롤러</a>를 보완한다.
레플리케이션 컨트롤러는 종료하지 않을 파드(예: 웹 서버)를 관리하고, 잡은 종료될 것으로
예상되는 파드(예: 배치 작업)를 관리한다.</p><p><a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/>파드 라이프사이클</a>에서 설명한 것처럼, <code>잡</code> 은 <em>오직</em>
<code>OnFailure</code> 또는 <code>Never</code> 와 같은 <code>RestartPolicy</code> 를 사용하는 파드에만 적절하다.
(참고: <code>RestartPolicy</code> 가 설정되지 않은 경우에는 기본값은 <code>Always</code> 이다.)</p><h3 id=단일-잡으로-컨트롤러-파드-시작>단일 잡으로 컨트롤러 파드 시작</h3><p>또 다른 패턴은 단일 잡이 파드를 생성한 후 다른 파드들을 생성해서 해당 파드들에
일종의 사용자 정의 컨트롤러 역할을 하는 것이다. 이를 통해 최대한의 유연성을 얻을 수 있지만,
시작하기에는 다소 복잡할 수 있으며 쿠버네티스와의 통합성이 낮아진다.</p><p>이 패턴의 한 예시는 파드를 시작하는 잡이다. 파드는 스크립트를 실행해서
스파크(Spark) 마스터 컨트롤러 (<a href=https://github.com/kubernetes/examples/tree/master/staging/spark/README.md>스파크 예시</a>를 본다)를 시작하고,
스파크 드라이버를 실행한 다음, 정리한다.</p><p>이 접근 방식의 장점은 전체 프로세스가 잡 오브젝트의 완료를 보장하면서도,
파드 생성과 작업 할당 방법을 완전히 제어하고 유지한다는 것이다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/workloads/pods>파드</a>에 대해 배운다.</li><li>다른 방식으로 잡을 구동하는 방법에 대해서 읽는다.<ul><li><a href=/ko/docs/tasks/job/coarse-parallel-processing-work-queue/>작업 대기열을 사용한 거친 병렬 처리</a></li><li><a href=/ko/docs/tasks/job/fine-parallel-processing-work-queue/>작업 대기열을 사용한 정밀 병렬 처리</a></li><li><a href=/ko/docs/tasks/job/indexed-parallel-processing-static/>병렬 처리를 위한 정적 작업 할당으로 인덱스된 잡</a>(베타) 사용</li><li>템플릿 기반으로 복수의 잡 생성: <a href=/ko/docs/tasks/job/parallel-processing-expansion/>확장을 사용한 병렬 처리</a></li></ul></li><li><a href=#clean-up-finished-jobs-automatically>완료된 잡을 자동으로 정리</a> 섹션 내 링크를 따라서
클러스터가 완료되거나 실패된 태스크를 어떻게 정리하는지에 대해 더 배운다.</li><li><code>Job</code>은 쿠버네티스 REST API의 일부이다.
잡 API에 대해 이해하기 위해
<a href=/docs/reference/kubernetes-api/workload-resources/job-v1/>Job</a>
오브젝트 정의를 읽는다.</li><li>스케줄을 기반으로 실행되는 일련의 잡을 정의하는데 사용할 수 있고, 유닉스 툴 <code>cron</code>과 유사한
<a href=/ko/docs/concepts/workloads/controllers/cron-jobs/><code>CronJob</code></a>에 대해 읽는다.</li><li>단계별로 구성된 <a href=/docs/tasks/job/pod-failure-policy/>예제</a>를 통해, <code>podFailurePolicy</code>를 사용하여 재시도 가능 및 재시도 불가능 파드의 실패 처리를 하기위한 구성 방법을 연습한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4de50a37ebb6f2340484192126cb7a04>2.6 - 완료된 잡 자동 정리</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.23 [stable]</code></div><p>완료-이후-TTL(TTL-after-finished) <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a>는
실행이 완료된 리소스 오브젝트의 수명을 제한하는
TTL (time to live) 메커니즘을 제공한다.
TTL 컨트롤러는 <a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡>잡</a>만을 제어한다.</p><h2 id=완료-이후-ttl-컨트롤러>완료-이후-TTL 컨트롤러</h2><p>완료-이후-TTL 컨트롤러는 잡만을 지원한다. 클러스터 운영자는
<a href=/ko/docs/concepts/workloads/controllers/job/#%EC%99%84%EB%A3%8C%EB%90%9C-%EC%9E%A1%EC%9D%84-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%A0%95%EB%A6%AC>예시</a>
와 같이 <code>.spec.ttlSecondsAfterFinished</code> 필드를 명시하여
완료된 잡(<code>완료</code> 또는 <code>실패</code>)을 자동으로 정리하기 위해 이 기능을 사용할 수 있다.
잡의 작업이 완료된 TTL 초(sec) 후 (다른 말로는, TTL이 만료되었을 때),
완료-이후-TTL 컨트롤러는 해당 잡이 정리될 수 있다고 가정한다.
완료-이후-TTL 컨트롤러가 잡을 정리할때 잡을 연속적으로 삭제한다. 이는
의존하는 오브젝트도 해당 잡과 함께 삭제되는 것을 의미한다. 잡이 삭제되면 완료자(finalizers)와
같은 라이프 사이클 보증이 적용 된다.</p><p>TTL 초(sec)는 언제든지 설정이 가능하다. 여기에 잡 필드 중
<code>.spec.ttlSecondsAfterFinished</code> 를 설정하는 몇 가지 예시가 있다.</p><ul><li>작업이 완료된 다음, 일정 시간 후에 자동으로 잡이 정리될 수 있도록
잡 메니페스트에 이 필드를 지정한다.</li><li>이미 완료된 기존 잡에 이 새 기능을 적용하기 위해서 이 필드를
설정한다.</li><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>어드미션 웹후크 변형</a>
을 사용해서
잡 생성시 이 필드를 동적으로 설정 한다. 클러스터 관리자는 이것을
사용해서 완료된 잡에 대해 TTL 정책을 적용할 수 있다.</li><li>잡이 완료된 이후에
<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>어드미션 웹후크 변형</a>
을 사용해서 이 필드를 동적으로 설정하고, 잡의 상태,
레이블 등에 따라 다른 TTL 값을 선택한다.</li></ul><h2 id=경고>경고</h2><h3 id=ttl-초-sec-업데이트>TTL 초(sec) 업데이트</h3><p>TTL 기간은, 예를 들어 잡의 <code>.spec.ttlSecondsAfterFinished</code> 필드는
잡을 생성하거나 완료한 후에 수정할 수 있다. 그러나, 잡을
삭제할 수 있게 되면(TTL이 만료된 경우) 시스템은 TTL을 연장하기
위한 업데이트가 성공적인 API 응답을 리턴하더라도
작업이 유지되도록 보장하지 않는다.</p><h3 id=시간-차이-skew>시간 차이(Skew)</h3><p>완료-이후-TTL 컨트롤러는 쿠버네티스 잡에
저장된 타임스탬프를 사용해서 TTL의 만료 여부를 결정하기 때문에, 이 기능은 클러스터 간의
시간 차이에 민감하며, 시간 차이에 의해서 완료-이후-TTL 컨트롤러가 잘못된 시간에 잡
오브젝트를 정리하게 될 수 있다.</p><p>시계가 항상 정확한 것은 아니지만, 그 차이는
아주 작아야 한다. 0이 아닌 TTL을 설정할때는 이 위험에 대해 유의해야 한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><p><a href=/ko/docs/concepts/workloads/controllers/job/#%EC%99%84%EB%A3%8C%EB%90%9C-%EC%9E%A1%EC%9D%84-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%A0%95%EB%A6%AC>자동으로 잡 정리</a></p></li><li><p><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-apps/592-ttl-after-finish/README.md>디자인 문서</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2e4cec01c525b45eccd6010e21cc76d9>2.7 - 크론잡</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.21 [stable]</code></div><p><em>크론잡은</em> 반복 일정에 따라 <a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡>잡</a>을 만든다.</p><p>하나의 크론잡 오브젝트는 <em>크론탭</em> (크론 테이블) 파일의 한 줄과 같다.
크론잡은 잡을 <a href=https://ko.wikipedia.org/wiki/Cron>크론</a> 형식으로 쓰여진 주어진 일정에 따라 주기적으로 동작시킨다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong><p>모든 <strong>크론잡</strong> <code>일정:</code> 시간은
<a class=glossary-tooltip title='컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>의 시간대를 기준으로 한다.</p><p>컨트롤 플레인이 파드 또는 베어 컨테이너에서 kube-controller-manager를 실행하는 경우,
kube-controller-manager 컨테이너에 설정된 시간대는
크론잡 컨트롤러가 사용하는 시간대로 결정한다.</p></div><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong><p><a href=/docs/reference/kubernetes-api/workload-resources/cron-job-v1/>v1 CronJob API</a>은
위에서 설명한 타임존 설정을 공식적으로 지원하지는 않는다.</p><p><code>CRON_TZ</code> 또는 <code>TZ</code> 와 같은 변수를 설정하는 것은 쿠버네티스 프로젝트에서 공식적으로 지원하지는 않는다.
<code>CRON_TZ</code> 또는 <code>TZ</code> 와 같은 변수를 설정하는 것은
크론탭을 파싱하고 다음 잡 생성 시간을 계산하는 내부 라이브러리의 구현 상세사항이다.
프로덕션 클러스터에서는 사용을 권장하지 않는다.</p></div><p>크론잡 리소스에 대한 매니페스트를 생성할 때에는 제공하는 이름이
유효한 <a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.
이름은 52자 이하여야 한다. 이는 크론잡 컨트롤러는 제공된 잡 이름에
11자를 자동으로 추가하고, 작업 이름의 최대 길이는
63자라는 제약 조건이 있기 때문이다.</p><h2 id=크론잡>크론잡</h2><p>크론잡은 백업, 리포트 생성 등의 정기적 작업을 수행하기 위해 사용된다.
각 작업은 무기한 반복되도록 구성해야 한다(예:
1일/1주/1달마다 1회).
작업을 시작해야 하는 해당 간격 내 특정 시점을 정의할 수 있다.</p><h3 id=예시>예시</h3><p>이 크론잡 매니페스트 예제는 현재 시간과 hello 메시지를 1분마다 출력한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-cronjob-yaml")' title="Copy application/job/cronjob.yaml to clipboard"></img></div><div class=includecode id=application-job-cronjob-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * *&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>(<a href=/ko/docs/tasks/job/automated-tasks-with-cron-jobs/>크론잡으로 자동화된 작업 실행하기</a>는
이 예시를 더 자세히 설명한다.)</p><h3 id=크론-스케줄-문법>크론 스케줄 문법</h3><pre tabindex=0><code># ┌───────────── 분 (0 - 59)
# │ ┌───────────── 시 (0 - 23)
# │ │ ┌───────────── 일 (1 - 31)
# │ │ │ ┌───────────── 월 (1 - 12)
# │ │ │ │ ┌───────────── 요일 (0 - 6) (일요일부터 토요일까지;
# │ │ │ │ │                                   특정 시스템에서는 7도 일요일)
# │ │ │ │ │                                   또는 sun, mon, tue, wed, thu, fri, sat
# │ │ │ │ │
# * * * * *
</code></pre><table><thead><tr><th>항목</th><th>설명</th><th>상응 표현</th></tr></thead><tbody><tr><td>@yearly (or @annually)</td><td>매년 1월 1일 자정에 실행</td><td>0 0 1 1 *</td></tr><tr><td>@monthly</td><td>매월 1일 자정에 실행</td><td>0 0 1 * *</td></tr><tr><td>@weekly</td><td>매주 일요일 자정에 실행</td><td>0 0 * * 0</td></tr><tr><td>@daily (or @midnight)</td><td>매일 자정에 실행</td><td>0 0 * * *</td></tr><tr><td>@hourly</td><td>매시 0분에 시작</td><td>0 * * * *</td></tr></tbody></table><p>예를 들면, 다음은 해당 작업이 매주 금요일 자정에 시작되어야 하고, 매월 13일 자정에도 시작되어야 한다는 뜻이다.</p><p><code>0 0 13 * 5</code></p><p>크론잡 스케줄 표현을 생성하기 위해서 <a href=https://crontab.guru/>crontab.guru</a>와 같은 웹 도구를 사용할 수도 있다.</p><h2 id=타임-존>타임 존</h2><p>크론잡에 타임 존이 명시되어 있지 않으면, kube-controller-manager는 로컬 타임 존을 기준으로 스케줄을 해석한다.</p><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [beta]</code></div><p><code>CronJobTimeZone</code> <a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>를 활성화하면,
크론잡에 대해 타임 존을 명시할 수 있다(기능 게이트를 활성화하지 않거나,
타임 존에 대한 실험적 지원을 제공하지 않는 쿠버네티스 버전을 사용 중인 경우,
클러스터의 모든 크론잡은 타임 존이 명시되지 않은 것으로 동작한다).</p><p>이 기능을 활성화하면, <code>spec.timeZone</code>을 유효한 <a href=https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>타임 존</a> 이름으로 지정할 수 있다.
예를 들어, <code>spec.timeZone: "Etc/UTC"</code>와 같이 설정하면 쿠버네티스는 협정 세계시를 기준으로 스케줄을 해석한다.</p><p>Go 표준 라이브러리의 타임 존 데이터베이스가 바이너리로 인클루드되며, 시스템에서 외부 데이터베이스를 사용할 수 없을 때 폴백(fallback)으로 사용된다.</p><h2 id=cron-job-limitations>크론잡의 한계</h2><p>크론잡은 일정의 실행시간 마다 <em>약</em> 한 번의 잡 오브젝트를 생성한다. "약" 이라고 하는 이유는
특정 환경에서는 두 개의 잡이 만들어지거나, 잡이 생성되지 않기도 하기 때문이다. 보통 이렇게 하지
않도록 해야겠지만, 완벽히 그럴 수는 없다. 따라서 잡은 <em>멱등원</em> 이 된다.</p><p>만약 <code>startingDeadlineSeconds</code> 가 큰 값으로 설정되거나, 설정되지 않고(디폴트 값),
<code>concurrencyPolicy</code> 가 <code>Allow</code> 로 설정될 경우, 잡은 항상 적어도 한 번은
실행될 것이다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> <code>startingDeadlineSeconds</code> 가 10초 미만의 값으로 설정되면, 크론잡이 스케줄되지 않을 수 있다. 이는 크론잡 컨트롤러가 10초마다 항목을 확인하기 때문이다.</div><p>모든 크론잡에 대해 크론잡 <a class=glossary-tooltip title='API 서버를 통해 클러스터의 공유된 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 컨트롤 루프.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/architecture/controller/ target=_blank aria-label=컨트롤러>컨트롤러</a> 는 마지막 일정부터 지금까지 얼마나 많은 일정이 누락되었는지 확인한다. 만약 100회 이상의 일정이 누락되었다면, 잡을 실행하지 않고 아래와 같은 에러 로그를 남긴다.</p><pre tabindex=0><code>Cannot determine if job needs to be started. Too many missed start time (&gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.
</code></pre><p>중요한 것은 만약 <code>startingDeadlineSeconds</code> 필드가 설정이 되면(<code>nil</code> 이 아닌 값으로), 컨트롤러는 마지막 일정부터 지금까지 대신 <code>startingDeadlineSeconds</code> 값에서 몇 개의 잡이 누락되었는지 카운팅한다. 예를 들면, <code>startingDeadlineSeconds</code> 가 <code>200</code> 이면, 컨트롤러는 최근 200초 내 몇 개의 잡이 누락되었는지 카운팅한다.</p><p>크론잡은 정해진 일정에 잡 실행을 실패하면 놓쳤다고 카운팅된다. 예를 들면, <code>concurrencyPolicy</code> 가 <code>Forbid</code> 로 설정되었고, 크론잡이 이전 일정이 스케줄되어 여전히 시도하고 있을 때, 그 때 누락되었다고 판단한다.</p><p>즉, 크론잡이 <code>08:30:00</code> 에 시작하여 매 분마다 새로운 잡을 실행하도록 설정이 되었고,
<code>startingDeadlineSeconds</code> 값이 설정되어 있지 않는다고 가정해보자. 만약 크론잡 컨트롤러가
<code>08:29:00</code> 부터 <code>10:21:00</code> 까지 고장이 나면, 일정을 놓친 작업 수가 100개를 초과하여 잡이 실행되지 않을 것이다.</p><p>이 개념을 더 자세히 설명하자면, 크론잡이 <code>08:30:00</code> 부터 매 분 실행되는 일정으로 설정되고,
<code>startingDeadlineSeconds</code> 이 200이라고 가정한다. 크론잡 컨트롤러가
전의 예시와 같이 고장났다고 하면 (<code>08:29:00</code> 부터 <code>10:21:00</code> 까지), 잡은 10:22:00 부터 시작될 것이다. 이 경우, 컨트롤러가 마지막 일정부터 지금까지가 아니라, 최근 200초 안에 얼마나 놓쳤는지 체크하기 때문이다. (여기서는 3번 놓쳤다고 체크함)</p><p>크론잡은 오직 그 일정에 맞는 잡 생성에 책임이 있고,
잡은 그 잡이 대표하는 파드 관리에 책임이 있다.</p><h2 id=new-controller>컨트롤러 버전</h2><p>쿠버네티스 v1.21부터 크론잡 컨트롤러의 두 번째 버전이
기본 구현이다. 기본 크론잡 컨트롤러를 비활성화하고
대신 원래 크론잡 컨트롤러를 사용하려면, <code>CronJobControllerV2</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>
플래그를 <a class=glossary-tooltip title='컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>에 전달하고,
이 플래그를 <code>false</code> 로 설정한다. 예를 들면, 다음과 같다.</p><pre tabindex=0><code>--feature-gates=&#34;CronJobControllerV2=false&#34;
</code></pre><h2 id=다음-내용>다음 내용</h2><ul><li>크론잡이 의존하고 있는 <a href=/ko/docs/concepts/workloads/pods/>파드</a>와
<a href=/ko/docs/concepts/workloads/controllers/job/>잡</a> 두 개념에
대해 배운다.</li><li>크론잡 <code>.spec.schedule</code> 필드의 <a href=https://pkg.go.dev/github.com/robfig/cron/v3#hdr-CRON_Expression_Format>형식</a>에
대해서 읽는다.</li><li>크론잡을 생성하고 다루기 위한 지침 및
크론잡 매니페스트의 예제로
<a href=/ko/docs/tasks/job/automated-tasks-with-cron-jobs/>크론잡으로 자동화된 작업 실행</a>를 읽는다.</li><li>실패했거나 완료된 잡을 자동으로 정리하도록 하려면,
<a href=/ko/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically>완료된 잡을 자동으로 정리</a>를 확인한다.</li><li><code>CronJob</code>은 쿠버네티스 REST API의 일부이다.
<a href=/docs/reference/kubernetes-api/workload-resources/cron-job-v1/>CronJob</a>
오브젝트 정의를 읽고 쿠버네티스 크론잡 API에 대해 이해한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-27f1331d515d95f76aa1156088b4ad91>2.8 - 레플리케이션 컨트롤러</h1><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <a href=/ko/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>을 구성하는 <a href=/ko/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>가 현재 권장하는 레플리케이션 설정 방법이다.</div><p><em>레플리케이션컨트롤러</em> 는 언제든지 지정된 수의 파드 레플리카가
실행 중임을 보장한다.
다시 말하면, 레플리케이션 컨트롤러는 파드 또는 동일 종류의 파드의 셋이 항상 기동되고 사용 가능한지 확인한다.</p><h2 id=레플리케이션-컨트롤러의-동작방식>레플리케이션 컨트롤러의 동작방식</h2><p>파드가 너무 많으면 레플리케이션 컨트롤러가 추가적인 파드를 제거한다.
너무 적으면 레플리케이션 컨트롤러는 더 많은 파드를 시작한다.
수동으로 생성된 파드와 달리 레플리케이션 컨트롤러가 유지 관리하는 파드는 실패하거나 삭제되거나 종료되는 경우 자동으로 교체된다.
예를 들어, 커널 업그레이드와 같이 파괴적인 유지 보수 작업을 하고 난 이후의 노드에서 파드가 다시 생성된다.
따라서 애플리케이션에 하나의 파드만 필요한 경우에도 레플리케이션 컨트롤러를 사용해야 한다.
레플리케이션 컨트롤러는 프로세스 감시자(supervisor)와 유사하지만
단일 노드에서 개별 프로세스를 감시하는 대신 레플리케이션 컨트롤러는
여러 노드에서 여러 파드를 감시한다.</p><p>레플리케이션 컨트롤러는 디스커션에서 종종 "rc"로 축약되며
kubectl 명령에서 숏컷으로 사용된다.</p><p>간단한 경우는 하나의 레플리케이션 컨트롤러 오브젝트를 생성하여
한 개의 파드 인스턴스를 영구히 안정적으로 실행하는 것이다.
보다 복잡한 사용 사례는 웹 서버와 같이 복제된 서비스의 동일한 레플리카를 여러 개 실행하는 것이다.</p><h2 id=레플리케이션-컨트롤러-예제-실행>레플리케이션 컨트롤러 예제 실행</h2><p>레플리케이션 컨트롤러 예제의 config는 nginx 웹서버의 복사본 세 개를 실행한다.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ko/examples/controllers/replication.yaml download=controllers/replication.yaml><code>controllers/replication.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-replication-yaml")' title="Copy controllers/replication.yaml to clipboard"></img></div><div class=includecode id=controllers-replication-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicationController<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>예제 파일을 다운로드한 후 다음 명령을 실행하여 예제 작업을 실행하라.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/replication.yaml
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><pre tabindex=0><code>replicationcontroller/nginx created
</code></pre><p>다음 명령을 사용하여 레플리케이션 컨트롤러의 상태를 확인하자.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe replicationcontrollers/nginx
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><pre tabindex=0><code>Name:        nginx
Namespace:   default
Selector:    app=nginx
Labels:      app=nginx
Annotations:    &lt;none&gt;
Replicas:    3 current / 3 desired
Pods Status: 0 Running / 3 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:       app=nginx
  Containers:
   nginx:
    Image:              nginx
    Port:               80/TCP
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Events:
  FirstSeen       LastSeen     Count    From                        SubobjectPath    Type      Reason              Message
  ---------       --------     -----    ----                        -------------    ----      ------              -------
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-qrm3m
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-3ntk0
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-4ok8v
</code></pre><p>이제 세 개의 파드가 생성되었으나 아직 이미지가 풀(pull)되지 않아서 어떤 파드도 시작되지 않았다.
조금 지난 후에 같은 명령이 다음과 같이 보일 것이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Pods Status:    <span style=color:#666>3</span> Running / <span style=color:#666>0</span> Waiting / <span style=color:#666>0</span> Succeeded / <span style=color:#666>0</span> Failed
</span></span></code></pre></div><p>레플리케이션 컨트롤러에 속한 모든 파드를 머신이 읽을 수 있는 형식으로 나열하기 위해 다음과 같은 명령을 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><p>출력 결과는 다음과 같다.</p><pre tabindex=0><code>nginx-3ntk0 nginx-4ok8v nginx-qrm3m
</code></pre><p>여기서 셀렉터는 레플리케이션컨트롤러(<code>kubectl describe</code> 의 출력에서 보인)의 셀렉터와 같고,
다른 형식의 파일인 <code>replication.yaml</code> 의 것과 동일하다. <code>--output=jsonpath</code> 은
반환된 목록의 각 파드의 이름을 출력하도록 하는 옵션이다.</p><h2 id=레플리케이션-컨트롤러의-spec-작성>레플리케이션 컨트롤러의 Spec 작성</h2><p>다른 모든 쿠버네티스 컨피그와 마찬가지로 레플리케이션 컨트롤러는 <code>apiVersion</code>, <code>kind</code>, <code>metadata</code> 와 같은 필드가 필요하다.
레플리케이션 컨트롤러 오브젝트의 이름은 유효한
<a href=/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84>DNS 서브도메인 이름</a>이어야 한다.
환경설정 파일의 동작에 관련된 일반적인 정보는 <a href=/ko/docs/concepts/overview/working-with-objects/object-management/>쿠버네티스 오브젝트 관리</a>를 참고한다.</p><p>레플리케이션 컨트롤러는 또한 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> section</a>도 필요하다.</p><h3 id=파드-템플릿>파드 템플릿</h3><p><code>.spec.template</code> 는 오직 <code>.spec</code> 필드에서 요구되는 것이다.</p><p><code>.spec.template</code> 는 <a href=/ko/docs/concepts/workloads/pods/#%ED%8C%8C%EB%93%9C-%ED%85%9C%ED%94%8C%EB%A6%BF>파드 템플릿</a>이다. 정확하게 <a class=glossary-tooltip title='파드는 클러스터에서 실행 중인 컨테이너의 집합을 나타낸다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ target=_blank aria-label=파드>파드</a> 스키마와 동일하나, 중첩되어 있고 <code>apiVersion</code> 혹은 <code>kind</code>를 갖지 않는다.</p><p>파드에 필요한 필드 외에도 레플리케이션 컨트롤러의 파드 템플릿은 적절한 레이블과 적절한 재시작 정책을 지정해야 한다. 레이블의 경우 다른 컨트롤러와
중첩되지 않도록 하라. <a href=#%ED%8C%8C%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0>파드 셀렉터</a>를 참조하라.</p><p>오직 <code>Always</code> 와 동일한 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EC%A0%95%EC%B1%85><code>.spec.template.spec.restartPolicy</code></a>만 허용되며, 특별히 지정되지 않으면 기본값이다.</p><p>로컬 컨테이너의 재시작의 경우, 레플리케이션 컨트롤러는 노드의 에이전트에게 위임한다.
예를 들어 <a href=/docs/reference/command-line-tools-reference/kubelet/>Kubelet</a> 혹은 도커이다.</p><h3 id=레플리케이션-컨트롤러에서-레이블>레플리케이션 컨트롤러에서 레이블</h3><p>레플리케이션 컨트롤러 자체는 레이블 (<code>.metadata.labels</code>) 을 가질 수 있다. 일반적으로 이것을 <code>.spec.template.metadata.labels</code> 와 동일하게 설정할 것이다. <code>.metadata.labels</code> 가 지정되어 있지 않은 경우,
기본은 <code>.spec.template.metadata.labels</code> 이다. 하지만 레이블은
다른 것이 허용되며, <code>.metadata.labels</code> 라벨은 레플리케이션 컨트롤러의
동작에 영향을 미치지 않는다.</p><h3 id=파드-셀렉터>파드 셀렉터</h3><p><code>.spec.selector</code> 필드는 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EB%A0%88%EC%9D%B4%EB%B8%94-%EC%85%80%EB%A0%89%ED%84%B0>레이블 셀렉터</a>이다. 레플리케이션 컨트롤러는 셀렉터와 일치하는 레이블이 있는 모든 파드를 관리한다.
직접 생성하거나 삭제된 파드와 다른 사람이나 프로세스가 생성하거나
삭제한 파드를 구분하지 않는다. 이렇게 하면 실행중인 파드에 영향을 주지 않고
레플리케이션 컨트롤러를 교체할 수 있다.</p><p>지정된 경우 <code>.spec.template.metadata.labels</code> 은
<code>.spec.selector</code> 와 동일해야 하며 그렇지 않으면 API에 의해 거부된다. <code>.spec.selector</code> 가 지정되지 않은 경우 기본값은
<code>.spec.template.metadata.labels</code> 이다.</p><p>또한 일반적으로 이 셀렉터와 레이블이 일치하는 파드를 직접
다른 레플리케이션 컨트롤러 또는 잡과 같은 다른 컨트롤러로 작성해서는 안된다.
그렇게 하면 레플리케이션 컨트롤러는 다른 파드를 생성했다고 생각한다.
쿠버네티스는 이런 작업을 중단해 주지 않는다.</p><p>중첩된 셀렉터들을 갖는 다수의 컨트롤러들을 종료하게 되면, 삭제된 것들은 스스로 관리를 해야 한다
(<a href=#%EB%A0%88%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0>아래</a>를 참조).</p><h3 id=다수의-레플리카>다수의 레플리카</h3><p><code>.spec.replicas</code> 를 동시에 실행하고 싶은 파드의 수로 설정함으로써
실행할 파드의 수를 지정할 수 있다. 레플리카가 증가 또는 감소한 경우 또는
파드가 정상적으로 종료되고 교체가 일찍 시작되는 경우라면
언제든지 실행중인 수가 더 높거나 낮을 수 있다.</p><p><code>.spec.replicas</code> 를 지정하지 않으면 기본값은 1이다.</p><h2 id=레플리케이션-컨트롤러-사용하기>레플리케이션 컨트롤러 사용하기</h2><h3 id=레플리케이션-컨트롤러와-레플리케이션-컨트롤러의-파드-삭제>레플리케이션 컨트롤러와 레플리케이션 컨트롤러의 파드 삭제</h3><p>레플리케이션 컨트롤러와 레플리케이션의 모든 파드를 삭제하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a> 를 사용하라.
Kubectl은 레플리케이션 컨트롤러를 0으로 스케일하고 레플리케이션 컨트롤러 자체를
삭제하기 전에 각 파드를 삭제하기를 기다린다. 이 kubectl 명령이 인터럽트되면 다시 시작할 수 있다.</p><p>REST API나 <a href=/ko/docs/reference/using-api/client-libraries>클라이언트 라이브러리</a>를 사용하는 경우
명시적으로 단계를 수행해야 한다(레플리카를 0으로 스케일하고 파드의 삭제를 기다린 이후, 레플리케이션 컨트롤러를 삭제).</p><h3 id=레플리케이션-컨트롤러만-삭제>레플리케이션 컨트롤러만 삭제</h3><p>해당 파드에 영향을 주지 않고 레플리케이션 컨트롤러를 삭제할 수 있다.</p><p>kubectl을 사용하여, <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>에 옵션으로 <code>--cascade=orphan</code>을 지정하라.</p><p>REST API나 <a href=/ko/docs/reference/using-api/client-libraries>클라이언트 라이브러리</a>를 사용하는 경우 레플리케이션 컨트롤러 오브젝트를 삭제하라.</p><p>원본이 삭제되면 대체할 새로운 레플리케이션 컨트롤러를 생성하여 교체할 수 있다. 오래된 파드와 새로운 파드의 <code>.spec.selector</code> 가 동일하다면,
새로운 레플리케이션 컨트롤러는 오래된 파드를 채택할 것이다. 그러나 기존 파드를
새로운 파드 템플릿과 일치시키려는 노력은 하지 않을 것이다.
새로운 spec에 대한 파드를 제어된 방법으로 업데이트하려면 <a href=#%EB%A1%A4%EB%A7%81-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>롤링 업데이트</a>를 사용하라.</p><h3 id=레플리케이션-컨트롤러에서-파드-격리>레플리케이션 컨트롤러에서 파드 격리</h3><p>파드는 레이블을 변경하여 레플리케이션 컨트롤러의 대상 셋에서 제거될 수 있다. 이 기술은 디버깅과 데이터 복구를 위해 서비스에서 파드를 제거하는 데 사용될 수 있다. 이 방법으로 제거된 파드는 자동으로 교체된다 (레플리카 수가 변경되지 않는다고 가정).</p><h2 id=일반적인-사용법-패턴>일반적인 사용법 패턴</h2><h3 id=다시-스케줄하기>다시 스케줄하기</h3><p>위에서 언급했듯이, 실행하려는 파드가 한 개 혹은 1000개이든 관계없이 레플리케이션 컨트롤러는 노드 실패 또는 파드 종료시 지정된 수의 파드가 존재하도록 보장한다 (예 : 다른 제어 에이전트에 의한 동작으로 인해).</p><h3 id=스케일링>스케일링</h3><p>레플리케이션컨트롤러는 <code>replicas</code> 필드를 업데이트하여, 수동으로 또는 오토 스케일링 제어 에이전트를 통해, 레플리카의 수를 늘리거나 줄일 수 있다.</p><h3 id=롤링-업데이트>롤링 업데이트</h3><p>레플리케이션 컨트롤러는 파드를 하나씩 교체함으로써 서비스에 대한 롤링 업데이트를 쉽게 하도록 설계되었다.</p><p><a href=https://issue.k8s.io/1353>#1353</a>에서 설명한 것처럼, 권장되는 접근법은 1 개의 레플리카를 가진 새로운 레플리케이션 컨트롤러를 생성하고 새로운 (+1) 컨트롤러 및 이전 (-1) 컨트롤러를 차례대로 스케일한 후 0개의 레플리카가 되면 이전 컨트롤러를 삭제하는 것이다. 예상치 못한 오류와 상관없이 파드 세트를 예측 가능하게 업데이트한다.</p><p>이상적으로 롤링 업데이트 컨트롤러는 애플리케이션 준비 상태를 고려하며 주어진 시간에 충분한 수의 파드가 생산적으로 제공되도록 보장할 것이다.</p><p>두 레플리케이션 컨트롤러는 일반적으로 롤링 업데이트를 동기화 하는 이미지 업데이트이기 때문에 파드의 기본 컨테이너 이미지 태그와 같이 적어도 하나의 차별화된 레이블로 파드를 생성해야 한다.</p><h3 id=다수의-릴리스-트랙>다수의 릴리스 트랙</h3><p>롤링 업데이트가 진행되는 동안 다수의 애플리케이션 릴리스를 실행하는 것 외에도 다수의 릴리스 트랙을 사용하여 장기간에 걸쳐 또는 연속적으로 실행하는 것이 일반적이다. 트랙은 레이블 별로 구분된다.</p><p>예를 들어, 서비스는 <code>tier in (frontend), environment in (prod)</code> 이 있는 모든 파드를 대상으로 할 수 있다. 이제 이 계층을 구성하는 10 개의 복제된 파드가 있다고 가정해 보자. 하지만 이 구성 요소의 새로운 버전을 '카나리' 하기를 원한다. 대량의 레플리카에 대해 <code>replicas</code> 를 9로 설정하고 <code>tier=frontend, environment=prod, track=stable</code> 레이블을 설정한 레플리케이션 컨트롤러와, 카나리에 <code>replicas</code> 가 1로 설정된 다른 레플리케이션 컨트롤러에 <code>tier=frontend, environment=prod, track=canary</code> 라는 레이블을 설정할 수 있다. 이제 이 서비스는 카나리와 카나리 이외의 파드 모두를 포함한다. 그러나 레플리케이션 컨트롤러를 별도로 조작하여 테스트하고 결과를 모니터링하는 등의 작업이 혼란스러울 수 있다.</p><h3 id=서비스와-레플리케이션컨트롤러-사용>서비스와 레플리케이션컨트롤러 사용</h3><p>하나의 서비스 뒤에 여러 개의 레플리케이션컨트롤러가 있을 수 있다.
예를 들어 일부 트래픽은 이전 버전으로 이동하고 일부는 새 버전으로 이동한다.</p><p>레플리케이션컨트롤러는 자체적으로 종료되지 않지만, 서비스만큼 오래 지속될 것으로 기대되지는 않는다. 서비스는 여러 레플리케이션컨트롤러에 의해 제어되는 파드로 구성될 수 있으며, 서비스 라이프사이클 동안(예를 들어, 서비스를 실행하는 파드 업데이트 수행을 위해) 많은 레플리케이션컨트롤러가 생성 및 제거될 것으로 예상된다. 서비스 자체와 클라이언트 모두 파드를 유지하는 레플리케이션컨트롤러를 의식하지 않는 상태로 남아 있어야 한다.</p><h2 id=레플리케이션을-위한-프로그램-작성>레플리케이션을 위한 프로그램 작성</h2><p>레플리케이션 컨트롤러에 의해 생성된 파드는 해당 구성이 시간이 지남에 따라 이질적이 될 수 있지만 균일하고 의미상 동일하도록 설계되었다. 이는 레플리카된 상태 스테이트리스 서버에 적합하지만 레플리케이션 컨트롤러를 사용하여 마스터 선출, 샤드 및 워크-풀 애플리케이션의 가용성을 유지할 수도 있다. <a href=https://www.rabbitmq.com/tutorials/tutorial-two-python.html>RabbitMQ work queues</a>와 같은 애플리케이션은 안티패턴으로 간주되는 각 파드의 구성에 대한 정적/일회성 사용자 정의와 반대로 동적 작업 할당 메커니즘을 사용해야 한다. 리소스의 수직 자동 크기 조정 (예 : CPU 또는 메모리)과 같은 수행된 모든 파드 사용자 정의는 레플리케이션 컨트롤러 자체와 달리 다른 온라인 컨트롤러 프로세스에 의해 수행되어야 한다.</p><h2 id=레플리케이션-컨트롤러의-책임>레플리케이션 컨트롤러의 책임</h2><p>레플리케이션 컨트롤러는 의도한 수의 파드가 해당 레이블 셀렉터와 일치하고 동작하는지를 확인한다. 현재, 종료된 파드만 해당 파드의 수에서 제외된다. 향후 시스템에서 사용할 수 있는 <a href=https://issue.k8s.io/620>readiness</a> 및 기타 정보가 고려될 수 있으며 교체 정책에 대한 통제를 더 추가 할 수 있고 외부 클라이언트가 임의로 정교한 교체 또는 스케일 다운 정책을 구현하기 위해 사용할 수 있는 이벤트를 내보낼 계획이다.</p><p>레플리케이션 컨트롤러는 이 좁은 책임에 영원히 제약을 받는다. 그 자체로는 준비성 또는 활성 프로브를 실행하지 않을 것이다. 오토 스케일링을 수행하는 대신, 외부 오토 스케일러 (<a href=https://issue.k8s.io/492>#492</a>에서 논의된)가 레플리케이션 컨트롤러의 <code>replicas</code> 필드를 변경함으로써 제어되도록 의도되었다. 레플리케이션 컨트롤러에 스케줄링 정책 (예를 들어 <a href=https://issue.k8s.io/367#issuecomment-48428019>spreading</a>)을 추가하지 않을 것이다. 오토사이징 및 기타 자동화 된 프로세스를 방해할 수 있으므로 제어된 파드가 현재 지정된 템플릿과 일치하는지 확인해야 한다. 마찬가지로 기한 완료, 순서 종속성, 구성 확장 및 기타 기능은 다른 곳에 속한다. 대량의 파드 생성 메커니즘 (<a href=https://issue.k8s.io/170>#170</a>)까지도 고려해야 한다.</p><p>레플리케이션 컨트롤러는 조합 가능한 빌딩-블록 프리미티브가 되도록 고안되었다. 향후 사용자의 편의를 위해 더 상위 수준의 API 및/또는 도구와 그리고 다른 보완적인 기본 요소가 그 위에 구축 될 것으로 기대한다. 현재 kubectl이 지원하는 "매크로" 작업 (실행, 스케일)은 개념 증명의 예시이다. 예를 들어 <a href=https://netflixtechblog.com/asgard-web-based-cloud-management-and-deployment-2c9fc4e4d3a1>Asgard</a>와 같이 레플리케이션 컨트롤러, 오토 스케일러, 서비스, 정책 스케줄링, 카나리 등을 관리할 수 있다.</p><h2 id=api-오브젝트>API 오브젝트</h2><p>레플리케이션 컨트롤러는 쿠버네티스 REST API의 최상위 수준의 리소스이다.
API 오브젝트에 대한 더 자세한 것은
<a href=/docs/reference/generated/kubernetes-api/v1.25/#replicationcontroller-v1-core>ReplicationController API object</a> 에서 찾을 수 있다.</p><h2 id=레플리케이션-컨트롤러의-대안>레플리케이션 컨트롤러의 대안</h2><h3 id=레플리카셋>레플리카셋</h3><p><a href=/ko/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>은 새로운 <a href=/ko/docs/concepts/overview/working-with-objects/labels/#%EC%A7%91%ED%95%A9%EC%84%B1-%EA%B8%B0%EC%A4%80-%EC%9A%94%EA%B1%B4>집합성 기준 레이블 셀렉터</a>이다.
이것은 주로 <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>에 의해 파드의 생성, 삭제 및 업데이트를 오케스트레이션 하는 메커니즘으로 사용된다.
사용자 지정 업데이트 조정이 필요하거나 업데이트가 필요하지 않은 경우가 아니면 레플리카셋을 직접 사용하는 대신 디플로이먼트를 사용하는 것이 좋다.</p><h3 id=디플로이먼트-권장됨>디플로이먼트 (권장됨)</h3><p><a href=/ko/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>는 기본 레플리카셋과 그 파드를 업데이트하는 상위 수준의 API 오브젝트이다. 선언적이며, 서버 사이드이고, 추가 기능이 있기 때문에 롤링 업데이트 기능을 원한다면 디플로이먼트를 권장한다.</p><h3 id=베어-파드>베어 파드</h3><p>사용자가 직접 파드를 만든 경우와 달리 레플리케이션 컨트롤러는 노드 오류 또는 커널 업그레이드와 같은 장애가 발생하는 노드 유지 관리의 경우와 같이 어떤 이유로든 삭제되거나 종료된 파드를 대체한다. 따라서 애플리케이션에 하나의 파드만 필요한 경우에도 레플리케이션 컨트롤러를 사용하는 것이 좋다. 프로세스 관리자와 비슷하게 생각하면, 단지 단일 노드의 개별 프로세스가 아닌 여러 노드에서 여러 파드를 감독하는 것이다. 레플리케이션 컨트롤러는 로컬 컨테이너가 노드의 에이전트로 (예를 들어 Kubelet 또는 도커 ) 재시작하도록 위임한다.</p><h3 id=잡>잡</h3><p>자체적으로 제거될 것으로 예상되는 파드 (즉, 배치 잡)의 경우
레플리케이션 컨트롤러 대신 <a href=/ko/docs/concepts/workloads/controllers/job/><code>Job</code></a>을 사용하라.</p><h3 id=데몬셋>데몬셋</h3><p>머신 모니터링이나 머신 로깅과 같은 머신 레벨 기능을 제공하는 파드에는 레플리케이션 컨트롤러 대신
<a href=/ko/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>을 사용하라. 이런 파드들의 수명은 머신의 수명에 달려 있다.
다른 파드가 시작되기 전에 파드가 머신에서 실행되어야 하며,
머신이 재부팅/종료 준비가 되어 있을 때 안전하게 종료된다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/workloads/pods>파드</a>에 대해 배운다.</li><li>레플리케이션 컨트롤러를 대신하는 <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>에 대해 배운다.</li><li><code>ReplicationController</code>는 쿠버네티스 REST API의 일부이다.
레플리케이션 컨트롤러 API에 대해 이해하기 위해
<a href=/docs/reference/kubernetes-api/workload-resources/replication-controller-v1/>ReplicationController</a>
오브젝트 정의를 읽는다.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>