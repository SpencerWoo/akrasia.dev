<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/kubectl/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/reference/kubectl/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/reference/kubectl/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/kubectl/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/kubectl/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/kubectl/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/reference/kubectl/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/reference/kubectl/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/reference/kubectl/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/reference/kubectl/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>명령줄 도구 (kubectl) | Kubernetes</title><meta property="og:title" content="명령줄 도구 (kubectl)"><meta property="og:description" content="운영 수준의 컨테이너 오케스트레이션"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/reference/kubectl/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="명령줄 도구 (kubectl)"><meta itemprop=description content="운영 수준의 컨테이너 오케스트레이션"><meta name=twitter:card content="summary"><meta name=twitter:title content="명령줄 도구 (kubectl)"><meta name=twitter:description content="운영 수준의 컨테이너 오케스트레이션"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="쿠버네티스는 다음을 제공한다: 쿠버네티스 API를 사용하여 쿠버네티스 클러스터의 컨트롤 플레인과 통신하기 위한 커맨드라인 툴
이 툴의 이름은 kubectl이다.
구성을 위해, kubectl 은 config 파일을 $HOME/.kube 에서 찾는다. KUBECONFIG 환경 변수를 설정하거나 --kubeconfig 플래그를 설정하여 다른 kubeconfig 파일을 지정할 수 있다.
이 개요는 kubectl 구문을 다루고, 커맨드 동작을 설명하며, 일반적인 예제를 제공한다. 지원되는 모든 플래그 및 하위 명령을 포함한 각 명령에 대한 자세한 내용은 kubectl 참조 문서를 참고한다.
설치 방법에 대해서는 kubectl 설치를 참고하고, 빠른 가이드는 치트 시트를 참고한다."><meta property="og:description" content="쿠버네티스는 다음을 제공한다: 쿠버네티스 API를 사용하여 쿠버네티스 클러스터의 컨트롤 플레인과 통신하기 위한 커맨드라인 툴
이 툴의 이름은 kubectl이다.
구성을 위해, kubectl 은 config 파일을 $HOME/.kube 에서 찾는다. KUBECONFIG 환경 변수를 설정하거나 --kubeconfig 플래그를 설정하여 다른 kubeconfig 파일을 지정할 수 있다.
이 개요는 kubectl 구문을 다루고, 커맨드 동작을 설명하며, 일반적인 예제를 제공한다. 지원되는 모든 플래그 및 하위 명령을 포함한 각 명령에 대한 자세한 내용은 kubectl 참조 문서를 참고한다.
설치 방법에 대해서는 kubectl 설치를 참고하고, 빠른 가이드는 치트 시트를 참고한다."><meta name=twitter:description content="쿠버네티스는 다음을 제공한다: 쿠버네티스 API를 사용하여 쿠버네티스 클러스터의 컨트롤 플레인과 통신하기 위한 커맨드라인 툴
이 툴의 이름은 kubectl이다.
구성을 위해, kubectl 은 config 파일을 $HOME/.kube 에서 찾는다. KUBECONFIG 환경 변수를 설정하거나 --kubeconfig 플래그를 설정하여 다른 kubeconfig 파일을 지정할 수 있다.
이 개요는 kubectl 구문을 다루고, 커맨드 동작을 설명하며, 일반적인 예제를 제공한다. 지원되는 모든 플래그 및 하위 명령을 포함한 각 명령에 대한 자세한 내용은 kubectl 참조 문서를 참고한다.
설치 방법에 대해서는 kubectl 설치를 참고하고, 빠른 가이드는 치트 시트를 참고한다."><meta property="og:url" content="https://kubernetes.io/ko/docs/reference/kubectl/"><meta property="og:title" content="명령줄 도구 (kubectl)"><meta name=twitter:title content="명령줄 도구 (kubectl)"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/reference/kubectl/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/reference/kubectl/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/reference/kubectl/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/reference/kubectl/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/reference/kubectl/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/reference/kubectl/>English</a>
<a class=dropdown-item href=/zh-cn/docs/reference/kubectl/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/reference/kubectl/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/reference/kubectl/>Français (French)</a>
<a class=dropdown-item href=/de/docs/reference/kubectl/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/reference/kubectl/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/reference/kubectl/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/reference/kubectl/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/reference/kubectl/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/reference/kubectl/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>명령줄 도구 (kubectl)</h1><ul><li>1: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>kubectl 치트 시트</a></li><li>2: <a href=#pg-4d3e62632c189fcc3c1357cd8fb8799c>kubectl</a></li><li>3: <a href=#pg-a938176c695852fe70362c29cf615f1c>JSONPath 지원</a></li><li>4: <a href=#pg-8de6aceb8bf692c06cced446bac5bc92>kubectl 사용 규칙</a></li><li>5: <a href=#pg-a7abc09192597e614b58f8b552b682f5>도커 사용자를 위한 kubectl</a></li></ul><div class=content><p>쿠버네티스는 다음을 제공한다: 쿠버네티스 API를 사용하여
쿠버네티스 클러스터의 <a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>과
통신하기 위한 커맨드라인 툴</p><p>이 툴의 이름은 <code>kubectl</code>이다.</p><p>구성을 위해, <code>kubectl</code> 은 config 파일을 $HOME/.kube 에서 찾는다.
KUBECONFIG 환경 변수를 설정하거나 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/><code>--kubeconfig</code></a>
플래그를 설정하여 다른 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
파일을 지정할 수 있다.</p><p>이 개요는 <code>kubectl</code> 구문을 다루고, 커맨드 동작을 설명하며, 일반적인 예제를 제공한다.
지원되는 모든 플래그 및 하위 명령을 포함한 각 명령에 대한 자세한 내용은
<a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a> 참조 문서를 참고한다.</p><p>설치 방법에 대해서는 <a href=/ko/docs/tasks/tools/>kubectl 설치</a>를 참고하고,
빠른 가이드는 <a href=/ko/docs/reference/kubectl/cheatsheet/>치트 시트</a>를 참고한다. <code>docker</code> 명령줄 도구에 익숙하다면,
<a href=/ko/docs/reference/kubectl/docker-cli-to-kubectl/>도커 사용자를 위한 <code>kubectl</code></a>에서 대응되는 쿠버네티스 명령어를 볼 수 있다.</p><h2 id=구문>구문</h2><p>터미널 창에서 <code>kubectl</code> 명령을 실행하려면 다음의 구문을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> <span style=color:#666>[</span>flags<span style=color:#666>]</span>
</span></span></code></pre></div><p>다음은 <code>command</code>, <code>TYPE</code>, <code>NAME</code> 과 <code>flags</code> 에 대한 설명이다.</p><ul><li><p><code>command</code>: 하나 이상의 리소스에서 수행하려는 동작을 지정한다.
예: <code>create</code>, <code>get</code>, <code>describe</code>, <code>delete</code></p></li><li><p><code>TYPE</code>: <a href=#%EB%A6%AC%EC%86%8C%EC%8A%A4-%ED%83%80%EC%9E%85>리소스 타입</a>을 지정한다. 리소스 타입은 대소문자를 구분하지 않으며
단수형, 복수형 또는 약어 형식을 지정할 수 있다.
예를 들어, 다음의 명령은 동일한 출력 결과를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod pod1
</span></span><span style=display:flex><span>kubectl get pods pod1
</span></span><span style=display:flex><span>kubectl get po pod1
</span></span></code></pre></div></li><li><p><code>NAME</code>: 리소스 이름을 지정한다. 이름은 대소문자를 구분한다. 이름을 생략하면, 모든 리소스에 대한 세부 사항이 표시된다. 예: <code>kubectl get pods</code></p><p>여러 리소스에 대한 작업을 수행할 때, 타입 및 이름별로 각 리소스를 지정하거나 하나 이상의 파일을 지정할 수 있다.</p><ul><li><p>타입 및 이름으로 리소스를 지정하려면 다음을 참고한다.</p><ul><li><p>리소스가 모두 동일한 타입인 경우 리소스를 그룹화하려면 다음을 사용한다. <code>TYPE1 name1 name2 name&lt;#></code><br>예: <code>kubectl get pod example-pod1 example-pod2</code></p></li><li><p>여러 리소스 타입을 개별적으로 지정하려면 다음을 사용한다. <code>TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE&lt;#>/name&lt;#></code><br>예: <code>kubectl get pod/example-pod1 replicationcontroller/example-rc1</code></p></li></ul></li><li><p>하나 이상의 파일로 리소스를 지정하려면 다음을 사용한다. <code>-f file1 -f file2 -f file&lt;#></code></p><ul><li>YAML이 특히 구성 파일에 대해 더 사용자 친화적이므로, <a href=/ko/docs/concepts/configuration/overview/#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EA%B5%AC%EC%84%B1-%ED%8C%81>JSON 대신 YAML을 사용한다</a>.<br>예: <code>kubectl get -f ./pod.yaml</code></li></ul></li></ul></li><li><p><code>flags</code>: 선택적 플래그를 지정한다. 예를 들어, <code>-s</code> 또는 <code>--server</code> 플래그를 사용하여 쿠버네티스 API 서버의 주소와 포트를 지정할 수 있다.<br></p></li></ul><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 커맨드 라인에서 지정하는 플래그는 기본값과 해당 환경 변수를 무시한다.</div><p>도움이 필요하다면, 터미널 창에서 <code>kubectl help</code> 를 실행한다.</p><h2 id=클러스터-내-인증과-네임스페이스-오버라이드>클러스터 내 인증과 네임스페이스 오버라이드</h2><p>기본적으로 <code>kubectl</code>은 먼저 자신이 파드 안에서 실행되고 있는지, 즉 클러스터 안에 있는지를 판별한다. 이를 위해 <code>KUBERNETES_SERVICE_HOST</code>와 <code>KUBERNETES_SERVICE_PORT</code> 환경 변수, 그리고 서비스 어카운트 토큰 파일이 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 경로에 있는지를 확인한다. 세 가지가 모두 감지되면, 클러스터 내 인증이 적용된다.</p><p>하위 호환성을 위해, 클러스터 내 인증 시에 <code>POD_NAMESPACE</code> 환경 변수가 설정되어 있으면, 서비스 어카운트 토큰의 기본 네임스페이스 설정을 오버라이드한다. 기본 네임스페이스 설정에 의존하는 모든 매니페스트와 도구가 영향을 받을 것이다.</p><p><strong><code>POD_NAMESPACE</code> 환경 변수</strong></p><p><code>POD_NAMESPACE</code> 환경 변수가 설정되어 있으면, 네임스페이스에 속하는 자원에 대한 CLI 작업은 환경 변수에 설정된 네임스페이스를 기본값으로 사용한다. 예를 들어, 환경 변수가 <code>seattle</code>로 설정되어 있으면, <code>kubectl get pods</code> 명령은 <code>seattle</code> 네임스페이스에 있는 파드 목록을 반환한다. 이는 파드가 네임스페이스에 속하는 자원이며, 명령어에 네임스페이스를 특정하지 않았기 때문이다. <code>kubectl api-resources</code> 명령을 실행하고 결과를 확인하여 특정 자원이 네임스페이스에 속하는 자원인지 판별한다.</p><p>명시적으로 <code>--namespace &lt;value></code> 인자를 사용하면 위와 같은 동작을 오버라이드한다.</p><p><strong>kubectl이 서비스어카운트 토큰을 관리하는 방법</strong></p><p>만약</p><ul><li>쿠버네티스 서비스 어카운트 토큰 파일이
<code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 경로에 마운트되어 있고,</li><li><code>KUBERNETES_SERVICE_HOST</code> 환경 변수가 설정되어 있고,</li><li><code>KUBERNETES_SERVICE_PORT</code> 환경 변수가 설정되어 있고,</li><li>kubectl 명령에 네임스페이스를 명시하지 않으면</li></ul><p>kubectl은 자신이 클러스터 내부에서 실행되고 있다고 가정한다.
kubectl은 해당 서비스어카운트의 네임스페이스(파드의 네임스페이스와 동일하다)를 인식하고 해당 네임스페이스에 대해 동작한다.
이는 클러스터 외부에서 실행되었을 때와는 다른데,
kubectl이 클러스터 외부에서 실행되었으며 네임스페이스가 명시되지 않은 경우
kubectl은 <code>default</code> 네임스페이스에 대해 동작한다.</p><h2 id=명령어>명령어</h2><p>다음 표에는 모든 <code>kubectl</code> 작업에 대한 간단한 설명과 일반적인 구문이 포함되어 있다.</p><table><thead><tr><th>명령어</th><th>구문</th><th>설명</th></tr></thead><tbody><tr><td><code>alpha</code></td><td><code>kubectl alpha SUBCOMMAND [flags]</code></td><td>쿠버네티스 클러스터에서 기본적으로 활성화되어 있지 않은 알파 기능의 사용할 수 있는 명령을 나열한다.</td></tr><tr><td><code>annotate</code></td><td><code>kubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td><td>하나 이상의 리소스 어노테이션을 추가하거나 업데이트한다.</td></tr><tr><td><code>api-resources</code></td><td><code>kubectl api-resources [flags]</code></td><td>사용 가능한 API 리소스를 나열한다.</td></tr><tr><td><code>api-versions</code></td><td><code>kubectl api-versions [flags]</code></td><td>사용 가능한 API 버전을 나열한다.</td></tr><tr><td><code>apply</code></td><td><code>kubectl apply -f FILENAME [flags]</code></td><td>파일이나 표준입력(stdin)으로부터 리소스에 구성 변경 사항을 적용한다.</td></tr><tr><td><code>attach</code></td><td><code>kubectl attach POD -c CONTAINER [-i] [-t] [flags]</code></td><td>실행 중인 컨테이너에 연결하여 출력 스트림을 보거나 표준입력을 통해 컨테이너와 상호 작용한다.</td></tr><tr><td><code>auth</code></td><td><code>kubectl auth [flags] [options]</code></td><td>승인을 검사한다.</td></tr><tr><td><code>autoscale</code></td><td><code>kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></td><td>레플리케이션 컨트롤러에서 관리하는 파드 집합을 자동으로 조정한다.</td></tr><tr><td><code>certificate</code></td><td><code>kubectl certificate SUBCOMMAND [options]</code></td><td>인증서 리소스를 수정한다.</td></tr><tr><td><code>cluster-info</code></td><td><code>kubectl cluster-info [flags]</code></td><td>클러스터의 마스터와 서비스에 대한 엔드포인트 정보를 표시한다.</td></tr><tr><td><code>completion</code></td><td><code>kubectl completion SHELL [options]</code></td><td>지정된 셸(bash 또는 zsh)에 대한 셸 완성 코드를 출력한다.</td></tr><tr><td><code>config</code></td><td><code>kubectl config SUBCOMMAND [flags]</code></td><td>kubeconfig 파일을 수정한다. 세부 사항은 개별 하위 명령을 참고한다.</td></tr><tr><td><code>convert</code></td><td><code>kubectl convert -f FILENAME [options]</code></td><td>다른 API 버전 간에 구성 파일을 변환한다. YAML 및 JSON 형식이 모두 허용된다. 참고 - <code>kubectl-convert</code> 플러그인을 설치해야 한다.</td></tr><tr><td><code>cordon</code></td><td><code>kubectl cordon NODE [options]</code></td><td>노드를 스케줄 불가능(unschedulable)으로 표시한다.</td></tr><tr><td><code>cp</code></td><td><code>kubectl cp &lt;file-spec-src> &lt;file-spec-dest> [options]</code></td><td>컨테이너에서 그리고 컨테이너로 파일 및 디렉터리를 복사한다.</td></tr><tr><td><code>create</code></td><td><code>kubectl create -f FILENAME [flags]</code></td><td>파일이나 표준입력에서 하나 이상의 리소스를 생성한다.</td></tr><tr><td><code>delete</code></td><td><code>kubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]</code></td><td>파일, 표준입력 또는 레이블 셀렉터, 이름, 리소스 셀렉터 또는 리소스를 지정하여 리소스를 삭제한다.</td></tr><tr><td><code>describe</code></td><td><code>kubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]</code></td><td>하나 이상의 리소스의 자세한 상태를 표시한다.</td></tr><tr><td><code>diff</code></td><td><code>kubectl diff -f FILENAME [flags]</code></td><td>라이브 구성에 대해 파일이나 표준입력의 차이점을 출력한다.</td></tr><tr><td><code>drain</code></td><td><code>kubectl drain NODE [options]</code></td><td>유지 보수를 준비 중인 노드를 드레인한다.</td></tr><tr><td><code>edit</code></td><td><code>kubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]</code></td><td>기본 편집기를 사용하여 서버에서 하나 이상의 리소스 정의를 편집하고 업데이트한다.</td></tr><tr><td><code>exec</code></td><td><code>kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]</code></td><td>파드의 컨테이너에 대해 명령을 실행한다.</td></tr><tr><td><code>explain</code></td><td><code>kubectl explain [--recursive=false] [flags]</code></td><td>파드, 노드, 서비스 등의 다양한 리소스에 대한 문서를 출력한다.</td></tr><tr><td><code>expose</code></td><td><code>kubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code></td><td>레플리케이션 컨트롤러, 서비스 또는 파드를 새로운 쿠버네티스 서비스로 노출한다.</td></tr><tr><td><code>get</code></td><td><code>kubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]</code></td><td>하나 이상의 리소스를 나열한다.</td></tr><tr><td><code>kustomize</code></td><td><code>kubectl kustomize &lt;dir> [flags] [options]</code></td><td>kustomization.yaml 파일의 지시 사항에서 생성된 API 리소스 집합을 나열한다. 인수는 파일을 포함하는 디렉터리의 경로이거나, 리포지터리 루트와 관련하여 경로 접미사가 동일한 git 리포지터리 URL이어야 한다.</td></tr><tr><td><code>label</code></td><td><code>kubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td><td>하나 이상의 리소스 레이블을 추가하거나 업데이트한다.</td></tr><tr><td><code>logs</code></td><td><code>kubectl logs POD [-c CONTAINER] [--follow] [flags]</code></td><td>파드의 컨테이너에 대한 로그를 출력한다.</td></tr><tr><td><code>options</code></td><td><code>kubectl options</code></td><td>모든 명령에 적용되는 전역 커맨드 라인 옵션을 나열한다.</td></tr><tr><td><code>patch</code></td><td><code>kubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]</code></td><td>전략적 병합 패치 프로세스를 사용하여 리소스의 하나 이상의 필드를 업데이트한다.</td></tr><tr><td><code>plugin</code></td><td><code>kubectl plugin [flags] [options]</code></td><td>플러그인과 상호 작용하기 위한 유틸리티를 제공한다.</td></tr><tr><td><code>port-forward</code></td><td><code>kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]</code></td><td>하나 이상의 로컬 포트를 파드로 전달한다.</td></tr><tr><td><code>proxy</code></td><td><code>kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</code></td><td>쿠버네티스 API 서버에 프록시를 실행한다.</td></tr><tr><td><code>replace</code></td><td><code>kubectl replace -f FILENAME</code></td><td>파일 또는 표준입력에서 리소스를 교체한다.</td></tr><tr><td><code>rollout</code></td><td><code>kubectl rollout SUBCOMMAND [options]</code></td><td>리소스의 롤아웃을 관리한다. 유효한 리소스 타입에는 디플로이먼트(deployment), 데몬셋(daemonset)과 스테이트풀셋(statefulset)이 포함된다.</td></tr><tr><td><code>run</code></td><td><code>kubectl run NAME --image=image [--env="key=value"] [--port=port] [--dry-run=server|client|none] [--overrides=inline-json] [flags]</code></td><td>클러스터에서 지정된 이미지를 실행한다.</td></tr><tr><td><code>scale</code></td><td><code>kubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code></td><td>지정된 레플리케이션 컨트롤러의 크기를 업데이트한다.</td></tr><tr><td><code>set</code></td><td><code>kubectl set SUBCOMMAND [options]</code></td><td>애플리케이션 리소스를 구성한다.</td></tr><tr><td><code>taint</code></td><td><code>kubectl taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N [options]</code></td><td>하나 이상의 노드에서 테인트(taint)를 업데이트한다.</td></tr><tr><td><code>top</code></td><td><code>kubectl top [flags] [options]</code></td><td>리소스(CPU/메모리/스토리지) 사용량을 표시한다.</td></tr><tr><td><code>uncordon</code></td><td><code>kubectl uncordon NODE [options]</code></td><td>노드를 스케줄 가능(schedulable)으로 표시한다.</td></tr><tr><td><code>version</code></td><td><code>kubectl version [--client] [flags]</code></td><td>클라이언트와 서버에서 실행 중인 쿠버네티스 버전을 표시한다.</td></tr><tr><td><code>wait</code></td><td><code>kubectl wait ([-f FILENAME] | resource.group/resource.name | resource.group [(-l label | --all)]) [--for=delete|--for condition=available] [options]</code></td><td>실험(experimental) 기능: 하나 이상의 리소스에서 특정 조건을 기다린다.</td></tr></tbody></table><p>명령 동작에 대한 자세한 내용을 배우려면 <a href=/ko/docs/reference/kubectl/kubectl/>kubectl</a> 참조 문서를 참고한다.</p><h2 id=리소스-타입>리소스 타입</h2><p>다음 표에는 지원되는 모든 리소스 타입과 해당 약어가 나열되어 있다.</p><p>(이 출력은 <code>kubectl api-resources</code> 에서 확인할 수 있으며, 쿠버네티스 1.19.1 에서의 출력을 기준으로 한다.)</p><table><thead><tr><th>NAME</th><th>SHORTNAMES</th><th>APIGROUP</th><th>NAMESPACED</th><th>KIND</th></tr></thead><tbody><tr><td><code>bindings</code></td><td></td><td></td><td>true</td><td>Binding</td></tr><tr><td><code>componentstatuses</code></td><td><code>cs</code></td><td></td><td>false</td><td>ComponentStatus</td></tr><tr><td><code>configmaps</code></td><td><code>cm</code></td><td></td><td>true</td><td>ConfigMap</td></tr><tr><td><code>endpoints</code></td><td><code>ep</code></td><td></td><td>true</td><td>Endpoints</td></tr><tr><td><code>events</code></td><td><code>ev</code></td><td></td><td>true</td><td>Event</td></tr><tr><td><code>limitranges</code></td><td><code>limits</code></td><td></td><td>true</td><td>LimitRange</td></tr><tr><td><code>namespaces</code></td><td><code>ns</code></td><td></td><td>false</td><td>Namespace</td></tr><tr><td><code>nodes</code></td><td><code>no</code></td><td></td><td>false</td><td>Node</td></tr><tr><td><code>persistentvolumeclaims</code></td><td><code>pvc</code></td><td></td><td>true</td><td>PersistentVolumeClaim</td></tr><tr><td><code>persistentvolumes</code></td><td><code>pv</code></td><td></td><td>false</td><td>PersistentVolume</td></tr><tr><td><code>pods</code></td><td><code>po</code></td><td></td><td>true</td><td>Pod</td></tr><tr><td><code>podtemplates</code></td><td></td><td></td><td>true</td><td>PodTemplate</td></tr><tr><td><code>replicationcontrollers</code></td><td><code>rc</code></td><td></td><td>true</td><td>ReplicationController</td></tr><tr><td><code>resourcequotas</code></td><td><code>quota</code></td><td></td><td>true</td><td>ResourceQuota</td></tr><tr><td><code>secrets</code></td><td></td><td></td><td>true</td><td>Secret</td></tr><tr><td><code>serviceaccounts</code></td><td><code>sa</code></td><td></td><td>true</td><td>ServiceAccount</td></tr><tr><td><code>services</code></td><td><code>svc</code></td><td></td><td>true</td><td>Service</td></tr><tr><td><code>mutatingwebhookconfigurations</code></td><td></td><td>admissionregistration.k8s.io</td><td>false</td><td>MutatingWebhookConfiguration</td></tr><tr><td><code>validatingwebhookconfigurations</code></td><td></td><td>admissionregistration.k8s.io</td><td>false</td><td>ValidatingWebhookConfiguration</td></tr><tr><td><code>customresourcedefinitions</code></td><td><code>crd,crds</code></td><td>apiextensions.k8s.io</td><td>false</td><td>CustomResourceDefinition</td></tr><tr><td><code>apiservices</code></td><td></td><td>apiregistration.k8s.io</td><td>false</td><td>APIService</td></tr><tr><td><code>controllerrevisions</code></td><td></td><td>apps</td><td>true</td><td>ControllerRevision</td></tr><tr><td><code>daemonsets</code></td><td><code>ds</code></td><td>apps</td><td>true</td><td>DaemonSet</td></tr><tr><td><code>deployments</code></td><td><code>deploy</code></td><td>apps</td><td>true</td><td>Deployment</td></tr><tr><td><code>replicasets</code></td><td><code>rs</code></td><td>apps</td><td>true</td><td>ReplicaSet</td></tr><tr><td><code>statefulsets</code></td><td><code>sts</code></td><td>apps</td><td>true</td><td>StatefulSet</td></tr><tr><td><code>tokenreviews</code></td><td></td><td>authentication.k8s.io</td><td>false</td><td>TokenReview</td></tr><tr><td><code>localsubjectaccessreviews</code></td><td></td><td>authorization.k8s.io</td><td>true</td><td>LocalSubjectAccessReview</td></tr><tr><td><code>selfsubjectaccessreviews</code></td><td></td><td>authorization.k8s.io</td><td>false</td><td>SelfSubjectAccessReview</td></tr><tr><td><code>selfsubjectrulesreviews</code></td><td></td><td>authorization.k8s.io</td><td>false</td><td>SelfSubjectRulesReview</td></tr><tr><td><code>subjectaccessreviews</code></td><td></td><td>authorization.k8s.io</td><td>false</td><td>SubjectAccessReview</td></tr><tr><td><code>horizontalpodautoscalers</code></td><td><code>hpa</code></td><td>autoscaling</td><td>true</td><td>HorizontalPodAutoscaler</td></tr><tr><td><code>cronjobs</code></td><td><code>cj</code></td><td>batch</td><td>true</td><td>CronJob</td></tr><tr><td><code>jobs</code></td><td></td><td>batch</td><td>true</td><td>Job</td></tr><tr><td><code>certificatesigningrequests</code></td><td><code>csr</code></td><td>certificates.k8s.io</td><td>false</td><td>CertificateSigningRequest</td></tr><tr><td><code>leases</code></td><td></td><td>coordination.k8s.io</td><td>true</td><td>Lease</td></tr><tr><td><code>endpointslices</code></td><td></td><td>discovery.k8s.io</td><td>true</td><td>EndpointSlice</td></tr><tr><td><code>events</code></td><td><code>ev</code></td><td>events.k8s.io</td><td>true</td><td>Event</td></tr><tr><td><code>ingresses</code></td><td><code>ing</code></td><td>extensions</td><td>true</td><td>Ingress</td></tr><tr><td><code>flowschemas</code></td><td></td><td>flowcontrol.apiserver.k8s.io</td><td>false</td><td>FlowSchema</td></tr><tr><td><code>prioritylevelconfigurations</code></td><td></td><td>flowcontrol.apiserver.k8s.io</td><td>false</td><td>PriorityLevelConfiguration</td></tr><tr><td><code>ingressclasses</code></td><td></td><td>networking.k8s.io</td><td>false</td><td>IngressClass</td></tr><tr><td><code>ingresses</code></td><td><code>ing</code></td><td>networking.k8s.io</td><td>true</td><td>Ingress</td></tr><tr><td><code>networkpolicies</code></td><td><code>netpol</code></td><td>networking.k8s.io</td><td>true</td><td>NetworkPolicy</td></tr><tr><td><code>runtimeclasses</code></td><td></td><td>node.k8s.io</td><td>false</td><td>RuntimeClass</td></tr><tr><td><code>poddisruptionbudgets</code></td><td><code>pdb</code></td><td>policy</td><td>true</td><td>PodDisruptionBudget</td></tr><tr><td><code>podsecuritypolicies</code></td><td><code>psp</code></td><td>policy</td><td>false</td><td>PodSecurityPolicy</td></tr><tr><td><code>clusterrolebindings</code></td><td></td><td>rbac.authorization.k8s.io</td><td>false</td><td>ClusterRoleBinding</td></tr><tr><td><code>clusterroles</code></td><td></td><td>rbac.authorization.k8s.io</td><td>false</td><td>ClusterRole</td></tr><tr><td><code>rolebindings</code></td><td></td><td>rbac.authorization.k8s.io</td><td>true</td><td>RoleBinding</td></tr><tr><td><code>roles</code></td><td></td><td>rbac.authorization.k8s.io</td><td>true</td><td>Role</td></tr><tr><td><code>priorityclasses</code></td><td><code>pc</code></td><td>scheduling.k8s.io</td><td>false</td><td>PriorityClass</td></tr><tr><td><code>csidrivers</code></td><td></td><td>storage.k8s.io</td><td>false</td><td>CSIDriver</td></tr><tr><td><code>csinodes</code></td><td></td><td>storage.k8s.io</td><td>false</td><td>CSINode</td></tr><tr><td><code>storageclasses</code></td><td><code>sc</code></td><td>storage.k8s.io</td><td>false</td><td>StorageClass</td></tr><tr><td><code>volumeattachments</code></td><td></td><td>storage.k8s.io</td><td>false</td><td>VolumeAttachment</td></tr></tbody></table><h2 id=출력-옵션>출력 옵션</h2><p>특정 명령의 출력을 서식화하거나 정렬하는 방법에 대한 정보는 다음 섹션을 참고한다. 다양한 출력 옵션을 지원하는 명령에 대한 자세한 내용은 <a href=/ko/docs/reference/kubectl/kubectl/>kubectl</a> 참조 문서를 참고한다.</p><h3 id=출력-서식화>출력 서식화</h3><p>모든 <code>kubectl</code> 명령의 기본 출력 형식은 사람이 읽을 수 있는 일반 텍스트 형식이다. 특정 형식으로 터미널 창에 세부 정보를 출력하려면, 지원되는 <code>kubectl</code> 명령에 <code>-o</code> 또는 <code>--output</code> 플래그를 추가할 수 있다.</p><h4 id=구문-1>구문</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> -o &lt;output_format&gt;
</span></span></code></pre></div><p><code>kubectl</code> 명령에 따라, 다음과 같은 출력 형식이 지원된다.</p><table><thead><tr><th>출력 형식</th><th>설명</th></tr></thead><tbody><tr><td><code>-o custom-columns=&lt;spec></code></td><td>쉼표로 구분된 <a href=#custom-columns>사용자 정의 열</a> 목록을 사용하여 테이블을 출력한다.</td></tr><tr><td><code>-o custom-columns-file=&lt;filename></code></td><td><code>&lt;filename></code> 파일에서 <a href=#custom-columns>사용자 정의 열</a> 템플릿을 사용하여 테이블을 출력한다.</td></tr><tr><td><code>-o json</code></td><td>JSON 형식의 API 오브젝트를 출력한다.</td></tr><tr><td><code>-o jsonpath=&lt;template></code></td><td><a href=/ko/docs/reference/kubectl/jsonpath/>jsonpath</a> 표현식에 정의된 필드를 출력한다.</td></tr><tr><td><code>-o jsonpath-file=&lt;filename></code></td><td><code>&lt;filename></code> 파일에서 <a href=/ko/docs/reference/kubectl/jsonpath/>jsonpath</a> 표현식으로 정의된 필드를 출력한다.</td></tr><tr><td><code>-o name</code></td><td>리소스 이름만 출력한다.</td></tr><tr><td><code>-o wide</code></td><td>추가 정보가 포함된 일반 텍스트 형식으로 출력된다. 파드의 경우, 노드 이름이 포함된다.</td></tr><tr><td><code>-o yaml</code></td><td>YAML 형식의 API 오브젝트를 출력한다.</td></tr></tbody></table><h5 id=예제>예제</h5><p>이 예제에서, 다음의 명령은 단일 파드에 대한 세부 정보를 YAML 형식의 오브젝트로 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod web-pod-13je7 -o yaml
</span></span></code></pre></div><p>기억하기: 각 명령이 지원하는 출력 형식에 대한 자세한 내용은
<a href=/ko/docs/reference/kubectl/kubectl/>kubectl</a> 참조 문서를 참고한다.</p><h4 id=custom-columns>사용자 정의 열</h4><p>사용자 정의 열을 정의하고 원하는 세부 정보만 테이블에 출력하려면, <code>custom-columns</code> 옵션을 사용할 수 있다.
사용자 정의 열을 인라인으로 정의하거나 템플릿 파일을 사용하도록 선택할 수 있다. <code>-o custom-columns=&lt;spec></code> 또는 <code>-o custom-columns-file=&lt;filename></code></p><h5 id=예제-1>예제</h5><p>인라인:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; -o custom-columns<span style=color:#666>=</span>NAME:.metadata.name,RSRC:.metadata.resourceVersion
</span></span></code></pre></div><p>템플릿 파일:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; -o custom-columns-file<span style=color:#666>=</span>template.txt
</span></span></code></pre></div><p><code>template.txt</code> 파일에 포함된 내용은 다음과 같다.</p><pre tabindex=0><code>NAME          RSRC
metadata.name metadata.resourceVersion
</code></pre><p>두 명령 중 하나를 실행한 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME           RSRC
submit-queue   610995
</code></pre><h4 id=서버측-열>서버측 열</h4><p><code>kubectl</code> 는 서버에서 오브젝트에 대한 특정 열 정보 수신을 지원한다.
이는 클라이언트가 출력할 수 있도록, 주어진 리소스에 대해 서버가 해당 리소스와 관련된 열과 행을 반환한다는 것을 의미한다.
이는 서버가 출력의 세부 사항을 캡슐화하도록 하여, 동일한 클러스터에 대해 사용된 클라이언트에서 사람이 읽을 수 있는 일관된 출력을 허용한다.</p><p>이 기능은 기본적으로 활성화되어 있다. 사용하지 않으려면,
<code>kubectl get</code> 명령에 <code>--server-print=false</code> 플래그를 추가한다.</p><h5 id=예제-2>예제</h5><p>파드 상태에 대한 정보를 출력하려면, 다음과 같은 명령을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; --server-print<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME       AGE
pod-name   1m
</code></pre><h3 id=오브젝트-목록-정렬>오브젝트 목록 정렬</h3><p>터미널 창에서 정렬된 목록으로 오브젝트를 출력하기 위해, 지원되는 <code>kubectl</code> 명령에 <code>--sort-by</code> 플래그를 추가할 수 있다. <code>--sort-by</code> 플래그와 함께 숫자나 문자열 필드를 지정하여 오브젝트를 정렬한다. 필드를 지정하려면, <a href=/ko/docs/reference/kubectl/jsonpath/>jsonpath</a> 표현식을 사용한다.</p><h4 id=구문-2>구문</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> --sort-by<span style=color:#666>=</span>&lt;jsonpath_exp&gt;
</span></span></code></pre></div><h5 id=예제-3>예제</h5><p>이름별로 정렬된 파드 목록을 출력하려면, 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --sort-by<span style=color:#666>=</span>.metadata.name
</span></span></code></pre></div><h2 id=예제-일반적인-작업>예제: 일반적인 작업</h2><p>다음 예제 세트를 사용하여 일반적으로 사용되는 <code>kubectl</code> 조작 실행에 익숙해진다.</p><p><code>kubectl apply</code> - 파일 또는 표준입력에서 리소스를 적용하거나 업데이트한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># example-service.yaml의 정의를 사용하여 서비스를 생성한다.</span>
</span></span><span style=display:flex><span>kubectl apply -f example-service.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># example-controller.yaml의 정의를 사용하여 레플리케이션 컨트롤러를 생성한다.</span>
</span></span><span style=display:flex><span>kubectl apply -f example-controller.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;directory&gt; 디렉터리 내의 .yaml, .yml 또는 .json 파일에 정의된 오브젝트를 생성한다.</span>
</span></span><span style=display:flex><span>kubectl apply -f &lt;directory&gt;
</span></span></code></pre></div><p><code>kubectl get</code> - 하나 이상의 리소스를 나열한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드를 일반 텍스트 출력 형식으로 나열한다.</span>
</span></span><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드를 일반 텍스트 출력 형식으로 나열하고 추가 정보(예: 노드 이름)를 포함한다.</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 지정된 이름의 레플리케이션 컨트롤러를 일반 텍스트 출력 형식으로 나열한다. 팁: &#39;replicationcontroller&#39; 리소스 타입을 &#39;rc&#39;로 짧게 바꿔쓸 수 있다.</span>
</span></span><span style=display:flex><span>kubectl get replicationcontroller &lt;rc-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 레플리케이션 컨트롤러와 서비스를 일반 텍스트 출력 형식으로 함께 나열한다.</span>
</span></span><span style=display:flex><span>kubectl get rc,services
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 데몬 셋을 일반 텍스트 출력 형식으로 나열한다.</span>
</span></span><span style=display:flex><span>kubectl get ds
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 노드 server01에서 실행 중인 모든 파드를 나열한다.</span>
</span></span><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>spec.nodeName<span style=color:#666>=</span>server01
</span></span></code></pre></div><p><code>kubectl describe</code> - 초기화되지 않은 리소스를 포함하여 하나 이상의 리소스의 기본 상태를 디폴트로 표시한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 노드 이름이 &lt;node-name&gt;인 노드의 세부 사항을 표시한다.</span>
</span></span><span style=display:flex><span>kubectl describe nodes &lt;node-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 이름이 &lt;pod-name&gt; 인 파드의 세부 정보를 표시한다.</span>
</span></span><span style=display:flex><span>kubectl describe pods/&lt;pod-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이름이 &lt;rc-name&gt;인 레플리케이션 컨트롤러가 관리하는 모든 파드의 세부 정보를 표시한다.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 기억하기: 레플리케이션 컨트롤러에서 생성된 모든 파드에는 레플리케이션 컨트롤러 이름이 접두사로 붙는다.</span>
</span></span><span style=display:flex><span>kubectl describe pods &lt;rc-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드의 정보를 출력한다.</span>
</span></span><span style=display:flex><span>kubectl describe pods
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubectl get</code> 명령은 일반적으로 동일한 리소스 타입의 하나 이상의
리소스를 검색하는 데 사용된다. 예를 들어, <code>-o</code> 또는 <code>--output</code> 플래그를
사용하여 출력 형식을 사용자 정의할 수 있는 풍부한 플래그 세트가 있다.
<code>-w</code> 또는 <code>--watch</code> 플래그를 지정하여 특정 오브젝트에 대한 업데이트 진행과정을 확인할 수
있다. <code>kubectl describe</code> 명령은 지정된 리소스의 여러 관련 측면을
설명하는 데 더 중점을 둔다. API 서버에 대한 여러 API 호출을 호출하여
사용자에 대한 뷰(view)를 빌드할 수 있다. 예를 들어, <code>kubectl describe node</code>
명령은 노드에 대한 정보뿐만 아니라, 노드에서 실행 중인 파드의 요약 정보, 노드에 대해 생성된 이벤트 등의
정보도 검색한다.</div><p><code>kubectl delete</code> - 파일, 표준입력 또는 레이블 선택기, 이름, 리소스 선택기나 리소스를 지정하여 리소스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># pod.yaml 파일에 지정된 타입과 이름을 사용하여 파드를 삭제한다.</span>
</span></span><span style=display:flex><span>kubectl delete -f pod.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &#39;&lt;label-key&gt;=&lt;label-value&gt;&#39; 레이블이 있는 모든 파드와 서비스를 삭제한다.</span>
</span></span><span style=display:flex><span>kubectl delete pods,services -l &lt;label-key&gt;<span style=color:#666>=</span>&lt;label-value&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 초기화되지 않은 파드를 포함한 모든 파드를 삭제한다.</span>
</span></span><span style=display:flex><span>kubectl delete pods --all
</span></span></code></pre></div><p><code>kubectl exec</code> - 파드의 컨테이너에 대해 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 &lt;pod-name&gt;에서 &#39;date&#39;를 실행한 결과를 얻는다. 기본적으로, 첫 번째 컨테이너에서 출력된다.</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -- date
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 &lt;pod-name&gt;의 &lt;container-name&gt; 컨테이너에서 &#39;date&#39;를 실행하여 출력 결과를 얻는다.</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; -- date
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 &lt;pod-name&gt;에서 대화식 TTY를 연결해 /bin/bash를 실행한다. 기본적으로, 첫 번째 컨테이너에서 출력된다.</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -ti &lt;pod-name&gt; -- /bin/bash
</span></span></code></pre></div><p><code>kubectl logs</code> - 파드의 컨테이너에 대한 로그를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 &lt;pod-name&gt;에서 로그의 스냅샷을 반환한다.</span>
</span></span><span style=display:flex><span>kubectl logs &lt;pod-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 &lt;pod-name&gt;에서 로그 스트리밍을 시작한다. 이것은 리눅스 명령 &#39;tail -f&#39;와 비슷하다.</span>
</span></span><span style=display:flex><span>kubectl logs -f &lt;pod-name&gt;
</span></span></code></pre></div><p><code>kubectl diff</code> - 제안된 클러스터 업데이트의 차이점을 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;pod.json&#34;에 포함된 리소스의 차이점을 출력한다.</span>
</span></span><span style=display:flex><span>kubectl diff -f pod.json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 표준입력에서 파일을 읽어 차이점을 출력한다.</span>
</span></span><span style=display:flex><span>cat service.yaml | kubectl diff -f -
</span></span></code></pre></div><h2 id=예제-플러그인-작성-및-사용>예제: 플러그인 작성 및 사용</h2><p><code>kubectl</code> 플러그인 작성과 사용에 익숙해지려면 다음의 예제 세트를 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 어떤 언어로든 간단한 플러그인을 만들고 &#34;kubectl-&#34; 접두사로</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 시작하도록 실행 파일의 이름을 지정한다.</span>
</span></span><span style=display:flex><span>cat ./kubectl-hello
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#080></span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이 플러그인은 &#34;hello world&#34;라는 단어를 출력한다</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;hello world&#34;</span>
</span></span></code></pre></div><p>작성한 플러그인을 실행 가능하게 한다</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chmod a+x ./kubectl-hello
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 그리고 PATH의 위치로 옮긴다</span>
</span></span><span style=display:flex><span>sudo mv ./kubectl-hello /usr/local/bin
</span></span><span style=display:flex><span>sudo chown root:root /usr/local/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이제 kubectl 플러그인을 만들고 &#34;설치했다&#34;.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># kubectl에서 플러그인을 일반 명령처럼 호출하여 플러그인을 사용할 수 있다</span>
</span></span><span style=display:flex><span>kubectl hello
</span></span></code></pre></div><pre tabindex=0><code>hello world
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 플러그인을 배치한 $PATH의 폴더에서 플러그인을 삭제하여,</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 플러그인을 &#34;제거&#34;할 수 있다</span>
</span></span><span style=display:flex><span>sudo rm /usr/local/bin/kubectl-hello
</span></span></code></pre></div><p><code>kubectl</code> 에 사용할 수 있는 모든 플러그인을 보려면,
<code>kubectl plugin list</code> 하위 명령을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl plugin list
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
/usr/local/bin/kubectl-bar
</code></pre><p><code>kubectl plugin list</code> 는 또한 실행 가능하지 않거나,
다른 플러그인에 의해 차단된 플러그인에 대해 경고한다. 예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo chmod -x /usr/local/bin/kubectl-foo <span style=color:#080;font-style:italic># 실행 권한 제거</span>
</span></span><span style=display:flex><span>kubectl plugin list
</span></span></code></pre></div><pre tabindex=0><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable
/usr/local/bin/kubectl-bar

error: one plugin warning was found
</code></pre><p>플러그인은 기존 kubectl 명령 위에 보다 복잡한 기능을
구축하는 수단으로 생각할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat ./kubectl-whoami
</span></span></code></pre></div><p>다음 몇 가지 예는 이미 <code>kubectl-whoami</code> 에
다음 내용이 있다고 가정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#080></span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이 플러그인은 현재 선택된 컨텍스트를 기반으로 현재 사용자에 대한</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 정보를 출력하기 위해 &#39;kubectl config&#39; 명령을 사용한다.</span>
</span></span><span style=display:flex><span>kubectl config view --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{ range .contexts }}{{ if eq .name &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config current-context<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34; }}Current user: {{ printf &#34;%s\n&#34; .context.user }}{{ end }}{{ end }}&#39;</span>
</span></span></code></pre></div><p>위의 플러그인을 실행하면 KUBECONFIG 파일에서 현재의 컨텍스트에 대한
사용자가 포함된 출력이 제공된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 파일을 실행 가능하게 한다</span>
</span></span><span style=display:flex><span>sudo chmod +x ./kubectl-whoami
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 그리고 PATH로 옮긴다</span>
</span></span><span style=display:flex><span>sudo mv ./kubectl-whoami /usr/local/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl whoami
</span></span><span style=display:flex><span>Current user: plugins-user
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><code>kubectl</code> 레퍼런스 문서를 읽는다.<ul><li>kubectl <a href=/ko/docs/reference/kubectl/kubectl/>명령어 레퍼런스</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>명령줄 인자</a> 레퍼런스</li></ul></li><li><a href=/ko/docs/reference/kubectl/conventions/><code>kubectl</code> 사용 규칙</a>에 대해 알아본다.</li><li>kubectl의 <a href=/ko/docs/reference/kubectl/jsonpath/>JSONPath 지원</a>에 대해 알아본다.</li><li><a href=/ko/docs/tasks/extend-kubectl/kubectl-plugins/>플러그인으로 kubectl 확장</a>에 대해 알아본다.<ul><li>플러그인에 대해 좀 더 알아보려면, <a href=https://github.com/kubernetes/sample-cli-plugin>예시 CLI 플러그인</a>을 살펴본다.</li></ul></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>1 - kubectl 치트 시트</h1><p>이 페이지는 일반적으로 사용하는 <code>kubectl</code> 커맨드와 플래그에 대한 목록을 포함한다.</p><h2 id=kubectl-자동-완성>Kubectl 자동 완성</h2><h3 id=bash>BASH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># bash-completion 패키지를 먼저 설치한 후, bash의 자동 완성을 현재 셸에 설정한다</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># 자동 완성을 bash 셸에 영구적으로 추가한다</span>
</span></span></code></pre></div><p>또한, <code>kubectl</code>의 의미로 사용되는 약칭을 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
</span></span><span style=display:flex><span><span style=color:#a2f>complete</span> -o default -F __start_kubectl k
</span></span></code></pre></div><h3 id=zsh>ZSH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># 현재 셸에 zsh의 자동 완성 설정</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;[[ $commands[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&#39;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># 자동 완성을 zsh 셸에 영구적으로 추가한다.</span>
</span></span></code></pre></div><h3 id=all-namespaces-에-대한-노트>--all-namespaces 에 대한 노트</h3><p><code>--all-namespaces</code>를 붙여야 하는 상황이 자주 발생하므로, <code>--all-namespaces</code>의 축약형을 알아 두는 것이 좋다.</p><p><code>kubectl -A</code></p><h2 id=kubectl-컨텍스트와-설정>Kubectl 컨텍스트와 설정</h2><p><code>kubectl</code>이 통신하고 설정 정보를 수정하는 쿠버네티스 클러스터를
지정한다. 설정 파일에 대한 자세한 정보는 <a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig를 이용한 클러스터 간 인증</a> 문서를
참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl config view <span style=color:#080;font-style:italic># 병합된 kubeconfig 설정을 표시한다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 동시에 여러 kubeconfig 파일을 사용하고 병합된 구성을 확인한다</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># e2e 사용자의 암호를 확인한다</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>     <span style=color:#080;font-style:italic># 첫 번째 사용자 출력</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>    <span style=color:#080;font-style:italic># 사용자 리스트 조회</span>
</span></span><span style=display:flex><span>kubectl config get-contexts                           <span style=color:#080;font-style:italic># 컨텍스트 리스트 출력</span>
</span></span><span style=display:flex><span>kubectl config current-context                        <span style=color:#080;font-style:italic># 현재 컨텍스트 출력</span>
</span></span><span style=display:flex><span>kubectl config use-context my-cluster-name            <span style=color:#080;font-style:italic># my-cluster-name를 기본 컨텍스트로 설정</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config set-cluster my-cluster-name            <span style=color:#080;font-style:italic># kubeconfig에 클러스터 엔트리를 설정</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># kubeconfig에 이 클라이언트가 발생시킨 요청에 사용할 프록시 서버의 URL을 구성한다.</span>
</span></span><span style=display:flex><span>kubectl config set-cluster my-cluster-name --proxy-url<span style=color:#666>=</span>my-proxy-url
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 기본 인증을 지원하는 새로운 사용자를 kubeconf에 추가한다</span>
</span></span><span style=display:flex><span>kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 해당 컨텍스트에서 모든 후속 kubectl 커맨드에 대한 네임스페이스를 영구적으로 저장한다</span>
</span></span><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 특정 사용자와 네임스페이스를 사용하는 컨텍스트 설정</span>
</span></span><span style=display:flex><span>kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config <span style=color:#a2f>unset</span> users.foo                       <span style=color:#080;font-style:italic># foo 사용자 삭제</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 컨텍스트/네임스페이스를 설정/조회하는 단축 명령 (bash 및 bash 호환 셸에서만 동작함, 네임스페이스 설정을 위해 kn 을 사용하기 전에 현재 컨텍스트가 설정되어야 함)</span>
</span></span><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>kx</span><span style=color:#666>=</span><span style=color:#b44>&#39;f() { [ &#34;$1&#34; ] &amp;&amp; kubectl config use-context $1 || kubectl config current-context ; } ; f&#39;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>kn</span><span style=color:#666>=</span><span style=color:#b44>&#39;f() { [ &#34;$1&#34; ] &amp;&amp; kubectl config set-context --current --namespace $1 || kubectl config view --minify | grep namespace | cut -d&#34; &#34; -f6 ; } ; f&#39;</span>
</span></span></code></pre></div><h2 id=kubectl-apply>Kubectl apply</h2><p><code>apply</code>는 쿠버네티스 리소스를 정의하는 파일을 통해 애플리케이션을 관리한다. <code>kubectl apply</code>를 실행하여 클러스터에 리소스를 생성하고 업데이트한다. 이것은 프로덕션 환경에서 쿠버네티스 애플리케이션을 관리할 때 권장된다. <a href=https://kubectl.docs.kubernetes.io>Kubectl Book</a>을 참고한다.</p><h2 id=오브젝트-생성>오브젝트 생성</h2><p>쿠버네티스 매니페스트는 JSON이나 YAML로 정의된다. 파일 확장자는 <code>.yaml</code>
, <code>.yml</code>, <code>.json</code> 이 사용된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f ./my-manifest.yaml            <span style=color:#080;font-style:italic># 리소스(들) 생성</span>
</span></span><span style=display:flex><span>kubectl apply -f ./my1.yaml -f ./my2.yaml      <span style=color:#080;font-style:italic># 여러 파일로 부터 생성</span>
</span></span><span style=display:flex><span>kubectl apply -f ./dir                         <span style=color:#080;font-style:italic># dir 내 모든 매니페스트 파일에서 리소스(들) 생성</span>
</span></span><span style=display:flex><span>kubectl apply -f https://git.io/vPieo          <span style=color:#080;font-style:italic># url로부터 리소스(들) 생성</span>
</span></span><span style=display:flex><span>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx  <span style=color:#080;font-style:italic># nginx 단일 인스턴스를 시작</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;Hello World&#34;를 출력하는 잡(Job) 생성</span>
</span></span><span style=display:flex><span>kubectl create job hello --image<span style=color:#666>=</span>busybox:1.28 -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 매분마다 &#34;Hello World&#34;를 출력하는 크론잡(CronJob) 생성</span>
</span></span><span style=display:flex><span>kubectl create cronjob hello --image<span style=color:#666>=</span>busybox:1.28   --schedule<span style=color:#666>=</span><span style=color:#b44>&#34;*/1 * * * *&#34;</span> -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl explain pods                           <span style=color:#080;font-style:italic># 파드 매니페스트 문서를 조회</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># stdin으로 다수의 YAML 오브젝트 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox:1.28
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>---
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep-less
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox:1.28
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 여러 개의 키로 시크릿 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: mysecret
</span></span></span><span style=display:flex><span><span style=color:#b44>type: Opaque
</span></span></span><span style=display:flex><span><span style=color:#b44>data:
</span></span></span><span style=display:flex><span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><h2 id=리소스-조회-및-찾기>리소스 조회 및 찾기</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 기본 출력을 위한 Get 커맨드</span>
</span></span><span style=display:flex><span>kubectl get services                          <span style=color:#080;font-style:italic># 네임스페이스 내 모든 서비스의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># 모든 네임스페이스 내 모든 파드의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide                      <span style=color:#080;font-style:italic># 해당하는 네임스페이스 내 모든 파드의 상세 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># 특정 디플로이먼트의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pods                              <span style=color:#080;font-style:italic># 네임스페이스 내 모든 파드의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># 파드의 YAML 조회</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 상세 출력을 위한 Describe 커맨드</span>
</span></span><span style=display:flex><span>kubectl describe nodes my-node
</span></span><span style=display:flex><span>kubectl describe pods my-pod
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Name으로 정렬된 서비스의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 재시작 횟수로 정렬된 파드의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># PersistentVolumes을 용량별로 정렬해서 조회</span>
</span></span><span style=display:flex><span>kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># app=cassandra 레이블을 가진 모든 파드의 레이블 버전 조회</span>
</span></span><span style=display:flex><span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 예를 들어 &#39;ca.crt&#39;와 같이 점이 있는 키값을 검색한다</span>
</span></span><span style=display:flex><span>kubectl get configmap myconfig <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.ca\.crt}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 밑줄(`_`) 대신 대시(`-`)를 사용하여 base64 인코딩된 값을 조회</span>
</span></span><span style=display:flex><span>kubectl get secret my-secret --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{index .data &#34;key-name-with-dashes&#34;}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 워커 노드 조회 (셀렉터를 사용하여 &#39;node-role.kubernetes.io/control-plane&#39;</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 으로 명명된 라벨의 결과를 제외)</span>
</span></span><span style=display:flex><span>kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/control-plane&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 네임스페이스의 모든 실행 중인 파드를 조회</span>
</span></span><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 노드의 외부IP를 조회</span>
</span></span><span style=display:flex><span>kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 특정 RC에 속해있는 파드 이름의 목록 조회</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;jq&#34; 커맨드는 jsonpath를 사용하는 매우 복잡한 변환에 유용하다. https://stedolan.github.io/jq/ 에서 확인할 수 있다.</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드(또는 레이블을 지원하는 다른 쿠버네티스 오브젝트)의 레이블 조회</span>
</span></span><span style=display:flex><span>kubectl get pods --show-labels
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 어떤 노드가 준비됐는지 확인</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 외부 도구 없이 디코딩된 시크릿 출력</span>
</span></span><span style=display:flex><span>kubectl get secret my-secret -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range $k,$v := .data}}{{&#34;### &#34;}}{{$k}}{{&#34;\n&#34;}}{{$v|base64decode}}{{&#34;\n\n&#34;}}{{end}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드에 의해 현재 사용되고 있는 모든 시크릿 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드의 초기화 컨테이너(initContainer)의 컨테이너ID 목록 조회</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 초기화 컨테이너(initContainer)를 제거하지 않고 정지된 모든 컨테이너를 정리할 때 유용하다.</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 타임스탬프로 정렬된 이벤트 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 매니페스트가 적용된 경우 클러스터의 현재 상태와 클러스터의 상태를 비교한다.</span>
</span></span><span style=display:flex><span>kubectl diff -f ./my-manifest.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 노드에 대해 반환된 모든 키의 마침표로 구분된 트리를 생성한다.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 복잡한 중첩 JSON 구조 내에서 키를 찾을 때 유용하다.</span>
</span></span><span style=display:flex><span>kubectl get nodes -o json | jq -c <span style=color:#b44>&#39;paths|join(&#34;.&#34;)&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 등에 대해 반환된 모든 키의 마침표로 구분된 트리를 생성한다.</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq -c <span style=color:#b44>&#39;paths|join(&#34;.&#34;)&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드에 대해 ENV를 생성한다(각 파드에 기본 컨테이너가 있고, 기본 네임스페이스가 있고, `env` 명령어가 동작한다고 가정).</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># `env` 뿐만 아니라 다른 지원되는 명령어를 모든 파드에 실행할 때에도 참고할 수 있다.</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> pod in <span style=color:#a2f;font-weight:700>$(</span>kubectl get po --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span> <span style=color:#a2f>echo</span> <span style=color:#b8860b>$pod</span> <span style=color:#666>&amp;&amp;</span> kubectl <span style=color:#a2f>exec</span> -it <span style=color:#b8860b>$pod</span> -- env; <span style=color:#a2f;font-weight:700>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 디플로이먼트의 status 서브리소스를 조회한다.</span>
</span></span><span style=display:flex><span>kubectl get deployment nginx-deployment --subresource<span style=color:#666>=</span>status
</span></span></code></pre></div><h2 id=리소스-업데이트>리소스 업데이트</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># &#34;frontend&#34; 디플로이먼트의 &#34;www&#34; 컨테이너 이미지를 업데이트하는 롤링 업데이트</span>
</span></span><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># 현 리비전을 포함한 디플로이먼트의 이력을 체크</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># 이전 디플로이먼트로 롤백</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># 특정 리비전으로 롤백</span>
</span></span><span style=display:flex><span>kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># 완료될 때까지 &#34;frontend&#34; 디플로이먼트의 롤링 업데이트 상태를 감시</span>
</span></span><span style=display:flex><span>kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># &#34;frontend&#34; 디플로이먼트의 롤링 재시작</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># stdin으로 전달된 JSON을 기반으로 파드 교체</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 리소스를 강제 교체, 삭제 후 재생성함. 이것은 서비스를 중단시킴.</span>
</span></span><span style=display:flex><span>kubectl replace --force -f ./pod.json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 복제된 nginx를 위한 서비스를 생성한다. 80 포트로 서비스하고, 컨테이너는 8000 포트로 연결한다.</span>
</span></span><span style=display:flex><span>kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 단일-컨테이너 파드의 이미지 버전(태그)을 v4로 업데이트</span>
</span></span><span style=display:flex><span>kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># 레이블 추가</span>
</span></span><span style=display:flex><span>kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># 어노테이션 추가</span>
</span></span><span style=display:flex><span>kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># 디플로이먼트 &#34;foo&#34; 오토스케일</span>
</span></span></code></pre></div><h2 id=리소스-패치>리소스 패치</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 노드를 부분적으로 업데이트</span>
</span></span><span style=display:flex><span>kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 컨테이너의 이미지를 업데이트. 병합(merge) 키이므로, spec.containers[*].name이 필요</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 위치 배열을 이용한 json 패치를 사용하여, 컨테이너의 이미지를 업데이트</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 위치 배열을 이용한 json 패치를 사용하여 livenessProbe 디플로이먼트 비활성화</span>
</span></span><span style=display:flex><span>kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 위치 배열에 새 요소 추가</span>
</span></span><span style=display:flex><span>kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 디플로이먼트의 scale 서브리소스를 패치하여 레플리카 수 업데이트</span>
</span></span><span style=display:flex><span>kubectl patch deployment nginx-deployment --subresource<span style=color:#666>=</span><span style=color:#b44>&#39;scale&#39;</span> --type<span style=color:#666>=</span><span style=color:#b44>&#39;merge&#39;</span> -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;replicas&#34;:2}}&#39;</span>
</span></span></code></pre></div><h2 id=리소스-편집>리소스 편집</h2><p>선호하는 편집기로 모든 API 리소스를 편집할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># docker-registry라는 서비스 편집</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># 다른 편집기 사용</span>
</span></span></code></pre></div><h2 id=리소스-스케일링>리소스 스케일링</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># &#39;foo&#39;라는 레플리카셋을 3으로 스케일</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># &#34;foo.yaml&#34;에 지정된 리소스의 크기를 3으로 스케일</span>
</span></span><span style=display:flex><span>kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># mysql이라는 디플로이먼트의 현재 크기가 2인 경우, mysql을 3으로 스케일</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># 여러 개의 레플리케이션 컨트롤러 스케일</span>
</span></span></code></pre></div><h2 id=리소스-삭제>리소스 삭제</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl delete -f ./pod.json                                      <span style=color:#080;font-style:italic># pod.json에 지정된 유형 및 이름을 사용하여 파드 삭제</span>
</span></span><span style=display:flex><span>kubectl delete pod unwanted --now                                 <span style=color:#080;font-style:italic># 유예 시간 없이 즉시 파드 삭제</span>
</span></span><span style=display:flex><span>kubectl delete pod,service baz foo                                <span style=color:#080;font-style:italic># &#34;baz&#34;, &#34;foo&#34;와 동일한 이름을 가진 파드와 서비스 삭제</span>
</span></span><span style=display:flex><span>kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                      <span style=color:#080;font-style:italic># name=myLabel 라벨을 가진 파드와 서비스 삭제</span>
</span></span><span style=display:flex><span>kubectl -n my-ns delete pod,svc --all                             <span style=color:#080;font-style:italic># my-ns 네임스페이스 내 모든 파드와 서비스 삭제</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># awk pattern1 또는 pattern2에 매칭되는 모든 파드 삭제</span>
</span></span><span style=display:flex><span>kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</span></span></code></pre></div><h2 id=실행-중인-파드와-상호-작용>실행 중인 파드와 상호 작용</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># 파드 로그 덤프 (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># name이 myLabel인 파드 로그 덤프 (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># 컨테이너의 이전 인스턴스 생성에 대한 파드 로그 덤프 (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># 파드 로그 덤프 (stdout, 멀티-컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># name이 myLabel인 파드 로그 덤프 (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># 컨테이너의 이전 인스턴스 생성에 대한 파드 로그 덤프 (stdout, 멀티-컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># 실시간 스트림 파드 로그(stdout)</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># 실시간 스트림 파드 로그(stdout, 멀티-컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># name이 myLabel인 모든 파드의 로그 스트리밍 (stdout)</span>
</span></span><span style=display:flex><span>kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox:1.28 -- sh  <span style=color:#080;font-style:italic># 대화형 셸로 파드를 실행</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx -n mynamespace      <span style=color:#080;font-style:italic># mynamespace 네임스페이스에서 nginx 파드 1개 실행</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx                     <span style=color:#080;font-style:italic># nginx 파드를 실행하고 해당 스펙을 pod.yaml 파일에 기록</span>
</span></span><span style=display:flex><span>--dry-run<span style=color:#666>=</span>client -o yaml &gt; pod.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># 실행 중인 컨테이너에 연결</span>
</span></span><span style=display:flex><span>kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># 로컬 머신의 5000번 포트를 리스닝하고, my-pod의 6000번 포트로 전달</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># 기존 파드에서 명령 실행(한 개 컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> --stdin --tty my-pod -- /bin/sh        <span style=color:#080;font-style:italic># 실행 중인 파드로 대화형 셸 액세스(1 컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># 기존 파드에서 명령 실행(멀티-컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># 특정 파드와 해당 컨테이너에 대한 메트릭 표시</span>
</span></span><span style=display:flex><span>kubectl top pod POD_NAME --sort-by<span style=color:#666>=</span>cpu              <span style=color:#080;font-style:italic># 지정한 파드에 대한 메트릭을 표시하고 &#39;cpu&#39; 또는 &#39;memory&#39;별로 정렬</span>
</span></span></code></pre></div><h2 id=컨테이너로-컨테이너에서-파일과-디렉터리-복사>컨테이너로/컨테이너에서 파일과 디렉터리 복사</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cp /tmp/foo_dir my-pod:/tmp/bar_dir            <span style=color:#080;font-style:italic># 로컬 디렉토리 /tmp/foo_dir 를 현재 네임스페이스의 my-pod 파드 안의 /tmp/bar_dir 로 복사</span>
</span></span><span style=display:flex><span>kubectl cp /tmp/foo my-pod:/tmp/bar -c my-container    <span style=color:#080;font-style:italic># 로컬 파일 /tmp/foo 를 my-pod 파드의 my-container 컨테이너 안의 /tmp/bar 로 복사</span>
</span></span><span style=display:flex><span>kubectl cp /tmp/foo my-namespace/my-pod:/tmp/bar       <span style=color:#080;font-style:italic># 로컬 파일 /tmp/foo 를 my-namespace 네임스페이스의 my-pod 파드 안의 /tmp/bar 로 복사</span>
</span></span><span style=display:flex><span>kubectl cp my-namespace/my-pod:/tmp/foo /tmp/bar       <span style=color:#080;font-style:italic># my-namespace 네임스페이스의 my-pod 파드 안의 파일 /tmp/foo 를 로컬의 /tmp/bar 로 복사</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubectl cp</code> 명령을 사용하려면 컨테이너 이미지에 'tar' 바이너리가 포함되어 있어야 한다. 'tar'가 없으면, <code>kubectl cp</code>는 실패할 것이다.
심볼릭 링크, 와일드카드 확장, 파일 모드 보존과 같은 고급 사용 사례에 대해서는 <code>kubectl exec</code> 를 고려해 볼 수 있다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tar cf - /tmp/foo | kubectl <span style=color:#a2f>exec</span> -i -n my-namespace my-pod -- tar xf - -C /tmp/bar           <span style=color:#080;font-style:italic># 로컬 파일 /tmp/foo 를 my-namespace 네임스페이스의 my-pod 파드 안의 /tmp/bar 로 복사</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -n my-namespace my-pod -- tar cf - /tmp/foo | tar xf - -C /tmp/bar    <span style=color:#080;font-style:italic># my-namespace 네임스페이스의 my-pod 파드 안의 파일 /tmp/foo 를 로컬의 /tmp/bar 로 복사</span>
</span></span></code></pre></div><h2 id=디플로이먼트-서비스와-상호-작용>디플로이먼트, 서비스와 상호 작용</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs deploy/my-deployment                         <span style=color:#080;font-style:italic># 디플로이먼트에 대한 파드 로그 덤프 (단일-컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl logs deploy/my-deployment -c my-container         <span style=color:#080;font-style:italic># 디플로이먼트에 대한 파드 로그 덤프 (멀티-컨테이너 경우)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl port-forward svc/my-service <span style=color:#666>5000</span>                  <span style=color:#080;font-style:italic># 로컬 머신의 5000번 포트를 리스닝하고, my-service의 동일한(5000번) 포트로 전달</span>
</span></span><span style=display:flex><span>kubectl port-forward svc/my-service 5000:my-service-port  <span style=color:#080;font-style:italic># 로컬 머신의 5000번 포트를 리스닝하고, my-service의 &lt;my-service-port&gt; 라는 이름을 가진 포트로 전달</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl port-forward deploy/my-deployment 5000:6000       <span style=color:#080;font-style:italic># 로컬 머신의 5000번 포트를 리스닝하고, &lt;my-deployment&gt; 에 의해 생성된 파드의 6000번 포트로 전달</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> deploy/my-deployment -- ls                   <span style=color:#080;font-style:italic># &lt;my-deployment&gt; 에 의해 생성된 첫번째 파드의 첫번째 컨테이너에 명령어 실행 (단일- 또는 다중-컨테이너 경우)</span>
</span></span></code></pre></div><h2 id=노드-클러스터와-상호-작용>노드, 클러스터와 상호 작용</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># my-node를 스케줄링할 수 없도록 표기</span>
</span></span><span style=display:flex><span>kubectl drain my-node                                                 <span style=color:#080;font-style:italic># 유지 보수를 위해서 my-node를 준비 상태로 비움</span>
</span></span><span style=display:flex><span>kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># my-node를 스케줄링할 수 있도록 표기</span>
</span></span><span style=display:flex><span>kubectl top node my-node                                              <span style=color:#080;font-style:italic># 주어진 노드에 대한 메트릭 표시</span>
</span></span><span style=display:flex><span>kubectl cluster-info                                                  <span style=color:#080;font-style:italic># 마스터 및 서비스의 주소 표시</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># 현재 클러스터 상태를 stdout으로 덤프</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># 현재 클러스터 상태를 /path/to/cluster-state으로 덤프</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 현재 노드에 존재하고 있는 테인트(taint)들을 확인</span>
</span></span><span style=display:flex><span>kubectl get nodes -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span>NodeName:.metadata.name,TaintKey:.spec.taints<span style=color:#666>[</span>*<span style=color:#666>]</span>.key,TaintValue:.spec.taints<span style=color:#666>[</span>*<span style=color:#666>]</span>.value,TaintEffect:.spec.taints<span style=color:#666>[</span>*<span style=color:#666>]</span>.effect
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이미 존재하고 있는 key와 effect를 갖는 테인트의 경우, 지정한 값으로 대체</span>
</span></span><span style=display:flex><span>kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</span></span></code></pre></div><h3 id=리소스-타입>리소스 타입</h3><p>단축명, <a href=/ko/docs/concepts/overview/kubernetes-api/#api-%EA%B7%B8%EB%A3%B9%EA%B3%BC-%EB%B2%84%EC%A0%84-%EA%B7%9C%EC%B9%99>API 그룹</a>과 함께 지원되는 모든 리소스 유형들, 그것들의 <a href=/ko/docs/concepts/overview/working-with-objects/namespaces>네임스페이스</a>와 <a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects>종류(Kind)</a>를 나열:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources
</span></span></code></pre></div><p>API 리소스를 탐색하기 위한 다른 작업:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># 네임스페이스를 가지는 모든 리소스</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># 네임스페이스를 가지지 않는 모든 리소스</span>
</span></span><span style=display:flex><span>kubectl api-resources -o name                <span style=color:#080;font-style:italic># 모든 리소스의 단순한 (리소스 이름만) 출력</span>
</span></span><span style=display:flex><span>kubectl api-resources -o wide                <span style=color:#080;font-style:italic># 모든 리소스의 확장된 (&#34;wide&#34;로 알려진) 출력</span>
</span></span><span style=display:flex><span>kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># &#34;list&#34;와 &#34;get&#34;의 요청 동사를 지원하는 모든 리소스 출력</span>
</span></span><span style=display:flex><span>kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># &#34;extensions&#34; API 그룹의 모든 리소스</span>
</span></span></code></pre></div><h3 id=출력-형식-지정>출력 형식 지정</h3><p>특정 형식으로 터미널 창에 세부 사항을 출력하려면, 지원되는 <code>kubectl</code> 명령에 <code>-o</code> (또는 <code>--output</code>) 플래그를 추가한다.</p><table><thead><tr><th>출력 형식</th><th>세부 사항</th></tr></thead><tbody><tr><td><code>-o=custom-columns=&lt;명세></code></td><td>쉼표로 구분된 사용자 정의 열 목록을 사용하여 테이블 출력</td></tr><tr><td><code>-o=custom-columns-file=&lt;파일명></code></td><td><code>&lt;파일명></code>파일에서 사용자 정의 열 템플릿을 사용하여 테이블 출력</td></tr><tr><td><code>-o=json</code></td><td>JSON 형식의 API 오브젝트 출력</td></tr><tr><td><code>-o=jsonpath=&lt;템플릿></code></td><td><a href=/ko/docs/reference/kubectl/jsonpath>jsonpath</a> 표현식에 정의된 필드 출력</td></tr><tr><td><code>-o=jsonpath-file=&lt;파일명></code></td><td>&lt;파일명> 파일에서 <a href=/ko/docs/reference/kubectl/jsonpath>jsonpath</a> 표현식에 정의된 필드 출력</td></tr><tr><td><code>-o=name</code></td><td>리소스 명만 출력하고 그 외에는 출력하지 않음</td></tr><tr><td><code>-o=wide</code></td><td>추가 정보가 포함된 일반-텍스트 형식으로 출력하고, 파드의 경우 노드 명이 포함</td></tr><tr><td><code>-o=yaml</code></td><td>YAML 형식의 API 오브젝트 출력</td></tr></tbody></table><p><code>-o=custom-columns</code> 의 사용 예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 클러스터에서 실행 중인 모든 이미지</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[*].image&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># `default` 네임스페이스의 모든 이미지를 파드별로 그룹지어 출력</span>
</span></span><span style=display:flex><span>kubectl get pods --namespace default --output<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#34;NAME:.metadata.name,IMAGE:.spec.containers[*].image&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#080;font-style:italic># &#34;registry.k8s.io/coredns:1.6.2&#34; 를 제외한 모든 이미지</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[?(@.image!=&#34;registry.k8s.io/coredns:1.6.2&#34;)].image&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이름에 관계없이 메타데이터 아래의 모든 필드</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:metadata.*&#39;</span>
</span></span></code></pre></div><p>더 많은 예제는 kubectl <a href=/ko/docs/reference/kubectl/#custom-columns>참조 문서</a>를 참고한다.</p><h3 id=kubectl-출력-로그-상세-레벨-verbosity-과-디버깅>Kubectl 출력 로그 상세 레벨(verbosity)과 디버깅</h3><p>Kubectl 로그 상세 레벨(verbosity)은 <code>-v</code> 또는<code>--v</code> 플래그와 로그 레벨을 나타내는 정수로 제어된다. 일반적인 쿠버네티스 로깅 규칙과 관련 로그 레벨이 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>여기</a>에 설명되어 있다.</p><table><thead><tr><th>로그 레벨</th><th>세부 사항</th></tr></thead><tbody><tr><td><code>--v=0</code></td><td>일반적으로 클러스터 운영자(operator)에게 <em>항상</em> 보여지게 하기에는 유용함.</td></tr><tr><td><code>--v=1</code></td><td>자세한 정보를 원하지 않는 경우, 적절한 기본 로그 수준.</td></tr><tr><td><code>--v=2</code></td><td>서비스와 시스템의 중요한 변화와 관련이있는 중요한 로그 메시지에 대한 유용한 정상 상태 정보. 이는 대부분의 시스템에서 권장되는 기본 로그 수준이다.</td></tr><tr><td><code>--v=3</code></td><td>변경 사항에 대한 확장 정보.</td></tr><tr><td><code>--v=4</code></td><td>디버그 수준 상세화.</td></tr><tr><td><code>--v=5</code></td><td>트레이스 수준 상세화.</td></tr><tr><td><code>--v=6</code></td><td>요청한 리소스를 표시.</td></tr><tr><td><code>--v=7</code></td><td>HTTP 요청 헤더를 표시.</td></tr><tr><td><code>--v=8</code></td><td>HTTP 요청 내용을 표시.</td></tr><tr><td><code>--v=9</code></td><td>내용을 잘라 내지 않고 HTTP 요청 내용을 표시.</td></tr></tbody></table><h2 id=다음-내용>다음 내용</h2><ul><li><p><a href=/ko/docs/reference/kubectl/>kubectl 개요</a>를 읽고 <a href=/ko/docs/reference/kubectl/jsonpath>JsonPath</a>에 대해 배워보자.</p></li><li><p><a href=/ko/docs/reference/kubectl/kubectl/>kubectl</a> 옵션을 참고한다.</p></li><li><p>재사용 스크립트에서 kubectl 사용 방법을 이해하기 위해 <a href=/ko/docs/reference/kubectl/conventions/>kubectl 사용 규칙</a>을 참고한다.</p></li><li><p>더 많은 커뮤니티 <a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>kubectl 치트시트</a>를 확인한다.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4d3e62632c189fcc3c1357cd8fb8799c>2 - kubectl</h1><h2 id=시놉시스>시놉시스</h2><p>kubectl은 쿠버네티스 클러스터 관리자를 제어한다.</p><p>자세한 정보는 <a href=/ko/docs/reference/kubectl/>kubectl 개요</a>를 확인한다.</p><pre tabindex=0><code>kubectl [flags]
</code></pre><h2 id=옵션>옵션</h2><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--add-dir-header</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>true인 경우, 로그 메시지의 헤더에 파일 디렉터리를 추가한다.</td></tr><tr><td colspan=2>--alsologtostderr</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>표준 에러와 파일에 로그를 기록한다.</td></tr><tr><td colspan=2>--as string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>작업을 수행할 사용자 이름</td></tr><tr><td colspan=2>--as-group stringArray</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>작업을 수행할 그룹. 이 플래그를 반복해서 여러 그룹을 지정할 수 있다.</td></tr><tr><td colspan=2>--azure-container-registry-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Azure 컨테이너 레지스트리 구성 정보가 포함된 파일의 경로이다.</td></tr><tr><td colspan=2>--cache-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: "$HOME/.kube/cache"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>기본 캐시 디렉터리</td></tr><tr><td colspan=2>--certificate-authority string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>인증 기관의 인증서에 대한 파일 경로</td></tr><tr><td colspan=2>--client-certificate string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>TLS용 클라이언트 인증서의 파일 경로</td></tr><tr><td colspan=2>--client-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>TLS용 클라이언트 키의 파일 경로</td></tr><tr><td colspan=2>--cloud-provider-gce-l7lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 130.211.0.0/22,35.191.0.0/16</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>L7 LB 트래픽 프록시 및 상태 확인을 위해 GCE 방화벽에서 오픈된 CIDR</td></tr><tr><td colspan=2>--cloud-provider-gce-lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 130.211.0.0/22,209.85.152.0/22,209.85.204.0/22,35.191.0.0/16</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>L4 LB 트래픽 프록시 및 상태 확인을 위해 GCE 방화벽에서 오픈된 CIDR</td></tr><tr><td colspan=2>--cluster string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>사용할 kubeconfig 클러스터의 이름</td></tr><tr><td colspan=2>--context string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>사용할 kubeconfig 콘텍스트의 이름</td></tr><tr><td colspan=2>--default-not-ready-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 300</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>아직 톨러레이션(toleration)이 없는 모든 파드에 기본적으로 추가되는 notReady:NoExecute에 대한 톨러레이션의 tolerationSeconds를 나타낸다.</td></tr><tr><td colspan=2>--default-unreachable-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 300</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>아직 톨러레이션이 없어서 기본인 unreachable:NoExecute가 추가된 모든 파드에 대한 톨러레이션의 tolerationSeconds를 나타낸다.</td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>kubectl에 대한 도움말</td></tr><tr><td colspan=2>--insecure-skip-tls-verify</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>true인 경우, 서버 인증서의 유효성을 확인하지 않는다. 이렇게 하면 사용자의 HTTPS 연결이 안전하지 않게 된다.</td></tr><tr><td colspan=2>--kubeconfig string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>CLI 요청에 사용할 kubeconfig 파일의 경로이다.</td></tr><tr><td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: :0</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>로깅이 file:N에 도달했을 때 스택 트레이스를 내보낸다.</td></tr><tr><td colspan=2>--log-dir string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>비어 있지 않으면, 이 디렉터리에 로그 파일을 작성한다.</td></tr><tr><td colspan=2>--log-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>비어 있지 않으면, 이 로그 파일을 사용한다.</td></tr><tr><td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 1800</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>로그 파일이 커질 수 있는 최대 크기를 정의한다. 단위는 메가 바이트이다. 값이 0이면, 파일의 최대 크기는 무제한이다.</td></tr><tr><td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 5s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>로그를 비우는 간격의 최대 시간(초)</td></tr><tr><td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>파일 대신 표준 에러에 기록</td></tr><tr><td colspan=2>--match-server-version</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>클라이언트 버전과 일치하는 서버 버전 필요</td></tr><tr><td colspan=2>-n, --namespace string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>지정된 경우, 해당 네임스페이스가 CLI 요청의 범위가 됨</td></tr><tr><td colspan=2>--one-output</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>true이면, 로그를 기본 심각도 수준으로만 기록한다(그렇지 않으면 각각의 더 낮은 심각도 수준에도 기록함).</td></tr><tr><td colspan=2>--password string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>API 서버에 대한 기본 인증을 위한 비밀번호</td></tr><tr><td colspan=2>--profile string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: "none"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>캡처할 프로파일의 이름. (none|cpu|heap|goroutine|threadcreate|block|mutex) 중 하나</td></tr><tr><td colspan=2>--profile-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: "profile.pprof"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>프로파일을 쓸 파일의 이름</td></tr><tr><td colspan=2>--request-timeout string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: "0"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>단일 서버 요청을 포기하기 전에 대기하는 시간이다. 0이 아닌 값에는 해당 시간 단위(예: 1s, 2m, 3h)가 포함되어야 한다. 값이 0이면 요청 시간이 초과되지 않는다.</td></tr><tr><td colspan=2>-s, --server string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>쿠버네티스 API 서버의 주소와 포트</td></tr><tr><td colspan=2>--skip-headers</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>true이면, 로그 메시지에서 헤더 접두사를 사용하지 않는다.</td></tr><tr><td colspan=2>--skip-log-headers</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>true이면, 로그 파일을 열 때 헤더를 사용하지 않는다.</td></tr><tr><td colspan=2>--stderrthreshold severity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 2</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>이 임계값 이상의 로그는 표준 에러로 이동한다.</td></tr><tr><td colspan=2>--tls-server-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>서버 인증서 유효성 검사에 사용할 서버 이름. 제공되지 않으면, 서버에 접속하는 데 사용되는 호스트 이름이 사용된다.</td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>API 서버 인증을 위한 베어러(Bearer) 토큰</td></tr><tr><td colspan=2>--user string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>사용할 kubeconfig 사용자의 이름</td></tr><tr><td colspan=2>--username string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>API 서버에 대한 기본 인증을 위한 사용자 이름</td></tr><tr><td colspan=2>-v, --v Level</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>로그 수준의 자세한 정도를 나타내는 숫자</td></tr><tr><td colspan=2>--version version[=true]</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>버전 정보를 출력하고 종료</td></tr><tr><td colspan=2>--vmodule moduleSpec</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>파일 필터링 로깅을 위한 쉼표로 구분된 pattern=N 설정 목록</td></tr><tr><td colspan=2>--warnings-as-errors</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>서버에서 받은 경고를 오류로 처리하고 0이 아닌 종료 코드로 종료</td></tr></tbody></table><h2 id=환경-변수>환경 변수</h2><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>KUBECONFIG</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>kubectl 구성 ("kubeconfig") 파일 경로. 기본: "$HOME/.kube/config"</td></tr><tr><td colspan=2>KUBECTL_COMMAND_HEADERS</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>false로 설정하면, 호출된 kubectl 명령(쿠버네티스 버전 v1.22 이상)을 자세히 설명하는 추가 HTTP 헤더를 해제</td></tr></tbody></table><h2 id=더-보기>더 보기</h2><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands#annotate>kubectl annotate</a> - 리소스에 대한 어노테이션 업데이트</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-resources>kubectl api-resources</a> - 서버에서 지원되는 API 리소스 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-versions>kubectl api-versions</a> - "그룹/버전" 형식으로 서버에서 지원되는 API 버전을 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#apply>kubectl apply</a> - 파일명 또는 표준 입력으로 리소스에 구성 적용</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#attach>kubectl attach</a> - 실행 중인 컨테이너에 연결</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#auth>kubectl auth</a> - 권한 검사</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a> - 디플로이먼트(Deployment), 레플리카셋(ReplicaSet) 또는 레플리케이션컨트롤러(ReplicationController) 자동 스케일링</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#certificate>kubectl certificate</a> - 인증서 리소스 수정</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cluster-info>kubectl cluster-info</a> - 클러스터 정보 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#completion>kubectl completion</a> - 지정된 셸(bash 또는 zsh)에 대한 셸 완성 코드 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a> - kubeconfig 파일 수정</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cordon>kubectl cordon</a> - 노드를 unschedulable로 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cp>kubectl cp</a> - 컨테이너 간에 파일과 디렉터리 복사</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#create>kubectl create</a> - 파일 또는 표준 입력에서 리소스를 생성</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#debug>kubectl debug</a> - 워크로드와 노드의 문제 해결을 위한 디버깅 세션 생성</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#delete>kubectl delete</a> - 파일명, 표준 입력, 리소스 및 이름, 또는 리소스 및 레이블 셀렉터로 리소스 삭제</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#describe>kubectl describe</a> - 특정 리소스 또는 리소스 그룹의 세부 정보를 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#diff>kubectl diff</a> - 적용 예정 버전과 라이브 버전 비교</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#drain>kubectl drain</a> - 유지 보수 준비 중 노드 드레인</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#edit>kubectl edit</a> - 서버에서 리소스 편집</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#exec>kubectl exec</a> - 컨테이너에서 커맨드 실행</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#explain>kubectl explain</a> - 리소스의 문서</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#expose>kubectl expose</a> - 레플리케이션 컨트롤러, 서비스, 디플로이먼트 또는 파드를 가져와서 새로운 쿠버네티스 서비스로 노출</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#get>kubectl get</a> - 하나 이상의 리소스 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#kustomize>kubectl kustomize</a> - 디렉터리 또는 원격 URL에서 kustomization 대상을 빌드</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#label>kubectl label</a> - 리소스의 레이블 업데이트</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#logs>kubectl logs</a> - 파드의 컨테이너에 대한 로그 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#options>kubectl options</a> - 모든 커맨드에서 상속된 플래그 목록을 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#patch>kubectl patch</a> - 리소스 필드를 업데이트</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#plugin>kubectl plugin</a> - 플러그인과 상호 작용하기 위한 유틸리티를 제공</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#port-forward>kubectl port-forward</a> - 하나 이상의 로컬 포트를 파드로 전달</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#proxy>kubectl proxy</a> - 쿠버네티스 API 서버에 대한 프록시 실행</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#replace>kubectl replace</a> - 파일명 또는 표준 입력으로 리소스 교체</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#rollout>kubectl rollout</a> - 리소스 롤아웃 관리</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#run>kubectl run</a> - 클러스터에서 특정 이미지 실행</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#scale>kubectl scale</a> - 디플로이먼트, 레플리카셋 또는 레플리케이션 컨트롤러의 새 크기 설정</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#set>kubectl set</a> - 오브젝트에 특정 기능 설정</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a> - 하나 이상의 노드에서 테인트(taint) 업데이트</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#top>kubectl top</a> - 리소스(CPU/메모리/스토리지) 사용량을 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#uncordon>kubectl uncordon</a> - 노드를 schedulable로 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#version>kubectl version</a> - 클라이언트 및 서버 버전 정보 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#wait>kubectl wait</a> - 실험적(experimental) 기능: 하나 이상의 리소스에 대해서 특정 조건이 만족될 때까지 대기(wait)</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a938176c695852fe70362c29cf615f1c>3 - JSONPath 지원</h1><p>Kubectl은 JSONPath 템플릿을 지원한다.</p><p>JSONPath 템플릿은 중괄호 {}로 둘러싸인 JSONPath 표현식으로 구성된다.
Kubectl은 JSONPath 표현식을 사용하여 JSON 오브젝트의 특정 필드를 필터링하고 출력 형식을 지정한다.
원본 JSONPath 템플릿 구문 외에도 다음과 같은 기능과 구문이 유효하다.</p><ol><li>큰따옴표를 사용하여 JSONPath 표현식 내부의 텍스트를 인용한다.</li><li>목록을 반복하려면 <code>range</code>, <code>end</code> 오퍼레이터를 사용한다.</li><li>목록에서 뒤로 이동하려면 negative slice 인덱스를 사용한다. negative 인덱스는 목록을 "순환(wrap around)" 하지 않으며, <code>-index + listLength >= 0</code> 인 한 유효하다.</li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong><ul><li><p>표현식은 항상 루트 오브젝트에서 시작하므로 <code>$</code> 오퍼레이터는 선택 사항이다.</p></li><li><p>결과 오브젝트는 String() 함수로 출력된다.</p></li></ul></div><p>JSON 입력 시 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;List&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;items&#34;</span>:[
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>},
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;4&#34;</span>},
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[{<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>}]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;8&#34;</span>},
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[
</span></span><span style=display:flex><span>          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
</span></span><span style=display:flex><span>          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;another&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.3&#34;</span>}
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;users&#34;</span>:[
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;myself&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {}
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;e2e&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {<span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;admin&#34;</span>, <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;secret&#34;</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><table><thead><tr><th>Function</th><th>Description</th><th>Example</th><th>Result</th></tr></thead><tbody><tr><td><code>text</code></td><td>일반 텍스트</td><td><code>kind is {.kind}</code></td><td><code>kind is List</code></td></tr><tr><td><code>@</code></td><td>현재 오브젝트</td><td><code>{@}</code></td><td>입력과 동일</td></tr><tr><td><code>.</code> or <code>[]</code></td><td>자식 오퍼레이터</td><td><code>{.kind}</code>, <code>{['kind']}</code> or <code>{['name\.type']}</code></td><td><code>List</code></td></tr><tr><td><code>..</code></td><td>재귀 하향(recursive descent)</td><td><code>{..name}</code></td><td><code>127.0.0.1 127.0.0.2 myself e2e</code></td></tr><tr><td><code>*</code></td><td>와일드 카드. 모든 오브젝트 가져오기</td><td><code>{.items[*].metadata.name}</code></td><td><code>[127.0.0.1 127.0.0.2]</code></td></tr><tr><td><code>[start:end:step]</code></td><td>아래 첨자 오퍼레이터</td><td><code>{.users[0].name}</code></td><td><code>myself</code></td></tr><tr><td><code>[,]</code></td><td>조합 오퍼레이터</td><td><code>{.items[*]['metadata.name', 'status.capacity']}</code></td><td><code>127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]</code></td></tr><tr><td><code>?()</code></td><td>필터</td><td><code>{.users[?(@.name=="e2e")].user.password}</code></td><td><code>secret</code></td></tr><tr><td><code>range</code>, <code>end</code></td><td>반복 목록</td><td><code>{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}</code></td><td><code>[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]</code></td></tr><tr><td><code>''</code></td><td>해석된 문자열 인용</td><td><code>{range .items[*]}{.metadata.name}{'\t'}{end}</code></td><td><code>127.0.0.1 127.0.0.2</code></td></tr></tbody></table><p><code>kubectl</code> 및 JSONPath 표현식을 사용하는 예는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -o json
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{@}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0]}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0].metadata.name}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*][&#39;metadata.name&#39;, &#39;status.capacity&#39;]}&#34;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{.metadata.name}{&#34;\t&#34;}{.status.startTime}{&#34;\n&#34;}{end}&#39;</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>윈도우에서 공백이 포함된 JSONPath 템플릿을 큰따옴표(위의 bash에 표시된 작은따옴표가 아님)로 묶어야 한다. 즉, 템플릿의 모든 문자 주변에 작은따옴표 또는 이스케이프된 큰따옴표를 사용해야 한다. 예를 들면, 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>kubectl get pods -o=jsonpath=<span style=color:#b44>&#34;{range .items[*]}{.metadata.name}{&#39;\t&#39;}{.status.startTime}{&#39;\n&#39;}{end}&#34;</span>
</span></span><span style=display:flex><span>kubectl get pods -o=jsonpath=<span style=color:#b44>&#34;{range .items[*]}{.metadata.name}{\&#34;</span>\t\<span style=color:#b44>&#34;}{.status.startTime}{\&#34;</span>\n\<span style=color:#b44>&#34;}{end}&#34;</span>
</span></span></code></pre></div></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>JSONPath 정규식은 지원되지 않는다. 정규 표현식을 이용해 매치하려면 <code>jq</code>와 같은 도구를 사용하면 된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># kubectl은 JSONPath 출력에 대한 정규 표현식을 지원하지 않는다.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 다음 커맨드는 작동하지 않는다.</span>
</span></span><span style=display:flex><span>kubectl get pods -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[?(@.metadata.name=~/^test$/)].metadata.name}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 다음 커맨드는 원하는 결과를 얻는다.</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq -r <span style=color:#b44>&#39;.items[] | select(.metadata.name | test(&#34;test-&#34;)).spec.containers[].image&#39;</span>
</span></span></code></pre></div></div></div><div class=td-content style=page-break-before:always><h1 id=pg-8de6aceb8bf692c06cced446bac5bc92>4 - kubectl 사용 규칙</h1><p><code>kubectl</code>에 대한 권장 사용 규칙.</p><h2 id=재사용-가능한-스크립트에서-kubectl-사용>재사용 가능한 스크립트에서 <code>kubectl</code> 사용</h2><p>스크립트의 안정적인 출력을 위해서</p><ul><li><code>-o name</code>, <code>-o json</code>, <code>-o yaml</code>, <code>-o go-template</code> 혹은 <code>-o jsonpath</code>와 같은 머신 지향(machine-oriented) 출력 양식 중 하나를 요청한다.</li><li>예를 들어 <code>jobs.v1.batch/myjob</code>과 같이 전체 버전을 사용한다. 이를 통해 <code>kubectl</code>이 시간이 지남에 따라 변경될 수 있는 기본 버전을 사용하지 않도록 한다.</li><li>문맥, 설정 또는 기타 암묵적 상태에 의존하지 않는다.</li></ul><h2 id=subresources>서브리소스</h2><ul><li>kubectl의 <code>get</code>, <code>patch</code>, <code>edit</code> 및 <code>replace</code>와 같은 명령어에서
서브리소스를 지원하는 모든 리소스에 대해 <code>--subresource</code> 알파 플래그를 사용하여
서브리소스를 조회하고 업데이트할 수 있다. 현재, <code>status</code>와 <code>scale</code> 서브리소스만 지원된다.</li><li>서브리소스에 대한 API 계약은 전체 리소스와 동일하다.
<code>status</code> 서브리소스를 새 값으로 업데이트해도,
컨트롤러에서 서브리소스를 잠재적으로 다른 값으로 조정할 수 있다는 점을 염두에 두어야 한다.</li></ul><h2 id=모범-사례>모범 사례</h2><h3 id=kubectl-run><code>kubectl run</code></h3><p><code>kubectl run</code>으로 infrastructure as code를 충족시키기 위해서</p><ul><li>버전이 명시된 태그로 이미지를 태그하고 그 태그를 새로운 버전으로 이동하지 않는다. 예를 들어, <code>:latest</code>가 아닌 <code>:v1234</code>, <code>v1.2.3</code>, <code>r03062016-1-4</code>를 사용한다(자세한 정보는 <a href=/ko/docs/concepts/configuration/overview/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%9D%B4%EB%AF%B8%EC%A7%80>구성 모범 사례</a>를 참고한다).</li><li>많은 파라미터가 적용된 이미지를 위한 스크립트를 작성한다.</li><li>필요하지만 <code>kubectl run</code> 플래그를 통해 표현할 수 없는 기능은 구성 파일을 소스 코드 버전 관리 시스템에 넣어서 전환한다.</li></ul><p><code>--dry-run</code> 플래그를 사용하여 실제로 제출하지 않고 클러스터로 보낼 오브젝트를 미리 볼 수 있다.</p><h3 id=kubectl-apply><code>kubectl apply</code></h3><ul><li><code>kubectl apply</code>를 사용해서 리소스를 생성하거나 업데이트 할 수 있다. kubectl apply를 사용하여 리소스를 업데이트하는 방법에 대한 자세한 정보는 <a href=https://kubectl.docs.kubernetes.io>Kubectl 책</a>을 참고한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a7abc09192597e614b58f8b552b682f5>5 - 도커 사용자를 위한 kubectl</h1><p>당신은 쿠버네티스 커맨드 라인 도구인 <code>kubectl</code>을 사용하여 API 서버와 상호 작용할 수 있다. 만약 도커 커맨드 라인 도구에 익숙하다면 <code>kubectl</code>을 사용하는 것은 간단하다. 다음 섹션에서는 도커의 하위 명령을 보여주고 <code>kubectl</code>과 같은 명령어를 설명한다.</p><h2 id=docker-run>docker run</h2><p>nginx 디플로이먼트(Deployment)를 실행하고 해당 디플로이먼트를 노출시키려면, <a href=/docs/reference/generated/kubectl/kubectl-commands#-em-deployment-em->kubectl create deployment</a>을 참고한다.
docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -d --restart<span style=color:#666>=</span>always -e <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster --name nginx-app -p 80:80 nginx
</span></span></code></pre></div><pre tabindex=0><code>55c103fa129692154a7652490236fee9be47d70a8dd562281ae7d2f9a339a6db
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   9 seconds ago       Up 9 seconds        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># nginx 실행하는 파드를 시작한다</span>
</span></span><span style=display:flex><span>kubectl create deployment --image<span style=color:#666>=</span>nginx nginx-app
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/nginx-app created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># nginx-app 에 env를 추가한다</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> env deployment/nginx-app  <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/nginx-app env updated
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubectl</code> 커맨드는 생성되거나 변경된 리소스의 유형과 이름을 출력하므로, 이를 후속 커맨드에 사용할 수 있다. 디플로이먼트가 생성된 후에는 새로운 서비스를 노출할 수 있다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 서비스를 통해 포트를 노출</span>
</span></span><span style=display:flex><span>kubectl expose deployment nginx-app --port<span style=color:#666>=</span><span style=color:#666>80</span> --name<span style=color:#666>=</span>nginx-http
</span></span></code></pre></div><pre tabindex=0><code>service &#34;nginx-http&#34; exposed
</code></pre><p>kubectl을 사용하면, N개의 파드가 nginx를 실행하도록 <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>를 생성할 수 있다. 여기서 N은 스펙에 명시된 레플리카 수이며, 기본값은 1이다. 또한 파드의 레이블과 셀럭터를 사용하여 서비스를 생성할 수 있다. 자세한 내용은 <a href=/ko/docs/tasks/access-application-cluster/service-access-application-cluster>클러스터 내 애플리케이션에 접근하기 위해 서비스 사용하기</a>를 참고한다.</p><p>기본적으로 이미지는 <code>docker run -d ...</code> 와 비슷하게 백그라운드로 실행된다. 포그라운드로 실행하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#run><code>kubectl run</code></a>을 이용하여 파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run <span style=color:#666>[</span>-i<span style=color:#666>]</span> <span style=color:#666>[</span>--tty<span style=color:#666>]</span> --attach &lt;name&gt; --image<span style=color:#666>=</span>&lt;image&gt;
</span></span></code></pre></div><p><code>docker run ...</code> 과 달리 <code>--attach</code> 를 지정하면 <code>표준 입력(stdin)</code>, <code>표준 출력(stdout)</code> 및 <code>표준 오류(stderr)</code>가 붙는다. 연결된(attached) 스트림을 제어할 수 없다(<code>docker -a ...</code>).
해당 컨테이너에서 분리(detach)하려면 이스케이프 시퀀스(escape sequence) Ctrl+P를 입력한 다음 Ctrl+Q를 입력한다.</p><h2 id=docker-ps>docker ps</h2><p>현재 실행 중인 목록을 보기 위해서는 <a href=/docs/reference/generated/kubectl/kubectl-commands/#get>kubectl get</a>을 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps -a
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                NAMES
14636241935f        ubuntu:16.04        &#34;echo test&#34;              5 seconds ago        Exited (0) 5 seconds ago                        cocky_fermi
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   About a minute ago   Up About a minute          0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po
</span></span></code></pre></div><pre tabindex=0><code>NAME                        READY     STATUS      RESTARTS   AGE
nginx-app-8df569cb7-4gd89   1/1       Running     0          3m
ubuntu                      0/1       Completed   0          20s
</code></pre><h2 id=docker-attach>docker attach</h2><p>이미 실행 중인 컨테이너에 연결하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#attach>kubectl attach</a>를 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   5 minutes ago       Up 5 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker attach 55c103fa1296
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it nginx-app-5jyvm
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>컨테이너에서 분리하려면 이스케이프 시퀀스 Ctrl+P를 입력한 다음 Ctrl+Q를 입력한다.</p><h2 id=docker-exec>docker exec</h2><p>컨테이너에서 커맨드를 실행하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>를 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   6 minutes ago       Up 6 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker <span style=color:#a2f>exec</span> 55c103fa1296 cat /etc/hostname
</span></span></code></pre></div><pre tabindex=0><code>55c103fa1296
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po
</span></span></code></pre></div><pre tabindex=0><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> nginx-app-5jyvm -- cat /etc/hostname
</span></span></code></pre></div><pre tabindex=0><code>nginx-app-5jyvm
</code></pre><p>대화형 커맨드를 사용한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker <span style=color:#a2f>exec</span> -ti 55c103fa1296 /bin/sh
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># exit</span>
</span></span></code></pre></div><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -ti nginx-app-5jyvm -- /bin/sh
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># exit</span>
</span></span></code></pre></div><p>자세한 내용은 <a href=/ko/docs/tasks/debug/debug-application/get-shell-running-container/>실행 중인 컨테이너의 셸 얻기</a>를 참고한다.</p><h2 id=docker-logs>docker logs</h2><p>실행 중인 프로세스의 표준 입력(stdout)/표준 오류(stderr)를 수행하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#logs>kubectl logs</a>를 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker logs -f a9e
</span></span></code></pre></div><pre tabindex=0><code>192.168.9.1 - - [14/Jul/2015:01:04:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.35.0&#34; &#34;-&#34;
192.168.9.1 - - [14/Jul/2015:01:04:03 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.35.0&#34; &#34;-&#34;
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs -f nginx-app-zibvs
</span></span></code></pre></div><pre tabindex=0><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
</code></pre><p>파드와 컨테이너에는 근소한 차이가 있다. 기본적으로 파드는 프로세스가 종료되어도 종료되지 않는다. 대신 파드가 프로세스를 다시 시작한다. 이는 도커의 실행 옵션인 <code>--restart=always</code>와 유사하지만, 한 가지 큰 차이점이 있다. 도커에서는 프로세스의 각 호출에 대한 출력이 연결되지만, 쿠버네티스의 경우 각 호출은 별개다. 쿠버네티스에서 이전 실행의 출력 내용을 보려면 다음을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs --previous nginx-app-zibvs
</span></span></code></pre></div><pre tabindex=0><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
</code></pre><p>자세한 정보는 <a href=/ko/docs/concepts/cluster-administration/logging/>로깅 아키텍처</a>를 참고한다.</p><h2 id=docker-stop-과-docker-rm>docker stop 과 docker rm</h2><p>실행 중인 프로세스를 중지하고 삭제하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#delete>kubectl delete</a>을 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
a9ec34d98787        nginx               &#34;nginx -g &#39;daemon of&#34;  22 hours ago        Up 22 hours         0.0.0.0:80-&gt;80/tcp, 443/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker stop a9ec34d98787
</span></span></code></pre></div><pre tabindex=0><code>a9ec34d98787
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker rm a9ec34d98787
</span></span></code></pre></div><pre tabindex=0><code>a9ec34d98787
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment nginx-app
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
nginx-app    1/1     1            1           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
</span></span></code></pre></div><pre tabindex=0><code>NAME                         READY     STATUS    RESTARTS   AGE
nginx-app-2883164633-aklf7   1/1       Running   0          2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-app
</span></span></code></pre></div><pre tabindex=0><code>deployment &#34;nginx-app&#34; deleted
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 아무것도 반환하지 않는다</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> kubectl을 사용할 때는 파드를 직접 삭제하지 않는다. 먼저 파드를 소유한 디플로이먼트를 삭제해야 한다. 만약 파드를 직접 삭제하면 디플로이먼트가 파드를 재생성할 것이다.</div><h2 id=docker-login>docker login</h2><p>kubectl은 <code>docker login</code>와 직접적인 유사점은 없다. 프라이빗 레지스트리와 함께 쿠버네티스를 사용하려면 <a href=/ko/docs/concepts/containers/images/#%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B9%97-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%8A%B8%EB%A6%AC-%EC%82%AC%EC%9A%A9>프라이빗 레지스트리 사용</a>을 참고한다.</p><h2 id=docker-version>docker version</h2><p>클라이언트와 서버의 버전을 가져오려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#version>kubectl version</a>을 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker version
</span></span></code></pre></div><pre tabindex=0><code>Client version: 1.7.0
Client API version: 1.19
Go version (client): go1.4.2
Git commit (client): 0baf609
OS/Arch (client): linux/amd64
Server version: 1.7.0
Server API version: 1.19
Go version (server): go1.4.2
Git commit (server): 0baf609
OS/Arch (server): linux/amd64
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl version
</span></span></code></pre></div><pre tabindex=0><code>Client Version: version.Info{Major:&#34;1&#34;, Minor:&#34;6&#34;, GitVersion:&#34;v1.6.9+a3d1dfa6f4335&#34;, GitCommit:&#34;9b77fed11a9843ce3780f70dd251e92901c43072&#34;, GitTreeState:&#34;dirty&#34;, BuildDate:&#34;2017-08-29T20:32:58Z&#34;, OpenPaasKubernetesVersion:&#34;v1.03.02&#34;, GoVersion:&#34;go1.7.5&#34;, Compiler:&#34;gc&#34;, Platform:&#34;linux/amd64&#34;}
Server Version: version.Info{Major:&#34;1&#34;, Minor:&#34;6&#34;, GitVersion:&#34;v1.6.9+a3d1dfa6f4335&#34;, GitCommit:&#34;9b77fed11a9843ce3780f70dd251e92901c43072&#34;, GitTreeState:&#34;dirty&#34;, BuildDate:&#34;2017-08-29T20:32:58Z&#34;, OpenPaasKubernetesVersion:&#34;v1.03.02&#34;, GoVersion:&#34;go1.7.5&#34;, Compiler:&#34;gc&#34;, Platform:&#34;linux/amd64&#34;}
</code></pre><h2 id=docker-info>docker info</h2><p>환경 및 설정에 대한 자세한 정보는 <a href=/docs/reference/generated/kubectl/kubectl-commands/#cluster-info>kubectl cluster-info</a>를 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker info
</span></span></code></pre></div><pre tabindex=0><code>Containers: 40
Images: 168
Storage Driver: aufs
 Root Dir: /usr/local/google/docker/aufs
 Backing Filesystem: extfs
 Dirs: 248
 Dirperm1 Supported: false
Execution Driver: native-0.2
Logging Driver: json-file
Kernel Version: 3.13.0-53-generic
Operating System: Ubuntu 14.04.2 LTS
CPUs: 12
Total Memory: 31.32 GiB
Name: k8s-is-fun.mtv.corp.google.com
ID: ADUV:GCYR:B3VJ:HMPO:LNPQ:KD5S:YKFQ:76VN:IANZ:7TFV:ZBF4:BYJO
WARNING: No swap limit support
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><pre tabindex=0><code>Kubernetes master is running at https://203.0.113.141
KubeDNS is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/kube-dns/proxy
kubernetes-dashboard is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy
Grafana is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
Heapster is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
InfluxDB is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-influxdb/proxy
</code></pre></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>