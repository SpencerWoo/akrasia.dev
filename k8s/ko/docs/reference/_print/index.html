<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/reference/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/reference/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/reference/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/reference/><link rel=alternate hreflang=hi href=https://kubernetes.io/hi/docs/reference/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/reference/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/reference/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/reference/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>레퍼런스 | Kubernetes</title><meta property="og:title" content="레퍼런스"><meta property="og:description" content="운영 수준의 컨테이너 오케스트레이션"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/reference/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="레퍼런스"><meta itemprop=description content="운영 수준의 컨테이너 오케스트레이션"><meta name=twitter:card content="summary"><meta name=twitter:title content="레퍼런스"><meta name=twitter:description content="운영 수준의 컨테이너 오케스트레이션"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="쿠버네티스 문서의 본 섹션에서는 레퍼런스를 다룬다.
API 레퍼런스 표준 용어집 - 포괄적이고, 표준화 된 쿠버네티스 용어 목록
쿠버네티스 API 레퍼런스
쿠버네티스 v1.25용 원페이지(One-page) API 레퍼런스
쿠버네티스 API 사용 - 쿠버네티스 API에 대한 개요
API 접근 제어 - 쿠버네티스가 API 접근을 제어하는 방법에 대한 세부사항
잘 알려진 레이블, 어노테이션과 테인트
공식적으로 지원되는 클라이언트 라이브러리 프로그래밍 언어에서 쿠버네티스 API를 호출하기 위해서, 클라이언트 라이브러리를 사용할 수 있다. 공식적으로 지원되는 클라이언트 라이브러리는 다음과 같다."><meta property="og:description" content="쿠버네티스 문서의 본 섹션에서는 레퍼런스를 다룬다.
API 레퍼런스 표준 용어집 - 포괄적이고, 표준화 된 쿠버네티스 용어 목록
쿠버네티스 API 레퍼런스
쿠버네티스 v1.25용 원페이지(One-page) API 레퍼런스
쿠버네티스 API 사용 - 쿠버네티스 API에 대한 개요
API 접근 제어 - 쿠버네티스가 API 접근을 제어하는 방법에 대한 세부사항
잘 알려진 레이블, 어노테이션과 테인트
공식적으로 지원되는 클라이언트 라이브러리 프로그래밍 언어에서 쿠버네티스 API를 호출하기 위해서, 클라이언트 라이브러리를 사용할 수 있다. 공식적으로 지원되는 클라이언트 라이브러리는 다음과 같다."><meta name=twitter:description content="쿠버네티스 문서의 본 섹션에서는 레퍼런스를 다룬다.
API 레퍼런스 표준 용어집 - 포괄적이고, 표준화 된 쿠버네티스 용어 목록
쿠버네티스 API 레퍼런스
쿠버네티스 v1.25용 원페이지(One-page) API 레퍼런스
쿠버네티스 API 사용 - 쿠버네티스 API에 대한 개요
API 접근 제어 - 쿠버네티스가 API 접근을 제어하는 방법에 대한 세부사항
잘 알려진 레이블, 어노테이션과 테인트
공식적으로 지원되는 클라이언트 라이브러리 프로그래밍 언어에서 쿠버네티스 API를 호출하기 위해서, 클라이언트 라이브러리를 사용할 수 있다. 공식적으로 지원되는 클라이언트 라이브러리는 다음과 같다."><meta property="og:url" content="https://kubernetes.io/ko/docs/reference/"><meta property="og:title" content="레퍼런스"><meta name=twitter:title content="레퍼런스"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/reference/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/reference/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/reference/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/reference/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/reference/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/reference/>English</a>
<a class=dropdown-item href=/zh-cn/docs/reference/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/reference/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/reference/>Français (French)</a>
<a class=dropdown-item href=/de/docs/reference/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/reference/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/reference/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/reference/>Bahasa Indonesia</a>
<a class=dropdown-item href=/hi/docs/reference/>हिन्दी (Hindi)</a>
<a class=dropdown-item href=/ru/docs/reference/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/reference/>Polski (Polish)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/reference/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>레퍼런스</h1><ul><li>1: <a href=#pg-2b03679960950df772fb4fe7d78427b9>용어집</a></li><li>2: <a href=#pg-882c82a32bfb4d7946585a93a966b442>API 개요</a></li><ul><li>2.1: <a href=#pg-79880efc25dc8cb3b6962ad78a964319>클라이언트 라이브러리</a></li><li>2.2: <a href=#pg-e4dbb59f8f23854d7b7d574e169923c4>쿠버네티스 API 헬스(health) 엔드포인트</a></li></ul><li>3: <a href=#pg-99b26586d8a33ec06996dcf7892a9683>API 접근 제어</a></li><ul><li>3.1: <a href=#pg-de45b6ca7419a0e308044425b2ac52bb>부트스트랩 토큰을 사용한 인증</a></li><li>3.2: <a href=#pg-bea207258f3576b8ec7444a20d498e1d>서비스 어카운트 관리하기</a></li><li>3.3: <a href=#pg-342be69d36f174f762c36f4fe11fcb20>인가 개요</a></li><li>3.4: <a href=#pg-36e1423f0b5caa8eafeb6f53c175d13c>Kubelet 인증/인가</a></li></ul><li>4: <a href=#pg-e7512a333ae98d32429d24b2290eb15a>잘 알려진 레이블, 어노테이션, 테인트(Taint)</a></li><ul></ul><li>5: <a href=#pg-75e3b4b5f680fdd081dc8af8060a2bf7>노드 레퍼런스 정보</a></li><ul><li>5.1: <a href=#pg-26e96c9d268f9c39dfc525b98f477a12>도커심 제거 및 CRI 호환 런타임 사용에 대한 기사</a></li></ul><li>6: <a href=#pg-af7c1f9168ec67f957edc504f43faf9a>쿠버네티스 이슈와 보안</a></li><ul><li>6.1: <a href=#pg-980c0542a3b195a20cfd4358792e2a38>쿠버네티스 이슈 트래커</a></li><li>6.2: <a href=#pg-1f7dc06f1cc1ea2cdde4480e54d5fb34>쿠버네티스 보안과 공개 정보</a></li></ul><li>7: <a href=#pg-5bbbc5163b35431b3bff029ab9ec57d3>설치 도구</a></li><ul><li>7.1: <a href=#pg-f351ced098abbb076bc8c4be1053672b>Kubeadm</a></li><ul><li>7.1.1: <a href=#pg-36c22b52e8447eb3d2452d4f56fbea9b>Kubeadm Generated</a></li><ul></ul></ul></ul><li>8: <a href=#pg-df8ff2190764e70c3de2015e2cb46b14>포트와 프로토콜</a></li><li>9: <a href=#pg-03460a7254c6c73eb2a1bb3dd7d25910>명령줄 도구 (kubectl)</a></li><ul><li>9.1: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>kubectl 치트 시트</a></li><li>9.2: <a href=#pg-4d3e62632c189fcc3c1357cd8fb8799c>kubectl</a></li><li>9.3: <a href=#pg-a938176c695852fe70362c29cf615f1c>JSONPath 지원</a></li><li>9.4: <a href=#pg-8de6aceb8bf692c06cced446bac5bc92>kubectl 사용 규칙</a></li><li>9.5: <a href=#pg-a7abc09192597e614b58f8b552b682f5>도커 사용자를 위한 kubectl</a></li></ul><li>10: <a href=#pg-54e562dd1441d0195970a6526b0055cc>컴포넌트 도구</a></li><ul><li>10.1: <a href=#pg-ca5d01a42c486d535539d3038aa67eb9>기능 게이트</a></li><li>10.2: <a href=#pg-a727de6cb5a090d5f115f88a8606c438>kube-proxy</a></li></ul><li>11: <a href=#pg-f8b023454daa9497b7eea35b7d35c075>스케줄링</a></li><ul><li>11.1: <a href=#pg-ef4fb938b6b63c95f5f26f9b1cec3054>스케줄러 구성</a></li><li>11.2: <a href=#pg-5a0a68fb6a7ffefb6d5f861100fa0ae3>스케줄링 정책</a></li></ul><li>12: <a href=#pg-c808ce38575e73f72835d7ed02b03780>도구</a></li><ul></ul></ul><div class=content><p>쿠버네티스 문서의 본 섹션에서는 레퍼런스를 다룬다.</p><h2 id=api-레퍼런스>API 레퍼런스</h2><ul><li><p><a href=/ko/docs/reference/glossary/>표준 용어집</a> - 포괄적이고, 표준화 된 쿠버네티스 용어 목록</p></li><li><p><a href=/docs/reference/kubernetes-api/>쿠버네티스 API 레퍼런스</a></p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 v1.25용 원페이지(One-page) API 레퍼런스</a></p></li><li><p><a href=/ko/docs/reference/using-api/>쿠버네티스 API 사용</a> - 쿠버네티스 API에 대한 개요</p></li><li><p><a href=/ko/docs/reference/access-authn-authz/>API 접근 제어</a> - 쿠버네티스가 API 접근을 제어하는 방법에 대한 세부사항</p></li><li><p><a href=/ko/docs/reference/labels-annotations-taints/>잘 알려진 레이블, 어노테이션과 테인트</a></p></li></ul><h2 id=공식적으로-지원되는-클라이언트-라이브러리>공식적으로 지원되는 클라이언트 라이브러리</h2><p>프로그래밍 언어에서 쿠버네티스 API를 호출하기 위해서,
<a href=/ko/docs/reference/using-api/client-libraries/>클라이언트 라이브러리</a>를 사용할 수 있다.
공식적으로 지원되는 클라이언트 라이브러리는 다음과 같다.</p><ul><li><a href=https://github.com/kubernetes/client-go/>쿠버네티스 Go 클라이언트 라이브러리</a></li><li><a href=https://github.com/kubernetes-client/python>쿠버네티스 Python 클라이언트 라이브러리</a></li><li><a href=https://github.com/kubernetes-client/java>쿠버네티스 Java 클라이언트 라이브러리</a></li><li><a href=https://github.com/kubernetes-client/javascript>쿠버네티스 JavaScript 클라이언트 라이브러리</a></li><li><a href=https://github.com/kubernetes-client/csharp>쿠버네티스 C# 클라이언트 라이브러리</a></li><li><a href=https://github.com/kubernetes-client/haskell>쿠버네티스 Haskell 클라이언트 라이브러리</a></li></ul><h2 id=cli>CLI</h2><ul><li><a href=/ko/docs/reference/kubectl/>kubectl</a> - 명령어를 실행하거나 쿠버네티스 클러스터를 관리하기 위해 사용하는 주된 CLI 도구.<ul><li><a href=/ko/docs/reference/kubectl/jsonpath/>JSONPath</a> - kubectl에서 <a href=https://goessner.net/articles/JsonPath/>JSONPath 표현</a>을 사용하기 위한 문법 가이드.</li></ul></li><li><a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a> - 안정적인 쿠버네티스 클러스터를 쉽게 프로비전하기 위한 CLI 도구.</li></ul><h2 id=컴포넌트>컴포넌트</h2><ul><li><p><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> - 각
노드에서 구동되는 주요한 에이전트. kubelet은 PodSpecs 집합을 가지며
기술된 컨테이너가 구동되고 있는지, 정상 작동하는지를 보장한다.</p></li><li><p><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a> -
파드, 서비스, 레플리케이션 컨트롤러와 같은 API 오브젝트에 대한 검증과 구성을
수행하는 REST API.</p></li><li><p><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a> - 쿠버네티스에 탑재된 핵심 제어 루프를 포함하는 데몬.</p></li><li><p><a href=/ko/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> - 간단한
TCP/UDP 스트림 포워딩이나 백-엔드 집합에 걸쳐서 라운드-로빈 TCP/UDP 포워딩을
할 수 있다.</p></li><li><p><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a> - 가용성, 성능 및 용량을 관리하는 스케줄러.</p><ul><li><a href=/ko/docs/reference/scheduling/policies>kube-scheduler 정책</a></li><li><a href=/ko/docs/reference/scheduling/config/#%EC%97%AC%EB%9F%AC-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC>kube-scheduler 프로파일</a></li></ul></li><li><p>컨트롤 플레인과 워커 노드에서 꼭 열어야 하는
<a href=/ko/docs/reference/ports-and-protocols/>포트와 프로토콜</a> 리스트</p></li></ul><h2 id=api-설정>API 설정</h2><p>이 섹션은 쿠버네티스 구성요소 또는 도구를 환경설정하는 데에 사용되는
"미발표된" API를 다룬다. 이 API들은 사용자나 관리자가 클러스터를
사용/관리하는 데에 중요하지만, 이들 API의 대부분은 아직 API 서버가
제공하지 않는다.</p><ul><li><a href=/docs/reference/config-api/apiserver-config.v1alpha1/>kube-apiserver 환경설정 (v1alpha1)</a></li><li><a href=/docs/reference/config-api/apiserver-config.v1/>kube-apiserver 환경설정 (v1)</a></li><li><a href=/docs/reference/config-api/apiserver-encryption.v1/>kube-apiserver 암호화 (v1)</a></li><li><a href=/docs/reference/config-api/apiserver-eventratelimit.v1alpha1/>kube-apiserver 요청 제한 (v1alpha1)</a></li><li><a href=/docs/reference/config-api/kubelet-config.v1alpha1/>kubelet 환경설정 (v1alpha1)</a> 및
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>kubelet 환경설정 (v1beta1)</a></li><li><a href=/docs/reference/config-api/kubelet-credentialprovider.v1alpha1/>kubelet 자격증명 제공자 (v1alpha1)</a></li><li><a href=/docs/reference/config-api/kubelet-credentialprovider.v1beta1/>kubelet 자격증명 제공자 (v1beta1)</a></li><li><a href=/docs/reference/config-api/kube-scheduler-config.v1beta2/>kube-scheduler 환경설정 (v1beta2)</a> 및
<a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler 환경설정 (v1beta3)</a></li><li><a href=/docs/reference/config-api/kube-proxy-config.v1alpha1/>kube-proxy 환경설정 (v1alpha1)</a></li><li><a href=/docs/reference/config-api/apiserver-audit.v1/><code>audit.k8s.io/v1</code> API</a></li><li><a href=/docs/reference/config-api/client-authentication.v1beta1/>클라이언트 인증 API (v1beta1)</a> 및
<a href=/docs/reference/config-api/client-authentication.v1/>클라이언트 인증 API (v1)</a></li><li><a href=/docs/reference/config-api/apiserver-webhookadmission.v1/>WebhookAdmission 환경설정 (v1)</a></li><li><a href=/docs/reference/config-api/imagepolicy.v1alpha1/>이미지 정책 API (v1alpha1)</a></li></ul><h2 id=kubeadm을-위한-api-설정>kubeadm을 위한 API 설정</h2><ul><li><a href=/docs/reference/config-api/kubeadm-config.v1beta2/>v1beta2</a></li><li><a href=/docs/reference/config-api/kubeadm-config.v1beta3/>v1beta3</a></li></ul><h2 id=설계-문서>설계 문서</h2><p>쿠버네티스 기능에 대한 설계 문서의 아카이브.
<a href=https://git.k8s.io/design-proposals-archive/architecture/architecture.md>쿠버네티스 아키텍처</a>와
<a href=https://git.k8s.io/design-proposals-archive>쿠버네티스 디자인 개요</a>부터 읽어보는 것이 좋다.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-2b03679960950df772fb4fe7d78427b9>1 - 용어집</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-882c82a32bfb4d7946585a93a966b442>2 - API 개요</h1><p>이 섹션은 쿠버네티스 API에 대한 참조 정보를 제공한다.</p><p>REST API는 쿠버네티스의 근본적인 구조이다. 모든 조작,
컴포넌트 간의 통신과 외부 사용자의 명령은 API 서버에서 처리할 수 있는
REST API 호출이다. 따라서, 쿠버네티스 플랫폼 안의 모든 것은
API 오브젝트로 취급되고,
<a href=/docs/reference/generated/kubernetes-api/v1.25/>API</a>에 상응하는 항목이 있다.</p><p><a href=/docs/reference/generated/kubernetes-api/v1.25/>쿠버네티스 API 참조</a>는
쿠버네티스 버전 v1.25에 대한 API가 나열되어 있다.</p><p>일반적인 배경 정보를 보려면,
<a href=/ko/docs/concepts/overview/kubernetes-api/>쿠버네티스 API</a>를 참고한다.
<a href=/ko/docs/concepts/security/controlling-access/>쿠버네티스 API에 대한 접근 제어</a>는
클라이언트가 쿠버네티스 API 서버에 인증하는 방법과
요청이 승인되는 방법을 설명한다.</p><h2 id=api-버전-규칙>API 버전 규칙</h2><p>JSON과 Protobuf 직렬화 스키마 모두 스키마 변경에 대해서
동일한 가이드라인을 따른다. 이후 설명에서는 이 형식 모두를 다룬다.</p><p>API 버전 규칙과 소프트웨어 버전 규칙은 간접적으로 연관된다.
<a href=https://git.k8s.io/sig-release/release-engineering/versioning.md>API와 릴리스 버전 부여에 관한 제안</a>에는
API 버전 규칙과 소프트웨어 버전 규칙 간의 관계가 기술되어 있다.</p><p>API 버전의 차이는 수준의 안정성과 지원의 차이를 나타낸다.
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>API 변경 문서</a>에서
각 수준의 기준에 대한 더 많은 정보를 찾을 수 있다.</p><p>아래는 각 수준의 기준에 대한 요약이다.</p><ul><li><p>알파(Alpha):</p><ul><li>버전 이름에 <code>alpha</code>가 포함된다(예: <code>v1alpha1</code>).</li><li>버그가 있을 수도 있다. 이 기능을 활성화하면 버그에 노출될 수 있다.
기본적으로 비활성화되어 있다.</li><li>기능에 대한 기술 지원이 언제든 공지 없이 중단될 수 있다.</li><li>다음 소프트웨어를 릴리스할 때 공지 없이 API의 호환성이 깨지는 방식으로 변경될 수 있다.</li><li>버그에 대한 위험이 높고 장기간 지원되지 않으므로
단기간 테스트 용도의 클러스터에서만 사용하기를 권장한다.</li></ul></li><li><p>베타(Beta):</p><ul><li><p>버전 이름에 <code>beta</code>가 포함된다(예: <code>v2beta3</code>).</p></li><li><p>코드가 잘 테스트 되었다. 이 기능을 활성화해도 안전하다.
기본적으로 활성화되어 있다.</p></li><li><p>구체적인 내용이 바뀔 수는 있지만, 전반적인 기능에 대한 기술 지원이 중단되지 않는다.</p></li><li><p>오브젝트에 대한 스키마나 문법이 다음 베타 또는 안정화 릴리스에서
호환되지 않는 방식으로 바뀔 수도 있다. 이런 경우, 다음 버전으로
이관할 수 있는 가이드가 제공된다. 스키마 변경은 API 오브젝트의 삭제, 편집 또는 재생성이
필요할 수도 있다. 편집 절차는 좀 생각해볼 필요가 있다.
이 기능에 의존하고 있는 애플리케이션은 다운타임이 필요할 수도 있다.</p></li><li><p>이 소프트웨어는 프로덕션 용도로 권장하지 않는다. 이후 여러 버전에서
호환되지 않는 변경 사항이 적용될 수 있다. 복수의 클러스터를 가지고 있어서
독립적으로 업그레이드할 수 있다면, 이런 제약에서 벗어날 수도 있다.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 베타 기능을 사용해보고 피드백을 제공하자. 기능이 베타 수준을 벗어난 이후에는
실질적으로 더 많은 변경이 어렵다.</div></li><li><p>안정화(Stable):</p><ul><li>버전 이름이 <code>vX</code>이고 <code>X</code> 는 정수다.</li><li>안정화 버전의 기능은 이후 여러 버전에 걸쳐서 소프트웨어 릴리스에 포함된다.</li></ul></li></ul><h2 id=api-그룹>API 그룹</h2><p><a href=https://git.k8s.io/design-proposals-archive/api-machinery/api-group.md>API 그룹</a>은
쿠버네티스 API를 더 쉽게 확장할 수 있도록 해 준다.
API 그룹은 REST 경로와 직렬화된 오브젝트의 <code>apiVersion</code> 필드에
명시된다.</p><p>쿠버네티스에는 다음과 같은 다양한 API 그룹이 있다.</p><ul><li><em>핵심</em> (또는 <em>레거시</em> 라고 불리는) 그룹은 REST 경로 <code>/api/v1</code>에 있다.
핵심 그룹은 <code>apiVersion</code> 필드의 일부로 명시되지 않는다. 예를
들어, <code>apiVersion: v1</code> 과 같다.</li><li>이름이 있는 그룹은 REST 경로 <code>/apis/$GROUP_NAME/$VERSION</code>에 있으며
<code>apiVersion: $GROUP_NAME/$VERSION</code>을 사용한다(예를 들어, <code>apiVersion: batch/v1</code>).
지원되는 API 그룹 전체의 목록은
<a href=/docs/reference/generated/kubernetes-api/v1.25/#-strong-api-groups-strong->쿠버네티스 API 참조 문서</a>에서 확인할 수 있다.</li></ul><h2 id=api-그룹-활성화-또는-비활성화>API 그룹 활성화 또는 비활성화</h2><p>특정 리소스 및 API 그룹은 기본적으로 활성화된다. API 서버에서
<code>--runtime-config</code> 를 설정하여 활성화 또는 비활성화할 수 있다.
<code>--runtime-config</code> 플래그는 API 서버의 런타임 구성을 설명하는
쉼표로 구분된 <code>&lt;key>=&lt;value></code> 쌍을 허용한다. 만약 <code>=&lt;value></code>
부분을 생략하면, <code>=true</code> 가 명시된 것처럼 취급한다. 예를 들면, 다음과 같다.</p><ul><li><code>batch/v1</code> 을 비활성화하려면, <code>--runtime-config=batch/v1=false</code> 로 설정</li><li><code>batch/v2alpha1</code> 을 활성화하려면, <code>--runtime-config=batch/v2alpha1</code> 으로 설정</li><li>예를 들어 <code>storage.k8s.io/v1beta1/csistoragecapacities</code>와 같이 특정 버전의 API를 활성화하려면, <code>--runtime-config=storage.k8s.io/v1beta1/csistoragecapacities</code>와 같이 설정</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 그룹이나 리소스를 활성화 또는 비활성화하려면, apiserver와 controller-manager를 재시작하여
<code>--runtime-config</code> 변경을 반영해야 한다.</div><h2 id=지속성>지속성</h2><p>쿠버네티스는 <a class=glossary-tooltip title='모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>에 기록하여 API 리소스 측면에서
직렬화된 상태를 저장한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#api-conventions>API 규칙</a>에 대해 자세히 알아보기</li><li><a href=https://git.k8s.io/design-proposals-archive/api-machinery/aggregated-api-servers.md>애그리게이터(aggregator)</a>에
대한 디자인 문서 읽기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-79880efc25dc8cb3b6962ad78a964319>2.1 - 클라이언트 라이브러리</h1><p>이 페이지는 다양한 프로그래밍 언어에서 쿠버네티스 API를 사용하기 위한
클라이언트 라이브러리에 대한 개요를 포함하고 있다.</p><p><a href=/ko/docs/reference/using-api/>쿠버네티스 REST API</a>를 사용해 애플리케이션을 작성하기 위해
API 호출 또는 요청/응답 타입을 직접 구현할 필요는 없다.
사용하고 있는 프로그래밍 언어를 위한 클라이언트 라이브러리를 사용하면 된다.</p><p>클라이언트 라이브러리는 대체로 인증과 같은 공통의 태스크를 처리한다.
대부분의 클라이언트 라이브러리들은 API 클라이언트가 쿠버네티스 클러스터 내부에서 동작하는 경우 인증
또는 <a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig 파일</a> 포맷을 통해
자격증명과 API 서버 주소를 읽을 수 있게
쿠버네티스 서비스 어카운트를 발견하고 사용할 수 있다.</p><h2 id=공식적으로-지원되는-쿠버네티스-클라이언트-라이브러리>공식적으로 지원되는 쿠버네티스 클라이언트 라이브러리</h2><p>다음의 클라이언트 라이브러리들은
<a href=https://github.com/kubernetes/community/tree/master/sig-api-machinery>쿠버네티스 SIG API Machinery</a>에서 공식적으로 관리된다.</p><table><thead><tr><th>언어</th><th>클라이언트 라이브러리</th><th>예제 프로그램</th></tr></thead><tbody><tr><td>C</td><td><a href=https://github.com/kubernetes-client/c/>github.com/kubernetes-client/c</a></td><td><a href=https://github.com/kubernetes-client/c/tree/master/examples>둘러보기</a></td></tr><tr><td>dotnet</td><td><a href=https://github.com/kubernetes-client/csharp>github.com/kubernetes-client/csharp</a></td><td><a href=https://github.com/kubernetes-client/csharp/tree/master/examples/simple>둘러보기</a></td></tr><tr><td>Go</td><td><a href=https://github.com/kubernetes/client-go/>github.com/kubernetes/client-go/</a></td><td><a href=https://github.com/kubernetes/client-go/tree/master/examples>둘러보기</a></td></tr><tr><td>Haskell</td><td><a href=https://github.com/kubernetes-client/haskell>github.com/kubernetes-client/haskell</a></td><td><a href=https://github.com/kubernetes-client/haskell/tree/master/kubernetes-client/example>둘러보기</a></td></tr><tr><td>Java</td><td><a href=https://github.com/kubernetes-client/java/>github.com/kubernetes-client/java</a></td><td><a href=https://github.com/kubernetes-client/java#installation>둘러보기</a></td></tr><tr><td>JavaScript</td><td><a href=https://github.com/kubernetes-client/javascript>github.com/kubernetes-client/javascript</a></td><td><a href=https://github.com/kubernetes-client/javascript/tree/master/examples>둘러보기</a></td></tr><tr><td>Perl</td><td><a href=https://github.com/kubernetes-client/perl/>github.com/kubernetes-client/perl/</a></td><td><a href=https://github.com/kubernetes-client/perl/tree/master/examples>둘러보기</a></td></tr><tr><td>Python</td><td><a href=https://github.com/kubernetes-client/python/>github.com/kubernetes-client/python/</a></td><td><a href=https://github.com/kubernetes-client/python/tree/master/examples>둘러보기</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/kubernetes-client/ruby/>github.com/kubernetes-client/ruby/</a></td><td><a href=https://github.com/kubernetes-client/ruby/tree/master/examples>둘러보기</a></td></tr></tbody></table><h2 id=커뮤니티에-의해-관리되는-클라이언트-라이브러리>커뮤니티에 의해 관리되는 클라이언트 라이브러리</h2><div class="alert alert-secondary callout third-party-content" role=alert><strong>참고:</strong>
이 섹션은 쿠버네티스에 필요한 기능을 제공하는 써드파티 프로젝트와 관련이 있다. 쿠버네티스 프로젝트 작성자는 써드파티 프로젝트에 책임이 없다. 이 페이지는 <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 웹사이트 가이드라인</a>에 따라 프로젝트를 알파벳 순으로 나열한다. 이 목록에 프로젝트를 추가하려면 변경사항을 제출하기 전에 <a href=/contribute/style/content-guide/#third-party-content>콘텐츠 가이드</a>를 읽어본다.</div><p>다음의 쿠버네티스 API 클라이언트 라이브러리들은 쿠버네티스 팀이 아닌
각각의 저자들이 제공하고 관리한다.</p><table><thead><tr><th>언어</th><th>클라이언트 라이브러리</th></tr></thead><tbody><tr><td>Clojure</td><td><a href=https://github.com/yanatan16/clj-kubernetes-api>github.com/yanatan16/clj-kubernetes-api</a></td></tr><tr><td>DotNet</td><td><a href=https://github.com/tonnyeremin/kubernetes_gen>github.com/tonnyeremin/kubernetes_gen</a></td></tr><tr><td>DotNet (RestSharp)</td><td><a href=https://github.com/masroorhasan/Kubernetes.DotNet>github.com/masroorhasan/Kubernetes.DotNet</a></td></tr><tr><td>Elixir</td><td><a href=https://github.com/obmarg/kazan/>github.com/obmarg/kazan</a></td></tr><tr><td>Elixir</td><td><a href=https://github.com/coryodaniel/k8s>github.com/coryodaniel/k8s</a></td></tr><tr><td>Go</td><td><a href=https://github.com/ericchiang/k8s>github.com/ericchiang/k8s</a></td></tr><tr><td>Java (OSGi)</td><td><a href=https://bitbucket.org/amdatulabs/amdatu-kubernetes>bitbucket.org/amdatulabs/amdatu-kubernetes</a></td></tr><tr><td>Java (Fabric8, OSGi)</td><td><a href=https://github.com/fabric8io/kubernetes-client>github.com/fabric8io/kubernetes-client</a></td></tr><tr><td>Java</td><td><a href=https://github.com/manusa/yakc>github.com/manusa/yakc</a></td></tr><tr><td>Lisp</td><td><a href=https://github.com/brendandburns/cl-k8s>github.com/brendandburns/cl-k8s</a></td></tr><tr><td>Lisp</td><td><a href=https://github.com/xh4/cube>github.com/xh4/cube</a></td></tr><tr><td>Node.js (TypeScript)</td><td><a href=https://github.com/Goyoo/node-k8s-client>github.com/Goyoo/node-k8s-client</a></td></tr><tr><td>Node.js</td><td><a href=https://github.com/ajpauwels/easy-k8s>github.com/ajpauwels/easy-k8s</a></td></tr><tr><td>Node.js</td><td><a href=https://github.com/godaddy/kubernetes-client>github.com/godaddy/kubernetes-client</a></td></tr><tr><td>Node.js</td><td><a href=https://github.com/tenxcloud/node-kubernetes-client>github.com/tenxcloud/node-kubernetes-client</a></td></tr><tr><td>Perl</td><td><a href=https://metacpan.org/pod/Net::Kubernetes>metacpan.org/pod/Net::Kubernetes</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/allansun/kubernetes-php-client>github.com/allansun/kubernetes-php-client</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/maclof/kubernetes-client>github.com/maclof/kubernetes-client</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/travisghansen/kubernetes-client-php>github.com/travisghansen/kubernetes-client-php</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/renoki-co/php-k8s>github.com/renoki-co/php-k8s</a></td></tr><tr><td>Python</td><td><a href=https://github.com/fiaas/k8s>github.com/fiaas/k8s</a></td></tr><tr><td>Python</td><td><a href=https://github.com/gtsystem/lightkube>github.com/gtsystem/lightkube</a></td></tr><tr><td>Python</td><td><a href=https://github.com/mnubo/kubernetes-py>github.com/mnubo/kubernetes-py</a></td></tr><tr><td>Python</td><td><a href=https://github.com/tomplus/kubernetes_asyncio>github.com/tomplus/kubernetes_asyncio</a></td></tr><tr><td>Python</td><td><a href=https://github.com/Frankkkkk/pykorm>github.com/Frankkkkk/pykorm</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/abonas/kubeclient>github.com/abonas/kubeclient</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/k8s-ruby/k8s-ruby>github.com/k8s-ruby/k8s-ruby</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/kontena/k8s-client>github.com/kontena/k8s-client</a></td></tr><tr><td>Rust</td><td><a href=https://github.com/clux/kube-rs>github.com/clux/kube-rs</a></td></tr><tr><td>Rust</td><td><a href=https://github.com/ynqa/kubernetes-rust>github.com/ynqa/kubernetes-rust</a></td></tr><tr><td>Scala</td><td><a href=https://github.com/hagay3/skuber>github.com/hagay3/skuber</a></td></tr><tr><td>Scala</td><td><a href=https://github.com/joan38/kubernetes-client>github.com/joan38/kubernetes-client</a></td></tr><tr><td>Swift</td><td><a href=https://github.com/swiftkube/client>github.com/swiftkube/client</a></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e4dbb59f8f23854d7b7d574e169923c4>2.2 - 쿠버네티스 API 헬스(health) 엔드포인트</h1><p>쿠버네티스 <a class=glossary-tooltip title='쿠버네티스 API를 제공하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 서버'>API 서버</a>는 현재 상태를 나타내는 API 엔드포인트를 제공한다.
이 페이지에서는 API 엔드포인트들에 대해 설명하고 이를 사용하는 방법을 다룬다.</p><h2 id=헬스를-위한-api-엔드포인트>헬스를 위한 API 엔드포인트</h2><p>쿠버네티스 API 서버는 현재 상태를 나타내는 세 가지 API 엔드포인트(<code>healthz</code>, <code>livez</code> 와 <code>readyz</code>)를 제공한다.
<code>healthz</code> 엔드포인트는 사용 중단(deprecated)됐으며 (쿠버네티스 v1.16 버전 이후), 대신 보다 구체적인 <code>livez</code> 와 <code>readyz</code> 엔드포인트를 사용해야 한다.
<code>livez</code> 엔드포인트는 <code>--livez-grace-period</code> <a href=/docs/reference/command-line-tools-reference/kube-apiserver>플래그</a> 옵션을 사용하여 시작 대기 시간을 지정할 수 있다.
<code>/readyz</code> 엔드포인트는 <code>--shutdown-delay-duration</code> <a href=/docs/reference/command-line-tools-reference/kube-apiserver>플래그</a> 옵션을 사용하여 정상적(graceful)으로 셧다운할 수 있다.
API 서버의 <code>healthz</code>/<code>livez</code>/<code>readyz</code> 를 사용하는 머신은 HTTP 상태 코드에 의존해야 한다.
상태 코드 200은 호출된 엔드포인트에 따라 API 서버의 <code>healthy</code>/<code>live</code>/<code>ready</code> 상태를 나타낸다.
아래 표시된 더 자세한 옵션은 운영자가 클러스터를 디버깅하거나 특정 API 서버의 상태를 이해하는 데 사용할 수 있다.</p><p>다음의 예시는 헬스 API 엔드포인트와 상호 작용할 수 있는 방법을 보여준다.</p><p>모든 엔드포인트에 대해, <code>verbose</code> 파라미터를 사용하여 검사 항목과 상태를 출력할 수 있다.
이는 운영자가 머신 사용을 위한 것이 아닌, API 서버의 현재 상태를 디버깅하는데 유용하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -k https://localhost:6443/livez?verbose
</span></span></code></pre></div><p>인증을 사용하는 원격 호스트에서 사용할 경우에는 다음과 같이 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --raw<span style=color:#666>=</span><span style=color:#b44>&#39;/readyz?verbose&#39;</span>
</span></span></code></pre></div><p>출력은 다음과 같다.</p><pre><code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
</code></pre><p>또한 쿠버네티스 API 서버는 특정 체크를 제외할 수 있다.
쿼리 파라미터는 다음 예와 같이 조합될 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -k <span style=color:#b44>&#39;https://localhost:6443/readyz?verbose&amp;exclude=etcd&#39;</span>
</span></span></code></pre></div><p>출력에서 etcd 체크가 제외된 것을 보여준다.</p><pre><code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
</code></pre><h2 id=개별-헬스-체크>개별 헬스 체크</h2><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [alpha]</code></div><p>각 개별 헬스 체크는 HTTP 엔드포인트를 노출하며 개별적으로 체크할 수 있다.
개별 체크를 위한 스키마는 <code>/livez/&lt;healthcheck-name></code> 이고, 여기서 <code>livez</code> 와 <code>readyz</code> 는 API 서버의 활성 상태 또는 준비 상태인지를 확인할 때 사용한다.
<code>&lt;healthcheck-name></code> 경로 위에서 설명한 <code>verbose</code> 플래그를 사용해서 찾을 수 있고, <code>[+]</code> 와 <code>ok</code> 사이의 경로를 사용한다.
이러한 개별 헬스 체크는 머신에서 사용되서는 안되며, 운영자가 시스템의 현재 상태를 디버깅하는데 유용하다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -k https://localhost:6443/livez/etcd
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-99b26586d8a33ec06996dcf7892a9683>3 - API 접근 제어</h1><p>쿠버네티스가 API 접근을 구현 및 제어하는 방법에 대한 자세한 내용은
<a href=/ko/docs/concepts/security/controlling-access/>쿠버네티스 API에 대한 접근 제어</a>를 참고한다.</p><p>참조 문헌</p><ul><li><a href=/docs/reference/access-authn-authz/authentication/>인증</a><ul><li><a href=/ko/docs/reference/access-authn-authz/bootstrap-tokens/>부트스트랩 토큰 인증</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/admission-controllers/>승인 컨트롤러</a><ul><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>동적 승인 제어</a></li></ul></li><li><a href=/ko/docs/reference/access-authn-authz/authorization/>인가</a><ul><li><a href=/docs/reference/access-authn-authz/rbac/>역할 기반 접근 제어</a></li><li><a href=/docs/reference/access-authn-authz/abac/>속성 기반 접근 제어</a></li><li><a href=/docs/reference/access-authn-authz/node/>노드 인가</a></li><li><a href=/docs/reference/access-authn-authz/webhook/>웹훅 인가</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/>인증서 서명 요청</a><ul><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection>CSR 승인</a>과
<a href=/docs/reference/access-authn-authz/certificate-signing-requests/#signing>인증서 서명</a>을 포함함</li></ul></li><li>서비스 어카운트<ul><li><a href=/docs/tasks/configure-pod-container/configure-service-account/>개발자 가이드</a></li><li><a href=/ko/docs/reference/access-authn-authz/service-accounts-admin/>관리</a></li></ul></li><li><a href=/ko/docs/reference/access-authn-authz/kubelet-authn-authz/>kubelet 인증과 인가</a><ul><li>kubelet <a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>TLS 부트스트래핑</a>을 포함함</li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-de45b6ca7419a0e308044425b2ac52bb>3.1 - 부트스트랩 토큰을 사용한 인증</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [stable]</code></div><p>부트스트랩 토큰은 새 클러스터를 만들거나 새 노드를 기존 클러스터에 결합할 때
사용되는 간단한 전달자 토큰이다.
<a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a>을 지원하도록 구축되었지만
<code>kubeadm</code> 없이 클러스터를 시작하려는 사용자를 위해 다른 컨텍스트에서 사용할 수 있다.
또한 RBAC 정책을 통해 <a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>Kubelet TLS 부트스트래핑</a>
시스템과 함께 동작하도록 구축되었다.</p><h2 id=부트스트랩-토큰-개요>부트스트랩 토큰 개요</h2><p>부트스트랩 토큰은 <code>kube-system</code> 네임스페이스에 있는
특정 유형(<code>bootstrap.kubernetes.io/token</code>)의 시크릿(Secret)으로 정의된다.
API 서버의 부트스트랩 인증자가 이러한 시크릿을 읽는다.
만료된 토큰은 컨트롤러 관리자가 TokenCleaner 컨트롤러로 제거한다.
토큰은 BootstrapSigner 컨트롤러를 통해
"discovery" 프로세스에 사용되는 특정 컨피그맵(ConfigMap)에 대한
서명을 만드는 데도 사용된다.</p><h2 id=토큰-형식>토큰 형식</h2><p>부트스트랩 토큰은 <code>abcdef.0123456789abcdef</code> 형식을 취한다. 더 공식적으로는
정규식 <code>[a-z0-9]{6}\.[a-z0-9]{16}</code> 와 일치해야 한다.</p><p>토큰의 첫 번째 부분은 "Token ID" 이며 공개 정보로 간주된다.
인증에 사용하는 시크릿의 일부를 노출하지 않고 토큰을 참조할 때 사용한다.
두 번째 부분은 "Token Secret"이며
신뢰할 수 있는 당사자와만 공유해야 한다.</p><h2 id=부트스트랩-토큰-인증-활성화>부트스트랩 토큰 인증 활성화</h2><p>API 서버에서 다음 플래그를 사용하여 부트스트랩 토큰 인증자를
활성화할 수 있다.</p><pre tabindex=0><code>--enable-bootstrap-token-auth
</code></pre><p>활성화되면 부트스트랩 토큰을 API 서버에 대한 요청을 인증하기 위한
전달자 토큰 자격 증명으로 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>Authorization: Bearer 07401b.f395accd246ae52d
</span></span></span></code></pre></div><p>토큰은 사용자 이름 <code>system:bootstrap:&lt;token id></code> 로 인증되며 <code>system:bootstrappers</code> 그룹의 구성원이다.
토큰의 시크릿에 추가 그룹을
지정할 수 있다.</p><p>만료된 토큰은 컨트롤러 관리자에서 <code>tokencleaner</code>
컨트롤러를 활성화하여 자동으로 삭제할 수 있다.</p><pre tabindex=0><code>--controllers=*,tokencleaner
</code></pre><h2 id=부트스트랩-토큰-시크릿-형식>부트스트랩 토큰 시크릿 형식</h2><p>각각의 유효한 토큰은 <code>kube-system</code> 네임스페이스의 시크릿에 의해 지원된다.
전체 디자인 문서는
<a href=https://git.k8s.io/design-proposals-archive/cluster-lifecycle/bootstrap-discovery.md>여기</a>에서 찾을 수 있다.</p><p>시크릿은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Name MUST be of form &#34;bootstrap-token-&lt;token id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-07401b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Type MUST be &#39;bootstrap.kubernetes.io/token&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Human readable description. Optional.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The default bootstrap token generated by &#39;kubeadm init&#39;.&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Token ID and secret. Required.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>07401b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>f395accd246ae52d<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Expiration. Optional.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>2017-03-10T03:22:11Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Allowed usages.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Extra groups to authenticate the token as. Must start with &#34;system:bootstrappers:&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>system:bootstrappers:worker,system:bootstrappers:ingress<span style=color:#bbb>
</span></span></span></code></pre></div><p>시크릿 유형은 <code>bootstrap.kubernetes.io/token</code> 이어야 하고
이름은 <code>bootstrap-token-&lt;token id></code>여야 한다. 반드시 <code>kube-system</code>
네임스페이스에도 존재해야 한다.</p><p><code>usage-bootstrap-*</code> 멤버는 이 시크릿의 용도를 나타낸다.
활성화하려면 값을 <code>true</code> 로 설정해야 한다.</p><ul><li><code>usage-bootstrap-authentication</code> 은 토큰을 API 서버에
베어러 토큰으로 인증하는데 사용할 수 있음을 나타낸다.</li><li><code>usage-bootstrap-signing</code> 은 토큰을 사용하여 아래에 설명된
<code>cluster-info</code> 컨피그맵에 서명할 수 있음을 나타낸다.</li></ul><p><code>expiration</code> 필드는 토큰의 만료를 제어한다. 만료된 토큰은
인증에 사용될 때 거부되고 컨피그맵서명 중에 무시된다.
만료된 값은 RFC3339를 사용하여 절대 UTC 시간으로 인코딩된다.
만료된 토큰을 자동으로 삭제하려면 <code>tokencleaner</code> 컨트롤러를 활성화한다.</p><h2 id=kubeadm을-사용한-토큰-관리>kubeadm을 사용한 토큰 관리</h2><p><code>kubeadm</code> 툴을 사용하여 실행중인 클러스터에서 토큰을 관리할 수 있다.
자세한 내용은 <a href=/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token docs</a> 에서 찾을 수 있다.</p><h2 id=컨피그맵-서명>컨피그맵 서명</h2><p>토큰은 인증 외에도 컨피그맵에 서명하는데 사용할 수 있다.
이것은 클라이언트가 API 서버를 신뢰하기 전에 클러스터 부트스트랩 프로세스의 초기에 사용된다.
서명된 컨피그맵은 공유 토큰으로 인증할 수 있다.</p><p>컨트롤러 관리자에서 <code>bootstrapsigner</code> 컨트롤러를 활성화하여
컨피그맵서명을 활성화 한다.</p><pre tabindex=0><code>--controllers=*,bootstrapsigner
</code></pre><p>서명된 컨피그맵은 <code>kube-public</code> 네임스페이스에 있는 <code>cluster-info</code> 이다.
일반적인 흐름은 클라이언트가 인증되지 않고 TLS 오류를 무시하는 동안
컨피그맵을 읽는 것이다. 그런 다음 컨피그맵에 포함된 서명을 확인하여
컨피그맵의 페이로드를 확인한다.</p><p>컨피그맵은 다음과 같을 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster-info<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-public<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jws-kubeconfig-07401b</span>:<span style=color:#bbb> </span>eyJhbGciOiJIUzI1NiIsImtpZCI6IjA3NDAxYiJ9..tYEfbo6zDNo40MQE07aZcQX2m3EB2rO3NuXtxVMYm9U<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeconfig</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    clusters:
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    - cluster:
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        certificate-authority-data: &lt;really long certificate data&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        server: https://10.138.0.2:6443
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      name: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    contexts: []
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    current-context: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    kind: Config
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    preferences: {}
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    users: []</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>컨피그맵의 <code>kubeconfig</code> 멤버는 클러스터 정보만 입력된 구성 파일이다.
여기서 전달되는 핵심은 <code>certificate-authority-data</code> 이다.<br>이는 향후 확대될 수 있다.</p><p>서명은 "detached" 모드를 사용하는 JWS 서명이다. 서명을 검증하려면
사용자는 JWS 규칙(뒤로 오는 <code>=</code> 를 삭제하는 동안 인코딩된 base64)에 따라
<code>kubeconfig</code> 페이로드를 인코딩해야 한다. 그런 다음 인코딩된 페이로드는
두 개의 점 사이에 삽입하여 전체 JWS를 형성하는 데 사용된다.
전체 토큰(예:<code>07401b.f395accd246ae52d</code>)을 공유 시크릿으로 사용하여
<code>HS256</code> 방식(HMAC-SHA256)을 사용함으로 JWS를 확인할 수 있다.
사용자는 <em>반드시</em> HS256이 사용되고 있는지 확인해야 한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 부트스트래핑 토큰을 가진 모든 당사자는 해당 토큰에 대한 유효한 서명을 만들 수 있다.
컨피그맵 서명을 사용할 때 많은 클라이언트와 동일한 토큰을 공유하는 것은 권장되지 않는다.
손상된 클라이언트는 잠재적으로 서명에 의존하여
TLS 트러스트를 부트스트랩하는 다른 클라이언트를 대신할 수 있기 때문이다.</div><p>자세한 내용은 <a href=/docs/reference/setup-tools/kubeadm/implementation-details/>kubeadm implementation details</a>
섹션을 참조하면 된다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bea207258f3576b8ec7444a20d498e1d>3.2 - 서비스 어카운트 관리하기</h1><p>이것은 서비스 어카운트에 대한 클러스터 관리자 안내서다.
독자는 <a href=/docs/tasks/configure-pod-container/configure-service-account/>쿠버네티스 서비스 어카운트 설정</a>에 익숙하다고 가정한다.</p><p>인증 및 사용자 어카운트에 대한 지원은 아직 준비 중이다.
서비스 어카운트를 더 잘 설명하기 위해, 때때로 미완성 기능이 언급될 수 있다.</p><h2 id=사용자-어카운트와-서비스-어카운트-비교>사용자 어카운트와 서비스 어카운트 비교</h2><p>쿠버네티스는 여러 가지 이유로 사용자 어카운트와 서비스 어카운트의 개념을
구분한다.</p><ul><li>사용자 어카운트는 사람을 위한 것이다. 서비스 어카운트는 파드에서 실행되는 프로세스를
위한 것이다.</li><li>사용자 어카운트는 전역을 대상으로 고려된다.
클러스터의 모든 네임스페이스에 걸쳐 이름이 고유해야 한다. 서비스 어카운트는 네임스페이스에 할당된다.</li><li>일반적으로 클러스터의 사용자 어카운트는 기업 데이터베이스로부터 동기화될 수 있으며,
여기서 새로운 사용자 어카운트를 생성하려면 특별한 권한이 필요하며 복잡한 비즈니스 프로세스에 연결된다.
서비스 어카운트 생성은
클러스터 사용자가 최소 권한 원칙에 따라 특정 작업을 위한 서비스 어카운트를 만들 수 있도록
보다 가볍게 만들어졌다.</li><li>사람과 서비스 어카운트에 대한 감사 항목은 다를 수 있다.</li><li>복잡한 시스템의 설정들은 그 시스템의 구성요소에 대한 다양한 서비스 어카운트 정의를 포함할 수 있다.
서비스 어카운트는 많은 제약없이 만들 수 있고 네임스페이스에 할당된 이름을 가질 수 있기 때문에
이러한 설정은 이식성이 좋다.</li></ul><h2 id=서비스-어카운트-자동화>서비스 어카운트 자동화</h2><p>서비스 계정 자동화를 구현하기 위해 세 가지 개별 요소가 협력한다.</p><ul><li><code>ServiceAccount</code> 어드미션 컨트롤러</li><li>토큰 컨트롤러</li><li><code>ServiceAccount</code> 컨트롤러</li></ul><h3 id=서비스어카운트-serviceaccount-어드미션-컨트롤러>서비스어카운트(ServiceAccount) 어드미션 컨트롤러</h3><p>파드 수정은 <a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러</a>라는
플러그인을 통해 구현된다.
이것은 API 서버의 일부이다.
파드가 생성되거나 수정될 때 파드를 수정하기 위해 동기적으로 동작한다.
이 플러그인이 활성 상태(대부분의 배포에서 기본값)인 경우 파드 생성 또는 수정 시 다음 작업을 수행한다.</p><ol><li>파드에 <code>ServiceAccount</code> 가 없다면, <code>ServiceAccount</code> 를 <code>default</code> 로 설정한다.</li><li>이전 단계는 파드에 참조되는 <code>ServiceAccount</code> 가 있도록 하고, 그렇지 않으면 이를 거부한다.</li><li>서비스어카운트 <code>automountServiceAccountToken</code> 와 파드의 <code>automountServiceAccountToken</code> 중
어느 것도 <code>false</code> 로 설정되어 있지 않다면,
API 접근을 위한 토큰이 포함된 <code>volume</code> 을 파드에 추가한다.</li><li>이전 단계에서 서비스어카운트 토큰을 위한 볼륨이 만들어졌다면,
<code>/var/run/secrets/kubernetes.io/serviceaccount</code> 에 마운트된 파드의 각 컨테이너에
<code>volumeSource</code> 를 추가한다.</li><li>파드에 <code>imagePullSecrets</code> 이 없는 경우,
<code>ServiceAccount</code> 의 <code>imagePullSecrets</code> 이 파드에 추가된다.</li></ol><h4 id=바인딩된-서비스-어카운트-토큰-볼륨>바인딩된 서비스 어카운트 토큰 볼륨</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.22 [stable]</code></div><p>서비스 어카운트 어드미션 컨트롤러는 토큰 컨트롤러에서 생성한 만료되지 않은 서비스 계정 토큰에
시크릿 기반 볼륨 대신 다음과 같은 프로젝티드 볼륨을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-api-access-&lt;random-suffix&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>420</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 0644</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3607</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-root-ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>namespace<span style=color:#bbb>
</span></span></span></code></pre></div><p>프로젝티드 볼륨은 세 가지로 구성된다.</p><ol><li><code>kube-apiserver</code>로부터 TokenRequest API를 통해 얻은 <code>서비스어카운트토큰(ServiceAccountToken)</code>.
서비스어카운트토큰은 기본적으로 1시간 뒤에, 또는 파드가 삭제될 때 만료된다.
서비스어카운트토큰은 파드에 연결되며 kube-apiserver를 위해 존재한다.</li><li>kube-apiserver에 대한 연결을 확인하는 데 사용되는 CA 번들을 포함하는 <code>컨피그맵(ConfigMap)</code>.</li><li>파드의 네임스페이스를 참조하는 <code>DownwardAPI</code>.</li></ol><p>상세 사항은 <a href=/ko/docs/tasks/configure-pod-container/configure-projected-volume-storage/>프로젝티드 볼륨</a>을 참고한다.</p><h3 id=토큰-컨트롤러>토큰 컨트롤러</h3><p>토큰컨트롤러는 <code>kube-controller-manager</code> 의 일부로 실행된다. 이것은 비동기적으로 동작한다. 토큰 컨트롤러는,</p><ul><li>서비스어카운트 생성을 감시하고 API에 접근할 수 있는 해당
서비스어카운트 토큰 시크릿을 생성한다.</li><li>서비스어카운트 삭제를 감시하고 해당하는 모든 서비스어카운트
토큰 시크릿을 삭제한다.</li><li>서비스어카운트 토큰 시크릿 추가를 감시하고, 참조된 서비스어카운트가
존재하는지 확인하고, 필요한 경우 시크릿에 토큰을 추가한다.</li><li>시크릿 삭제를 감시하고 필요한 경우 해당 서비스어카운트에서
참조를 제거한다.</li></ul><p>서비스 어카운트 개인키 파일은 <code>--service-account-private-key-file</code>
플래그를 사용하여 <code>kube-controller-manager</code> 의 토큰 컨트롤러에 전달해야
한다. 개인키는 생성된 서비스 어카운트 토큰에 서명하는 데 사용될 것이다.
마찬가지로 <code>--service-account-key-file</code> 플래그를 사용하여 해당 공개키를
<code>kube-apiserver</code> 에 전달해야 한다. 공개키는 인증 과정에서 토큰을
검증하는 데 사용될 것이다.</p><h4 id=추가적인-api-토큰-생성>추가적인 API 토큰 생성</h4><p>컨트롤러 루프는 API 토큰이 포함된 시크릿이 각 서비스어카운트에 존재하도록 보장한다.
서비스어카운트에 대한 추가적인 API 토큰을 생성하기 위해
서비스어카운트를 참조하는 어노테이션과 함께
<code>kubernetes.io/service-account-token</code> 유형의 시크릿을 생성하면
컨트롤러가 새로 생성된 토큰으로 갱신한다.</p><p>다음은 시크릿에 대한 샘플 구성이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecretname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span>myserviceaccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./secret.yaml
</span></span><span style=display:flex><span>kubectl describe secret mysecretname
</span></span></code></pre></div><h4 id=서비스-어카운트-토큰-시크릿-삭제-무효화>서비스 어카운트 토큰 시크릿 삭제/무효화</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret mysecretname
</span></span></code></pre></div><h3 id=서비스어카운트-컨트롤러>서비스어카운트 컨트롤러</h3><p>서비스어카운트 컨트롤러는 네임스페이스에 있는 서비스어카운트를 관리하고
"default"라는 이름의 서비스어카운트가 모든 활성 네임스페이스에 존재하는지 확인한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-342be69d36f174f762c36f4fe11fcb20>3.3 - 인가 개요</h1><p>지원되는 인가 모듈을 사용하여 정책을 만드는 방법을 포함한
쿠버네티스 인가에 대해 자세히 알아보자.</p><p>쿠버네티스에서는 사용자의 요청이 인가(접근 권한을 부여) 받기 전에 사용자가 인증(로그인)되어야 한다.
인증에 대한 자세한 내용은 <a href=/ko/docs/concepts/security/controlling-access/>쿠버네티스 API 접근 제어하기</a>를
참고한다.</p><p>쿠버네티스는 REST API 요청에 공통적인 속성을 요구한다.
이는 쿠버네티스 인가가 쿠버네티스 API 이외에 다른 API를 처리할 수 있는
기존 조직 전체 또는 클라우드 제공자 전체의 접근 제어 시스템과
연동된다는 것을 의미한다.</p><h2 id=요청-허용-또는-거부-결정>요청 허용 또는 거부 결정</h2><p>쿠버네티스는 API 서버를 이용하여 API 요청을 인가한다.
모든 정책과 비교하여 모든 요청 속성을 평가하고 요청을 허용하거나 거부한다.
계속 진행하려면 API 요청의 모든 부분이 일부 정책에 의해 반드시 허용되어야 한다.
이는 기본적으로 승인이 거부된다는 것을 의미한다.</p><p>(쿠버네티스는 API 서버를 사용하지만,
특정 오브젝트의 특정 필드에 의존하는 접근 제어 및 정책은
어드미션 컨트롤러에 의해 처리된다.)</p><p>여러 개의 인가 모듈이 구성되면 각 모듈이 순서대로 확인된다.
어느 인가 모듈이 요청을 승인하거나 거부할 경우, 그 결정은 즉시 반환되며 다른 인가 모듈이 참고되지 않는다.
모든 모듈에서 요청에 대한 평가가 없으면 요청이 거부된다.
요청 거부는 HTTP 상태 코드 403을 반환한다.</p><h2 id=요청-속성-검토>요청 속성 검토</h2><p>쿠버네티스는 다음 API 요청 속성만 검토한다.</p><ul><li><strong>user</strong> - 인증 중에 제공된 <code>user</code> 문자열.</li><li><strong>group</strong> - 인증된 사용자가 속한 그룹 이름 목록.</li><li><strong>extra</strong> - 인증 계층에서 제공하는 문자열 값에 대한 임의의 문자열 키 맵.</li><li><strong>API</strong> - 요청이 API 리소스에 대한 것인지 여부.</li><li><strong>Request path</strong> - <code>/api</code> 또는 <code>/healthz</code>와 같이 다양한 리소스가 아닌 엔드포인트의 경로.</li><li><strong>API request verb</strong> - <code>get</code>, <code>list</code>, <code>create</code>, <code>update</code>, <code>patch</code>, <code>watch</code>, <code>delete</code>, <code>deletecollection</code>과 같은 리소스 요청에 사용하는 API 동사. 리소스 API 엔드포인트의 요청 동사를 결정하려면 <a href=/ko/docs/reference/access-authn-authz/authorization/#%EC%9A%94%EC%B2%AD-%EB%8F%99%EC%82%AC-%EA%B2%B0%EC%A0%95>요청 동사 결정</a>을 참고한다.</li><li><strong>HTTP request verb</strong> - <code>get</code>, <code>post</code>, <code>put</code>, <code>delete</code>처럼 소문자 HTTP 메서드는 리소스가 아닌 요청에 사용한다.</li><li><strong>Resource</strong> - 접근 중인 리소스의 ID 또는 이름(리소스 요청만 해당) -- <code>get</code>, <code>update</code>, <code>patch</code>, <code>delete</code> 동사를 사용하는 리소스 요청의 경우 리소스 이름을 지정해야 한다.</li><li><strong>Subresource</strong> - 접근 중인 하위 리소스(리소스 요청만 해당).</li><li><strong>Namespace</strong> - 접근 중인 오브젝트의 네임스페이스(네임스페이스에 할당된 리소스 요청만 해당)</li><li><strong>API group</strong> - 접근 중인 <a class=glossary-tooltip title='쿠버네티스 API의 연관된 경로들의 집합.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/kubernetes-api/#api-%ea%b7%b8%eb%a3%b9%ea%b3%bc-%eb%b2%84%ec%a0%84-%ea%b7%9c%ec%b9%99 target=_blank aria-label='API 그룹'>API 그룹</a>(리소스 요청에만 해당). 빈 문자열은 <em>핵심(core)</em> <a href=/ko/docs/reference/using-api/#api-%EA%B7%B8%EB%A3%B9>API 그룹</a>을 지정한다.</li></ul><h2 id=요청-동사-결정>요청 동사 결정</h2><p><strong>리소스가 아닌 요청</strong>
<code>/api/v1/...</code> 또는 <code>/apis/&lt;group>/&lt;version>/...</code> 이외에 다른 엔드포인트에 대한 요청은
"리소스가 아닌 요청"으로 간주되며, 요청의 소문자 HTTP 메서드를 동사로 사용한다.
예를 들어, <code>/api</code> 또는 <code>/healthz</code>와 같은 엔드포인트에 대한 <code>GET</code> 요청은 <code>get</code>을 동사로 사용할 것이다.</p><p><strong>리소스 요청</strong>
리소스 API 엔드포인트에 대한 요청 동사를 결정하려면
사용된 HTTP 동사와 해당 요청이 개별 리소스 또는 리소스 모음에 적용되는지 여부를
검토한다.</p><table><thead><tr><th>HTTP 동사</th><th>요청 동사</th></tr></thead><tbody><tr><td>POST</td><td>create</td></tr><tr><td>GET, HEAD</td><td>get(개별 리소스), list(전체 오브젝트 내용을 포함한 리소스 모음), watch(개별 리소스 또는 리소스 모음을 주시)</td></tr><tr><td>PUT</td><td>update</td></tr><tr><td>PATCH</td><td>patch</td></tr><tr><td>DELETE</td><td>delete(개별 리소스), deletecollection(리소스 모음)</td></tr></tbody></table><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> <code>get</code>, <code>list</code>, <code>watch</code> 요청은 모두 리소스의 전체 세부 내용을 반환할 수 있다. 반환된 데이터의 관점으론 모두 동일하다. 예를 들어 <code>secrets</code>에 대해 <code>list</code> 요청은 반환된 리소스의 <code>data</code> 속성을 여전히 드러낼 것이다.</div><p>쿠버네티스는 종종 전문 동사를 사용하여 부가적인 권한 인가를 확인한다. 예를 들면,</p><ul><li><a href=/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping>RBAC</a><ul><li><code>rbac.authorization.k8s.io</code> API 그룹의 <code>roles</code> 및 <code>clusterroles</code> 리소스에 대한 <code>bind</code> 동사.</li></ul></li><li><a href=/docs/reference/access-authn-authz/authentication/>인증</a><ul><li>핵심 API 그룹의 <code>users</code>, <code>groups</code>, <code>serviceaccounts</code>와 <code>authentication.k8s.io</code> API 그룹의 <code>userextras</code> 동사.</li></ul></li></ul><h2 id=authorization-modules>인가 모드</h2><p>쿠버네티스 API 서버는 몇 가지 인가 모드 중 하나를 사용하여 요청을 승인할 수 있다.</p><ul><li><strong>Node</strong> - 실행되도록 스케줄된 파드에 따라 kubelet에게 권한을 부여하는 특수 목적 인가 모드. Node 인가 모드 사용에 대한 자세한 내용은 <a href=/docs/reference/access-authn-authz/node/>Node 인가</a>를 참조한다.</li><li><strong>ABAC</strong> - 속성 기반 접근 제어 (ABAC, Attribute-based access control)는 속성과 결합한 정책의 사용을 통해 사용자에게 접근 권한을 부여하는 접근 제어 패러다임을 말한다. 이 정책은 모든 유형의 속성(사용자 속성, 리소스 속성, 오브젝트, 환경 속성 등)을 사용할 수 있다. ABAC 모드 사용에 대한 자세한 내용은 <a href=/docs/reference/access-authn-authz/abac/>ABAC 모드</a>를 참조한다.</li><li><strong>RBAC</strong> - 역할 기반 접근 제어(RBAC, Role-based access control)는 기업 내 개별 사용자의 역할을 기반으로 컴퓨터나 네트워크 리소스에 대한 접근을 규제하는 방식이다. 이 맥락에서 접근은 개별 사용자가 파일을 보거나 만들거나 수정하는 것과 같은 특정 작업을 수행할 수 있는 능력이다. RBAC 모드 사용에 대한 자세한 내용은 <a href=/docs/reference/access-authn-authz/rbac/>RBAC 모드</a>를 참조한다.<ul><li>지정된 RBAC(역할 기반 접근 제어)이 인가 결정을 위해 <code>rbac.authorization.k8s.io</code> API 그룹을 사용하면, 관리자가 쿠버네티스 API를 통해 권한 정책을 동적으로 구성할 수 있다.</li><li>RBAC을 활성화하려면 <code>--authorization-mode=RBAC</code>로 API 서버를 시작한다.</li></ul></li><li><strong>Webhook</strong> - WebHook은 HTTP 콜백이다(어떤 일이 일어날 때 발생하는 HTTP POST와 HTTP POST를 통한 간단한 이벤트 알림). WebHook을 구현하는 웹 애플리케이션은 특정한 일이 발생할 때 URL에 메시지를 POST 할 것이다. Webhook 모드 사용에 대한 자세한 내용은 <a href=/docs/reference/access-authn-authz/webhook/>Webhook 모드</a>를 참조한다.</li></ul><h4 id=api-접근-확인>API 접근 확인</h4><p><code>kubectl</code>은 API 인증 계층을 신속하게 쿼리하기 위한 <code>auth can-i</code> 하위 명령어를 제공한다.
이 명령은 현재 사용자가 지정된 작업을 수행할 수 있는지 여부를 알아내기 위해 <code>SelfSubjectAccessReview</code> API를 사용하며,
사용되는 인가 모드에 관계없이 작동한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl auth can-i create deployments --namespace dev
</span></span></code></pre></div><p>다음과 유사하게 출력된다.</p><pre tabindex=0><code>yes
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl auth can-i create deployments --namespace prod
</span></span></code></pre></div><p>다음과 유사하게 출력된다.</p><pre tabindex=0><code>no
</code></pre><p>관리자는 이를 <a href=/docs/reference/access-authn-authz/authentication/#user-impersonation>사용자 가장(impersonation)</a>과
병행하여 다른 사용자가 수행할 수 있는 작업을 결정할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl auth can-i list secrets --namespace dev --as dave
</span></span></code></pre></div><p>다음과 유사하게 출력된다.</p><pre tabindex=0><code>no
</code></pre><p>유사하게, <code>dev</code> 네임스페이스의 <code>dev-sa</code> 서비스어카운트가
<code>target</code> 네임스페이스의 파드 목록을 볼 수 있는지 확인하려면 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl auth can-i list pods <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	--namespace target <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	--as system:serviceaccount:dev:dev-sa
</span></span></code></pre></div><p>다음과 유사하게 출력된다.</p><pre tabindex=0><code>yes
</code></pre><p><code>SelfSubjectAccessReview</code>는 <code>authorization.k8s.io</code> API 그룹의 일부로서
API 서버 인가를 외부 서비스에 노출시킨다.
이 그룹의 기타 리소스에는 다음이 포함된다.</p><ul><li><code>SubjectAccessReview</code> - 현재 사용자뿐만 아니라 모든 사용자에 대한 접근 검토. API 서버에 인가 결정을 위임하는 데 유용하다. 예를 들어, kubelet 및 확장(extension) API 서버는 자신의 API에 대한 사용자 접근을 결정하기 위해 해당 리소스를 사용한다.</li><li><code>LocalSubjectAccessReview</code> - <code>SubjectAccessReview</code>와 비슷하지만 특정 네임스페이스로 제한된다.</li><li><code>SelfSubjectRulesReview</code> - 사용자가 네임스페이스 안에서 수행할 수 있는 작업 집합을 반환하는 검토. 사용자가 자신의 접근을 빠르게 요약해서 보거나 UI가 작업을 숨기거나 표시하는 데 유용하다.</li></ul><p>이러한 API는 반환된 오브젝트의 응답 "status" 필드가 쿼리의 결과인
일반 쿠버네티스 리소스를 생성하여 쿼리할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create -f - -o yaml <span style=color:#b44>&lt;&lt; EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: authorization.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: SelfSubjectAccessReview
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  resourceAttributes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    group: apps
</span></span></span><span style=display:flex><span><span style=color:#b44>    resource: deployments
</span></span></span><span style=display:flex><span><span style=color:#b44>    verb: create
</span></span></span><span style=display:flex><span><span style=color:#b44>    namespace: dev
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>생성된 <code>SelfSubjectAccessReview</code> 는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>SelfSubjectAccessReview<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceAttributes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>apps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>deployments<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>dev<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verb</span>:<span style=color:#bbb> </span>create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>denied</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=인가-모듈에-플래그-사용>인가 모듈에 플래그 사용</h2><p>정책에 포함된 인가 모듈을 나타내기 위해
정책에 플래그를 포함시켜야 한다.</p><p>다음 플래그를 사용할 수 있다.</p><ul><li><code>--authorization-mode=ABAC</code> 속성 기반 접근 제어(ABAC) 모드를 사용하면 로컬 파일을 사용하여 정책을 구성할 수 있다.</li><li><code>--authorization-mode=RBAC</code> 역할 기반 접근 제어(RBAC) 모드를 사용하면 쿠버네티스 API를 사용하여 정책을 만들고 저장할 수 있다.</li><li><code>--authorization-mode=Webhook</code> WebHook은 원격 REST 엔드포인트를 사용하여 인가를 관리할 수 있는 HTTP 콜백 모드다.</li><li><code>--authorization-mode=Node</code> 노드 인가는 kubelet이 생성한 API 요청을 특별히 인가시키는 특수 목적 인가 모드다.</li><li><code>--authorization-mode=AlwaysDeny</code> 이 플래그는 모든 요청을 차단한다. 이 플래그는 테스트에만 사용한다.</li><li><code>--authorization-mode=AlwaysAllow</code> 이 플래그는 모든 요청을 허용한다. API 요청에 대한 인가가 필요하지 않은 경우에만 이 플래그를 사용한다.</li></ul><p>하나 이상의 인가 모듈을 선택할 수 있다. 모듈이 순서대로 확인되기 때문에
우선 순위가 더 높은 모듈이 요청을 허용하거나 거부할 수 있다.</p><h2 id=privilege-escalation-via-pod-creation>워크로드 생성 및 수정을 통한 권한 확대</h2><p>네임스페이스에서 파드를 직접, 또는 오퍼레이터와 같은 <a href=/ko/docs/concepts/architecture/controller/>컨트롤러</a>를 통해 생성/수정할 수 있는 사용자는
해당 네임스페이스 안에서 자신의 권한을 확대할 수 있다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 시스템 관리자는 파드 생성/수정에 대한 접근 권한을 부여할 때 주의한다.
<a href=#escalation-paths>권한 확대 경로</a>에서 접근 권한이 잘못 사용되었을 때의 상세사항을 확인할 수 있다.</div><h3 id=escalation-paths>권한 확대 경로</h3><ul><li>네임스페이스 내의 임의의 시크릿을 마운트<ul><li>다른 워크로드를 위한 시크릿으로의 접근에 사용될 수 있음</li><li>더 권한이 많은 서비스 어카운트의 서비스 어카운트 토큰 획득에 사용될 수 있음</li></ul></li><li>네임스페이스 내의 임의의 서비스 어카운트를 사용<ul><li>다른 워크로드인것처럼 사칭하여 쿠버네티스 API 액션을 수행할 수 있음</li><li>서비스 어카운트가 갖고 있는 '권한이 필요한 액션'을 수행할 수 있음</li></ul></li><li>네임스페이스 내의 다른 워크로드를 위한 컨피그맵을 마운트<ul><li>다른 워크로드를 위한 정보(예: DB 호스트 이름) 획득에 사용될 수 있음</li></ul></li><li>네임스페이스 내의 다른 워크로드를 위한 볼륨을 마운트<ul><li>다른 워크로드를 위한 정보의 획득 및 수정에 사용될 수 있음</li></ul></li></ul><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 시스템 관리자는 위와 같은 영역을 수정하는 CRD를 배포할 때 주의를 기울여야 한다.
이들은 의도하지 않은 권한 확대 경로를 노출할 수 있다.
RBAC 제어에 대해 결정할 때 이와 같은 사항을 고려해야 한다.</div><h2 id=다음-내용>다음 내용</h2><ul><li>인증에 대한 자세한 내용은 <a href=/ko/docs/concepts/security/controlling-access/>쿠버네티스 API 접근 제어하기</a>에서 <strong>인증</strong> 을 참조한다.</li><li>어드미션 제어에 대한 자세한 내용은 <a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러 사용하기</a>를 참조한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-36e1423f0b5caa8eafeb6f53c175d13c>3.4 - Kubelet 인증/인가</h1><h2 id=개요>개요</h2><p>kubelet의 HTTPS 엔드포인트는 다양한 민감도의 데이터에 대한 접근을 제공하는 API를 노출하며,
노드와 컨테이너 내에서 다양한 수준의 권한으로 작업을 수행할 수 있도록 허용한다.</p><p>이 문서는 kubelet의 HTTPS 엔드포인트에 대한 접근을 인증하고 인가하는 방법을 설명한다.</p><h2 id=kubelet-인증>Kubelet 인증</h2><p>기본적으로, 다른 구성의 인증 방법에 의해 거부되지 않은 kubelet의 HTTPS 엔드포인트에 대한 요청은
익명의 요청으로 처리되며, <code>system:anonymous</code>의 사용자 이름과 <code>system:unauthenticated</code>
의 그룹이 부여된다.</p><p>익명의 접근을 비활성화하고 인증되지 않은 요청에 <code>401 Unauthorized</code> 응답을 보내려면 아래를 참고한다.</p><ul><li><code>--anonymous-auth=false</code> 플래그로 kubelet을 시작</li></ul><p>kubelet의 HTTPS 엔드포인트에 대한 X509 클라이언트 인증서 인증을 활성화하려면 아래를 참고한다.</p><ul><li><code>--client-ca-file</code> 플래그로 kubelet을 시작하면 클라이언트 인증서를 확인할 수 있는 CA 번들을 제공</li><li><code>--kubelet-client-certificate</code> 및 <code>--kubelet-client-key</code> 플래그로 apiserver를 시작</li><li>자세한 내용은 <a href=/docs/reference/access-authn-authz/authentication/#x509-client-certs>apiserver 인증 문서</a>를 참고</li></ul><p>API bearer 토큰(서비스 계정 토큰 포함)을 kubelet의 HTTPS 엔드포인트 인증에 사용하려면 아래를 참고한다.</p><ul><li>API 서버에서 <code>authentication.k8s.io/v1beta1</code> API 그룹이 사용 가능한지 확인</li><li><code>--authentication-token-webhook</code> 및 <code>--kubeconfig</code> 플래그로 kubelet을 시작</li><li>kubelet은 구성된 API 서버의 <code>TokenReview</code> API를 호출하여 bearer 토큰에서 사용자 정보를 결정</li></ul><h2 id=kubelet-승인>Kubelet 승인</h2><p>성공적으로 인증된 모든 요청(익명 요청 포함)이 승인된다. 기본 인가 모드는 모든 요청을 허용하는 <code>AlwaysAllow</code> 이다.</p><p>kubelet API에 대한 접근을 세분화하는 데는 다양한 이유가 있다.</p><ul><li>익명 인증을 사용할 수 있지만, 익명 사용자의 kubelet API 호출 기능은 제한되어야 함</li><li>bearer 토큰 인증을 사용할 수 있지만, 임의의 API 사용자(API 계정)의 kubelet API 호출 기능은 제한되어야 함</li><li>클라이언트 인증을 사용할 수 있지만, 구성된 CA에서 서명한 일부 클라이언트 인증서만 kubelet API를 사용하도록 허용해야 함</li></ul><p>kubelet API에 대한 접근을 세분화하려면 API 서버에 권한을 위임한다.</p><ul><li><code>authorization.k8s.io/v1beta1</code> API 그룹이 API 서버에서 사용 가능한지 확인</li><li><code>--authorization-mode=Webhook</code> 및 <code>--kubeconfig</code> 플래그로 kubelet을 시작</li><li>kubelet은 구성된 API 서버의 <code>SubjectAccessReview</code> API를 호출하여 각각의 요청이 승인되었는지 여부를 확인</li></ul><p>kubelet은 API 요청을 apiserver와 동일한 <a href=/ko/docs/reference/access-authn-authz/authorization/#%EC%9A%94%EC%B2%AD-%EC%86%8D%EC%84%B1-%EA%B2%80%ED%86%A0>요청 속성</a> 접근 방식을 사용하여 승인한다.</p><p>동사는 들어오는 요청의 HTTP 동사로부터 결정된다.</p><table><thead><tr><th>HTTP 동사</th><th>요청 동사</th></tr></thead><tbody><tr><td>POST</td><td>create</td></tr><tr><td>GET, HEAD</td><td>get</td></tr><tr><td>PUT</td><td>update</td></tr><tr><td>PATCH</td><td>patch</td></tr><tr><td>DELETE</td><td>delete</td></tr></tbody></table><p>리소스 및 하위 리소스는 들어오는 요청의 경로로부터 결정된다.</p><table><thead><tr><th>Kubelet API</th><th>리소스</th><th>하위 리소스</th></tr></thead><tbody><tr><td>/stats/*</td><td>nodes</td><td>stats</td></tr><tr><td>/metrics/*</td><td>nodes</td><td>metrics</td></tr><tr><td>/logs/*</td><td>nodes</td><td>log</td></tr><tr><td>/spec/*</td><td>nodes</td><td>spec</td></tr><tr><td><em>all others</em></td><td>nodes</td><td>proxy</td></tr></tbody></table><p>네임스페이스와 API 그룹 속성은 항상 빈 문자열이며,
리소스 이름은 항상 kubelet의 <code>Node</code> API 오브젝트 이름이다.</p><p>이 모드로 실행할 때, <code>--kubelet-client-certificate</code> 및 <code>--kubelet-client-key</code> 플래그로 식별된 사용자에게
다음 속성에 대한 권한이 있는지 확인한다.</p><ul><li>verb=*, resource=nodes, subresource=proxy</li><li>verb=*, resource=nodes, subresource=stats</li><li>verb=*, resource=nodes, subresource=log</li><li>verb=*, resource=nodes, subresource=spec</li><li>verb=*, resource=nodes, subresource=metrics</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e7512a333ae98d32429d24b2290eb15a>4 - 잘 알려진 레이블, 어노테이션, 테인트(Taint)</h1><p>쿠버네티스는 모든 레이블과 어노테이션을 <code>kubernetes.io</code>와 <code>k8s.io</code> 네임스페이스 아래에 정의해 놓았다.</p><p>이 문서는 각 값에 대한 레퍼런스를 제공하며, 값을 할당하기 위한 협력 포인트도 제공한다.</p><h2 id=api-오브젝트에서-사용되는-레이블-어노테이션-테인트>API 오브젝트에서 사용되는 레이블, 어노테이션, 테인트</h2><h3 id=app-kubernetes-io-component>app.kubernetes.io/component</h3><p>예시: <code>app.kubernetes.io/component: "database"</code></p><p>적용 대상: 모든 오브젝트</p><p>아키텍처 내의 컴포넌트.</p><p><a href=/ko/docs/concepts/overview/working-with-objects/common-labels/#labels>추천하는 레이블</a>을 확인한다.</p><h3 id=app-kubernetes-io-created-by-사용-중단됨>app.kubernetes.io/created-by (사용 중단됨)</h3><p>예시: <code>app.kubernetes.io/created-by: "controller-manager"</code></p><p>적용 대상: 모든 오브젝트</p><p>리소스를 생성한 컨트롤러/사용자.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> v1.9부터 이 레이블은 더 이상 사용되지 않는다.</div><h3 id=app-kubernetes-io-instance>app.kubernetes.io/instance</h3><p>예시: <code>app.kubernetes.io/instance: "mysql-abcxzy"</code></p><p>적용 대상: 모든 오브젝트</p><p>애플리케이션 인스턴스를 식별하기 위한 고유한 이름.</p><p><a href=/ko/docs/concepts/overview/working-with-objects/common-labels/#labels>추천하는 레이블</a>을 확인한다.</p><h3 id=app-kubernetes-io-managed-by>app.kubernetes.io/managed-by</h3><p>예시: <code>app.kubernetes.io/managed-by: "helm"</code></p><p>적용 대상: 모든 오브젝트</p><p>애플리케이션의 작업을 관리하기 위해 사용되는 도구.</p><p><a href=/ko/docs/concepts/overview/working-with-objects/common-labels/#labels>추천하는 레이블</a>을 확인한다.</p><h3 id=app-kubernetes-io-name>app.kubernetes.io/name</h3><p>예시: <code>app.kubernetes.io/name: "mysql"</code></p><p>적용 대상: 모든 오브젝트</p><p>애플리케이션의 이름.</p><p><a href=/ko/docs/concepts/overview/working-with-objects/common-labels/#labels>추천하는 레이블</a>을 확인한다.</p><h3 id=app-kubernetes-io-part-of>app.kubernetes.io/part-of</h3><p>예시: <code>app.kubernetes.io/part-of: "wordpress"</code></p><p>적용 대상: 모든 오브젝트</p><p>해당 애플리케이션이 속한 상위 레벨의 애플리케이션 이름.</p><p><a href=/ko/docs/concepts/overview/working-with-objects/common-labels/#labels>추천하는 레이블</a>을 확인한다.</p><h3 id=app-kubernetes-io-version>app.kubernetes.io/version</h3><p>예시: <code>app.kubernetes.io/version: "5.7.21"</code></p><p>적용 대상: 모든 오브젝트</p><p>애플리케이션의 현재 버전(시맨틱 버전, 리비전 해시, 기타 등등).</p><p><a href=/ko/docs/concepts/overview/working-with-objects/common-labels/#labels>추천하는 레이블</a>을 확인한다.</p><h3 id=cluster-autoscaler-kubernetes-io-safe-to-evict>cluster-autoscaler.kubernetes.io/safe-to-evict</h3><p>예시: <code>cluster-autoscaler.kubernetes.io/safe-to-evict: "true"</code></p><p>적용 대상: 파드</p><p>이 어노테이션이 <code>"true"</code>로 설정된 경우, 파드 축출을 막는 다른 규칙이 있는 경우에도
클러스터 오토스케일러가 파드를 축출할 수 있다.
클러스터 오토스케일러는 명시적으로 이 어노테이션이 <code>"false"</code>로 설정된 파드를 절대 축출하지 않는다.
따라서, 계속해서 실행을 유지하고자 하는 중요한 파드에 설정할 수 있다.
이 어노테이션이 설정되지 않은 경우, 클러스터 오토스케일러는 파드 수준(Pod-level) 동작을 따른다.</p><h2 id=kubernetes-io-arch>kubernetes.io/arch</h2><p>예시: <code>kubernetes.io/arch=amd64</code></p><p>적용 대상: 노드</p><p>Go에 의해 정의된 <code>runtime.GOARCH</code> 값을 kubelet이 읽어서 이 레이블의 값으로 채운다. arm 노드와 x86 노드를 혼합하여 사용하는 경우 유용할 수 있다.</p><h2 id=kubernetes-io-os>kubernetes.io/os</h2><p>예시: <code>kubernetes.io/os=linux</code></p><p>적용 대상: 노드</p><p>Go에 의해 정의된 <code>runtime.GOOS</code> 값을 kubelet이 읽어서 이 레이블의 값으로 채운다. 클러스터에서 여러 운영체제를 혼합하여 사용(예: 리눅스 및 윈도우 노드)하는 경우 유용할 수 있다.</p><h2 id=kubernetes-io-metadata-name>kubernetes.io/metadata.name</h2><p>예시: <code>kubernetes.io/metadata.name=mynamespace</code></p><p>적용 대상: 네임스페이스</p><p>(<a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>의 일부인)
쿠버네티스 API 서버가 이 레이블을 모든 네임스페이스에 설정한다.
레이블의 값은 네임스페이스의 이름으로 적용된다. 이 레이블의 값을 변경할 수는 없다.</p><p>레이블 <a class=glossary-tooltip title='사용자가 레이블에 따라서 리소스 리스트를 필터할 수 있게 한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=셀렉터>셀렉터</a>를 이용하여 특정 네임스페이스를 지정하고 싶다면
이 레이블이 유용할 수 있다.</p><h2 id=beta-kubernetes-io-arch-사용-중단됨>beta.kubernetes.io/arch (사용 중단됨)</h2><p>이 레이블은 사용 중단되었다. 대신 <code>kubernetes.io/arch</code> 을 사용한다.</p><h2 id=beta-kubernetes-io-os-사용-중단됨>beta.kubernetes.io/os (사용 중단됨)</h2><p>이 레이블은 사용 중단되었다. 대신 <code>kubernetes.io/os</code> 을 사용한다.</p><h2 id=kubernetesiohostname>kubernetes.io/hostname</h2><p>예시: <code>kubernetes.io/hostname=ip-172-20-114-199.ec2.internal</code></p><p>적용 대상: 노드</p><p>kubelet이 호스트네임을 읽어서 이 레이블의 값으로 채운다. <code>kubelet</code> 에 <code>--hostname-override</code> 플래그를 전달하여 실제 호스트네임과 다른 값으로 설정할 수도 있다.</p><p>이 레이블은 토폴로지 계층의 일부로도 사용된다. <a href=#topologykubernetesiozone><code>topology.kubernetes.io/zone</code></a>에서 세부 사항을 확인한다.</p><h2 id=change-cause>kubernetes.io/change-cause</h2><p>예시: <code>kubernetes.io/change-cause=kubectl edit --record deployment foo</code></p><p>적용 대상: 모든 오브젝트</p><p>이 어노테이션은 어떤 오브젝트가 왜 변경되었는지 그 이유를 담는다.</p><p>어떤 오브젝트를 변경할 수도 있는 <code>kubectl</code> 명령에 <code>--record</code> 플래그를 사용하면 이 레이블이 추가된다.</p><h3 id=description>kubernetes.io/description</h3><p>예시: <code>kubernetes.io/description: "Description of K8s object."</code></p><p>적용 대상: 모든 오브젝트</p><p>이 어노테이션은 주어진 오브젝트의 특정 상태를 표현하는데 사용한다.</p><h3 id=enforce-mountable-secrets>kubernetes.io/enforce-mountable-secrets</h3><p>예시: <code>kubernetes.io/enforce-mountable-secrets: "true"</code></p><p>적용 대상: 서비스어카운트(ServiceAccount)</p><p>이 어노테이션의 값은 <strong>true</strong>로 설정되어야만 작동한다. 이 어노테이션은, 해당 서비스어카운트로 동작중인 파드가 그 서비스어카운트의 <code>secrets</code> 항목에 명시된 Secret API 오브젝트만을 참조한다는 뜻이다.</p><h2 id=pod-deletion-cost>controller.kubernetes.io/pod-deletion-cost</h2><p>예시: <code>controller.kubernetes.io/pod-deletion-cost=10</code></p><p>적용 대상: 파드</p><p>이 어노테이션은 레플리카셋(ReplicaSet) 다운스케일 순서를 조정할 수 있는 요소인 <a href=/ko/docs/concepts/workloads/controllers/replicaset/#%ED%8C%8C%EB%93%9C-%EC%82%AD%EC%A0%9C-%EB%B9%84%EC%9A%A9>파드 삭제 비용</a>을
설정하기 위해 사용한다. 명시된 값은 <code>int32</code> 타입으로 파싱된다.</p><h3 id=cluster-autoscaler-kubernetes-io-enable-ds-eviction>cluster-autoscaler.kubernetes.io/enable-ds-eviction</h3><p>예시: <code>cluster-autoscaler.kubernetes.io/enable-ds-eviction: "true"</code></p><p>적용 대상: Pod</p><p>이 어노테이션은 클러스터 오토스케일러가 데몬셋 파드를 축출할 것인지 여부를 제어한다.
이 어노테이션은 데몬셋 매니페스트 내 데몬셋 파드에 명시되어야 한다.
이 어노테이션이 <code>"true"</code>로 설정된 경우, 파드 축출을 막는 다른 규칙이 있는 경우에도
클러스터 오토스케일러가 파드를 축출할 수 있다. 클러스터 오토스케일러가 데몬셋 파드를 축출하는 것을 허용하지 않기 위해서는,
중요한 데몬셋 파드에 이 어노테이션을 <code>"false"</code>로 설정한다.
이 어노테이션이 설정되지 않은 경우, 클러스터 오토스케일러는 전체 동작을 따른다. 즉, 해당 구성에 따라서 데몬셋을 축출한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 어노테이션은 데몬셋 파드에만 적용된다.</div><h3 id=kubernetes-io-ingress-bandwidth>kubernetes.io/ingress-bandwidth</h3><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 인그레스 트래픽 조절 어노테이션은 실험적인 기능이다.
만약 트래픽 조절 기능을 활성화시키고 싶다면, CNI 설정 파일(기본적으로 <code>/etc/cni/net.d</code>)에 <code>bandwidth</code> 플러그인을 추가해야 하며,
실행파일이 CNI의 실행파일 경로(기본적으로 <code>/opt/cni/bin</code>) 아래에 포함되어있는지도 확인하자.</div><p>Example: <code>kubernetes.io/ingress-bandwidth: 10M</code></p><p>적용 대상: 파드</p><p>파드에 QoS(quality-of-service)를 적용함으로써 가용한 대역폭을 효과적으로 제한할 수 있다.
인그레스 트래픽(파드로 향하는)은 효과적으로 데이터를 처리하기 위해 대기 중인 패킷을 큐로 관리한다.
파드의 대역폭을 제한하기 위해서는, 오브젝트를 정의하는 JSON 파일을 작성하고
<code>kubernetes.io/ingress-bandwidth</code> 어노테이션을 통해 데이터 트래픽의 속도를 명시한다. 인그레스 속도를 명시할 때 사용되는 단위는
초당 비트(<a href=/docs/reference/kubernetes-api/common-definitions/quantity/>수량</a>)이다.
예를 들어, <code>10M</code>은 초당 10 메가비트를 의미한다.</p><h3 id=kubernetes-io-egress-bandwidth>kubernetes.io/egress-bandwidth</h3><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이그레스 트래픽 조절 어노테이션은 실험적인 기능이다.
만약 트래픽 조절 기능을 활성화시키고 싶다면, CNI 설정 파일(기본적으로 <code>/etc/cni/net.d</code>)에 <code>bandwidth</code> 플러그인을 추가해야 하며,
실행파일이 CNI의 실행파일 경로(기본적으로 <code>/opt/cni/bin</code>) 아래에 포함되어있는지도 확인하자.</div><p>예시: <code>kubernetes.io/egress-bandwidth: 10M</code></p><p>적용 대상: 파드</p><p>이그레스 트래픽(파드로부터의)은 설정된 속도를 초과하는 패킷을 삭제하는 정책에 의해 처리되며,
파드에 거는 제한은 다른 파드의 대역폭에 영향을 주지 않는다.
파드의 대역폭을 제한하기 위해서는, 오브젝트를 정의하는 JSON 파일을 작성하고
<code>kubernetes.io/egress-bandwidth</code> 어노테이션을 통해 데이터 트래픽의 속도를 명시한다. 이그레스 속도를 명시할 때 사용되는 단위는
초당 비트(<a href=/docs/reference/kubernetes-api/common-definitions/quantity/>수량</a>)이다.
예를 들어, <code>10M</code>은 초당 10 메가비트를 의미한다.</p><h2 id=beta-kubernetes-io-instance-type-사용-중단됨>beta.kubernetes.io/instance-type (사용 중단됨)</h2><div class="alert alert-info note callout" role=alert><strong>참고:</strong> v1.17부터, <a href=#nodekubernetesioinstance-type><code>node.kubernetes.io/instance-type</code></a>으로 대체되었다.</div><h2 id=nodekubernetesioinstance-type>node.kubernetes.io/instance-type</h2><p>예시: <code>node.kubernetes.io/instance-type=m3.medium</code></p><p>적용 대상: 노드</p><p><code>클라우드 제공자</code>에 의해 정의된 인스턴스 타입의 값을 kubelet이 읽어서 이 레이블의 값으로 채운다.
<code>클라우드 제공자</code>를 사용하는 경우에만 이 레이블이 설정된다.
특정 워크로드를 특정 인스턴스 타입에 할당하고 싶다면 이 레이블이 유용할 수 있다.
하지만 일반적으로는 자원 기반 스케줄링을 수행하는 쿠버네티스 스케줄러를 이용하게 된다. 인스턴스 타입 보다는 특성을 기준으로 스케줄링을 고려해야 한다(예: <code>g2.2xlarge</code> 를 요구하기보다는, GPU가 필요하다고 요구한다).</p><h2 id=failure-domainbetakubernetesioregion>failure-domain.beta.kubernetes.io/region (사용 중단됨)</h2><p><a href=#topologykubernetesioregion><code>topology.kubernetes.io/region</code></a>을 확인한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> v1.17부터, <a href=#topologykubernetesioregion><code>topology.kubernetes.io/region</code></a>으로 대체되었다.</div><h2 id=failure-domainbetakubernetesiozone>failure-domain.beta.kubernetes.io/zone (사용 중단됨)</h2><p><a href=#topologykubernetesiozone><code>topology.kubernetes.io/zone</code></a>을 확인한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> v1.17부터, <a href=#topologykubernetesiozone><code>topology.kubernetes.io/zone</code></a>으로 대체되었다.</div><h2 id=statefulsetkubernetesiopod-name>statefulset.kubernetes.io/pod-name</h2><p>예시:</p><p><code>statefulset.kubernetes.io/pod-name=mystatefulset-7</code></p><p>스테이트풀셋(StatefulSet) 컨트롤러가 파드를 위한 스테이트풀셋을 생성하면, 컨트롤 플레인이 파드에 이 레이블을 설정한다.
생성되는 파드의 이름을 이 레이블의 값으로 설정한다.</p><p>스테이트풀셋 문서의 <a href=/ko/docs/concepts/workloads/controllers/statefulset/#%ED%8C%8C%EB%93%9C-%EC%9D%B4%EB%A6%84-%EB%A0%88%EC%9D%B4%EB%B8%94>파드 이름 레이블</a>에서
상세 사항을 확인한다.</p><h2 id=topologykubernetesioregion>topology.kubernetes.io/region</h2><p>예시:</p><p><code>topology.kubernetes.io/region=us-east-1</code></p><p><a href=#topologykubernetesiozone><code>topology.kubernetes.io/zone</code></a>을 확인한다.</p><h2 id=topologykubernetesiozone>topology.kubernetes.io/zone</h2><p>예시:</p><p><code>topology.kubernetes.io/zone=us-east-1c</code></p><p>적용 대상: 노드, 퍼시스턴트볼륨(PersistentVolume)</p><p>노드의 경우: <code>클라우드 제공자</code>가 제공하는 값을 이용하여 <code>kubelet</code> 또는 외부 <code>cloud-controller-manager</code>가 이 어노테이션의 값을 설정한다. <code>클라우드 제공자</code>를 사용하는 경우에만 이 레이블이 설정된다. 하지만, 토폴로지 내에서 의미가 있는 경우에만 이 레이블을 노드에 설정해야 한다.</p><p>퍼시스턴트볼륨의 경우: 토폴로지 어웨어 볼륨 프로비저너가 자동으로 퍼시스턴트볼륨에 노드 어피니티 제약을 설정한다.</p><p>영역(zone)은 논리적 고장 도메인을 나타낸다. 가용성 향상을 위해 일반적으로 쿠버네티스 클러스터는 여러 영역에 걸쳐 구성된다. 영역에 대한 정확한 정의는 사업자 별 인프라 구현에 따라 다르지만, 일반적으로 영역은 '영역 내 매우 낮은 네트워크 지연시간, 영역 내 네트워크 트래픽 비용 없음, 다른 영역의 고장에 독립적임' 등의 공통적인 특성을 갖는다. 예를 들어, 같은 영역 내의 노드는 하나의 네트워크 스위치를 공유하여 활용할 수 있으며, 반대로 다른 영역에 있는 노드는 하나의 네트워크 스위치를 공유해서는 안 된다.</p><p>지역(region)은 하나 이상의 영역으로 구성된 더 큰 도메인을 나타낸다. 쿠버네티스 클러스터가 여러 지역에 걸쳐 있는 경우는 드물다. 영역이나 지역에 대한 정확한 정의는 사업자 별 인프라 구현에 따라 다르지만, 일반적으로 지역은 '지역 내 네트워크 지연시간보다 지역 간 네트워크 지연시간이 큼, 지역 간 네트워크 트래픽은 비용이 발생함, 다른 영역/지역의 고장에 독립적임' 등의 공통적인 특성을 갖는다. 예를 들어, 같은 지역 내의 노드는 전력 인프라(예: UPS 또는 발전기)를 공유하여 활용할 수 있으며, 반대로 다른 지역에 있는 노드는 일반적으로 전력 인프라를 공유하지 않는다.</p><p>쿠버네티스는 영역과 지역의 구조에 대해 다음과 같이 가정한다.</p><ol><li>지역과 영역은 계층적이다. 영역은 지역의 엄격한 부분집합(strict subset)이며, 하나의 영역이 두 개의 지역에 속할 수는 없다.</li><li>영역 이름은 모든 지역에 걸쳐서 유일하다. 예를 들어, "africa-east-1" 라는 지역은 "africa-east-1a" 와 "africa-east-1b" 라는 영역으로 구성될 수 있다.</li></ol><p>토폴로지 레이블이 변경되는 일은 없다고 가정할 수 있다. 일반적으로 레이블의 값은 변경될 수 있지만, 특정 노드가 삭제 후 재생성되지 않고서는 다른 영역으로 이동할 수 없기 때문이다.</p><p>쿠버네티스는 이 정보를 다양한 방식으로 활용할 수 있다. 예를 들어, 단일 영역 클러스터에서는 스케줄러가 자동으로 레플리카셋의 파드를 여러 노드에 퍼뜨린다(노드 고장의 영향을 줄이기 위해 - <a href=#kubernetesiohostname><code>kubernetes.io/hostname</code></a> 참고). 복수 영역 클러스터에서는, 여러 영역에 퍼뜨린다(영역 고장의 영향을 줄이기 위해). 이는 <em>SelectorSpreadPriority</em> 를 통해 실현된다.</p><p><em>SelectorSpreadPriority</em> 는 최선 노력(best effort) 배치 방법이다. 클러스터가 위치한 영역들의 특성이 서로 다르다면(예: 노드 숫자가 다름, 노드 타입이 다름, 파드 자원 요구사항이 다름), 파드 숫자를 영역별로 다르게 하여 배치할 수 있다. 필요하다면, 영역들의 특성(노드 숫자/타입)을 일치시켜 불균형 배치의 가능성을 줄일 수 있다.</p><p>스케줄러도 (<em>VolumeZonePredicate</em> 표시자를 이용하여) '파드가 요청하는 볼륨'이 위치하는 영역과 같은 영역에 파드를 배치한다. 여러 영역에서 볼륨에 접근할 수는 없다.</p><p><code>PersistentVolumeLabel</code>이 퍼시스턴트볼륨의 자동 레이블링을 지원하지 않는다면, 레이블을 수동으로 추가하거나 <code>PersistentVolumeLabel</code>이 동작하도록 변경할 수 있다.
<code>PersistentVolumeLabel</code>이 설정되어 있으면, 스케줄러는 파드가 다른 영역에 있는 볼륨에 마운트하는 것을 막는다. 만약 사용 중인 인프라에 이러한 제약이 없다면, 볼륨에 영역 레이블을 추가할 필요가 전혀 없다.</p><h2 id=volume-beta-kubernetes-io-storage-provisioner-사용-중단됨>volume.beta.kubernetes.io/storage-provisioner (사용 중단됨)</h2><p>예시: <code>volume.beta.kubernetes.io/storage-provisioner: k8s.io/minikube-hostpath</code></p><p>적용 대상: 퍼시스턴트볼륨클레임(PersistentVolumeClaim)</p><p>이 어노테이션은 사용 중단되었다.</p><h3 id=mount-options>volume.beta.kubernetes.io/mount-options (deprecated)</h3><p>예시 : <code>volume.beta.kubernetes.io/mount-options: "ro,soft"</code></p><p>적용 대상: 퍼시스턴트볼륨</p><p>쿠버네티스 관리자는, 노드에 퍼시스턴트볼륨이 마운트될 경우 추가적인 <a href=/ko/docs/concepts/storage/persistent-volumes/#mount-options>마운트 옵션</a>을 명세할 수 있다.</p><p>이 어노테이션은 사용 중단되었다.</p><h2 id=volume-kubernetes-io-storage-provisioner>volume.kubernetes.io/storage-provisioner</h2><p>적용 대상: 퍼시스턴트볼륨클레임</p><p>이 어노테이션은 동적 프로비저닝이 요구되는 PVC에 추가될 예정이다.</p><h2 id=nodekubernetesiowindows-build>node.kubernetes.io/windows-build</h2><p>예시: <code>node.kubernetes.io/windows-build=10.0.17763</code></p><p>적용 대상: 노드</p><p>kubelet이 Microsoft 윈도우에서 실행되고 있다면, 사용 중인 Windows Server 버전을 기록하기 위해 kubelet이 노드에 이 레이블을 추가한다.</p><p>이 레이블의 값은 "MajorVersion.MinorVersion.BuildNumber"의 형태를 갖는다.</p><h2 id=servicekubernetesioheadless>service.kubernetes.io/headless</h2><p>예시: <code>service.kubernetes.io/headless=""</code></p><p>적용 대상: 서비스</p><p>서비스가 헤드리스(headless)이면, 컨트롤 플레인이 엔드포인트(Endpoints) 오브젝트에 이 레이블을 추가한다.</p><h2 id=kubernetesioservice-name>kubernetes.io/service-name</h2><p>예시: <code>kubernetes.io/service-name="nginx"</code></p><p>적용 대상: 서비스</p><p>쿠버네티스가 여러 서비스를 구분하기 위해 이 레이블을 사용한다. 현재는 <code>ELB</code>(Elastic Load Balancer) 를 위해서만 사용되고 있다.</p><h3 id=kubernetes-io-service-account-name>kubernetes.io/service-account.name</h3><p>예시: <code>kubernetes.io/service-account.name: "sa-name"</code></p><p>Used on: 시크릿(Secret)</p><p>이 어노테이션에는 토큰(<code>kubernetes.io/service-account-token</code> 타입의 시크릿에 저장되는)이 나타내는
서비스어카운트의 <a class=glossary-tooltip title='/api/v1/pods/some-name과 같이, 리소스 URL에서 오브젝트를 가리키는 클라이언트 제공 문자열.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/names target=_blank aria-label=이름>이름</a>을 기록한다.</p><h3 id=kubernetes-io-service-account-uid>kubernetes.io/service-account.uid</h3><p>예시: <code>kubernetes.io/service-account.uid: da68f9c6-9d26-11e7-b84e-002dc52800da</code></p><p>적용 대상: 시크릿</p><p>이 어노테이션에는 토큰(<code>kubernetes.io/service-account-token</code> 타입의 시크릿에 저장되는)이 나타내는
서비스어카운트의 <a class=glossary-tooltip title='오브젝트를 중복 없이 식별하기 위해 쿠버네티스 시스템이 생성하는 문자열.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/names target=_blank aria-label='고유 ID'>고유 ID</a>를 기록한다.</p><h2 id=endpointslicekubernetesiomanaged-by>endpointslice.kubernetes.io/managed-by</h2><p>예시: <code>endpointslice.kubernetes.io/managed-by="controller"</code></p><p>적용 대상: 엔드포인트슬라이스(EndpointSlices)</p><p>이 레이블은 엔드포인트슬라이스(EndpointSlice)를 어떤 컨트롤러나 엔티티가 관리하는지를 나타내기 위해 사용된다. 이 레이블을 사용함으로써 한 클러스터 내에서 여러 엔드포인트슬라이스 오브젝트가 각각 다른 컨트롤러나 엔티티에 의해 관리될 수 있다.</p><h2 id=endpointslicekubernetesioskip-mirror>endpointslice.kubernetes.io/skip-mirror</h2><p>예시: <code>endpointslice.kubernetes.io/skip-mirror="true"</code></p><p>적용 대상: 엔드포인트(Endpoints)</p><p>특정 자원에 이 레이블을 <code>"true"</code> 로 설정하여, EndpointSliceMirroring 컨트롤러가 엔드포인트슬라이스를 이용하여 해당 자원을 미러링하지 않도록 지시할 수 있다.</p><h2 id=servicekubernetesioservice-proxy-name>service.kubernetes.io/service-proxy-name</h2><p>예시: <code>service.kubernetes.io/service-proxy-name="foo-bar"</code></p><p>적용 대상: 서비스</p><p>kube-proxy 에는 커스텀 프록시를 위한 이와 같은 레이블이 있으며, 이 레이블은 서비스 컨트롤을 커스텀 프록시에 위임한다.</p><h2 id=experimental-windows-kubernetes-io-isolation-type>experimental.windows.kubernetes.io/isolation-type (deprecated)</h2><p>예시: <code>experimental.windows.kubernetes.io/isolation-type: "hyperv"</code></p><p>적용 대상: 파드</p><p>Hyper-V 격리(isolation)를 사용하여 윈도우 컨테이너를 실행하려면 이 어노테이션을 사용한다. Hyper-V 격리 기능을 활성화하고 Hyper-V 격리가 적용된 컨테이너를 생성하기 위해, kubelet은 기능 게이트 <code>HyperVContainer=true</code> 로 설정하여 실행되어야 하며, 파드에는 <code>experimental.windows.kubernetes.io/isolation-type=hyperv</code> 어노테이션이 설정되어 있어야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 이 어노테이션은 하나의 컨테이너로 구성된 파드에만 설정할 수 있다.
v1.20부터 이 어노테이션은 더이상 사용되지 않는다. 실험적인 Hyper-V 지원은 1.21버전에서 제거되었다.</div><h2 id=ingressclass-kubernetes-io-is-default-class>ingressclass.kubernetes.io/is-default-class</h2><p>예시: <code>ingressclass.kubernetes.io/is-default-class: "true"</code></p><p>적용 대상: 인그레스클래스(IngressClass)</p><p>하나의 인그레스클래스 리소스에 이 어노테이션이 <code>"true"</code>로 설정된 경우, 클래스가 명시되지 않은 새로운 인그레스(Ingress) 리소스는 해당 기본 클래스로 할당될 것이다.</p><h2 id=kubernetes-io-ingress-class-사용-중단됨>kubernetes.io/ingress.class (사용 중단됨)</h2><div class="alert alert-info note callout" role=alert><strong>참고:</strong> v1.18부터, <code>spec.ingressClassName</code>으로 대체되었다.</div><h2 id=storageclass-kubernetes-io-is-default-class>storageclass.kubernetes.io/is-default-class</h2><p>예시: <code>storageclass.kubernetes.io/is-default-class=true</code></p><p>적용 대상: 스토리지클래스(StorageClass)</p><p>하나의 스토리지클래스(StorageClass) 리소스에 이 어노테이션이 <code>"true"</code>로 설정된 경우,
클래스가 명시되지 않은 새로운 퍼시스턴트볼륨클레임 리소스는 해당 기본 클래스로 할당될 것이다.</p><h2 id=alpha-kubernetes-io-provided-node-ip>alpha.kubernetes.io/provided-node-ip</h2><p>예시: <code>alpha.kubernetes.io/provided-node-ip: "10.0.0.1"</code></p><p>적용 대상: 노드</p><p>kubelet이 노드에 할당된 IPv4 주소를 명시하기 위해 이 어노테이션을 사용할 수 있다.</p><p>kubelet이 <code>--cloud-provider</code> 플래그를 사용하여 어떤 값을 갖게 되었다면 (외부 또는 레거시 트리 내(in-tree) 클라우드 공급자 모두 포함), kubelet은 이 어노테이션을 노드에 설정하여 명령줄 플래그(<code>--node-ip</code>)를 통해 설정된 IP 주소를 명시한다. cloud-controller-manager는 클라우드 제공자에게 이 IP 주소가 유효한지를 검증한다.</p><h2 id=batch-kubernetes-io-job-completion-index>batch.kubernetes.io/job-completion-index</h2><p>예시: <code>batch.kubernetes.io/job-completion-index: "3"</code></p><p>적용 대상: 파드</p><p>kube-controller-manager의 잡(Job) 컨트롤러는
<code>Indexed</code> <a href=/ko/docs/concepts/workloads/controllers/job/#%EC%99%84%EB%A3%8C-%EB%AA%A8%EB%93%9C>완료 모드</a>로 생성된 파드에 이 어노테이션을 추가한다.</p><h2 id=kubectl-kubernetes-io-default-container>kubectl.kubernetes.io/default-container</h2><p>예시: <code>kubectl.kubernetes.io/default-container: "front-end-app"</code></p><p>파드의 기본 컨테이너로 사용할 컨테이너 이름을 지정하는 어노테이션이다. 예를 들어, <code>kubectl logs</code> 또는 <code>kubectl exec</code> 명령을 사용할 때 <code>-c</code> 또는 <code>--container</code> 플래그를 지정하지 않으면, 이 어노테이션으로 명시된 기본 컨테이너를 대상으로 실행될 것이다.</p><h2 id=endpoints-kubernetes-io-over-capacity>endpoints.kubernetes.io/over-capacity</h2><p>예시: <code>endpoints.kubernetes.io/over-capacity:truncated</code></p><p>적용 대상: 엔드포인트(Endpoints)</p><p>v1.22 이상의 쿠버네티스 클러스터에서, 한 엔드포인트(Endpoints) 리소스가 관리하고 있는 엔드포인트의 수가 1000개 이상이면 엔드포인트 컨트롤러가 해당 엔드포인트 리소스에 이 어노테이션을 추가한다. 이 어노테이션은 해당 엔드포인트 리소스가 용량 초과 되었으며 엔드포인트 컨트롤러가 엔드포인트의 수를 1000으로 줄였음을 나타낸다.</p><h2 id=batch-kubernetes-io-job-tracking>batch.kubernetes.io/job-tracking</h2><p>예시: <code>batch.kubernetes.io/job-tracking: ""</code></p><p>적용 대상: 잡</p><p>잡에 어노테이션이 있으면 컨트롤 플레인은 <a href=/ko/docs/concepts/workloads/controllers/job/#job-tracking-with-finalizers>finalizers를 사용하여 잡 상태 추적</a>
중임을 나타낸다.
어노테이션을 수동으로 추가하거나 제거하지 <strong>않는다</strong>.</p><h2 id=scheduleralphakubernetesio-preferavoidpods>scheduler.alpha.kubernetes.io/preferAvoidPods (deprecated)</h2><p>적용 대상: 노드</p><p>이 어노테이션을 사용하려면 <a href=/ko/docs/reference/scheduling/config/#scheduling-plugins>NodePreferAvoidPods 스케줄링 플러그인</a>이 활성화되어 있어야 한다.
해당 플러그인은 쿠버네티스 1.22에서 사용 중단되었다.
대신 <a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트와 톨러레이션</a>을 사용한다.</p><p><strong>이 이후로 나오는 테인트는 모두 '적용 대상: 노드' 이다.</strong></p><h2 id=node-kubernetes-io-not-ready>node.kubernetes.io/not-ready</h2><p>예시: <code>node.kubernetes.io/not-ready:NoExecute</code></p><p>노드 컨트롤러는 노드의 헬스를 모니터링하여 노드가 사용 가능한 상태인지를 감지하고 그에 따라 이 테인트를 추가하거나 제거한다.</p><h2 id=node-kubernetes-io-unreachable>node.kubernetes.io/unreachable</h2><p>예시: <code>node.kubernetes.io/unreachable:NoExecute</code></p><p>노드 컨트롤러는 <a href=/ko/docs/concepts/architecture/nodes/#condition>노드 컨디션</a>이 <code>Ready</code>에서 <code>Unknown</code>으로 변경된 노드에 이 테인트를 추가한다.</p><h2 id=node-kubernetes-io-unschedulable>node.kubernetes.io/unschedulable</h2><p>예시: <code>node.kubernetes.io/unschedulable:NoSchedule</code></p><p>경쟁 상태(race condition) 발생을 막기 위해, 생성 중인 노드에 이 테인트가 추가된다.</p><h2 id=node-kubernetes-io-memory-pressure>node.kubernetes.io/memory-pressure</h2><p>예시: <code>node.kubernetes.io/memory-pressure:NoSchedule</code></p><p>kubelet은 노드의 <code>memory.available</code>와 <code>allocatableMemory.available</code>을 관측하여 메모리 압박을 감지한다. 그 뒤, 관측한 값을 kubelet에 설정된 문턱값(threshold)과 비교하여 노드 컨디션과 테인트의 추가/삭제 여부를 결정한다.</p><h2 id=node-kubernetes-io-disk-pressure>node.kubernetes.io/disk-pressure</h2><p>예시: <code>node.kubernetes.io/disk-pressure:NoSchedule</code></p><p>kubelet은 노드의 <code>imagefs.available</code>, <code>imagefs.inodesFree</code>, <code>nodefs.available</code>, <code>nodefs.inodesFree</code>(리눅스에 대해서만)를 관측하여 디스크 압박을 감지한다. 그 뒤, 관측한 값을 kubelet에 설정된 문턱값(threshold)과 비교하여 노드 컨디션과 테인트의 추가/삭제 여부를 결정한다.</p><h2 id=node-kubernetes-io-network-unavailable>node.kubernetes.io/network-unavailable</h2><p>예시: <code>node.kubernetes.io/network-unavailable:NoSchedule</code></p><p>사용 중인 클라우드 공급자가 추가 네트워크 환경설정을 필요로 한다고 명시하면, kubelet이 이 테인트를 설정한다. 클라우드 상의 네트워크 경로가 올바르게 구성되어야, 클라우드 공급자가 이 테인트를 제거할 것이다.</p><h2 id=node-kubernetes-io-pid-pressure>node.kubernetes.io/pid-pressure</h2><p>예시: <code>node.kubernetes.io/pid-pressure:NoSchedule</code></p><p>kubelet은 '<code>/proc/sys/kernel/pid_max</code>의 크기의 D-값'과 노드에서 쿠버네티스가 사용 중인 PID를 확인하여, <code>pid.available</code> 지표라고 불리는 '사용 가능한 PID 수'를 가져온다. 그 뒤, 관측한 지표를 kubelet에 설정된 문턱값(threshold)과 비교하여 노드 컨디션과 테인트의 추가/삭제 여부를 결정한다.</p><h3 id=node-kubernetes-io-out-of-service>node.kubernetes.io/out-of-service</h3><p>예시: <code>node.kubernetes.io/out-of-service:NoExecute</code></p><p>사용자는 노드에 테인트를 수동으로 추가함으로써 서비스 중이 아니라고 표시할 수 있다. 만약 <code>NodeOutOfServiceVolumeDetach</code>
<a href=/ko/docs/reference/command-line-tools-reference/feature-gates/>기능 게이트</a>가 <code>kube-controller-manager</code>에 활성화되어 있으며
노드가 이 테인트로 인해 서비스 중이 아니라고 표시되어있을 경우, 노드에서 실행되던 매칭되는 톨러레이션이 없는 파드들은 강제로 삭제됨과 동시에 볼륨이 분리된다. 이는 서비스 중이 아닌 노드의 파드들이 다른 노드에서 빠르게 복구될 수 있도록 해준다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 이 테인트를 언제 어떻게 사용할지에 대한 자세한 사항은
<a href=/ko/docs/concepts/architecture/nodes/#non-graceful-node-shutdown>논 그레이스풀 노드 셧다운</a>
를 참조한다.</div><h2 id=node-cloudprovider-kubernetes-io-uninitialized>node.cloudprovider.kubernetes.io/uninitialized</h2><p>예시: <code>node.cloudprovider.kubernetes.io/uninitialized:NoSchedule</code></p><p>kubelet이 "외부" 클라우드 공급자에 의해 실행되었다면 노드가 '사용 불가능'한 상태라고 표시하기 위해 이 테인트가 추가되며, 추후 cloud-controller-manager가 이 노드를 초기화하고 이 테인트를 제거한다.</p><h2 id=node-cloudprovider-kubernetes-io-shutdown>node.cloudprovider.kubernetes.io/shutdown</h2><p>예시: <code>node.cloudprovider.kubernetes.io/shutdown:NoSchedule</code></p><p>노드의 상태가 클라우드 공급자가 정의한 'shutdown' 상태이면, 이에 따라 노드에 <code>node.cloudprovider.kubernetes.io/shutdown</code> 테인트가 <code>NoSchedule</code> 값으로 설정된다.</p><h2 id=pod-security-kubernetes-io-enforce>pod-security.kubernetes.io/enforce</h2><p>예시: <code>pod-security.kubernetes.io/enforce: baseline</code></p><p>적용 대상: 네임스페이스</p><p>값은 <strong>반드시</strong> <a href=/ko/docs/concepts/security/pod-security-standards/>파드 보안 표준</a> 레벨과 상응하는
<code>privileged</code>, <code>baseline</code>, 또는 <code>restricted</code> 중 하나여야 한다.
특히 <code>enforce</code> 레이블은 표시된 수준에 정의된 요구 사항을 충족하지 않는
레이블 네임스페이스에 모든 파드의 생성을 금지한다.</p><p>더 많은 정보는 <a href=/docs/concepts/security/pod-security-admission>네임스페이스에서 파드 보안 적용</a>을
참고한다.</p><h2 id=pod-security-kubernetes-io-enforce-version>pod-security.kubernetes.io/enforce-version</h2><p>예시: <code>pod-security.kubernetes.io/enforce-version: 1.25</code></p><p>적용 대상: 네임스페이스</p><p>값은 <strong>반드시</strong> <code>latest</code>이거나 <code>v&lt;MAJOR>.&lt;MINOR></code> 형식의 유효한 쿠버네티스 버전이어야 한다.
설정된 파드의 유효성을 검사할 때 적용할 <a href=/ko/docs/concepts/security/pod-security-standards/>파드 보안 표준</a>
정책의 버전이 결정된다.</p><p>더 많은 정보는 <a href=/docs/concepts/security/pod-security-admission>네임스페이스에서 파드 보안 적용</a>을
참고한다.</p><h2 id=pod-security-kubernetes-io-audit>pod-security.kubernetes.io/audit</h2><p>예시: <code>pod-security.kubernetes.io/audit: baseline</code></p><p>적용 대상: 네임스페이스</p><p>값은 <strong>반드시</strong> <a href=/ko/docs/concepts/security/pod-security-standards/>파드 보안 표준</a> 레벨과 상응하는
<code>privileged</code>, <code>baseline</code>, 또는 <code>restricted</code> 중 하나여야 한다.
특히 <code>audit</code> 레이블은 표시된 수준에 정의된 요구 사항을 충족하지 않는 레이블 네임스페이스에 파드를 생성하는 것을
방지하지 않지만, 해당 파드에 audit 어노테이션을 추가한다.</p><p>더 많은 정보는 <a href=/docs/concepts/security/pod-security-admission>네임스페이스에서 파드 보안 적용</a>을
참고한다.</p><h2 id=pod-security-kubernetes-io-audit-version>pod-security.kubernetes.io/audit-version</h2><p>예시: <code>pod-security.kubernetes.io/audit-version: 1.25</code></p><p>적용 대상: 네임스페이스</p><p>값은 <strong>반드시</strong> <code>latest</code>이거나 <code>v&lt;MAJOR>.&lt;MINOR></code> 형식의 유효한 쿠버네티스 버전이어야 한다.
설정된 파드의 유효성을 검사할 때 적용할 <a href=/ko/docs/concepts/security/pod-security-standards/>파드 보안 표준</a>
정책의 버전이 결정된다.</p><p>더 많은 정보는 <a href=/docs/concepts/security/pod-security-admission>네임스페이스에서 파드 보안 적용</a>을
참고한다.</p><h2 id=pod-security-kubernetes-io-warn>pod-security.kubernetes.io/warn</h2><p>예시: <code>pod-security.kubernetes.io/warn: baseline</code></p><p>적용 대상: 네임스페이스</p><p>값은 <strong>반드시</strong> <a href=/ko/docs/concepts/security/pod-security-standards/>파드 보안 표준</a> 레벨과 상응하는
<code>privileged</code>, <code>baseline</code>, 또는 <code>restricted</code> 중 하나여야 한다.
특히 <code>warn</code> 레이블은 해당 레이블이 달린 네임스페이스에, 표시된 레벨에 명시된 요구 사항을 충족하지 않는 파드를 생성하는 것을
방지하지는 않지만, 그러한 파드가 생성되면 사용자에게 경고를 반환한다.
디플로이먼트, 잡, 스테이트풀셋 등과 같은 파드 템플릿을 포함하는
객체를 만들거나 업데이트할 때에도 경고가 표시된다.</p><p>더 많은 정보는 <a href=/docs/concepts/security/pod-security-admission>네임스페이스에서 파드 보안 적용</a>을
참고한다.</p><h2 id=pod-security-kubernetes-io-warn-version>pod-security.kubernetes.io/warn-version</h2><p>예시: <code>pod-security.kubernetes.io/warn-version: 1.25</code></p><p>적용 대상: 네임스페이스</p><p>값은 <strong>반드시</strong> <code>latest</code>이거나 <code>v&lt;MAJOR>.&lt;MINOR></code> 형식의 유효한 쿠버네티스 버전이어야 한다.
설정된 파드의 유효성을 검사할 때 적용할 <a href=/ko/docs/concepts/security/pod-security-standards/>파드 보안 표준</a>
정책의 버전이 결정된다. 디플로이먼트, 잡, 스테이트풀셋 등과 같은 파드 템플릿을 포함하는
객체를 만들거나 업데이트할 때에도 경고가 표시된다.</p><p>더 많은 정보는 <a href=/docs/concepts/security/pod-security-admission>네임스페이스에서 파드 보안 적용</a>을
참고한다.</p><h3 id=kubernetes-io-psp>kubernetes.io/psp (사용 중단됨)</h3><p>예시: <code>kubernetes.io/psp: restricted</code></p><p>적용 대상: 파드</p><p>이 어노테이션은 파드시큐리티폴리시(PodSecurityPolicy)<a href=/ko/docs/concepts/security/pod-security-policy/>PodSecurityPolicies</a>를 사용하는 경우에만 관련이 있다.
쿠버네티스 v1.25은 파드시큐리티폴리시 API를 지원하지 않는다.</p><p>파드시큐리티폴리시 어드미션 컨트롤러가 파드를 승인했을 때,
어드미션 컨트롤러는 파드가 이 어노테이션을 갖도록 수정했다.
이 어노테이션 값은 유효성 검사에서 사용된 파드시큐리티폴리시의 이름이었다.</p><h2 id=seccomp-security-alpha-kubernetes-io-pod>seccomp.security.alpha.kubernetes.io/pod (사용 중단됨)</h2><p>이 어노테이션은 쿠버네티스 v1.19부터 사용 중단되었으며 향후 릴리스에서는 작동하지 않을 것이다.
대신 해당 파드 또는 컨테이너의 <code>securityContext.seccompProfile</code> 필드를 사용한다.
파드의 보안 설정을 지정하려면, 파드 스펙에 <code>securityContext</code> 필드를 추가한다.
파드의 <code>.spec</code> 내의 <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context><code>securityContext</code></a> 필드는 파드 수준 보안 속성을 정의한다.
<a href=/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod>파드의 보안 컨텍스트를 설정</a>하면,
해당 설정이 파드 내의 모든 컨테이너에 적용된다.</p><h2 id=container-seccomp-security-alpha-kubernetes-io>container.seccomp.security.alpha.kubernetes.io/[이름]</h2><p>이 어노테이션은 쿠버네티스 v1.19부터 사용 중단되었으며 향후 릴리스에서는 작동하지 않을 것이다.
대신 해당 파드 또는 컨테이너의 <code>securityContext.seccompProfile</code> 필드를 사용한다.
<a href=/docs/tutorials/security/seccomp/>seccomp를 이용하여 컨테이너의 syscall 제한하기</a> 튜토리얼에서
seccomp 프로파일을 파드 또는 파드 내 컨테이너에 적용하는 단계를 확인한다.
튜토리얼에서는 쿠버네티스에 seccomp를 설정하기 위해 사용할 수 있는 방법을 소개하며,
이는 파드의 <code>.spec</code> 내에 <code>securityContext</code> 를 설정함으로써 가능하다.</p><h3 id=snapshot-storage-kubernetes-io-allowvolumemodechange>snapshot.storage.kubernetes.io/allowVolumeModeChange</h3><p>예시: <code>snapshot.storage.kubernetes.io/allowVolumeModeChange: "true"</code></p><p>적용 대상: VolumeSnapshotContent</p><p>값은 <code>true</code> 혹은 <code>false</code>만을 받는다.
<a class=glossary-tooltip title='컨테이너의 볼륨으로 마운트될 수 있도록 퍼시스턴트볼륨(PersistentVolume)에 정의된 스토리지 리소스를 요청한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=퍼시스턴트볼륨클레임>퍼시스턴트볼륨클레임</a>이
볼륨스냅샷(VolumeSnapshot)으로부터 생성될 경우,
사용자가 소스 볼륨의 모드를 수정할 수 있는지 여부를 결정한다.</p><p>자세한 사항은 <a href=/ko/docs/concepts/storage/volume-snapshots/#convert-volume-mode>스냅샷의 볼륨 모드 변환하기</a>와
<a href=https://kubernetes-csi.github.io/docs/>쿠버네티스 CSI 개발자용 문서</a>를 참조한다.</p><h2 id=audit을-위한-어노테이션들>Audit을 위한 어노테이션들</h2><ul><li><a href=/docs/reference/labels-annotations-taints/audit-annotations/#authorization-k8s-io-decision><code>authorization.k8s.io/decision</code></a></li><li><a href=/docs/reference/labels-annotations-taints/audit-annotations/#authorization-k8s-io-reason><code>authorization.k8s.io/reason</code></a></li><li><a href=/docs/reference/labels-annotations-taints/audit-annotations/#insecure-sha1-invalid-cert-kubernetes-io-hostname><code>insecure-sha1.invalid-cert.kubernetes.io/$hostname</code></a></li><li><a href=/docs/reference/labels-annotations-taints/audit-annotations/#missing-san-invalid-cert-kubernetes-io-hostname><code>missing-san.invalid-cert.kubernetes.io/$hostname</code></a></li><li><a href=/docs/reference/labels-annotations-taints/audit-annotations/#pod-security-kubernetes-io-audit-violations><code>pod-security.kubernetes.io/audit-violations</code></a></li><li><a href=/docs/reference/labels-annotations-taints/audit-annotations/#pod-security-kubernetes-io-enforce-policy><code>pod-security.kubernetes.io/enforce-policy</code></a></li><li><a href=/docs/reference/labels-annotations-taints/audit-annotations/#pod-security-kubernetes-io-exempt><code>pod-security.kubernetes.io/exempt</code></a></li></ul><p>자세한 사항은 <a href=/docs/reference/labels-annotations-taints/audit-annotations/>Audit 어노테이션</a> 페이지를 참고한다.</p><h2 id=kubeadm>kubeadm</h2><h3 id=kubeadm-alpha-kubernetes-io-cri-socket>kubeadm.alpha.kubernetes.io/cri-socket</h3><p>예시: <code>kubeadm.alpha.kubernetes.io/cri-socket: unix:///run/containerd/container.sock</code></p><p>적용 대상: 노드</p><p>kubeadm <code>init</code>/<code>join</code>시 주어지는 CRI 소켓 정보를 유지하기 위해 사용하는 어노테이션.
kubeadm은 노드 오브젝트를 이 정보를 주석 처리한다. 이상적으로는 KubeletConfiguration의 항목이어야 하기 때문에,
어노테이션은 "alpha" 상태로 남아있다.</p><h3 id=kubeadm-kubernetes-io-etcd-advertise-client-urls>kubeadm.kubernetes.io/etcd.advertise-client-urls</h3><p>예시: <code>kubeadm.kubernetes.io/etcd.advertise-client-urls: https://172.17.0.18:2379</code></p><p>적용 대상: 파드</p><p>etcd 클라이언트들이 접근할 수 있는 URL 목록을 추적하기 위해, 로컬에서 관리되는 etcd 파드에 배치되는 어노테이션.
주로 etcd 클러스터의 헬스 체크에 사용한다.</p><h3 id=kubeadm-kubernetes-io-kube-apiserver-advertise-address-endpoint>kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint</h3><p>예시: <code>kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint: https//172.17.0.18:6443</code></p><p>적용 대상: 파드</p><p>외부로 노출시킬 API 서버의 엔드포인트를 추적하기 위해,
로컬에서 관리되는 kube-apiserver 파드에 배치되는 어노테이션.</p><h3 id=kubeadm-kubernetes-io-component-config-hash>kubeadm.kubernetes.io/component-config.hash</h3><p>예시: <code>kubeadm.kubernetes.io/component-config.hash: 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae</code></p><p>적용 대상: 컨피그맵(ConfigMap)</p><p>컴포넌트 설정을 관리하는 컨피그맵에 배치되는 어노테이션.
사용자가 특정 컴포넌트에 대해서 kubeadm 기본값과 다른 설정값을 적용했는지 판단하기 위한 해시(SHA-256)를 가지고 있다.</p><h3 id=node-role-kubernetes-io-control-plane>node-role.kubernetes.io/control-plane</h3><p>적용 대상: 노드</p><p>kubeadm이 관리하는 컨트롤 플레인 노드에 적용되는 레이블.</p><h3 id=node-role-kubernetes-io-control-plane-1>node-role.kubernetes.io/control-plane</h3><p>예시: <code>node-role.kubernetes.io/control-plane:NoSchedule</code></p><p>적용 대상: 노드</p><p>중요한 워크로드만 스케줄링할 수 있도록 컨트롤 플레인 노드에 적용시키는 테인트.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-75e3b4b5f680fdd081dc8af8060a2bf7>5 - 노드 레퍼런스 정보</h1></div><div class=td-content><h1 id=pg-26e96c9d268f9c39dfc525b98f477a12>5.1 - 도커심 제거 및 CRI 호환 런타임 사용에 대한 기사</h1><p>이 문서는 쿠버네티스의 <em>도커심</em>
사용 중단(deprecation) 및 제거, 또는
해당 제거를 고려한 CRI 호환 컨테이너 런타임
사용에 관한 기사 및 기타 페이지 목록을 제공한다.</p><h2 id=쿠버네티스-프로젝트>쿠버네티스 프로젝트</h2><ul><li><p>쿠버네티스 블로그: <a href=/blog/2020/12/02/dockershim-faq/>도커심 제거 FAQ</a> (originally published 2020/12/02)</p></li><li><p>쿠버네티스 블로그: <a href=/blog/2022/02/17/dockershim-faq/>업데이트: 도커심 제거 FAQ</a> (updated published 2022/02/17)</p></li><li><p>쿠버네티스 블로그: <a href=/blog/2022/01/07/kubernetes-is-moving-on-from-dockershim/>도커심에서 움직이는 쿠버네티스: 약속과 다음 단계</a> (published 2022/01/07)</p></li><li><p>쿠버네티스 블로그: <a href=/blog/2021/11/12/are-you-ready-for-dockershim-removal/>도커심 제거가 다가오고 있다. 준비됐는가?</a> (published 2021/11/12)</p></li><li><p>쿠버네티스 문서: <a href=/ko/docs/tasks/administer-cluster/migrating-from-dockershim/>도커심에서 마이그레이션하기</a></p></li><li><p>쿠버네티스 문서: <a href=/ko/docs/setup/production-environment/container-runtimes/>컨테이너 런타임</a></p></li><li><p>쿠버네티스 개선 제안 이슈: <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2221-remove-dockershim/README.md>KEP-2221: kubelet에서 도커심 제거하기</a></p></li><li><p>쿠버네티스 개선 제안 이슈: <a href=https://github.com/kubernetes/enhancements/issues/2221>kubelet에서 도커심 제거하기</a> (<em>k/enhancements#2221</em>)</p></li></ul><p>GitHub 이슈를 통해 피드백을 제공할 수 있다. <a href=https://github.com/kubernetes/kubernetes/issues/106917><strong>도커심 제거 피드백 및 이슈</strong></a>. (<em>k/kubernetes/#106917</em>)</p><h2 id=third-party>외부 소스</h2><ul><li><p>아마존 웹 서비스 EKS 문서: <a href=https://docs.aws.amazon.com/eks/latest/userguide/dockershim-deprecation.html>아마존 EKS 도커심 지원 종료</a></p></li><li><p>CNCF 컨퍼런스 영상: <a href="https://www.youtube.com/watch?v=uDOu6rK4yOk">도커에서 containerd 런타임으로 마이그레이션하며 얻은 교훈</a> (Ana Caylin, at KubeCon Europe 2019)</p></li><li><p>도커닷컴 블로그: <a href=https://www.docker.com/blog/what-developers-need-to-know-about-docker-docker-engine-and-kubernetes-v1-20/>개발자가 도커, 도커 엔진 및 쿠버네티스 v1.20에 관해 알아야 할 사항</a> (published 2020/12/04)</p></li><li><p>"<em>구글 오픈소스</em>" 유튜브 채널: <a href=https://youtu.be/fl7_4hjT52g>구글과 함께 쿠버네티스 배우기 - 도커심에서 containerd로 마이그레이션하기</a></p></li><li><p>Azure의 Microsoft 앱 블로그: <a href=https://techcommunity.microsoft.com/t5/apps-on-azure-blog/dockershim-deprecation-and-aks/ba-p/3055902>도커심 지원 중단 및 AKS</a> (published 2022/01/21)</p></li><li><p>Mirantis 블로그: <a href=https://www.mirantis.com/blog/the-future-of-dockershim-is-cri-dockerd/>도커심의 미래는 cri-dockerd</a> (published 2021/04/21)</p></li><li><p>Mirantis: <a href=https://github.com/Mirantis/cri-dockerd>Mirantis/cri-dockerd</a> Git 리포지터리 (깃허브)</p></li><li><p>Tripwire: <a href=https://www.tripwire.com/state-of-security/security-data-protection/cloud/how-dockershim-forthcoming-deprecation-affects-your-kubernetes/>곧 다가올 도커심의 지원 중단이 당신의 쿠버네티스에 미칠 영향</a> (published 2021/07/01)</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-af7c1f9168ec67f957edc504f43faf9a>6 - 쿠버네티스 이슈와 보안</h1></div><div class=td-content><h1 id=pg-980c0542a3b195a20cfd4358792e2a38>6.1 - 쿠버네티스 이슈 트래커</h1><p>보안 문제를 보고하려면 <a href=/ko/docs/reference/issues-security/security/#%EC%B7%A8%EC%95%BD%EC%A0%90-%EB%B3%B4%EA%B3%A0>쿠버네티스 보안 공개 프로세스</a>를 따른다.</p><p>쿠버네티스 코드 작업 및 공개 이슈는 <a href=https://github.com/kubernetes/kubernetes/issues/>깃허브 이슈</a>를 사용하여 추적된다.</p><ul><li>[잘 알려진 CVE에 대한] 공식 리스트(/docs/reference/issues-security/official-cve-feed/)
<a href=https://github.com/kubernetes/committee-security-response>보안 대응 위원회(Security Response Committee)</a>
가 발표한 (보안 취약점)</li><li><a href="https://github.com/kubernetes/kubernetes/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aarea%2Fsecurity+in%3Atitle+CVE">CVE-연관된 깃허브 이슈들</a></li></ul><p>보안에 관련된 공지사항은 <a href=https://groups.google.com/forum/#!forum/kubernetes-security-announce>kubernetes-security-announce@googlegroups.com</a> 메일 리스트로 전송된다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1f7dc06f1cc1ea2cdde4480e54d5fb34>6.2 - 쿠버네티스 보안과 공개 정보</h1><p>이 페이지는 쿠버네티스 보안 및 공개 정보를 설명한다.</p><h2 id=보안-공지>보안 공지</h2><p>보안 및 주요 API 공지에 대한 이메일을 위해서는 <a href=https://groups.google.com/forum/#!forum/kubernetes-security-announce>kubernetes-security-announce</a>) 그룹에 가입한다.</p><h2 id=취약점-보고>취약점 보고</h2><p>우리는 쿠버네티스 오픈소스 커뮤니티에 취약점을 보고하는 보안 연구원들과 사용자들에게 매우 감사하고 있다. 모든 보고서는 커뮤니티 자원 봉사자들에 의해 철저히 조사된다.</p><p>보고서를 작성하려면, <a href=https://hackerone.com/kubernetes>쿠버네티스 버그 현상금 프로그램</a>에 취약점을 제출한다. 이를 통해 표준화된 응답시간으로 취약점을 분류하고 처리할 수 있다.</p><p>또한, 보안 세부 내용과 <a href=https://github.com/kubernetes/kubernetes/blob/master/.github/ISSUE_TEMPLATE/bug-report.yaml>모든 쿠버네티스 버그 보고서</a>로 부터 예상되는 세부사항을 <a href=mailto:security@kubernetes.io>security@kubernetes.io</a>로 이메일을 보낸다.</p><p><a href=https://git.k8s.io/security/README.md#product-security-committee-psc>보안 대응 위원회(Security Response Committee) 구성원</a>의 GPG 키를 사용하여 이 목록으로 이메일을 암호화할 수 있다. GPG를 사용한 암호화는 공개할 필요가 없다.</p><h3 id=언제-취약점을-보고해야-하는가>언제 취약점을 보고해야 하는가?</h3><ul><li>쿠버네티스에서 잠재적인 보안 취약점을 발견했다고 생각하는 경우</li><li>취약성이 쿠버네티스에 어떤 영향을 미치는지 확신할 수 없는 경우</li><li>쿠버네티스가 의존하는 다른 프로젝트에서 취약점을 발견한 경우<ul><li>자체 취약성 보고 및 공개 프로세스가 있는 프로젝트의 경우 직접 보고한다.</li></ul></li></ul><h3 id=언제-취약점을-보고하지-말아야-하는가>언제 취약점을 보고하지 말아야 하는가?</h3><ul><li>보안을 위해 쿠버네티스 구성요소를 조정하는데 도움이 필요한 경우</li><li>보안 관련 업데이트를 적용하는 데 도움이 필요한 경우</li><li>보안 관련 문제가 아닌 경우</li></ul><h2 id=보안-취약점-대응>보안 취약점 대응</h2><p>각 보고서는 보안 대응 위원회 위원들에 의해 작업일 3일 이내에 인정되고 분석된다. 이렇게 하면 <a href=https://git.k8s.io/security/security-release-process.md#disclosures>보안 릴리스 프로세스</a>가 시작된다.</p><p>보안 대응 위원회와 공유하는 모든 취약성 정보는 쿠버네티스 프로젝트 내에 있으며, 문제를 해결할 필요가 없는 한 다른 프로젝트에 전파되지 않는다.</p><p>보안 문제가 심사에서 확인된 수정, 릴리스 계획으로 이동함에 따라 리포터를 계속 업데이트할 것이다.</p><h2 id=공개-시기>공개 시기</h2><p>공개 날짜는 쿠버네티스 보안 대응 위원회와 버그 제출자가 협상한다. 사용자 완화가 가능해지면 가능한 빨리 버그를 완전히 공개하는 것이 좋다. 버그 또는 픽스가 아직 완전히 이해되지 않았거나 솔루션이 제대로 테스트되지 않았거나 벤더 협력을 위해 공개를 지연시키는 것이 합리적이다. 공개 기간은 즉시(특히 이미 공개적으로 알려진 경우)부터 몇 주까지다. 간단한 완화 기능이 있는 취약점의 경우 보고 날짜부터 공개 날짜까지는 7일 정도 소요될 것으로 예상된다. 쿠버네티스 보안 대응 위원회는 공개 날짜를 설정할 때 최종 결정권을 갖는다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5bbbc5163b35431b3bff029ab9ec57d3>7 - 설치 도구</h1></div><div class=td-content><h1 id=pg-f351ced098abbb076bc8c4be1053672b>7.1 - Kubeadm</h1><p><img src=/images/kubeadm-stacked-color.png align=right width=150px>Kubeadm은 쿠버네티스 클러스터 생성을 위한 "빠른 경로"의 모범 사례로 <code>kubeadm init</code> 및 <code>kubeadm join</code> 을 제공하도록 만들어진 도구이다.</p><p>kubeadm은 실행 가능한 최소 클러스터를 시작하고 실행하는 데 필요한 작업을 수행한다. 설계 상, 시스템 프로비저닝이 아닌 부트스트랩(bootstrapping)만 다룬다. 마찬가지로, 쿠버네티스 대시보드, 모니터링 솔루션 및 클라우드별 애드온과 같은 다양한 있으면 좋은(nice-to-have) 애드온을 설치하는 것은 범위에 포함되지 않는다.</p><p>대신, 우리는 더 높은 수준의 맞춤형 도구가 kubeadm 위에 구축될 것으로 기대하며, 이상적으로는, 모든 배포의 기반으로 kubeadm을 사용하면 규격을 따르는 클러스터를 더 쉽게 생성할 수 있다.</p><h2 id=설치-방법>설치 방법</h2><p>kubeadm을 설치하려면, <a href=/ko/docs/setup/production-environment/tools/kubeadm/install-kubeadm/>설치 가이드</a>를 참고한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>: 쿠버네티스 컨트롤 플레인 노드를 부트스트랩한다.</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>: 쿠버네티스 워커(worker) 노드를 부트스트랩하고 클러스터에 조인시킨다.</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/>kubeadm upgrade</a>: 쿠버네티스 클러스터를 새로운 버전으로 업그레이드한다.</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config</a>: kubeadm v1.7.x 이하의 버전을 사용하여 클러스터를 초기화한 경우, <code>kubeadm upgrade</code> 를 위해 사용자의 클러스터를 구성한다.</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token</a>: <code>kubeadm join</code> 을 위한 토큰을 관리한다.</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>: <code>kubeadm init</code> 또는 <code>kubeadm join</code> 에 의한 호스트의 모든 변경 사항을 되돌린다.</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-certs>kubeadm certs</a>: 쿠버네티스 인증서를 관리한다.</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig>kubeadm kubeconfig</a>: kubeconfig 파일을 관리한다.</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-version/>kubeadm version</a>: kubeadm 버전을 출력한다.</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a>: 커뮤니티에서 피드백을 수집하기 위해서 기능 미리 보기를 제공한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-36c22b52e8447eb3d2452d4f56fbea9b>7.1.1 - Kubeadm Generated</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-df8ff2190764e70c3de2015e2cb46b14>8 - 포트와 프로토콜</h1><p>물리적 네트워크 방화벽이 있는 온프레미스 데이터 센터 또는
퍼블릭 클라우드의 가상 네트워크와 같이 네트워크 경계가 엄격한 환경에서
쿠버네티스를 실행할 때, 쿠버네티스 구성 요소에서
사용하는 포트와 프로토콜을 알고 있는 것이 유용하다.</p><h2 id=컨트롤-플레인>컨트롤 플레인</h2><table><thead><tr><th>프로토콜</th><th>방향</th><th>포트 범위</th><th>용도</th><th>사용 주체</th></tr></thead><tbody><tr><td>TCP</td><td>인바운드</td><td>6443</td><td>쿠버네티스 API 서버</td><td>전부</td></tr><tr><td>TCP</td><td>인바운드</td><td>2379-2380</td><td>etcd 서버 클라이언트 API</td><td>kube-apiserver, etcd</td></tr><tr><td>TCP</td><td>인바운드</td><td>10250</td><td>Kubelet API</td><td>Self, 컨트롤 플레인</td></tr><tr><td>TCP</td><td>인바운드</td><td>10259</td><td>kube-scheduler</td><td>Self</td></tr><tr><td>TCP</td><td>인바운드</td><td>10257</td><td>kube-controller-manager</td><td>Self</td></tr></tbody></table><p>etcd 포트가 컨트롤 플레인 섹션에 포함되어 있지만, 외부 또는 사용자 지정 포트에서 자체
etcd 클러스터를 호스팅할 수도 있다.</p><h2 id=node>워커 노드</h2><table><thead><tr><th>프로토콜</th><th>방향</th><th>포트 범위</th><th>용도</th><th>사용 주체</th></tr></thead><tbody><tr><td>TCP</td><td>인바운드</td><td>10250</td><td>Kubelet API</td><td>Self, 컨트롤 플레인</td></tr><tr><td>TCP</td><td>인바운드</td><td>30000-32767</td><td>NodePort 서비스†</td><td>전부</td></tr></tbody></table><p>† <a href=/ko/docs/concepts/services-networking/service/>노드포트(NodePort) 서비스</a>의 기본 포트 범위.</p><p>모든 기본 포트 번호를 재정의할 수 있다. 사용자 지정 포트를 사용하는 경우
여기에 언급된 기본값 대신 해당 포트를 열어야 한다.</p><p>종종 발생하는 한 가지 일반적인 예는 API 서버 포트를 443으로 변경하는 경우이다.
또는, API 서버의 기본 포트를 그대로 유지하고,
443 포트에서 수신 대기하는 로드 밸런서 뒤에 API 서버를 두고,
로드 밸런서에서 API 서버로 가는 요청을 API 서버의 기본 포트로 라우팅할 수도 있다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-03460a7254c6c73eb2a1bb3dd7d25910>9 - 명령줄 도구 (kubectl)</h1><p>쿠버네티스는 다음을 제공한다: 쿠버네티스 API를 사용하여
쿠버네티스 클러스터의 <a class=glossary-tooltip title='컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='컨트롤 플레인'>컨트롤 플레인</a>과
통신하기 위한 커맨드라인 툴</p><p>이 툴의 이름은 <code>kubectl</code>이다.</p><p>구성을 위해, <code>kubectl</code> 은 config 파일을 $HOME/.kube 에서 찾는다.
KUBECONFIG 환경 변수를 설정하거나 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/><code>--kubeconfig</code></a>
플래그를 설정하여 다른 <a href=/ko/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
파일을 지정할 수 있다.</p><p>이 개요는 <code>kubectl</code> 구문을 다루고, 커맨드 동작을 설명하며, 일반적인 예제를 제공한다.
지원되는 모든 플래그 및 하위 명령을 포함한 각 명령에 대한 자세한 내용은
<a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a> 참조 문서를 참고한다.</p><p>설치 방법에 대해서는 <a href=/ko/docs/tasks/tools/>kubectl 설치</a>를 참고하고,
빠른 가이드는 <a href=/ko/docs/reference/kubectl/cheatsheet/>치트 시트</a>를 참고한다. <code>docker</code> 명령줄 도구에 익숙하다면,
<a href=/ko/docs/reference/kubectl/docker-cli-to-kubectl/>도커 사용자를 위한 <code>kubectl</code></a>에서 대응되는 쿠버네티스 명령어를 볼 수 있다.</p><h2 id=구문>구문</h2><p>터미널 창에서 <code>kubectl</code> 명령을 실행하려면 다음의 구문을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> <span style=color:#666>[</span>flags<span style=color:#666>]</span>
</span></span></code></pre></div><p>다음은 <code>command</code>, <code>TYPE</code>, <code>NAME</code> 과 <code>flags</code> 에 대한 설명이다.</p><ul><li><p><code>command</code>: 하나 이상의 리소스에서 수행하려는 동작을 지정한다.
예: <code>create</code>, <code>get</code>, <code>describe</code>, <code>delete</code></p></li><li><p><code>TYPE</code>: <a href=#%EB%A6%AC%EC%86%8C%EC%8A%A4-%ED%83%80%EC%9E%85>리소스 타입</a>을 지정한다. 리소스 타입은 대소문자를 구분하지 않으며
단수형, 복수형 또는 약어 형식을 지정할 수 있다.
예를 들어, 다음의 명령은 동일한 출력 결과를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod pod1
</span></span><span style=display:flex><span>kubectl get pods pod1
</span></span><span style=display:flex><span>kubectl get po pod1
</span></span></code></pre></div></li><li><p><code>NAME</code>: 리소스 이름을 지정한다. 이름은 대소문자를 구분한다. 이름을 생략하면, 모든 리소스에 대한 세부 사항이 표시된다. 예: <code>kubectl get pods</code></p><p>여러 리소스에 대한 작업을 수행할 때, 타입 및 이름별로 각 리소스를 지정하거나 하나 이상의 파일을 지정할 수 있다.</p><ul><li><p>타입 및 이름으로 리소스를 지정하려면 다음을 참고한다.</p><ul><li><p>리소스가 모두 동일한 타입인 경우 리소스를 그룹화하려면 다음을 사용한다. <code>TYPE1 name1 name2 name&lt;#></code><br>예: <code>kubectl get pod example-pod1 example-pod2</code></p></li><li><p>여러 리소스 타입을 개별적으로 지정하려면 다음을 사용한다. <code>TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE&lt;#>/name&lt;#></code><br>예: <code>kubectl get pod/example-pod1 replicationcontroller/example-rc1</code></p></li></ul></li><li><p>하나 이상의 파일로 리소스를 지정하려면 다음을 사용한다. <code>-f file1 -f file2 -f file&lt;#></code></p><ul><li>YAML이 특히 구성 파일에 대해 더 사용자 친화적이므로, <a href=/ko/docs/concepts/configuration/overview/#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EA%B5%AC%EC%84%B1-%ED%8C%81>JSON 대신 YAML을 사용한다</a>.<br>예: <code>kubectl get -f ./pod.yaml</code></li></ul></li></ul></li><li><p><code>flags</code>: 선택적 플래그를 지정한다. 예를 들어, <code>-s</code> 또는 <code>--server</code> 플래그를 사용하여 쿠버네티스 API 서버의 주소와 포트를 지정할 수 있다.<br></p></li></ul><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 커맨드 라인에서 지정하는 플래그는 기본값과 해당 환경 변수를 무시한다.</div><p>도움이 필요하다면, 터미널 창에서 <code>kubectl help</code> 를 실행한다.</p><h2 id=클러스터-내-인증과-네임스페이스-오버라이드>클러스터 내 인증과 네임스페이스 오버라이드</h2><p>기본적으로 <code>kubectl</code>은 먼저 자신이 파드 안에서 실행되고 있는지, 즉 클러스터 안에 있는지를 판별한다. 이를 위해 <code>KUBERNETES_SERVICE_HOST</code>와 <code>KUBERNETES_SERVICE_PORT</code> 환경 변수, 그리고 서비스 어카운트 토큰 파일이 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 경로에 있는지를 확인한다. 세 가지가 모두 감지되면, 클러스터 내 인증이 적용된다.</p><p>하위 호환성을 위해, 클러스터 내 인증 시에 <code>POD_NAMESPACE</code> 환경 변수가 설정되어 있으면, 서비스 어카운트 토큰의 기본 네임스페이스 설정을 오버라이드한다. 기본 네임스페이스 설정에 의존하는 모든 매니페스트와 도구가 영향을 받을 것이다.</p><p><strong><code>POD_NAMESPACE</code> 환경 변수</strong></p><p><code>POD_NAMESPACE</code> 환경 변수가 설정되어 있으면, 네임스페이스에 속하는 자원에 대한 CLI 작업은 환경 변수에 설정된 네임스페이스를 기본값으로 사용한다. 예를 들어, 환경 변수가 <code>seattle</code>로 설정되어 있으면, <code>kubectl get pods</code> 명령은 <code>seattle</code> 네임스페이스에 있는 파드 목록을 반환한다. 이는 파드가 네임스페이스에 속하는 자원이며, 명령어에 네임스페이스를 특정하지 않았기 때문이다. <code>kubectl api-resources</code> 명령을 실행하고 결과를 확인하여 특정 자원이 네임스페이스에 속하는 자원인지 판별한다.</p><p>명시적으로 <code>--namespace &lt;value></code> 인자를 사용하면 위와 같은 동작을 오버라이드한다.</p><p><strong>kubectl이 서비스어카운트 토큰을 관리하는 방법</strong></p><p>만약</p><ul><li>쿠버네티스 서비스 어카운트 토큰 파일이
<code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 경로에 마운트되어 있고,</li><li><code>KUBERNETES_SERVICE_HOST</code> 환경 변수가 설정되어 있고,</li><li><code>KUBERNETES_SERVICE_PORT</code> 환경 변수가 설정되어 있고,</li><li>kubectl 명령에 네임스페이스를 명시하지 않으면</li></ul><p>kubectl은 자신이 클러스터 내부에서 실행되고 있다고 가정한다.
kubectl은 해당 서비스어카운트의 네임스페이스(파드의 네임스페이스와 동일하다)를 인식하고 해당 네임스페이스에 대해 동작한다.
이는 클러스터 외부에서 실행되었을 때와는 다른데,
kubectl이 클러스터 외부에서 실행되었으며 네임스페이스가 명시되지 않은 경우
kubectl은 <code>default</code> 네임스페이스에 대해 동작한다.</p><h2 id=명령어>명령어</h2><p>다음 표에는 모든 <code>kubectl</code> 작업에 대한 간단한 설명과 일반적인 구문이 포함되어 있다.</p><table><thead><tr><th>명령어</th><th>구문</th><th>설명</th></tr></thead><tbody><tr><td><code>alpha</code></td><td><code>kubectl alpha SUBCOMMAND [flags]</code></td><td>쿠버네티스 클러스터에서 기본적으로 활성화되어 있지 않은 알파 기능의 사용할 수 있는 명령을 나열한다.</td></tr><tr><td><code>annotate</code></td><td><code>kubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td><td>하나 이상의 리소스 어노테이션을 추가하거나 업데이트한다.</td></tr><tr><td><code>api-resources</code></td><td><code>kubectl api-resources [flags]</code></td><td>사용 가능한 API 리소스를 나열한다.</td></tr><tr><td><code>api-versions</code></td><td><code>kubectl api-versions [flags]</code></td><td>사용 가능한 API 버전을 나열한다.</td></tr><tr><td><code>apply</code></td><td><code>kubectl apply -f FILENAME [flags]</code></td><td>파일이나 표준입력(stdin)으로부터 리소스에 구성 변경 사항을 적용한다.</td></tr><tr><td><code>attach</code></td><td><code>kubectl attach POD -c CONTAINER [-i] [-t] [flags]</code></td><td>실행 중인 컨테이너에 연결하여 출력 스트림을 보거나 표준입력을 통해 컨테이너와 상호 작용한다.</td></tr><tr><td><code>auth</code></td><td><code>kubectl auth [flags] [options]</code></td><td>승인을 검사한다.</td></tr><tr><td><code>autoscale</code></td><td><code>kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></td><td>레플리케이션 컨트롤러에서 관리하는 파드 집합을 자동으로 조정한다.</td></tr><tr><td><code>certificate</code></td><td><code>kubectl certificate SUBCOMMAND [options]</code></td><td>인증서 리소스를 수정한다.</td></tr><tr><td><code>cluster-info</code></td><td><code>kubectl cluster-info [flags]</code></td><td>클러스터의 마스터와 서비스에 대한 엔드포인트 정보를 표시한다.</td></tr><tr><td><code>completion</code></td><td><code>kubectl completion SHELL [options]</code></td><td>지정된 셸(bash 또는 zsh)에 대한 셸 완성 코드를 출력한다.</td></tr><tr><td><code>config</code></td><td><code>kubectl config SUBCOMMAND [flags]</code></td><td>kubeconfig 파일을 수정한다. 세부 사항은 개별 하위 명령을 참고한다.</td></tr><tr><td><code>convert</code></td><td><code>kubectl convert -f FILENAME [options]</code></td><td>다른 API 버전 간에 구성 파일을 변환한다. YAML 및 JSON 형식이 모두 허용된다. 참고 - <code>kubectl-convert</code> 플러그인을 설치해야 한다.</td></tr><tr><td><code>cordon</code></td><td><code>kubectl cordon NODE [options]</code></td><td>노드를 스케줄 불가능(unschedulable)으로 표시한다.</td></tr><tr><td><code>cp</code></td><td><code>kubectl cp &lt;file-spec-src> &lt;file-spec-dest> [options]</code></td><td>컨테이너에서 그리고 컨테이너로 파일 및 디렉터리를 복사한다.</td></tr><tr><td><code>create</code></td><td><code>kubectl create -f FILENAME [flags]</code></td><td>파일이나 표준입력에서 하나 이상의 리소스를 생성한다.</td></tr><tr><td><code>delete</code></td><td><code>kubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]</code></td><td>파일, 표준입력 또는 레이블 셀렉터, 이름, 리소스 셀렉터 또는 리소스를 지정하여 리소스를 삭제한다.</td></tr><tr><td><code>describe</code></td><td><code>kubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]</code></td><td>하나 이상의 리소스의 자세한 상태를 표시한다.</td></tr><tr><td><code>diff</code></td><td><code>kubectl diff -f FILENAME [flags]</code></td><td>라이브 구성에 대해 파일이나 표준입력의 차이점을 출력한다.</td></tr><tr><td><code>drain</code></td><td><code>kubectl drain NODE [options]</code></td><td>유지 보수를 준비 중인 노드를 드레인한다.</td></tr><tr><td><code>edit</code></td><td><code>kubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]</code></td><td>기본 편집기를 사용하여 서버에서 하나 이상의 리소스 정의를 편집하고 업데이트한다.</td></tr><tr><td><code>exec</code></td><td><code>kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]</code></td><td>파드의 컨테이너에 대해 명령을 실행한다.</td></tr><tr><td><code>explain</code></td><td><code>kubectl explain [--recursive=false] [flags]</code></td><td>파드, 노드, 서비스 등의 다양한 리소스에 대한 문서를 출력한다.</td></tr><tr><td><code>expose</code></td><td><code>kubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code></td><td>레플리케이션 컨트롤러, 서비스 또는 파드를 새로운 쿠버네티스 서비스로 노출한다.</td></tr><tr><td><code>get</code></td><td><code>kubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]</code></td><td>하나 이상의 리소스를 나열한다.</td></tr><tr><td><code>kustomize</code></td><td><code>kubectl kustomize &lt;dir> [flags] [options]</code></td><td>kustomization.yaml 파일의 지시 사항에서 생성된 API 리소스 집합을 나열한다. 인수는 파일을 포함하는 디렉터리의 경로이거나, 리포지터리 루트와 관련하여 경로 접미사가 동일한 git 리포지터리 URL이어야 한다.</td></tr><tr><td><code>label</code></td><td><code>kubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td><td>하나 이상의 리소스 레이블을 추가하거나 업데이트한다.</td></tr><tr><td><code>logs</code></td><td><code>kubectl logs POD [-c CONTAINER] [--follow] [flags]</code></td><td>파드의 컨테이너에 대한 로그를 출력한다.</td></tr><tr><td><code>options</code></td><td><code>kubectl options</code></td><td>모든 명령에 적용되는 전역 커맨드 라인 옵션을 나열한다.</td></tr><tr><td><code>patch</code></td><td><code>kubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]</code></td><td>전략적 병합 패치 프로세스를 사용하여 리소스의 하나 이상의 필드를 업데이트한다.</td></tr><tr><td><code>plugin</code></td><td><code>kubectl plugin [flags] [options]</code></td><td>플러그인과 상호 작용하기 위한 유틸리티를 제공한다.</td></tr><tr><td><code>port-forward</code></td><td><code>kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]</code></td><td>하나 이상의 로컬 포트를 파드로 전달한다.</td></tr><tr><td><code>proxy</code></td><td><code>kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</code></td><td>쿠버네티스 API 서버에 프록시를 실행한다.</td></tr><tr><td><code>replace</code></td><td><code>kubectl replace -f FILENAME</code></td><td>파일 또는 표준입력에서 리소스를 교체한다.</td></tr><tr><td><code>rollout</code></td><td><code>kubectl rollout SUBCOMMAND [options]</code></td><td>리소스의 롤아웃을 관리한다. 유효한 리소스 타입에는 디플로이먼트(deployment), 데몬셋(daemonset)과 스테이트풀셋(statefulset)이 포함된다.</td></tr><tr><td><code>run</code></td><td><code>kubectl run NAME --image=image [--env="key=value"] [--port=port] [--dry-run=server|client|none] [--overrides=inline-json] [flags]</code></td><td>클러스터에서 지정된 이미지를 실행한다.</td></tr><tr><td><code>scale</code></td><td><code>kubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code></td><td>지정된 레플리케이션 컨트롤러의 크기를 업데이트한다.</td></tr><tr><td><code>set</code></td><td><code>kubectl set SUBCOMMAND [options]</code></td><td>애플리케이션 리소스를 구성한다.</td></tr><tr><td><code>taint</code></td><td><code>kubectl taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N [options]</code></td><td>하나 이상의 노드에서 테인트(taint)를 업데이트한다.</td></tr><tr><td><code>top</code></td><td><code>kubectl top [flags] [options]</code></td><td>리소스(CPU/메모리/스토리지) 사용량을 표시한다.</td></tr><tr><td><code>uncordon</code></td><td><code>kubectl uncordon NODE [options]</code></td><td>노드를 스케줄 가능(schedulable)으로 표시한다.</td></tr><tr><td><code>version</code></td><td><code>kubectl version [--client] [flags]</code></td><td>클라이언트와 서버에서 실행 중인 쿠버네티스 버전을 표시한다.</td></tr><tr><td><code>wait</code></td><td><code>kubectl wait ([-f FILENAME] | resource.group/resource.name | resource.group [(-l label | --all)]) [--for=delete|--for condition=available] [options]</code></td><td>실험(experimental) 기능: 하나 이상의 리소스에서 특정 조건을 기다린다.</td></tr></tbody></table><p>명령 동작에 대한 자세한 내용을 배우려면 <a href=/ko/docs/reference/kubectl/kubectl/>kubectl</a> 참조 문서를 참고한다.</p><h2 id=리소스-타입>리소스 타입</h2><p>다음 표에는 지원되는 모든 리소스 타입과 해당 약어가 나열되어 있다.</p><p>(이 출력은 <code>kubectl api-resources</code> 에서 확인할 수 있으며, 쿠버네티스 1.19.1 에서의 출력을 기준으로 한다.)</p><table><thead><tr><th>NAME</th><th>SHORTNAMES</th><th>APIGROUP</th><th>NAMESPACED</th><th>KIND</th></tr></thead><tbody><tr><td><code>bindings</code></td><td></td><td></td><td>true</td><td>Binding</td></tr><tr><td><code>componentstatuses</code></td><td><code>cs</code></td><td></td><td>false</td><td>ComponentStatus</td></tr><tr><td><code>configmaps</code></td><td><code>cm</code></td><td></td><td>true</td><td>ConfigMap</td></tr><tr><td><code>endpoints</code></td><td><code>ep</code></td><td></td><td>true</td><td>Endpoints</td></tr><tr><td><code>events</code></td><td><code>ev</code></td><td></td><td>true</td><td>Event</td></tr><tr><td><code>limitranges</code></td><td><code>limits</code></td><td></td><td>true</td><td>LimitRange</td></tr><tr><td><code>namespaces</code></td><td><code>ns</code></td><td></td><td>false</td><td>Namespace</td></tr><tr><td><code>nodes</code></td><td><code>no</code></td><td></td><td>false</td><td>Node</td></tr><tr><td><code>persistentvolumeclaims</code></td><td><code>pvc</code></td><td></td><td>true</td><td>PersistentVolumeClaim</td></tr><tr><td><code>persistentvolumes</code></td><td><code>pv</code></td><td></td><td>false</td><td>PersistentVolume</td></tr><tr><td><code>pods</code></td><td><code>po</code></td><td></td><td>true</td><td>Pod</td></tr><tr><td><code>podtemplates</code></td><td></td><td></td><td>true</td><td>PodTemplate</td></tr><tr><td><code>replicationcontrollers</code></td><td><code>rc</code></td><td></td><td>true</td><td>ReplicationController</td></tr><tr><td><code>resourcequotas</code></td><td><code>quota</code></td><td></td><td>true</td><td>ResourceQuota</td></tr><tr><td><code>secrets</code></td><td></td><td></td><td>true</td><td>Secret</td></tr><tr><td><code>serviceaccounts</code></td><td><code>sa</code></td><td></td><td>true</td><td>ServiceAccount</td></tr><tr><td><code>services</code></td><td><code>svc</code></td><td></td><td>true</td><td>Service</td></tr><tr><td><code>mutatingwebhookconfigurations</code></td><td></td><td>admissionregistration.k8s.io</td><td>false</td><td>MutatingWebhookConfiguration</td></tr><tr><td><code>validatingwebhookconfigurations</code></td><td></td><td>admissionregistration.k8s.io</td><td>false</td><td>ValidatingWebhookConfiguration</td></tr><tr><td><code>customresourcedefinitions</code></td><td><code>crd,crds</code></td><td>apiextensions.k8s.io</td><td>false</td><td>CustomResourceDefinition</td></tr><tr><td><code>apiservices</code></td><td></td><td>apiregistration.k8s.io</td><td>false</td><td>APIService</td></tr><tr><td><code>controllerrevisions</code></td><td></td><td>apps</td><td>true</td><td>ControllerRevision</td></tr><tr><td><code>daemonsets</code></td><td><code>ds</code></td><td>apps</td><td>true</td><td>DaemonSet</td></tr><tr><td><code>deployments</code></td><td><code>deploy</code></td><td>apps</td><td>true</td><td>Deployment</td></tr><tr><td><code>replicasets</code></td><td><code>rs</code></td><td>apps</td><td>true</td><td>ReplicaSet</td></tr><tr><td><code>statefulsets</code></td><td><code>sts</code></td><td>apps</td><td>true</td><td>StatefulSet</td></tr><tr><td><code>tokenreviews</code></td><td></td><td>authentication.k8s.io</td><td>false</td><td>TokenReview</td></tr><tr><td><code>localsubjectaccessreviews</code></td><td></td><td>authorization.k8s.io</td><td>true</td><td>LocalSubjectAccessReview</td></tr><tr><td><code>selfsubjectaccessreviews</code></td><td></td><td>authorization.k8s.io</td><td>false</td><td>SelfSubjectAccessReview</td></tr><tr><td><code>selfsubjectrulesreviews</code></td><td></td><td>authorization.k8s.io</td><td>false</td><td>SelfSubjectRulesReview</td></tr><tr><td><code>subjectaccessreviews</code></td><td></td><td>authorization.k8s.io</td><td>false</td><td>SubjectAccessReview</td></tr><tr><td><code>horizontalpodautoscalers</code></td><td><code>hpa</code></td><td>autoscaling</td><td>true</td><td>HorizontalPodAutoscaler</td></tr><tr><td><code>cronjobs</code></td><td><code>cj</code></td><td>batch</td><td>true</td><td>CronJob</td></tr><tr><td><code>jobs</code></td><td></td><td>batch</td><td>true</td><td>Job</td></tr><tr><td><code>certificatesigningrequests</code></td><td><code>csr</code></td><td>certificates.k8s.io</td><td>false</td><td>CertificateSigningRequest</td></tr><tr><td><code>leases</code></td><td></td><td>coordination.k8s.io</td><td>true</td><td>Lease</td></tr><tr><td><code>endpointslices</code></td><td></td><td>discovery.k8s.io</td><td>true</td><td>EndpointSlice</td></tr><tr><td><code>events</code></td><td><code>ev</code></td><td>events.k8s.io</td><td>true</td><td>Event</td></tr><tr><td><code>ingresses</code></td><td><code>ing</code></td><td>extensions</td><td>true</td><td>Ingress</td></tr><tr><td><code>flowschemas</code></td><td></td><td>flowcontrol.apiserver.k8s.io</td><td>false</td><td>FlowSchema</td></tr><tr><td><code>prioritylevelconfigurations</code></td><td></td><td>flowcontrol.apiserver.k8s.io</td><td>false</td><td>PriorityLevelConfiguration</td></tr><tr><td><code>ingressclasses</code></td><td></td><td>networking.k8s.io</td><td>false</td><td>IngressClass</td></tr><tr><td><code>ingresses</code></td><td><code>ing</code></td><td>networking.k8s.io</td><td>true</td><td>Ingress</td></tr><tr><td><code>networkpolicies</code></td><td><code>netpol</code></td><td>networking.k8s.io</td><td>true</td><td>NetworkPolicy</td></tr><tr><td><code>runtimeclasses</code></td><td></td><td>node.k8s.io</td><td>false</td><td>RuntimeClass</td></tr><tr><td><code>poddisruptionbudgets</code></td><td><code>pdb</code></td><td>policy</td><td>true</td><td>PodDisruptionBudget</td></tr><tr><td><code>podsecuritypolicies</code></td><td><code>psp</code></td><td>policy</td><td>false</td><td>PodSecurityPolicy</td></tr><tr><td><code>clusterrolebindings</code></td><td></td><td>rbac.authorization.k8s.io</td><td>false</td><td>ClusterRoleBinding</td></tr><tr><td><code>clusterroles</code></td><td></td><td>rbac.authorization.k8s.io</td><td>false</td><td>ClusterRole</td></tr><tr><td><code>rolebindings</code></td><td></td><td>rbac.authorization.k8s.io</td><td>true</td><td>RoleBinding</td></tr><tr><td><code>roles</code></td><td></td><td>rbac.authorization.k8s.io</td><td>true</td><td>Role</td></tr><tr><td><code>priorityclasses</code></td><td><code>pc</code></td><td>scheduling.k8s.io</td><td>false</td><td>PriorityClass</td></tr><tr><td><code>csidrivers</code></td><td></td><td>storage.k8s.io</td><td>false</td><td>CSIDriver</td></tr><tr><td><code>csinodes</code></td><td></td><td>storage.k8s.io</td><td>false</td><td>CSINode</td></tr><tr><td><code>storageclasses</code></td><td><code>sc</code></td><td>storage.k8s.io</td><td>false</td><td>StorageClass</td></tr><tr><td><code>volumeattachments</code></td><td></td><td>storage.k8s.io</td><td>false</td><td>VolumeAttachment</td></tr></tbody></table><h2 id=출력-옵션>출력 옵션</h2><p>특정 명령의 출력을 서식화하거나 정렬하는 방법에 대한 정보는 다음 섹션을 참고한다. 다양한 출력 옵션을 지원하는 명령에 대한 자세한 내용은 <a href=/ko/docs/reference/kubectl/kubectl/>kubectl</a> 참조 문서를 참고한다.</p><h3 id=출력-서식화>출력 서식화</h3><p>모든 <code>kubectl</code> 명령의 기본 출력 형식은 사람이 읽을 수 있는 일반 텍스트 형식이다. 특정 형식으로 터미널 창에 세부 정보를 출력하려면, 지원되는 <code>kubectl</code> 명령에 <code>-o</code> 또는 <code>--output</code> 플래그를 추가할 수 있다.</p><h4 id=구문-1>구문</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> -o &lt;output_format&gt;
</span></span></code></pre></div><p><code>kubectl</code> 명령에 따라, 다음과 같은 출력 형식이 지원된다.</p><table><thead><tr><th>출력 형식</th><th>설명</th></tr></thead><tbody><tr><td><code>-o custom-columns=&lt;spec></code></td><td>쉼표로 구분된 <a href=#custom-columns>사용자 정의 열</a> 목록을 사용하여 테이블을 출력한다.</td></tr><tr><td><code>-o custom-columns-file=&lt;filename></code></td><td><code>&lt;filename></code> 파일에서 <a href=#custom-columns>사용자 정의 열</a> 템플릿을 사용하여 테이블을 출력한다.</td></tr><tr><td><code>-o json</code></td><td>JSON 형식의 API 오브젝트를 출력한다.</td></tr><tr><td><code>-o jsonpath=&lt;template></code></td><td><a href=/ko/docs/reference/kubectl/jsonpath/>jsonpath</a> 표현식에 정의된 필드를 출력한다.</td></tr><tr><td><code>-o jsonpath-file=&lt;filename></code></td><td><code>&lt;filename></code> 파일에서 <a href=/ko/docs/reference/kubectl/jsonpath/>jsonpath</a> 표현식으로 정의된 필드를 출력한다.</td></tr><tr><td><code>-o name</code></td><td>리소스 이름만 출력한다.</td></tr><tr><td><code>-o wide</code></td><td>추가 정보가 포함된 일반 텍스트 형식으로 출력된다. 파드의 경우, 노드 이름이 포함된다.</td></tr><tr><td><code>-o yaml</code></td><td>YAML 형식의 API 오브젝트를 출력한다.</td></tr></tbody></table><h5 id=예제>예제</h5><p>이 예제에서, 다음의 명령은 단일 파드에 대한 세부 정보를 YAML 형식의 오브젝트로 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod web-pod-13je7 -o yaml
</span></span></code></pre></div><p>기억하기: 각 명령이 지원하는 출력 형식에 대한 자세한 내용은
<a href=/ko/docs/reference/kubectl/kubectl/>kubectl</a> 참조 문서를 참고한다.</p><h4 id=custom-columns>사용자 정의 열</h4><p>사용자 정의 열을 정의하고 원하는 세부 정보만 테이블에 출력하려면, <code>custom-columns</code> 옵션을 사용할 수 있다.
사용자 정의 열을 인라인으로 정의하거나 템플릿 파일을 사용하도록 선택할 수 있다. <code>-o custom-columns=&lt;spec></code> 또는 <code>-o custom-columns-file=&lt;filename></code></p><h5 id=예제-1>예제</h5><p>인라인:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; -o custom-columns<span style=color:#666>=</span>NAME:.metadata.name,RSRC:.metadata.resourceVersion
</span></span></code></pre></div><p>템플릿 파일:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; -o custom-columns-file<span style=color:#666>=</span>template.txt
</span></span></code></pre></div><p><code>template.txt</code> 파일에 포함된 내용은 다음과 같다.</p><pre tabindex=0><code>NAME          RSRC
metadata.name metadata.resourceVersion
</code></pre><p>두 명령 중 하나를 실행한 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME           RSRC
submit-queue   610995
</code></pre><h4 id=서버측-열>서버측 열</h4><p><code>kubectl</code> 는 서버에서 오브젝트에 대한 특정 열 정보 수신을 지원한다.
이는 클라이언트가 출력할 수 있도록, 주어진 리소스에 대해 서버가 해당 리소스와 관련된 열과 행을 반환한다는 것을 의미한다.
이는 서버가 출력의 세부 사항을 캡슐화하도록 하여, 동일한 클러스터에 대해 사용된 클라이언트에서 사람이 읽을 수 있는 일관된 출력을 허용한다.</p><p>이 기능은 기본적으로 활성화되어 있다. 사용하지 않으려면,
<code>kubectl get</code> 명령에 <code>--server-print=false</code> 플래그를 추가한다.</p><h5 id=예제-2>예제</h5><p>파드 상태에 대한 정보를 출력하려면, 다음과 같은 명령을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; --server-print<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>NAME       AGE
pod-name   1m
</code></pre><h3 id=오브젝트-목록-정렬>오브젝트 목록 정렬</h3><p>터미널 창에서 정렬된 목록으로 오브젝트를 출력하기 위해, 지원되는 <code>kubectl</code> 명령에 <code>--sort-by</code> 플래그를 추가할 수 있다. <code>--sort-by</code> 플래그와 함께 숫자나 문자열 필드를 지정하여 오브젝트를 정렬한다. 필드를 지정하려면, <a href=/ko/docs/reference/kubectl/jsonpath/>jsonpath</a> 표현식을 사용한다.</p><h4 id=구문-2>구문</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> --sort-by<span style=color:#666>=</span>&lt;jsonpath_exp&gt;
</span></span></code></pre></div><h5 id=예제-3>예제</h5><p>이름별로 정렬된 파드 목록을 출력하려면, 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --sort-by<span style=color:#666>=</span>.metadata.name
</span></span></code></pre></div><h2 id=예제-일반적인-작업>예제: 일반적인 작업</h2><p>다음 예제 세트를 사용하여 일반적으로 사용되는 <code>kubectl</code> 조작 실행에 익숙해진다.</p><p><code>kubectl apply</code> - 파일 또는 표준입력에서 리소스를 적용하거나 업데이트한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># example-service.yaml의 정의를 사용하여 서비스를 생성한다.</span>
</span></span><span style=display:flex><span>kubectl apply -f example-service.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># example-controller.yaml의 정의를 사용하여 레플리케이션 컨트롤러를 생성한다.</span>
</span></span><span style=display:flex><span>kubectl apply -f example-controller.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &lt;directory&gt; 디렉터리 내의 .yaml, .yml 또는 .json 파일에 정의된 오브젝트를 생성한다.</span>
</span></span><span style=display:flex><span>kubectl apply -f &lt;directory&gt;
</span></span></code></pre></div><p><code>kubectl get</code> - 하나 이상의 리소스를 나열한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드를 일반 텍스트 출력 형식으로 나열한다.</span>
</span></span><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드를 일반 텍스트 출력 형식으로 나열하고 추가 정보(예: 노드 이름)를 포함한다.</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 지정된 이름의 레플리케이션 컨트롤러를 일반 텍스트 출력 형식으로 나열한다. 팁: &#39;replicationcontroller&#39; 리소스 타입을 &#39;rc&#39;로 짧게 바꿔쓸 수 있다.</span>
</span></span><span style=display:flex><span>kubectl get replicationcontroller &lt;rc-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 레플리케이션 컨트롤러와 서비스를 일반 텍스트 출력 형식으로 함께 나열한다.</span>
</span></span><span style=display:flex><span>kubectl get rc,services
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 데몬 셋을 일반 텍스트 출력 형식으로 나열한다.</span>
</span></span><span style=display:flex><span>kubectl get ds
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 노드 server01에서 실행 중인 모든 파드를 나열한다.</span>
</span></span><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>spec.nodeName<span style=color:#666>=</span>server01
</span></span></code></pre></div><p><code>kubectl describe</code> - 초기화되지 않은 리소스를 포함하여 하나 이상의 리소스의 기본 상태를 디폴트로 표시한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 노드 이름이 &lt;node-name&gt;인 노드의 세부 사항을 표시한다.</span>
</span></span><span style=display:flex><span>kubectl describe nodes &lt;node-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 이름이 &lt;pod-name&gt; 인 파드의 세부 정보를 표시한다.</span>
</span></span><span style=display:flex><span>kubectl describe pods/&lt;pod-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이름이 &lt;rc-name&gt;인 레플리케이션 컨트롤러가 관리하는 모든 파드의 세부 정보를 표시한다.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 기억하기: 레플리케이션 컨트롤러에서 생성된 모든 파드에는 레플리케이션 컨트롤러 이름이 접두사로 붙는다.</span>
</span></span><span style=display:flex><span>kubectl describe pods &lt;rc-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드의 정보를 출력한다.</span>
</span></span><span style=display:flex><span>kubectl describe pods
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubectl get</code> 명령은 일반적으로 동일한 리소스 타입의 하나 이상의
리소스를 검색하는 데 사용된다. 예를 들어, <code>-o</code> 또는 <code>--output</code> 플래그를
사용하여 출력 형식을 사용자 정의할 수 있는 풍부한 플래그 세트가 있다.
<code>-w</code> 또는 <code>--watch</code> 플래그를 지정하여 특정 오브젝트에 대한 업데이트 진행과정을 확인할 수
있다. <code>kubectl describe</code> 명령은 지정된 리소스의 여러 관련 측면을
설명하는 데 더 중점을 둔다. API 서버에 대한 여러 API 호출을 호출하여
사용자에 대한 뷰(view)를 빌드할 수 있다. 예를 들어, <code>kubectl describe node</code>
명령은 노드에 대한 정보뿐만 아니라, 노드에서 실행 중인 파드의 요약 정보, 노드에 대해 생성된 이벤트 등의
정보도 검색한다.</div><p><code>kubectl delete</code> - 파일, 표준입력 또는 레이블 선택기, 이름, 리소스 선택기나 리소스를 지정하여 리소스를 삭제한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># pod.yaml 파일에 지정된 타입과 이름을 사용하여 파드를 삭제한다.</span>
</span></span><span style=display:flex><span>kubectl delete -f pod.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &#39;&lt;label-key&gt;=&lt;label-value&gt;&#39; 레이블이 있는 모든 파드와 서비스를 삭제한다.</span>
</span></span><span style=display:flex><span>kubectl delete pods,services -l &lt;label-key&gt;<span style=color:#666>=</span>&lt;label-value&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 초기화되지 않은 파드를 포함한 모든 파드를 삭제한다.</span>
</span></span><span style=display:flex><span>kubectl delete pods --all
</span></span></code></pre></div><p><code>kubectl exec</code> - 파드의 컨테이너에 대해 명령을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 &lt;pod-name&gt;에서 &#39;date&#39;를 실행한 결과를 얻는다. 기본적으로, 첫 번째 컨테이너에서 출력된다.</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -- date
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 &lt;pod-name&gt;의 &lt;container-name&gt; 컨테이너에서 &#39;date&#39;를 실행하여 출력 결과를 얻는다.</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; -- date
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 &lt;pod-name&gt;에서 대화식 TTY를 연결해 /bin/bash를 실행한다. 기본적으로, 첫 번째 컨테이너에서 출력된다.</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -ti &lt;pod-name&gt; -- /bin/bash
</span></span></code></pre></div><p><code>kubectl logs</code> - 파드의 컨테이너에 대한 로그를 출력한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 &lt;pod-name&gt;에서 로그의 스냅샷을 반환한다.</span>
</span></span><span style=display:flex><span>kubectl logs &lt;pod-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 &lt;pod-name&gt;에서 로그 스트리밍을 시작한다. 이것은 리눅스 명령 &#39;tail -f&#39;와 비슷하다.</span>
</span></span><span style=display:flex><span>kubectl logs -f &lt;pod-name&gt;
</span></span></code></pre></div><p><code>kubectl diff</code> - 제안된 클러스터 업데이트의 차이점을 본다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;pod.json&#34;에 포함된 리소스의 차이점을 출력한다.</span>
</span></span><span style=display:flex><span>kubectl diff -f pod.json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 표준입력에서 파일을 읽어 차이점을 출력한다.</span>
</span></span><span style=display:flex><span>cat service.yaml | kubectl diff -f -
</span></span></code></pre></div><h2 id=예제-플러그인-작성-및-사용>예제: 플러그인 작성 및 사용</h2><p><code>kubectl</code> 플러그인 작성과 사용에 익숙해지려면 다음의 예제 세트를 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 어떤 언어로든 간단한 플러그인을 만들고 &#34;kubectl-&#34; 접두사로</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 시작하도록 실행 파일의 이름을 지정한다.</span>
</span></span><span style=display:flex><span>cat ./kubectl-hello
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#080></span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이 플러그인은 &#34;hello world&#34;라는 단어를 출력한다</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;hello world&#34;</span>
</span></span></code></pre></div><p>작성한 플러그인을 실행 가능하게 한다</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chmod a+x ./kubectl-hello
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 그리고 PATH의 위치로 옮긴다</span>
</span></span><span style=display:flex><span>sudo mv ./kubectl-hello /usr/local/bin
</span></span><span style=display:flex><span>sudo chown root:root /usr/local/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이제 kubectl 플러그인을 만들고 &#34;설치했다&#34;.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># kubectl에서 플러그인을 일반 명령처럼 호출하여 플러그인을 사용할 수 있다</span>
</span></span><span style=display:flex><span>kubectl hello
</span></span></code></pre></div><pre tabindex=0><code>hello world
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 플러그인을 배치한 $PATH의 폴더에서 플러그인을 삭제하여,</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 플러그인을 &#34;제거&#34;할 수 있다</span>
</span></span><span style=display:flex><span>sudo rm /usr/local/bin/kubectl-hello
</span></span></code></pre></div><p><code>kubectl</code> 에 사용할 수 있는 모든 플러그인을 보려면,
<code>kubectl plugin list</code> 하위 명령을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl plugin list
</span></span></code></pre></div><p>출력 결과는 다음과 비슷하다.</p><pre tabindex=0><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
/usr/local/bin/kubectl-bar
</code></pre><p><code>kubectl plugin list</code> 는 또한 실행 가능하지 않거나,
다른 플러그인에 의해 차단된 플러그인에 대해 경고한다. 예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo chmod -x /usr/local/bin/kubectl-foo <span style=color:#080;font-style:italic># 실행 권한 제거</span>
</span></span><span style=display:flex><span>kubectl plugin list
</span></span></code></pre></div><pre tabindex=0><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable
/usr/local/bin/kubectl-bar

error: one plugin warning was found
</code></pre><p>플러그인은 기존 kubectl 명령 위에 보다 복잡한 기능을
구축하는 수단으로 생각할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat ./kubectl-whoami
</span></span></code></pre></div><p>다음 몇 가지 예는 이미 <code>kubectl-whoami</code> 에
다음 내용이 있다고 가정한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#080></span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이 플러그인은 현재 선택된 컨텍스트를 기반으로 현재 사용자에 대한</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 정보를 출력하기 위해 &#39;kubectl config&#39; 명령을 사용한다.</span>
</span></span><span style=display:flex><span>kubectl config view --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{ range .contexts }}{{ if eq .name &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config current-context<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34; }}Current user: {{ printf &#34;%s\n&#34; .context.user }}{{ end }}{{ end }}&#39;</span>
</span></span></code></pre></div><p>위의 플러그인을 실행하면 KUBECONFIG 파일에서 현재의 컨텍스트에 대한
사용자가 포함된 출력이 제공된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 파일을 실행 가능하게 한다</span>
</span></span><span style=display:flex><span>sudo chmod +x ./kubectl-whoami
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 그리고 PATH로 옮긴다</span>
</span></span><span style=display:flex><span>sudo mv ./kubectl-whoami /usr/local/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl whoami
</span></span><span style=display:flex><span>Current user: plugins-user
</span></span></code></pre></div><h2 id=다음-내용>다음 내용</h2><ul><li><code>kubectl</code> 레퍼런스 문서를 읽는다.<ul><li>kubectl <a href=/ko/docs/reference/kubectl/kubectl/>명령어 레퍼런스</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>명령줄 인자</a> 레퍼런스</li></ul></li><li><a href=/ko/docs/reference/kubectl/conventions/><code>kubectl</code> 사용 규칙</a>에 대해 알아본다.</li><li>kubectl의 <a href=/ko/docs/reference/kubectl/jsonpath/>JSONPath 지원</a>에 대해 알아본다.</li><li><a href=/ko/docs/tasks/extend-kubectl/kubectl-plugins/>플러그인으로 kubectl 확장</a>에 대해 알아본다.<ul><li>플러그인에 대해 좀 더 알아보려면, <a href=https://github.com/kubernetes/sample-cli-plugin>예시 CLI 플러그인</a>을 살펴본다.</li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>9.1 - kubectl 치트 시트</h1><p>이 페이지는 일반적으로 사용하는 <code>kubectl</code> 커맨드와 플래그에 대한 목록을 포함한다.</p><h2 id=kubectl-자동-완성>Kubectl 자동 완성</h2><h3 id=bash>BASH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># bash-completion 패키지를 먼저 설치한 후, bash의 자동 완성을 현재 셸에 설정한다</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># 자동 완성을 bash 셸에 영구적으로 추가한다</span>
</span></span></code></pre></div><p>또한, <code>kubectl</code>의 의미로 사용되는 약칭을 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
</span></span><span style=display:flex><span><span style=color:#a2f>complete</span> -o default -F __start_kubectl k
</span></span></code></pre></div><h3 id=zsh>ZSH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># 현재 셸에 zsh의 자동 완성 설정</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;[[ $commands[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&#39;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># 자동 완성을 zsh 셸에 영구적으로 추가한다.</span>
</span></span></code></pre></div><h3 id=all-namespaces-에-대한-노트>--all-namespaces 에 대한 노트</h3><p><code>--all-namespaces</code>를 붙여야 하는 상황이 자주 발생하므로, <code>--all-namespaces</code>의 축약형을 알아 두는 것이 좋다.</p><p><code>kubectl -A</code></p><h2 id=kubectl-컨텍스트와-설정>Kubectl 컨텍스트와 설정</h2><p><code>kubectl</code>이 통신하고 설정 정보를 수정하는 쿠버네티스 클러스터를
지정한다. 설정 파일에 대한 자세한 정보는 <a href=/ko/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig를 이용한 클러스터 간 인증</a> 문서를
참고한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl config view <span style=color:#080;font-style:italic># 병합된 kubeconfig 설정을 표시한다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 동시에 여러 kubeconfig 파일을 사용하고 병합된 구성을 확인한다</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># e2e 사용자의 암호를 확인한다</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>     <span style=color:#080;font-style:italic># 첫 번째 사용자 출력</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>    <span style=color:#080;font-style:italic># 사용자 리스트 조회</span>
</span></span><span style=display:flex><span>kubectl config get-contexts                           <span style=color:#080;font-style:italic># 컨텍스트 리스트 출력</span>
</span></span><span style=display:flex><span>kubectl config current-context                        <span style=color:#080;font-style:italic># 현재 컨텍스트 출력</span>
</span></span><span style=display:flex><span>kubectl config use-context my-cluster-name            <span style=color:#080;font-style:italic># my-cluster-name를 기본 컨텍스트로 설정</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config set-cluster my-cluster-name            <span style=color:#080;font-style:italic># kubeconfig에 클러스터 엔트리를 설정</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># kubeconfig에 이 클라이언트가 발생시킨 요청에 사용할 프록시 서버의 URL을 구성한다.</span>
</span></span><span style=display:flex><span>kubectl config set-cluster my-cluster-name --proxy-url<span style=color:#666>=</span>my-proxy-url
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 기본 인증을 지원하는 새로운 사용자를 kubeconf에 추가한다</span>
</span></span><span style=display:flex><span>kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 해당 컨텍스트에서 모든 후속 kubectl 커맨드에 대한 네임스페이스를 영구적으로 저장한다</span>
</span></span><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 특정 사용자와 네임스페이스를 사용하는 컨텍스트 설정</span>
</span></span><span style=display:flex><span>kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config <span style=color:#a2f>unset</span> users.foo                       <span style=color:#080;font-style:italic># foo 사용자 삭제</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 컨텍스트/네임스페이스를 설정/조회하는 단축 명령 (bash 및 bash 호환 셸에서만 동작함, 네임스페이스 설정을 위해 kn 을 사용하기 전에 현재 컨텍스트가 설정되어야 함)</span>
</span></span><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>kx</span><span style=color:#666>=</span><span style=color:#b44>&#39;f() { [ &#34;$1&#34; ] &amp;&amp; kubectl config use-context $1 || kubectl config current-context ; } ; f&#39;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>kn</span><span style=color:#666>=</span><span style=color:#b44>&#39;f() { [ &#34;$1&#34; ] &amp;&amp; kubectl config set-context --current --namespace $1 || kubectl config view --minify | grep namespace | cut -d&#34; &#34; -f6 ; } ; f&#39;</span>
</span></span></code></pre></div><h2 id=kubectl-apply>Kubectl apply</h2><p><code>apply</code>는 쿠버네티스 리소스를 정의하는 파일을 통해 애플리케이션을 관리한다. <code>kubectl apply</code>를 실행하여 클러스터에 리소스를 생성하고 업데이트한다. 이것은 프로덕션 환경에서 쿠버네티스 애플리케이션을 관리할 때 권장된다. <a href=https://kubectl.docs.kubernetes.io>Kubectl Book</a>을 참고한다.</p><h2 id=오브젝트-생성>오브젝트 생성</h2><p>쿠버네티스 매니페스트는 JSON이나 YAML로 정의된다. 파일 확장자는 <code>.yaml</code>
, <code>.yml</code>, <code>.json</code> 이 사용된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f ./my-manifest.yaml            <span style=color:#080;font-style:italic># 리소스(들) 생성</span>
</span></span><span style=display:flex><span>kubectl apply -f ./my1.yaml -f ./my2.yaml      <span style=color:#080;font-style:italic># 여러 파일로 부터 생성</span>
</span></span><span style=display:flex><span>kubectl apply -f ./dir                         <span style=color:#080;font-style:italic># dir 내 모든 매니페스트 파일에서 리소스(들) 생성</span>
</span></span><span style=display:flex><span>kubectl apply -f https://git.io/vPieo          <span style=color:#080;font-style:italic># url로부터 리소스(들) 생성</span>
</span></span><span style=display:flex><span>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx  <span style=color:#080;font-style:italic># nginx 단일 인스턴스를 시작</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;Hello World&#34;를 출력하는 잡(Job) 생성</span>
</span></span><span style=display:flex><span>kubectl create job hello --image<span style=color:#666>=</span>busybox:1.28 -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 매분마다 &#34;Hello World&#34;를 출력하는 크론잡(CronJob) 생성</span>
</span></span><span style=display:flex><span>kubectl create cronjob hello --image<span style=color:#666>=</span>busybox:1.28   --schedule<span style=color:#666>=</span><span style=color:#b44>&#34;*/1 * * * *&#34;</span> -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl explain pods                           <span style=color:#080;font-style:italic># 파드 매니페스트 문서를 조회</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># stdin으로 다수의 YAML 오브젝트 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox:1.28
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>---
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep-less
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox:1.28
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 여러 개의 키로 시크릿 생성</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: mysecret
</span></span></span><span style=display:flex><span><span style=color:#b44>type: Opaque
</span></span></span><span style=display:flex><span><span style=color:#b44>data:
</span></span></span><span style=display:flex><span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><h2 id=리소스-조회-및-찾기>리소스 조회 및 찾기</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 기본 출력을 위한 Get 커맨드</span>
</span></span><span style=display:flex><span>kubectl get services                          <span style=color:#080;font-style:italic># 네임스페이스 내 모든 서비스의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># 모든 네임스페이스 내 모든 파드의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide                      <span style=color:#080;font-style:italic># 해당하는 네임스페이스 내 모든 파드의 상세 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># 특정 디플로이먼트의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pods                              <span style=color:#080;font-style:italic># 네임스페이스 내 모든 파드의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># 파드의 YAML 조회</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 상세 출력을 위한 Describe 커맨드</span>
</span></span><span style=display:flex><span>kubectl describe nodes my-node
</span></span><span style=display:flex><span>kubectl describe pods my-pod
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Name으로 정렬된 서비스의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 재시작 횟수로 정렬된 파드의 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># PersistentVolumes을 용량별로 정렬해서 조회</span>
</span></span><span style=display:flex><span>kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># app=cassandra 레이블을 가진 모든 파드의 레이블 버전 조회</span>
</span></span><span style=display:flex><span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 예를 들어 &#39;ca.crt&#39;와 같이 점이 있는 키값을 검색한다</span>
</span></span><span style=display:flex><span>kubectl get configmap myconfig <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.ca\.crt}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 밑줄(`_`) 대신 대시(`-`)를 사용하여 base64 인코딩된 값을 조회</span>
</span></span><span style=display:flex><span>kubectl get secret my-secret --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{index .data &#34;key-name-with-dashes&#34;}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 워커 노드 조회 (셀렉터를 사용하여 &#39;node-role.kubernetes.io/control-plane&#39;</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 으로 명명된 라벨의 결과를 제외)</span>
</span></span><span style=display:flex><span>kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/control-plane&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 네임스페이스의 모든 실행 중인 파드를 조회</span>
</span></span><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 노드의 외부IP를 조회</span>
</span></span><span style=display:flex><span>kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 특정 RC에 속해있는 파드 이름의 목록 조회</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;jq&#34; 커맨드는 jsonpath를 사용하는 매우 복잡한 변환에 유용하다. https://stedolan.github.io/jq/ 에서 확인할 수 있다.</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드(또는 레이블을 지원하는 다른 쿠버네티스 오브젝트)의 레이블 조회</span>
</span></span><span style=display:flex><span>kubectl get pods --show-labels
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 어떤 노드가 준비됐는지 확인</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 외부 도구 없이 디코딩된 시크릿 출력</span>
</span></span><span style=display:flex><span>kubectl get secret my-secret -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range $k,$v := .data}}{{&#34;### &#34;}}{{$k}}{{&#34;\n&#34;}}{{$v|base64decode}}{{&#34;\n\n&#34;}}{{end}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드에 의해 현재 사용되고 있는 모든 시크릿 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드의 초기화 컨테이너(initContainer)의 컨테이너ID 목록 조회</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 초기화 컨테이너(initContainer)를 제거하지 않고 정지된 모든 컨테이너를 정리할 때 유용하다.</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 타임스탬프로 정렬된 이벤트 목록 조회</span>
</span></span><span style=display:flex><span>kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 매니페스트가 적용된 경우 클러스터의 현재 상태와 클러스터의 상태를 비교한다.</span>
</span></span><span style=display:flex><span>kubectl diff -f ./my-manifest.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 노드에 대해 반환된 모든 키의 마침표로 구분된 트리를 생성한다.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 복잡한 중첩 JSON 구조 내에서 키를 찾을 때 유용하다.</span>
</span></span><span style=display:flex><span>kubectl get nodes -o json | jq -c <span style=color:#b44>&#39;paths|join(&#34;.&#34;)&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 파드 등에 대해 반환된 모든 키의 마침표로 구분된 트리를 생성한다.</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq -c <span style=color:#b44>&#39;paths|join(&#34;.&#34;)&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 모든 파드에 대해 ENV를 생성한다(각 파드에 기본 컨테이너가 있고, 기본 네임스페이스가 있고, `env` 명령어가 동작한다고 가정).</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># `env` 뿐만 아니라 다른 지원되는 명령어를 모든 파드에 실행할 때에도 참고할 수 있다.</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> pod in <span style=color:#a2f;font-weight:700>$(</span>kubectl get po --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span> <span style=color:#a2f>echo</span> <span style=color:#b8860b>$pod</span> <span style=color:#666>&amp;&amp;</span> kubectl <span style=color:#a2f>exec</span> -it <span style=color:#b8860b>$pod</span> -- env; <span style=color:#a2f;font-weight:700>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 디플로이먼트의 status 서브리소스를 조회한다.</span>
</span></span><span style=display:flex><span>kubectl get deployment nginx-deployment --subresource<span style=color:#666>=</span>status
</span></span></code></pre></div><h2 id=리소스-업데이트>리소스 업데이트</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># &#34;frontend&#34; 디플로이먼트의 &#34;www&#34; 컨테이너 이미지를 업데이트하는 롤링 업데이트</span>
</span></span><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># 현 리비전을 포함한 디플로이먼트의 이력을 체크</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># 이전 디플로이먼트로 롤백</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># 특정 리비전으로 롤백</span>
</span></span><span style=display:flex><span>kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># 완료될 때까지 &#34;frontend&#34; 디플로이먼트의 롤링 업데이트 상태를 감시</span>
</span></span><span style=display:flex><span>kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># &#34;frontend&#34; 디플로이먼트의 롤링 재시작</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># stdin으로 전달된 JSON을 기반으로 파드 교체</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 리소스를 강제 교체, 삭제 후 재생성함. 이것은 서비스를 중단시킴.</span>
</span></span><span style=display:flex><span>kubectl replace --force -f ./pod.json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 복제된 nginx를 위한 서비스를 생성한다. 80 포트로 서비스하고, 컨테이너는 8000 포트로 연결한다.</span>
</span></span><span style=display:flex><span>kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 단일-컨테이너 파드의 이미지 버전(태그)을 v4로 업데이트</span>
</span></span><span style=display:flex><span>kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># 레이블 추가</span>
</span></span><span style=display:flex><span>kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># 어노테이션 추가</span>
</span></span><span style=display:flex><span>kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># 디플로이먼트 &#34;foo&#34; 오토스케일</span>
</span></span></code></pre></div><h2 id=리소스-패치>리소스 패치</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 노드를 부분적으로 업데이트</span>
</span></span><span style=display:flex><span>kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 컨테이너의 이미지를 업데이트. 병합(merge) 키이므로, spec.containers[*].name이 필요</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 위치 배열을 이용한 json 패치를 사용하여, 컨테이너의 이미지를 업데이트</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 위치 배열을 이용한 json 패치를 사용하여 livenessProbe 디플로이먼트 비활성화</span>
</span></span><span style=display:flex><span>kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 위치 배열에 새 요소 추가</span>
</span></span><span style=display:flex><span>kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 디플로이먼트의 scale 서브리소스를 패치하여 레플리카 수 업데이트</span>
</span></span><span style=display:flex><span>kubectl patch deployment nginx-deployment --subresource<span style=color:#666>=</span><span style=color:#b44>&#39;scale&#39;</span> --type<span style=color:#666>=</span><span style=color:#b44>&#39;merge&#39;</span> -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;replicas&#34;:2}}&#39;</span>
</span></span></code></pre></div><h2 id=리소스-편집>리소스 편집</h2><p>선호하는 편집기로 모든 API 리소스를 편집할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># docker-registry라는 서비스 편집</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># 다른 편집기 사용</span>
</span></span></code></pre></div><h2 id=리소스-스케일링>리소스 스케일링</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># &#39;foo&#39;라는 레플리카셋을 3으로 스케일</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># &#34;foo.yaml&#34;에 지정된 리소스의 크기를 3으로 스케일</span>
</span></span><span style=display:flex><span>kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># mysql이라는 디플로이먼트의 현재 크기가 2인 경우, mysql을 3으로 스케일</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># 여러 개의 레플리케이션 컨트롤러 스케일</span>
</span></span></code></pre></div><h2 id=리소스-삭제>리소스 삭제</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl delete -f ./pod.json                                      <span style=color:#080;font-style:italic># pod.json에 지정된 유형 및 이름을 사용하여 파드 삭제</span>
</span></span><span style=display:flex><span>kubectl delete pod unwanted --now                                 <span style=color:#080;font-style:italic># 유예 시간 없이 즉시 파드 삭제</span>
</span></span><span style=display:flex><span>kubectl delete pod,service baz foo                                <span style=color:#080;font-style:italic># &#34;baz&#34;, &#34;foo&#34;와 동일한 이름을 가진 파드와 서비스 삭제</span>
</span></span><span style=display:flex><span>kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                      <span style=color:#080;font-style:italic># name=myLabel 라벨을 가진 파드와 서비스 삭제</span>
</span></span><span style=display:flex><span>kubectl -n my-ns delete pod,svc --all                             <span style=color:#080;font-style:italic># my-ns 네임스페이스 내 모든 파드와 서비스 삭제</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># awk pattern1 또는 pattern2에 매칭되는 모든 파드 삭제</span>
</span></span><span style=display:flex><span>kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</span></span></code></pre></div><h2 id=실행-중인-파드와-상호-작용>실행 중인 파드와 상호 작용</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># 파드 로그 덤프 (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># name이 myLabel인 파드 로그 덤프 (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># 컨테이너의 이전 인스턴스 생성에 대한 파드 로그 덤프 (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># 파드 로그 덤프 (stdout, 멀티-컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># name이 myLabel인 파드 로그 덤프 (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># 컨테이너의 이전 인스턴스 생성에 대한 파드 로그 덤프 (stdout, 멀티-컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># 실시간 스트림 파드 로그(stdout)</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># 실시간 스트림 파드 로그(stdout, 멀티-컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># name이 myLabel인 모든 파드의 로그 스트리밍 (stdout)</span>
</span></span><span style=display:flex><span>kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox:1.28 -- sh  <span style=color:#080;font-style:italic># 대화형 셸로 파드를 실행</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx -n mynamespace      <span style=color:#080;font-style:italic># mynamespace 네임스페이스에서 nginx 파드 1개 실행</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx                     <span style=color:#080;font-style:italic># nginx 파드를 실행하고 해당 스펙을 pod.yaml 파일에 기록</span>
</span></span><span style=display:flex><span>--dry-run<span style=color:#666>=</span>client -o yaml &gt; pod.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># 실행 중인 컨테이너에 연결</span>
</span></span><span style=display:flex><span>kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># 로컬 머신의 5000번 포트를 리스닝하고, my-pod의 6000번 포트로 전달</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># 기존 파드에서 명령 실행(한 개 컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> --stdin --tty my-pod -- /bin/sh        <span style=color:#080;font-style:italic># 실행 중인 파드로 대화형 셸 액세스(1 컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># 기존 파드에서 명령 실행(멀티-컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># 특정 파드와 해당 컨테이너에 대한 메트릭 표시</span>
</span></span><span style=display:flex><span>kubectl top pod POD_NAME --sort-by<span style=color:#666>=</span>cpu              <span style=color:#080;font-style:italic># 지정한 파드에 대한 메트릭을 표시하고 &#39;cpu&#39; 또는 &#39;memory&#39;별로 정렬</span>
</span></span></code></pre></div><h2 id=컨테이너로-컨테이너에서-파일과-디렉터리-복사>컨테이너로/컨테이너에서 파일과 디렉터리 복사</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cp /tmp/foo_dir my-pod:/tmp/bar_dir            <span style=color:#080;font-style:italic># 로컬 디렉토리 /tmp/foo_dir 를 현재 네임스페이스의 my-pod 파드 안의 /tmp/bar_dir 로 복사</span>
</span></span><span style=display:flex><span>kubectl cp /tmp/foo my-pod:/tmp/bar -c my-container    <span style=color:#080;font-style:italic># 로컬 파일 /tmp/foo 를 my-pod 파드의 my-container 컨테이너 안의 /tmp/bar 로 복사</span>
</span></span><span style=display:flex><span>kubectl cp /tmp/foo my-namespace/my-pod:/tmp/bar       <span style=color:#080;font-style:italic># 로컬 파일 /tmp/foo 를 my-namespace 네임스페이스의 my-pod 파드 안의 /tmp/bar 로 복사</span>
</span></span><span style=display:flex><span>kubectl cp my-namespace/my-pod:/tmp/foo /tmp/bar       <span style=color:#080;font-style:italic># my-namespace 네임스페이스의 my-pod 파드 안의 파일 /tmp/foo 를 로컬의 /tmp/bar 로 복사</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubectl cp</code> 명령을 사용하려면 컨테이너 이미지에 'tar' 바이너리가 포함되어 있어야 한다. 'tar'가 없으면, <code>kubectl cp</code>는 실패할 것이다.
심볼릭 링크, 와일드카드 확장, 파일 모드 보존과 같은 고급 사용 사례에 대해서는 <code>kubectl exec</code> 를 고려해 볼 수 있다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tar cf - /tmp/foo | kubectl <span style=color:#a2f>exec</span> -i -n my-namespace my-pod -- tar xf - -C /tmp/bar           <span style=color:#080;font-style:italic># 로컬 파일 /tmp/foo 를 my-namespace 네임스페이스의 my-pod 파드 안의 /tmp/bar 로 복사</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -n my-namespace my-pod -- tar cf - /tmp/foo | tar xf - -C /tmp/bar    <span style=color:#080;font-style:italic># my-namespace 네임스페이스의 my-pod 파드 안의 파일 /tmp/foo 를 로컬의 /tmp/bar 로 복사</span>
</span></span></code></pre></div><h2 id=디플로이먼트-서비스와-상호-작용>디플로이먼트, 서비스와 상호 작용</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs deploy/my-deployment                         <span style=color:#080;font-style:italic># 디플로이먼트에 대한 파드 로그 덤프 (단일-컨테이너 경우)</span>
</span></span><span style=display:flex><span>kubectl logs deploy/my-deployment -c my-container         <span style=color:#080;font-style:italic># 디플로이먼트에 대한 파드 로그 덤프 (멀티-컨테이너 경우)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl port-forward svc/my-service <span style=color:#666>5000</span>                  <span style=color:#080;font-style:italic># 로컬 머신의 5000번 포트를 리스닝하고, my-service의 동일한(5000번) 포트로 전달</span>
</span></span><span style=display:flex><span>kubectl port-forward svc/my-service 5000:my-service-port  <span style=color:#080;font-style:italic># 로컬 머신의 5000번 포트를 리스닝하고, my-service의 &lt;my-service-port&gt; 라는 이름을 가진 포트로 전달</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl port-forward deploy/my-deployment 5000:6000       <span style=color:#080;font-style:italic># 로컬 머신의 5000번 포트를 리스닝하고, &lt;my-deployment&gt; 에 의해 생성된 파드의 6000번 포트로 전달</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> deploy/my-deployment -- ls                   <span style=color:#080;font-style:italic># &lt;my-deployment&gt; 에 의해 생성된 첫번째 파드의 첫번째 컨테이너에 명령어 실행 (단일- 또는 다중-컨테이너 경우)</span>
</span></span></code></pre></div><h2 id=노드-클러스터와-상호-작용>노드, 클러스터와 상호 작용</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># my-node를 스케줄링할 수 없도록 표기</span>
</span></span><span style=display:flex><span>kubectl drain my-node                                                 <span style=color:#080;font-style:italic># 유지 보수를 위해서 my-node를 준비 상태로 비움</span>
</span></span><span style=display:flex><span>kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># my-node를 스케줄링할 수 있도록 표기</span>
</span></span><span style=display:flex><span>kubectl top node my-node                                              <span style=color:#080;font-style:italic># 주어진 노드에 대한 메트릭 표시</span>
</span></span><span style=display:flex><span>kubectl cluster-info                                                  <span style=color:#080;font-style:italic># 마스터 및 서비스의 주소 표시</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># 현재 클러스터 상태를 stdout으로 덤프</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># 현재 클러스터 상태를 /path/to/cluster-state으로 덤프</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 현재 노드에 존재하고 있는 테인트(taint)들을 확인</span>
</span></span><span style=display:flex><span>kubectl get nodes -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span>NodeName:.metadata.name,TaintKey:.spec.taints<span style=color:#666>[</span>*<span style=color:#666>]</span>.key,TaintValue:.spec.taints<span style=color:#666>[</span>*<span style=color:#666>]</span>.value,TaintEffect:.spec.taints<span style=color:#666>[</span>*<span style=color:#666>]</span>.effect
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이미 존재하고 있는 key와 effect를 갖는 테인트의 경우, 지정한 값으로 대체</span>
</span></span><span style=display:flex><span>kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</span></span></code></pre></div><h3 id=리소스-타입>리소스 타입</h3><p>단축명, <a href=/ko/docs/concepts/overview/kubernetes-api/#api-%EA%B7%B8%EB%A3%B9%EA%B3%BC-%EB%B2%84%EC%A0%84-%EA%B7%9C%EC%B9%99>API 그룹</a>과 함께 지원되는 모든 리소스 유형들, 그것들의 <a href=/ko/docs/concepts/overview/working-with-objects/namespaces>네임스페이스</a>와 <a href=/ko/docs/concepts/overview/working-with-objects/kubernetes-objects>종류(Kind)</a>를 나열:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources
</span></span></code></pre></div><p>API 리소스를 탐색하기 위한 다른 작업:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># 네임스페이스를 가지는 모든 리소스</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># 네임스페이스를 가지지 않는 모든 리소스</span>
</span></span><span style=display:flex><span>kubectl api-resources -o name                <span style=color:#080;font-style:italic># 모든 리소스의 단순한 (리소스 이름만) 출력</span>
</span></span><span style=display:flex><span>kubectl api-resources -o wide                <span style=color:#080;font-style:italic># 모든 리소스의 확장된 (&#34;wide&#34;로 알려진) 출력</span>
</span></span><span style=display:flex><span>kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># &#34;list&#34;와 &#34;get&#34;의 요청 동사를 지원하는 모든 리소스 출력</span>
</span></span><span style=display:flex><span>kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># &#34;extensions&#34; API 그룹의 모든 리소스</span>
</span></span></code></pre></div><h3 id=출력-형식-지정>출력 형식 지정</h3><p>특정 형식으로 터미널 창에 세부 사항을 출력하려면, 지원되는 <code>kubectl</code> 명령에 <code>-o</code> (또는 <code>--output</code>) 플래그를 추가한다.</p><table><thead><tr><th>출력 형식</th><th>세부 사항</th></tr></thead><tbody><tr><td><code>-o=custom-columns=&lt;명세></code></td><td>쉼표로 구분된 사용자 정의 열 목록을 사용하여 테이블 출력</td></tr><tr><td><code>-o=custom-columns-file=&lt;파일명></code></td><td><code>&lt;파일명></code>파일에서 사용자 정의 열 템플릿을 사용하여 테이블 출력</td></tr><tr><td><code>-o=json</code></td><td>JSON 형식의 API 오브젝트 출력</td></tr><tr><td><code>-o=jsonpath=&lt;템플릿></code></td><td><a href=/ko/docs/reference/kubectl/jsonpath>jsonpath</a> 표현식에 정의된 필드 출력</td></tr><tr><td><code>-o=jsonpath-file=&lt;파일명></code></td><td>&lt;파일명> 파일에서 <a href=/ko/docs/reference/kubectl/jsonpath>jsonpath</a> 표현식에 정의된 필드 출력</td></tr><tr><td><code>-o=name</code></td><td>리소스 명만 출력하고 그 외에는 출력하지 않음</td></tr><tr><td><code>-o=wide</code></td><td>추가 정보가 포함된 일반-텍스트 형식으로 출력하고, 파드의 경우 노드 명이 포함</td></tr><tr><td><code>-o=yaml</code></td><td>YAML 형식의 API 오브젝트 출력</td></tr></tbody></table><p><code>-o=custom-columns</code> 의 사용 예시:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 클러스터에서 실행 중인 모든 이미지</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[*].image&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># `default` 네임스페이스의 모든 이미지를 파드별로 그룹지어 출력</span>
</span></span><span style=display:flex><span>kubectl get pods --namespace default --output<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#34;NAME:.metadata.name,IMAGE:.spec.containers[*].image&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#080;font-style:italic># &#34;registry.k8s.io/coredns:1.6.2&#34; 를 제외한 모든 이미지</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[?(@.image!=&#34;registry.k8s.io/coredns:1.6.2&#34;)].image&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 이름에 관계없이 메타데이터 아래의 모든 필드</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:metadata.*&#39;</span>
</span></span></code></pre></div><p>더 많은 예제는 kubectl <a href=/ko/docs/reference/kubectl/#custom-columns>참조 문서</a>를 참고한다.</p><h3 id=kubectl-출력-로그-상세-레벨-verbosity-과-디버깅>Kubectl 출력 로그 상세 레벨(verbosity)과 디버깅</h3><p>Kubectl 로그 상세 레벨(verbosity)은 <code>-v</code> 또는<code>--v</code> 플래그와 로그 레벨을 나타내는 정수로 제어된다. 일반적인 쿠버네티스 로깅 규칙과 관련 로그 레벨이 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>여기</a>에 설명되어 있다.</p><table><thead><tr><th>로그 레벨</th><th>세부 사항</th></tr></thead><tbody><tr><td><code>--v=0</code></td><td>일반적으로 클러스터 운영자(operator)에게 <em>항상</em> 보여지게 하기에는 유용함.</td></tr><tr><td><code>--v=1</code></td><td>자세한 정보를 원하지 않는 경우, 적절한 기본 로그 수준.</td></tr><tr><td><code>--v=2</code></td><td>서비스와 시스템의 중요한 변화와 관련이있는 중요한 로그 메시지에 대한 유용한 정상 상태 정보. 이는 대부분의 시스템에서 권장되는 기본 로그 수준이다.</td></tr><tr><td><code>--v=3</code></td><td>변경 사항에 대한 확장 정보.</td></tr><tr><td><code>--v=4</code></td><td>디버그 수준 상세화.</td></tr><tr><td><code>--v=5</code></td><td>트레이스 수준 상세화.</td></tr><tr><td><code>--v=6</code></td><td>요청한 리소스를 표시.</td></tr><tr><td><code>--v=7</code></td><td>HTTP 요청 헤더를 표시.</td></tr><tr><td><code>--v=8</code></td><td>HTTP 요청 내용을 표시.</td></tr><tr><td><code>--v=9</code></td><td>내용을 잘라 내지 않고 HTTP 요청 내용을 표시.</td></tr></tbody></table><h2 id=다음-내용>다음 내용</h2><ul><li><p><a href=/ko/docs/reference/kubectl/>kubectl 개요</a>를 읽고 <a href=/ko/docs/reference/kubectl/jsonpath>JsonPath</a>에 대해 배워보자.</p></li><li><p><a href=/ko/docs/reference/kubectl/kubectl/>kubectl</a> 옵션을 참고한다.</p></li><li><p>재사용 스크립트에서 kubectl 사용 방법을 이해하기 위해 <a href=/ko/docs/reference/kubectl/conventions/>kubectl 사용 규칙</a>을 참고한다.</p></li><li><p>더 많은 커뮤니티 <a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>kubectl 치트시트</a>를 확인한다.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4d3e62632c189fcc3c1357cd8fb8799c>9.2 - kubectl</h1><h2 id=시놉시스>시놉시스</h2><p>kubectl은 쿠버네티스 클러스터 관리자를 제어한다.</p><p>자세한 정보는 <a href=/ko/docs/reference/kubectl/>kubectl 개요</a>를 확인한다.</p><pre tabindex=0><code>kubectl [flags]
</code></pre><h2 id=옵션>옵션</h2><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--add-dir-header</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>true인 경우, 로그 메시지의 헤더에 파일 디렉터리를 추가한다.</td></tr><tr><td colspan=2>--alsologtostderr</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>표준 에러와 파일에 로그를 기록한다.</td></tr><tr><td colspan=2>--as string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>작업을 수행할 사용자 이름</td></tr><tr><td colspan=2>--as-group stringArray</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>작업을 수행할 그룹. 이 플래그를 반복해서 여러 그룹을 지정할 수 있다.</td></tr><tr><td colspan=2>--azure-container-registry-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Azure 컨테이너 레지스트리 구성 정보가 포함된 파일의 경로이다.</td></tr><tr><td colspan=2>--cache-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: "$HOME/.kube/cache"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>기본 캐시 디렉터리</td></tr><tr><td colspan=2>--certificate-authority string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>인증 기관의 인증서에 대한 파일 경로</td></tr><tr><td colspan=2>--client-certificate string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>TLS용 클라이언트 인증서의 파일 경로</td></tr><tr><td colspan=2>--client-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>TLS용 클라이언트 키의 파일 경로</td></tr><tr><td colspan=2>--cloud-provider-gce-l7lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 130.211.0.0/22,35.191.0.0/16</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>L7 LB 트래픽 프록시 및 상태 확인을 위해 GCE 방화벽에서 오픈된 CIDR</td></tr><tr><td colspan=2>--cloud-provider-gce-lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 130.211.0.0/22,209.85.152.0/22,209.85.204.0/22,35.191.0.0/16</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>L4 LB 트래픽 프록시 및 상태 확인을 위해 GCE 방화벽에서 오픈된 CIDR</td></tr><tr><td colspan=2>--cluster string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>사용할 kubeconfig 클러스터의 이름</td></tr><tr><td colspan=2>--context string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>사용할 kubeconfig 콘텍스트의 이름</td></tr><tr><td colspan=2>--default-not-ready-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 300</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>아직 톨러레이션(toleration)이 없는 모든 파드에 기본적으로 추가되는 notReady:NoExecute에 대한 톨러레이션의 tolerationSeconds를 나타낸다.</td></tr><tr><td colspan=2>--default-unreachable-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 300</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>아직 톨러레이션이 없어서 기본인 unreachable:NoExecute가 추가된 모든 파드에 대한 톨러레이션의 tolerationSeconds를 나타낸다.</td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>kubectl에 대한 도움말</td></tr><tr><td colspan=2>--insecure-skip-tls-verify</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>true인 경우, 서버 인증서의 유효성을 확인하지 않는다. 이렇게 하면 사용자의 HTTPS 연결이 안전하지 않게 된다.</td></tr><tr><td colspan=2>--kubeconfig string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>CLI 요청에 사용할 kubeconfig 파일의 경로이다.</td></tr><tr><td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: :0</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>로깅이 file:N에 도달했을 때 스택 트레이스를 내보낸다.</td></tr><tr><td colspan=2>--log-dir string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>비어 있지 않으면, 이 디렉터리에 로그 파일을 작성한다.</td></tr><tr><td colspan=2>--log-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>비어 있지 않으면, 이 로그 파일을 사용한다.</td></tr><tr><td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 1800</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>로그 파일이 커질 수 있는 최대 크기를 정의한다. 단위는 메가 바이트이다. 값이 0이면, 파일의 최대 크기는 무제한이다.</td></tr><tr><td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 5s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>로그를 비우는 간격의 최대 시간(초)</td></tr><tr><td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>파일 대신 표준 에러에 기록</td></tr><tr><td colspan=2>--match-server-version</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>클라이언트 버전과 일치하는 서버 버전 필요</td></tr><tr><td colspan=2>-n, --namespace string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>지정된 경우, 해당 네임스페이스가 CLI 요청의 범위가 됨</td></tr><tr><td colspan=2>--one-output</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>true이면, 로그를 기본 심각도 수준으로만 기록한다(그렇지 않으면 각각의 더 낮은 심각도 수준에도 기록함).</td></tr><tr><td colspan=2>--password string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>API 서버에 대한 기본 인증을 위한 비밀번호</td></tr><tr><td colspan=2>--profile string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: "none"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>캡처할 프로파일의 이름. (none|cpu|heap|goroutine|threadcreate|block|mutex) 중 하나</td></tr><tr><td colspan=2>--profile-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: "profile.pprof"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>프로파일을 쓸 파일의 이름</td></tr><tr><td colspan=2>--request-timeout string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: "0"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>단일 서버 요청을 포기하기 전에 대기하는 시간이다. 0이 아닌 값에는 해당 시간 단위(예: 1s, 2m, 3h)가 포함되어야 한다. 값이 0이면 요청 시간이 초과되지 않는다.</td></tr><tr><td colspan=2>-s, --server string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>쿠버네티스 API 서버의 주소와 포트</td></tr><tr><td colspan=2>--skip-headers</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>true이면, 로그 메시지에서 헤더 접두사를 사용하지 않는다.</td></tr><tr><td colspan=2>--skip-log-headers</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>true이면, 로그 파일을 열 때 헤더를 사용하지 않는다.</td></tr><tr><td colspan=2>--stderrthreshold severity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 2</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>이 임계값 이상의 로그는 표준 에러로 이동한다.</td></tr><tr><td colspan=2>--tls-server-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>서버 인증서 유효성 검사에 사용할 서버 이름. 제공되지 않으면, 서버에 접속하는 데 사용되는 호스트 이름이 사용된다.</td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>API 서버 인증을 위한 베어러(Bearer) 토큰</td></tr><tr><td colspan=2>--user string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>사용할 kubeconfig 사용자의 이름</td></tr><tr><td colspan=2>--username string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>API 서버에 대한 기본 인증을 위한 사용자 이름</td></tr><tr><td colspan=2>-v, --v Level</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>로그 수준의 자세한 정도를 나타내는 숫자</td></tr><tr><td colspan=2>--version version[=true]</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>버전 정보를 출력하고 종료</td></tr><tr><td colspan=2>--vmodule moduleSpec</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>파일 필터링 로깅을 위한 쉼표로 구분된 pattern=N 설정 목록</td></tr><tr><td colspan=2>--warnings-as-errors</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>서버에서 받은 경고를 오류로 처리하고 0이 아닌 종료 코드로 종료</td></tr></tbody></table><h2 id=환경-변수>환경 변수</h2><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>KUBECONFIG</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>kubectl 구성 ("kubeconfig") 파일 경로. 기본: "$HOME/.kube/config"</td></tr><tr><td colspan=2>KUBECTL_COMMAND_HEADERS</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>false로 설정하면, 호출된 kubectl 명령(쿠버네티스 버전 v1.22 이상)을 자세히 설명하는 추가 HTTP 헤더를 해제</td></tr></tbody></table><h2 id=더-보기>더 보기</h2><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands#annotate>kubectl annotate</a> - 리소스에 대한 어노테이션 업데이트</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-resources>kubectl api-resources</a> - 서버에서 지원되는 API 리소스 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-versions>kubectl api-versions</a> - "그룹/버전" 형식으로 서버에서 지원되는 API 버전을 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#apply>kubectl apply</a> - 파일명 또는 표준 입력으로 리소스에 구성 적용</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#attach>kubectl attach</a> - 실행 중인 컨테이너에 연결</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#auth>kubectl auth</a> - 권한 검사</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a> - 디플로이먼트(Deployment), 레플리카셋(ReplicaSet) 또는 레플리케이션컨트롤러(ReplicationController) 자동 스케일링</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#certificate>kubectl certificate</a> - 인증서 리소스 수정</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cluster-info>kubectl cluster-info</a> - 클러스터 정보 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#completion>kubectl completion</a> - 지정된 셸(bash 또는 zsh)에 대한 셸 완성 코드 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a> - kubeconfig 파일 수정</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cordon>kubectl cordon</a> - 노드를 unschedulable로 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cp>kubectl cp</a> - 컨테이너 간에 파일과 디렉터리 복사</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#create>kubectl create</a> - 파일 또는 표준 입력에서 리소스를 생성</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#debug>kubectl debug</a> - 워크로드와 노드의 문제 해결을 위한 디버깅 세션 생성</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#delete>kubectl delete</a> - 파일명, 표준 입력, 리소스 및 이름, 또는 리소스 및 레이블 셀렉터로 리소스 삭제</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#describe>kubectl describe</a> - 특정 리소스 또는 리소스 그룹의 세부 정보를 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#diff>kubectl diff</a> - 적용 예정 버전과 라이브 버전 비교</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#drain>kubectl drain</a> - 유지 보수 준비 중 노드 드레인</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#edit>kubectl edit</a> - 서버에서 리소스 편집</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#exec>kubectl exec</a> - 컨테이너에서 커맨드 실행</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#explain>kubectl explain</a> - 리소스의 문서</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#expose>kubectl expose</a> - 레플리케이션 컨트롤러, 서비스, 디플로이먼트 또는 파드를 가져와서 새로운 쿠버네티스 서비스로 노출</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#get>kubectl get</a> - 하나 이상의 리소스 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#kustomize>kubectl kustomize</a> - 디렉터리 또는 원격 URL에서 kustomization 대상을 빌드</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#label>kubectl label</a> - 리소스의 레이블 업데이트</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#logs>kubectl logs</a> - 파드의 컨테이너에 대한 로그 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#options>kubectl options</a> - 모든 커맨드에서 상속된 플래그 목록을 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#patch>kubectl patch</a> - 리소스 필드를 업데이트</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#plugin>kubectl plugin</a> - 플러그인과 상호 작용하기 위한 유틸리티를 제공</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#port-forward>kubectl port-forward</a> - 하나 이상의 로컬 포트를 파드로 전달</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#proxy>kubectl proxy</a> - 쿠버네티스 API 서버에 대한 프록시 실행</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#replace>kubectl replace</a> - 파일명 또는 표준 입력으로 리소스 교체</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#rollout>kubectl rollout</a> - 리소스 롤아웃 관리</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#run>kubectl run</a> - 클러스터에서 특정 이미지 실행</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#scale>kubectl scale</a> - 디플로이먼트, 레플리카셋 또는 레플리케이션 컨트롤러의 새 크기 설정</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#set>kubectl set</a> - 오브젝트에 특정 기능 설정</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a> - 하나 이상의 노드에서 테인트(taint) 업데이트</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#top>kubectl top</a> - 리소스(CPU/메모리/스토리지) 사용량을 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#uncordon>kubectl uncordon</a> - 노드를 schedulable로 표시</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#version>kubectl version</a> - 클라이언트 및 서버 버전 정보 출력</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#wait>kubectl wait</a> - 실험적(experimental) 기능: 하나 이상의 리소스에 대해서 특정 조건이 만족될 때까지 대기(wait)</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a938176c695852fe70362c29cf615f1c>9.3 - JSONPath 지원</h1><p>Kubectl은 JSONPath 템플릿을 지원한다.</p><p>JSONPath 템플릿은 중괄호 {}로 둘러싸인 JSONPath 표현식으로 구성된다.
Kubectl은 JSONPath 표현식을 사용하여 JSON 오브젝트의 특정 필드를 필터링하고 출력 형식을 지정한다.
원본 JSONPath 템플릿 구문 외에도 다음과 같은 기능과 구문이 유효하다.</p><ol><li>큰따옴표를 사용하여 JSONPath 표현식 내부의 텍스트를 인용한다.</li><li>목록을 반복하려면 <code>range</code>, <code>end</code> 오퍼레이터를 사용한다.</li><li>목록에서 뒤로 이동하려면 negative slice 인덱스를 사용한다. negative 인덱스는 목록을 "순환(wrap around)" 하지 않으며, <code>-index + listLength >= 0</code> 인 한 유효하다.</li></ol><div class="alert alert-info note callout" role=alert><strong>참고:</strong><ul><li><p>표현식은 항상 루트 오브젝트에서 시작하므로 <code>$</code> 오퍼레이터는 선택 사항이다.</p></li><li><p>결과 오브젝트는 String() 함수로 출력된다.</p></li></ul></div><p>JSON 입력 시 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;List&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;items&#34;</span>:[
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>},
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;4&#34;</span>},
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[{<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>}]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;8&#34;</span>},
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[
</span></span><span style=display:flex><span>          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
</span></span><span style=display:flex><span>          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;another&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.3&#34;</span>}
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;users&#34;</span>:[
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;myself&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {}
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;e2e&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {<span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;admin&#34;</span>, <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;secret&#34;</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><table><thead><tr><th>Function</th><th>Description</th><th>Example</th><th>Result</th></tr></thead><tbody><tr><td><code>text</code></td><td>일반 텍스트</td><td><code>kind is {.kind}</code></td><td><code>kind is List</code></td></tr><tr><td><code>@</code></td><td>현재 오브젝트</td><td><code>{@}</code></td><td>입력과 동일</td></tr><tr><td><code>.</code> or <code>[]</code></td><td>자식 오퍼레이터</td><td><code>{.kind}</code>, <code>{['kind']}</code> or <code>{['name\.type']}</code></td><td><code>List</code></td></tr><tr><td><code>..</code></td><td>재귀 하향(recursive descent)</td><td><code>{..name}</code></td><td><code>127.0.0.1 127.0.0.2 myself e2e</code></td></tr><tr><td><code>*</code></td><td>와일드 카드. 모든 오브젝트 가져오기</td><td><code>{.items[*].metadata.name}</code></td><td><code>[127.0.0.1 127.0.0.2]</code></td></tr><tr><td><code>[start:end:step]</code></td><td>아래 첨자 오퍼레이터</td><td><code>{.users[0].name}</code></td><td><code>myself</code></td></tr><tr><td><code>[,]</code></td><td>조합 오퍼레이터</td><td><code>{.items[*]['metadata.name', 'status.capacity']}</code></td><td><code>127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]</code></td></tr><tr><td><code>?()</code></td><td>필터</td><td><code>{.users[?(@.name=="e2e")].user.password}</code></td><td><code>secret</code></td></tr><tr><td><code>range</code>, <code>end</code></td><td>반복 목록</td><td><code>{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}</code></td><td><code>[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]</code></td></tr><tr><td><code>''</code></td><td>해석된 문자열 인용</td><td><code>{range .items[*]}{.metadata.name}{'\t'}{end}</code></td><td><code>127.0.0.1 127.0.0.2</code></td></tr></tbody></table><p><code>kubectl</code> 및 JSONPath 표현식을 사용하는 예는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -o json
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{@}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0]}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0].metadata.name}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*][&#39;metadata.name&#39;, &#39;status.capacity&#39;]}&#34;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{.metadata.name}{&#34;\t&#34;}{.status.startTime}{&#34;\n&#34;}{end}&#39;</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>윈도우에서 공백이 포함된 JSONPath 템플릿을 큰따옴표(위의 bash에 표시된 작은따옴표가 아님)로 묶어야 한다. 즉, 템플릿의 모든 문자 주변에 작은따옴표 또는 이스케이프된 큰따옴표를 사용해야 한다. 예를 들면, 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>kubectl get pods -o=jsonpath=<span style=color:#b44>&#34;{range .items[*]}{.metadata.name}{&#39;\t&#39;}{.status.startTime}{&#39;\n&#39;}{end}&#34;</span>
</span></span><span style=display:flex><span>kubectl get pods -o=jsonpath=<span style=color:#b44>&#34;{range .items[*]}{.metadata.name}{\&#34;</span>\t\<span style=color:#b44>&#34;}{.status.startTime}{\&#34;</span>\n\<span style=color:#b44>&#34;}{end}&#34;</span>
</span></span></code></pre></div></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong><p>JSONPath 정규식은 지원되지 않는다. 정규 표현식을 이용해 매치하려면 <code>jq</code>와 같은 도구를 사용하면 된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># kubectl은 JSONPath 출력에 대한 정규 표현식을 지원하지 않는다.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 다음 커맨드는 작동하지 않는다.</span>
</span></span><span style=display:flex><span>kubectl get pods -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[?(@.metadata.name=~/^test$/)].metadata.name}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 다음 커맨드는 원하는 결과를 얻는다.</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq -r <span style=color:#b44>&#39;.items[] | select(.metadata.name | test(&#34;test-&#34;)).spec.containers[].image&#39;</span>
</span></span></code></pre></div></div></div><div class=td-content style=page-break-before:always><h1 id=pg-8de6aceb8bf692c06cced446bac5bc92>9.4 - kubectl 사용 규칙</h1><p><code>kubectl</code>에 대한 권장 사용 규칙.</p><h2 id=재사용-가능한-스크립트에서-kubectl-사용>재사용 가능한 스크립트에서 <code>kubectl</code> 사용</h2><p>스크립트의 안정적인 출력을 위해서</p><ul><li><code>-o name</code>, <code>-o json</code>, <code>-o yaml</code>, <code>-o go-template</code> 혹은 <code>-o jsonpath</code>와 같은 머신 지향(machine-oriented) 출력 양식 중 하나를 요청한다.</li><li>예를 들어 <code>jobs.v1.batch/myjob</code>과 같이 전체 버전을 사용한다. 이를 통해 <code>kubectl</code>이 시간이 지남에 따라 변경될 수 있는 기본 버전을 사용하지 않도록 한다.</li><li>문맥, 설정 또는 기타 암묵적 상태에 의존하지 않는다.</li></ul><h2 id=subresources>서브리소스</h2><ul><li>kubectl의 <code>get</code>, <code>patch</code>, <code>edit</code> 및 <code>replace</code>와 같은 명령어에서
서브리소스를 지원하는 모든 리소스에 대해 <code>--subresource</code> 알파 플래그를 사용하여
서브리소스를 조회하고 업데이트할 수 있다. 현재, <code>status</code>와 <code>scale</code> 서브리소스만 지원된다.</li><li>서브리소스에 대한 API 계약은 전체 리소스와 동일하다.
<code>status</code> 서브리소스를 새 값으로 업데이트해도,
컨트롤러에서 서브리소스를 잠재적으로 다른 값으로 조정할 수 있다는 점을 염두에 두어야 한다.</li></ul><h2 id=모범-사례>모범 사례</h2><h3 id=kubectl-run><code>kubectl run</code></h3><p><code>kubectl run</code>으로 infrastructure as code를 충족시키기 위해서</p><ul><li>버전이 명시된 태그로 이미지를 태그하고 그 태그를 새로운 버전으로 이동하지 않는다. 예를 들어, <code>:latest</code>가 아닌 <code>:v1234</code>, <code>v1.2.3</code>, <code>r03062016-1-4</code>를 사용한다(자세한 정보는 <a href=/ko/docs/concepts/configuration/overview/#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%9D%B4%EB%AF%B8%EC%A7%80>구성 모범 사례</a>를 참고한다).</li><li>많은 파라미터가 적용된 이미지를 위한 스크립트를 작성한다.</li><li>필요하지만 <code>kubectl run</code> 플래그를 통해 표현할 수 없는 기능은 구성 파일을 소스 코드 버전 관리 시스템에 넣어서 전환한다.</li></ul><p><code>--dry-run</code> 플래그를 사용하여 실제로 제출하지 않고 클러스터로 보낼 오브젝트를 미리 볼 수 있다.</p><h3 id=kubectl-apply><code>kubectl apply</code></h3><ul><li><code>kubectl apply</code>를 사용해서 리소스를 생성하거나 업데이트 할 수 있다. kubectl apply를 사용하여 리소스를 업데이트하는 방법에 대한 자세한 정보는 <a href=https://kubectl.docs.kubernetes.io>Kubectl 책</a>을 참고한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a7abc09192597e614b58f8b552b682f5>9.5 - 도커 사용자를 위한 kubectl</h1><p>당신은 쿠버네티스 커맨드 라인 도구인 <code>kubectl</code>을 사용하여 API 서버와 상호 작용할 수 있다. 만약 도커 커맨드 라인 도구에 익숙하다면 <code>kubectl</code>을 사용하는 것은 간단하다. 다음 섹션에서는 도커의 하위 명령을 보여주고 <code>kubectl</code>과 같은 명령어를 설명한다.</p><h2 id=docker-run>docker run</h2><p>nginx 디플로이먼트(Deployment)를 실행하고 해당 디플로이먼트를 노출시키려면, <a href=/docs/reference/generated/kubectl/kubectl-commands#-em-deployment-em->kubectl create deployment</a>을 참고한다.
docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -d --restart<span style=color:#666>=</span>always -e <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster --name nginx-app -p 80:80 nginx
</span></span></code></pre></div><pre tabindex=0><code>55c103fa129692154a7652490236fee9be47d70a8dd562281ae7d2f9a339a6db
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   9 seconds ago       Up 9 seconds        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># nginx 실행하는 파드를 시작한다</span>
</span></span><span style=display:flex><span>kubectl create deployment --image<span style=color:#666>=</span>nginx nginx-app
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/nginx-app created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># nginx-app 에 env를 추가한다</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> env deployment/nginx-app  <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/nginx-app env updated
</code></pre><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>kubectl</code> 커맨드는 생성되거나 변경된 리소스의 유형과 이름을 출력하므로, 이를 후속 커맨드에 사용할 수 있다. 디플로이먼트가 생성된 후에는 새로운 서비스를 노출할 수 있다.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 서비스를 통해 포트를 노출</span>
</span></span><span style=display:flex><span>kubectl expose deployment nginx-app --port<span style=color:#666>=</span><span style=color:#666>80</span> --name<span style=color:#666>=</span>nginx-http
</span></span></code></pre></div><pre tabindex=0><code>service &#34;nginx-http&#34; exposed
</code></pre><p>kubectl을 사용하면, N개의 파드가 nginx를 실행하도록 <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>를 생성할 수 있다. 여기서 N은 스펙에 명시된 레플리카 수이며, 기본값은 1이다. 또한 파드의 레이블과 셀럭터를 사용하여 서비스를 생성할 수 있다. 자세한 내용은 <a href=/ko/docs/tasks/access-application-cluster/service-access-application-cluster>클러스터 내 애플리케이션에 접근하기 위해 서비스 사용하기</a>를 참고한다.</p><p>기본적으로 이미지는 <code>docker run -d ...</code> 와 비슷하게 백그라운드로 실행된다. 포그라운드로 실행하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#run><code>kubectl run</code></a>을 이용하여 파드를 생성한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run <span style=color:#666>[</span>-i<span style=color:#666>]</span> <span style=color:#666>[</span>--tty<span style=color:#666>]</span> --attach &lt;name&gt; --image<span style=color:#666>=</span>&lt;image&gt;
</span></span></code></pre></div><p><code>docker run ...</code> 과 달리 <code>--attach</code> 를 지정하면 <code>표준 입력(stdin)</code>, <code>표준 출력(stdout)</code> 및 <code>표준 오류(stderr)</code>가 붙는다. 연결된(attached) 스트림을 제어할 수 없다(<code>docker -a ...</code>).
해당 컨테이너에서 분리(detach)하려면 이스케이프 시퀀스(escape sequence) Ctrl+P를 입력한 다음 Ctrl+Q를 입력한다.</p><h2 id=docker-ps>docker ps</h2><p>현재 실행 중인 목록을 보기 위해서는 <a href=/docs/reference/generated/kubectl/kubectl-commands/#get>kubectl get</a>을 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps -a
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                NAMES
14636241935f        ubuntu:16.04        &#34;echo test&#34;              5 seconds ago        Exited (0) 5 seconds ago                        cocky_fermi
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   About a minute ago   Up About a minute          0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po
</span></span></code></pre></div><pre tabindex=0><code>NAME                        READY     STATUS      RESTARTS   AGE
nginx-app-8df569cb7-4gd89   1/1       Running     0          3m
ubuntu                      0/1       Completed   0          20s
</code></pre><h2 id=docker-attach>docker attach</h2><p>이미 실행 중인 컨테이너에 연결하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#attach>kubectl attach</a>를 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   5 minutes ago       Up 5 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker attach 55c103fa1296
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it nginx-app-5jyvm
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>컨테이너에서 분리하려면 이스케이프 시퀀스 Ctrl+P를 입력한 다음 Ctrl+Q를 입력한다.</p><h2 id=docker-exec>docker exec</h2><p>컨테이너에서 커맨드를 실행하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>를 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   6 minutes ago       Up 6 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker <span style=color:#a2f>exec</span> 55c103fa1296 cat /etc/hostname
</span></span></code></pre></div><pre tabindex=0><code>55c103fa1296
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po
</span></span></code></pre></div><pre tabindex=0><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> nginx-app-5jyvm -- cat /etc/hostname
</span></span></code></pre></div><pre tabindex=0><code>nginx-app-5jyvm
</code></pre><p>대화형 커맨드를 사용한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker <span style=color:#a2f>exec</span> -ti 55c103fa1296 /bin/sh
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># exit</span>
</span></span></code></pre></div><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -ti nginx-app-5jyvm -- /bin/sh
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># exit</span>
</span></span></code></pre></div><p>자세한 내용은 <a href=/ko/docs/tasks/debug/debug-application/get-shell-running-container/>실행 중인 컨테이너의 셸 얻기</a>를 참고한다.</p><h2 id=docker-logs>docker logs</h2><p>실행 중인 프로세스의 표준 입력(stdout)/표준 오류(stderr)를 수행하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#logs>kubectl logs</a>를 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker logs -f a9e
</span></span></code></pre></div><pre tabindex=0><code>192.168.9.1 - - [14/Jul/2015:01:04:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.35.0&#34; &#34;-&#34;
192.168.9.1 - - [14/Jul/2015:01:04:03 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.35.0&#34; &#34;-&#34;
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs -f nginx-app-zibvs
</span></span></code></pre></div><pre tabindex=0><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
</code></pre><p>파드와 컨테이너에는 근소한 차이가 있다. 기본적으로 파드는 프로세스가 종료되어도 종료되지 않는다. 대신 파드가 프로세스를 다시 시작한다. 이는 도커의 실행 옵션인 <code>--restart=always</code>와 유사하지만, 한 가지 큰 차이점이 있다. 도커에서는 프로세스의 각 호출에 대한 출력이 연결되지만, 쿠버네티스의 경우 각 호출은 별개다. 쿠버네티스에서 이전 실행의 출력 내용을 보려면 다음을 수행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs --previous nginx-app-zibvs
</span></span></code></pre></div><pre tabindex=0><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
</code></pre><p>자세한 정보는 <a href=/ko/docs/concepts/cluster-administration/logging/>로깅 아키텍처</a>를 참고한다.</p><h2 id=docker-stop-과-docker-rm>docker stop 과 docker rm</h2><p>실행 중인 프로세스를 중지하고 삭제하려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#delete>kubectl delete</a>을 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
a9ec34d98787        nginx               &#34;nginx -g &#39;daemon of&#34;  22 hours ago        Up 22 hours         0.0.0.0:80-&gt;80/tcp, 443/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker stop a9ec34d98787
</span></span></code></pre></div><pre tabindex=0><code>a9ec34d98787
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker rm a9ec34d98787
</span></span></code></pre></div><pre tabindex=0><code>a9ec34d98787
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment nginx-app
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
nginx-app    1/1     1            1           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
</span></span></code></pre></div><pre tabindex=0><code>NAME                         READY     STATUS    RESTARTS   AGE
nginx-app-2883164633-aklf7   1/1       Running   0          2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-app
</span></span></code></pre></div><pre tabindex=0><code>deployment &#34;nginx-app&#34; deleted
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 아무것도 반환하지 않는다</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> kubectl을 사용할 때는 파드를 직접 삭제하지 않는다. 먼저 파드를 소유한 디플로이먼트를 삭제해야 한다. 만약 파드를 직접 삭제하면 디플로이먼트가 파드를 재생성할 것이다.</div><h2 id=docker-login>docker login</h2><p>kubectl은 <code>docker login</code>와 직접적인 유사점은 없다. 프라이빗 레지스트리와 함께 쿠버네티스를 사용하려면 <a href=/ko/docs/concepts/containers/images/#%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B9%97-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%8A%B8%EB%A6%AC-%EC%82%AC%EC%9A%A9>프라이빗 레지스트리 사용</a>을 참고한다.</p><h2 id=docker-version>docker version</h2><p>클라이언트와 서버의 버전을 가져오려면 <a href=/docs/reference/generated/kubectl/kubectl-commands/#version>kubectl version</a>을 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker version
</span></span></code></pre></div><pre tabindex=0><code>Client version: 1.7.0
Client API version: 1.19
Go version (client): go1.4.2
Git commit (client): 0baf609
OS/Arch (client): linux/amd64
Server version: 1.7.0
Server API version: 1.19
Go version (server): go1.4.2
Git commit (server): 0baf609
OS/Arch (server): linux/amd64
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl version
</span></span></code></pre></div><pre tabindex=0><code>Client Version: version.Info{Major:&#34;1&#34;, Minor:&#34;6&#34;, GitVersion:&#34;v1.6.9+a3d1dfa6f4335&#34;, GitCommit:&#34;9b77fed11a9843ce3780f70dd251e92901c43072&#34;, GitTreeState:&#34;dirty&#34;, BuildDate:&#34;2017-08-29T20:32:58Z&#34;, OpenPaasKubernetesVersion:&#34;v1.03.02&#34;, GoVersion:&#34;go1.7.5&#34;, Compiler:&#34;gc&#34;, Platform:&#34;linux/amd64&#34;}
Server Version: version.Info{Major:&#34;1&#34;, Minor:&#34;6&#34;, GitVersion:&#34;v1.6.9+a3d1dfa6f4335&#34;, GitCommit:&#34;9b77fed11a9843ce3780f70dd251e92901c43072&#34;, GitTreeState:&#34;dirty&#34;, BuildDate:&#34;2017-08-29T20:32:58Z&#34;, OpenPaasKubernetesVersion:&#34;v1.03.02&#34;, GoVersion:&#34;go1.7.5&#34;, Compiler:&#34;gc&#34;, Platform:&#34;linux/amd64&#34;}
</code></pre><h2 id=docker-info>docker info</h2><p>환경 및 설정에 대한 자세한 정보는 <a href=/docs/reference/generated/kubectl/kubectl-commands/#cluster-info>kubectl cluster-info</a>를 참고한다.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker info
</span></span></code></pre></div><pre tabindex=0><code>Containers: 40
Images: 168
Storage Driver: aufs
 Root Dir: /usr/local/google/docker/aufs
 Backing Filesystem: extfs
 Dirs: 248
 Dirperm1 Supported: false
Execution Driver: native-0.2
Logging Driver: json-file
Kernel Version: 3.13.0-53-generic
Operating System: Ubuntu 14.04.2 LTS
CPUs: 12
Total Memory: 31.32 GiB
Name: k8s-is-fun.mtv.corp.google.com
ID: ADUV:GCYR:B3VJ:HMPO:LNPQ:KD5S:YKFQ:76VN:IANZ:7TFV:ZBF4:BYJO
WARNING: No swap limit support
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><pre tabindex=0><code>Kubernetes master is running at https://203.0.113.141
KubeDNS is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/kube-dns/proxy
kubernetes-dashboard is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy
Grafana is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
Heapster is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
InfluxDB is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-influxdb/proxy
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-54e562dd1441d0195970a6526b0055cc>10 - 컴포넌트 도구</h1></div><div class=td-content><h1 id=pg-ca5d01a42c486d535539d3038aa67eb9>10.1 - 기능 게이트</h1><p>이 페이지에는 관리자가 다른 쿠버네티스 컴포넌트에서 지정할 수 있는 다양한
기능 게이트에 대한 개요가 포함되어 있다.</p><p>기능의 단계(stage)에 대한 설명은 <a href=#%EA%B8%B0%EB%8A%A5-%EB%8B%A8%EA%B3%84>기능 단계</a>를 참고한다.</p><h2 id=개요>개요</h2><p>기능 게이트는 쿠버네티스 기능을 설명하는 일련의 키=값 쌍이다.
각 쿠버네티스 컴포넌트에서 <code>--feature-gates</code> 커맨드 라인 플래그를 사용하여
이러한 기능을 켜거나 끌 수 있다.</p><p>각 쿠버네티스 컴포넌트를 사용하면 해당 컴포넌트와 관련된 기능 게이트 집합을
활성화 또는 비활성화할 수 있다.
모든 컴포넌트에 대한 전체 기능 게이트 집합을 보려면 <code>-h</code> 플래그를 사용한다.
kubelet과 같은 컴포넌트의 기능 게이트를 설정하려면,
기능 쌍 목록에 지정된 <code>--feature-gates</code> 플래그를 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--feature-gates<span style=color:#666>=</span>...,GracefulNodeShutdown<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span></code></pre></div><p>다음 표는 다른 쿠버네티스 컴포넌트에서 설정할 수 있는 기능 게이트를
요약한 것이다.</p><ul><li>"도입" 열에는 기능이 소개되거나 릴리스 단계가 변경될 때의
쿠버네티스 릴리스가 포함된다.</li><li>"종료" 열이 비어 있지 않으면, 여전히 기능 게이트를 사용할 수 있는 마지막
쿠버네티스 릴리스가 포함된다.</li><li>기능이 알파 또는 베타 상태인 경우,
<a href=#%EC%95%8C%ED%8C%8C-%EB%98%90%EB%8A%94-%EB%B2%A0%ED%83%80-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B8%B0%EB%8A%A5-%EA%B2%8C%EC%9D%B4%ED%8A%B8>알파/베타 기능 게이트 테이블</a>에서 나열된 기능을 찾을 수 있다.</li><li>기능이 안정된 경우 해당 기능에 대한 모든 단계를
<a href=#%EC%8A%B9%EA%B8%89-%EB%98%90%EB%8A%94-%EC%82%AC%EC%9A%A9-%EC%A4%91%EB%8B%A8%EB%90%9C-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B8%B0%EB%8A%A5-%EA%B2%8C%EC%9D%B4%ED%8A%B8>승급(graduated)/사용 중단(deprecated) 기능 게이트 테이블</a>에 나열할 수 있다.</li><li><a href=#%EC%8A%B9%EA%B8%89-%EB%98%90%EB%8A%94-%EC%82%AC%EC%9A%A9-%EC%A4%91%EB%8B%A8%EB%90%9C-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B8%B0%EB%8A%A5-%EA%B2%8C%EC%9D%B4%ED%8A%B8>승급/사용 중단 기능 게이트 테이블</a>에는
사용 중단된 기능과 철회(withdrawn) 기능의 목록도 있다.</li></ul><h3 id=알파-또는-베타-기능을-위한-기능-게이트>알파 또는 베타 기능을 위한 기능 게이트</h3><table><caption style=display:none>알파 또는 베타 단계에 있는 기능을 위한 기능 게이트</caption><thead><tr><th>기능</th><th>디폴트</th><th>단계</th><th>도입</th><th>종료</th></tr></thead><tbody><tr><td><code>APIListChunking</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.8</td></tr><tr><td><code>APIListChunking</code></td><td><code>true</code></td><td>베타</td><td>1.9</td><td></td></tr><tr><td><code>APIPriorityAndFairness</code></td><td><code>false</code></td><td>알파</td><td>1.18</td><td>1.19</td></tr><tr><td><code>APIPriorityAndFairness</code></td><td><code>true</code></td><td>베타</td><td>1.20</td><td></td></tr><tr><td><code>APIResponseCompression</code></td><td><code>false</code></td><td>알파</td><td>1.7</td><td>1.15</td></tr><tr><td><code>APIResponseCompression</code></td><td><code>true</code></td><td>베타</td><td>1.16</td><td></td></tr><tr><td><code>APIServerIdentity</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td></td></tr><tr><td><code>APIServerTracing</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td></td></tr><tr><td><code>AllowInsecureBackendProxy</code></td><td><code>true</code></td><td>베타</td><td>1.17</td><td></td></tr><tr><td><code>AnyVolumeDataSource</code></td><td><code>false</code></td><td>알파</td><td>1.18</td><td>1.23</td></tr><tr><td><code>AnyVolumeDataSource</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>AppArmor</code></td><td><code>true</code></td><td>베타</td><td>1.4</td><td></td></tr><tr><td><code>ContainerCheckpoint</code></td><td><code>false</code></td><td>알파</td><td>1.25</td><td></td></tr><tr><td><code>CPUManager</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.9</td></tr><tr><td><code>CPUManager</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td></td></tr><tr><td><code>CPUManagerPolicyAlphaOptions</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td></td></tr><tr><td><code>CPUManagerPolicyBetaOptions</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td></td></tr><tr><td><code>CPUManagerPolicyOptions</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td>1.22</td></tr><tr><td><code>CPUManagerPolicyOptions</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td></td></tr><tr><td><code>CSIMigrationAzureFile</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td>1.20</td></tr><tr><td><code>CSIMigrationAzureFile</code></td><td><code>false</code></td><td>베타</td><td>1.21</td><td>1.23</td></tr><tr><td><code>CSIMigrationAzureFile</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>CSIMigrationPortworx</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td>1.24</td></tr><tr><td><code>CSIMigrationPortworx</code></td><td><code>false</code></td><td>베타</td><td>1.25</td><td></td></tr><tr><td><code>CSIMigrationRBD</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td></td></tr><tr><td><code>CSIMigrationvSphere</code></td><td><code>false</code></td><td>알팝</td><td>1.18</td><td>1.18</td></tr><tr><td><code>CSIMigrationvSphere</code></td><td><code>false</code></td><td>베타</td><td>1.19</td><td>1.24</td></tr><tr><td><code>CSIMigrationvSphere</code></td><td><code>true</code></td><td>베타</td><td>1.25</td><td></td></tr><tr><td><code>CSINodeExpandSecret</code></td><td><code>false</code></td><td>알파</td><td>1.25</td><td></td></tr><tr><td><code>CSIVolumeHealth</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td></td></tr><tr><td><code>ContextualLogging</code></td><td><code>false</code></td><td>알파</td><td>1.24</td><td></td></tr><tr><td><code>CustomCPUCFSQuotaPeriod</code></td><td><code>false</code></td><td>알파</td><td>1.12</td><td></td></tr><tr><td><code>CustomResourceValidationExpressions</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td>1.24</td></tr><tr><td><code>CustomResourceValidationExpressions</code></td><td><code>true</code></td><td>베타</td><td>1.25</td><td></td></tr><tr><td><code>DelegateFSGroupToCSIDriver</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td>1.22</td></tr><tr><td><code>DelegateFSGroupToCSIDriver</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td></td></tr><tr><td><code>DevicePlugins</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.9</td></tr><tr><td><code>DevicePlugins</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td></td></tr><tr><td><code>DisableAcceleratorUsageMetrics</code></td><td><code>false</code></td><td>알파</td><td>1.19</td><td>1.19</td></tr><tr><td><code>DisableAcceleratorUsageMetrics</code></td><td><code>true</code></td><td>베타</td><td>1.20</td><td></td></tr><tr><td><code>DisableCloudProviders</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td></td></tr><tr><td><code>DisableKubeletCloudCredentialProviders</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td></td></tr><tr><td><code>DownwardAPIHugePages</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td>1.20</td></tr><tr><td><code>DownwardAPIHugePages</code></td><td><code>false</code></td><td>베타</td><td>1.21</td><td>1.21</td></tr><tr><td><code>DownwardAPIHugePages</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td></td></tr><tr><td><code>EndpointSliceTerminatingCondition</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td>1.21</td></tr><tr><td><code>EndpointSliceTerminatingCondition</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td></td></tr><tr><td><code>ExpandedDNSConfig</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td></td></tr><tr><td><code>ExperimentalHostUserNamespaceDefaulting</code></td><td><code>false</code></td><td>베타</td><td>1.5</td><td></td></tr><tr><td><code>GracefulNodeShutdown</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td>1.20</td></tr><tr><td><code>GracefulNodeShutdown</code></td><td><code>true</code></td><td>베타</td><td>1.21</td><td></td></tr><tr><td><code>GracefulNodeShutdownBasedOnPodPriority</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td>1.23</td></tr><tr><td><code>GracefulNodeShutdownBasedOnPodPriority</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>GRPCContainerProbe</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td>1.23</td></tr><tr><td><code>GRPCContainerProbe</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>HonorPVReclaimPolicy</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td></td></tr><tr><td><code>HPAContainerMetrics</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td></td></tr><tr><td><code>HPAScaleToZero</code></td><td><code>false</code></td><td>알파</td><td>1.16</td><td></td></tr><tr><td><code>InTreePluginAWSUnregister</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td></td></tr><tr><td><code>InTreePluginAzureDiskUnregister</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td></td></tr><tr><td><code>InTreePluginAzureFileUnregister</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td></td></tr><tr><td><code>InTreePluginGCEUnregister</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td></td></tr><tr><td><code>InTreePluginOpenStackUnregister</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td></td></tr><tr><td><code>InTreePluginPortworxUnregister</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td></td></tr><tr><td><code>InTreePluginRBDUnregister</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td></td></tr><tr><td><code>InTreePluginvSphereUnregister</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td></td></tr><tr><td><code>JobMutableNodeSchedulingDirectives</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td></td></tr><tr><td><code>JobReadyPods</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td>1.23</td></tr><tr><td><code>JobReadyPods</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>JobTrackingWithFinalizers</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td>1.22</td></tr><tr><td><code>JobTrackingWithFinalizers</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td>1.23</td></tr><tr><td><code>JobTrackingWithFinalizers</code></td><td><code>false</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>KubeletCredentialProviders</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td>1.23</td></tr><tr><td><code>KubeletCredentialProviders</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>KubeletInUserNamespace</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td></td></tr><tr><td><code>KubeletPodResources</code></td><td><code>false</code></td><td>알파</td><td>1.13</td><td>1.14</td></tr><tr><td><code>KubeletPodResources</code></td><td><code>true</code></td><td>베타</td><td>1.15</td><td></td></tr><tr><td><code>KubeletPodResourcesGetAllocatable</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.22</td></tr><tr><td><code>KubeletPodResourcesGetAllocatable</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td></td></tr><tr><td><code>KubeletTracing</code></td><td><code>false</code></td><td>알파</td><td>1.25</td><td></td></tr><tr><td><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td></td></tr><tr><td><code>LogarithmicScaleDown</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>LogarithmicScaleDown</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td></td></tr><tr><td><code>MatchLabelKeysInPodTopologySpread</code></td><td><code>false</code></td><td>알파</td><td>1.25</td><td></td></tr><tr><td><code>MaxUnavailableStatefulSet</code></td><td><code>false</code></td><td>알파</td><td>1.24</td><td></td></tr><tr><td><code>MemoryManager</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>MemoryManager</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td></td></tr><tr><td><code>MemoryQoS</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td></td></tr><tr><td><code>MinDomainsInPodTopologySpread</code></td><td><code>false</code></td><td>알파</td><td>1.24</td><td>1.24</td></tr><tr><td><code>MinDomainsInPodTopologySpread</code></td><td><code>true</code></td><td>베타</td><td>1.25</td><td></td></tr><tr><td><code>MixedProtocolLBService</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td>1.23</td></tr><tr><td><code>MixedProtocolLBService</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>NetworkPolicyStatus</code></td><td><code>false</code></td><td>알파</td><td>1.24</td><td></td></tr><tr><td><code>NodeInclusionPolicyInPodTopologySpread</code></td><td><code>false</code></td><td>알파</td><td>1.25</td><td></td></tr><tr><td><code>NodeSwap</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td></td></tr><tr><td><code>NodeOutOfServiceVolumeDetach</code></td><td><code>false</code></td><td>알파</td><td>1.24</td><td></td></tr><tr><td><code>OpenAPIEnums</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td>1.23</td></tr><tr><td><code>OpenAPIEnums</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>OpenAPIV3</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td>1.23</td></tr><tr><td><code>OpenAPIV3</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>PodAndContainerStatsFromCRI</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td></td></tr><tr><td><code>PodDeletionCost</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>PodDeletionCost</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td></td></tr><tr><td><code>PodHasNetworkCondition</code></td><td><code>false</code></td><td>알파</td><td>1.25</td><td></td></tr><tr><td><code>PodSecurity</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td>1.22</td></tr><tr><td><code>PodSecurity</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td></td></tr><tr><td><code>ProbeTerminationGracePeriod</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>ProbeTerminationGracePeriod</code></td><td><code>false</code></td><td>베타</td><td>1.22</td><td>1.24</td></tr><tr><td><code>ProbeTerminationGracePeriod</code></td><td><code>true</code></td><td>베타</td><td>1.25</td><td></td></tr><tr><td><code>ProcMountType</code></td><td><code>false</code></td><td>알파</td><td>1.12</td><td></td></tr><tr><td><code>ProxyTerminatingEndpoints</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td></td></tr><tr><td><code>QOSReserved</code></td><td><code>false</code></td><td>알파</td><td>1.11</td><td></td></tr><tr><td><code>ReadWriteOncePod</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td></td></tr><tr><td><code>RecoverVolumeExpansionFailure</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td></td></tr><tr><td><code>RemainingItemCount</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td>1.15</td></tr><tr><td><code>RemainingItemCount</code></td><td><code>true</code></td><td>베타</td><td>1.16</td><td></td></tr><tr><td><code>RotateKubeletServerCertificate</code></td><td><code>false</code></td><td>알파</td><td>1.7</td><td>1.11</td></tr><tr><td><code>RotateKubeletServerCertificate</code></td><td><code>true</code></td><td>베타</td><td>1.12</td><td></td></tr><tr><td><code>SeccompDefault</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td>1.24</td></tr><tr><td><code>SeccompDefault</code></td><td><code>true</code></td><td>베타</td><td>1.25</td><td></td></tr><tr><td><code>ServerSideFieldValidation</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td>1.24</td></tr><tr><td><code>ServerSideFieldValidation</code></td><td><code>true</code></td><td>베타</td><td>1.25</td><td></td></tr><tr><td><code>ServiceInternalTrafficPolicy</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>ServiceInternalTrafficPolicy</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td></td></tr><tr><td><code>ServiceIPStaticSubrange</code></td><td><code>false</code></td><td>알파</td><td>1.24</td><td>1.24</td></tr><tr><td><code>ServiceIPStaticSubrange</code></td><td><code>true</code></td><td>베타</td><td>1.25</td><td></td></tr><tr><td><code>SizeMemoryBackedVolumes</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td>1.21</td></tr><tr><td><code>SizeMemoryBackedVolumes</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td></td></tr><tr><td><code>StatefulSetAutoDeletePVC</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td></td></tr><tr><td><code>StorageVersionAPI</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td></td></tr><tr><td><code>StorageVersionHash</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.14</td></tr><tr><td><code>StorageVersionHash</code></td><td><code>true</code></td><td>베타</td><td>1.15</td><td></td></tr><tr><td><code>TopologyAwareHints</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.22</td></tr><tr><td><code>TopologyAwareHints</code></td><td><code>false</code></td><td>베타</td><td>1.23</td><td>1.23</td></tr><tr><td><code>TopologyAwareHints</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>TopologyManager</code></td><td><code>false</code></td><td>알파</td><td>1.16</td><td>1.17</td></tr><tr><td><code>TopologyManager</code></td><td><code>true</code></td><td>베타</td><td>1.18</td><td></td></tr><tr><td><code>VolumeCapacityPriority</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>-</td></tr><tr><td><code>WinDSR</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td></td></tr><tr><td><code>WinOverlay</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.19</td></tr><tr><td><code>WinOverlay</code></td><td><code>true</code></td><td>베타</td><td>1.20</td><td></td></tr><tr><td><code>WindowsHostProcessContainers</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td>1.22</td></tr><tr><td><code>WindowsHostProcessContainers</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td></td></tr></tbody></table><h3 id=승급-또는-사용-중단된-기능을-위한-기능-게이트>승급 또는 사용 중단된 기능을 위한 기능 게이트</h3><table><caption style=display:none>승급 또는 사용 중단 기능을 위한 기능 게이트</caption><thead><tr><th>기능</th><th>디폴트</th><th>단계</th><th>도입</th><th>종료</th></tr></thead><tbody><tr><td><code>Accelerators</code></td><td><code>false</code></td><td>알파</td><td>1.6</td><td>1.10</td></tr><tr><td><code>Accelerators</code></td><td>-</td><td>사용 중단</td><td>1.11</td><td>-</td></tr><tr><td><code>AdvancedAuditing</code></td><td><code>false</code></td><td>알파</td><td>1.7</td><td>1.7</td></tr><tr><td><code>AdvancedAuditing</code></td><td><code>true</code></td><td>베타</td><td>1.8</td><td>1.11</td></tr><tr><td><code>AdvancedAuditing</code></td><td><code>true</code></td><td>GA</td><td>1.12</td><td>-</td></tr><tr><td><code>AffinityInAnnotations</code></td><td><code>false</code></td><td>알파</td><td>1.6</td><td>1.7</td></tr><tr><td><code>AffinityInAnnotations</code></td><td>-</td><td>사용 중단</td><td>1.8</td><td>-</td></tr><tr><td><code>AllowExtTrafficLocalEndpoints</code></td><td><code>false</code></td><td>베타</td><td>1.4</td><td>1.6</td></tr><tr><td><code>AllowExtTrafficLocalEndpoints</code></td><td><code>true</code></td><td>GA</td><td>1.7</td><td>-</td></tr><tr><td><code>AttachVolumeLimit</code></td><td><code>false</code></td><td>알파</td><td>1.11</td><td>1.11</td></tr><tr><td><code>AttachVolumeLimit</code></td><td><code>true</code></td><td>베타</td><td>1.12</td><td>1.16</td></tr><tr><td><code>AttachVolumeLimit</code></td><td><code>true</code></td><td>GA</td><td>1.17</td><td>-</td></tr><tr><td><code>BalanceAttachedNodeVolumes</code></td><td><code>false</code></td><td>알파</td><td>1.11</td><td>1.21</td></tr><tr><td><code>BalanceAttachedNodeVolumes</code></td><td><code>false</code></td><td>사용 중단</td><td>1.22</td><td></td></tr><tr><td><code>BlockVolume</code></td><td><code>false</code></td><td>알파</td><td>1.9</td><td>1.12</td></tr><tr><td><code>BlockVolume</code></td><td><code>true</code></td><td>베타</td><td>1.13</td><td>1.17</td></tr><tr><td><code>BlockVolume</code></td><td><code>true</code></td><td>GA</td><td>1.18</td><td>-</td></tr><tr><td><code>BoundServiceAccountTokenVolume</code></td><td><code>false</code></td><td>알파</td><td>1.13</td><td>1.20</td></tr><tr><td><code>BoundServiceAccountTokenVolume</code></td><td><code>true</code></td><td>베타</td><td>1.21</td><td>1.21</td></tr><tr><td><code>BoundServiceAccountTokenVolume</code></td><td><code>true</code></td><td>GA</td><td>1.22</td><td>-</td></tr><tr><td><code>ConfigurableFSGroupPolicy</code></td><td><code>false</code></td><td>알파</td><td>1.18</td><td>1.19</td></tr><tr><td><code>ConfigurableFSGroupPolicy</code></td><td><code>true</code></td><td>베타</td><td>1.20</td><td>1.22</td></tr><tr><td><code>ConfigurableFSGroupPolicy</code></td><td><code>true</code></td><td>GA</td><td>1.23</td><td>-</td></tr><tr><td><code>ControllerManagerLeaderMigration</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>ControllerManagerLeaderMigration</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td>1.23</td></tr><tr><td><code>ControllerManagerLeaderMigration</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>CRIContainerLogRotation</code></td><td><code>false</code></td><td>알파</td><td>1.10</td><td>1.10</td></tr><tr><td><code>CRIContainerLogRotation</code></td><td><code>true</code></td><td>베타</td><td>1.11</td><td>1.20</td></tr><tr><td><code>CRIContainerLogRotation</code></td><td><code>true</code></td><td>GA</td><td>1.21</td><td>-</td></tr><tr><td><code>CSIBlockVolume</code></td><td><code>false</code></td><td>알파</td><td>1.11</td><td>1.13</td></tr><tr><td><code>CSIBlockVolume</code></td><td><code>true</code></td><td>베타</td><td>1.14</td><td>1.17</td></tr><tr><td><code>CSIBlockVolume</code></td><td><code>true</code></td><td>GA</td><td>1.18</td><td>-</td></tr><tr><td><code>CSIDriverRegistry</code></td><td><code>false</code></td><td>알파</td><td>1.12</td><td>1.13</td></tr><tr><td><code>CSIDriverRegistry</code></td><td><code>true</code></td><td>베타</td><td>1.14</td><td>1.17</td></tr><tr><td><code>CSIDriverRegistry</code></td><td><code>true</code></td><td>GA</td><td>1.18</td><td>-</td></tr><tr><td><code>CSIInlineVolume</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td>1.15</td></tr><tr><td><code>CSIInlineVolume</code></td><td><code>true</code></td><td>베타</td><td>1.16</td><td>1.24</td></tr><tr><td><code>CSIInlineVolume</code></td><td><code>true</code></td><td>GA</td><td>1.25</td><td>-</td></tr><tr><td><code>CSIMigration</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.16</td></tr><tr><td><code>CSIMigration</code></td><td><code>true</code></td><td>베타</td><td>1.17</td><td>1.24</td></tr><tr><td><code>CSIMigration</code></td><td><code>true</code></td><td>GA</td><td>1.25</td><td>-</td></tr><tr><td><code>CSIMigrationAWS</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.16</td></tr><tr><td><code>CSIMigrationAWS</code></td><td><code>false</code></td><td>베타</td><td>1.17</td><td>1.22</td></tr><tr><td><code>CSIMigrationAWS</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td>1.24</td></tr><tr><td><code>CSIMigrationAWS</code></td><td><code>true</code></td><td>GA</td><td>1.25</td><td>-</td></tr><tr><td><code>CSIMigrationAWSComplete</code></td><td><code>false</code></td><td>알파</td><td>1.17</td><td>1.20</td></tr><tr><td><code>CSIMigrationAWSComplete</code></td><td>-</td><td>사용 중단</td><td>1.21</td><td>-</td></tr><tr><td><code>CSIMigrationAzureDisk</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td>1.18</td></tr><tr><td><code>CSIMigrationAzureDisk</code></td><td><code>false</code></td><td>베타</td><td>1.19</td><td>1.22</td></tr><tr><td><code>CSIMigrationAzureDisk</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td>1.23</td></tr><tr><td><code>CSIMigrationAzureDisk</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td></td></tr><tr><td><code>CSIMigrationAzureDiskComplete</code></td><td><code>false</code></td><td>알파</td><td>1.17</td><td>1.20</td></tr><tr><td><code>CSIMigrationAzureDiskComplete</code></td><td>-</td><td>사용 중단</td><td>1.21</td><td>-</td></tr><tr><td><code>CSIMigrationAzureFileComplete</code></td><td><code>false</code></td><td>알파</td><td>1.17</td><td>1.20</td></tr><tr><td><code>CSIMigrationAzureFileComplete</code></td><td>-</td><td>사용 중단</td><td>1.21</td><td>-</td></tr><tr><td><code>CSIMigrationGCE</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.16</td></tr><tr><td><code>CSIMigrationGCE</code></td><td><code>false</code></td><td>베타</td><td>1.17</td><td>1.22</td></tr><tr><td><code>CSIMigrationGCE</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td>1.24</td></tr><tr><td><code>CSIMigrationGCE</code></td><td><code>true</code></td><td>GA</td><td>1.25</td><td>-</td></tr><tr><td><code>CSIMigrationGCEComplete</code></td><td><code>false</code></td><td>알파</td><td>1.17</td><td>1.20</td></tr><tr><td><code>CSIMigrationGCEComplete</code></td><td>-</td><td>사용 중단</td><td>1.21</td><td>-</td></tr><tr><td><code>CSIMigrationOpenStack</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.17</td></tr><tr><td><code>CSIMigrationOpenStack</code></td><td><code>true</code></td><td>베타</td><td>1.18</td><td>1.23</td></tr><tr><td><code>CSIMigrationOpenStack</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td></td></tr><tr><td><code>CSIMigrationOpenStackComplete</code></td><td><code>false</code></td><td>알파</td><td>1.17</td><td>1.20</td></tr><tr><td><code>CSIMigrationOpenStackComplete</code></td><td>-</td><td>사용 중단</td><td>1.21</td><td>-</td></tr><tr><td><code>CSIMigrationvSphereComplete</code></td><td><code>false</code></td><td>베타</td><td>1.19</td><td>1.21</td></tr><tr><td><code>CSIMigrationvSphereComplete</code></td><td>-</td><td>사용 중단</td><td>1.22</td><td>-</td></tr><tr><td><code>CSINodeInfo</code></td><td><code>false</code></td><td>알파</td><td>1.12</td><td>1.13</td></tr><tr><td><code>CSINodeInfo</code></td><td><code>true</code></td><td>베타</td><td>1.14</td><td>1.16</td></tr><tr><td><code>CSINodeInfo</code></td><td><code>true</code></td><td>GA</td><td>1.17</td><td>-</td></tr><tr><td><code>CSIPersistentVolume</code></td><td><code>false</code></td><td>알파</td><td>1.9</td><td>1.9</td></tr><tr><td><code>CSIPersistentVolume</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td>1.12</td></tr><tr><td><code>CSIPersistentVolume</code></td><td><code>true</code></td><td>GA</td><td>1.13</td><td>-</td></tr><tr><td><code>CSIServiceAccountToken</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td>1.20</td></tr><tr><td><code>CSIServiceAccountToken</code></td><td><code>true</code></td><td>베타</td><td>1.21</td><td>1.21</td></tr><tr><td><code>CSIServiceAccountToken</code></td><td><code>true</code></td><td>GA</td><td>1.22</td><td>-</td></tr><tr><td><code>CSIStorageCapacity</code></td><td><code>false</code></td><td>알파</td><td>1.19</td><td>1.20</td></tr><tr><td><code>CSIStorageCapacity</code></td><td><code>true</code></td><td>베타</td><td>1.21</td><td>1.23</td></tr><tr><td><code>CSIStorageCapacity</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>CSIVolumeFSGroupPolicy</code></td><td><code>false</code></td><td>알파</td><td>1.19</td><td>1.19</td></tr><tr><td><code>CSIVolumeFSGroupPolicy</code></td><td><code>true</code></td><td>베타</td><td>1.20</td><td>1.22</td></tr><tr><td><code>CSIVolumeFSGroupPolicy</code></td><td><code>true</code></td><td>GA</td><td>1.23</td><td></td></tr><tr><td><code>CSRDuration</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td>1.23</td></tr><tr><td><code>CSRDuration</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>CronJobControllerV2</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td>1.20</td></tr><tr><td><code>CronJobControllerV2</code></td><td><code>true</code></td><td>베타</td><td>1.21</td><td>1.21</td></tr><tr><td><code>CronJobControllerV2</code></td><td><code>true</code></td><td>GA</td><td>1.22</td><td>-</td></tr><tr><td><code>CronJobTimeZone</code></td><td><code>false</code></td><td>알파</td><td>1.24</td><td>1.24</td></tr><tr><td><code>CronJobTimeZone</code></td><td><code>true</code></td><td>베타</td><td>1.25</td><td></td></tr><tr><td><code>CustomPodDNS</code></td><td><code>false</code></td><td>알파</td><td>1.9</td><td>1.9</td></tr><tr><td><code>CustomPodDNS</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td>1.13</td></tr><tr><td><code>CustomPodDNS</code></td><td><code>true</code></td><td>GA</td><td>1.14</td><td>-</td></tr><tr><td><code>CustomResourceDefaulting</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td>1.15</td></tr><tr><td><code>CustomResourceDefaulting</code></td><td><code>true</code></td><td>베타</td><td>1.16</td><td>1.16</td></tr><tr><td><code>CustomResourceDefaulting</code></td><td><code>true</code></td><td>GA</td><td>1.17</td><td>-</td></tr><tr><td><code>CustomResourcePublishOpenAPI</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.14</td></tr><tr><td><code>CustomResourcePublishOpenAPI</code></td><td><code>true</code></td><td>베타</td><td>1.15</td><td>1.15</td></tr><tr><td><code>CustomResourcePublishOpenAPI</code></td><td><code>true</code></td><td>GA</td><td>1.16</td><td>-</td></tr><tr><td><code>CustomResourceSubresources</code></td><td><code>false</code></td><td>알파</td><td>1.10</td><td>1.10</td></tr><tr><td><code>CustomResourceSubresources</code></td><td><code>true</code></td><td>베타</td><td>1.11</td><td>1.15</td></tr><tr><td><code>CustomResourceSubresources</code></td><td><code>true</code></td><td>GA</td><td>1.16</td><td>-</td></tr><tr><td><code>CustomResourceValidation</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.8</td></tr><tr><td><code>CustomResourceValidation</code></td><td><code>true</code></td><td>베타</td><td>1.9</td><td>1.15</td></tr><tr><td><code>CustomResourceValidation</code></td><td><code>true</code></td><td>GA</td><td>1.16</td><td>-</td></tr><tr><td><code>CustomResourceWebhookConversion</code></td><td><code>false</code></td><td>알파</td><td>1.13</td><td>1.14</td></tr><tr><td><code>CustomResourceWebhookConversion</code></td><td><code>true</code></td><td>베타</td><td>1.15</td><td>1.15</td></tr><tr><td><code>CustomResourceWebhookConversion</code></td><td><code>true</code></td><td>GA</td><td>1.16</td><td>-</td></tr><tr><td><code>DaemonSetUpdateSurge</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>DaemonSetUpdateSurge</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td>1.24</td></tr><tr><td><code>DaemonSetUpdateSurge</code></td><td><code>true</code></td><td>GA</td><td>1.25</td><td>-</td></tr><tr><td><code>DefaultPodTopologySpread</code></td><td><code>false</code></td><td>알파</td><td>1.19</td><td>1.19</td></tr><tr><td><code>DefaultPodTopologySpread</code></td><td><code>true</code></td><td>베타</td><td>1.20</td><td>1.23</td></tr><tr><td><code>DefaultPodTopologySpread</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>DryRun</code></td><td><code>false</code></td><td>알파</td><td>1.12</td><td>1.12</td></tr><tr><td><code>DryRun</code></td><td><code>true</code></td><td>베타</td><td>1.13</td><td>1.18</td></tr><tr><td><code>DryRun</code></td><td><code>true</code></td><td>GA</td><td>1.19</td><td>-</td></tr><tr><td><code>DynamicAuditing</code></td><td><code>false</code></td><td>알파</td><td>1.13</td><td>1.18</td></tr><tr><td><code>DynamicAuditing</code></td><td>-</td><td>사용 중단</td><td>1.19</td><td>-</td></tr><tr><td><code>DynamicKubeletConfig</code></td><td><code>false</code></td><td>알파</td><td>1.4</td><td>1.10</td></tr><tr><td><code>DynamicKubeletConfig</code></td><td><code>true</code></td><td>베타</td><td>1.11</td><td>1.21</td></tr><tr><td><code>DynamicKubeletConfig</code></td><td><code>false</code></td><td>사용 중단</td><td>1.22</td><td>-</td></tr><tr><td><code>DynamicProvisioningScheduling</code></td><td><code>false</code></td><td>알파</td><td>1.11</td><td>1.11</td></tr><tr><td><code>DynamicProvisioningScheduling</code></td><td>-</td><td>사용 중단</td><td>1.12</td><td>-</td></tr><tr><td><code>DynamicVolumeProvisioning</code></td><td><code>true</code></td><td>알파</td><td>1.3</td><td>1.7</td></tr><tr><td><code>DynamicVolumeProvisioning</code></td><td><code>true</code></td><td>GA</td><td>1.8</td><td>-</td></tr><tr><td><code>EfficientWatchResumption</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td>1.20</td></tr><tr><td><code>EfficientWatchResumption</code></td><td><code>true</code></td><td>베타</td><td>1.21</td><td>1.23</td></tr><tr><td><code>EfficientWatchResumption</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>EnableAggregatedDiscoveryTimeout</code></td><td><code>true</code></td><td>사용 중단</td><td>1.16</td><td>-</td></tr><tr><td><code>EnableEquivalenceClassCache</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.14</td></tr><tr><td><code>EnableEquivalenceClassCache</code></td><td>-</td><td>사용 중단</td><td>1.15</td><td>-</td></tr><tr><td><code>EndpointSlice</code></td><td><code>false</code></td><td>알파</td><td>1.16</td><td>1.16</td></tr><tr><td><code>EndpointSlice</code></td><td><code>false</code></td><td>베타</td><td>1.17</td><td>1.17</td></tr><tr><td><code>EndpointSlice</code></td><td><code>true</code></td><td>베타</td><td>1.18</td><td>1.20</td></tr><tr><td><code>EndpointSlice</code></td><td><code>true</code></td><td>GA</td><td>1.21</td><td>-</td></tr><tr><td><code>EndpointSliceNodeName</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td>1.20</td></tr><tr><td><code>EndpointSliceNodeName</code></td><td><code>true</code></td><td>GA</td><td>1.21</td><td>-</td></tr><tr><td><code>EndpointSliceProxying</code></td><td><code>false</code></td><td>알파</td><td>1.18</td><td>1.18</td></tr><tr><td><code>EndpointSliceProxying</code></td><td><code>true</code></td><td>베타</td><td>1.19</td><td>1.21</td></tr><tr><td><code>EndpointSliceProxying</code></td><td><code>true</code></td><td>GA</td><td>1.22</td><td>-</td></tr><tr><td><code>EphemeralContainers</code></td><td><code>false</code></td><td>알파</td><td>1.16</td><td>1.22</td></tr><tr><td><code>EphemeralContainers</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td>1.24</td></tr><tr><td><code>EphemeralContainers</code></td><td><code>true</code></td><td>GA</td><td>1.25</td><td>-</td></tr><tr><td><code>EvenPodsSpread</code></td><td><code>false</code></td><td>알파</td><td>1.16</td><td>1.17</td></tr><tr><td><code>EvenPodsSpread</code></td><td><code>true</code></td><td>베타</td><td>1.18</td><td>1.18</td></tr><tr><td><code>EvenPodsSpread</code></td><td><code>true</code></td><td>GA</td><td>1.19</td><td>-</td></tr><tr><td><code>ExecProbeTimeout</code></td><td><code>true</code></td><td>GA</td><td>1.20</td><td>-</td></tr><tr><td><code>ExpandCSIVolumes</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.15</td></tr><tr><td><code>ExpandCSIVolumes</code></td><td><code>true</code></td><td>베타</td><td>1.16</td><td>1.23</td></tr><tr><td><code>ExpandCSIVolumes</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>ExpandInUsePersistentVolumes</code></td><td><code>false</code></td><td>알파</td><td>1.11</td><td>1.14</td></tr><tr><td><code>ExpandInUsePersistentVolumes</code></td><td><code>true</code></td><td>베타</td><td>1.15</td><td>1.23</td></tr><tr><td><code>ExpandInUsePersistentVolumes</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>ExpandPersistentVolumes</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.10</td></tr><tr><td><code>ExpandPersistentVolumes</code></td><td><code>true</code></td><td>베타</td><td>1.11</td><td>1.23</td></tr><tr><td><code>ExpandPersistentVolumes</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>ExperimentalCriticalPodAnnotation</code></td><td><code>false</code></td><td>알파</td><td>1.5</td><td>1.12</td></tr><tr><td><code>ExperimentalCriticalPodAnnotation</code></td><td><code>false</code></td><td>사용 중단</td><td>1.13</td><td>-</td></tr><tr><td><code>ExternalPolicyForExternalIP</code></td><td><code>true</code></td><td>GA</td><td>1.18</td><td>-</td></tr><tr><td><code>GCERegionalPersistentDisk</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td>1.12</td></tr><tr><td><code>GCERegionalPersistentDisk</code></td><td><code>true</code></td><td>GA</td><td>1.13</td><td>-</td></tr><tr><td><code>GenericEphemeralVolume</code></td><td><code>false</code></td><td>알파</td><td>1.19</td><td>1.20</td></tr><tr><td><code>GenericEphemeralVolume</code></td><td><code>true</code></td><td>베타</td><td>1.21</td><td>1.22</td></tr><tr><td><code>GenericEphemeralVolume</code></td><td><code>true</code></td><td>GA</td><td>1.23</td><td>-</td></tr><tr><td><code>HugePageStorageMediumSize</code></td><td><code>false</code></td><td>알파</td><td>1.18</td><td>1.18</td></tr><tr><td><code>HugePageStorageMediumSize</code></td><td><code>true</code></td><td>베타</td><td>1.19</td><td>1.21</td></tr><tr><td><code>HugePageStorageMediumSize</code></td><td><code>true</code></td><td>GA</td><td>1.22</td><td>-</td></tr><tr><td><code>HugePages</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.9</td></tr><tr><td><code>HugePages</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td>1.13</td></tr><tr><td><code>HugePages</code></td><td><code>true</code></td><td>GA</td><td>1.14</td><td>-</td></tr><tr><td><code>HyperVContainer</code></td><td><code>false</code></td><td>알파</td><td>1.10</td><td>1.19</td></tr><tr><td><code>HyperVContainer</code></td><td><code>false</code></td><td>사용 중단</td><td>1.20</td><td>-</td></tr><tr><td><code>IdentifyPodOS</code></td><td><code>false</code></td><td>알파</td><td>1.23</td><td>1.23</td></tr><tr><td><code>IdentifyPodOS</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td>1.24</td></tr><tr><td><code>IdentifyPodOS</code></td><td><code>true</code></td><td>GA</td><td>1.25</td><td>-</td></tr><tr><td><code>IPv6DualStack</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td>1.20</td></tr><tr><td><code>IPv6DualStack</code></td><td><code>true</code></td><td>베타</td><td>1.21</td><td>1.22</td></tr><tr><td><code>IPv6DualStack</code></td><td><code>true</code></td><td>GA</td><td>1.23</td><td>-</td></tr><tr><td><code>ImmutableEphemeralVolumes</code></td><td><code>false</code></td><td>알파</td><td>1.18</td><td>1.18</td></tr><tr><td><code>ImmutableEphemeralVolumes</code></td><td><code>true</code></td><td>베타</td><td>1.19</td><td>1.20</td></tr><tr><td><code>ImmutableEphemeralVolumes</code></td><td><code>true</code></td><td>GA</td><td>1.21</td><td></td></tr><tr><td><code>IndexedJob</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>IndexedJob</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td>1.23</td></tr><tr><td><code>IndexedJob</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>IngressClassNamespacedParams</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>IngressClassNamespacedParams</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td>1.22</td></tr><tr><td><code>IngressClassNamespacedParams</code></td><td><code>true</code></td><td>GA</td><td>1.23</td><td>-</td></tr><tr><td><code>Initializers</code></td><td><code>false</code></td><td>알파</td><td>1.7</td><td>1.13</td></tr><tr><td><code>Initializers</code></td><td>-</td><td>사용 중단</td><td>1.14</td><td>-</td></tr><tr><td><code>JobPodFailurePolicy</code></td><td><code>false</code></td><td>알파</td><td>1.25</td><td>-</td></tr><tr><td><code>KubeletConfigFile</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.9</td></tr><tr><td><code>KubeletConfigFile</code></td><td>-</td><td>사용 중단</td><td>1.10</td><td>-</td></tr><tr><td><code>KubeletPluginsWatcher</code></td><td><code>false</code></td><td>알파</td><td>1.11</td><td>1.11</td></tr><tr><td><code>KubeletPluginsWatcher</code></td><td><code>true</code></td><td>베타</td><td>1.12</td><td>1.12</td></tr><tr><td><code>KubeletPluginsWatcher</code></td><td><code>true</code></td><td>GA</td><td>1.13</td><td>-</td></tr><tr><td><code>LegacyNodeRoleBehavior</code></td><td><code>false</code></td><td>알파</td><td>1.16</td><td>1.18</td></tr><tr><td><code>LegacyNodeRoleBehavior</code></td><td><code>true</code></td><td>베타</td><td>1.19</td><td>1.20</td></tr><tr><td><code>LegacyNodeRoleBehavior</code></td><td><code>false</code></td><td>GA</td><td>1.21</td><td>-</td></tr><tr><td><code>LegacyServiceAccountTokenNoAutoGeneration</code></td><td><code>true</code></td><td>베타</td><td>1.24</td><td></td></tr><tr><td><code>LocalStorageCapacityIsolation</code></td><td><code>false</code></td><td>알파</td><td>1.7</td><td>1.9</td></tr><tr><td><code>LocalStorageCapacityIsolation</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td>1.24</td></tr><tr><td><code>LocalStorageCapacityIsolation</code></td><td><code>true</code></td><td>GA</td><td>1.25</td><td>-</td></tr><tr><td><code>MountContainers</code></td><td><code>false</code></td><td>알파</td><td>1.9</td><td>1.16</td></tr><tr><td><code>MountContainers</code></td><td><code>false</code></td><td>사용 중단</td><td>1.17</td><td>-</td></tr><tr><td><code>MountPropagation</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.9</td></tr><tr><td><code>MountPropagation</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td>1.11</td></tr><tr><td><code>MountPropagation</code></td><td><code>true</code></td><td>GA</td><td>1.12</td><td>-</td></tr><tr><td><code>NamespaceDefaultLabelName</code></td><td><code>true</code></td><td>베타</td><td>1.21</td><td>1.21</td></tr><tr><td><code>NamespaceDefaultLabelName</code></td><td><code>true</code></td><td>GA</td><td>1.22</td><td>-</td></tr><tr><td><code>NetworkPolicyEndPort</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>NetworkPolicyEndPort</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td>1.24</td></tr><tr><td><code>NetworkPolicyEndPort</code></td><td><code>true</code></td><td>GA</td><td>1.25</td><td>-</td></tr><tr><td><code>NodeDisruptionExclusion</code></td><td><code>false</code></td><td>알파</td><td>1.16</td><td>1.18</td></tr><tr><td><code>NodeDisruptionExclusion</code></td><td><code>true</code></td><td>베타</td><td>1.19</td><td>1.20</td></tr><tr><td><code>NodeDisruptionExclusion</code></td><td><code>true</code></td><td>GA</td><td>1.21</td><td>-</td></tr><tr><td><code>NodeLease</code></td><td><code>false</code></td><td>알파</td><td>1.12</td><td>1.13</td></tr><tr><td><code>NodeLease</code></td><td><code>true</code></td><td>베타</td><td>1.14</td><td>1.16</td></tr><tr><td><code>NodeLease</code></td><td><code>true</code></td><td>GA</td><td>1.17</td><td>-</td></tr><tr><td><code>NonPreemptingPriority</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td>1.18</td></tr><tr><td><code>NonPreemptingPriority</code></td><td><code>true</code></td><td>베타</td><td>1.19</td><td>1.23</td></tr><tr><td><code>NonPreemptingPriority</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>PVCProtection</code></td><td><code>false</code></td><td>알파</td><td>1.9</td><td>1.9</td></tr><tr><td><code>PVCProtection</code></td><td>-</td><td>사용 중단</td><td>1.10</td><td>-</td></tr><tr><td><code>PersistentLocalVolumes</code></td><td><code>false</code></td><td>알파</td><td>1.7</td><td>1.9</td></tr><tr><td><code>PersistentLocalVolumes</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td>1.13</td></tr><tr><td><code>PersistentLocalVolumes</code></td><td><code>true</code></td><td>GA</td><td>1.14</td><td>-</td></tr><tr><td><code>PodAffinityNamespaceSelector</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>PodAffinityNamespaceSelector</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td>1.23</td></tr><tr><td><code>PodAffinityNamespaceSelector</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>PodDisruptionBudget</code></td><td><code>false</code></td><td>알파</td><td>1.3</td><td>1.4</td></tr><tr><td><code>PodDisruptionBudget</code></td><td><code>true</code></td><td>베타</td><td>1.5</td><td>1.20</td></tr><tr><td><code>PodDisruptionBudget</code></td><td><code>true</code></td><td>GA</td><td>1.21</td><td>-</td></tr><tr><td><code>PodDisruptionConditions</code></td><td><code>false</code></td><td>알파</td><td>1.25</td><td>-</td></tr><tr><td><code>PodOverhead</code></td><td><code>false</code></td><td>알파</td><td>1.16</td><td>1.17</td></tr><tr><td><code>PodOverhead</code></td><td><code>true</code></td><td>베타</td><td>1.18</td><td>1.23</td></tr><tr><td><code>PodOverhead</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>PodPriority</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.10</td></tr><tr><td><code>PodPriority</code></td><td><code>true</code></td><td>베타</td><td>1.11</td><td>1.13</td></tr><tr><td><code>PodPriority</code></td><td><code>true</code></td><td>GA</td><td>1.14</td><td>-</td></tr><tr><td><code>PodReadinessGates</code></td><td><code>false</code></td><td>알파</td><td>1.11</td><td>1.11</td></tr><tr><td><code>PodReadinessGates</code></td><td><code>true</code></td><td>베타</td><td>1.12</td><td>1.13</td></tr><tr><td><code>PodReadinessGates</code></td><td><code>true</code></td><td>GA</td><td>1.14</td><td>-</td></tr><tr><td><code>PodShareProcessNamespace</code></td><td><code>false</code></td><td>알파</td><td>1.10</td><td>1.11</td></tr><tr><td><code>PodShareProcessNamespace</code></td><td><code>true</code></td><td>베타</td><td>1.12</td><td>1.16</td></tr><tr><td><code>PodShareProcessNamespace</code></td><td><code>true</code></td><td>GA</td><td>1.17</td><td>-</td></tr><tr><td><code>PreferNominatedNode</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>PreferNominatedNode</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td>1.23</td></tr><tr><td><code>PreferNominatedNode</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>RemoveSelfLink</code></td><td><code>false</code></td><td>알파</td><td>1.16</td><td>1.19</td></tr><tr><td><code>RemoveSelfLink</code></td><td><code>true</code></td><td>베타</td><td>1.20</td><td>1.23</td></tr><tr><td><code>RemoveSelfLink</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>RequestManagement</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td>1.16</td></tr><tr><td><code>RequestManagement</code></td><td>-</td><td>사용 중단</td><td>1.17</td><td>-</td></tr><tr><td><code>ResourceLimitsPriorityFunction</code></td><td><code>false</code></td><td>알파</td><td>1.9</td><td>1.18</td></tr><tr><td><code>ResourceLimitsPriorityFunction</code></td><td>-</td><td>사용 중단</td><td>1.19</td><td>-</td></tr><tr><td><code>ResourceQuotaScopeSelectors</code></td><td><code>false</code></td><td>알파</td><td>1.11</td><td>1.11</td></tr><tr><td><code>ResourceQuotaScopeSelectors</code></td><td><code>true</code></td><td>베타</td><td>1.12</td><td>1.16</td></tr><tr><td><code>ResourceQuotaScopeSelectors</code></td><td><code>true</code></td><td>GA</td><td>1.17</td><td>-</td></tr><tr><td><code>RootCAConfigMap</code></td><td><code>false</code></td><td>알파</td><td>1.13</td><td>1.19</td></tr><tr><td><code>RootCAConfigMap</code></td><td><code>true</code></td><td>베타</td><td>1.20</td><td>1.20</td></tr><tr><td><code>RootCAConfigMap</code></td><td><code>true</code></td><td>GA</td><td>1.21</td><td>-</td></tr><tr><td><code>RotateKubeletClientCertificate</code></td><td><code>true</code></td><td>베타</td><td>1.8</td><td>1.18</td></tr><tr><td><code>RotateKubeletClientCertificate</code></td><td><code>true</code></td><td>GA</td><td>1.19</td><td>-</td></tr><tr><td><code>RunAsGroup</code></td><td><code>true</code></td><td>베타</td><td>1.14</td><td>1.20</td></tr><tr><td><code>RunAsGroup</code></td><td><code>true</code></td><td>GA</td><td>1.21</td><td>-</td></tr><tr><td><code>RuntimeClass</code></td><td><code>false</code></td><td>알파</td><td>1.12</td><td>1.13</td></tr><tr><td><code>RuntimeClass</code></td><td><code>true</code></td><td>베타</td><td>1.14</td><td>1.19</td></tr><tr><td><code>RuntimeClass</code></td><td><code>true</code></td><td>GA</td><td>1.20</td><td>-</td></tr><tr><td><code>SCTPSupport</code></td><td><code>false</code></td><td>알파</td><td>1.12</td><td>1.18</td></tr><tr><td><code>SCTPSupport</code></td><td><code>true</code></td><td>베타</td><td>1.19</td><td>1.19</td></tr><tr><td><code>SCTPSupport</code></td><td><code>true</code></td><td>GA</td><td>1.20</td><td>-</td></tr><tr><td><code>ScheduleDaemonSetPods</code></td><td><code>false</code></td><td>알파</td><td>1.11</td><td>1.11</td></tr><tr><td><code>ScheduleDaemonSetPods</code></td><td><code>true</code></td><td>베타</td><td>1.12</td><td>1.16</td></tr><tr><td><code>ScheduleDaemonSetPods</code></td><td><code>true</code></td><td>GA</td><td>1.17</td><td>-</td></tr><tr><td><code>SelectorIndex</code></td><td><code>false</code></td><td>알파</td><td>1.18</td><td>1.18</td></tr><tr><td><code>SelectorIndex</code></td><td><code>true</code></td><td>베타</td><td>1.19</td><td>1.19</td></tr><tr><td><code>SelectorIndex</code></td><td><code>true</code></td><td>GA</td><td>1.20</td><td>-</td></tr><tr><td><code>ServerSideApply</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.15</td></tr><tr><td><code>ServerSideApply</code></td><td><code>true</code></td><td>베타</td><td>1.16</td><td>1.21</td></tr><tr><td><code>ServerSideApply</code></td><td><code>true</code></td><td>GA</td><td>1.22</td><td>-</td></tr><tr><td><code>ServiceAccountIssuerDiscovery</code></td><td><code>false</code></td><td>알파</td><td>1.18</td><td>1.19</td></tr><tr><td><code>ServiceAccountIssuerDiscovery</code></td><td><code>true</code></td><td>베타</td><td>1.20</td><td>1.20</td></tr><tr><td><code>ServiceAccountIssuerDiscovery</code></td><td><code>true</code></td><td>GA</td><td>1.21</td><td>-</td></tr><tr><td><code>ServiceAppProtocol</code></td><td><code>false</code></td><td>알파</td><td>1.18</td><td>1.18</td></tr><tr><td><code>ServiceAppProtocol</code></td><td><code>true</code></td><td>베타</td><td>1.19</td><td>1.19</td></tr><tr><td><code>ServiceAppProtocol</code></td><td><code>true</code></td><td>GA</td><td>1.20</td><td>-</td></tr><tr><td><code>ServiceLBNodePortControl</code></td><td><code>false</code></td><td>알파</td><td>1.20</td><td>1.21</td></tr><tr><td><code>ServiceLBNodePortControl</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td>1.23</td></tr><tr><td><code>ServiceLBNodePortControl</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>ServiceLoadBalancerClass</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>ServiceLoadBalancerClass</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td>1.23</td></tr><tr><td><code>ServiceLoadBalancerClass</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>ServiceLoadBalancerFinalizer</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td>1.15</td></tr><tr><td><code>ServiceLoadBalancerFinalizer</code></td><td><code>true</code></td><td>베타</td><td>1.16</td><td>1.16</td></tr><tr><td><code>ServiceLoadBalancerFinalizer</code></td><td><code>true</code></td><td>GA</td><td>1.17</td><td>-</td></tr><tr><td><code>ServiceNodeExclusion</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.18</td></tr><tr><td><code>ServiceNodeExclusion</code></td><td><code>true</code></td><td>베타</td><td>1.19</td><td>1.20</td></tr><tr><td><code>ServiceNodeExclusion</code></td><td><code>true</code></td><td>GA</td><td>1.21</td><td>-</td></tr><tr><td><code>ServiceTopology</code></td><td><code>false</code></td><td>알파</td><td>1.17</td><td>1.19</td></tr><tr><td><code>ServiceTopology</code></td><td><code>false</code></td><td>사용 중단</td><td>1.20</td><td>-</td></tr><tr><td><code>SetHostnameAsFQDN</code></td><td><code>false</code></td><td>알파</td><td>1.19</td><td>1.19</td></tr><tr><td><code>SetHostnameAsFQDN</code></td><td><code>true</code></td><td>베타</td><td>1.20</td><td>1.21</td></tr><tr><td><code>SetHostnameAsFQDN</code></td><td><code>true</code></td><td>GA</td><td>1.22</td><td>-</td></tr><tr><td><code>StartupProbe</code></td><td><code>false</code></td><td>알파</td><td>1.16</td><td>1.17</td></tr><tr><td><code>StartupProbe</code></td><td><code>true</code></td><td>베타</td><td>1.18</td><td>1.19</td></tr><tr><td><code>StartupProbe</code></td><td><code>true</code></td><td>GA</td><td>1.20</td><td>-</td></tr><tr><td><code>StatefulSetMinReadySeconds</code></td><td><code>false</code></td><td>알파</td><td>1.22</td><td>1.22</td></tr><tr><td><code>StatefulSetMinReadySeconds</code></td><td><code>true</code></td><td>베타</td><td>1.23</td><td>1.24</td></tr><tr><td><code>StatefulSetMinReadySeconds</code></td><td><code>true</code></td><td>GA</td><td>1.25</td><td>-</td></tr><tr><td><code>StorageObjectInUseProtection</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td>1.10</td></tr><tr><td><code>StorageObjectInUseProtection</code></td><td><code>true</code></td><td>GA</td><td>1.11</td><td>-</td></tr><tr><td><code>StreamingProxyRedirects</code></td><td><code>false</code></td><td>베타</td><td>1.5</td><td>1.5</td></tr><tr><td><code>StreamingProxyRedirects</code></td><td><code>true</code></td><td>베타</td><td>1.6</td><td>1.17</td></tr><tr><td><code>StreamingProxyRedirects</code></td><td><code>true</code></td><td>사용 중단</td><td>1.18</td><td>1.21</td></tr><tr><td><code>StreamingProxyRedirects</code></td><td><code>false</code></td><td>사용 중단</td><td>1.22</td><td>-</td></tr><tr><td><code>SupportIPVSProxyMode</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.8</td></tr><tr><td><code>SupportIPVSProxyMode</code></td><td><code>false</code></td><td>베타</td><td>1.9</td><td>1.9</td></tr><tr><td><code>SupportIPVSProxyMode</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td>1.10</td></tr><tr><td><code>SupportIPVSProxyMode</code></td><td><code>true</code></td><td>GA</td><td>1.11</td><td>-</td></tr><tr><td><code>SupportNodePidsLimit</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.14</td></tr><tr><td><code>SupportNodePidsLimit</code></td><td><code>true</code></td><td>베타</td><td>1.15</td><td>1.19</td></tr><tr><td><code>SupportNodePidsLimit</code></td><td><code>true</code></td><td>GA</td><td>1.20</td><td>-</td></tr><tr><td><code>SupportPodPidsLimit</code></td><td><code>false</code></td><td>알파</td><td>1.10</td><td>1.13</td></tr><tr><td><code>SupportPodPidsLimit</code></td><td><code>true</code></td><td>베타</td><td>1.14</td><td>1.19</td></tr><tr><td><code>SupportPodPidsLimit</code></td><td><code>true</code></td><td>GA</td><td>1.20</td><td>-</td></tr><tr><td><code>SuspendJob</code></td><td><code>false</code></td><td>알파</td><td>1.21</td><td>1.21</td></tr><tr><td><code>SuspendJob</code></td><td><code>true</code></td><td>베타</td><td>1.22</td><td>1.23</td></tr><tr><td><code>SuspendJob</code></td><td><code>true</code></td><td>GA</td><td>1.24</td><td>-</td></tr><tr><td><code>Sysctls</code></td><td><code>true</code></td><td>베타</td><td>1.11</td><td>1.20</td></tr><tr><td><code>Sysctls</code></td><td><code>true</code></td><td>GA</td><td>1.21</td><td>-</td></tr><tr><td><code>TTLAfterFinished</code></td><td><code>false</code></td><td>알파</td><td>1.12</td><td>1.20</td></tr><tr><td><code>TTLAfterFinished</code></td><td><code>true</code></td><td>베타</td><td>1.21</td><td>1.22</td></tr><tr><td><code>TTLAfterFinished</code></td><td><code>true</code></td><td>GA</td><td>1.23</td><td>-</td></tr><tr><td><code>TaintBasedEvictions</code></td><td><code>false</code></td><td>알파</td><td>1.6</td><td>1.12</td></tr><tr><td><code>TaintBasedEvictions</code></td><td><code>true</code></td><td>베타</td><td>1.13</td><td>1.17</td></tr><tr><td><code>TaintBasedEvictions</code></td><td><code>true</code></td><td>GA</td><td>1.18</td><td>-</td></tr><tr><td><code>TaintNodesByCondition</code></td><td><code>false</code></td><td>알파</td><td>1.8</td><td>1.11</td></tr><tr><td><code>TaintNodesByCondition</code></td><td><code>true</code></td><td>베타</td><td>1.12</td><td>1.16</td></tr><tr><td><code>TaintNodesByCondition</code></td><td><code>true</code></td><td>GA</td><td>1.17</td><td>-</td></tr><tr><td><code>TokenRequest</code></td><td><code>false</code></td><td>알파</td><td>1.10</td><td>1.11</td></tr><tr><td><code>TokenRequest</code></td><td><code>true</code></td><td>베타</td><td>1.12</td><td>1.19</td></tr><tr><td><code>TokenRequest</code></td><td><code>true</code></td><td>GA</td><td>1.20</td><td>-</td></tr><tr><td><code>TokenRequestProjection</code></td><td><code>false</code></td><td>알파</td><td>1.11</td><td>1.11</td></tr><tr><td><code>TokenRequestProjection</code></td><td><code>true</code></td><td>베타</td><td>1.12</td><td>1.19</td></tr><tr><td><code>TokenRequestProjection</code></td><td><code>true</code></td><td>GA</td><td>1.20</td><td>-</td></tr><tr><td><code>ValidateProxyRedirects</code></td><td><code>false</code></td><td>알파</td><td>1.12</td><td>1.13</td></tr><tr><td><code>ValidateProxyRedirects</code></td><td><code>true</code></td><td>베타</td><td>1.14</td><td>1.21</td></tr><tr><td><code>ValidateProxyRedirects</code></td><td><code>true</code></td><td>사용 중단</td><td>1.22</td><td>-</td></tr><tr><td><code>VolumePVCDataSource</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td>1.15</td></tr><tr><td><code>VolumePVCDataSource</code></td><td><code>true</code></td><td>베타</td><td>1.16</td><td>1.17</td></tr><tr><td><code>VolumePVCDataSource</code></td><td><code>true</code></td><td>GA</td><td>1.18</td><td>-</td></tr><tr><td><code>VolumeScheduling</code></td><td><code>false</code></td><td>알파</td><td>1.9</td><td>1.9</td></tr><tr><td><code>VolumeScheduling</code></td><td><code>true</code></td><td>베타</td><td>1.10</td><td>1.12</td></tr><tr><td><code>VolumeScheduling</code></td><td><code>true</code></td><td>GA</td><td>1.13</td><td>-</td></tr><tr><td><code>VolumeSnapshotDataSource</code></td><td><code>false</code></td><td>알파</td><td>1.12</td><td>1.16</td></tr><tr><td><code>VolumeSnapshotDataSource</code></td><td><code>true</code></td><td>베타</td><td>1.17</td><td>1.19</td></tr><tr><td><code>VolumeSnapshotDataSource</code></td><td><code>true</code></td><td>GA</td><td>1.20</td><td>-</td></tr><tr><td><code>VolumeSubpath</code></td><td><code>true</code></td><td>GA</td><td>1.10</td><td>-</td></tr><tr><td><code>VolumeSubpathEnvExpansion</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.14</td></tr><tr><td><code>VolumeSubpathEnvExpansion</code></td><td><code>true</code></td><td>베타</td><td>1.15</td><td>1.16</td></tr><tr><td><code>VolumeSubpathEnvExpansion</code></td><td><code>true</code></td><td>GA</td><td>1.17</td><td>-</td></tr><tr><td><code>WarningHeaders</code></td><td><code>true</code></td><td>베타</td><td>1.19</td><td>1.21</td></tr><tr><td><code>WarningHeaders</code></td><td><code>true</code></td><td>GA</td><td>1.22</td><td>-</td></tr><tr><td><code>WatchBookmark</code></td><td><code>false</code></td><td>알파</td><td>1.15</td><td>1.15</td></tr><tr><td><code>WatchBookmark</code></td><td><code>true</code></td><td>베타</td><td>1.16</td><td>1.16</td></tr><tr><td><code>WatchBookmark</code></td><td><code>true</code></td><td>GA</td><td>1.17</td><td>-</td></tr><tr><td><code>WindowsEndpointSliceProxying</code></td><td><code>false</code></td><td>알파</td><td>1.19</td><td>1.20</td></tr><tr><td><code>WindowsEndpointSliceProxying</code></td><td><code>true</code></td><td>베타</td><td>1.21</td><td>1.21</td></tr><tr><td><code>WindowsEndpointSliceProxying</code></td><td><code>true</code></td><td>GA</td><td>1.22</td><td>-</td></tr><tr><td><code>WindowsGMSA</code></td><td><code>false</code></td><td>알파</td><td>1.14</td><td>1.15</td></tr><tr><td><code>WindowsGMSA</code></td><td><code>true</code></td><td>베타</td><td>1.16</td><td>1.17</td></tr><tr><td><code>WindowsGMSA</code></td><td><code>true</code></td><td>GA</td><td>1.18</td><td>-</td></tr><tr><td><code>WindowsRunAsUserName</code></td><td><code>false</code></td><td>알파</td><td>1.16</td><td>1.16</td></tr><tr><td><code>WindowsRunAsUserName</code></td><td><code>true</code></td><td>베타</td><td>1.17</td><td>1.17</td></tr><tr><td><code>WindowsRunAsUserName</code></td><td><code>true</code></td><td>GA</td><td>1.18</td><td>-</td></tr></tbody></table><h2 id=기능-사용>기능 사용</h2><h3 id=기능-단계>기능 단계</h3><p>기능은 <em>알파</em>, <em>베타</em> 또는 <em>GA</em> 단계일 수 있다.
<em>알파</em> 기능은 다음을 의미한다.</p><ul><li>기본적으로 비활성화되어 있다.</li><li>버그가 있을 수 있다. 이 기능을 사용하면 버그에 노출될 수 있다.</li><li>기능에 대한 지원은 사전 통지없이 언제든지 중단될 수 있다.</li><li>API는 이후 소프트웨어 릴리스에서 예고없이 호환되지 않는 방식으로 변경될 수 있다.</li><li>버그의 위험이 증가하고 장기 지원이 부족하여, 단기 테스트
클러스터에서만 사용하는 것이 좋다.</li></ul><p><em>베타</em> 기능은 다음을 의미한다.</p><ul><li>기본적으로 활성화되어 있다.</li><li>이 기능은 잘 테스트되었다. 이 기능을 활성화하면 안전한 것으로 간주된다.</li><li>세부 내용은 변경될 수 있지만, 전체 기능에 대한 지원은 중단되지 않는다.</li><li>오브젝트의 스키마 및/또는 시맨틱은 후속 베타 또는 안정 릴리스에서
호환되지 않는 방식으로 변경될 수 있다. 이러한 상황이 발생하면, 다음 버전으로 마이그레이션하기 위한
지침을 제공한다. API 오브젝트를 삭제, 편집 및 재작성해야
할 수도 있다. 편집 과정에서 약간의 생각이 필요할 수 있다.
해당 기능에 의존하는 애플리케이션의 경우 다운타임이 필요할 수 있다.</li><li>후속 릴리스에서 호환되지 않는 변경이 발생할 수 있으므로
업무상 중요하지 않은(non-business-critical) 용도로만
권장한다. 독립적으로 업그레이드할 수 있는 여러 클러스터가 있는 경우, 이 제한을 완화할 수 있다.</li></ul><div class="alert alert-info note callout" role=alert><strong>참고:</strong> <em>베타</em> 기능을 사용해 보고 의견을 보내주길 바란다!
베타 기간이 종료된 후에는, 더 많은 변경을 하는 것이 실용적이지 않을 수 있다.</div><p><em>GA</em>(General Availability) 기능은 <em>안정</em> 기능이라고도 한다. 이 의미는 다음과 같다.</p><ul><li>이 기능은 항상 활성화되어 있다. 비활성화할 수 없다.</li><li>해당 기능 게이트는 더 이상 필요하지 않다.</li><li>여러 후속 버전의 릴리스된 소프트웨어에 안정적인 기능의 버전이 포함된다.</li></ul><h2 id=feature-gates>기능 게이트 목록</h2><p>각 기능 게이트는 특정 기능을 활성화/비활성화하도록 설계되었다.</p><ul><li><code>APIListChunking</code>: API 클라이언트가 API 서버에서 (<code>LIST</code> 또는 <code>GET</code>)
리소스를 청크(chunks)로 검색할 수 있도록 한다.</li><li><code>APIPriorityAndFairness</code>: 각 서버의 우선 순위와 공정성을 통해 동시 요청을
관리할 수 있다. (<code>RequestManagement</code> 에서 이름이 변경됨)</li><li><code>APIResponseCompression</code>: <code>LIST</code> 또는 <code>GET</code> 요청에 대한 API 응답을 압축한다.</li><li><code>APIServerIdentity</code>: 클러스터의 각 API 서버에 ID를 할당한다.</li><li><code>APIServerTracing</code>: API 서버에서 분산 추적(tracing)에 대한 지원을 추가한다.
자세한 내용은 <a href=/ko/docs/concepts/cluster-administration/system-traces/>쿠버네티스 시스템 컴포넌트에 대한 추적</a>페이지를 살펴본다.</li><li><code>Accelerators</code>: 도커 엔진 사용 시 Nvidia GPU 지원을 활성화하는
플러그인의 초기 형태를 제공하였으며, 사용 중단되었다.
대안을 위해서는 <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>장치 플러그인</a>을
확인한다.</li><li><code>AdvancedAuditing</code>: <a href=/ko/docs/tasks/debug/debug-cluster/audit/#advanced-audit>고급 감사</a> 기능을 활성화한다.</li><li><code>AffinityInAnnotations</code>: <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-affinity-%EC%99%80-%EC%95%88%ED%8B%B0-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-anti-affinity>파드 어피니티 또는 안티-어피니티</a>
설정을 활성화한다.</li><li><code>AllowExtTrafficLocalEndpoints</code>: 서비스가 외부 요청을 노드의 로컬 엔드포인트로 라우팅할 수 있도록 한다.</li><li><code>AllowInsecureBackendProxy</code>: 사용자가 파드 로그 요청에서 kubelet의
TLS 확인을 건너뛸 수 있도록 한다.</li><li><code>AnyVolumeDataSource</code>: <a class=glossary-tooltip title='컨테이너의 볼륨으로 마운트될 수 있도록 퍼시스턴트볼륨(PersistentVolume)에 정의된 스토리지 리소스를 요청한다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=PVC>PVC</a>의
<code>DataSource</code> 로 모든 사용자 정의 리소스 사용을 활성화한다.</li><li><code>AppArmor</code>: 리눅스 노드에서 실행되는 파드에 대한 AppArmor 필수 접근 제어의 사용을 활성화한다.
자세한 내용은 <a href=/ko/docs/tutorials/security/apparmor/>AppArmor 튜토리얼</a>을 참고한다.</li><li><code>AttachVolumeLimit</code>: 볼륨 플러그인이 노드에 연결될 수 있는 볼륨 수에
대한 제한을 보고하도록 한다.
자세한 내용은 <a href=/ko/docs/concepts/storage/storage-limits/#%EB%8F%99%EC%A0%81-%EB%B3%BC%EB%A5%A8-%ED%95%9C%EB%8F%84>동적 볼륨 제한</a>을
참고한다.</li><li><code>BalanceAttachedNodeVolumes</code>: 스케줄링 시 균형 잡힌 리소스 할당을 위해 고려할 노드의 볼륨 수를
포함한다. 스케줄러가 결정을 내리는 동안 CPU, 메모리 사용률 및 볼륨 수가
더 가까운 노드가 선호된다.</li><li><code>BlockVolume</code>: 파드에서 원시 블록 장치의 정의와 사용을 활성화한다.
자세한 내용은 <a href=/ko/docs/concepts/storage/persistent-volumes/#%EC%9B%90%EC%8B%9C-%EB%B8%94%EB%A1%9D-%EB%B3%BC%EB%A5%A8-%EC%A7%80%EC%9B%90>원시 블록 볼륨 지원</a>을
참고한다.</li><li><code>BoundServiceAccountTokenVolume</code>: ServiceAccountTokenVolumeProjection으로 구성된 프로젝션 볼륨을 사용하도록
서비스어카운트 볼륨을 마이그레이션한다.
클러스터 관리자는 <code>serviceaccount_stale_tokens_total</code> 메트릭을 사용하여
확장 토큰에 의존하는 워크로드를 모니터링 할 수 있다.
이러한 워크로드가 없는 경우 <code>--service-account-extend-token-expiration=false</code> 플래그로
<code>kube-apiserver</code>를 시작하여 확장 토큰 기능을 끈다.
자세한 내용은 <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/1205-bound-service-account-tokens/README.md>바운드 서비스 계정 토큰</a>을 확인한다.</li><li><code>ContainerCheckpoint</code>: kubelet의 <code>체크포인트</code> API를 활성화한다.
자세한 내용은 <a href=/docs/reference/node/kubelet-checkpoint-api/>kubelet 체크포인트 API</a>를 확인한다.</li><li><code>ControllerManagerLeaderMigration</code>: HA 클러스터에서 클러스터 오퍼레이터가
kube-controller-manager의 컨트롤러들을 외부 controller-manager(예를 들면,
cloud-controller-manager)로 다운타임 없이 라이브 마이그레이션할 수 있도록 허용하도록
<a href=/docs/tasks/administer-cluster/controller-manager-leader-migration/#initial-leader-migration-configuration>kube-controller-manager</a>와
<a href=/docs/tasks/administer-cluster/controller-manager-leader-migration/#deploy-cloud-controller-manager>cloud-controller-manager</a>의
리더 마이그레이션(Leader Migration)을 활성화한다.</li><li><code>CPUManager</code>: 컨테이너 수준의 CPU 어피니티 지원을 활성화한다.
<a href=/docs/tasks/administer-cluster/cpu-management-policies/>CPU 관리 정책</a>을 참고한다.</li><li><code>CPUManagerPolicyAlphaOptions</code>: CPUManager 정책 중 실험적이며 알파 품질인 옵션의
미세 조정을 허용한다.
이 기능 게이트는 품질 수준이 알파인 CPUManager 옵션의 <em>그룹</em>을 보호한다.
이 기능 게이트는 베타 또는 안정(stable) 상태로 승급되지 않을 것이다.</li><li><code>CPUManagerPolicyBetaOptions</code>: CPUManager 정책 중 실험적이며 베타 품질인 옵션의
미세 조정을 허용한다.
이 기능 게이트는 품질 수준이 베타인 CPUManager 옵션의 <em>그룹</em>을 보호한다.
이 기능 게이트는 안정(stable) 상태로 승급되지 않을 것이다.</li><li><code>CPUManagerPolicyOptions</code>: CPUManager 정책의 미세 조정을 허용한다.</li><li><code>CRIContainerLogRotation</code>: CRI 컨테이너 런타임에 컨테이너 로그 로테이션을 활성화한다.
로그 파일 사이즈 기본값은 10MB이며,
컨테이너 당 최대 로그 파일 수 기본값은 5이다.
이 값은 kubelet 환경설정으로 변경할 수 있다.
더 자세한 내용은
<a href=/ko/docs/concepts/cluster-administration/logging/#%EB%85%B8%EB%93%9C-%EB%A0%88%EB%B2%A8%EC%97%90%EC%84%9C%EC%9D%98-%EB%A1%9C%EA%B9%85>노드 레벨에서의 로깅</a>을 참고한다.</li><li><code>CSIBlockVolume</code>: 외부 CSI 볼륨 드라이버가 블록 스토리지를 지원할 수 있게 한다.
자세한 내용은 <a href=/ko/docs/concepts/storage/volumes/#csi-%EC%9B%90%EC%8B%9C-raw-%EB%B8%94%EB%A1%9D-%EB%B3%BC%EB%A5%A8-%EC%A7%80%EC%9B%90><code>csi</code> 원시 블록 볼륨 지원</a>을
참고한다.</li><li><code>CSIDriverRegistry</code>: csi.storage.k8s.io에서 CSIDriver API 오브젝트와 관련된
모든 로직을 활성화한다.</li><li><code>CSIInlineVolume</code>: 파드에 대한 CSI 인라인 볼륨 지원을 활성화한다.</li><li><code>CSIMigration</code>: shim 및 변환 로직을 통해 볼륨 작업을 인-트리 플러그인에서
사전 설치된 해당 CSI 플러그인으로 라우팅할 수 있다.</li><li><code>CSIMigrationAWS</code>: shim 및 변환 로직을 통해 볼륨 작업을
AWS-EBS 인-트리 플러그인에서 EBS CSI 플러그인으로 라우팅할 수 있다.
이 기능이 비활성화되어 있거나 EBS CSI 플러그인이 설치 및 구성되어 있지 않은 노드에서의 마운트 동작에 대해
인-트리 EBS 플러그인으로의 폴백(falling back)을 지원한다.
프로비전 동작에 대해서는 폴백을 지원하지 않는데,
프로비전 동작은 해당 CSI 플러그인이 설치 및 구성되어 있어야 가능하기 때문이다.</li><li><code>CSIMigrationAWSComplete</code>: kubelet 및 볼륨 컨트롤러에서 EBS 인-트리
플러그인 등록을 중지하고 shim 및 변환 로직을 사용하여 볼륨 작업을 AWS-EBS
인-트리 플러그인에서 EBS CSI 플러그인으로 라우팅할 수 있다.
클러스터의 모든 노드에 CSIMigration과 CSIMigrationAWS 기능 플래그가 활성화되고
EBS CSI 플러그인이 설치 및 구성이 되어 있어야 한다.
이 플래그는 인-트리 EBS 플러그인의 등록을 막는 <code>InTreePluginAWSUnregister</code> 기능 플래그로 인해
더 이상 사용되지 않는다.</li><li><code>CSIMigrationAzureDisk</code>: shim 및 변환 로직을 통해 볼륨 작업을
Azure-Disk 인-트리 플러그인에서 AzureDisk CSI 플러그인으로 라우팅할 수 있다.
이 기능이 비활성화되어 있거나 AzureDisk CSI 플러그인이 설치 및 구성되어 있지 않은 노드에서의 마운트 동작에 대해
인-트리 AzureDisk 플러그인으로의 폴백(falling back)을 지원한다.
프로비전 동작에 대해서는 폴백을 지원하지 않는데,
프로비전 동작은 해당 CSI 플러그인이 설치 및 구성되어 있어야 가능하기 때문이다.
이 기능을 사용하려면 CSIMigration 기능 플래그가 활성화되어 있어야 한다.</li><li><code>CSIMigrationAzureDiskComplete</code>: kubelet 및 볼륨 컨트롤러에서
Azure-Disk 인-트리 플러그인 등록을 중지하고
shim 및 변환 로직을 사용하여
볼륨 작업을 Azure-Disk 인-트리 플러그인에서 AzureDisk CSI 플러그인으로 라우팅할 수 있다.
클러스터의 모든 노드에 CSIMigration과 CSIMigrationAzureDisk 기능 플래그가 활성화되고
AzureDisk CSI 플러그인이 설치 및 구성이 되어 있어야 한다.
이 플래그는 인-트리 AzureDisk 플러그인의 등록을 막는
<code>InTreePluginAzureDiskUnregister</code> 기능 플래그로 인해 더 이상 사용되지 않는다.</li><li><code>CSIMigrationAzureFile</code>: shim 및 변환 로직을 통해 볼륨 작업을
Azure-File 인-트리 플러그인에서 AzureFile CSI 플러그인으로 라우팅할 수 있다.
이 기능이 비활성화되어 있거나 AzureFile CSI 플러그인이 설치 및 구성되어 있지 않은 노드에서의 마운트 동작에 대해
인-트리 AzureFile 플러그인으로의 폴백(falling back)을 지원한다.
프로비전 동작에 대해서는 폴백을 지원하지 않는데,
프로비전 동작은 해당 CSI 플러그인이 설치 및 구성되어 있어야 가능하기 때문이다.
이 기능을 사용하려면 CSIMigration 기능 플래그가 활성화되어 있어야 한다.</li><li><code>CSIMigrationAzureFileComplete</code>: kubelet 및 볼륨 컨트롤러에서 Azure 파일 인-트리
플러그인 등록을 중지하고 shim 및 변환 로직을 통해 볼륨 작업을
Azure 파일 인-트리 플러그인에서 AzureFile CSI 플러그인으로
라우팅할 수 있다. 클러스터의 모든 노드에 CSIMigration과 CSIMigrationAzureFile 기능
플래그가 활성화되고 AzureFile CSI 플러그인이 설치 및 구성이 되어
있어야 한다. 이 플래그는 인-트리 AzureFile 플러그인의 등록을 막는
<code>InTreePluginAzureFileUnregister</code> 기능 플래그로 인해
더 이상 사용되지 않는다.</li><li><code>CSIMigrationGCE</code>: shim 및 변환 로직을 통해 볼륨 작업을
GCE-PD 인-트리 플러그인에서 PD CSI 플러그인으로 라우팅할 수 있다.
이 기능이 비활성화되어 있거나 PD CSI 플러그인이 설치 및 구성되어 있지 않은 노드에서의 마운트 동작에 대해
인-트리 GCE 플러그인으로의 폴백(falling back)을 지원한다.
프로비전 동작에 대해서는 폴백을 지원하지 않는데,
프로비전 동작은 해당 CSI 플러그인이 설치 및 구성되어 있어야 가능하기 때문이다.
이 기능을 사용하려면 CSIMigration 기능 플래그가 활성화되어 있어야 한다.</li><li><code>CSIMigrationGCEComplete</code>: kubelet 및 볼륨 컨트롤러에서 GCE-PD
인-트리 플러그인 등록을 중지하고 shim 및 변환 로직을 통해 볼륨 작업을 GCE-PD
인-트리 플러그인에서 PD CSI 플러그인으로 라우팅할 수 있다.
CSIMigration과 CSIMigrationGCE 기능 플래그가 활성화되고 PD CSI
플러그인이 클러스터의 모든 노드에 설치 및 구성이 되어 있어야 한다.
이 플래그는 인-트리 GCE PD 플러그인의 등록을 막는 <code>InTreePluginGCEUnregister</code> 기능 플래그로 인해
더 이상 사용되지 않는다.</li><li><code>CSIMigrationOpenStack</code>: shim 및 변환 로직을 통해 볼륨 작업을
Cinder 인-트리 플러그인에서 Cinder CSI 플러그인으로 라우팅할 수 있다.
이 기능이 비활성화되어 있거나 Cinder CSI 플러그인이 설치 및 구성되어 있지 않은 노드에서의 마운트 동작에 대해
인-트리 Cinder 플러그인으로의 폴백(falling back)을 지원한다.
프로비전 동작에 대해서는 폴백을 지원하지 않는데,
프로비전 동작은 해당 CSI 플러그인이 설치 및 구성되어 있어야 가능하기 때문이다.
이 기능을 사용하려면 CSIMigration 기능 플래그가 활성화되어 있어야 한다.</li><li><code>CSIMigrationOpenStackComplete</code>: kubelet 및 볼륨 컨트롤러에서
Cinder 인-트리 플러그인 등록을 중지하고 shim 및 변환 로직이 Cinder 인-트리
플러그인에서 Cinder CSI 플러그인으로 볼륨 작업을 라우팅할 수 있도록 한다.
클러스터의 모든 노드에 CSIMigration과 CSIMigrationOpenStack 기능 플래그가 활성화되고
Cinder CSI 플러그인이 설치 및 구성이 되어 있어야 한다.
이 플래그는 인-트리 openstack cinder 플러그인의 등록을 막는 <code>InTreePluginOpenStackUnregister</code> 기능 플래그로 인해
더 이상 사용되지 않는다.</li><li><code>csiMigrationRBD</code>: RBD 트리 내(in-tree) 플러그인으로 가는 볼륨 작업을
Ceph RBD CSI 플러그인으로 라우트하는 심(shim)과 변환 로직을 활성화한다.
클러스터에 CSIMigration 및 csiMigrationRBD 기능 플래그가 활성화되어 있어야 하고,
Ceph CSI 플러그인이 설치 및 설정되어 있어야 한다.
이 플래그는 트리 내(in-tree) RBD 플러그인 등록을 금지시키는 <code>InTreePluginRBDUnregister</code> 기능 플래그에 의해
사용 중단되었다.</li><li><code>CSIMigrationvSphere</code>: vSphere 인-트리 플러그인에서 vSphere CSI 플러그인으로 볼륨 작업을
라우팅하는 shim 및 변환 로직을 사용한다.
이 기능이 비활성화되어 있거나 vSphere CSI 플러그인이 설치 및 구성되어 있지 않은 노드에서의 마운트 동작에 대해
인-트리 vSphere 플러그인으로의 폴백(falling back)을 지원한다.
프로비전 동작에 대해서는 폴백을 지원하지 않는데,
프로비전 동작은 해당 CSI 플러그인이 설치 및 구성되어 있어야 가능하기 때문이다.
이 기능을 사용하려면 CSIMigration 기능 플래그가 활성화되어 있어야 한다.</li><li><code>CSIMigrationvSphereComplete</code>: kubelet 및 볼륨 컨트롤러에서 vSphere 인-트리
플러그인 등록을 중지하고 shim 및 변환 로직을 활성화하여 vSphere 인-트리 플러그인에서
vSphere CSI 플러그인으로 볼륨 작업을 라우팅할 수 있도록 한다. CSIMigration 및
CSIMigrationvSphere 기능 플래그가 활성화되고 vSphere CSI 플러그인이
클러스터의 모든 노드에 설치 및 구성이 되어 있어야 한다.
이 플래그는 인-트리 vsphere 플러그인의 등록을 막는 <code>InTreePluginvSphereUnregister</code> 기능 플래그로 인해
더 이상 사용되지 않는다.</li><li><code>CSIMigrationPortworx</code>: Portworx 트리 내(in-tree) 플러그인으로 가는 볼륨 작업을
Portworx CSI 플러그인으로 라우트하는 심(shim)과 변환 로직을 활성화한다.
Portworx CSI 드라이버가 설치 및 설정되어 있어야 한다.</li><li><code>CSINodeInfo</code>: <code>csi.storage.k8s.io</code> 내의 CSINodeInfo API 오브젝트와 관련된 모든 로직을 활성화한다.</li><li><code>CSINodeExpandSecret</code>: CSI 드라이버가 <code>NodeExpandVolume</code> 작업 수행 중에 사용할 수 있도록
시크릿 인증 데이터를 드라이버에 전송 가능하게 한다.</li><li><code>CSIPersistentVolume</code>: <a href=https://git.k8s.io/design-proposals-archive/storage/container-storage-interface.md>CSI (Container Storage Interface)</a>
호환 볼륨 플러그인을 통해 프로비저닝된 볼륨을 감지하고
마운트할 수 있다.</li><li><code>CSIServiceAccountToken</code> : 볼륨을 마운트하는 파드의 서비스 계정 토큰을 받을 수 있도록
CSI 드라이버를 활성화한다.
<a href=https://kubernetes-csi.github.io/docs/token-requests.html>토큰 요청</a>을 참조한다.</li><li><code>CSIStorageCapacity</code>: CSI 드라이버가 스토리지 용량 정보를 게시하고
쿠버네티스 스케줄러가 파드를 스케줄할 때 해당 정보를 사용하도록 한다.
<a href=/ko/docs/concepts/storage/storage-capacity/>스토리지 용량</a>을 참고한다.
자세한 내용은 <a href=/ko/docs/concepts/storage/volumes/#csi><code>csi</code> 볼륨 유형</a> 문서를 확인한다.</li><li><code>CSIVolumeFSGroupPolicy</code>: CSI드라이버가 <code>fsGroupPolicy</code> 필드를 사용하도록 허용한다.
이 필드는 CSI드라이버에서 생성된 볼륨이 마운트될 때 볼륨 소유권과
권한 수정을 지원하는지 여부를 제어한다.</li><li><code>CSIVolumeHealth</code>: 노드에서의 CSI 볼륨 상태 모니터링 기능을 활성화한다.</li><li><code>CSRDuration</code>: 클라이언트가 쿠버네티스 CSR API를 통해 발급된 인증서의 기간을
요청할 수 있다.</li><li><code>ConfigurableFSGroupPolicy</code>: 사용자가 파드에 볼륨을 마운트할 때 fsGroups에 대한
볼륨 권한 변경 정책을 구성할 수 있다. 자세한 내용은
<a href=/docs/tasks/configure-pod-container/security-context/#configure-volume-permission-and-ownership-change-policy-for-pods>파드의 볼륨 권한 및 소유권 변경 정책 구성</a>을
참고한다.</li><li><code>ContextualLogging</code>: 이 기능을 활성화하면,
컨텍스츄얼 로깅을 지원하는 쿠버네티스 구성 요소가 로그 출력에 추가 상세를 추가한다.</li><li><code>ControllerManagerLeaderMigration</code>: <code>kube-controller-manager</code> 및 <code>cloud-controller-manager</code>에
대한 리더 마이그레이션을 지원한다.</li><li><code>CronJobControllerV2</code>: <a class=glossary-tooltip title='정기적인 일정으로 실행되는 반복 작업(잡).' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/cron-jobs/ target=_blank aria-label=크론잡(CronJob)>크론잡(CronJob)</a>
컨트롤러의 대체 구현을 사용한다. 그렇지 않으면,
동일한 컨트롤러의 버전 1이 선택된다.</li><li><code>CronJobTimeZone</code>: <a href=/ko/docs/concepts/workloads/controllers/cron-jobs/>크론잡</a>의 선택적 <code>timeZone</code> 필드 사용을 허용한다.</li><li><code>CustomCPUCFSQuotaPeriod</code>: <a href=/docs/tasks/administer-cluster/kubelet-config-file/>kubelet config</a>에서
<code>cpuCFSQuotaPeriod</code> 를 노드가 변경할 수 있도록 한다.</li><li><code>CustomResourceValidationExpressions</code>: <code>x-kubernetes-validations</code> 확장 기능으로 작성된
검증 규칙을 기반으로 커스텀 리소스를 검증하는
표현 언어 검증(expression language validation)을 CRD에 활성화한다.</li><li><code>CustomPodDNS</code>: <code>dnsConfig</code> 속성을 사용하여 파드의 DNS 설정을 사용자 정의할 수 있다.
자세한 내용은 <a href=/ko/docs/concepts/services-networking/dns-pod-service/#pod-dns-config>파드의 DNS 설정</a>을
확인한다.</li><li><code>CustomResourceDefaulting</code>: OpenAPI v3 유효성 검사 스키마에서 기본값에 대한 CRD 지원을 활성화한다.</li><li><code>CustomResourcePublishOpenAPI</code>: CRD OpenAPI 사양을 게시할 수 있다.</li><li><code>CustomResourceSubresources</code>: <a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>커스텀리소스데피니션</a>에서
생성된 리소스에서 <code>/status</code> 및 <code>/scale</code> 하위 리소스를 활성화한다.</li><li><code>CustomResourceValidation</code>: <a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>커스텀리소스데피니션</a>에서
생성된 리소스에서 스키마 기반 유효성 검사를 활성화한다.</li><li><code>CustomResourceWebhookConversion</code>: <a href=/ko/docs/concepts/extend-kubernetes/api-extension/custom-resources/>커스텀리소스데피니션</a>에서
생성된 리소스에 대해 웹 훅 기반의 변환을 활성화한다.</li><li><code>DaemonSetUpdateSurge</code>: 노드당 업데이트 중 가용성을 유지하도록
데몬셋 워크로드를 사용하도록 설정한다.
<a href=/ko/docs/tasks/manage-daemon/update-daemon-set/>데몬셋에서 롤링 업데이트 수행</a>을 참고한다.</li><li><code>DefaultPodTopologySpread</code>: <code>PodTopologySpread</code> 스케줄링 플러그인을 사용하여
<a href=/ko/docs/concepts/scheduling-eviction/topology-spread-constraints/#%EB%82%B4%EB%B6%80-%EA%B8%B0%EB%B3%B8-%EC%A0%9C%EC%95%BD>기본 분배</a>를 수행한다.</li><li><code>DelegateFSGroupToCSIDriver</code>: CSI 드라이버가 지원할 경우, NodeStageVolume 및 NodePublishVolume CSI 호출을 통해
<code>fsGroup</code>를 전달하여 파드의 <code>securityContext</code>에서
<code>fsGroup</code>를 드라이브에 적용하는 역할을 위임한다.</li><li><code>DevicePlugins</code>: 노드에서 <a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>장치 플러그인</a>
기반 리소스 프로비저닝을 활성화한다.</li><li><code>DisableAcceleratorUsageMetrics</code>:
<a href=/ko/docs/concepts/cluster-administration/system-metrics/#%EC%95%A1%EC%85%80%EB%9F%AC%EB%A0%88%EC%9D%B4%ED%84%B0-%EB%A9%94%ED%8A%B8%EB%A6%AD-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94>kubelet이 수집한 액셀러레이터 지표 비활성화</a>.</li><li><code>DisableCloudProviders</code>: <code>kube-apiserver</code>, <code>kube-controller-manager</code>,
<code>--cloud-provider</code> 컴포넌트 플래그와 관련된 <code>kubelet</code>의
모든 기능을 비활성화한다.</li><li><code>DisableKubeletCloudCredentialProviders</code>: 이미지 풀 크리덴셜을 위해
클라우드 프로바이더 컨테이너 레지스트리에 인증을 수행하는 kubelet 내부(in-tree) 기능을 비활성화한다.</li><li><code>DownwardAPIHugePages</code>: <a href=/ko/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>다운워드 API</a>에서
hugepages 사용을 활성화한다.</li><li><code>DryRun</code>: 서버 측의 <a href=/docs/reference/using-api/api-concepts/#dry-run>dry run</a> 요청을
요청을 활성화하여 커밋하지 않고 유효성 검사, 병합 및 변화를 테스트할 수 있다.</li><li><code>DynamicAuditing</code>: v1.19 이전의 버전에서 동적 감사를 활성화하는 데 사용된다.</li><li><code>DynamicKubeletConfig</code>: kubelet의 동적 구성을 활성화한다.
이 기능은 지원하는 버전 차이(supported skew policy) 바깥에서는 더 이상 지원되지 않는다.
이 기능 게이트는 1.24에 kubelet에서 제거되었다. <a href=/docs/tasks/administer-cluster/reconfigure-kubelet/>kubelet 재구성하기</a>를 참고한다.</li><li><code>DynamicProvisioningScheduling</code>: 볼륨 토폴로지를 인식하고 PV 프로비저닝을 처리하도록
기본 스케줄러를 확장한다.
이 기능은 v1.12의 <code>VolumeScheduling</code> 기능으로 대체되었다.</li><li><code>DynamicVolumeProvisioning</code>: 파드에 퍼시스턴트 볼륨의
<a href=/ko/docs/concepts/storage/dynamic-provisioning/>동적 프로비저닝</a>을 활성화한다.</li><li><code>EfficientWatchResumption</code>: 스토리지에서 생성된 북마크(진행
알림) 이벤트를 사용자에게 전달할 수 있다. 이것은 감시 작업에만
적용된다.</li><li><code>EnableAggregatedDiscoveryTimeout</code>: 수집된 검색 호출에서 5초
시간 초과를 활성화한다.</li><li><code>EnableEquivalenceClassCache</code>: 스케줄러가 파드를 스케줄링할 때 노드의
동등성을 캐시할 수 있게 한다.</li><li><code>EndpointSlice</code>: 보다 스케일링 가능하고 확장 가능한 네트워크 엔드포인트에 대한
엔드포인트슬라이스(EndpointSlices)를 활성화한다. <a href=/ko/docs/concepts/services-networking/endpoint-slices/>엔드포인트슬라이스 활성화</a>를 참고한다.</li><li><code>EndpointSliceNodeName</code> : 엔드포인트슬라이스 <code>nodeName</code> 필드를 활성화한다.</li><li><code>EndpointSliceProxying</code>: 활성화되면, 리눅스에서 실행되는
kube-proxy는 엔드포인트 대신 엔드포인트슬라이스를
기본 데이터 소스로 사용하여 확장성과 성능을 향상시킨다.
<a href=/ko/docs/concepts/services-networking/endpoint-slices/>엔드포인트슬라이스 활성화</a>를 참고한다.</li><li><code>EndpointSliceTerminatingCondition</code>: 엔드포인트슬라이스 <code>terminating</code> 및 <code>serving</code>
조건 필드를 활성화한다.</li><li><code>EphemeralContainers</code>: 파드를 실행하기 위한
<a class=glossary-tooltip title='파드 내에 임시적으로 실행할 수 있는 컨테이너 타입' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/pods/ephemeral-containers/ target=_blank aria-label='임시 컨테이너'>임시 컨테이너</a>를
추가할 수 있다.</li><li><code>EvenPodsSpread</code>: 토폴로지 도메인 간에 파드를 균등하게 스케줄링할 수 있다.
<a href=/ko/docs/concepts/scheduling-eviction/topology-spread-constraints/>파드 토폴로지 분배 제약 조건</a>을 참고한다.</li><li><code>ExecProbeTimeout</code> : kubelet이 exec 프로브 시간 초과를 준수하는지 확인한다.
이 기능 게이트는 기존 워크로드가 쿠버네티스가 exec 프로브 제한 시간을 무시한
현재 수정된 결함에 의존하는 경우 존재한다.
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes>준비성 프로브</a>를 참조한다.</li><li><code>ExpandCSIVolumes</code>: CSI 볼륨 확장을 활성화한다.</li><li><code>ExpandedDNSConfig</code>: 더 많은 DNS 검색 경로와 더 긴 DNS 검색 경로 목록을 허용하려면
kubelet과 kube-apiserver를 사용하도록 설정한다.
이 기능을 사용하려면 컨테이너 런타임이 지원해야 한다(Containerd: v1.5.6 이상, CRI-O: v1.22 이상).
<a href=/ko/docs/concepts/services-networking/dns-pod-service/#%ED%99%95%EC%9E%A5%EB%90%9C-dns-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95>확장된 DNS 구성</a>을 참고한다.</li><li><code>ExpandInUsePersistentVolumes</code>: 사용 중인 PVC를 확장할 수 있다.
<a href=/ko/docs/concepts/storage/persistent-volumes/#%EC%82%AC%EC%9A%A9-%EC%A4%91%EC%9D%B8-%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8%EB%B3%BC%EB%A5%A8%ED%81%B4%EB%A0%88%EC%9E%84-%ED%81%AC%EA%B8%B0-%EC%A1%B0%EC%A0%95>사용 중인 퍼시스턴트볼륨클레임 크기 조정</a>을 참고한다.</li><li><code>ExpandPersistentVolumes</code>: 퍼시스턴트 볼륨 확장을 활성화한다.
<a href=/ko/docs/concepts/storage/persistent-volumes/#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8-%EB%B3%BC%EB%A5%A8-%ED%81%B4%EB%A0%88%EC%9E%84-%ED%99%95%EC%9E%A5>퍼시스턴트 볼륨 클레임 확장</a>을 참고한다.</li><li><code>ExperimentalCriticalPodAnnotation</code>: 특정 파드에 <em>critical</em> 로
어노테이션을 달아서 <a href=/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/>스케줄링이 보장되도록</a> 한다.
이 기능은 v1.13부터 파드 우선 순위 및 선점으로 인해 사용 중단되었다.</li><li><code>ExperimentalHostUserNamespaceDefaulting</code>: 사용자 네임스페이스를 호스트로
기본 활성화한다. 이것은 다른 호스트 네임스페이스, 호스트 마운트,
권한이 있는 컨테이너 또는 특정 비-네임스페이스(non-namespaced) 기능(예: <code>MKNODE</code>, <code>SYS_MODULE</code> 등)을
사용하는 컨테이너를 위한 것이다. 도커 데몬에서 사용자 네임스페이스
재 매핑이 활성화된 경우에만 활성화해야 한다.</li><li><code>ExternalPolicyForExternalIP</code>: ExternalTrafficPolicy가 서비스(Service) ExternalIP에 적용되지 않는
버그를 수정한다.</li><li><code>GCERegionalPersistentDisk</code>: GCE에서 지역 PD 기능을 활성화한다.</li><li><code>GenericEphemeralVolume</code>: 일반 볼륨의 모든 기능을 지원하는 임시, 인라인
볼륨을 활성화한다(타사 스토리지 공급 업체, 스토리지 용량 추적, 스냅샷으로부터 복원
등에서 제공할 수 있음).
<a href=/ko/docs/concepts/storage/ephemeral-volumes/>임시 볼륨</a>을 참고한다.</li><li><code>GracefulNodeShutdown</code> : kubelet에서 정상 종료를 지원한다.
시스템 종료 중에 kubelet은 종료 이벤트를 감지하고 노드에서 실행 중인
파드를 정상적으로 종료하려고 시도한다. 자세한 내용은
<a href=/ko/docs/concepts/architecture/nodes/#%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%8A%A4%ED%92%80-graceful-%EB%85%B8%EB%93%9C-%EC%85%A7%EB%8B%A4%EC%9A%B4>Graceful Node Shutdown</a>을
참조한다.</li><li><code>GracefulNodeShutdownBasedOnPodPriority</code>: 그레이스풀(graceful) 노드 셧다운을 할 때
kubelet이 파드 우선순위를 체크할 수 있도록 활성화한다.</li><li><code>GRPCContainerProbe</code>: 활성 프로브(Liveness Probe), 준비성 프로브(Readiness Probe), 스타트업 프로브(Startup Probe)에 대해 gRPC 프로브를 활성화한다.
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-grpc-liveness-probe>활성/준비성/스타트업 프로브 구성하기</a>를 참조한다.</li><li><code>HonorPVReclaimPolicy</code>: 퍼시스턴트 볼륨 회수 정책이 <code>Delete</code>인 경우 PV-PVC 삭제 순서와 상관없이 정책을 준수한다.
더 자세한 정보는
<a href=/ko/docs/concepts/storage/persistent-volumes/#persistentvolume-deletion-protection-finalizer>퍼시스턴트볼륨 삭제 보호 파이널라이저(finalizer)</a> 문서를
참고한다.</li><li><code>HPAContainerMetrics</code>: <code>HorizontalPodAutoscaler</code> 를 활성화하여 대상 파드의
개별 컨테이너 메트릭을 기반으로 확장한다.</li><li><code>HPAScaleToZero</code>: 사용자 정의 또는 외부 메트릭을 사용할 때 <code>HorizontalPodAutoscaler</code> 리소스에 대해
<code>minReplicas</code> 를 0으로 설정한다.</li><li><code>HugePages</code>: 사전 할당된 <a href=/ko/docs/tasks/manage-hugepages/scheduling-hugepages/>huge page</a>의
할당 및 사용을 활성화한다.</li><li><code>HugePageStorageMediumSize</code>: 사전 할당된 <a href=/ko/docs/tasks/manage-hugepages/scheduling-hugepages/>huge page</a>의
여러 크기를 지원한다.</li><li><code>HyperVContainer</code>: 윈도우 컨테이너를 위한
<a href=https://docs.microsoft.com/ko-kr/virtualization/windowscontainers/manage-containers/hyperv-container>Hyper-V 격리</a>
기능을 활성화한다.</li><li><code>IdentifyPodOS</code>: 파드 OS 필드를 지정할 수 있게 한다.
이를 통해 API 서버 관리 시 파드의 OS를 정석적인 방법으로 알 수 있다.
쿠버네티스 1.25에서,
<code>pod.spec.os.name</code> 에 사용할 수 있는 값은 <code>windows</code> 와 <code>linux</code> 이다.</li><li><code>ImmutableEphemeralVolumes</code>: 안정성과 성능 향상을 위해 개별 시크릿(Secret)과 컨피그맵(ConfigMap)을
변경할 수 없는(immutable) 것으로 표시할 수 있다.</li><li><code>IndexedJob</code>: <a href=/ko/docs/concepts/workloads/controllers/job/>잡</a> 컨트롤러가 파드 완료(completion)를
완료 인덱스에 따라 관리할 수 있도록 허용한다.</li><li><code>IngressClassNamespacedParams</code>: 네임스페이스 범위의 파라미터가
<code>IngressClass</code> 리소스를 참조할 수 있도록 허용한다.
이 기능은 <code>IngressClass.spec.parameters</code>에 <code>Scope</code> 및 <code>Namespace</code>의 2 필드를 추가한다.</li><li><code>Initializers</code>: Initializers 어드미션 플러그인을 사용하여,
오브젝트 생성 시 비동기 협조(asynchronous coordination)를 허용한다.</li><li><code>InTreePluginAWSUnregister</code>: kubelet 및 볼륨 컨트롤러에 aws-ebs 인-트리
플러그인의 등록을 중지한다.</li><li><code>InTreePluginAzureDiskUnregister</code>: kubelet 및 볼륨 컨트롤러에 azuredisk 인-트리
플러그인의 등록을 중지한다.</li><li><code>InTreePluginAzureFileUnregister</code>: kubelet 및 볼륨 컨트롤러에 azurefile 인-트리
플러그인의 등록을 중지한다.</li><li><code>InTreePluginGCEUnregister</code>: kubelet 및 볼륨 컨트롤러에 gce-pd 인-트리
플러그인의 등록을 중지한다.</li><li><code>InTreePluginOpenStackUnregister</code>: kubelet 및 볼륨 컨트롤러에 오픈스택 cinder 인-트리
플러그인의 등록을 중지한다.</li><li><code>InTreePluginPortworxUnregister</code>: kubelet 및 볼륨 컨트롤러에 Portworx 인-트리
플러그인의 등록을 중지한다.</li><li><code>InTreePluginRBDUnregister</code>: kubelet 및 볼륨 컨트롤러에 RBD 인-트리
플러그인의 등록을 중지한다.</li><li><code>InTreePluginvSphereUnregister</code>: kubelet 및 볼륨 컨트롤러에 vSphere 인-트리
플러그인의 등록을 중지한다.</li><li><code>IPv6DualStack</code>: IPv6을 위한 <a href=/ko/docs/concepts/services-networking/dual-stack/>이중 스택</a>
기능을 활성화한다.</li><li><code>JobMutableNodeSchedulingDirectives</code>: <a href=/ko/docs/concepts/workloads/controllers/job/>잡</a>의
파드 템플릿에 있는 노드 스케줄링 지시를 업데이트할 수 있게 한다.</li><li><code>JobPodFailurePolicy</code>: 사용자가 컨테이너의 종료 코드나 파드 상태에 따라 파드의 장애를 처리할 수 있도록 한다.</li><li><code>JobReadyPods</code>: 파드 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%ED%8C%8C%EB%93%9C%EC%9D%98-%EC%BB%A8%EB%94%94%EC%85%98>컨디션</a>이
<code>Ready</code>인 파드의 수를 추적하는 기능을 활성화한다.
<code>Ready</code>인 파드의 수는 <a href=/ko/docs/concepts/workloads/controllers/job/>잡</a> 상태의
<a href=/docs/reference/kubernetes-api/workload-resources/job-v1/#JobStatus>status</a>
필드에 기록된다.</li><li><code>JobTrackingWithFinalizers</code>: 클러스터에 무제한으로 남아 있는 파드에 의존하지 않고
<a href=/ko/docs/concepts/workloads/controllers/job>잡</a>의 완료를 추적할 수 있다.
잡 컨트롤러는 완료된 파드를 추적하기 위해
완료된 파드의 잡 상태 필드를 사용한다.</li><li><code>KubeletConfigFile</code>: 구성 파일을 사용하여 지정된 파일에서
kubelet 구성을 로드할 수 있다.
자세한 내용은 <a href=/docs/tasks/administer-cluster/kubelet-config-file/>구성 파일을 통해 kubelet 파라미터 설정</a>을
참고한다.</li><li><code>KubeletCredentialProviders</code>: 이미지 풀 자격 증명에 대해
kubelet exec 자격 증명 공급자를 활성화한다.</li><li><code>KubeletInUserNamespace</code>: <a class=glossary-tooltip title='A Linux kernel feature to emulate superuser privilege for unprivileged users.' data-toggle=tooltip data-placement=top href=https://man7.org/linux/man-pages/man7/user_namespaces.7.html target=_blank aria-label='user namespace'>user namespace</a>에서
kubelet 실행을 활성화한다.
<a href=/docs/tasks/administer-cluster/kubelet-in-userns/>루트가 아닌 유저로 쿠버네티스 노드 컴포넌트 실행</a>을 참고한다.</li><li><code>KubeletPluginsWatcher</code>: kubelet이 <a href=/ko/docs/concepts/storage/volumes/#csi>CSI 볼륨 드라이버</a>와 같은
플러그인을 검색할 수 있도록 프로브 기반 플러그인 감시자(watcher) 유틸리티를 사용한다.</li><li><code>KubeletPodResources</code>: kubelet의 파드 리소스 gPRC 엔드포인트를 활성화한다. 자세한 내용은
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/606-compute-device-assignment/README.md>장치 모니터링 지원</a>을
참고한다.</li><li><code>KubeletPodResourcesGetAllocatable</code>: kubelet의 파드 리소스
<code>GetAllocatableResources</code> 기능을 활성화한다.
이 API는 클라이언트가 노드의 여유 컴퓨팅 자원을 잘 파악할 수 있도록,
할당 가능 자원에 대한 정보를
<a href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#%EC%9E%A5%EC%B9%98-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81>자원 할당 보고</a>한다.</li><li><code>LegacyNodeRoleBehavior</code>: 비활성화되면, 서비스 로드 밸런서 및 노드 중단의 레거시 동작은
<code>NodeDisruptionExclusion</code> 과 <code>ServiceNodeExclusion</code> 에 의해 제공된 기능별 레이블을 대신하여
<code>node-role.kubernetes.io/master</code> 레이블을 무시한다.</li><li><code>KubeletTracing</code>: kubelet에 분산 추적에 대한 지원을 추가한다.
활성화된 경우, kubelet CRI 인터페이스와 인증된 http 서버들은
OpenTelemetry 추적 범위를 형성하는 데 도움을 준다.
자세한 내용은 <a href=/ko/docs/concepts/cluster-administration/system-traces/>쿠버네티스 시스템 컴포넌트에 대한 추적</a> 페이지를 확인한다.</li><li><code>LegacyServiceAccountTokenNoAutoGeneration</code>: 시크릿 기반
<a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>서비스 어카운트 토큰</a>의 자동 생성을 중단한다.</li><li><code>LocalStorageCapacityIsolation</code>:
<a href=/ko/docs/concepts/configuration/manage-resources-containers/>로컬 임시 스토리지</a>와
<a href=/ko/docs/concepts/storage/volumes/#emptydir>emptyDir 볼륨</a>의
<code>sizeLimit</code> 속성을 사용할 수 있게 한다.</li><li><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code>: <a href=/ko/docs/concepts/configuration/manage-resources-containers/>로컬 임시 스토리지</a>에
<code>LocalStorageCapacityIsolation</code> 이 활성화되고
<a href=/ko/docs/concepts/storage/volumes/#emptydir>emptyDir 볼륨</a>의
백업 파일시스템이 프로젝트 쿼터를 지원하고 활성화된 경우, 파일시스템 사용보다는
프로젝트 쿼터를 사용하여 <a href=/ko/docs/concepts/storage/volumes/#emptydir>emptyDir 볼륨</a>
스토리지 사용을 모니터링하여 성능과 정확성을
향상시킨다.</li><li><code>LogarithmicScaleDown</code>: 컨트롤러 스케일 다운 시에 파드 타임스탬프를 로그 스케일로 버켓화하여
축출할 파드를 반-랜덤하게 선택하는 기법을 활성화한다.</li><li><code>MatchLabelKeysInPodTopologySpread</code>: <a href=/ko/docs/concepts/scheduling-eviction/topology-spread-constraints/>파드 토폴로지 분배 제약 조건</a>의
<code>matchLabelKeys</code> 필드를 활성화한다.</li><li><code>MaxUnavailableStatefulSet</code>: 스테이트풀셋의
<a href=/ko/docs/concepts/workloads/controllers/statefulset/#%EB%A1%A4%EB%A7%81-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8>롤링 업데이트 전략</a>에 대해
<code>maxUnavailable</code> 필드를 설정할 수 있도록 한다.
이 필드는 업데이트 동안 사용 불가능(unavailable) 상태의 파드를 몇 개까지 허용할지를 정한다.</li><li><code>MemoryManager</code>: NUMA 토폴로지를 기반으로 컨테이너에 대한
메모리 어피니티를 설정할 수 있다.</li><li><code>MemoryQoS</code>: cgroup v2 메모리 컨트롤러를 사용하여
파드/컨테이너에서 메모리 보호 및 사용 제한을 사용하도록 설정한다.</li><li><code>MinDomainsInPodTopologySpread</code>: <a href=/ko/docs/concepts/scheduling-eviction/topology-spread-constraints/>파드 토폴로지 분배 제약 조건</a> 내의
<code>minDomains</code> 사용을 활성화한다.</li><li><code>MixedProtocolLBService</code>: 동일한 로드밸런서 유형 서비스 인스턴스에서 다른 프로토콜
사용을 활성화한다.</li><li><code>MountContainers</code>: 호스트의 유틸리티 컨테이너를 볼륨 마운터로 사용할 수 있다.</li><li><code>MountPropagation</code>: 한 컨테이너에서 다른 컨테이너 또는 파드로 마운트된 볼륨을 공유할 수 있다.
자세한 내용은 <a href=/ko/docs/concepts/storage/volumes/#%EB%A7%88%EC%9A%B4%ED%8A%B8-%EC%A0%84%ED%8C%8C-propagation>마운트 전파(propagation)</a>을 참고한다.</li><li><code>NamespaceDefaultLabelName</code>: API 서버로 하여금 모든 네임스페이스에 대해 변경할 수 없는 (immutable)
<a class=glossary-tooltip title='사용자에게 의미 있고 관련성 높은 특징으로 식별할 수 있도록 오브젝트에 태그를 붙인다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=레이블>레이블</a> <code>kubernetes.io/metadata.name</code>을 설정하도록 한다.
(네임스페이스의 이름도 변경 불가)</li><li><code>NetworkPolicyEndPort</code>: 네트워크폴리시(NetworkPolicy) 오브젝트에서 단일 포트를 지정하는 것 대신에
포트 범위를 지정할 수 있도록, <code>endPort</code> 필드의 사용을 활성화한다.</li><li><code>NetworkPolicyStatus</code>: 네트워크폴리시 오브젝트에 대해 <code>status</code> 서브리소스를 활성화한다.</li><li><code>NodeInclusionPolicyInPodTopologySpread</code>: 파드 토폴로지 분배 비대칭도를 계산할 때
<a href=/ko/docs/concepts/scheduling-eviction/topology-spread-constraints/>파드 토폴로지 분배 제약 조건</a>의
<code>nodeAffinityPolicy</code>와 <code>nodeTaintsPolicy</code>를 활성화한다.</li><li><code>NodeDisruptionExclusion</code>: 영역(zone) 장애 시 노드가 제외되지 않도록 노드 레이블 <code>node.kubernetes.io/exclude-disruption</code>
사용을 활성화한다.</li><li><code>NodeLease</code>: 새로운 리스(Lease) API가 노드 상태 신호로 사용될 수 있는 노드 하트비트(heartbeats)를 보고할 수 있게 한다.</li><li><code>NodeOutOfServiceVolumeDetach</code>: 노드가 <code>node.kubernetes.io/out-of-service</code> 테인트를 사용하여 서비스 불가(out-of-service)로 표시되면,
노드에 있던 이 테인트를 허용하지 않는 파드는 강제로 삭제되며,
종료되는 파드에 대한 볼륨 해제(detach) 동작도 즉시 수행된다.
이로 인해 삭제된 파드가 다른 노드에서 빠르게 복구될 수 있다.</li><li><code>NodeSwap</code>: 노드의 쿠버네티스 워크로드용 스왑 메모리를 할당하려면 kubelet을 활성화한다.
반드시 <code>KubeletConfiguration.failSwapOn</code>를 false로 설정한 후 사용해야 한다.
더 자세한 정보는 <a href=/ko/docs/concepts/architecture/nodes/#swap-memory>스왑 메모리</a>를 참고한다.</li><li><code>NonPreemptingPriority</code>: 프라이어리티클래스(PriorityClass)와 파드에 <code>preemptionPolicy</code> 필드를 활성화한다.</li><li><code>OpenAPIEnums</code>: API 서버로부터 리턴된 스펙 내 OpenAPI 스키마의
"enum" 필드 채우기를 활성화한다.</li><li><code>OpenAPIV3</code>: API 서버의 OpenAPI v3 발행을 활성화한다.</li><li><code>PodDeletionCost</code>: 레플리카셋 다운스케일 시 삭제될 파드의 우선순위를 사용자가 조절할 수 있도록,
<a href=/ko/docs/concepts/workloads/controllers/replicaset/#%ED%8C%8C%EB%93%9C-%EC%82%AD%EC%A0%9C-%EB%B9%84%EC%9A%A9>파드 삭제 비용</a> 기능을 활성화한다.</li><li><code>PersistentLocalVolumes</code>: 파드에서 <code>local</code> 볼륨 유형의 사용을 활성화한다.
<code>local</code> 볼륨을 요청하는 경우 파드 어피니티를 지정해야 한다.</li><li><code>PodAffinityNamespaceSelector</code>: <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%85%80%EB%A0%89%ED%84%B0>파드 어피니티 네임스페이스 셀렉터</a>
기능과
<a href=/ko/docs/concepts/policy/resource-quotas/#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B0%84-%ED%8C%8C%EB%93%9C-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-%EC%BF%BC%ED%84%B0>CrossNamespacePodAffinity</a>
쿼터 범위 기능을 활성화한다.</li><li><code>PodAndContainerStatsFromCRI</code>: kubelet이 컨테이너와 파드에 대한 통계치들을
cAdvisor가 아닌 CRI 컨테이너 런타임으로부터 수집하도록 설정한다.</li><li><code>PodDisruptionBudget</code>: <a href=/docs/tasks/run-application/configure-pdb/>PodDisruptionBudget</a> 기능을 활성화한다.</li><li><code>PodDisruptionConditions</code>: 중단(disruption)으로 인해 파드가 삭제되고 있음을 나타내는 파드 컨디션을 추가하도록 지원한다.</li><li><code>PodHasNetworkCondition</code>: kubelet이 파드에 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-has-network>파드 네트워크 준비성</a> 컨디션을 표시하도록 지원한다.</li><li><code>PodOverhead</code>: 파드 오버헤드를 판단하기 위해 <a href=/ko/docs/concepts/scheduling-eviction/pod-overhead/>파드오버헤드(PodOverhead)</a>
기능을 활성화한다.</li><li><code>PodPriority</code>: <a href=/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/>우선 순위</a>를
기반으로 파드의 스케줄링 취소와 선점을 활성화한다.</li><li><code>PodReadinessGates</code>: 파드 준비성 평가를 확장하기 위해
<code>PodReadinessGate</code> 필드 설정을 활성화한다. 자세한 내용은 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate>파드의 준비성 게이트</a>를
참고한다.</li><li><code>PodSecurity</code>: <code>PodSecurity</code> 어드미션 플러그인을 사용하도록 설정한다.</li><li><code>PodShareProcessNamespace</code>: 파드에서 실행되는 컨테이너 간에 단일 프로세스 네임스페이스를
공유하기 위해 파드에서 <code>shareProcessNamespace</code> 설정을 활성화한다. 자세한 내용은
<a href=/docs/tasks/configure-pod-container/share-process-namespace/>파드의 컨테이너 간 프로세스 네임스페이스 공유</a>에서 확인할 수 있다.</li><li><code>PreferNominatedNode</code>: 이 플래그는 클러스터에 존재하는 다른 노드를 반복해서 검사하기 전에
지정된 노드를 먼저 검사할지 여부를
스케줄러에 알려준다.</li><li><code>ProbeTerminationGracePeriod</code>: 파드의 <a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#probe-level-terminationgraceperiodseconds>프로브-수준
<code>terminationGracePeriodSeconds</code> 설정하기</a>
기능을 활성화한다.
더 자세한 사항은 <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2238-liveness-probe-grace-period>기능개선 제안</a>을 참고한다.</li><li><code>ProcMountType</code>: SecurityContext의 <code>procMount</code> 필드를 설정하여
컨테이너의 proc 타입의 마운트를 제어할 수 있다.</li><li><code>ProxyTerminatingEndpoints</code>: <code>ExternalTrafficPolicy=Local</code>일 때 종료 엔드포인트를 처리하도록
kube-proxy를 활성화한다.</li><li><code>PVCProtection</code>: 파드에서 사용 중일 때 퍼시스턴트볼륨클레임(PVC)이
삭제되지 않도록 한다.</li><li><code>QOSReserved</code>: QoS 수준에서 리소스 예약을 허용하여 낮은 QoS 수준의 파드가
더 높은 QoS 수준에서 요청된 리소스로 파열되는 것을 방지한다
(현재 메모리만 해당).</li><li><code>ReadWriteOncePod</code>: <code>ReadWriteOncePod</code> 퍼시스턴트 볼륨 엑세스 모드를
사용한다.</li><li><code>RecoverVolumeExpansionFailure</code>: 이전에 실패했던 볼륨 확장으로부터 복구할 수 있도록,
사용자가 PVC를 더 작은 크기로 변경할 수 있도록 한다.
<a href=/ko/docs/concepts/storage/persistent-volumes/#%EB%B3%BC%EB%A5%A8-%ED%99%95%EC%9E%A5-%EC%8B%9C-%EC%98%A4%EB%A5%98-%EB%B3%B5%EA%B5%AC>볼륨 확장 시 오류 복구</a>에서
자세한 사항을 확인한다.</li><li><code>RemainingItemCount</code>: API 서버가
<a href=/docs/reference/using-api/api-concepts/#retrieving-large-results-sets-in-chunks>청크(chunking) 목록 요청</a>에 대한
응답에서 남은 항목 수를 표시하도록 허용한다.</li><li><code>RemoveSelfLink</code>: 모든 오브젝트와 콜렉션에 대해 <code>.metadata.selfLink</code> 필드를 빈 칸(빈 문자열)으로 설정한다.
이 필드는 쿠버네티스 v1.16에서 사용 중단되었다.
이 기능을 활성화하면, <code>.metadata.selfLink</code> 필드는 쿠버네티스 API에 존재하지만,
항상 빈 칸으로 유지된다.</li><li><code>RequestManagement</code>: 각 API 서버에서 우선 순위 및 공정성으로 요청 동시성을
관리할 수 있다. 1.17 이후 <code>APIPriorityAndFairness</code> 에서 사용 중단되었다.</li><li><code>ResourceLimitsPriorityFunction</code>: 입력 파드의 CPU 및 메모리 한도 중
하나 이상을 만족하는 노드에 가능한 최저 점수 1을 할당하는
스케줄러 우선 순위 기능을 활성화한다. 의도는 동일한 점수를 가진
노드 사이의 관계를 끊는 것이다.</li><li><code>ResourceQuotaScopeSelectors</code>: 리소스 쿼터 범위 셀렉터를 활성화한다.</li><li><code>RootCAConfigMap</code>: 모든 네임스페이스에 <code>kube-root-ca.crt</code>라는
<a class=glossary-tooltip title='키-값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트이다. 볼륨에서 환경 변수, 커맨드-라인 인수 또는 구성 파일로 사용될 수 있다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/configuration/configmap/ target=_blank aria-label=컨피그맵>컨피그맵</a>을 게시하도록
<code>kube-controller-manager</code> 를 구성한다. 이 컨피그맵에는 kube-apiserver에 대한 연결을 확인하는 데
사용되는 CA 번들이 포함되어 있다. 자세한 내용은
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/1205-bound-service-account-tokens/README.md>바운드 서비스 계정 토큰</a>을
참조한다.</li><li><code>RotateKubeletClientCertificate</code>: kubelet에서 클라이언트 TLS 인증서의 로테이션을 활성화한다.
자세한 내용은
<a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/#kubelet-configuration>kubelet 구성</a>을 참고한다.</li><li><code>RotateKubeletServerCertificate</code>: kubelet에서 서버 TLS 인증서의 로테이션을 활성화한다.
자세한 사항은
<a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/#kubelet-configuration>kubelet 구성</a>을 확인한다.</li><li><code>RunAsGroup</code>: 컨테이너의 init 프로세스에 설정된 기본 그룹 ID 제어를
활성화한다.</li><li><code>RuntimeClass</code>: 컨테이너 런타임 구성을 선택하기 위해 <a href=/ko/docs/concepts/containers/runtime-class/>런타임클래스(RuntimeClass)</a>
기능을 활성화한다.</li><li><code>ScheduleDaemonSetPods</code>: 데몬셋(DaemonSet) 컨트롤러 대신 기본 스케줄러로 데몬셋 파드를
스케줄링할 수 있다.</li><li><code>SCTPSupport</code>: 파드, 서비스, 엔드포인트, 엔드포인트슬라이스 및 네트워크폴리시 정의에서
<em>SCTP</em> <code>protocol</code> 값을 활성화한다.</li><li><code>SeccompDefault</code>: 모든 워크로드의 기본 구분 프로파일로
<code>RuntimeDefault</code>을 사용한다.
seccomp 프로파일은 파드 및 컨테이너 <code>securityContext</code>에 지정되어 있다.</li><li><code>SelectorIndex</code>: API 서버 감시(watch) 캐시의 레이블 및 필드 기반 인덱스를 사용하여
목록 작업을 가속화할 수 있다.</li><li><code>SELinuxMountReadWriteOncePod</code>: kubelet으로 하여금,
볼륨에 있는 모든 파일에 대해 SELinux 레이블을 재귀적으로 적용하는 대신
올바른 SELinux 레이블을 가지고 볼륨을 마운트할 수 있도록 한다.</li><li><code>ServerSideApply</code>: API 서버에서 <a href=/docs/reference/using-api/server-side-apply/>SSA(Sever Side Apply)</a>
경로를 활성화한다.</li><li><code>ServerSideFieldValidation</code>: 서버-사이드(server-side) 필드 검증을 활성화한다.
이는 리소스 스키마의 검증이 클라이언트 사이드(예: <code>kubectl create</code> 또는 <code>kubectl apply</code> 명령줄)가 아니라
API 서버 사이드에서 수행됨을 의미한다.</li><li><code>ServiceAccountIssuerDiscovery</code>: API 서버에서 서비스 어카운트 발행자에 대해 OIDC 디스커버리 엔드포인트(발급자 및
JWKS URL)를 활성화한다. 자세한 내용은
<a href=/docs/tasks/configure-pod-container/configure-service-account/#service-account-issuer-discovery>파드의 서비스 어카운트 구성</a>을
참고한다.</li><li><code>ServiceAppProtocol</code>: 서비스와 엔드포인트에서 <code>appProtocol</code> 필드를 활성화한다.</li><li><code>ServiceInternalTrafficPolicy</code>: 서비스에서 <code>internalTrafficPolicy</code> 필드를 활성화한다.</li><li><code>ServiceLBNodePortControl</code>: 서비스에서 <code>allocateLoadBalancerNodePorts</code> 필드를 활성화한다.</li><li><code>ServiceLoadBalancerClass</code>: 서비스에서 <code>loadBalancerClass</code> 필드를 활성화한다.
자세한 내용은
<a href=/ko/docs/concepts/services-networking/service/#load-balancer-class>로드밸런서 구현체의 종류 확인하기</a>를 참고한다.</li><li><code>ServiceLoadBalancerFinalizer</code>: 서비스 로드 밸런서에 대한 Finalizer 보호를 활성화한다.</li><li><code>ServiceNodeExclusion</code>: 클라우드 제공자가 생성한 로드 밸런서에서 노드를
제외할 수 있다. "<code>node.kubernetes.io/exclude-from-external-load-balancers</code>"로
레이블이 지정된 경우 노드를 제외할 수 있다.</li><li><code>ServiceTopology</code>: 서비스가 클러스터의 노드 토폴로지를 기반으로 트래픽을 라우팅할 수
있도록 한다. 자세한 내용은
<a href=/ko/docs/concepts/services-networking/service-topology/>서비스토폴로지(ServiceTopology)</a>를
참고한다.</li><li><code>ServiceIPStaticSubrange</code>: ClusterIP 범위를 분할하는
서비스 ClusterIP 할당 전략을 활성화한다.
ClusterIP 동적 할당을 주로 상위 범위에서 수행하여,
사용자가 고정 ClusterIP를 하위 범위에서 할당하는 상황에서도 충돌 확률을 낮출 수 있다.
더 자세한 사항은
<a href=/ko/docs/concepts/services-networking/service/#avoiding-collisions>충돌 방지</a>를 참고한다.</li><li><code>SetHostnameAsFQDN</code>: 전체 주소 도메인 이름(FQDN)을 파드의 호스트 이름으로
설정하는 기능을 활성화한다.
<a href=/ko/docs/concepts/services-networking/dns-pod-service/#pod-sethostnameasfqdn-field>파드의 <code>setHostnameAsFQDN</code> 필드</a>를 참고한다.</li><li><code>SizeMemoryBackedVolumes</code>: memory-backed 볼륨(보통 <code>emptyDir</code> 볼륨)의 크기 상한을
지정할 수 있도록 kubelets를 활성화한다.</li><li><code>StartupProbe</code>: kubelet에서
<a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/#%EC%96%B8%EC%A0%9C-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%ED%94%84%EB%A1%9C%EB%B8%8C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80>스타트업</a>
프로브를 활성화한다.</li><li><code>StatefulSetMinReadySeconds</code>: 스테이트풀셋 컨트롤러가 <code>minReadySeconds</code>를
반영할 수 있다.</li><li><code>StorageObjectInUseProtection</code>: 퍼시스턴트볼륨 또는 퍼시스턴트볼륨클레임 오브젝트가 여전히
사용 중인 경우 삭제를 연기한다.</li><li><code>StorageVersionAPI</code>: <a href=/docs/reference/generated/kubernetes-api/v1.25/#storageversion-v1alpha1-internal-apiserver-k8s-io>스토리지 버전 API</a>를
활성화한다.</li><li><code>StorageVersionHash</code>: API 서버가 디스커버리에서 스토리지 버전 해시를 노출하도록
허용한다.</li><li><code>StreamingProxyRedirects</code>: 스트리밍 요청을 위해 백엔드(kubelet)에서 리디렉션을
가로채서 따르도록 API 서버에 지시한다.
스트리밍 요청의 예로는 <code>exec</code>, <code>attach</code> 및 <code>port-forward</code> 요청이 있다.</li><li><code>SupportIPVSProxyMode</code>: IPVS를 사용하여 클러스터 내 서비스 로드 밸런싱을 제공한다.
자세한 내용은 <a href=/ko/docs/concepts/services-networking/service/#%EA%B0%80%EC%83%81-ip%EC%99%80-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C>서비스 프록시</a>를 참고한다.</li><li><code>SupportNodePidsLimit</code>: 노드에서 PID 제한 지원을 활성화한다.
<code>--system-reserved</code> 및 <code>--kube-reserved</code> 옵션의 <code>pid=&lt;number></code>
파라미터를 지정하여 지정된 수의 프로세스 ID가
시스템 전체와 각각 쿠버네티스 시스템 데몬에 대해 예약되도록
할 수 있다.</li><li><code>SupportPodPidsLimit</code>: 파드의 PID 제한에 대한 지원을 활성화한다.</li><li><code>SuspendJob</code>: 잡 중지/재시작 기능을 활성화한다.
자세한 내용은 <a href=/ko/docs/concepts/workloads/controllers/job/>잡 문서</a>를
참고한다.</li><li><code>Sysctls</code>: 각 파드에 설정할 수 있는 네임스페이스 커널
파라미터(sysctl)를 지원한다. 자세한 내용은
<a href=/ko/docs/tasks/administer-cluster/sysctl-cluster/>sysctl</a>을 참고한다.</li><li><code>TTLAfterFinished</code>: <a href=/ko/docs/concepts/workloads/controllers/ttlafterfinished/>TTL 컨트롤러</a>가
실행이 끝난 후 리소스를 정리하도록
허용한다.</li><li><code>TaintBasedEvictions</code>: 노드의 테인트(taint) 및 파드의 톨러레이션(toleration)을 기반으로
노드에서 파드를 축출할 수 있다.
자세한 내용은 <a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트와 톨러레이션</a>을
참고한다.</li><li><code>TaintNodesByCondition</code>: <a href=/ko/docs/concepts/architecture/nodes/#condition>노드 컨디션</a>을
기반으로 자동 테인트 노드를 활성화한다.</li><li><code>TokenRequest</code>: 서비스 어카운트 리소스에서 <code>TokenRequest</code> 엔드포인트를 활성화한다.</li><li><code>TokenRequestProjection</code>: <a href=/ko/docs/concepts/storage/volumes/#projected><code>projected</code> 볼륨</a>을 통해
서비스 어카운트 토큰을 파드에 주입할 수 있다.</li><li><code>TopologyAwareHints</code>: 엔드포인트슬라이스(EndpointSlices)에서 토폴로지 힌트 기반
토폴로지-어웨어 라우팅을 활성화한다. 자세한 내용은
<a href=/ko/docs/concepts/services-networking/topology-aware-hints/>토폴로지 인지 힌트</a>
를 참고한다.</li><li><code>TopologyManager</code>: 쿠버네티스의 다른 컴포넌트에 대한 세분화된 하드웨어 리소스
할당을 조정하는 메커니즘을 활성화한다.
<a href=/docs/tasks/administer-cluster/topology-manager/>노드의 토폴로지 관리 정책 제어</a>를 참고한다.</li><li><code>ValidateProxyRedirects</code>: 이 플래그는 API 서버가 동일한 호스트로만 리디렉션되는가를
확인해야 하는지 여부를 제어한다. <code>StreamingProxyRedirects</code>
플래그가 활성화된 경우에만 사용된다.</li><li><code>VolumeCapacityPriority</code>: 가용 PV 용량을 기반으로
여러 토폴로지에 있는 노드들의 우선순위를 정하는 기능을 활성화한다.</li><li><code>VolumePVCDataSource</code>: 기존 PVC를 데이터 소스로 지정하는 기능을 지원한다.</li><li><code>VolumeScheduling</code>: 볼륨 토폴로지 인식 스케줄링을 활성화하고
퍼시스턴트볼륨클레임(PVC) 바인딩이 스케줄링 결정을 인식하도록 한다. 또한
<code>PersistentLocalVolumes</code> 기능 게이트와 함께 사용될 때
<a href=/ko/docs/concepts/storage/volumes/#local><code>local</code></a> 볼륨 유형을 사용할 수 있다.</li><li><code>VolumeSnapshotDataSource</code>: 볼륨 스냅샷 데이터 소스 지원을 활성화한다.</li><li><code>VolumeSubpath</code>: 컨테이너에 볼륨의 하위 경로(subpath)를 마운트할 수 있다.</li><li><code>VolumeSubpathEnvExpansion</code>: 환경 변수를 <code>subPath</code>로 확장하기 위해
<code>subPathExpr</code> 필드를 활성화한다.</li><li><code>WarningHeaders</code>: API 응답에서 경고 헤더를 보낼 수 있다.</li><li><code>WatchBookmark</code>: 감시자 북마크(watch bookmark) 이벤트 지원을 활성화한다.</li><li><code>WinDSR</code>: kube-proxy가 윈도우용 DSR 로드 밸런서를 생성할 수 있다.</li><li><code>WinOverlay</code>: kube-proxy가 윈도우용 오버레이 모드에서 실행될 수 있도록 한다.</li><li><code>WindowsEndpointSliceProxying</code>: 활성화되면, 윈도우에서 실행되는 kube-proxy는
엔드포인트 대신 엔드포인트슬라이스를 기본 데이터 소스로 사용하여
확장성과 성능을 향상시킨다.
<a href=/ko/docs/concepts/services-networking/endpoint-slices/>엔드포인트슬라이스 활성화하기</a>를 참고한다.</li><li><code>WindowsGMSA</code>: 파드에서 컨테이너 런타임으로 GMSA 자격 증명 스펙을 전달할 수 있다.</li><li><code>WindowsHostProcessContainers</code>: 윈도우 HostProcess 컨테이너에 대한 지원을 사용하도록 설정한다.</li><li><code>WindowsRunAsUserName</code> : 기본 사용자가 아닌(non-default) 사용자로 윈도우 컨테이너에서
애플리케이션을 실행할 수 있도록 지원한다. 자세한 내용은
<a href=/ko/docs/tasks/configure-pod-container/configure-runasusername/>RunAsUserName 구성</a>을
참고한다.</li></ul><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/reference/using-api/deprecation-policy/>사용 중단 정책</a>은 쿠버네티스에 대한
기능과 컴포넌트를 제거하는 프로젝트의 접근 방법을 설명한다.</li><li>쿠버네티스 1.24부터, 새로운 베타 API는 기본적으로 활성화되어 있지 않다.
베타 기능을 활성화하려면, 연관된 API 리소스도 활성화해야 한다.
예를 들어, <code>storage.k8s.io/v1beta1/csistoragecapacities</code>와 같은 특정 리소스를 활성화하려면,
<code>--runtime-config=storage.k8s.io/v1beta1/csistoragecapacities</code>를 설정한다.
명령줄 플래그에 대한 상세 사항은 <a href=/ko/docs/reference/using-api/#api-%EB%B2%84%EC%A0%84-%EA%B7%9C%EC%B9%99>API 버전 규칙</a>을 참고한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a727de6cb5a090d5f115f88a8606c438>10.2 - kube-proxy</h1><h2 id=시놉시스>시놉시스</h2><p>쿠버네티스 네트워크 프록시는 각 노드에서 실행된다.
이는 각 노드의 쿠버네티스 API에 정의된 서비스를 반영하며 단순한
TCP, UDP 및 SCTP 스트림 포워딩 또는 라운드 로빈 TCP, UDP 및 SCTP 포워딩을 백엔드 셋에서 수행 할 수 있다.
서비스 클러스트 IP 및 포트는 현재 서비스 프록시에 의해 열린 포트를 지정하는
Docker-links-compatible 환경 변수를 통해 찾을 수 있다.
이러한 클러스터 IP에 클러스터 DNS를 제공하는 선택적 애드온이 있다. 유저는 apiserver API로
서비스를 생성하여 프록시를 구성해야 한다.</p><pre tabindex=0><code>kube-proxy [flags]
</code></pre><h2 id=옵션>옵션</h2><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--add_dir_header</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>true인 경우 파일 경로를 로그 메시지의 헤더에 추가한다.</p></td></tr><tr><td colspan=2>--alsologtostderr</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>파일과 함께, 표준 에러에도 로그를 출력한다.</p></td></tr><tr><td colspan=2>--bind-address string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 0.0.0.0</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>프록시 서버가 서비스할 IP 주소(모든 IPv4 인터페이스의 경우 '0.0.0.0'으로 설정, 모든 IPv6 인터페이스의 경우 '::'로 설정)</p></td></tr><tr><td colspan=2>--bind-address-hard-fail</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>true인 경우 kube-proxy는 포트 바인딩 실패를 치명적인 것으로 간주하고 종료한다.</p></td></tr><tr><td colspan=2>--boot-id-file string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: "/proc/sys/kernel/random/boot_id"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>boot-id를 위해 확인할 파일 목록(쉼표로 분리). 가장 먼저 발견되는 항목을 사용한다.</p></td></tr><tr><td colspan=2>--cleanup</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>true인 경우 iptables 및 ipvs 규칙을 제거하고 종료한다.</p></td></tr><tr><td colspan=2>--cluster-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>클러스터에 있는 파드의 CIDR 범위. 구성 후에는 이 범위 밖에서 서비스 클러스터 IP로 전송되는 트래픽은 마스커레이드되고 파드에서 외부 LoadBalancer IP로 전송된 트래픽은 대신 해당 클러스터 IP로 전송된다. 듀얼-스택(dual-stack) 클러스터의 경우, 각 IP 체계(IPv4와 IPv6)별로 최소한 하나의 CIDR을 포함하는 목록(쉼표로 분리)을 가진다. --config를 통해 설정 파일이 명시될 경우 이 파라미터는 무시된다.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>설정 파일의 경로.</p></td></tr><tr><td colspan=2>--config-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 15m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>apiserver의 설정이 갱신되는 빈도. 0보다 커야 한다.</p></td></tr><tr><td colspan=2>--conntrack-max-per-core int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 32768</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>CPU 코어당 추적할 최대 NAT 연결 수(한도(limit)를 그대로 두고 contrack-min을 무시하려면 0으로 설정한다)(</p></td></tr><tr><td colspan=2>--conntrack-min int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 131072</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>conntrack-max-per-core와 관계없이 할당할 최소 conntrack 항목 수(한도를 그대로 두려면 conntrack-max-per-core값을 0으로 설정).</p></td></tr><tr><td colspan=2>--conntrack-tcp-timeout-close-wait duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 1h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>CLOSE_WAIT 상태의 TCP 연결에 대한 NAT 시간 초과</p></td></tr><tr><td colspan=2>--conntrack-tcp-timeout-established duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 24h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>설정된 TCP 연결에 대한 유휴시간 초과(값이 0이면 그대로 유지)</p></td></tr><tr><td colspan=2>--detect-local-mode LocalMode</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>로컬 트래픽을 탐지하는 데 사용할 모드. --config를 통해 설정 파일이 명시될 경우 이 파라미터는 무시된다.</p></td></tr><tr><td colspan=2>--feature-gates &lt;쉼표로 구분된 'key=True|False' 쌍들></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>알파/실험적 기능의 기능 게이트를 나타내는 `key=value` 쌍의 집합. 사용 가능한 옵션은 다음과 같다:<br><br>APIListChunking=true|false (BETA - default=true)<br>APIPriorityAndFairness=true|false (BETA - default=true)<br>APIResponseCompression=true|false (BETA - default=true)<br>APIServerIdentity=true|false (ALPHA - default=false)<br>APIServerTracing=true|false (ALPHA - default=false)<br>AllAlpha=true|false (ALPHA - default=false)<br>AllBeta=true|false (BETA - default=false)<br>AnyVolumeDataSource=true|false (BETA - default=true)<br>AppArmor=true|false (BETA - default=true)<br>CPUManager=true|false (BETA - default=true)<br>CPUManagerPolicyAlphaOptions=true|false (ALPHA - default=false)<br>CPUManagerPolicyBetaOptions=true|false (BETA - default=true)<br>CPUManagerPolicyOptions=true|false (BETA - default=true)<br>CSIMigrationAzureFile=true|false (BETA - default=true)<br>CSIMigrationPortworx=true|false (BETA - default=false)<br>CSIMigrationRBD=true|false (ALPHA - default=false)<br>CSIMigrationvSphere=true|false (BETA - default=true)<br>CSINodeExpandSecret=true|false (ALPHA - default=false)<br>CSIVolumeHealth=true|false (ALPHA - default=false)<br>ContainerCheckpoint=true|false (ALPHA - default=false)<br>CronJobTimeZone=true|false (BETA - default=true)<br>CustomCPUCFSQuotaPeriod=true|false (ALPHA - default=false)<br>CustomResourceValidationExpressions=true|false (BETA - default=true)<br>DelegateFSGroupToCSIDriver=true|false (BETA - default=true)<br>DevicePlugins=true|false (BETA - default=true)<br>DisableCloudProviders=true|false (ALPHA - default=false)<br>DisableKubeletCloudCredentialProviders=true|false (ALPHA - default=false)<br>DownwardAPIHugePages=true|false (BETA - default=true)<br>EndpointSliceTerminatingCondition=true|false (BETA - default=true)<br>ExpandedDNSConfig=true|false (ALPHA - default=false)<br>ExperimentalHostUserNamespaceDefaulting=true|false (BETA - default=false)<br>GRPCContainerProbe=true|false (BETA - default=true)<br>GracefulNodeShutdown=true|false (BETA - default=true)<br>GracefulNodeShutdownBasedOnPodPriority=true|false (BETA - default=true)<br>HPAContainerMetrics=true|false (ALPHA - default=false)<br>HPAScaleToZero=true|false (ALPHA - default=false)<br>HonorPVReclaimPolicy=true|false (ALPHA - default=false)<br>IPTablesOwnershipCleanup=true|false (ALPHA - default=false)<br>InTreePluginAWSUnregister=true|false (ALPHA - default=false)<br>InTreePluginAzureDiskUnregister=true|false (ALPHA - default=false)<br>InTreePluginAzureFileUnregister=true|false (ALPHA - default=false)<br>InTreePluginGCEUnregister=true|false (ALPHA - default=false)<br>InTreePluginOpenStackUnregister=true|false (ALPHA - default=false)<br>InTreePluginPortworxUnregister=true|false (ALPHA - default=false)<br>InTreePluginRBDUnregister=true|false (ALPHA - default=false)<br>InTreePluginvSphereUnregister=true|false (ALPHA - default=false)<br>JobMutableNodeSchedulingDirectives=true|false (BETA - default=true)<br>JobPodFailurePolicy=true|false (ALPHA - default=false)<br>JobReadyPods=true|false (BETA - default=true)<br>JobTrackingWithFinalizers=true|false (BETA - default=true)<br>KMSv2=true|false (ALPHA - default=false)<br>KubeletCredentialProviders=true|false (BETA - default=true)<br>KubeletInUserNamespace=true|false (ALPHA - default=false)<br>KubeletPodResources=true|false (BETA - default=true)<br>KubeletPodResourcesGetAllocatable=true|false (BETA - default=true)<br>KubeletTracing=true|false (ALPHA - default=false)<br>LegacyServiceAccountTokenNoAutoGeneration=true|false (BETA - default=true)<br>LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (BETA - default=true)<br>LogarithmicScaleDown=true|false (BETA - default=true)<br>MatchLabelKeysInPodTopologySpread=true|false (ALPHA - default=false)<br>MaxUnavailableStatefulSet=true|false (ALPHA - default=false)<br>MemoryManager=true|false (BETA - default=true)<br>MemoryQoS=true|false (ALPHA - default=false)<br>MinDomainsInPodTopologySpread=true|false (BETA - default=false)<br>MixedProtocolLBService=true|false (BETA - default=true)<br>MultiCIDRRangeAllocator=true|false (ALPHA - default=false)<br>NetworkPolicyStatus=true|false (ALPHA - default=false)<br>NodeInclusionPolicyInPodTopologySpread=true|false (ALPHA - default=false)<br>NodeOutOfServiceVolumeDetach=true|false (ALPHA - default=false)<br>NodeSwap=true|false (ALPHA - default=false)<br>OpenAPIEnums=true|false (BETA - default=true)<br>OpenAPIV3=true|false (BETA - default=true)<br>PodAndContainerStatsFromCRI=true|false (ALPHA - default=false)<br>PodDeletionCost=true|false (BETA - default=true)<br>PodDisruptionConditions=true|false (ALPHA - default=false)<br>PodHasNetworkCondition=true|false (ALPHA - default=false)<br>ProbeTerminationGracePeriod=true|false (BETA - default=true)<br>ProcMountType=true|false (ALPHA - default=false)<br>ProxyTerminatingEndpoints=true|false (ALPHA - default=false)<br>QOSReserved=true|false (ALPHA - default=false)<br>ReadWriteOncePod=true|false (ALPHA - default=false)<br>RecoverVolumeExpansionFailure=true|false (ALPHA - default=false)<br>RemainingItemCount=true|false (BETA - default=true)<br>RetroactiveDefaultStorageClass=true|false (ALPHA - default=false)<br>RotateKubeletServerCertificate=true|false (BETA - default=true)<br>SELinuxMountReadWriteOncePod=true|false (ALPHA - default=false)<br>SeccompDefault=true|false (BETA - default=true)<br>ServerSideFieldValidation=true|false (BETA - default=true)<br>ServiceIPStaticSubrange=true|false (BETA - default=true)<br>ServiceInternalTrafficPolicy=true|false (BETA - default=true)<br>SizeMemoryBackedVolumes=true|false (BETA - default=true)<br>StatefulSetAutoDeletePVC=true|false (ALPHA - default=false)<br>StorageVersionAPI=true|false (ALPHA - default=false)<br>StorageVersionHash=true|false (BETA - default=true)<br>TopologyAwareHints=true|false (BETA - default=true)<br>TopologyManager=true|false (BETA - default=true)<br>UserNamespacesStatelessPodsSupport=true|false (ALPHA - default=false)<br>VolumeCapacityPriority=true|false (ALPHA - default=false)<br>WinDSR=true|false (ALPHA - default=false)<br>WinOverlay=true|false (BETA - default=true)<br>WindowsHostProcessContainers=true|false (BETA - default=true)<br><br>--config를 통해 설정 파일이 명시될 경우 이 파라미터는 무시된다.</p></td></tr><tr><td colspan=2>--healthz-bind-address ipport&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 0.0.0.0:10256</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>헬스 체크 서버가 서비스할 포트가 있는 IP 주소(모든 IPv4의 인터페이스의 경우 '0.0.0.0:10256', 모든 IPv6의 인터페이스인 경우 '[::]:10256'로 설정)이며, 사용 안 할 경우 빈칸으로 둔다. --config를 통해 설정 파일이 명시될 경우 이 파라미터는 무시된다.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>kube-proxy에 대한 도움말.</p></td></tr><tr><td colspan=2>--hostname-override string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>문자열 값이 있으면, 이 값을 실제 호스트네임 대신에 ID로 사용한다.</p></td></tr><tr><td colspan=2>--iptables-masquerade-bit int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 14</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>순수 iptable 프록시를 사용하는 경우 SNAT가 필요한 패킷을 표시하는 fwmark 스페이스 비트. [0, 31] 범위 안에 있어야 한다.</p></td></tr><tr><td colspan=2>--iptables-min-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 1s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>엔드포인트 및 서비스가 변경될 때 iptable 규칙을 새로 고칠 수 있는 빈도의 최소 간격(예: '5s', '1m', '2h22m').</p></td></tr><tr><td colspan=2>--iptables-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 30s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>iptable 규칙을 새로 고치는 빈도의 최대 간격(예: '5s', '1m', '2h22m'). 0 보다 커야 한다.</p></td></tr><tr><td colspan=2>--ipvs-exclude-cidrs stringSlice</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>IPVS 규칙을 정리할 때 ipvs 프록시가 건드리지 않아야 하는 쉼표로 구분된 CIDR 목록.</p></td></tr><tr><td colspan=2>--ipvs-min-sync-period duration</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>엔드포인트 및 서비스가 변경될 때 ipvs 규칙을 새로 고칠 수 있는 빈도의 최소 간격(예: '5s', '1m', '2h22m').</p></td></tr><tr><td colspan=2>--ipvs-scheduler string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>프록시 모드가 ipvs인 경우 ipvs 스케줄러 유형.</p></td></tr><tr><td colspan=2>--ipvs-strict-arp</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>arp_ignore를 1로 설정하고 arp_annotes를 2로 설정하여 엄격한 ARP를 사용.</p></td></tr><tr><td colspan=2>--ipvs-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 30s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ipvs 규칙이 새로 갱신되는 빈도의 최대 간격(예: '5s', '1m', '2h22m'). 0 보다 커야 한다.</p></td></tr><tr><td colspan=2>--ipvs-tcp-timeout duration</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>유휴 IPVS TCP 연결에 대한 시간 초과. 0이면 그대로 유지(예: '5s', '1m', '2h22m').</p></td></tr><tr><td colspan=2>--ipvs-tcpfin-timeout duration</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>FIN 패킷을 수신한 후 IPVS TCP 연결에 대한 시간 초과. 0이면 그대로 유지(예: '5s', '1m', '2h22m').</p></td></tr><tr><td colspan=2>--ipvs-udp-timeout duration</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>IPVS UDP 패킷에 대한 시간 초과. 0이면 그대로 유지(예: '5s', '1m', '2h22m').</p></td></tr><tr><td colspan=2>--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 10</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>쿠버네티스 api 서버와 통신하는 동안 사용할 burst.</p></td></tr><tr><td colspan=2>--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: "application/vnd.kubernetes.protobuf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>api 서버에 보낸 요청의 내용 유형.</p></td></tr><tr><td colspan=2>--kube-api-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 5</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>쿠버네티스 api 서버와 통신할 때 사용할 QPS.</p></td></tr><tr><td colspan=2>--kubeconfig string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>인증 정보가 있는 kubeconfig 파일의 경로(마스터 위치는 마스터 플래그로 설정됨).</p></td></tr><tr><td colspan=2>--log_backtrace_at &lt;'file:N' 형식의 문자열>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: :0</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>파일의 N개 줄만큼 로그를 남기게 되면, 스택 트레이스를 출력한다.</p></td></tr><tr><td colspan=2>--log_dir string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>로그 파일을 지정된 경로 아래에 쓰며, 비어있을 경우 무시된다.</p></td></tr><tr><td colspan=2>--log_file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>지정된 로그 파일을 사용하며, 비어있을 경우 무시된다.</p></td></tr><tr><td colspan=2>--log_file_max_size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 1800</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>로그 파일의 최대 크기를 MB 단위로 지정하며, 값이 0일 경우는 최대 크기에 제한이 없다.</p></td></tr><tr><td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>로그를 파일 대신 표준 에러에 출력한다.</p></td></tr><tr><td colspan=2>--machine-id-file string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: "/etc/machine-id,/var/lib/dbus/machine-id"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>machine-id를 위해 확인할 파일 목록(쉼표로 분리). 가장 먼저 발견되는 항목을 사용한다.</p></td></tr><tr><td colspan=2>--masquerade-all</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>순수 iptables 프록시를 사용하는 경우 서비스 클러스터 IP를 통해 전송된 모든 트래픽을 SNAT함(일반적으로 필요하지 않음).</p></td></tr><tr><td colspan=2>--master string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>쿠버네티스 API 서버의 주소(kubeconfig의 모든 값 덮어쓰기).</p></td></tr><tr><td colspan=2>--metrics-bind-address ipport&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 127.0.0.1:10249</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>메트릭 서버가 서비스할 포트가 있는 IP 주소(모든 IPv4 인터페이스의 경우 '0.0.0.0:10249', 모든 IPv6 인터페이스의 경우 '[::]:10249'로 설정됨)로, 사용하지 않으려면 비워둔다. --config를 통해 설정 파일이 명시될 경우 이 파라미터는 무시된다.</p></td></tr><tr><td colspan=2>--nodeport-addresses stringSlice</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>NodePort에 사용할 주소를 지정하는 값의 문자열 조각. 값은 유효한 IP 블록(예: 1.2.3.0/24, 1.2.3.4/32). 기본값인 빈 문자열 조각값은([]) 모든 로컬 주소를 사용하는 것을 의미한다.</p></td></tr><tr><td colspan=2>--one_output</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>true일 경우, 심각도 기본 레벨에서만 로그를 쓴다(false일 경우 크게 심각하지 않은 단계에서도 로그를 쓴다).</p></td></tr><tr><td colspan=2>--oom-score-adj int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: -999</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>kube-proxy 프로세스에 대한 oom-score-adj 값. 값은 [-1000, 1000] 범위 내에 있어야 한다. --config를 통해 설정 파일이 명시될 경우 이 파라미터는 무시된다.</p></td></tr><tr><td colspan=2>--pod-bridge-interface string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>클러스터 내의 브리지 인터페이스 이름으로, kube-proxy는 지정된 인터페이스로부터 발생한 트래픽을 로컬로 간주한다. DetectLocalMode가 BridgeInterface로 설정되어 있을 경우, 해당 인자도 같이 설정되어야 한다.</p></td></tr><tr><td colspan=2>--pod-interface-name-prefix string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>클러스터 내에서 인터페이스의 접두사로, kube-proxy는 지정된 접두사가 붙은 인터페이스로부터 발생한 트래픽을 로컬로 간주한다. DetectLocalMode가 InterfaceNamePrefix로 설정되어 있을 경우, 해당 인자도 같이 설정되어야 한다.</p></td></tr><tr><td colspan=2>--profiling</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>값이 true이면 /debug/pprof 핸들러에서 웹 인터페이스를 통한 프로파일링을 활성화한다. --config를 통해 설정 파일이 명시될 경우 이 파라미터는 무시된다.</p></td></tr><tr><td colspan=2>--proxy-mode ProxyMode</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>사용할 프록시 모드: 'iptables' (리눅스), 'ipvs' (리눅스), 'kernelspace' (윈도우), 또는 'userspace' (리눅스/윈도우, 지원 중단). 리눅스에서의 기본값은 'iptables'이며, 윈도우에서의 기본값은 'userspace'(추후 'kernelspace'로 변경될 예정)이다. --config를 통해 설정 파일이 명시될 경우 이 파라미터는 무시된다.</p></td></tr><tr><td colspan=2>--proxy-port-range port-range</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>서비스 트래픽을 프록시하기 위해 사용할 수 있는 호스트 포트 범위(beginPort-endPort, single port 또는 beginPort+offset 포함). 만약 범위가 0, 0-0, 혹은 지정되지 않으면, 포트는 무작위로 선택된다.</p></td></tr><tr><td colspan=2>--show-hidden-metrics-for-version string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>숨겨진 메트릭을 표시하려는 이전 버전. 이전 마이너 버전만 인식하며, 다른 값은 허용하지 않는다. 포멧은 &lt;메이저>.&lt;마이너> 와 같으며, 예를 들면 '1.16' 과 같다. 이 포멧의 목적은, 다음 릴리스가 숨길 추가적인 메트릭을 사용자에게 공지하여, 그 이후 릴리스에서 메트릭이 영구적으로 삭제됐을 때 사용자가 놀라지 않도록 하기 위함이다. --config를 통해 설정 파일이 명시될 경우 이 파라미터는 무시된다.</p></td></tr><tr><td colspan=2>--skip_headers</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>true일 경우, 로그 메시지에 헤더를 쓰지 않는다.</p></td></tr><tr><td colspan=2>--skip_log_headers</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>true일 경우, 로그 파일을 열 때 헤더를 보여주지 않는다.</p></td></tr><tr><td colspan=2>--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 2</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>해당 임계값 이상의 로그를 표준에러로 보낸다.</p></td></tr><tr><td colspan=2>--udp-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본값: 250ms</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>유휴 UDP 연결이 열린 상태로 유지되는 시간(예: '250ms', '2s'). 값은 0보다 커야 한다. 프록시 모드 userspace에만 적용 가능함.</p></td></tr><tr><td colspan=2>-v, --v int</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>로그 상세 레벨(verbosity) 값</p></td></tr><tr><td colspan=2>--version version[=true]</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>버전 정보를 출력하고 종료</p></td></tr><tr><td colspan=2>--vmodule &lt;쉼표로 구분된 'pattern=N' 설정들></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>파일 필터 로깅을 위한 pattern=N 설정 목록(쉼표로 분리).</p></td></tr><tr><td colspan=2>--write-config-to string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>기본 구성 값을 이 파일에 옮겨쓰고 종료한다.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-f8b023454daa9497b7eea35b7d35c075>11 - 스케줄링</h1></div><div class=td-content><h1 id=pg-ef4fb938b6b63c95f5f26f9b1cec3054>11.1 - 스케줄러 구성</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.25 [stable]</code></div><p>구성 파일을 작성하고 해당 경로를 커맨드 라인 인수로 전달하여
<code>kube-scheduler</code> 의 동작을 사용자 정의할 수 있다.</p><p>스케줄링 프로파일(Profile)을 사용하면 <a class=glossary-tooltip title='노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>에서
여러 단계의 스케줄링을 구성할 수 있다.
각 단계는 익스텐션 포인트(extension point)를 통해 노출된다. 플러그인은 이러한
익스텐션 포인트 중 하나 이상을 구현하여 스케줄링 동작을 제공한다.</p><p>KubeSchedulerConfiguration (<a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>v1beta3</a>
또는 <a href=/docs/reference/config-api/kube-scheduler-config.v1/>v1</a>)
구조에 맞게 파일을 작성하고,
<code>kube-scheduler --config &lt;filename></code>을 실행하여
스케줄링 프로파일을 지정할 수 있다.</p><p>최소 구성은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clientConnection</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeconfig</span>:<span style=color:#bbb> </span>/etc/srv/kubernetes/kube-scheduler/kubeconfig<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> KubeSchedulerConfiguration <a href=/docs/reference/config-api/kube-scheduler-config.v1beta2/>v1beta2</a>는
v1.25부터 사용 중단되었고 v1.26부터 제거된다. KubeSchedulerConfiguration을
<a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>v1beta3</a> 또는 <a href=/docs/reference/config-api/kube-scheduler-config.v1/>v1</a>로 전환한 뒤에
쿠버네티스를 v1.25로 업그레이드하도록 한다.</div><h2 id=프로파일>프로파일</h2><p>스케줄링 프로파일을 사용하면 <a class=glossary-tooltip title='노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>에서
여러 단계의 스케줄링을 구성할 수 있다.
각 단계는 <a href=#%EC%9D%B5%EC%8A%A4%ED%85%90%EC%85%98-%ED%8F%AC%EC%9D%B8%ED%8A%B8>익스텐션 포인트</a>에 노출된다.
<a href=#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8>플러그인</a>은 이러한 익스텐션 포인트 중
하나 이상을 구현하여 스케줄링 동작을 제공한다.</p><p><code>kube-scheduler</code> 의 단일 인스턴스를 구성하여
<a href=#%EC%97%AC%EB%9F%AC-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC>여러 프로파일</a>을 실행할 수 있다.</p><h3 id=익스텐션-포인트>익스텐션 포인트</h3><p>스케줄링은 다음 익스텐션 포인트를 통해 노출되는 일련의 단계에서
발생한다.</p><ol><li><code>queueSort</code>: 이 플러그인은 스케줄링 대기열에서 보류 중인 파드를
정렬하는 데 사용되는 정렬 기능을 제공한다. 대기열 정렬 플러그인은 한 번에 단 하나만 활성화될 수 있다.
사용할 수 있다.</li><li><code>preFilter</code>: 이 플러그인은 필터링하기 전에 파드 또는 클러스터에 대한 정보를
사전 처리하거나 확인하는 데 사용된다. 이 플러그인은 파드를 unschedulable로
표시할 수 있다.</li><li><code>filter</code>: 이 플러그인은 스케줄링 정책의 단정(Predicates)과 동일하며
파드를 실행할 수 없는 노드를 필터링하는 데 사용된다. 필터는
구성된 순서대로 호출된다. 노드가 모든 필터를 통과하지 않으면 파드는 unschedulable로
표시된다.</li><li><code>postFilter</code>: 이 플러그인은 파드의 실행 가능한 노드를 찾을 수 없을 때,
구성된 순서대로 호출된다. <code>postFilter</code> 플러그인이 파드 <em>schedulable</em> 을 표시하는 경우,
나머지 플러그인은 호출 되지 않는다.</li><li><code>preScore</code>: 이것은 사전 스코어링 작업을 수행하는 데 사용할 수 있는
정보성 익스텐션 포인트이다.</li><li><code>score</code>: 이 플러그인은 필터링 단계를 통과한 각 노드에 점수를
제공한다. 그런 다음 스케줄러는 가중치 합계가 가장 높은
노드를 선택한다.</li><li><code>reserve</code>: 지정된 파드에 리소스가 예약된 경우 플러그인에
알리는 정보성 익스텐션 포인트이다. 플러그인은 또한
<code>Reserve</code> 도중 또는 이후에 실패한 경우 호출 되는 <code>Unreserve</code> 호출을
구현한다.</li><li><code>permit</code>: 이 플러그인은 파드 바인딩을 방지하거나 지연시킬 수 있다.</li><li><code>preBind</code>: 이 플러그인은 파드가 바인딩되기 전에 필요한 모든 작업을 수행한다.</li><li><code>bind</code>: 플러그인은 파드를 노드에 바인딩한다. <code>bind</code> 플러그인은 순서대로 호출되며
일단 바인딩이 완료되면 나머지 플러그인은 건너뛴다. bind
플러그인은 적어도 하나 이상 필요하다.</li><li><code>postBind</code>: 파드가 바인드된 후 호출되는
정보성 익스텐션 포인트이다.</li><li><code>multiPoint</code>: 이 필드는 플러그인들의 모든 적용 가능한 익스텐션 포인트에 대해
플러그인들을 동시에 활성화하거나 비활성화할 수 있게 하는 환경 설정 전용 필드이다.</li></ol><p>각 익스텐션 포인트에 대해 특정 <a href=#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8>기본 플러그인</a>을 비활성화하거나
자체 플러그인을 활성화할 수 있다. 예를 들면, 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodTopologySpread<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyCustomPluginA<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyCustomPluginB<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>비활성화된 배열의 이름으로 <code>*</code> 를 사용하여 해당 익스텐션 포인트에 대한
모든 기본 플러그인을 비활성화할 수 있다. 원하는 경우, 플러그인 순서를 재정렬하는 데
사용할 수도 있다.</p><h3 id=scheduling-plugins>스케줄링 플러그인</h3><p>기본적으로 활성화된 다음의 플러그인은 이들 익스텐션 포인트 중
하나 이상을 구현한다.</p><ul><li><code>ImageLocality</code>: 파드가 실행하는 컨테이너 이미지가 이미 있는 노드를
선호한다.
익스텐션 포인트: <code>score</code>.</li><li><code>TaintToleration</code>: <a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>테인트(taint)와 톨러레이션(toleration)</a>을
구현한다.
익스텐션 포인트 구현: <code>filter</code>, <code>preScore</code>, <code>score</code>.</li><li><code>NodeName</code>: 파드 명세 노드 이름이 현재 노드와 일치하는지 확인한다.
익스텐션 포인트: <code>filter</code>.</li><li><code>NodePorts</code>: 노드에 요청된 파드 포트에 대해 사용 가능한 포트가 있는지 확인한다.
익스텐션 포인트: <code>preFilter</code>, <code>filter</code>.</li><li><code>NodeAffinity</code>: <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EB%85%B8%EB%93%9C-%EC%85%80%EB%A0%89%ED%84%B0-nodeselector>노드 셀렉터</a>와
<a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EB%85%B8%EB%93%9C-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0>노드 어피니티</a>를
구현한다.
익스텐션 포인트: <code>filter</code>, <code>score</code>.</li><li><code>PodTopologySpread</code>: <a href=/ko/docs/concepts/scheduling-eviction/topology-spread-constraints/>파드 토폴로지 분배 제약 조건</a>을
구현한다.
익스텐션 포인트: <code>preFilter</code>, <code>filter</code>, <code>preScore</code>, <code>score</code>.</li><li><code>NodeUnschedulable</code>: <code>.spec.unschedulable</code> 이 true로 설정된 노드를
필터링한다.
익스텐션 포인트: <code>filter</code>.</li><li><code>NodeResourcesFit</code>: 노드에 파드가 요청하는 모든 리소스가 있는지
확인한다. 점수는 <code>LeastAllocated</code>(기본값), <code>MostAllocated</code>, <code>RequestedToCapacityRatio</code> 등
3가지 전략 중 하나를 사용할 수 있다.
익스텐션 포인트: <code>preFilter</code>, <code>filter</code>, <code>score</code>.</li><li><code>NodeResourcesBalancedAllocation</code>: 파드가 스케줄된 경우, 보다 균형잡힌 리소스 사용량을
얻을 수 있는 노드를 선호한다.
익스텐션 포인트: <code>score</code>.</li><li><code>VolumeBinding</code>: 노드에 요청된 <a class=glossary-tooltip title='데이터를 포함하고 있는 디렉터리이며, 파드의 컨테이너에서 접근 가능하다.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/storage/volumes/ target=_blank aria-label=볼륨>볼륨</a>이 있는지
또는 바인딩할 수 있는지 확인한다.
익스텐션 포인트: <code>preFilter</code>, <code>filter</code>, <code>reserve</code>, <code>preBind</code>, <code>score</code>.<div class="alert alert-info note callout" role=alert><strong>참고:</strong> <code>score</code> 익스텐션 포인트는 <code>VolumeCapacityPriority</code> 기능이
활성화되어 있어야 활성화되며,
요청된 볼륨 사이즈를 만족하는 가장 작은 PV들을 우선순위 매긴다.</div></li><li><code>VolumeRestrictions</code>: 노드에 마운트된 볼륨이 볼륨 제공자에 특정한
제한 사항을 충족하는지 확인한다.
익스텐션 포인트: <code>filter</code>.</li><li><code>VolumeZone</code>: 요청된 볼륨이 가질 수 있는 영역 요구 사항을 충족하는지
확인한다.
익스텐션 포인트: <code>filter</code>.</li><li><code>NodeVolumeLimits</code>: 노드에 대해 CSI 볼륨 제한을 충족할 수 있는지
확인한다.
익스텐션 포인트: <code>filter</code>.</li><li><code>EBSLimits</code>: 노드에 대해 AWS EBS 볼륨 제한을 충족할 수 있는지 확인한다.
익스텐션 포인트: <code>filter</code>.</li><li><code>GCEPDLimits</code>: 노드에 대해 GCP-PD 볼륨 제한을 충족할 수 있는지 확인한다.
익스텐션 포인트: <code>filter</code>.</li><li><code>AzureDiskLimits</code>: 노드에 대해 Azure 디스크 볼륨 제한을 충족할 수 있는지
확인한다.
익스텐션 포인트: <code>filter</code>.</li><li><code>InterPodAffinity</code>: <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%ED%8C%8C%EB%93%9C%EA%B0%84-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0%EC%99%80-%EC%95%88%ED%8B%B0-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0>파드 간 어피니티 및 안티-어피니티</a>를
구현한다.
익스텐션 포인트: <code>preFilter</code>, <code>filter</code>, <code>preScore</code>, <code>score</code>.</li><li><code>PrioritySort</code>: 기본 우선 순위 기반 정렬을 제공한다.
익스텐션 포인트: <code>queueSort</code>.</li><li><code>DefaultBinder</code>: 기본 바인딩 메커니즘을 제공한다.
익스텐션 포인트: <code>bind</code>.</li><li><code>DefaultPreemption</code>: 기본 선점 메커니즘을 제공한다.
익스텐션 포인트: <code>postFilter</code>.</li></ul><p>기본으로 활성화되지 않는 다음의 플러그인을
컴포넌트 구성 API를 통해 활성화할 수도 있다.</p><ul><li><code>CinderLimits</code>: 노드에 대해 <a href=https://docs.openstack.org/cinder/>OpenStack Cinder</a>
볼륨 제한이 충족될 수 있는지 확인한다.
익스텐션 포인트: <code>filter</code>.</li></ul><h3 id=여러-프로파일>여러 프로파일</h3><p>둘 이상의 프로파일을 실행하도록 <code>kube-scheduler</code> 를 구성할 수 있다.
각 프로파일에는 연관된 스케줄러 이름이 있으며 <a href=#%EC%9D%B5%EC%8A%A4%ED%85%90%EC%85%98-%ED%8F%AC%EC%9D%B8%ED%8A%B8>익스텐션 포인트</a>에 구성된
다른 플러그인 세트를 가질 수 있다.</p><p>다음의 샘플 구성을 사용하면, 스케줄러는 기본 플러그인이 있는
프로파일과 모든 스코어링 플러그인이 비활성화된 프로파일의 두 가지 프로파일로
실행된다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>default-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>no</span>-scoring-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preScore</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>특정 프로파일에 따라 스케줄하려는 파드는
<code>.spec.schedulerName</code> 에 해당 스케줄러 이름을 포함할 수 있다.</p><p>기본적으로, 스케줄러 이름 <code>default-scheduler</code> 를 가진 하나의 프로파일이 생성된다.
이 프로파일에는 위에서 설명한 기본 플러그인이 포함되어 있다. 둘 이상의
프로파일을 선언할 때, 각각에 대한 고유한 스케줄러 이름이 필요하다.</p><p>파드가 스케줄러 이름을 지정하지 않으면, kube-apiserver는 이를 <code>default-scheduler</code> 로
설정한다. 따라서, 해당 파드를 스케줄하려면 이 스케줄러 이름을 가진 프로파일이
있어야 한다.</p><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 파드의 스케줄링 이벤트에는 ReportingController로 <code>.spec.schedulerName</code> 이 있다.
리더 선출을 위한 이벤트는 목록에서 첫 번째 프로파일의 스케줄러 이름을
사용한다.</div><div class="alert alert-info note callout" role=alert><strong>참고:</strong> 모든 프로파일은 <code>queueSort</code> 익스텐션 포인트에서 동일한 플러그인을 사용해야 하며
동일한 구성 파라미터(해당하는 경우)를 가져야 한다. 그 이유는 스케줄러가 보류 중 상태인 파드 대기열을
단 하나만 가질 수 있기 때문이다.</div><h3 id=multipoint>다수의 익스텐션 포인트에 플러그인 적용하기</h3><p><code>kubescheduler.config.k8s.io/v1beta3</code> 부터,
다수의 익스텐션 포인트에 대해 플러그인을 쉽게 활성화하거나
비활성화할 수 있게 하는 프로파일 환경 설정 <code>multiPoint</code> 가 추가되었다.
이를 사용하여 사용자와 관리자가 커스텀 프로파일을 사용할 때 환경 설정을 간소화할 수 있다.</p><p><code>preScore</code>, <code>score</code>, <code>preFilter</code>, <code>filter</code> 익스텐션 포인트가 있는 <code>MyPlugin</code> 이라는 플러그인이 있다고 가정하자.
모든 사용 가능한 익스텐션 포인트에 대해 <code>MyPlugin</code> 을 활성화하려면,
다음과 같은 프로파일 환경 설정을 사용한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>multipoint-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>multiPoint</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyPlugin<span style=color:#bbb>
</span></span></span></code></pre></div><p>위의 예시는 아래와 같이 모든 익스텐션 포인트에 대해 <code>MyPlugin</code> 을 수동으로 활성화하는 것과
동일한 효과를 갖는다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>non-multipoint-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preScore</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyPlugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyPlugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preFilter</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyPlugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>filter</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyPlugin<span style=color:#bbb>
</span></span></span></code></pre></div><p>여기서 <code>multiPoint</code> 를 사용했을 때의 이점은,
추후 <code>MyPlugin</code> 이 다른 익스텐션 포인트에 대한 구현을 추가했을 때,
새로운 익스텐션에 대해서도 <code>multiPoint</code> 환경 설정이 자동으로 활성화될 것이라는 점이다.</p><p><code>disabled</code> 필드를 사용하여, <code>MultiPoint</code> 확장으로부터 특정 익스텐션 포인트를 제외할 수 있다.
기본 플러그인을 비활성화하거나, 기본이 아닌(non-default) 플러그인을 비활성화하거나,
와일드카드(<code>'*'</code>)를 사용하여 모든 플러그인을 비활성화할 수 있다.
다음은 <code>Score</code> 와 <code>PreScore</code> 에 대해 비활성화하는 예시이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>non-multipoint-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>multiPoint</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;MyPlugin&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preScore</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>kubescheduler.config.k8s.io/v1beta3</code> 부터, <code>MultiPoint</code> 필드를 통해
내부적으로 모든 <a href=#scheduling-plugins>기본 플러그인</a>이 활성화된다.
그러나, 개별 익스텐션 포인트에 대해 기본값(예: 순서, Score 가중치)을 유연하게 재설정하는 것도 여전히 가능하다.
예를 들어, 2개의 Score 플러그인 <code>DefaultScore1</code> 과 <code>DefaultScore2</code> 가 있고
각각의 가중치가 <code>1</code> 이라고 하자.
이 때, 다음과 같이 가중치를 다르게 설정하여 순서를 바꿀 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>multipoint-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultScore2&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>이 예제에서, 이 플러그인들을 <code>MultiPoint</code> 에 명시할 필요는 없는데,
이는 이 플러그인들이 기본 플러그인이기 때문이다.
그리고 <code>Score</code> 에는 <code>DefaultScore2</code> 플러그인만 명시되었다.
이는 익스텐션 포인트를 명시하여 설정된 플러그인은 언제나 <code>MultiPoint</code> 플러그인보다 우선순위가 높기 때문이다.
결론적으로, 위의 예시에서는 두 플러그인을 모두 명시하지 않고도 두 플러그인의 순서를 조정하였다.</p><p><code>MultiPoint</code> 플러그인을 설정할 때, 일반적인 우선 순위는 다음과 같다.</p><ol><li>명시된 익스텐션 포인트가 먼저 실행되며, 여기에 명시된 환경 설정은 다른 모든 곳에 설정된 내용보다 우선한다.</li><li><code>MultiPoint</code> 및 플러그인 설정을 통해 수동으로 구성된 플러그인</li><li>기본 플러그인 및 기본 플러그인의 기본 설정</li></ol><p>위의 우선 순위를 설명하기 위해, 다음과 같은 예시를 가정한다.</p><table><thead><tr><th>플러그인</th><th>익스텐션 포인트</th></tr></thead><tbody><tr><td><code>DefaultQueueSort</code></td><td><code>QueueSort</code></td></tr><tr><td><code>CustomQueueSort</code></td><td><code>QueueSort</code></td></tr><tr><td><code>DefaultPlugin1</code></td><td><code>Score</code>, <code>Filter</code></td></tr><tr><td><code>DefaultPlugin2</code></td><td><code>Score</code></td></tr><tr><td><code>CustomPlugin1</code></td><td><code>Score</code>, <code>Filter</code></td></tr><tr><td><code>CustomPlugin2</code></td><td><code>Score</code>, <code>Filter</code></td></tr></tbody></table><p>이들 플러그인에 대한 유효한 예시 환경 설정은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>multipoint-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>multiPoint</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomQueueSort&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomPlugin1&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomPlugin2&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultQueueSort&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>filter</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin1&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin2&#39;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>명시한 익스텐션 포인트 내에 <code>MultiPoint</code> 플러그인을 재정의해도 에러가 발생하지 않음에 유의한다.
명시한 익스텐션 포인트의 우선 순위가 더 높으므로,
이 재정의는 무시되고 로그에만 기록된다.</p><p>대부분의 환경 설정을 한 곳에서 관리하는 것 말고도, 이 예시는 다음과 같은 내용을 포함한다.</p><ul><li>커스텀 <code>queueSort</code> 플러그인을 활성화하고 기존의 기본 플러그인을 비활성화한다</li><li><code>CustomPlugin1</code> 과 <code>CustomPlugin2</code> 플러그인을 활성화하며, 이 플러그인에 연결된 모든 익스텐션 포인트를 위해 이 플러그인들이 먼저 실행된다</li><li><code>filter</code> 에 대해서만 <code>DefaultPlugin1</code> 을 비활성화한다</li><li><code>score</code> 에 대해, <code>DefaultPlugin2</code> 플러그인이 (심지어 커스텀 플러그인보다도) 가장 먼저 실행되도록 순서를 조정한다</li></ul><p><code>multiPoint</code> 필드가 없는 <code>v1beta3</code> 이전 버전의 환경 설정에서는, 위의 스니펫을 다음과 같이 표현할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>multipoint-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 기본 QueueSort 플러그인을 비활성화한다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>queueSort</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomQueueSort&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultQueueSort&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 커스텀 Filter 플러그인을 활성화한다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>filter</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomPlugin1&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;CustomPlugin2&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin2&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin1&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 커스텀 score 플러그인을 활성화하고 순서를 조정한다</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin2&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;DefaultPlugin1&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>다소 복잡한 예시를 통해, 익스텐션 포인트를 설정함에 있어서 <code>MultiPoint</code> 환경 설정의 유연성과
기존 방법과의 끊김없는 통합을 확인할 수 있다.</p><h2 id=스케줄러-설정-전환>스케줄러 설정 전환</h2><ul class="nav nav-tabs" id=tab-with-md role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-with-md-0 role=tab aria-controls=tab-with-md-0 aria-selected=true>v1beta1 → v1beta2</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-md-1 role=tab aria-controls=tab-with-md-1>v1beta2 → v1beta3</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-md-2 role=tab aria-controls=tab-with-md-2>v1beta3 → v1</a></li></ul><div class=tab-content id=tab-with-md><div id=tab-with-md-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-with-md-0><p><ul><li><p>설정 버전 v1beta2 에서는, <code>NodeResourcesFit</code> 플러그인을 위한 새로운 스코어링 확장을
이용할 수 있다.
새 확장은 <code>NodeResourcesLeastAllocated</code>, <code>NodeResourcesMostAllocated</code>,
<code>RequestedToCapacityRatio</code> 플러그인의 기능을 통합하여 제공한다.
예를 들어, 이전에 <code>NodeResourcesMostAllocated</code> 플러그인을 사용했다면,
대신 <code>NodeResourcesFit</code>(기본적으로 활성화되어 있음)을 사용하면서
다음과 같이 <code>scoreStrategy</code>를 포함하는 <code>pluginConfig</code>를 추가할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>scoringStrategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>MostAllocated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>NodeResourcesFit<span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p>스케줄러 플러그인 <code>NodeLabel</code>은 사용 중단되었다. 대신, 비슷한 효과를 얻기 위해 <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-affinity-%EC%99%80-%EC%95%88%ED%8B%B0-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0-anti-affinity><code>NodeAffinity</code></a> 플러그인(기본적으로 활성화되어 있음)을 사용한다.</p></li><li><p>스케줄러 플러그인 <code>ServiceAffinity</code>은 사용 중단되었다. 대신, 비슷한 효과를 얻기 위해 <a href=/ko/docs/concepts/scheduling-eviction/assign-pod-node/#%ED%8C%8C%EB%93%9C%EA%B0%84-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0%EC%99%80-%EC%95%88%ED%8B%B0-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0><code>InterPodAffinity</code></a> 플러그인(기본적으로 활성화되어 있음)을 사용한다.</p></li><li><p>스케줄러 플러그인 <code>NodePreferAvoidPods</code>은 사용 중단되었다. 대신, 비슷한 효과를 얻기 위해 <a href=/ko/docs/concepts/scheduling-eviction/taint-and-toleration/>노드 테인트</a>를 사용한다.</p></li><li><p>v1beta2 설정 파일에서 활성화된 플러그인은 해당 플러그인의 기본 설정값보다 v1beta2 설정 파일의 값이 우선 적용된다.</p></li><li><p>스케줄러 healthz와 metrics 바인드 주소에 대해 <code>host</code> 또는 <code>port</code> 가 잘못 설정되면 검증 실패를 유발한다.</p></li></ul></div><div id=tab-with-md-1 class=tab-pane role=tabpanel aria-labelledby=tab-with-md-1><p><ul><li>세 플러그인의 가중치 기본값이 다음과 같이 증가한다.<ul><li><code>InterPodAffinity</code>: 1 에서 2 로</li><li><code>NodeAffinity</code>: 1 에서 2 로</li><li><code>TaintToleration</code>: 1 에서 3 으로</li></ul></li></ul></div><div id=tab-with-md-2 class=tab-pane role=tabpanel aria-labelledby=tab-with-md-2><p><ul><li>스케줄러 플러그인 <code>SelectorSpread</code>는 제거되었다. 대신, 비슷한 효과를 얻기 위해
<code>PodTopologySpread</code> 플러그인(기본적으로 활성화되어 있음)을 사용한다.</li></ul></div></div><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler 레퍼런스</a> 읽어보기</li><li><a href=/ko/docs/concepts/scheduling-eviction/kube-scheduler/>스케줄링</a>에 대해 알아보기</li><li><a href=/docs/reference/config-api/kube-scheduler-config.v1beta2/>kube-scheduler 설정 (v1beta2)</a> 레퍼런스 읽어보기</li><li><a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler 설정 (v1beta3)</a> 레퍼런스 읽어보기</li><li><a href=/docs/reference/config-api/kube-scheduler-config.v1/>kube-scheduler 설정 (v1)</a> 레퍼런스 읽어보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5a0a68fb6a7ffefb6d5f861100fa0ae3>11.2 - 스케줄링 정책</h1><p>쿠버네티스 v1.23 이전 버전에서는, <em>단정(predicates)</em> 및 <em>우선순위(priorities)</em> 프로세스를 지정하기 위해 스케줄링 정책을 사용할 수 있다.
예를 들어, <code>kube-scheduler --policy-config-file &lt;filename></code> 또는 <code>kube-scheduler --policy-configmap &lt;ConfigMap></code> 명령을 실행하여 스케줄링 정책을 설정할 수 있다.</p><p>이러한 스케줄링 정책은 쿠버네티스 v1.23 버전부터 지원되지 않는다. 관련된 플래그인 <code>policy-config-file</code>, <code>policy-configmap</code>, <code>policy-configmap-namespace</code>, <code>use-legacy-policy-config</code> 플래그도 지원되지 않는다. 대신, 비슷한 효과를 얻기 위해 <a href=/ko/docs/reference/scheduling/config/>스케줄러 구성</a>을 사용한다.</p><h2 id=다음-내용>다음 내용</h2><ul><li><a href=/ko/docs/concepts/scheduling-eviction/kube-scheduler/>스케줄링</a>에 대해 배우기</li><li><a href=/docs/reference/scheduling/profiles/>kube-scheduler 프로파일</a>에 대해 배우기</li><li><a href=/docs/reference/config-api/kube-scheduler-config.v1/>kube-scheduler configuration 레퍼런스 (v1)</a> 읽어보기</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c808ce38575e73f72835d7ed02b03780>12 - 도구</h1><p>쿠버네티스는 쿠버네티스 시스템으로 작업하는 데 도움이 되는 몇 가지 도구를 포함한다.</p><h2 id=crictl>crictl</h2><p><a href=https://github.com/kubernetes-sigs/cri-tools><code>crictl</code></a>은
<a class=glossary-tooltip title='Kubelet과 컨테이너 런타임을 통합시키기 위한 API' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/components/#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%9f%b0%ed%83%80%ec%9e%84 target=_blank aria-label=CRI>CRI</a>-호환 컨테이너 런타임의 조사 및 디버깅을 위한
명령줄 인터페이스이다.</p><h2 id=대시보드>대시보드</h2><p><a href=/ko/docs/tasks/access-application-cluster/web-ui-dashboard/><code>대시보드</code></a>는
쿠버네티스의 웹기반 유저 인터페이스이며
컨테이너화된 애플리케이션을 쿠버네티스 클러스터로 배포하고 클러스터 및 클러스터 자원의 문제를 해결하며 관리할 수 있게 해 준다.</p><h2 id=helm>Helm</h2><div class="alert alert-secondary callout third-party-content" role=alert>&#128711; 이 항목은 쿠버네티스에 속하지 않는 써드파티 프로젝트 또는 제품의 링크로 연결됩니다. <a class=alert-more-info href=#third-party-content-disclaimer>추가 정보</a></div><p><a href=https://helm.sh/>Helm</a>은 사전 구성된 쿠버네티스 리소스 패키지를 관리하기 위한 도구이다.
이 패키지는 <em>Helm charts</em> 라고 알려져 있다.</p><p>Helm의 용도</p><ul><li>쿠버네티스 차트로 배포된 인기있는 소프트웨어를 검색하고 사용</li><li>쿠버네티스 차트로 나의 애플리케이션을 공유</li><li>쿠버네티스 애플리케이션의 반복가능한 빌드 및 생성</li><li>매니페스트 파일의 지능화된 관리</li><li>Helm 패키지의 릴리스 관리</li></ul><h2 id=kompose>Kompose</h2><p><a href=https://github.com/kubernetes/kompose><code>Kompose</code></a>는 도커 컴포즈(Compose) 유저들이 쿠버네티스로 이동하는데 도움이 되는 도구이다.</p><p>Kompose의 용도</p><ul><li>도커 컴포즈 파일을 쿠버네티스 오브젝트로 변환</li><li>로컬 도커 개발 환경에서 나의 애플리케이션을 쿠버네티스를 통해 관리하도록 이전</li><li>V1 또는 V2 도커 컴포즈 <code>yaml</code> 파일 또는 <a href=https://docs.docker.com/compose/bundles/>분산 애플리케이션 번들</a>을 변환</li></ul><h2 id=kui>Kui</h2><p><a href=https://github.com/kubernetes-sigs/kui><code>Kui</code></a>는 입력으로 일반적인 <code>kubectl</code> 커맨드 라인 요청을 받고
출력으로 그래픽적인 응답을 제공하는 GUI 도구이다.</p><p>Kui는 입력으로 일반적인 <code>kubectl</code> 커맨드 라인 요청을 받고 출력으로 그래픽적인 응답을 제공한다.
Kui는 ASCII 표 대신 정렬 가능한 표를 GUI로 제공한다.</p><p>Kui를 사용하면 다음의 작업이 가능하다.</p><ul><li>자동으로 생성되어 길이가 긴 리소스 이름을 클릭하여 복사할 수 있다.</li><li><code>kubectl</code> 명령을 입력하면 실행되는 모습을 볼 수 있으며, <code>kubectl</code> 보다 더 빠른 경우도 있다.</li><li><a class=glossary-tooltip title='완료를 목표로 실행되는 유한 또는 배치 작업.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/workloads/controllers/job/ target=_blank aria-label=잡>잡</a>을 조회하여
실행 형상을 워터폴 그림으로 확인한다.</li><li>탭이 있는 UI를 이용하여 클러스터의 자원을 클릭 동작으로 확인할 수 있다.</li></ul><h2 id=minikube>Minikube</h2><p><a href=https://minikube.sigs.k8s.io/docs/><code>minikube</code></a>는 개발과 테스팅 목적으로
단일 노드 쿠버네티스 클러스터를 로컬 워크스테이션에서
실행하는 도구이다.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>