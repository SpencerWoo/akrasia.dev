<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/access-authn-authz/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/access-authn-authz/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/access-authn-authz/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/access-authn-authz/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/reference/access-authn-authz/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/reference/access-authn-authz/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>API 접근 제어 | Kubernetes</title><meta property="og:title" content="API 접근 제어"><meta property="og:description" content="운영 수준의 컨테이너 오케스트레이션"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/reference/access-authn-authz/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="API 접근 제어"><meta itemprop=description content="운영 수준의 컨테이너 오케스트레이션"><meta name=twitter:card content="summary"><meta name=twitter:title content="API 접근 제어"><meta name=twitter:description content="운영 수준의 컨테이너 오케스트레이션"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="쿠버네티스가 API 접근을 구현 및 제어하는 방법에 대한 자세한 내용은 쿠버네티스 API에 대한 접근 제어를 참고한다.
참조 문헌
인증 부트스트랩 토큰 인증 승인 컨트롤러 동적 승인 제어 인가 역할 기반 접근 제어 속성 기반 접근 제어 노드 인가 웹훅 인가 인증서 서명 요청 CSR 승인과 인증서 서명을 포함함 서비스 어카운트 개발자 가이드 관리 kubelet 인증과 인가 kubelet TLS 부트스트래핑을 포함함 "><meta property="og:description" content="쿠버네티스가 API 접근을 구현 및 제어하는 방법에 대한 자세한 내용은 쿠버네티스 API에 대한 접근 제어를 참고한다.
참조 문헌
인증 부트스트랩 토큰 인증 승인 컨트롤러 동적 승인 제어 인가 역할 기반 접근 제어 속성 기반 접근 제어 노드 인가 웹훅 인가 인증서 서명 요청 CSR 승인과 인증서 서명을 포함함 서비스 어카운트 개발자 가이드 관리 kubelet 인증과 인가 kubelet TLS 부트스트래핑을 포함함 "><meta name=twitter:description content="쿠버네티스가 API 접근을 구현 및 제어하는 방법에 대한 자세한 내용은 쿠버네티스 API에 대한 접근 제어를 참고한다.
참조 문헌
인증 부트스트랩 토큰 인증 승인 컨트롤러 동적 승인 제어 인가 역할 기반 접근 제어 속성 기반 접근 제어 노드 인가 웹훅 인가 인증서 서명 요청 CSR 승인과 인증서 서명을 포함함 서비스 어카운트 개발자 가이드 관리 kubelet 인증과 인가 kubelet TLS 부트스트래핑을 포함함 "><meta property="og:url" content="https://kubernetes.io/ko/docs/reference/access-authn-authz/"><meta property="og:title" content="API 접근 제어"><meta name=twitter:title content="API 접근 제어"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/reference/access-authn-authz/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/reference/access-authn-authz/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/reference/access-authn-authz/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/reference/access-authn-authz/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/reference/access-authn-authz/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/reference/access-authn-authz/>English</a>
<a class=dropdown-item href=/zh-cn/docs/reference/access-authn-authz/>中文 (Chinese)</a>
<a class=dropdown-item href=/fr/docs/reference/access-authn-authz/>Français (French)</a>
<a class=dropdown-item href=/de/docs/reference/access-authn-authz/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/reference/access-authn-authz/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/reference/access-authn-authz/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/reference/access-authn-authz/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>API 접근 제어</h1><ul><li>1: <a href=#pg-de45b6ca7419a0e308044425b2ac52bb>부트스트랩 토큰을 사용한 인증</a></li><li>2: <a href=#pg-bea207258f3576b8ec7444a20d498e1d>서비스 어카운트 관리하기</a></li><li>3: <a href=#pg-342be69d36f174f762c36f4fe11fcb20>인가 개요</a></li><li>4: <a href=#pg-36e1423f0b5caa8eafeb6f53c175d13c>Kubelet 인증/인가</a></li></ul><div class=content><p>쿠버네티스가 API 접근을 구현 및 제어하는 방법에 대한 자세한 내용은
<a href=/ko/docs/concepts/security/controlling-access/>쿠버네티스 API에 대한 접근 제어</a>를 참고한다.</p><p>참조 문헌</p><ul><li><a href=/docs/reference/access-authn-authz/authentication/>인증</a><ul><li><a href=/ko/docs/reference/access-authn-authz/bootstrap-tokens/>부트스트랩 토큰 인증</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/admission-controllers/>승인 컨트롤러</a><ul><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>동적 승인 제어</a></li></ul></li><li><a href=/ko/docs/reference/access-authn-authz/authorization/>인가</a><ul><li><a href=/docs/reference/access-authn-authz/rbac/>역할 기반 접근 제어</a></li><li><a href=/docs/reference/access-authn-authz/abac/>속성 기반 접근 제어</a></li><li><a href=/docs/reference/access-authn-authz/node/>노드 인가</a></li><li><a href=/docs/reference/access-authn-authz/webhook/>웹훅 인가</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/>인증서 서명 요청</a><ul><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection>CSR 승인</a>과
<a href=/docs/reference/access-authn-authz/certificate-signing-requests/#signing>인증서 서명</a>을 포함함</li></ul></li><li>서비스 어카운트<ul><li><a href=/docs/tasks/configure-pod-container/configure-service-account/>개발자 가이드</a></li><li><a href=/ko/docs/reference/access-authn-authz/service-accounts-admin/>관리</a></li></ul></li><li><a href=/ko/docs/reference/access-authn-authz/kubelet-authn-authz/>kubelet 인증과 인가</a><ul><li>kubelet <a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>TLS 부트스트래핑</a>을 포함함</li></ul></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-de45b6ca7419a0e308044425b2ac52bb>1 - 부트스트랩 토큰을 사용한 인증</h1><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.18 [stable]</code></div><p>부트스트랩 토큰은 새 클러스터를 만들거나 새 노드를 기존 클러스터에 결합할 때
사용되는 간단한 전달자 토큰이다.
<a href=/ko/docs/reference/setup-tools/kubeadm/>kubeadm</a>을 지원하도록 구축되었지만
<code>kubeadm</code> 없이 클러스터를 시작하려는 사용자를 위해 다른 컨텍스트에서 사용할 수 있다.
또한 RBAC 정책을 통해 <a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>Kubelet TLS 부트스트래핑</a>
시스템과 함께 동작하도록 구축되었다.</p><h2 id=부트스트랩-토큰-개요>부트스트랩 토큰 개요</h2><p>부트스트랩 토큰은 <code>kube-system</code> 네임스페이스에 있는
특정 유형(<code>bootstrap.kubernetes.io/token</code>)의 시크릿(Secret)으로 정의된다.
API 서버의 부트스트랩 인증자가 이러한 시크릿을 읽는다.
만료된 토큰은 컨트롤러 관리자가 TokenCleaner 컨트롤러로 제거한다.
토큰은 BootstrapSigner 컨트롤러를 통해
"discovery" 프로세스에 사용되는 특정 컨피그맵(ConfigMap)에 대한
서명을 만드는 데도 사용된다.</p><h2 id=토큰-형식>토큰 형식</h2><p>부트스트랩 토큰은 <code>abcdef.0123456789abcdef</code> 형식을 취한다. 더 공식적으로는
정규식 <code>[a-z0-9]{6}\.[a-z0-9]{16}</code> 와 일치해야 한다.</p><p>토큰의 첫 번째 부분은 "Token ID" 이며 공개 정보로 간주된다.
인증에 사용하는 시크릿의 일부를 노출하지 않고 토큰을 참조할 때 사용한다.
두 번째 부분은 "Token Secret"이며
신뢰할 수 있는 당사자와만 공유해야 한다.</p><h2 id=부트스트랩-토큰-인증-활성화>부트스트랩 토큰 인증 활성화</h2><p>API 서버에서 다음 플래그를 사용하여 부트스트랩 토큰 인증자를
활성화할 수 있다.</p><pre tabindex=0><code>--enable-bootstrap-token-auth
</code></pre><p>활성화되면 부트스트랩 토큰을 API 서버에 대한 요청을 인증하기 위한
전달자 토큰 자격 증명으로 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>Authorization: Bearer 07401b.f395accd246ae52d
</span></span></span></code></pre></div><p>토큰은 사용자 이름 <code>system:bootstrap:&lt;token id></code> 로 인증되며 <code>system:bootstrappers</code> 그룹의 구성원이다.
토큰의 시크릿에 추가 그룹을
지정할 수 있다.</p><p>만료된 토큰은 컨트롤러 관리자에서 <code>tokencleaner</code>
컨트롤러를 활성화하여 자동으로 삭제할 수 있다.</p><pre tabindex=0><code>--controllers=*,tokencleaner
</code></pre><h2 id=부트스트랩-토큰-시크릿-형식>부트스트랩 토큰 시크릿 형식</h2><p>각각의 유효한 토큰은 <code>kube-system</code> 네임스페이스의 시크릿에 의해 지원된다.
전체 디자인 문서는
<a href=https://git.k8s.io/design-proposals-archive/cluster-lifecycle/bootstrap-discovery.md>여기</a>에서 찾을 수 있다.</p><p>시크릿은 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Name MUST be of form &#34;bootstrap-token-&lt;token id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-07401b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Type MUST be &#39;bootstrap.kubernetes.io/token&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Human readable description. Optional.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The default bootstrap token generated by &#39;kubeadm init&#39;.&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Token ID and secret. Required.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>07401b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>f395accd246ae52d<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Expiration. Optional.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>2017-03-10T03:22:11Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Allowed usages.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Extra groups to authenticate the token as. Must start with &#34;system:bootstrappers:&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>system:bootstrappers:worker,system:bootstrappers:ingress<span style=color:#bbb>
</span></span></span></code></pre></div><p>시크릿 유형은 <code>bootstrap.kubernetes.io/token</code> 이어야 하고
이름은 <code>bootstrap-token-&lt;token id></code>여야 한다. 반드시 <code>kube-system</code>
네임스페이스에도 존재해야 한다.</p><p><code>usage-bootstrap-*</code> 멤버는 이 시크릿의 용도를 나타낸다.
활성화하려면 값을 <code>true</code> 로 설정해야 한다.</p><ul><li><code>usage-bootstrap-authentication</code> 은 토큰을 API 서버에
베어러 토큰으로 인증하는데 사용할 수 있음을 나타낸다.</li><li><code>usage-bootstrap-signing</code> 은 토큰을 사용하여 아래에 설명된
<code>cluster-info</code> 컨피그맵에 서명할 수 있음을 나타낸다.</li></ul><p><code>expiration</code> 필드는 토큰의 만료를 제어한다. 만료된 토큰은
인증에 사용될 때 거부되고 컨피그맵서명 중에 무시된다.
만료된 값은 RFC3339를 사용하여 절대 UTC 시간으로 인코딩된다.
만료된 토큰을 자동으로 삭제하려면 <code>tokencleaner</code> 컨트롤러를 활성화한다.</p><h2 id=kubeadm을-사용한-토큰-관리>kubeadm을 사용한 토큰 관리</h2><p><code>kubeadm</code> 툴을 사용하여 실행중인 클러스터에서 토큰을 관리할 수 있다.
자세한 내용은 <a href=/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token docs</a> 에서 찾을 수 있다.</p><h2 id=컨피그맵-서명>컨피그맵 서명</h2><p>토큰은 인증 외에도 컨피그맵에 서명하는데 사용할 수 있다.
이것은 클라이언트가 API 서버를 신뢰하기 전에 클러스터 부트스트랩 프로세스의 초기에 사용된다.
서명된 컨피그맵은 공유 토큰으로 인증할 수 있다.</p><p>컨트롤러 관리자에서 <code>bootstrapsigner</code> 컨트롤러를 활성화하여
컨피그맵서명을 활성화 한다.</p><pre tabindex=0><code>--controllers=*,bootstrapsigner
</code></pre><p>서명된 컨피그맵은 <code>kube-public</code> 네임스페이스에 있는 <code>cluster-info</code> 이다.
일반적인 흐름은 클라이언트가 인증되지 않고 TLS 오류를 무시하는 동안
컨피그맵을 읽는 것이다. 그런 다음 컨피그맵에 포함된 서명을 확인하여
컨피그맵의 페이로드를 확인한다.</p><p>컨피그맵은 다음과 같을 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster-info<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-public<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jws-kubeconfig-07401b</span>:<span style=color:#bbb> </span>eyJhbGciOiJIUzI1NiIsImtpZCI6IjA3NDAxYiJ9..tYEfbo6zDNo40MQE07aZcQX2m3EB2rO3NuXtxVMYm9U<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeconfig</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    clusters:
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    - cluster:
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        certificate-authority-data: &lt;really long certificate data&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        server: https://10.138.0.2:6443
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      name: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    contexts: []
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    current-context: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    kind: Config
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    preferences: {}
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    users: []</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>컨피그맵의 <code>kubeconfig</code> 멤버는 클러스터 정보만 입력된 구성 파일이다.
여기서 전달되는 핵심은 <code>certificate-authority-data</code> 이다.<br>이는 향후 확대될 수 있다.</p><p>서명은 "detached" 모드를 사용하는 JWS 서명이다. 서명을 검증하려면
사용자는 JWS 규칙(뒤로 오는 <code>=</code> 를 삭제하는 동안 인코딩된 base64)에 따라
<code>kubeconfig</code> 페이로드를 인코딩해야 한다. 그런 다음 인코딩된 페이로드는
두 개의 점 사이에 삽입하여 전체 JWS를 형성하는 데 사용된다.
전체 토큰(예:<code>07401b.f395accd246ae52d</code>)을 공유 시크릿으로 사용하여
<code>HS256</code> 방식(HMAC-SHA256)을 사용함으로 JWS를 확인할 수 있다.
사용자는 <em>반드시</em> HS256이 사용되고 있는지 확인해야 한다.</p><div class="alert alert-danger warning callout" role=alert><strong>경고:</strong> 부트스트래핑 토큰을 가진 모든 당사자는 해당 토큰에 대한 유효한 서명을 만들 수 있다.
컨피그맵 서명을 사용할 때 많은 클라이언트와 동일한 토큰을 공유하는 것은 권장되지 않는다.
손상된 클라이언트는 잠재적으로 서명에 의존하여
TLS 트러스트를 부트스트랩하는 다른 클라이언트를 대신할 수 있기 때문이다.</div><p>자세한 내용은 <a href=/docs/reference/setup-tools/kubeadm/implementation-details/>kubeadm implementation details</a>
섹션을 참조하면 된다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bea207258f3576b8ec7444a20d498e1d>2 - 서비스 어카운트 관리하기</h1><p>이것은 서비스 어카운트에 대한 클러스터 관리자 안내서다.
독자는 <a href=/docs/tasks/configure-pod-container/configure-service-account/>쿠버네티스 서비스 어카운트 설정</a>에 익숙하다고 가정한다.</p><p>인증 및 사용자 어카운트에 대한 지원은 아직 준비 중이다.
서비스 어카운트를 더 잘 설명하기 위해, 때때로 미완성 기능이 언급될 수 있다.</p><h2 id=사용자-어카운트와-서비스-어카운트-비교>사용자 어카운트와 서비스 어카운트 비교</h2><p>쿠버네티스는 여러 가지 이유로 사용자 어카운트와 서비스 어카운트의 개념을
구분한다.</p><ul><li>사용자 어카운트는 사람을 위한 것이다. 서비스 어카운트는 파드에서 실행되는 프로세스를
위한 것이다.</li><li>사용자 어카운트는 전역을 대상으로 고려된다.
클러스터의 모든 네임스페이스에 걸쳐 이름이 고유해야 한다. 서비스 어카운트는 네임스페이스에 할당된다.</li><li>일반적으로 클러스터의 사용자 어카운트는 기업 데이터베이스로부터 동기화될 수 있으며,
여기서 새로운 사용자 어카운트를 생성하려면 특별한 권한이 필요하며 복잡한 비즈니스 프로세스에 연결된다.
서비스 어카운트 생성은
클러스터 사용자가 최소 권한 원칙에 따라 특정 작업을 위한 서비스 어카운트를 만들 수 있도록
보다 가볍게 만들어졌다.</li><li>사람과 서비스 어카운트에 대한 감사 항목은 다를 수 있다.</li><li>복잡한 시스템의 설정들은 그 시스템의 구성요소에 대한 다양한 서비스 어카운트 정의를 포함할 수 있다.
서비스 어카운트는 많은 제약없이 만들 수 있고 네임스페이스에 할당된 이름을 가질 수 있기 때문에
이러한 설정은 이식성이 좋다.</li></ul><h2 id=서비스-어카운트-자동화>서비스 어카운트 자동화</h2><p>서비스 계정 자동화를 구현하기 위해 세 가지 개별 요소가 협력한다.</p><ul><li><code>ServiceAccount</code> 어드미션 컨트롤러</li><li>토큰 컨트롤러</li><li><code>ServiceAccount</code> 컨트롤러</li></ul><h3 id=서비스어카운트-serviceaccount-어드미션-컨트롤러>서비스어카운트(ServiceAccount) 어드미션 컨트롤러</h3><p>파드 수정은 <a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러</a>라는
플러그인을 통해 구현된다.
이것은 API 서버의 일부이다.
파드가 생성되거나 수정될 때 파드를 수정하기 위해 동기적으로 동작한다.
이 플러그인이 활성 상태(대부분의 배포에서 기본값)인 경우 파드 생성 또는 수정 시 다음 작업을 수행한다.</p><ol><li>파드에 <code>ServiceAccount</code> 가 없다면, <code>ServiceAccount</code> 를 <code>default</code> 로 설정한다.</li><li>이전 단계는 파드에 참조되는 <code>ServiceAccount</code> 가 있도록 하고, 그렇지 않으면 이를 거부한다.</li><li>서비스어카운트 <code>automountServiceAccountToken</code> 와 파드의 <code>automountServiceAccountToken</code> 중
어느 것도 <code>false</code> 로 설정되어 있지 않다면,
API 접근을 위한 토큰이 포함된 <code>volume</code> 을 파드에 추가한다.</li><li>이전 단계에서 서비스어카운트 토큰을 위한 볼륨이 만들어졌다면,
<code>/var/run/secrets/kubernetes.io/serviceaccount</code> 에 마운트된 파드의 각 컨테이너에
<code>volumeSource</code> 를 추가한다.</li><li>파드에 <code>imagePullSecrets</code> 이 없는 경우,
<code>ServiceAccount</code> 의 <code>imagePullSecrets</code> 이 파드에 추가된다.</li></ol><h4 id=바인딩된-서비스-어카운트-토큰-볼륨>바인딩된 서비스 어카운트 토큰 볼륨</h4><div style=margin-top:10px;margin-bottom:10px><b>기능 상태:</b> <code>Kubernetes v1.22 [stable]</code></div><p>서비스 어카운트 어드미션 컨트롤러는 토큰 컨트롤러에서 생성한 만료되지 않은 서비스 계정 토큰에
시크릿 기반 볼륨 대신 다음과 같은 프로젝티드 볼륨을 추가한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-api-access-&lt;random-suffix&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>420</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 0644</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3607</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-root-ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>namespace<span style=color:#bbb>
</span></span></span></code></pre></div><p>프로젝티드 볼륨은 세 가지로 구성된다.</p><ol><li><code>kube-apiserver</code>로부터 TokenRequest API를 통해 얻은 <code>서비스어카운트토큰(ServiceAccountToken)</code>.
서비스어카운트토큰은 기본적으로 1시간 뒤에, 또는 파드가 삭제될 때 만료된다.
서비스어카운트토큰은 파드에 연결되며 kube-apiserver를 위해 존재한다.</li><li>kube-apiserver에 대한 연결을 확인하는 데 사용되는 CA 번들을 포함하는 <code>컨피그맵(ConfigMap)</code>.</li><li>파드의 네임스페이스를 참조하는 <code>DownwardAPI</code>.</li></ol><p>상세 사항은 <a href=/ko/docs/tasks/configure-pod-container/configure-projected-volume-storage/>프로젝티드 볼륨</a>을 참고한다.</p><h3 id=토큰-컨트롤러>토큰 컨트롤러</h3><p>토큰컨트롤러는 <code>kube-controller-manager</code> 의 일부로 실행된다. 이것은 비동기적으로 동작한다. 토큰 컨트롤러는,</p><ul><li>서비스어카운트 생성을 감시하고 API에 접근할 수 있는 해당
서비스어카운트 토큰 시크릿을 생성한다.</li><li>서비스어카운트 삭제를 감시하고 해당하는 모든 서비스어카운트
토큰 시크릿을 삭제한다.</li><li>서비스어카운트 토큰 시크릿 추가를 감시하고, 참조된 서비스어카운트가
존재하는지 확인하고, 필요한 경우 시크릿에 토큰을 추가한다.</li><li>시크릿 삭제를 감시하고 필요한 경우 해당 서비스어카운트에서
참조를 제거한다.</li></ul><p>서비스 어카운트 개인키 파일은 <code>--service-account-private-key-file</code>
플래그를 사용하여 <code>kube-controller-manager</code> 의 토큰 컨트롤러에 전달해야
한다. 개인키는 생성된 서비스 어카운트 토큰에 서명하는 데 사용될 것이다.
마찬가지로 <code>--service-account-key-file</code> 플래그를 사용하여 해당 공개키를
<code>kube-apiserver</code> 에 전달해야 한다. 공개키는 인증 과정에서 토큰을
검증하는 데 사용될 것이다.</p><h4 id=추가적인-api-토큰-생성>추가적인 API 토큰 생성</h4><p>컨트롤러 루프는 API 토큰이 포함된 시크릿이 각 서비스어카운트에 존재하도록 보장한다.
서비스어카운트에 대한 추가적인 API 토큰을 생성하기 위해
서비스어카운트를 참조하는 어노테이션과 함께
<code>kubernetes.io/service-account-token</code> 유형의 시크릿을 생성하면
컨트롤러가 새로 생성된 토큰으로 갱신한다.</p><p>다음은 시크릿에 대한 샘플 구성이다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecretname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span>myserviceaccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./secret.yaml
</span></span><span style=display:flex><span>kubectl describe secret mysecretname
</span></span></code></pre></div><h4 id=서비스-어카운트-토큰-시크릿-삭제-무효화>서비스 어카운트 토큰 시크릿 삭제/무효화</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret mysecretname
</span></span></code></pre></div><h3 id=서비스어카운트-컨트롤러>서비스어카운트 컨트롤러</h3><p>서비스어카운트 컨트롤러는 네임스페이스에 있는 서비스어카운트를 관리하고
"default"라는 이름의 서비스어카운트가 모든 활성 네임스페이스에 존재하는지 확인한다.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-342be69d36f174f762c36f4fe11fcb20>3 - 인가 개요</h1><p>지원되는 인가 모듈을 사용하여 정책을 만드는 방법을 포함한
쿠버네티스 인가에 대해 자세히 알아보자.</p><p>쿠버네티스에서는 사용자의 요청이 인가(접근 권한을 부여) 받기 전에 사용자가 인증(로그인)되어야 한다.
인증에 대한 자세한 내용은 <a href=/ko/docs/concepts/security/controlling-access/>쿠버네티스 API 접근 제어하기</a>를
참고한다.</p><p>쿠버네티스는 REST API 요청에 공통적인 속성을 요구한다.
이는 쿠버네티스 인가가 쿠버네티스 API 이외에 다른 API를 처리할 수 있는
기존 조직 전체 또는 클라우드 제공자 전체의 접근 제어 시스템과
연동된다는 것을 의미한다.</p><h2 id=요청-허용-또는-거부-결정>요청 허용 또는 거부 결정</h2><p>쿠버네티스는 API 서버를 이용하여 API 요청을 인가한다.
모든 정책과 비교하여 모든 요청 속성을 평가하고 요청을 허용하거나 거부한다.
계속 진행하려면 API 요청의 모든 부분이 일부 정책에 의해 반드시 허용되어야 한다.
이는 기본적으로 승인이 거부된다는 것을 의미한다.</p><p>(쿠버네티스는 API 서버를 사용하지만,
특정 오브젝트의 특정 필드에 의존하는 접근 제어 및 정책은
어드미션 컨트롤러에 의해 처리된다.)</p><p>여러 개의 인가 모듈이 구성되면 각 모듈이 순서대로 확인된다.
어느 인가 모듈이 요청을 승인하거나 거부할 경우, 그 결정은 즉시 반환되며 다른 인가 모듈이 참고되지 않는다.
모든 모듈에서 요청에 대한 평가가 없으면 요청이 거부된다.
요청 거부는 HTTP 상태 코드 403을 반환한다.</p><h2 id=요청-속성-검토>요청 속성 검토</h2><p>쿠버네티스는 다음 API 요청 속성만 검토한다.</p><ul><li><strong>user</strong> - 인증 중에 제공된 <code>user</code> 문자열.</li><li><strong>group</strong> - 인증된 사용자가 속한 그룹 이름 목록.</li><li><strong>extra</strong> - 인증 계층에서 제공하는 문자열 값에 대한 임의의 문자열 키 맵.</li><li><strong>API</strong> - 요청이 API 리소스에 대한 것인지 여부.</li><li><strong>Request path</strong> - <code>/api</code> 또는 <code>/healthz</code>와 같이 다양한 리소스가 아닌 엔드포인트의 경로.</li><li><strong>API request verb</strong> - <code>get</code>, <code>list</code>, <code>create</code>, <code>update</code>, <code>patch</code>, <code>watch</code>, <code>delete</code>, <code>deletecollection</code>과 같은 리소스 요청에 사용하는 API 동사. 리소스 API 엔드포인트의 요청 동사를 결정하려면 <a href=/ko/docs/reference/access-authn-authz/authorization/#%EC%9A%94%EC%B2%AD-%EB%8F%99%EC%82%AC-%EA%B2%B0%EC%A0%95>요청 동사 결정</a>을 참고한다.</li><li><strong>HTTP request verb</strong> - <code>get</code>, <code>post</code>, <code>put</code>, <code>delete</code>처럼 소문자 HTTP 메서드는 리소스가 아닌 요청에 사용한다.</li><li><strong>Resource</strong> - 접근 중인 리소스의 ID 또는 이름(리소스 요청만 해당) -- <code>get</code>, <code>update</code>, <code>patch</code>, <code>delete</code> 동사를 사용하는 리소스 요청의 경우 리소스 이름을 지정해야 한다.</li><li><strong>Subresource</strong> - 접근 중인 하위 리소스(리소스 요청만 해당).</li><li><strong>Namespace</strong> - 접근 중인 오브젝트의 네임스페이스(네임스페이스에 할당된 리소스 요청만 해당)</li><li><strong>API group</strong> - 접근 중인 <a class=glossary-tooltip title='쿠버네티스 API의 연관된 경로들의 집합.' data-toggle=tooltip data-placement=top href=/ko/docs/concepts/overview/kubernetes-api/#api-%ea%b7%b8%eb%a3%b9%ea%b3%bc-%eb%b2%84%ec%a0%84-%ea%b7%9c%ec%b9%99 target=_blank aria-label='API 그룹'>API 그룹</a>(리소스 요청에만 해당). 빈 문자열은 <em>핵심(core)</em> <a href=/ko/docs/reference/using-api/#api-%EA%B7%B8%EB%A3%B9>API 그룹</a>을 지정한다.</li></ul><h2 id=요청-동사-결정>요청 동사 결정</h2><p><strong>리소스가 아닌 요청</strong>
<code>/api/v1/...</code> 또는 <code>/apis/&lt;group>/&lt;version>/...</code> 이외에 다른 엔드포인트에 대한 요청은
"리소스가 아닌 요청"으로 간주되며, 요청의 소문자 HTTP 메서드를 동사로 사용한다.
예를 들어, <code>/api</code> 또는 <code>/healthz</code>와 같은 엔드포인트에 대한 <code>GET</code> 요청은 <code>get</code>을 동사로 사용할 것이다.</p><p><strong>리소스 요청</strong>
리소스 API 엔드포인트에 대한 요청 동사를 결정하려면
사용된 HTTP 동사와 해당 요청이 개별 리소스 또는 리소스 모음에 적용되는지 여부를
검토한다.</p><table><thead><tr><th>HTTP 동사</th><th>요청 동사</th></tr></thead><tbody><tr><td>POST</td><td>create</td></tr><tr><td>GET, HEAD</td><td>get(개별 리소스), list(전체 오브젝트 내용을 포함한 리소스 모음), watch(개별 리소스 또는 리소스 모음을 주시)</td></tr><tr><td>PUT</td><td>update</td></tr><tr><td>PATCH</td><td>patch</td></tr><tr><td>DELETE</td><td>delete(개별 리소스), deletecollection(리소스 모음)</td></tr></tbody></table><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> <code>get</code>, <code>list</code>, <code>watch</code> 요청은 모두 리소스의 전체 세부 내용을 반환할 수 있다. 반환된 데이터의 관점으론 모두 동일하다. 예를 들어 <code>secrets</code>에 대해 <code>list</code> 요청은 반환된 리소스의 <code>data</code> 속성을 여전히 드러낼 것이다.</div><p>쿠버네티스는 종종 전문 동사를 사용하여 부가적인 권한 인가를 확인한다. 예를 들면,</p><ul><li><a href=/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping>RBAC</a><ul><li><code>rbac.authorization.k8s.io</code> API 그룹의 <code>roles</code> 및 <code>clusterroles</code> 리소스에 대한 <code>bind</code> 동사.</li></ul></li><li><a href=/docs/reference/access-authn-authz/authentication/>인증</a><ul><li>핵심 API 그룹의 <code>users</code>, <code>groups</code>, <code>serviceaccounts</code>와 <code>authentication.k8s.io</code> API 그룹의 <code>userextras</code> 동사.</li></ul></li></ul><h2 id=authorization-modules>인가 모드</h2><p>쿠버네티스 API 서버는 몇 가지 인가 모드 중 하나를 사용하여 요청을 승인할 수 있다.</p><ul><li><strong>Node</strong> - 실행되도록 스케줄된 파드에 따라 kubelet에게 권한을 부여하는 특수 목적 인가 모드. Node 인가 모드 사용에 대한 자세한 내용은 <a href=/docs/reference/access-authn-authz/node/>Node 인가</a>를 참조한다.</li><li><strong>ABAC</strong> - 속성 기반 접근 제어 (ABAC, Attribute-based access control)는 속성과 결합한 정책의 사용을 통해 사용자에게 접근 권한을 부여하는 접근 제어 패러다임을 말한다. 이 정책은 모든 유형의 속성(사용자 속성, 리소스 속성, 오브젝트, 환경 속성 등)을 사용할 수 있다. ABAC 모드 사용에 대한 자세한 내용은 <a href=/docs/reference/access-authn-authz/abac/>ABAC 모드</a>를 참조한다.</li><li><strong>RBAC</strong> - 역할 기반 접근 제어(RBAC, Role-based access control)는 기업 내 개별 사용자의 역할을 기반으로 컴퓨터나 네트워크 리소스에 대한 접근을 규제하는 방식이다. 이 맥락에서 접근은 개별 사용자가 파일을 보거나 만들거나 수정하는 것과 같은 특정 작업을 수행할 수 있는 능력이다. RBAC 모드 사용에 대한 자세한 내용은 <a href=/docs/reference/access-authn-authz/rbac/>RBAC 모드</a>를 참조한다.<ul><li>지정된 RBAC(역할 기반 접근 제어)이 인가 결정을 위해 <code>rbac.authorization.k8s.io</code> API 그룹을 사용하면, 관리자가 쿠버네티스 API를 통해 권한 정책을 동적으로 구성할 수 있다.</li><li>RBAC을 활성화하려면 <code>--authorization-mode=RBAC</code>로 API 서버를 시작한다.</li></ul></li><li><strong>Webhook</strong> - WebHook은 HTTP 콜백이다(어떤 일이 일어날 때 발생하는 HTTP POST와 HTTP POST를 통한 간단한 이벤트 알림). WebHook을 구현하는 웹 애플리케이션은 특정한 일이 발생할 때 URL에 메시지를 POST 할 것이다. Webhook 모드 사용에 대한 자세한 내용은 <a href=/docs/reference/access-authn-authz/webhook/>Webhook 모드</a>를 참조한다.</li></ul><h4 id=api-접근-확인>API 접근 확인</h4><p><code>kubectl</code>은 API 인증 계층을 신속하게 쿼리하기 위한 <code>auth can-i</code> 하위 명령어를 제공한다.
이 명령은 현재 사용자가 지정된 작업을 수행할 수 있는지 여부를 알아내기 위해 <code>SelfSubjectAccessReview</code> API를 사용하며,
사용되는 인가 모드에 관계없이 작동한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl auth can-i create deployments --namespace dev
</span></span></code></pre></div><p>다음과 유사하게 출력된다.</p><pre tabindex=0><code>yes
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl auth can-i create deployments --namespace prod
</span></span></code></pre></div><p>다음과 유사하게 출력된다.</p><pre tabindex=0><code>no
</code></pre><p>관리자는 이를 <a href=/docs/reference/access-authn-authz/authentication/#user-impersonation>사용자 가장(impersonation)</a>과
병행하여 다른 사용자가 수행할 수 있는 작업을 결정할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl auth can-i list secrets --namespace dev --as dave
</span></span></code></pre></div><p>다음과 유사하게 출력된다.</p><pre tabindex=0><code>no
</code></pre><p>유사하게, <code>dev</code> 네임스페이스의 <code>dev-sa</code> 서비스어카운트가
<code>target</code> 네임스페이스의 파드 목록을 볼 수 있는지 확인하려면 다음을 실행한다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl auth can-i list pods <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	--namespace target <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	--as system:serviceaccount:dev:dev-sa
</span></span></code></pre></div><p>다음과 유사하게 출력된다.</p><pre tabindex=0><code>yes
</code></pre><p><code>SelfSubjectAccessReview</code>는 <code>authorization.k8s.io</code> API 그룹의 일부로서
API 서버 인가를 외부 서비스에 노출시킨다.
이 그룹의 기타 리소스에는 다음이 포함된다.</p><ul><li><code>SubjectAccessReview</code> - 현재 사용자뿐만 아니라 모든 사용자에 대한 접근 검토. API 서버에 인가 결정을 위임하는 데 유용하다. 예를 들어, kubelet 및 확장(extension) API 서버는 자신의 API에 대한 사용자 접근을 결정하기 위해 해당 리소스를 사용한다.</li><li><code>LocalSubjectAccessReview</code> - <code>SubjectAccessReview</code>와 비슷하지만 특정 네임스페이스로 제한된다.</li><li><code>SelfSubjectRulesReview</code> - 사용자가 네임스페이스 안에서 수행할 수 있는 작업 집합을 반환하는 검토. 사용자가 자신의 접근을 빠르게 요약해서 보거나 UI가 작업을 숨기거나 표시하는 데 유용하다.</li></ul><p>이러한 API는 반환된 오브젝트의 응답 "status" 필드가 쿼리의 결과인
일반 쿠버네티스 리소스를 생성하여 쿼리할 수 있다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create -f - -o yaml <span style=color:#b44>&lt;&lt; EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: authorization.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: SelfSubjectAccessReview
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  resourceAttributes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    group: apps
</span></span></span><span style=display:flex><span><span style=color:#b44>    resource: deployments
</span></span></span><span style=display:flex><span><span style=color:#b44>    verb: create
</span></span></span><span style=display:flex><span><span style=color:#b44>    namespace: dev
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>생성된 <code>SelfSubjectAccessReview</code> 는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>SelfSubjectAccessReview<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceAttributes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>apps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>deployments<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>dev<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verb</span>:<span style=color:#bbb> </span>create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>denied</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=인가-모듈에-플래그-사용>인가 모듈에 플래그 사용</h2><p>정책에 포함된 인가 모듈을 나타내기 위해
정책에 플래그를 포함시켜야 한다.</p><p>다음 플래그를 사용할 수 있다.</p><ul><li><code>--authorization-mode=ABAC</code> 속성 기반 접근 제어(ABAC) 모드를 사용하면 로컬 파일을 사용하여 정책을 구성할 수 있다.</li><li><code>--authorization-mode=RBAC</code> 역할 기반 접근 제어(RBAC) 모드를 사용하면 쿠버네티스 API를 사용하여 정책을 만들고 저장할 수 있다.</li><li><code>--authorization-mode=Webhook</code> WebHook은 원격 REST 엔드포인트를 사용하여 인가를 관리할 수 있는 HTTP 콜백 모드다.</li><li><code>--authorization-mode=Node</code> 노드 인가는 kubelet이 생성한 API 요청을 특별히 인가시키는 특수 목적 인가 모드다.</li><li><code>--authorization-mode=AlwaysDeny</code> 이 플래그는 모든 요청을 차단한다. 이 플래그는 테스트에만 사용한다.</li><li><code>--authorization-mode=AlwaysAllow</code> 이 플래그는 모든 요청을 허용한다. API 요청에 대한 인가가 필요하지 않은 경우에만 이 플래그를 사용한다.</li></ul><p>하나 이상의 인가 모듈을 선택할 수 있다. 모듈이 순서대로 확인되기 때문에
우선 순위가 더 높은 모듈이 요청을 허용하거나 거부할 수 있다.</p><h2 id=privilege-escalation-via-pod-creation>워크로드 생성 및 수정을 통한 권한 확대</h2><p>네임스페이스에서 파드를 직접, 또는 오퍼레이터와 같은 <a href=/ko/docs/concepts/architecture/controller/>컨트롤러</a>를 통해 생성/수정할 수 있는 사용자는
해당 네임스페이스 안에서 자신의 권한을 확대할 수 있다.</p><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 시스템 관리자는 파드 생성/수정에 대한 접근 권한을 부여할 때 주의한다.
<a href=#escalation-paths>권한 확대 경로</a>에서 접근 권한이 잘못 사용되었을 때의 상세사항을 확인할 수 있다.</div><h3 id=escalation-paths>권한 확대 경로</h3><ul><li>네임스페이스 내의 임의의 시크릿을 마운트<ul><li>다른 워크로드를 위한 시크릿으로의 접근에 사용될 수 있음</li><li>더 권한이 많은 서비스 어카운트의 서비스 어카운트 토큰 획득에 사용될 수 있음</li></ul></li><li>네임스페이스 내의 임의의 서비스 어카운트를 사용<ul><li>다른 워크로드인것처럼 사칭하여 쿠버네티스 API 액션을 수행할 수 있음</li><li>서비스 어카운트가 갖고 있는 '권한이 필요한 액션'을 수행할 수 있음</li></ul></li><li>네임스페이스 내의 다른 워크로드를 위한 컨피그맵을 마운트<ul><li>다른 워크로드를 위한 정보(예: DB 호스트 이름) 획득에 사용될 수 있음</li></ul></li><li>네임스페이스 내의 다른 워크로드를 위한 볼륨을 마운트<ul><li>다른 워크로드를 위한 정보의 획득 및 수정에 사용될 수 있음</li></ul></li></ul><div class="alert alert-warning caution callout" role=alert><strong>주의:</strong> 시스템 관리자는 위와 같은 영역을 수정하는 CRD를 배포할 때 주의를 기울여야 한다.
이들은 의도하지 않은 권한 확대 경로를 노출할 수 있다.
RBAC 제어에 대해 결정할 때 이와 같은 사항을 고려해야 한다.</div><h2 id=다음-내용>다음 내용</h2><ul><li>인증에 대한 자세한 내용은 <a href=/ko/docs/concepts/security/controlling-access/>쿠버네티스 API 접근 제어하기</a>에서 <strong>인증</strong> 을 참조한다.</li><li>어드미션 제어에 대한 자세한 내용은 <a href=/docs/reference/access-authn-authz/admission-controllers/>어드미션 컨트롤러 사용하기</a>를 참조한다.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-36e1423f0b5caa8eafeb6f53c175d13c>4 - Kubelet 인증/인가</h1><h2 id=개요>개요</h2><p>kubelet의 HTTPS 엔드포인트는 다양한 민감도의 데이터에 대한 접근을 제공하는 API를 노출하며,
노드와 컨테이너 내에서 다양한 수준의 권한으로 작업을 수행할 수 있도록 허용한다.</p><p>이 문서는 kubelet의 HTTPS 엔드포인트에 대한 접근을 인증하고 인가하는 방법을 설명한다.</p><h2 id=kubelet-인증>Kubelet 인증</h2><p>기본적으로, 다른 구성의 인증 방법에 의해 거부되지 않은 kubelet의 HTTPS 엔드포인트에 대한 요청은
익명의 요청으로 처리되며, <code>system:anonymous</code>의 사용자 이름과 <code>system:unauthenticated</code>
의 그룹이 부여된다.</p><p>익명의 접근을 비활성화하고 인증되지 않은 요청에 <code>401 Unauthorized</code> 응답을 보내려면 아래를 참고한다.</p><ul><li><code>--anonymous-auth=false</code> 플래그로 kubelet을 시작</li></ul><p>kubelet의 HTTPS 엔드포인트에 대한 X509 클라이언트 인증서 인증을 활성화하려면 아래를 참고한다.</p><ul><li><code>--client-ca-file</code> 플래그로 kubelet을 시작하면 클라이언트 인증서를 확인할 수 있는 CA 번들을 제공</li><li><code>--kubelet-client-certificate</code> 및 <code>--kubelet-client-key</code> 플래그로 apiserver를 시작</li><li>자세한 내용은 <a href=/docs/reference/access-authn-authz/authentication/#x509-client-certs>apiserver 인증 문서</a>를 참고</li></ul><p>API bearer 토큰(서비스 계정 토큰 포함)을 kubelet의 HTTPS 엔드포인트 인증에 사용하려면 아래를 참고한다.</p><ul><li>API 서버에서 <code>authentication.k8s.io/v1beta1</code> API 그룹이 사용 가능한지 확인</li><li><code>--authentication-token-webhook</code> 및 <code>--kubeconfig</code> 플래그로 kubelet을 시작</li><li>kubelet은 구성된 API 서버의 <code>TokenReview</code> API를 호출하여 bearer 토큰에서 사용자 정보를 결정</li></ul><h2 id=kubelet-승인>Kubelet 승인</h2><p>성공적으로 인증된 모든 요청(익명 요청 포함)이 승인된다. 기본 인가 모드는 모든 요청을 허용하는 <code>AlwaysAllow</code> 이다.</p><p>kubelet API에 대한 접근을 세분화하는 데는 다양한 이유가 있다.</p><ul><li>익명 인증을 사용할 수 있지만, 익명 사용자의 kubelet API 호출 기능은 제한되어야 함</li><li>bearer 토큰 인증을 사용할 수 있지만, 임의의 API 사용자(API 계정)의 kubelet API 호출 기능은 제한되어야 함</li><li>클라이언트 인증을 사용할 수 있지만, 구성된 CA에서 서명한 일부 클라이언트 인증서만 kubelet API를 사용하도록 허용해야 함</li></ul><p>kubelet API에 대한 접근을 세분화하려면 API 서버에 권한을 위임한다.</p><ul><li><code>authorization.k8s.io/v1beta1</code> API 그룹이 API 서버에서 사용 가능한지 확인</li><li><code>--authorization-mode=Webhook</code> 및 <code>--kubeconfig</code> 플래그로 kubelet을 시작</li><li>kubelet은 구성된 API 서버의 <code>SubjectAccessReview</code> API를 호출하여 각각의 요청이 승인되었는지 여부를 확인</li></ul><p>kubelet은 API 요청을 apiserver와 동일한 <a href=/ko/docs/reference/access-authn-authz/authorization/#%EC%9A%94%EC%B2%AD-%EC%86%8D%EC%84%B1-%EA%B2%80%ED%86%A0>요청 속성</a> 접근 방식을 사용하여 승인한다.</p><p>동사는 들어오는 요청의 HTTP 동사로부터 결정된다.</p><table><thead><tr><th>HTTP 동사</th><th>요청 동사</th></tr></thead><tbody><tr><td>POST</td><td>create</td></tr><tr><td>GET, HEAD</td><td>get</td></tr><tr><td>PUT</td><td>update</td></tr><tr><td>PATCH</td><td>patch</td></tr><tr><td>DELETE</td><td>delete</td></tr></tbody></table><p>리소스 및 하위 리소스는 들어오는 요청의 경로로부터 결정된다.</p><table><thead><tr><th>Kubelet API</th><th>리소스</th><th>하위 리소스</th></tr></thead><tbody><tr><td>/stats/*</td><td>nodes</td><td>stats</td></tr><tr><td>/metrics/*</td><td>nodes</td><td>metrics</td></tr><tr><td>/logs/*</td><td>nodes</td><td>log</td></tr><tr><td>/spec/*</td><td>nodes</td><td>spec</td></tr><tr><td><em>all others</em></td><td>nodes</td><td>proxy</td></tr></tbody></table><p>네임스페이스와 API 그룹 속성은 항상 빈 문자열이며,
리소스 이름은 항상 kubelet의 <code>Node</code> API 오브젝트 이름이다.</p><p>이 모드로 실행할 때, <code>--kubelet-client-certificate</code> 및 <code>--kubelet-client-key</code> 플래그로 식별된 사용자에게
다음 속성에 대한 권한이 있는지 확인한다.</p><ul><li>verb=*, resource=nodes, subresource=proxy</li><li>verb=*, resource=nodes, subresource=stats</li><li>verb=*, resource=nodes, subresource=log</li><li>verb=*, resource=nodes, subresource=spec</li><li>verb=*, resource=nodes, subresource=metrics</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>