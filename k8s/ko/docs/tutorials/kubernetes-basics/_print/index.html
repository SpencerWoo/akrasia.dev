<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=hi href=https://kubernetes.io/hi/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/tutorials/kubernetes-basics/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/tutorials/kubernetes-basics/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>쿠버네티스 기초 학습 | Kubernetes</title><meta property="og:title" content="쿠버네티스 기초 학습"><meta property="og:description" content="운영 수준의 컨테이너 오케스트레이션"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="쿠버네티스 기초 학습"><meta itemprop=description content="운영 수준의 컨테이너 오케스트레이션"><meta name=twitter:card content="summary"><meta name=twitter:title content="쿠버네티스 기초 학습"><meta name=twitter:description content="운영 수준의 컨테이너 오케스트레이션"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="<!DOCTYPE html> 쿠버네티스 기초 이 튜토리얼에서는 쿠버네티스 클러스터 오케스트레이션 시스템의 기초를 익힐 수 있는 가이드를 제공한다. 각각의 모듈에는 쿠버네티스의 주요 기능과 개념에 대한 배경 지식이 담겨 있으며 대화형 온라인 튜토리얼도 포함되어 있다. 대화형 튜토리얼에서 간단한 클러스터와 그 클러스터 상의 컨테이너화 된 애플리케이션을 직접 관리해볼 수 있다.
대화형 튜토리얼을 사용해서 다음의 내용을 배울 수 있다.
컨테이너화된 애플리케이션을 클러스터에 배포하기. 디플로이먼트를 스케일링하기. 컨테이너화된 애플리케이션을 새로운 소프트웨어 버전으로 업데이트하기. 컨테이너화된 애플리케이션을 디버그하기. 이 튜토리얼에서는 Katacoda를 사용해서 독자의 웹브라우저에서 Minikube가 동작하는 가상 터미널을 구동시킨다."><meta property="og:description" content="<!DOCTYPE html> 쿠버네티스 기초 이 튜토리얼에서는 쿠버네티스 클러스터 오케스트레이션 시스템의 기초를 익힐 수 있는 가이드를 제공한다. 각각의 모듈에는 쿠버네티스의 주요 기능과 개념에 대한 배경 지식이 담겨 있으며 대화형 온라인 튜토리얼도 포함되어 있다. 대화형 튜토리얼에서 간단한 클러스터와 그 클러스터 상의 컨테이너화 된 애플리케이션을 직접 관리해볼 수 있다.
대화형 튜토리얼을 사용해서 다음의 내용을 배울 수 있다.
컨테이너화된 애플리케이션을 클러스터에 배포하기. 디플로이먼트를 스케일링하기. 컨테이너화된 애플리케이션을 새로운 소프트웨어 버전으로 업데이트하기. 컨테이너화된 애플리케이션을 디버그하기. 이 튜토리얼에서는 Katacoda를 사용해서 독자의 웹브라우저에서 Minikube가 동작하는 가상 터미널을 구동시킨다."><meta name=twitter:description content="<!DOCTYPE html> 쿠버네티스 기초 이 튜토리얼에서는 쿠버네티스 클러스터 오케스트레이션 시스템의 기초를 익힐 수 있는 가이드를 제공한다. 각각의 모듈에는 쿠버네티스의 주요 기능과 개념에 대한 배경 지식이 담겨 있으며 대화형 온라인 튜토리얼도 포함되어 있다. 대화형 튜토리얼에서 간단한 클러스터와 그 클러스터 상의 컨테이너화 된 애플리케이션을 직접 관리해볼 수 있다.
대화형 튜토리얼을 사용해서 다음의 내용을 배울 수 있다.
컨테이너화된 애플리케이션을 클러스터에 배포하기. 디플로이먼트를 스케일링하기. 컨테이너화된 애플리케이션을 새로운 소프트웨어 버전으로 업데이트하기. 컨테이너화된 애플리케이션을 디버그하기. 이 튜토리얼에서는 Katacoda를 사용해서 독자의 웹브라우저에서 Minikube가 동작하는 가상 터미널을 구동시킨다."><meta property="og:url" content="https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/"><meta property="og:title" content="쿠버네티스 기초 학습"><meta name=twitter:title content="쿠버네티스 기초 학습"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/docs/tutorials/kubernetes-basics/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/docs/tutorials/kubernetes-basics/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/docs/tutorials/kubernetes-basics/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/docs/tutorials/kubernetes-basics/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tutorials/kubernetes-basics/>English</a>
<a class=dropdown-item href=/zh-cn/docs/tutorials/kubernetes-basics/>中文 (Chinese)</a>
<a class=dropdown-item href=/ja/docs/tutorials/kubernetes-basics/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/tutorials/kubernetes-basics/>Français (French)</a>
<a class=dropdown-item href=/de/docs/tutorials/kubernetes-basics/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/tutorials/kubernetes-basics/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/tutorials/kubernetes-basics/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/tutorials/kubernetes-basics/>Bahasa Indonesia</a>
<a class=dropdown-item href=/hi/docs/tutorials/kubernetes-basics/>हिन्दी (Hindi)</a>
<a class=dropdown-item href=/vi/docs/tutorials/kubernetes-basics/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/tutorials/kubernetes-basics/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/tutorials/kubernetes-basics/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/tutorials/kubernetes-basics/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>이 섹션의 다중 페이지 출력 화면임.
<a href=# onclick="return print(),!1">여기를 클릭하여 프린트</a>.</p><p><a href=/ko/docs/tutorials/kubernetes-basics/>이 페이지의 일반 화면으로 돌아가기</a>.</p></div><h1 class=title>쿠버네티스 기초 학습</h1><ul><li>1: <a href=#pg-7df66040311338d6098ebeab43ba9afb>클러스터 생성하기</a></li><ul><li>1.1: <a href=#pg-de49316920e97a82e36763cb66781ada>Minikube를 사용해서 클러스터 생성하기</a></li><li>1.2: <a href=#pg-323b75976001e8dfe35d67d61bc74f1a>대화형 튜토리얼 - 클러스터 생성하기</a></li></ul><li>2: <a href=#pg-76d78b3fba507f7ed33cef14a35b631d>앱 배포하기</a></li><ul><li>2.1: <a href=#pg-2b1bba431989008c7493109a0f049ece>kubectl을 사용해서 디플로이먼트 생성하기</a></li><li>2.2: <a href=#pg-f8997ec143b382fa6c9621941ea62ca3>대화형 튜토리얼 - 앱 배포하기</a></li></ul><li>3: <a href=#pg-250d620a73ec8be7e1f7d835574c4596>앱 조사하기</a></li><ul><li>3.1: <a href=#pg-2771f4e8c45321b17cb0114a2d266453>파드와 노드 보기</a></li><li>3.2: <a href=#pg-4b01eab98a9844ad91131079654199dd>대화형 튜토리얼 - 앱 조사하기</a></li></ul><li>4: <a href=#pg-4b0e31c9e0eae68bbb0a358b4042ada9>앱 외부로 노출하기</a></li><ul><li>4.1: <a href=#pg-8ef4dad8f743b191a9e8c6f891cb191a>앱 노출을 위해 서비스 이용하기</a></li><li>4.2: <a href=#pg-352241d22effe0714772d21c7d1b512d>대화형 튜토리얼 - 앱 노출하기</a></li></ul><li>5: <a href=#pg-be4996c93fb39c459a30b6669569d423>앱 스케일링하기</a></li><ul><li>5.1: <a href=#pg-d1c15c9bd4f625adbc13149b1475287c>복수의 앱 인스턴스를 구동하기</a></li><li>5.2: <a href=#pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>대화형 튜토리얼 - 앱 스케일링하기</a></li></ul><li>6: <a href=#pg-62b8b17dadfb55f1801cf8439e944e58>앱 업데이트하기</a></li><ul><li>6.1: <a href=#pg-12e04355145afad615ca3c38335ba019>롤링 업데이트 수행하기</a></li><li>6.2: <a href=#pg-dddc0cb356c280e0339bcf42776987dc>대화형 튜토리얼 - 앱 업데이트 하기</a></li></ul></ul><div class=content><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-9><h2>쿠버네티스 기초</h2><p>이 튜토리얼에서는 쿠버네티스 클러스터 오케스트레이션 시스템의 기초를 익힐 수 있는 가이드를 제공한다. 각각의 모듈에는 쿠버네티스의 주요 기능과 개념에 대한 배경 지식이 담겨 있으며 대화형 온라인 튜토리얼도 포함되어 있다. 대화형 튜토리얼에서 간단한 클러스터와 그 클러스터 상의 컨테이너화 된 애플리케이션을 직접 관리해볼 수 있다.</p><p>대화형 튜토리얼을 사용해서 다음의 내용을 배울 수 있다.</p><ul><li>컨테이너화된 애플리케이션을 클러스터에 배포하기.</li><li>디플로이먼트를 스케일링하기.</li><li>컨테이너화된 애플리케이션을 새로운 소프트웨어 버전으로 업데이트하기.</li><li>컨테이너화된 애플리케이션을 디버그하기.</li></ul><p>이 튜토리얼에서는 Katacoda를 사용해서 독자의 웹브라우저에서 Minikube가 동작하는 가상 터미널을 구동시킨다. Minikube는 로컬에 설치할 수 있는 작은 규모의 쿠버네티스로써 어디에서든 작동된다. 어떤 소프트웨어도 설치할 필요가 없고, 아무 것도 설정할 필요가 없다. 왜냐하면 대화형 튜토리얼이 웹브라우저 자체에서 바로 동작하기 때문이다.</p></div></div><br><div class=row><div class=col-md-9><h2>쿠버네티스가 어떤 도움이 될까?</h2><p>오늘날의 웹서비스에 대해서, 사용자는 애플리케이션이 24/7 가용하기를 바라고, 개발자는 하루에도 몇 번이고 새로운 버전의 애플리케이션을 배포하기를 바란다. 컨테이너화를 통해 소프트웨어를 패키지하면 애플리케이션을 다운타임 없이 릴리스 및 업데이트할 수 있게 되어서 이런 목표를 달성하는데 도움이 된다. 쿠버네티스는 이렇게 컨테이너화된 애플리케이션을 원하는 곳 어디에든 또 언제든 구동시킬 수 있다는 확신을 갖는데 도움을 주며, 그 애플리케이션이 작동하는데 필요한 자원과 도구를 찾는 것을 도와준다. 쿠버네티스는 구글의 컨테이너 오케스트레이션 부문의 축적된 경험으로 설계되고 커뮤니티로부터 도출된 최고의 아이디어가 결합된 운영 수준의 오픈 소스 플랫폼이다.</p></div></div><br><div id=basics-modules class=content__modules><h2>쿠버네티스 기초 모듈</h2><div class=row><div class=col-md-12><div class=row><div class=col-md-4><div class=thumbnail><a href=/ko/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_01.svg?v=1469803628347" alt></a><div class=caption><a href=/ko/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><h5>1. 쿠버네티스 클러스터 생성하기</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/ko/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_02.svg?v=1469803628347" alt></a><div class=caption><a href=/ko/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><h5>2. 애플리케이션 배포하기</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/ko/docs/tutorials/kubernetes-basics/explore/explore-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_03.svg?v=1469803628347" alt></a><div class=caption><a href=/ko/docs/tutorials/kubernetes-basics/explore/explore-intro/><h5>3. 앱 조사하기</h5></a></div></div></div></div></div><div class=col-md-12><div class=row><div class=col-md-4><div class=thumbnail><a href=/ko/docs/tutorials/kubernetes-basics/expose/expose-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_04.svg?v=1469803628347" alt></a><div class=caption><a href=/ko/docs/tutorials/kubernetes-basics/expose/expose-intro/><h5>4. 앱 외부로 노출하기</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/ko/docs/tutorials/kubernetes-basics/scale/scale-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_05.svg?v=1469803628347" alt></a><div class=caption><a href=/ko/docs/tutorials/kubernetes-basics/scale/scale-intro/><h5>5. 애플리케이션 스케일링하기</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/ko/docs/tutorials/kubernetes-basics/update/update-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_06.svg?v=1469803628347" alt></a><div class=caption><a href=/ko/docs/tutorials/kubernetes-basics/update/update-intro/><h5>6. 앱 업데이트하기</h5></a></div></div></div></div></div></div></div></main></div></body></html></div></div><div class=td-content style=page-break-before:always><h1 id=pg-7df66040311338d6098ebeab43ba9afb>1 - 클러스터 생성하기</h1><p>쿠버네티스 <a class=glossary-tooltip title='컨테이너화된 애플리케이션을 실행하는 노드라고 하는 워커 머신의 집합. 모든 클러스터는 최소 한 개의 워커 노드를 가진다.' data-toggle=tooltip data-placement=top href='/ko/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=클러스터>클러스터</a>에 대한 내용을 확인하고 Minikube를 사용하여 간단한 클러스터를 생성해 본다.</p></div><div class=td-content><h1 id=pg-de49316920e97a82e36763cb66781ada>1.1 - Minikube를 사용해서 클러스터 생성하기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>목표</h3><ul><li>쿠버네티스 클러스터가 무엇인지 배운다.</li><li>Minikube가 무엇인지 배운다.</li><li>온라인 터미널을 사용해서 쿠버네티스 클러스터를 시작한다.</li></ul></div><div class=col-md-8><h3>쿠버네티스 클러스터</h3><p><b>쿠버네티스는 컴퓨터들을 연결하여 단일 형상으로 동작하도록 컴퓨팅 클러스터를 구성하고 높은 가용성을 제공하도록 조율한다.</b> 사용자는 쿠버네티스의 추상화 개념을 통해 개별 머신에 얽매이지 않고 컨테이너화된 애플리케이션을 클러스터에 배포할 수 있다. 이렇게 새로운 배포 모델을 활용하려면, 애플리케이션을 개별 호스트에 독립적인 방식으로 패키징할 필요가 있다. 즉, 컨테이너화가 필요하다. 예전 배치 모델인 설치형 애플리케이션이 특정 머신의 호스트와 밀접하게 통합되는 패키지인 것에 비해, 컨테이너화된 애플리케이션은 유연성(flexible)과 가용성(available)이 훨씬 높다. <b>쿠버네티스는 이러한 애플리케이션 컨테이너를 클러스터에 분산시키고 스케줄링하는 일을 더욱 효율적으로 자동화한다.</b> 쿠버네티스는 오픈소스 플랫폼이며 운영 수준의 안정성(production-ready)을 제공한다.</p><p>쿠버네티스 클러스터는 두 가지 형태의 자원으로 구성된다.<ul><li><b>컨트롤 플레인</b>은 클러스터를 조율한다.</li><li><b>노드</b>는 애플리케이션을 구동하는 작업자(worker)이다.</li></ul></p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>요약:</h3><ul><li>쿠버네티스 클러스터</li><li>Minikube</li></ul></div><div class="content__box content__box_fill"><p><i>쿠버네티스는 컴퓨터 클러스터에 애플리케이션 컨테이너의 배치(스케줄링) 및 실행을 오케스트레이션하는 운영 수준의 오픈소스 플랫폼이다.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>클러스터 다이어그램</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg></p></div></div><br><div class=row><div class=col-md-8><p><b>컨트롤 플레인은 클러스터 관리를 담당한다.</b> 컨트롤 플레인은 애플리케이션을 스케줄링하거나, 애플리케이션의 항상성을 유지하거나, 애플리케이션을 스케일링하고, 새로운 변경사항을 순서대로 반영(rolling out)하는 일과 같은 클러스터 내 모든 활동을 조율한다.</p><p><b>노드는 쿠버네티스 클러스터 내 워커 머신으로 동작하는 VM 또는 물리적인 컴퓨터다.</b> 각 노드는 노드를 관리하고 쿠버네티스 컨트롤 플레인과 통신하는 Kubelet이라는 에이전트를 갖는다. 노드는 컨테이너 운영을 담당하는 containerd 또는 도커와 같은 툴도 갖는다. 운영 트래픽을 처리하는 쿠버네티스 클러스터는 최소 세 대의 노드를 가져야 하는데, 이는 한 노드가 다운되면 etcd 멤버와 컨트롤 플레인 인스턴스가 사라져 중복성(redundancy)을 잃기 때문이다. 컨트롤 플레인 노드를 추가하여 이러한 위험을 줄일 수 있다.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>컨트롤 플레인은 실행 중인 애플리케이션을 호스팅하기 위해 사용되는 노드와 클러스터를 관리한다.</i></p></div></div></div><div class=row><div class=col-md-8><p>애플리케이션을 쿠버네티스에 배포하기 위해서는, 컨트롤 플레인에 애플리케이션 컨테이너의 구동을 지시하면 된다. 그러면 컨트롤 플레인은 컨테이너를 클러스터의 어느 노드에 구동시킬지 스케줄한다. <b>노드는 컨트롤 플레인이 제공하는 <a href=/ko/docs/concepts/overview/kubernetes-api/>쿠버네티스 API</a>를 통해서 컨트롤 플레인과 통신한다.</b> 최종 사용자도 쿠버네티스 API를 사용해서 클러스터와 직접 상호작용(interact)할 수 있다.</p><p>쿠버네티스 클러스터는 물리 및 가상 머신 모두에 설치될 수 있다. 쿠버네티스 개발을 시작하려면 Minikube를 사용할 수 있다. Minikube는 가벼운 쿠버네티스 구현체이며, 로컬 머신에 VM을 만들고 하나의 노드로 구성된 간단한 클러스터를 생성한다. Minikube는 리눅스, 맥, 그리고 윈도우 시스템에서 구동이 가능하다. Minikube CLI는 클러스터에 대해 시작, 중지, 상태 조회 및 삭제 등의 기본적인 부트스트래핑(bootstrapping) 기능을 제공한다. 하지만, 본 튜토리얼에서는 Minikube가 미리 설치된 채로 제공되는 온라인 터미널을 사용할 것이다.</p><p>쿠버네티스가 무엇인지 알아봤으니, 이제 온라인 튜토리얼로 이동해서 우리의 첫 번째 클러스터를 시작해보자!</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/ role=button>대화형 튜토리얼 시작하기 <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-323b75976001e8dfe35d67d61bc74f1a>1.2 - 대화형 튜토리얼 - 클러스터 생성하기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script defer src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>화면이 너무 좁아 터미널과 상호작용할 수 없습니다. 데스크톱/태블릿을 사용해주세요.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/1 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/ role=button>홈으로 이동<span></span></a>
<a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/ role=button>모듈 2로 진행하기 ><span></span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-76d78b3fba507f7ed33cef14a35b631d>2 - 앱 배포하기</h1></div><div class=td-content><h1 id=pg-2b1bba431989008c7493109a0f049ece>2.1 - kubectl을 사용해서 디플로이먼트 생성하기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>목표</h3><ul><li>애플리케이션 디플로이먼트(Deployment)에 대해 배운다.</li><li>kubectl로 첫 애플리케이션을 쿠버네티스에 배포한다.</li></ul></div><div class=col-md-8><h3>쿠버네티스 디플로이먼트</h3><p>일단 쿠버네티스 클러스터를 구동시키면, 그 위에 컨테이너화된 애플리케이션을 배포할 수 있다.
그러기 위해서, 쿠버네티스 <b>디플로이먼트</b> 설정을 만들어야 한다. 디플로이먼트는 쿠버네티스가
애플리케이션의 인스턴스를 어떻게 생성하고 업데이트해야 하는지를 지시한다. 디플로이먼트가 만들어지면,
쿠버네티스 컨트롤 플레인이 해당 디플로이먼트에 포함된 애플리케이션 인스턴스가 클러스터의 개별 노드에서 실행되도록 스케줄한다.</p><p>애플리케이션 인스턴스가 생성되면, 쿠버네티스 디플로이먼트 컨트롤러는 지속적으로 이들 인스턴스를
모니터링한다. 인스턴스를 구동 중인 노드가 다운되거나 삭제되면, 디플로이먼트 컨트롤러가 인스턴스를
클러스터 내부의 다른 노드의 인스턴스로 교체시켜준다.<b>이렇게 머신의 장애나 정비에 대응할 수 있는 자동 복구(self-healing) 메커니즘을
제공한다.</b></p><p>오케스트레이션 기능이 없던 환경에서는, 설치 스크립트가 애플리케이션을 시작하는데 종종 사용되곤
했지만, 머신의 장애가 발생한 경우 복구를 해주지는 않았다. 쿠버네티스 디플로이먼트는 애플리케이션
인스턴스를 생성해주고 여러 노드에 걸쳐서 지속적으로 인스턴스가 구동되도록 하는 두 가지를 모두
하기 때문에 애플리케이션 관리를 위한 접근법에서 근본적인 차이를 가져다준다.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>요약:</h3><ul><li>디플로이먼트</li><li>Kubectl</li></ul></div><div class="content__box content__box_fill"><p><i>디플로이먼트는 애플리케이션 인스턴스를 생성하고 업데이트하는 역할을 담당한다.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>쿠버네티스에 첫 번째 애플리케이션 배포하기</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg></p></div></div><br><div class=row><div class=col-md-8><p><b>Kubectl</b>이라는 쿠버네티스 CLI를 통해 디플로이먼트를 생성하고 관리할 수 있다.
Kubectl은 클러스터와 상호 작용하기 위해 쿠버네티스 API를 사용한다. 이 모듈에서는, 쿠버네티스
클러스터 상에 애플리케이션을 구동시키는 디플로이먼트를 생성하기 위해 필요한 가장 일반적인 Kubectl
명령어를 배우게 된다.</p><p>디플로이먼트를 생성할 때, 애플리케이션에 대한 컨테이너 이미지와 구동시키고자 하는 복제 수를 지정해야
한다. 디플로이먼트를 업데이트해서 이런 정보를 나중에 변경할 수 있다. 모듈
<a href=/ko/docs/tutorials/kubernetes-basics/scale/scale-intro/>5</a>와 <a href=/ko/docs/tutorials/kubernetes-basics/update/update-intro/>6</a>의 부트캠프에서 어떻게
스케일하고 업데이트하는지에 대해 다룬다.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>애플리케이션이 쿠버네티스 상에 배포되려면 지원되는 컨테이너 형식 중 하나로 패키지 되어야한다.</i></p></div></div></div><div class=row><div class=col-md-8><p>첫 번째 디플로이먼트로, NGINX를 사용해 모든 요청을 에코(echo)하는 도커 컨테이너로 패키지한 hello-node 애플리케이션을 사용해보자. (아직 hello-node 애플리케이션을 작성하고 컨테이너를 활용해서 배포해보지 않았다면, <a href=/ko/docs/tutorials/hello-minikube/>Hello Minikube 튜토리얼</a>의 지시를 따른다.)<p><p>이제 디플로이먼트를 이해했으니, 온라인 튜토리얼을 통해 우리의 첫 번째 애플리케이션을 배포해보자!</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/ role=button>대화형 튜토리얼 시작하기 <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-f8997ec143b382fa6c9621941ea62ca3>2.2 - 대화형 튜토리얼 - 앱 배포하기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script defer src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=row><div class=col-md-12><p>파드는 쿠버네티스 애플리케이션의 기본 실행 단위이다. 각 파드는 클러스터에서 실행중인 워크로드의 일부를 나타낸다. <a href=/ko/docs/concepts/workloads/pods/>파드에 대해 더 자세히 알아본다</a>.</p></div></div><br><div class=katacoda><div class=katacoda__alert>터미널로 상호 작용하기 위해서, 데스크탑/태블릿 버전을 사용해주세요</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/7 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/ role=button>&lt; 모듈 1로 돌아가기<span></span></a>
<a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/ role=button>홈으로 이동<span></span></a>
<a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/explore/explore-intro/ role=button>모듈 3으로 진행하기 ><span></span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-250d620a73ec8be7e1f7d835574c4596>3 - 앱 조사하기</h1></div><div class=td-content><h1 id=pg-2771f4e8c45321b17cb0114a2d266453>3.1 - 파드와 노드 보기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>목표</h3><ul><li>쿠버네티스 파드에 대해 배운다.</li><li>쿠버네티스 노드에 대해 배운다.</li><li>배포된 애플리케이션의 문제를 해결한다.</li></ul></div><div class=col-md-8><h2>쿠버네티스 파드</h2><p>모듈 <a href=/ko/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a>에서 배포를 생성했을 때, 쿠버네티스는 여러분의 애플리케이션 인스턴스에 <b>파드</b>를 생성했다. 파드는 하나 또는 그 이상의 애플리케이션 컨테이너 (도커와 같은)들의 그룹을 나타내는 쿠버네티스의 추상적 개념으로 일부는 컨테이너에 대한 자원을 공유한다. 그 자원은 다음을 포함한다:</p><ul><li>볼륨과 같은, 공유 스토리지</li><li>클러스터 IP 주소와 같은, 네트워킹</li><li>컨테이너 이미지 버전 또는 사용할 특정 포트와 같이, 각 컨테이너가 동작하는 방식에 대한 정보</li></ul><p>파드는 특유한 "로컬호스트" 애플리케이션 모형을 만들어. 상대적으로 밀접하게 결합되어진 상이한 애플리케이션 컨테이너들을 수용할 수 있다. 가령, 파드는 Node.js 앱과 더불어 Node.js 웹서버에 의해 발행되는 데이터를 공급하는 상이한 컨테이너를 함께 수용할 수 있다. 파드 내 컨테이너는 IP 주소, 그리고 포트 스페이스를 공유하고 항상 함께 위치하고 함께 스케쥴링 되고 동일 노드 상의 컨텍스트를 공유하면서 동작한다.</p><p>파드는 쿠버네티스 플랫폼 상에서 최소 단위가 된다. 우리가 쿠버네티스에서 배포를 생성할 때, 그 배포는 컨테이너 내부에서 컨테이너와 함께 파드를 생성한다. 각 파드는 스케쥴 되어진 노드에게 묶여지게 된다. 그리고 (재구동 정책에 따라) 소멸되거나 삭제되기 전까지 그 노드에 유지된다. 노드에 실패가 발생할 경우, 클러스터 내에 가용한 다른 노드들을 대상으로 스케쥴되어진다.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>요약:</h3><ul><li>파드</li><li>노드</li><li>Kubectl 주요 명령어</li></ul></div><div class="content__box content__box_fill"><p><i>파드는 하나 또는 그 이상의 애플리케이션 컨테이너 (도커와 같은)들의 그룹이고 공유 스토리지 (볼륨), IP 주소 그리고 그것을 동작시키는 방식에 대한 정보를 포함하고 있다.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>파드 개요</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg></p></div></div><br><div class=row><div class=col-md-8><h2>노드</h2><p>파드는 언제나 <b>노드</b> 상에서 동작한다. 노드는 쿠버네티스에서 워커 머신을 말하며 클러스터에 따라 가상 또는 물리 머신일 수 있다. 각 노드는 컨트롤 플레인에 의해 관리된다. 하나의 노드는 여러 개의 파드를 가질 수 있고, 쿠버네티스 컨트롤 플레인은 클러스터 내 노드를 통해서 파드에 대한 스케쥴링을 자동으로 처리한다. 컨트롤 플레인의 자동 스케줄링은 각 노드의 사용 가능한 리소스를 모두 고려한다.</p><p>모든 쿠버네티스 노드는 최소한 다음과 같이 동작한다.</p><ul><li>Kubelet은, 쿠버네티스 컨트롤 플레인과 노드 간 통신을 책임지는 프로세스이며, 하나의 머신 상에서 동작하는 파드와 컨테이너를 관리한다.</li><li>컨테이너 런타임(도커와 같은)은 레지스트리에서 컨테이너 이미지를 가져와 묶여 있는 것을 풀고 애플리케이션을 동작시키는 책임을 맡는다.</li></ul></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>만약 컨테이너들이 밀접하게 결합되어 있고 디스크와 같은 자원을 공유해야 한다면 오직 하나의 단일 파드에 함께 스케쥴되어져야 한다.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>노드 개요</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg></p></div></div><br><div class=row><div class=col-md-8><h2>kubectl로 문제해결하기</h2><p>모듈 <a href=/ko/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a>에서, Kubectl 커맨드-라인 인터페이스를 사용했다. 배포된 애플리케이션과 그 환경에 대한 정보를 얻기 위해 모듈3에서도 계속 그것을 사용할 것이다. 가장 보편적인 운용업무는 다음 kubectl 명령어를 이용하여 처리할 수 있다:</p><ul><li><b>kubectl get</b> - 자원을 나열한다</li><li><b>kubectl describe</b> - 자원에 대해 상세한 정보를 보여준다.</li><li><b>kubectl logs</b> - 파드 내 컨테이너의 로그들을 출력한다</li><li><b>kubectl exec</b> - 파드 내 컨테이너에 대한 명령을 실행한다.</li></ul><p>언제 애플리케이션이 배포되었으며, 현재 상태가 어떠한지, 그것의 구성은 어떠한지 등을 보기 위해 이러한 명령을 이용할 수 있다.</p><p>이제 클러스터 컴포넌트와 커맨드 라인에 대해 알아 보았으니, 애플리케이션을 조사해 보자.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>노드는 쿠버네티스에 있어서 워커 머신이며 클러스터에 따라 VM 또는 물리 머신이 될 수 있다. 여러 개의 파드는 하나의 노드 위에서 동작할 수 있다.</i></p></div></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/explore/explore-interactive/ role=button>대화형 튜토리얼 시작하기 <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-4b01eab98a9844ad91131079654199dd>3.2 - 대화형 튜토리얼 - 앱 조사하기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script defer src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><br><div class=katacoda><div class=katacoda__alert>터미널과 상호작용하기 위해, 데스크탑/태블릿 버전을 이용한다.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/4 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/ role=button>&lt; 모듈 2로 돌아가기<span class=btn></span></a>
<a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/ role=button>홈으로 이동<span></span></a>
<a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/expose/expose-intro/ role=button>모듈 4로 진행하기 ><span class=btn></span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-4b0e31c9e0eae68bbb0a358b4042ada9>4 - 앱 외부로 노출하기</h1></div><div class=td-content><h1 id=pg-8ef4dad8f743b191a9e8c6f891cb191a>4.1 - 앱 노출을 위해 서비스 이용하기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>목표</h3><ul><li>쿠버네티스의 서비스에 대해 배운다.</li><li>레이블과 레이블셀랙터 오브젝트가 어떻게 서비스와 연관되는지 이해한다.</li><li>서비스를 이용하여 쿠버네티스 클러스터 외부로 애플리케이션을 노출한다.</li></ul></div><div class=col-md-8><h3>쿠버네티스 서비스들에 대한 개요</h3><p>쿠버네티스 <a href=/ko/docs/concepts/workloads/pods/>파드들</a> 은 언젠가는 죽게된다. 실제 파드들은 <a href=/ko/docs/concepts/workloads/pods/pod-lifecycle/>생명주기</a>를 갖는다. 워커 노드가 죽으면, 노드 상에서 동작하는 파드들 또한 종료된다. <a href=/ko/docs/concepts/workloads/controllers/replicaset/>레플리카셋(ReplicaSet)</a>은 여러분의 애플리케이션이 지속적으로 동작할 수 있도록 새로운 파드들의 생성을 통해 동적으로 클러스터를 미리 지정해 둔 상태로 되돌려 줄 수도 있다. 또 다른 예시로서, 3개의 복제본을 갖는 이미지 처리용 백엔드를 고려해 보자. 그 복제본들은 교체 가능한 상태이다. 그래서 프론트엔드 시스템은 하나의 파드가 소멸되어 재생성이 되더라도, 백엔드 복제본들에 의한 영향을 받아서는 안된다. 즉, 동일 노드 상의 파드들이라 할지라도, 쿠버네티스 클러스터 내 각 파드는 유일한 IP 주소를 가지며, 여러분의 애플리케이션들이 지속적으로 기능할 수 있도록 파드들 속에서 발생하는 변화에 대해 자동으로 조정해 줄 방법이 있어야 한다.</p><p>쿠버네티스에서 서비스는 하나의 논리적인 파드 셋과 그 파드들에 접근할 수 있는 정책을 정의하는 추상적 개념이다. 서비스는 종속적인 파드들 사이를 느슨하게 결합되도록 해준다. 서비스는 모든 쿠버네티스 오브젝트들과 같이 YAML <a href=/ko/docs/concepts/configuration/overview/#일반적인-구성-팁>(보다 선호하는)</a> 또는 JSON을 이용하여 정의된다. 서비스가 대상으로 하는 파드 셋은 보통 <i>LabelSelector</i>에 의해 결정된다 (여러분이 왜 스펙에 <code>selector</code>가 포함되지 않은 서비스를 필요로 하게 될 수도 있는지에 대해 아래에서 확인해 보자).</p><p>비록 각 파드들이 고유의 IP를 갖고 있기는 하지만, 그 IP들은 서비스의 도움없이 클러스터 외부로 노출되어질 수 없다. 서비스들은 여러분의 애플리케이션들에게 트래픽이 실릴 수 있도록 허용해준다. 서비스들은 ServiceSpec에서 <code>type</code>을 지정함으로써 다양한 방식들로 노출시킬 수 있다:</p><ul><li><i>ClusterIP</i> (기본값) - 클러스터 내에서 내부 IP 에 대해 서비스를 노출해준다. 이 방식은 오직 클러스터 내에서만 서비스가 접근될 수 있도록 해준다.</li><li><i>NodePort</i> - NAT가 이용되는 클러스터 내에서 각각 선택된 노드들의 동일한 포트에 서비스를 노출시켜준다. <code>&lt;NodeIP>:&lt;NodePort></code>를 이용하여 클러스터 외부로부터 서비스가 접근할 수 있도록 해준다. ClusterIP의 상위 집합이다.</li><li><i>LoadBalancer</i> - (지원 가능한 경우) 기존 클라우드에서 외부용 로드밸런서를 생성하고 서비스에 고정된 공인 IP를 할당해준다. NodePort의 상위 집합이다.</li><li><i>ExternalName</i> - <code>CNAME</code> 레코드 및 값을 반환함으로써 서비스를 <code>externalName</code> 필드의 내용(예를 들면, <code>foo.bar.example.com</code>)에 매핑한다. 어떠한 종류의 프록시도 설정되지 않는다. 이 방식은 <code>kube-dns</code> v1.7 이상 또는 CoreDNS 버전 0.0.8 이상을 필요로 한다.</li></ul><p>다른 서비스 타입들에 대한 추가 정보는 <a href=/ko/docs/tutorials/services/source-ip/>소스 IP 이용하기</a> 튜토리얼에서 확인 가능하다. 또한 <a href=/ko/docs/concepts/services-networking/connect-applications-service/>서비스들로 애플리케이션에 접속하기</a>도 참고해 보자.</p><p>부가적으로, spec에 <code>selector</code>를 정의하지 않고 말아넣은 서비스들의 몇 가지 유즈케이스들이 있음을 주의하자. <code>selector</code> 없이 생성된 서비스는 상응하는 엔드포인트 오브젝트들 또한 생성하지 않는다. 이로써 사용자들로 하여금 하나의 서비스를 특정한 엔드포인트에 매핑 시킬수 있도록 해준다. selector를 생략하게 되는 또 다른 가능성은 여러분이 <code>type: ExternalName</code>을 이용하겠다고 확고하게 의도하는 경우이다.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>요약</h3><ul><li>파드들을 외부 트래픽에 노출하기</li><li>여러 파드에 걸쳐서 트래픽 로드밸런싱 하기</li><li>레이블 사용하기</li></ul></div><div class="content__box content__box_fill"><p><i>쿠버네티스 서비스는 논리적 파드 셋을 정의하고 외부 트래픽 노출, 로드밸런싱 그리고 그 파드들에 대한 서비스 디스커버리를 가능하게 해주는 추상 계층이다.</i></p></div></div></div><br><div class=row><div class=col-md-8><h3>서비스와 레이블</h3></div></div><div class=row><div class=col-md-8><p>서비스는 파드 셋에 걸쳐서 트래픽을 라우트한다. 여러분의 애플리케이션에 영향을 주지 않으면서 쿠버네티스에서 파드들이 죽게도 하고, 복제가 되게도 해주는 추상적 개념이다. 종속적인 파드들 사이에서의 디스커버리와 라우팅은 (하나의 애플리케이션에서 프로트엔드와 백엔드 컴포넌트와 같은) 쿠버네티스 서비스들에 의해 처리된다.</p><p>서비스는 쿠버네티스의 객체들에 대해 논리 연산을 허용해주는 기본 그룹핑 단위인, <a href=/ko/docs/concepts/overview/working-with-objects/labels>레이블과 셀렉터</a>를 이용하여 파드 셋과 매치시킨다. 레이블은 오브젝트들에 붙여진 키/밸류 쌍으로 다양한 방식으로 이용 가능하다:</p><ul><li>개발, 테스트, 그리고 상용환경에 대한 객체들의 지정</li><li>임베디드된 버전 태그들</li><li>태그들을 이용하는 객체들에 대한 분류</li></ul></div></div><br><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg></p></div></div><br><div class=row><div class=col-md-8><p>레이블은 오브젝트의 생성 시점 또는 이후 시점에 붙여질 수 있다. 언제든지 수정이 가능하다. 이제 서비스를 이용하여 우리의 애플리케이션을 노출도 시켜보고 레이블도 적용해 보자.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/expose/expose-interactive/ role=button>대화형 튜토리얼 시작<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-352241d22effe0714772d21c7d1b512d>4.2 - 대화형 튜토리얼 - 앱 노출하기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script defer src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>터미널과 상호작용하기 위해, 데스크탑/태블릿 버전을 이용한다.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/8 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/explore/explore-intro/ role=button>&lt; 모듈 3으로 돌아가기<span></span></a>
<a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/ role=button>홈으로 이동<span></span></a>
<a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/scale/scale-intro/ role=button>모듈 5로 진행하기 ><span></span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-be4996c93fb39c459a30b6669569d423>5 - 앱 스케일링하기</h1></div><div class=td-content><h1 id=pg-d1c15c9bd4f625adbc13149b1475287c>5.1 - 복수의 앱 인스턴스를 구동하기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>목표</h3><ul><li>kubectl을 사용해서 애플리케이션을 스케일한다.</li></ul></div><div class=col-md-8><h3>애플리케이션을 스케일하기</h3><p>지난 모듈에서 <a href=/ko/docs/concepts/workloads/controllers/deployment/>디플로이먼트</a>를 만들고,
<a href=/ko/docs/concepts/services-networking/service/>서비스</a>를
통해서 디플로이먼트를 외부에 노출시켜 봤다. 해당 디플로이먼트는 애플리케이션을 구동하기 위해 단
하나의 파드만을 생성했었다. 트래픽이 증가하면, 사용자 요청에 맞추어 애플리케이션의 규모를
조정할 필요가 있다.</p><p>디플로이먼트의 복제 수를 변경하면 <b>스케일링</b>이 수행된다</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>요약:</h3><ul><li>디플로이먼트 스케일링하기</li></ul></div><div class="content__box content__box_fill"><p><i>kubectl create deployment 명령에 --replicas 파라미터를 사용해서 처음부터 복수의 인스턴스로 구동되는
디플로이먼트를 만들 수도 있다</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>스케일링 개요</h2></div></div><div class=row><div class=col-md-1></div><div class=col-md-8><div id=myCarousel class=carousel data-ride=carousel data-interval=3000><ol class=carousel-indicators><li data-target=#myCarousel data-slide-to=0 class=active></li><li data-target=#myCarousel data-slide-to=1></li></ol><div class=carousel-inner role=listbox><div class="item carousel-item active"><img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg></div></div><a class="left carousel-control" href=#myCarousel role=button data-slide=prev><span class=sr-only>이전</span></a>
<a class="right carousel-control" href=#myCarousel role=button data-slide=next><span class=sr-only>다음</span></a></div></div></div><br><div class=row><div class=col-md-8><p>디플로이먼트를 스케일 아웃하면 신규 파드가 생성되어서 가용한 자원이 있는 노드에 스케줄된다.
스케일링 기능은 새로 의도한 상태(desired state)까지 파드의 수를 늘린다. 쿠버네티스는
파드의 <a href=/docs/user-guide/horizontal-pod-autoscaling/>오토스케일링</a>
도 지원하지만 본 튜토리얼에서는 다루지 않는다. 0까지 스케일링하는 것도 가능하다. 이 경우 해당
디플로이먼트의 모든 파드가 종료된다.</p><p>애플리케이션의 인스턴스를 복수로 구동하게 되면 트래픽을 해당 인스턴스 모두에 분산시킬 방법이
필요해진다. 서비스는 노출된 디플로이먼트의 모든 파드에 네트워크 트래픽을 분산시켜줄 통합된
로드밸런서를 갖는다. 서비스는 엔드포인트를 이용해서 구동중인 파드를 지속적으로 모니터링함으로써
가용한 파드에만 트래픽이 전달되도록 해준다.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>디플로이먼트의 복제 수를 변경하면 스케일링이 수행된다.</i></p></div></div></div><br><div class=row><div class=col-md-8><p>일단 복수의 애플리케이션의 인스턴스가 구동 중이면, 다운타임 없이 롤링 업데이트를 할 수 있다.
다음 모듈에서 이 내용을 다루도록 하겠다. 이제 온라인 터미널로 가서 애플리케이션을 스케일해보자.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/scale/scale-interactive/ role=button>대화형 튜토리얼 시작하기 <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>5.2 - 대화형 튜토리얼 - 앱 스케일링하기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script defer src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>터미널로 상호 작용하기 위해서, 데스크탑/태블릿 버전을 사용해주세요</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/5 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/expose/expose-interactive/ role=button>&lt; 모듈 4로 돌아가기<span></span></a>
<a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/ role=button>홈으로 이동<span></span></a>
<a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/update/update-intro/ role=button>모듈 6으로 진행하기 ><span></span></a></div></div></main><a class=scrolltop href=#top></a></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-62b8b17dadfb55f1801cf8439e944e58>6 - 앱 업데이트하기</h1></div><div class=td-content><h1 id=pg-12e04355145afad615ca3c38335ba019>6.1 - 롤링 업데이트 수행하기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>목표</h3><ul><li>kubectl을 이용하여 롤링 업데이트 수행하기</li></ul></div><div class=col-md-8><h3>애플리케이션 업데이트하기</h3><p>사용자들은 애플리케이션이 항상 가용한 상태일 것이라 여기고 개발자들은 하루에 여러번씩 새로운 버전을
배포하도록 요구 받고있다. 쿠버네티스에서는 이것을 롤링 업데이트를 통해 이루고 있다. <b>롤링 업데이트</b>는 파드 인스턴스를 점진적으로 새로운 것으로 업데이트하여 디플로이먼트 업데이트가 서비스 중단 없이 이루어질 수 있도록 해준다.
새로운 파드는 가용한 자원을 보유한 노드로 스케줄될 것이다.</p><p>이전 모듈에서 여러 개의 인스턴스를 동작시키도록 애플리케이션을 스케일했다. 이것은 애플리케이션의 가용성에 영향을 미치지 않으면서
업데이트를 수행하는 것에 대한 요구이다. 기본적으로, 업데이트가 이루어지는 동안 이용 불가한 파드의 최대 개수와 생성 가능한 새로운 파드의 최대 개수는 하나다.
두 옵션은 (파드에 대한) 개수 또는 백분율로 구성될 수 있다.
쿠버네티스에서, 업데이트는 버전으로 관리되고 어떠한 디플로이먼트 업데이트라도 이전의 (안정적인) 버전으로 원복이 가능하다.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>요약:</h3><ul><li>앱 업데이트하기</li></ul></div><div class="content__box content__box_fill"><p><i>롤링 업데이트는 파드 인스턴스를 점진적으로 새로운 것으로 업데이트하여 디플로이먼트 업데이트가 서비스 중단 없이 이루어질 수 있도록 해준다.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>롤링 업데이트 개요</h2></div></div><div class=row><div class=col-md-1></div><div class=col-md-8><div id=myCarousel class=carousel data-ride=carousel data-interval=3000><ol class=carousel-indicators><li data-target=#myCarousel data-slide-to=0 class=active></li><li data-target=#myCarousel data-slide-to=1></li><li data-target=#myCarousel data-slide-to=2></li><li data-target=#myCarousel data-slide-to=3></li></ol><div class=carousel-inner role=listbox><div class="item carousel-item active"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates1.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates2.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates3.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates4.svg></div></div><a class="left carousel-control" href=#myCarousel role=button data-slide=prev><span class=sr-only>이전</span></a>
<a class="right carousel-control" href=#myCarousel role=button data-slide=next><span class=sr-only>다음</span></a></div></div></div><br><div class=row><div class=col-md-8><p>애플리케이션 스케일링과 유사하게, 디플로이먼트가 외부로 노출되면, 서비스는 업데이트가 이루어지는 동안 오직 가용한 파드에게만 트래픽을 로드밸런스 할 것이다. 가용한 파드란 애플리케이션의 사용자들에게 가용한 상태의 인스턴스를 말한다.</p><p>롤링 업데이트는 다음 동작들을 허용해준다:</p><ul><li>하나의 환경에서 또 다른 환경으로의 애플리케이션 프로모션 (컨테이너 이미지 업데이트를 통해)</li><li>이전 버전으로의 롤백</li><li>서비스 중단 없는 애플리케이션의 지속적인 통합과 지속적인 전달</li></ul></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>디플로이먼트가 외부로 노출되면, 서비스는 업데이트가 이루어지는 동안 오직 가용한 파드에게만 트래픽을 로드밸런스 할 것이다.</i></p></div></div></div><br><div class=row><div class=col-md-8><p>다음 대화형 튜토리얼에서, 새로운 버전으로 애플리케이션을 업데이트하고, 롤백 또한 수행해 볼 것이다.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/update/update-interactive/ role=button>대화형 튜토리얼 시작하기 <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-dddc0cb356c280e0339bcf42776987dc>6.2 - 대화형 튜토리얼 - 앱 업데이트 하기</h1><!doctype html><html lang=ko><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script defer src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>터미널과 상호작용하기 위해, 데스크탑/태블릿 버전을 이용한다.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/6 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/scale/scale-interactive/ role=button>&lt; 모듈 5로 돌아가기<span></span></a>
<a class="btn btn-lg btn-success" href=/ko/docs/tutorials/kubernetes-basics/ role=button>쿠버네티스 기초로 돌아가기<span></span></a></div></div></main></div></body></html></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>