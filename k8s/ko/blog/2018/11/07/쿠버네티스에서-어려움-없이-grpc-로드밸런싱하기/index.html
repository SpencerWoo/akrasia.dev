<!doctype html><html lang=ko class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/blog/2018/11/07/grpc-load-balancing-on-kubernetes-without-tears/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>쿠버네티스에서 어려움 없이 gRPC 로드밸런싱하기 | Kubernetes</title><meta property="og:title" content="쿠버네티스에서 어려움 없이 gRPC 로드밸런싱하기"><meta property="og:description" content="저자: William Morgan (Buoyant)
번역: 송원석 (쏘카), 김상홍 (국민대), 손석호 (ETRI)
다수의 새로운 gRPC 사용자는 쿠버네티스의 기본 로드 밸런싱이 종종 작동하지 않는 것에 놀란다. 예를 들어, 만약 단순한 gRPC Node.js 마이크로서비스 앱을 만들고 쿠버네티스에 배포하면 어떤 일이 생기는지 살펴보자.
여기 표시된 voting 서비스는 여러 개의 파드로 구성되어 있지만, 쿠버네티스의 CPU 그래프는 명확하게 파드 중 하나만 실제 작업을 수행하고 있는 것(하나의 파드만 트래픽을 수신하고 있으므로)을 보여준다. 왜 그런 것일까?
이 블로그 게시물에서는, 이런 일이 발생하는 이유를 설명하고, CNCF의 서비스 메시(mesh)인 Linkerd 및 서비스 사이드카(sidecar)를 활용한 gRPC 로드밸런싱을 쿠버네티스 앱에 추가하여, 이 문제를 쉽게 해결할 수 있는 방법을 설명한다."><meta property="og:type" content="article"><meta property="og:url" content="https://kubernetes.io/ko/blog/2018/11/07/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%97%90%EC%84%9C-%EC%96%B4%EB%A0%A4%EC%9B%80-%EC%97%86%EC%9D%B4-grpc-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1%ED%95%98%EA%B8%B0/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2018-11-07T00:00:00+00:00"><meta property="article:modified_time" content="2022-09-02T23:17:26+09:00"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="쿠버네티스에서 어려움 없이 gRPC 로드밸런싱하기"><meta itemprop=description content="저자: William Morgan (Buoyant)
번역: 송원석 (쏘카), 김상홍 (국민대), 손석호 (ETRI)
다수의 새로운 gRPC 사용자는 쿠버네티스의 기본 로드 밸런싱이 종종 작동하지 않는 것에 놀란다. 예를 들어, 만약 단순한 gRPC Node.js 마이크로서비스 앱을 만들고 쿠버네티스에 배포하면 어떤 일이 생기는지 살펴보자.
여기 표시된 voting 서비스는 여러 개의 파드로 구성되어 있지만, 쿠버네티스의 CPU 그래프는 명확하게 파드 중 하나만 실제 작업을 수행하고 있는 것(하나의 파드만 트래픽을 수신하고 있으므로)을 보여준다. 왜 그런 것일까?
이 블로그 게시물에서는, 이런 일이 발생하는 이유를 설명하고, CNCF의 서비스 메시(mesh)인 Linkerd 및 서비스 사이드카(sidecar)를 활용한 gRPC 로드밸런싱을 쿠버네티스 앱에 추가하여, 이 문제를 쉽게 해결할 수 있는 방법을 설명한다."><meta itemprop=datePublished content="2018-11-07T00:00:00+00:00"><meta itemprop=dateModified content="2022-09-02T23:17:26+09:00"><meta itemprop=wordCount content="991"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="쿠버네티스에서 어려움 없이 gRPC 로드밸런싱하기"><meta name=twitter:description content="저자: William Morgan (Buoyant)
번역: 송원석 (쏘카), 김상홍 (국민대), 손석호 (ETRI)
다수의 새로운 gRPC 사용자는 쿠버네티스의 기본 로드 밸런싱이 종종 작동하지 않는 것에 놀란다. 예를 들어, 만약 단순한 gRPC Node.js 마이크로서비스 앱을 만들고 쿠버네티스에 배포하면 어떤 일이 생기는지 살펴보자.
여기 표시된 voting 서비스는 여러 개의 파드로 구성되어 있지만, 쿠버네티스의 CPU 그래프는 명확하게 파드 중 하나만 실제 작업을 수행하고 있는 것(하나의 파드만 트래픽을 수신하고 있으므로)을 보여준다. 왜 그런 것일까?
이 블로그 게시물에서는, 이런 일이 발생하는 이유를 설명하고, CNCF의 서비스 메시(mesh)인 Linkerd 및 서비스 사이드카(sidecar)를 활용한 gRPC 로드밸런싱을 쿠버네티스 앱에 추가하여, 이 문제를 쉽게 해결할 수 있는 방법을 설명한다."><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="저자: William Morgan (Buoyant)
번역: 송원석 (쏘카), 김상홍 (국민대), 손석호 (ETRI)
다수의 새로운 gRPC 사용자는 쿠버네티스의 기본 로드 밸런싱이 종종 작동하지 않는 것에 놀란다. 예를 들어, 만약 단순한 gRPC Node.js 마이크로서비스 앱을 만들고 쿠버네티스에 배포하면 어떤 일이 생기는지 살펴보자.
여기 표시된 voting 서비스는 여러 개의 파드로 구성되어 있지만, 쿠버네티스의 CPU 그래프는 명확하게 파드 중 하나만 실제 작업을 수행하고 있는 것(하나의 파드만 트래픽을 수신하고 있으므로)을 보여준다. 왜 그런 것일까?
이 블로그 게시물에서는, 이런 일이 발생하는 이유를 설명하고, CNCF의 서비스 메시(mesh)인 Linkerd 및 서비스 사이드카(sidecar)를 활용한 gRPC 로드밸런싱을 쿠버네티스 앱에 추가하여, 이 문제를 쉽게 해결할 수 있는 방법을 설명한다."><meta property="og:description" content="저자: William Morgan (Buoyant)
번역: 송원석 (쏘카), 김상홍 (국민대), 손석호 (ETRI)
다수의 새로운 gRPC 사용자는 쿠버네티스의 기본 로드 밸런싱이 종종 작동하지 않는 것에 놀란다. 예를 들어, 만약 단순한 gRPC Node.js 마이크로서비스 앱을 만들고 쿠버네티스에 배포하면 어떤 일이 생기는지 살펴보자.
여기 표시된 voting 서비스는 여러 개의 파드로 구성되어 있지만, 쿠버네티스의 CPU 그래프는 명확하게 파드 중 하나만 실제 작업을 수행하고 있는 것(하나의 파드만 트래픽을 수신하고 있으므로)을 보여준다. 왜 그런 것일까?
이 블로그 게시물에서는, 이런 일이 발생하는 이유를 설명하고, CNCF의 서비스 메시(mesh)인 Linkerd 및 서비스 사이드카(sidecar)를 활용한 gRPC 로드밸런싱을 쿠버네티스 앱에 추가하여, 이 문제를 쉽게 해결할 수 있는 방법을 설명한다."><meta name=twitter:description content="저자: William Morgan (Buoyant)
번역: 송원석 (쏘카), 김상홍 (국민대), 손석호 (ETRI)
다수의 새로운 gRPC 사용자는 쿠버네티스의 기본 로드 밸런싱이 종종 작동하지 않는 것에 놀란다. 예를 들어, 만약 단순한 gRPC Node.js 마이크로서비스 앱을 만들고 쿠버네티스에 배포하면 어떤 일이 생기는지 살펴보자.
여기 표시된 voting 서비스는 여러 개의 파드로 구성되어 있지만, 쿠버네티스의 CPU 그래프는 명확하게 파드 중 하나만 실제 작업을 수행하고 있는 것(하나의 파드만 트래픽을 수신하고 있으므로)을 보여준다. 왜 그런 것일까?
이 블로그 게시물에서는, 이런 일이 발생하는 이유를 설명하고, CNCF의 서비스 메시(mesh)인 Linkerd 및 서비스 사이드카(sidecar)를 활용한 gRPC 로드밸런싱을 쿠버네티스 앱에 추가하여, 이 문제를 쉽게 해결할 수 있는 방법을 설명한다."><meta property="og:url" content="https://kubernetes.io/ko/blog/2018/11/07/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%97%90%EC%84%9C-%EC%96%B4%EB%A0%A4%EC%9B%80-%EC%97%86%EC%9D%B4-grpc-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1%ED%95%98%EA%B8%B0/"><meta property="og:title" content="쿠버네티스에서 어려움 없이 gRPC 로드밸런싱하기"><meta name=twitter:title content="쿠버네티스에서 어려움 없이 gRPC 로드밸런싱하기"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/blog/grpc-load-balancing-with-linkerd/Screenshot2018-11-0116-c4d86100-afc1-4a08-a01c-16da391756dd.34.36.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script><title>쿠버네티스에서 어려움 없이 gRPC 로드밸런싱하기 | Kubernetes</title><script defer src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script></head><body class="td-page td-blog"><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ko/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/docs/>문서</a></li><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ko/blog/>쿠버네티스 블로그</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/training/>교육</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/partners/>파트너</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ko/case-studies/>사례 연구</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>버전</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ko/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ko/blog/2018/11/07/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%97%90%EC%84%9C-%EC%96%B4%EB%A0%A4%EC%9B%80-%EC%97%86%EC%9D%B4-grpc-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1%ED%95%98%EA%B8%B0/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ko/blog/2018/11/07/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%97%90%EC%84%9C-%EC%96%B4%EB%A0%A4%EC%9B%80-%EC%97%86%EC%9D%B4-grpc-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1%ED%95%98%EA%B8%B0/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ko/blog/2018/11/07/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%97%90%EC%84%9C-%EC%96%B4%EB%A0%A4%EC%9B%80-%EC%97%86%EC%9D%B4-grpc-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1%ED%95%98%EA%B8%B0/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ko/blog/2018/11/07/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%97%90%EC%84%9C-%EC%96%B4%EB%A0%A4%EC%9B%80-%EC%97%86%EC%9D%B4-grpc-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1%ED%95%98%EA%B8%B0/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ko/blog/2018/11/07/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%97%90%EC%84%9C-%EC%96%B4%EB%A0%A4%EC%9B%80-%EC%97%86%EC%9D%B4-grpc-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1%ED%95%98%EA%B8%B0/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>한국어 (Korean)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/blog/2018/11/07/grpc-load-balancing-on-kubernetes-without-tears/>English</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav><section class="header-hero text-center text-white font-bold pb-4"><h1>쿠버네티스 블로그</h1></section></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><form class="td-sidebar__search d-flex align-items-center"><input type=search class="form-control td-search-input" name=q placeholder="&#xf002 검색하기" aria-label=검색하기 autocomplete=off>
<button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type=button data-toggle=collapse data-target=#td-section-nav aria-controls=td-docs-nav aria-expanded=false aria-label="Toggle section navigation"></button></form><nav class="collapse td-sidebar-nav pt-2 pl-4" id=td-section-nav><ul class="td-sidebar-nav__section pr-md-3"><li class=td-sidebar-nav__section-title><a href=/ko/blog/2022/05/13/grpc-probes-now-in-beta/ class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">2022</a></li><ul><li class="blog-post collapse" data-year=2022><a class="td-sidebar-link td-sidebar-link__page" id=m-ko-blog-2022-05-13-grpc-probes-now-in-beta href=/ko/blog/2022/05/13/grpc-probes-now-in-beta/>쿠버네티스 1.24: gRPC 컨테이너 프로브 베타</a></li><li class="more-posts collapse" data-year=2022><a class=td-sidebar-link id=more-posts href>Show More Posts...</a></li></ul></ul><ul class="td-sidebar-nav__section pr-md-3"><li class=td-sidebar-nav__section-title><a href=/ko/blog/2021/08/04/kubernetes-1-22-release-announcement/ class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">2021</a></li><ul><li class="blog-post collapse" data-year=2021><a class="td-sidebar-link td-sidebar-link__page" id=m-ko-blog-2021-08-04-kubernetes-1-22-release-announcement href=/ko/blog/2021/08/04/kubernetes-1-22-release-announcement/>쿠버네티스 1.22: 새로운 정점에 도달(Reaching New Peaks)</a></li><li class="more-posts collapse" data-year=2021><a class=td-sidebar-link id=more-posts href>Show More Posts...</a></li></ul></ul><ul class="td-sidebar-nav__section pr-md-3"><li class=td-sidebar-nav__section-title><a href=/ko/blog/2020/12/02/dont-panic-kubernetes-and-docker/ class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">2020</a></li><ul><li class="blog-post collapse" data-year=2020><a class="td-sidebar-link td-sidebar-link__page" id=m-ko-blog-2020-12-02-dont-panic-kubernetes-and-docker href=/ko/blog/2020/12/02/dont-panic-kubernetes-and-docker/>당황하지 마세요. 쿠버네티스와 도커</a></li><li class="more-posts collapse" data-year=2020><a class=td-sidebar-link id=more-posts href>Show More Posts...</a></li></ul></ul><ul class="td-sidebar-nav__section pr-md-3"><li class=td-sidebar-nav__section-title><a href=/ko/blog/2018/11/07/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%97%90%EC%84%9C-%EC%96%B4%EB%A0%A4%EC%9B%80-%EC%97%86%EC%9D%B4-grpc-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1%ED%95%98%EA%B8%B0/ class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">2018</a></li><ul><li class="blog-post collapse show" data-year=2018><a class="td-sidebar-link td-sidebar-link__page active" id=m-ko-blog-2018-11-07-ec-bf-a0-eb-b2-84-eb-84-a4-ed-8b-b0-ec-8a-a4-ec-97-90-ec-84-9c-ec-96-b4-eb-a0-a4-ec-9b-80-ec-97-86-ec-9d-b4-grpc-eb-a1-9c-eb-93-9c-eb-b0-b8-eb-9f-b0-ec-8b-b1-ed-95-98-ea-b8-b0 href=/ko/blog/2018/11/07/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%97%90%EC%84%9C-%EC%96%B4%EB%A0%A4%EC%9B%80-%EC%97%86%EC%9D%B4-grpc-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1%ED%95%98%EA%B8%B0/>쿠버네티스에서 어려움 없이 gRPC 로드밸런싱하기</a></li><li class="more-posts collapse show" data-year=2018><a class=td-sidebar-link id=more-posts href>Show More Posts...</a></li></ul></ul></nav></div><script>let morePosts=document.querySelectorAll(".more-posts"),year="";morePosts.forEach(e=>{e.onclick=t=>{t.preventDefault(),year=e.dataset.year,console.log(year);let n=document.querySelectorAll(`.blog-post.hidden[data-year="${year}"]`);console.log(n),n.forEach(e=>{e.classList.add("show"),e.classList.remove("hidden")}),e.style.display="none"}})</script></div><main class="col-12 col-md-9 col-xl-8 pl-md-5 pr-md-4" role=main><section id=deprecation-warning><div class="content deprecation-warning pageinfo outdated-blog"><p>이 글은 작성일로부터 1년 이상 지났습니다. 오래된 글은 더 이상 유효하지 않은 컨텐츠를 포함하고 있을 수 있습니다. 이 페이지의 정보가 틀리지 않았는지 다시 한 번 확인하세요.</p></div></section><div class=td-content><h1>쿠버네티스에서 어려움 없이 gRPC 로드밸런싱하기</h1><div class="td-byline mb-4"><time datetime=2018-11-07 class=text-muted>2018.11.07</time></div><header class=article-meta></header><p><strong>저자</strong>: William Morgan (Buoyant)</p><p><strong>번역</strong>: 송원석 (쏘카), 김상홍 (국민대), 손석호 (ETRI)</p><p>다수의 새로운 gRPC 사용자는 쿠버네티스의 기본 로드
밸런싱이 종종 작동하지 않는 것에 놀란다. 예를 들어, 만약
<a href=https://github.com/sourishkrout/nodevoto>단순한 gRPC Node.js 마이크로서비스
앱</a>을 만들고 쿠버네티스에 배포하면 어떤 일이 생기는지 살펴보자.</p><p><img src=/images/blog/grpc-load-balancing-with-linkerd/Screenshot2018-11-0116-c4d86100-afc1-4a08-a01c-16da391756dd.34.36.png alt></p><p>여기 표시된 <code>voting</code> 서비스는 여러 개의 파드로 구성되어 있지만, 쿠버네티스의 CPU 그래프는 명확하게
파드 중 하나만 실제 작업을 수행하고 있는 것(하나의 파드만 트래픽을 수신하고 있으므로)을
보여준다. 왜 그런 것일까?</p><p>이 블로그 게시물에서는, 이런 일이 발생하는 이유를 설명하고,
<a href=https://cncf.io>CNCF</a>의 서비스 메시(mesh)인 <a href=https://linkerd.io>Linkerd</a> 및 서비스 사이드카(sidecar)를 활용한
gRPC 로드밸런싱을 쿠버네티스 앱에 추가하여, 이 문제를 쉽게 해결할 수 있는 방법을 설명한다.</p><h1 id=왜-grpc에-특별한-로드밸런싱이-필요한가>왜 gRPC에 특별한 로드밸런싱이 필요한가?</h1><p>먼저, 왜 gRPC를 위해 특별한 작업이 필요한지 살펴보자.</p><p>gRPC는 애플리케이션 개발자에게 점점 더 일반적인 선택지가 되고 있다.
JSON-over-HTTP와 같은 대체 프로토콜에 비해, gRPC는
극적으로 낮은 (역)직렬화 비용과, 자동 타입
체크, 공식화된 APIs, 적은 TCP 관리 오버헤드 등에 상당한 이점이 있다.</p><p>그러나, gRPC는 쿠버네티스에서 제공하는 것과 마찬가지로
표준(일반)적으로 사용되는 연결 수준 로드밸런싱(connection-level load balancing)을 어렵게 만드는 측면도 있다. gRPC는 HTTP/2로
구축되었고, HTTP/2는 하나의 오래 지속되는 TCP 연결을 갖도록 설계되있기 때문에,
모든 요청은 <em>다중화(multiplexed)</em>(특정 시점에 다수의 요청이
하나의 연결에서만 동작하는 것을 의미)된다. 일반적으로, 그것은
연결 관리 오버헤드를 줄이는 장점이 있다. 그러나, 그것은 또한
(상상할 수 있듯이) 연결 수준의 밸런싱(balancing)에는 유용하지 않다는 것을 의미한다. 일단
연결이 설정되면, 더 이상 밸런싱을 수행할 수 없기 때문이다. 모든 요청이
아래와 같이 단일 파드에 고정될 것이다.</p><p><img src=/images/blog/grpc-load-balancing-with-linkerd/Mono-8d2e53ef-b133-4aa0-9551-7e36a880c553.png alt></p><h1 id=왜-http-1-1에는-이러한-일이-발생하지-않는가>왜 HTTP/1.1에는 이러한 일이 발생하지 않는가?</h1><p>HTTP/1.1 또한 수명이 긴 연결의 개념이 있지만,
HTTP/1.1에는 TCP 연결을 순환시키게 만드는 여러 특징들이 있기 때문에,
이러한 문제가 발생하지 않는다. 그래서,
연결 수준 밸런싱은 "충분히 양호"하며, 대부분의 HTTP/1.1 앱에 대해서는
더 이상 아무것도 할 필요가 없다.</p><p>그 이유를 이해하기 위해, HTTP/1.1을 자세히 살펴보자. HTTP/2와 달리
HTTP/1.1은 요청을 다중화할 수 없다. TCP 연결 시점에 하나의 HTTP 요청만
활성화될 수 있다. 예를 들어 클라이언트가 'GET /foo'를 요청하고,
서버가 응답할 때까지 대기한다. 요청-응답 주기가
발생하면, 해당 연결에서 다른 요청을 실행할 수 없다.</p><p>일반적으로, 우리는 병렬로 많은 요청이 발생하기 원한다. 그러므로,
HTTP/1.1 동시 요청을 위해, 여러 HTTP/1.1 연결을 만들어야 하고,
그 모두에 걸쳐 우리의 요청을 발행해야 한다. 또한, 수명이 긴 HTTP/1.1
연결은 일반적으로 일정 시간 후 만료되고 클라이언트(또는 서버)에 의해 끊어진다.
이 두 가지 요소를 결합하면 일반적으로 HTTP/1.1 요청이
여러 TCP 연결에서 순환하며, 연결 수준 밸런싱이 작동한다.</p><h1 id=그래서-우리는-어떻게-grpc의-부하를-분산할-수-있을까>그래서 우리는 어떻게 gRPC의 부하를 분산할 수 있을까??</h1><p>이제 gRPC로 돌아가보자. 연결 수준에서 밸런싱을 맞출 수 없기 때문에, gRPC 로드 밸런싱을
수행하려면, 연결 밸런싱에서 <em>요청</em> 밸런싱으로 전환해야
한다. 즉, 각각에 대한 HTTP/2 연결을 열어야
하고, 아래와 같이, 이러한 연결들로 <em>요청</em>의 밸런싱을 맞춘다.</p><p><img src=/images/blog/grpc-load-balancing-with-linkerd/Stereo-09aff9d7-1c98-4a0a-9184-9998ed83a531.png alt></p><p>네트워크 측면에서, L3/L4에서 결정을 내리기 보다는 L5/L7에서 결정을
내려야 한다. 즉, TCP 연결을 통해 전송된 프로토콜을 이해해야 한다.</p><p>우리는 이것을 어떻게 달성해야할까? 몇 가지 옵션이 있다. 먼저, 우리의 애플리케이션
코드는 대상에 대한 자체 로드 밸런싱 풀을 수동으로 유지 관리할 수 있고,
gRPC 클라이언트에 <a href=https://godoc.org/google.golang.org/grpc/balancer>로드 밸런싱 풀을
사용</a>하도록 구성할 수 있다. 이 접근 방식은
우리에게 높은 제어력을 제공하지만, 시간이 지남에 따라 파드가 리스케줄링(reschedule)되면서 풀이 변경되는
쿠버네티스와 같은 환경에서는 매우 복잡할 수 있다. 이 경우, 우리의
애플리케이션은 파드와 쿠버네티스 API를 관찰하고 자체적으로 최신 상태를
유지해야 한다.</p><p>대안으로, 쿠버네티스에서 앱을 <a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>헤드리스(headless)
서비스</a>로 배포할 수 있다.
이 경우, 쿠버네티스는 서비스를 위한 DNS 항목에
<a href=/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4>다중 A 레코드를 생성할 것이다</a>.
만약 충분히 진보한 gRPC 클라이언트를 사용한다면,
해당 DNS 항목에서 로드 밸런싱 풀을 자동으로 유지 관리할 수 있다.
그러나 이 접근 방식은 우리를 특정 gRPC 클라이언트로를 사용하도록 제한할 뿐만 아니라,
헤드리스 서비스만 사용하는 경우도 거의 없으므로 제약이 크다.</p><p>마지막으로, 세 번째 접근 방식을 취할 수 있다. 경량 프록시를 사용하는 것이다.</p><h1 id=linkerd를-사용하여-쿠버네티스에서-grpc-로드-밸런싱>Linkerd를 사용하여 쿠버네티스에서 gRPC 로드 밸런싱</h1><p><a href=https://linkerd.io>Linkerd</a>는 <a href=https://cncf.io>CNCF</a>에서 관리하는 쿠버네티스용
<em>서비스 메시</em>이다. 우리의 목적과 가장 관련이 깊은 Linkerd는, 클러스터 수준의 권한
없이도 단일 서비스에 적용할 수 있는
<em>서비스 사이드카</em>로써도 작동한다. Linkerd를 서비스에 추가하는
것은, ​​각 파드에 작고, 초고속인 프록시를 추가하는 것을 의미하며, 이러한 프록시가
쿠버네티스 API를 와치(watch)하고 gRPC 로드 밸런싱을 자동으로 수행하는 것을 의미이다. 우리가 수행한 배포는
다음과 같다.</p><p><img src=/images/blog/grpc-load-balancing-with-linkerd/Linkerd-8df1031c-cdd1-4164-8e91-00f2d941e93f.io.png alt></p><p>Linkerd를 사용하면 몇 가지 장점이 있다. 첫째, 어떠한 언어로 작성된 서비스든지, 어떤 gRPC 클라이언트든지
그리고 어떠한 배포 모델과도 (헤드리스 여부와 상관없이) 함께 작동한다.
Linkerd의 프록시는 완전히 투명하기 때문에, HTTP/2와 HTTP/1.x를 자동으로 감지하고
L7 로드 밸런싱을 수행하며, 다른 모든 트래픽을
순수한 TCP로 통과(pass through)시킨다. 이것은 모든 것이 <em>그냥 작동</em>한다는 것을 의미한다.</p><p>둘째, Linkerd의 로드 밸런싱은 매우 정교하다. Linkerd는
쿠버네티스 API에 대한 와치(watch)를 유지하고 파드가 리스케술링 될 때
로드 밸런싱 풀을 자동으로 갱신할 뿐만 아니라, Linkerd는 응답 대기 시간이 가장 빠른 파드에
요청을 자동으로 보내기 위해 <em>지수 가중 이동 평균(exponentially-weighted moving average)</em> 을
사용한다. 하나의 파드가 잠시라도 느려지면, Linkerd가 트래픽을
변경할 것이다. 이를 통해 종단 간 지연 시간을 줄일 수 있다.</p><p>마지막으로, Linkerd의 Rust 기반 프록시는 매우 작고 빠르다. 그것은 1ms 미만의
p99 지연 시간(&lt;1ms of p99 latency)을 지원할 뿐만 아니라, 파드당 10mb 미만의 RSS(&lt;10mb of RSS)만 필요로 하므로
시스템 성능에도 거의 영향을 미치지 않는다.</p><h1 id=60초-안에-grpc-부하-분산>60초 안에 gRPC 부하 분산</h1><p>Linkerd는 시도하기가 매우 쉽다. 단지 —랩탑에 CLI를 설치하고— <a href=https://linkerd.io/2/getting-started/>Linkerd 시작
지침</a>의 단계만 따르면 된다.
클러스터에 컨트롤 플레인과 "메시"
서비스(프록시를 각 파드에 주입)를 설치한다. 서비스에 Linkerd가 즉시
실행될 것이므로 적절한 gRPC 밸런싱을 즉시 확인할 수 있다.</p><p>Linkerd 설치 후에, 예시 <code>voting</code> 서비스를
다시 살펴보자.</p><p><img src=/images/blog/grpc-load-balancing-with-linkerd/Screenshot2018-11-0116-24b8ee81-144c-4eac-b73d-871bbf0ea22e.57.42.png alt></p><p>그림과 같이, 모든 파드에 대한 CPU 그래프가 활성화되어 모든 파드가
—코드를 변경하지 않았지만— 트래픽을 받고 있다. 짜잔,
마법처럼 gRPC 로드 밸런싱이 됐다!</p><p>Linkerd는 또한 내장된 트래픽 수준 대시보드를 제공하므로, 더 이상
CPU 차트에서 무슨 일이 일어나고 있는지 추측하는 것이 필요하지 않다. 다음은 각 파드의
성공률, 요청 볼륨 및 지연 시간 백분위수를 보여주는
Linkerd 그래프이다.</p><p><img src=/images/blog/grpc-load-balancing-with-linkerd/Screenshot2018-11-0212-15ed0448-5424-4e47-9828-20032de868b5.08.38.png alt></p><p>각 파드가 약 5 RPS를 얻고 있음을 알 수 있다. 또한,
로드 밸런싱 문제는 해결되었지만 해당 서비스의
성공률에 대해서는 아직 할 일이 남았다는 것도 살펴볼 수 있다. (데모 앱은 독자에 대한 연습을 위해 의도적으로
실패 상태로 만들었다. Linkerd 대시보드를 사용하여
문제를 해결할 수 있는지 살펴보자!)</p><h1 id=마지막으로>마지막으로</h1><p>쿠버네티스 서비스에 gRPC 로드 밸런싱을 추가하는 방법에
흥미가 있다면, 어떤 언어로 작성되었든 상관없이, 어떤 gRPC
클라이언트를 사용중이든지, 또는 어떻게 배포되었든지, Linkerd를 사용하여 단 몇 개의 명령으로
gRPC 로드 밸런싱을 추가할 수 있다.</p><p>보안, 안정성 및 디버깅을 포함하여 Linkerd에는 더 많은 특징
및 진단 기능이 있지만 이는 향후 블로그 게시물의 주제로 남겨두려 한다.</p><p>더 알고 싶은가? 빠르게 성장하고 있는 우리 커뮤니티는 여러분의 참여를 환영한다!
Linkerd는 <a href=https://cncf.io>CNCF</a> 프로젝트로
<a href=https://github.com/linkerd/linkerd2>GitHub에 호스팅 되어 있고</a>, <a href=https://slack.linkerd.io>Slack</a>,
<a href=https://twitter.com/linkerd>Twitter</a>, 그리고 <a href=https://lists.cncf.io/g/cncf-linkerd-users>이메일 리스트</a>를 통해 커뮤니티를 만날 수 있다.
접속하여 커뮤니티에 참여하는 즐거움을 느껴보길 바란다!</p><ul class="list-unstyled d-flex justify-content-between align-items-center mb-0 pt-5"><li><a class="btn btn-primary disabled"><span class=mr-1>←</span>이전</a></li><a href=/ko/blog/2020/12/02/dont-panic-kubernetes-and-docker/ aria-label="다음 - 당황하지 마세요. 쿠버네티스와 도커" class="btn btn-primary">다음<span class=ml-1>→</span></a></li></ul></div></main><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"><div class="td-page-blog-meta ml-2 pb-1 pt-2 mb-4"><link rel=alternate type=application/rss+xml href=https://kubernetes.io/ko/feed.xml title=Kubernetes><a class=widget-link href=https://kubernetes.io/ko/feed.xml><div><i class="fas fa-rss fab-icon"></i><span class=widget-link-text>RSS Feed</span></div></a><a class=widget-link href=https://kubernetes.io/docs/contribute/new-content/blogs-case-studies/><div><i class="fa fa-edit fab-icon"></i> <span class=widget-link-text>Submit a Post</span></div></a><a class=widget-link href=https://twitter.com/kubernetesio><div><i class="fab fa-twitter-square fab-icon"></i><span class=widget-link-text>@Kubernetesio</span></div></a><a class=widget-link href=https://github.com/kubernetes/kubernetes><div><i class="fab fa-github-square fab-icon"></i> <span class=widget-link-text>on GitHub</span></div></a><a class=widget-link href=http://slack.k8s.io><div><i class="fab fa-slack fab-icon"></i><span class=widget-link-text>#kubernetes-users</span></div></a><a class=widget-link href=https://stackoverflow.com/questions/tagged/kubernetes><div><i class="fab fa-stack-overflow fab-icon"></i> <span class=widget-link-text>Overflow</span></div></a><a class=widget-link href=https://discuss.kubernetes.io><div><i class="fab fa-discourse fab-icon"></i><span class=widget-link-text> Forum</span></div></a><a class=widget-link href=https://kubernetes.io/docs/setup><div><i class="fa fa-download fab-icon"></i> <span class=widget-link-text>Kubernetes</span></div></a></div></div></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ko/docs/home/>홈</a>
<a class=text-white href=/ko/blog/>블로그</a>
<a class=text-white href=/ko/training/>교육</a>
<a class=text-white href=/ko/partners/>파트너</a>
<a class=text-white href=/ko/community/>Community</a>
<a class=text-white href=/ko/case-studies/>사례 연구</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>