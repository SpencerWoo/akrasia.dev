<!doctype html><html lang=fr class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/workloads/controllers/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/workloads/controllers/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/workloads/controllers/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/workloads/controllers/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/workloads/controllers/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/workloads/controllers/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/workloads/controllers/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/fr/docs/concepts/workloads/controllers/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Contrôleurs | Kubernetes</title><meta property="og:title" content="Contrôleurs"><meta property="og:description" content="Solution professionnelle d’orchestration de conteneurs"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/fr/docs/concepts/workloads/controllers/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Contrôleurs"><meta itemprop=description content="Solution professionnelle d’orchestration de conteneurs"><meta name=twitter:card content="summary"><meta name=twitter:title content="Contrôleurs"><meta name=twitter:description content="Solution professionnelle d’orchestration de conteneurs"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/fr/docs/concepts/workloads/controllers/"><meta property="og:title" content="Contrôleurs"><meta name=twitter:title content="Contrôleurs"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/fr/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/fr/docs/>Documentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/blog/>Blog de Kubernetes</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/partners/>Partenaires</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/community/>Communauté</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/case-studies/>Études de cas</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/fr/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/fr/docs/concepts/workloads/controllers/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/fr/docs/concepts/workloads/controllers/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/fr/docs/concepts/workloads/controllers/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/fr/docs/concepts/workloads/controllers/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/fr/docs/concepts/workloads/controllers/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Français (French)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/workloads/controllers/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/workloads/controllers/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/workloads/controllers/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/workloads/controllers/>日本語 (Japanese)</a>
<a class=dropdown-item href=/es/docs/concepts/workloads/controllers/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/workloads/controllers/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/workloads/controllers/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/workloads/controllers/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Version imprimable multipages.
<a href=# onclick="return print(),!1">Cliquer ici pour imprimer</a>.</p><p><a href=/fr/docs/concepts/workloads/controllers/>Retour à la version par défaut</a>.</p></div><h1 class=title>Contrôleurs</h1><ul><li>1: <a href=#pg-d459b930218774655fa7fd1620625539>ReplicaSet</a></li><li>2: <a href=#pg-a2dc0393e0c4079e1c504b6429844e86>Déploiements</a></li><li>3: <a href=#pg-6d72299952c37ca8cc61b416e5bdbcd4>StatefulSets</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-d459b930218774655fa7fd1620625539>1 - ReplicaSet</h1><p>Un ReplicaSet (ensemble de réplicas en français) a pour but de maintenir un ensemble stable de Pods à un moment donné.
Cet objet est souvent utilisé pour garantir la disponibilité d'un certain nombre identique de Pods.</p><h2 id=comment-un-replicaset-fonctionne>Comment un ReplicaSet fonctionne</h2><p>Un ReplicaSet est défini avec des champs, incluant un selecteur qui spécifie comment identifier les Pods qu'il peut posséder,
un nombre de replicas indiquant le nombre de Pods qu'il doit maintenir et un modèle de Pod spécifiant les données que les
nouveaux Pods que le replicatSet va créer jusqu'au nombre de replicas demandé.</p><p>Un ReplicaSet va atteindre son objectif en créant et supprimant des Pods pour atteindre le nombre de réplicas désirés.
Quand un ReplicaSet a besoin de créer de nouveaux Pods, il utilise alors son Pod template.</p><p>Le lien d'un ReplicaSet à ses Pods est fait par le champ <a href=/docs/concepts/workloads/controllers/garbage-collection/#owners-and-dependents>metadata.ownerReferences</a>,
qui spécifie la ressource de l'objet par lequel il est détenu. Tous les Pods acquis par un ReplicaSet ont leurs propres informations d'identification de leur Replicaset, avec leur propre champ ownerReferences. C'est par ce lien que le ReplicaSet connait l'état des Pods qu'il maintient et agit en fonction de ces derniers.</p><p>Un ReplicaSet identifie des nouveaux Pods à acquérir en utilisant son selecteur.
Si il y a un Pod qui n'a pas de OwnerReference ou que OwnerReference n'est pas un controller et qu'il correspond à un sélecteur de ReplicaSet, il va immédiatement être acquis par ce ReplicaSet.</p><h2 id=quand-utiliser-un-replicaset>Quand utiliser un ReplicaSet ?</h2><p>Un ReplicaSet garantit qu’un nombre spécifié de réplicas de Pod soient exécutés à un moment donné.
Cependant, un Deployment est un concept de plus haut niveau qui gère les ReplicaSets et
fournit des mises à jour déclaratives aux Pods ainsi que de nombreuses autres fonctionnalités utiles.
Par conséquent, nous vous recommandons d’utiliser des Deployments au lieu d’utiliser directement des ReplicaSets, sauf si
vous avez besoin d'une orchestration personnalisée des mises à jour ou si vous n'avez pas besoin de mises à jour.</p><p>Cela signifie qu'il est possible que vous n'ayez jamais besoin de manipuler des objets ReplicaSet :
utilisez plutôt un déploiement et définissez votre application dans la section spec.</p><h2 id=exemple>Exemple</h2><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/controllers/frontend.yaml download=controllers/frontend.yaml><code>controllers/frontend.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-frontend-yaml")' title="Copy controllers/frontend.yaml to clipboard"></img></div><div class=includecode id=controllers-frontend-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># modify replicas according to your case</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-frontend:v3<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Enregistrer ce manifeste dans <code>frontend.yaml</code> et le soumettre à un cluster Kubernetes va créer le ReplicaSet défini et les pods qu’il gère.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>Vous pouvez ensuite récupérer les ReplicaSets actuellement déployés :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>Et voir le frontend que vous avez créé :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME       DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>frontend   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       6s
</span></span></code></pre></div><p>Vous pouvez également vérifier l'état du ReplicaSet :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe rs/frontend
</span></span></code></pre></div><p>Et vous verrez une sortie similaire à :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:		frontend
</span></span><span style=display:flex><span>Namespace:	default
</span></span><span style=display:flex><span>Selector:	<span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend,tier in <span style=color:#666>(</span>frontend<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Labels:		<span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
</span></span><span style=display:flex><span>		<span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
</span></span><span style=display:flex><span>Annotations:	&lt;none&gt;
</span></span><span style=display:flex><span>Replicas:	<span style=color:#666>3</span> current / <span style=color:#666>3</span> desired
</span></span><span style=display:flex><span>Pods Status:	<span style=color:#666>3</span> Running / <span style=color:#666>0</span> Waiting / <span style=color:#666>0</span> Succeeded / <span style=color:#666>0</span> Failed
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:       <span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
</span></span><span style=display:flex><span>                <span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   php-redis:
</span></span><span style=display:flex><span>    Image:      gcr.io/google_samples/gb-frontend:v3
</span></span><span style=display:flex><span>    Port:       80/TCP
</span></span><span style=display:flex><span>    Requests:
</span></span><span style=display:flex><span>      cpu:      100m
</span></span><span style=display:flex><span>      memory:   100Mi
</span></span><span style=display:flex><span>    Environment:
</span></span><span style=display:flex><span>      GET_HOSTS_FROM:   dns
</span></span><span style=display:flex><span>    Mounts:             &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:              &lt;none&gt;
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  FirstSeen    LastSeen    Count    From                SubobjectPath    Type        Reason            Message
</span></span><span style=display:flex><span>  ---------    --------    -----    ----                -------------    --------    ------            -------
</span></span><span style=display:flex><span>  1m           1m          <span style=color:#666>1</span>        <span style=color:#666>{</span>replicaset-controller <span style=color:#666>}</span>             Normal      SuccessfulCreate  Created pod: frontend-qhloh
</span></span><span style=display:flex><span>  1m           1m          <span style=color:#666>1</span>        <span style=color:#666>{</span>replicaset-controller <span style=color:#666>}</span>             Normal      SuccessfulCreate  Created pod: frontend-dnjpy
</span></span><span style=display:flex><span>  1m           1m          <span style=color:#666>1</span>        <span style=color:#666>{</span>replicaset-controller <span style=color:#666>}</span>             Normal      SuccessfulCreate  Created pod: frontend-9si5l
</span></span></code></pre></div><p>Et enfin, vous pourrez afficher les Pods déployés :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get Pods
</span></span></code></pre></div><p>Vous devriez voir des informations sur les Pods avec une sortie similaire à :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-9si5l   1/1       Running   <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-dnjpy   1/1       Running   <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-qhloh   1/1       Running   <span style=color:#666>0</span>          1m
</span></span></code></pre></div><p>Vous pouvez également vérifier que la OwnerReference de ces pods est définie sur le frontend ReplicaSet.
Pour ce faire, récupérez le yaml de l’un des pods :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods frontend-9si5l -o yaml
</span></span></code></pre></div><p>La sortie sera similaire à celle-ci, avec les informations de l'interface ReplicaSet frontend définies dans le champ ownerReferences des métadonnées:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Pod
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  creationTimestamp: 2019-01-31T17:20:41Z
</span></span><span style=display:flex><span>  generateName: frontend-
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    tier: frontend
</span></span><span style=display:flex><span>  name: frontend-9si5l
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  ownerReferences:
</span></span><span style=display:flex><span>  - apiVersion: extensions/v1beta1
</span></span><span style=display:flex><span>    blockOwnerDeletion: <span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>    controller: <span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>    kind: ReplicaSet
</span></span><span style=display:flex><span>    name: frontend
</span></span><span style=display:flex><span>    uid: 892a2330-257c-11e9-aecd-025000000001
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=acquisitions-de-pod-en-dehors-du-template>Acquisitions de Pod en dehors du template</h2><p>Bien que vous puissiez créer des pods manuellement sans problème, il est fortement recommandé de s’assurer que ces pods n'ont pas de
labels correspondant au sélecteur de l’un de vos ReplicaSets. Car un ReplicaSet n’est pas limité
à posséder les pods spécifiés par son modèle - il peut acquérir d’autres pods de la manière spécifiée dans les sections précédentes.</p><p>Prenez l'exemple précédent de ReplicaSet, ainsi que les pods spécifiés dans le manifeste suivant :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/pod-rs.yaml download=pods/pod-rs.yaml><code>pods/pod-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-rs-yaml")' title="Copy pods/pod-rs.yaml to clipboard"></img></div><div class=includecode id=pods-pod-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:2.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:1.0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Ces pods n’ayant pas de contrôleur (ni d’objet) en tant que référence propriétaire, ils correspondent au sélecteur de du ReplicaSet frontend, ils seront donc immédiatement acquis par ce ReplicaSet.</p><p>Supposons que vous créiez les pods une fois le ReplicaSet frontend déployé et qui a déjà déployé ses replicas de Pods initiaux afin de
remplir son exigence de nombre de replicas :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>Les nouveaux pods seront acquis par le ReplicaSet, puis immédiatement terminés car le ReplicaSet dépasserait alors le compte désiré.</p><p>En récupérant les pods :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get Pods
</span></span></code></pre></div><p>La sortie montre que les nouveaux pods sont soit déjà terminés, soit en voie de l'être :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY   STATUS        RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-9si5l   1/1     Running       <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-dnjpy   1/1     Running       <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-qhloh   1/1     Running       <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>pod2             0/1     Terminating   <span style=color:#666>0</span>          4s
</span></span></code></pre></div><p>Cependant, si vous créez d'abord les pods :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>Et puis créez le ReplicaSet :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>Vous verrez que le ReplicaSet a acquis les pods et n'a créé que les nouveaux Pods manquants, conformément à ses spécifications,
jusqu'au nombre souhaité de Pods. En récupérant les Pods :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get Pods
</span></span></code></pre></div><p>La sortie va donner :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY   STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-pxj4r   1/1     Running   <span style=color:#666>0</span>          5s
</span></span><span style=display:flex><span>pod1             1/1     Running   <span style=color:#666>0</span>          13s
</span></span><span style=display:flex><span>pod2             1/1     Running   <span style=color:#666>0</span>          13s
</span></span></code></pre></div><p>De cette manière, un ReplicaSet peut avoir un ensemble de Pods hétérogène.</p><h2 id=écrire-un-manifest-de-replicaset>Écrire un manifest de ReplicaSet</h2><p>Comme avec tous les autres objets API Kubernetes, un ReplicaSet a besoin des champs <code>apiVersion</code>, <code>kind</code> et <code>metadata</code>.
Pour ReplicaSets, l'attribut <code>kind</code> est toujours ReplicaSet.</p><p>Dans Kubernetes 1.9, la version de l'API <code>apps/v1</code> pour le type ReplicaSet est la version actuelle et activée par défaut. La version de l'API <code>apps/v1beta2</code> est obsolète.</p><p>Reportez-vous aux premières lignes de l'exemple <code>frontend.yaml</code> pour obtenir des conseils.</p><p>Un ReplicaSet a également besoin de <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> section</a>.</p><h3 id=pod-template>Pod Template</h3><p>L'attribut <code>.spec.template</code> est un <a href=/docs/concepts/workloads/Pods/pod-overview/#pod-templates>modèle de pod</a> qui requiert d'avoir des labels. Dans notre exemple <code>frontend.yaml</code>, nous avons un label : <code>tier: frontend</code>.
Il faut faire attention à ne pas avoir des selecteurs que d'autres controllers utilisent, afin d'éviter que le ReplicaSet n'adopte ce pod.</p><p>Pour le champ <a href=/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy>restart policy</a>,
<code>.spec.template.spec.restartPolicy</code>, la seule valeur autorisée est <code>Always</code>, qui est la valeur par défaut.</p><h3 id=sélecteur-de-pod>Sélecteur de Pod</h3><p>Le champ <code>.spec.selector</code> est un <a href=/docs/concepts/overview/working-with-objects/labels/>label selector</a>. Tel que discuté
<a href=#how-a-replicaset-works>précédemment</a>, ce sont les labels utilisés pour identifier les Pods potentiels à acquérir. Dans notre
exemple avec <code>frontend.yaml</code>, le sélecteur était :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>matchLabels:
</span></span><span style=display:flex><span>	tier: frontend
</span></span></code></pre></div><p>Dans le ReplicaSet, <code>.spec.template.metadata.labels</code> doit correspondre à <code>spec.selector</code>, ou sinon il sera rejeté par l'API.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Pour 2 ReplicaSets spécifiant le même <code>.spec.selector</code> mais différents <code>.spec.template.metadata.labels</code> et <code>.spec.template.spec</code>, chaque ReplicaSet ignore les pods créés par l'autre ReplicaSet.</div><h3 id=replicas>Replicas</h3><p>Vous pouvez spécifier le nombre de pods à exécuter simultanément en définissant <code>.spec.replicas</code>. Le ReplicaSet va créer/supprimer
ses pods pour correspondre à ce nombre.</p><p>Si vous ne spécifiez pas <code>.spec.replicas</code>, la valeur par défaut est 1.</p><h2 id=travailler-avec-des-replicasets>Travailler avec des ReplicaSets</h2><h3 id=suppression-d-un-replicaset-et-de-ses-pods>Suppression d'un ReplicaSet et de ses pods</h3><p>Pour supprimer un ReplicaSet et tous ses pods, utilisez <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>. The <a href=/docs/concepts/workloads/controllers/garbage-collection/>Garbage collector</a> supprime automatiquement tous les pods associés par défaut.</p><p>Lors de l’utilisation de l’API REST ou de la bibliothèque <code>client-go</code>, vous devez définir <code>propagationPolicy</code> sur <code>Background</code> ou <code>Foreground</code> dans
l'option -d.
Par exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><h3 id=supprimer-juste-un-replicaset>Supprimer juste un ReplicaSet</h3><p>Vous pouvez supprimer un ReplicaSet sans affecter ses pods à l’aide de <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a> avec l'option <code>--cascade=false</code>.
Lorsque vous utilisez l'API REST ou la bibliothèque <code>client-go</code>, vous devez définir <code>propagationPolicy</code> sur <code>Orphan</code>.
Par exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>Une fois l’original supprimé, vous pouvez créer un nouveau ReplicaSet pour le remplacer. Tant que l'ancien et le nouveau <code>.spec.selector</code> sont identiques, le nouveau adoptera les anciens Pods.
Cependant, le ReplicaSet ne fera aucun effort pour que les pods existants correspondent à un nouveau Pod template.
Pour mettre à jour les Pods à une nouvelle spec de manière contrôlée, utilisez un
<a href=/docs/concepts/workloads/controllers/deployment/#creating-a-deployment>Deployment</a>, car les ReplicaSets ne supportent pas de rolling update directement.</p><h3 id=isoler-les-pods-d-un-replicaset>Isoler les pods d'un ReplicaSet</h3><p>Vous pouvez supprimer les pods d'un ReplicaSet en modifiant leurs labels. Cette technique peut être utilisée pour enlever les pods
pour le débogage, récupération de données, etc. Les pods ainsi supprimés seront automatiquement remplacés
(en supposant que le nombre de réplicas n’est pas également modifié).</p><h3 id=scaling-d-un-replicaset>Scaling d'un ReplicaSet</h3><p>Un ReplicaSet peut facilement être scalé en mettant simplement à jour le champ <code>.spec.replicas</code>. Le contrôleur ReplicaSet
garantit que le nombre souhaité de pods avec un sélecteur de label correspondant soient disponibles et opérationnels.</p><h3 id=replicaset-en-tant-que-horizontal-pod-autoscaler-target>ReplicaSet en tant que Horizontal Pod Autoscaler Target</h3><p>Un ReplicaSet peut également être une cible pour
<a href=/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscalers (HPA)</a>.
Un ReplicaSet peut être mis à l'échelle automatiquement par un HPA. Voici un exemple HPA qui cible
le ReplicaSet que nous avons créé dans l'exemple précédent.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/controllers/hpa-rs.yaml download=controllers/hpa-rs.yaml><code>controllers/hpa-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-hpa-rs-yaml")' title="Copy controllers/hpa-rs.yaml to clipboard"></img></div><div class=includecode id=controllers-hpa-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-scaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Enregistrer ce manifeste dans <code>hpa-rs.yaml</code> et le soumettre à un cluster Kubernetes devrait
créer le HPA défini qui scale automatiquement le ReplicaSet cible en fonction de l'utilisation du processeur
des pods répliqués.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/hpa-rs.yaml
</span></span></code></pre></div><p>Vous pouvez aussi utiliser la commande <code>kubectl autoscale</code> pour accomplir la même chose.
(et c'est plus facile !)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale rs frontend --max<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><h2 id=alternatives-au-replicaset>Alternatives au ReplicaSet</h2><h3 id=deployment-recommandé>Deployment (recommandé)</h3><p>Le <a href=/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a> est un object qui peut posséder les ReplicaSets et les mettres à jour ainsi que leurs Pods de façon déclarative, côté serveur et avec des rolling updates.</p><p>Alors que les ReplicaSets peuvent être utilisés indépendamment, ils sont principalement utilisés aujourd'hui par Deployments comme mécanisme pour orchestrer la création, suppresion et mises à jour des Pods.
Lorsque vous utilisez des Deployments, vous n’aurez plus à vous soucier de la gestion des ReplicaSets ainsi créés.
Les déploiements possèdent et gèrent leurs ReplicaSets.
C'est pourquoi il est recommandé d’utiliser les déploiements lorsque vous voulez des ReplicaSets.</p><h3 id=pods-nus>Pods nus</h3><p>Contrairement au cas où un utilisateur a créé directement des pods, un ReplicaSet remplace les pods supprimés ou terminés pour quelque raison que ce soit, par exemple en cas de défaillance d'un nœud ou de maintenance de nœud perturbateur, telle qu'une mise à jour kernel. Pour cette raison, nous vous recommandons d'utiliser un ReplicaSet même si votre application ne nécessite qu'un seul pod. Pensez-y de la même manière qu’un superviseur de processus, mais il supervise plusieurs pods sur plusieurs nœuds au lieu de processus individuels sur un seul nœud. Un ReplicaSet délègue les redémarrages de conteneurs locaux à un agent du nœud (par exemple, Kubelet ou Docker).</p><h3 id=job>Job</h3><p>Utilisez un <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/><code>Job</code></a> au lieu d'un ReplicaSet pour les pods qui doivent se terminer seuls
(c'est à dire des batch jobs).</p><h3 id=daemonset>DaemonSet</h3><p>Utilisez un <a href=/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a> au lieu d’un ReplicaSet pour les pods qui fournissent une
fonction au niveau du noeud, comme le monitoring ou la gestion des logs de ce noeud. Ces pods ont une durée de vie qui est liée
durée de vie d’une machine : le pod doit être en cours d’exécution sur la machine avant le démarrage des autres Pods et sont
sûrs de se terminer lorsque la machine est prête à être redémarrée/arrêtée.</p><h3 id=replicationcontroller>ReplicationController</h3><p>Les ReplicaSets sont les successeurs de <a href=/docs/concepts/workloads/controllers/replicationcontroller/><em>ReplicationControllers</em></a>.
Les deux servent le même objectif et se comportent de la même manière, à la différence près que ReplicationController ne prend pas en charge les
les exigences de sélecteur décrites dans le <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>labels user guide</a>.
En tant que tels, les ReplicaSets sont préférés aux ReplicationControllers.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a2dc0393e0c4079e1c504b6429844e86>2 - Déploiements</h1><p>Un <em>Deployment</em> (déploiement en français) fournit des mises à jour déclaratives pour <a href=/fr/docs/concepts/workloads/pods/pod/>Pods</a> et <a href=/fr/docs/concepts/workloads/controllers/replicaset/>ReplicaSets</a>.</p><p>Vous décrivez un <em>état désiré</em> dans un déploiement et le <a class=glossary-tooltip title="Boucle de contrôle surveillant l'état partagé du cluster à travers l'apiserver et effectuant des changements en essayant de déplacer l'état actuel vers l'état désiré." data-toggle=tooltip data-placement=top href=/docs/admin/kube-controller-manager/ target=_blank aria-label=controlleur>controlleur</a> déploiement change l'état réel à l'état souhaité à un rythme contrôlé.
Vous pouvez définir des Deployments pour créer de nouveaux ReplicaSets, ou pour supprimer des déploiements existants et adopter toutes leurs ressources avec de nouveaux déploiements.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Ne gérez pas les ReplicaSets appartenant à un Deployment.
Pensez à ouvrir un ticket dans le dépot Kubernetes principal si votre cas d'utilisation n'est pas traité ci-dessous.</div><h2 id=cas-d-utilisation>Cas d'utilisation</h2><p>Voici des cas d'utilisation typiques pour les déploiements:</p><ul><li><a href=#cr%C3%A9ation-dun-d%C3%A9ploiement>Créer un déploiement pour déployer un ReplicaSet</a>.
Le ReplicaSet crée des pods en arrière-plan.
Vérifiez l'état du déploiement pour voir s'il réussit ou non.</li><li><a href=#mise-%C3%A0-jour-dun-d%C3%A9ploiement>Déclarez le nouvel état des Pods</a> en mettant à jour le PodTemplateSpec du déploiement.
Un nouveau ReplicaSet est créé et le déploiement gère le déplacement des pods de l'ancien ReplicaSet vers le nouveau à un rythme contrôlé.
Chaque nouveau ReplicaSet met à jour la révision du déploiement.</li><li><a href=#annulation-dun-d%C3%A9ploiement>Revenir à une révision de déploiement antérieure</a> si l'état actuel du déploiement n'est pas stable.
Chaque restauration met à jour la révision du déploiement.</li><li><a href=#mise-%C3%A0-l%C3%A9chelle-dun-d%C3%A9ploiement>Augmentez le déploiement pour traiter plus de charge</a>.</li><li><a href=#pause-et-reprise-dun-d%C3%A9ploiement>Suspendre le déploiement</a> d'appliquer plusieurs correctifs à son PodTemplateSpec, puis de le reprendre pour démarrer un nouveau déploiement.</li><li><a href=#statut-de-d%C3%A9ploiement>Utiliser l'état du déploiement</a> comme indicateur qu'un déploiement est bloqué.</li><li><a href=#politique-de-nettoyage>Nettoyer les anciens ReplicaSets</a> dont vous n'avez plus besoin.</li></ul><h2 id=création-d-un-déploiement>Création d'un déploiement</h2><p>Voici un exemple de déploiement.
Il crée un ReplicaSet pour faire apparaître trois pods <code>nginx</code>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/controllers/nginx-deployment.yaml download=controllers/nginx-deployment.yaml><code>controllers/nginx-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-nginx-deployment-yaml")' title="Copy controllers/nginx-deployment.yaml to clipboard"></img></div><div class=includecode id=controllers-nginx-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dans cet exemple:</p><ul><li><p>Un déploiement nommé <code>nginx-deployment</code> est créé, indiqué par le champ <code>.metadata.name</code>.</p></li><li><p>Le déploiement crée trois pods répliqués, indiqués par le champ <code>replicas</code>.</p></li><li><p>Le champ <code>selector</code> définit comment le déploiement trouve les pods à gérer.
Dans ce cas, vous sélectionnez simplement un label définie dans le template de pod (<code>app:nginx</code>).
Cependant, des règles de sélection plus sophistiquées sont possibles, tant que le modèle de pod satisfait lui-même la règle.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le champ <code>matchLabels</code> est une table de hash {clé, valeur}.
Une seule {clé, valeur} dans la table <code>matchLabels</code> est équivalente à un élément de <code>matchExpressions</code>, dont le champ clé est "clé", l'opérateur est "In" et le tableau de valeurs contient uniquement "valeur".
Toutes les exigences, à la fois de <code>matchLabels</code> et de <code>matchExpressions</code>, doivent être satisfaites pour correspondre.</div></li><li><p>Le champ <code>template</code> contient les sous-champs suivants:</p><ul><li>Les Pods reçoivent le label <code>app:nginx</code> dans le champ <code>labels</code>.</li><li>La spécification du template de pod dans le champ <code>.template.spec</code>, indique que les pods exécutent un conteneur, <code>nginx</code>, qui utilise l'image <code>nginx</code> <a href=https://hub.docker.com/>Docker Hub</a> à la version 1.7.9.</li><li>Créez un conteneur et nommez-le <code>nginx</code> en utilisant le champ <code>name</code>.</li></ul></li></ul><p>Suivez les étapes ci-dessous pour créer le déploiement ci-dessus:</p><p>Avant de commencer, assurez-vous que votre cluster Kubernetes est opérationnel.</p><ol><li><p>Créez le déploiement en exécutant la commande suivante:</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous pouvez spécifier l'indicateur <code>--record</code> pour écrire la commande exécutée dans l'annotation de ressource <code>kubernetes.io/change-cause</code>.
C'est utile pour une future introspection.
Par exemple, pour voir les commandes exécutées dans chaque révision de déploiement.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml
</span></span></code></pre></div></li><li><p>Exécutez <code>kubectl get deployments</code> pour vérifier si le déploiement a été créé.
Si le déploiement est toujours en cours de création, la sortie est similaire à:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   0/3     <span style=color:#666>0</span>            <span style=color:#666>0</span>           1s
</span></span></code></pre></div><p>Lorsque vous inspectez les déploiements de votre cluster, les champs suivants s'affichent:</p><ul><li><code>NAME</code> répertorie les noms des déploiements dans le cluster.</li><li><code>DESIRED</code> affiche le nombre souhaité de <em>répliques</em> de l'application, que vous définissez lorsque vous créez le déploiement.
C'est l'<em>état désiré</em>.</li><li><code>CURRENT</code> affiche le nombre de réplicas en cours d'exécution.</li><li><code>UP-TO-DATE</code> affiche le nombre de réplicas qui ont été mises à jour pour atteindre l'état souhaité.</li><li><code>AVAILABLE</code> affiche le nombre de réplicas de l'application disponibles pour vos utilisateurs.</li><li><code>AGE</code> affiche la durée d'exécution de l'application.</li></ul><p>Notez que le nombre de réplicas souhaitées est de 3 selon le champ <code>.spec.replicas</code>.</p></li><li><p>Pour voir l'état du déploiement, exécutez:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Waiting <span style=color:#a2f;font-weight:700>for</span> rollout to finish: <span style=color:#666>2</span> out of <span style=color:#666>3</span> new replicas have been updated...
</span></span><span style=display:flex><span>deployment <span style=color:#b44>&#34;nginx-deployment&#34;</span> successfully rolled out
</span></span></code></pre></div></li><li><p>Exécutez à nouveau <code>kubectl get deployments</code> quelques secondes plus tard.
La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   3/3     3            3           18s
</span></span></code></pre></div><p>Notez que le déploiement a créé les trois répliques et que toutes les répliques sont à jour (elles contiennent le dernier modèle de pod) et disponibles.</p></li><li><p>Pour voir le ReplicaSet (<code>rs</code>) créé par le déploiement, exécutez <code>kubectl get rs</code>.
La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>nginx-deployment-75675f5897   3         3         3       18s
</span></span></code></pre></div><p>Notez que le nom du ReplicaSet est toujours formaté comme: <code>[DEPLOYMENT-NAME]-[RANDOM-STRING]</code>.
La chaîne aléatoire est générée aléatoirement et utilise le pod-template-hash comme graine.</p></li><li><p>Pour voir les labels générées automatiquement pour chaque Pod, exécutez <code>kubectl get pods --show-labels</code>.
La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                                READY     STATUS    RESTARTS   AGE       LABELS
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-7ci7o   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-kzszj   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-qqcnn   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
</span></span></code></pre></div></li></ol><p>Le ReplicaSet créé garantit qu'il y a trois pods <code>nginx</code>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous devez spécifier un sélecteur approprié et des labels de template de pod dans un déploiement (dans ce cas, <code>app: nginx</code>).
Ne superposez pas les étiquettes ou les sélecteurs avec d'autres contrôleurs (y compris d'autres déploiements et StatefulSets).
Kubernetes n'empêche pas les chevauchements de noms, et si plusieurs contrôleurs ont des sélecteurs qui se chevauchent, ces contrôleurs peuvent entrer en conflit et se comporter de façon inattendue.</div><h3 id=étiquette-pod-template-hash>Étiquette pod-template-hash</h3><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Ne modifiez pas ce label.</div><p>Le label <code>pod-template-hash</code> est ajoutée par le contrôleur de déploiement à chaque ReplicaSet créé ou adopté par un déploiement.</p><p>Ce label garantit que les ReplicaSets enfants d'un déploiement ne se chevauchent pas.
Il est généré en hachant le <code>PodTemplate</code> du ReplicaSet et en utilisant le hachage résultant comme valeur de label qui est ajoutée au sélecteur ReplicaSet, aux labels de template de pod et dans tous les pods existants que le ReplicaSet peut avoir.</p><h2 id=mise-à-jour-d-un-déploiement>Mise à jour d'un déploiement</h2><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le re-déploiement d'un déploiement est déclenché si et seulement si le modèle de pod du déploiement (c'est-à-dire <code>.spec.template</code>) est modifié, par exemple si les labels ou les images de conteneur du template sont mis à jour.
D'autres mises à jour, telles que la mise à l'échelle du déploiement, ne déclenchent pas de rollout.</div><p>Suivez les étapes ci-dessous pour mettre à jour votre déploiement:</p><ol><li><p>Mettons à jour les pods nginx pour utiliser l'image <code>nginx: 1.9.1</code> au lieu de l'image <code>nginx: 1.7.9</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl --record deployment.apps/nginx-deployment <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.9.1
</span></span></code></pre></div><p>ou utilisez la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.9.1 --record
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment image updated
</span></span></code></pre></div><p>Alternativement, vous pouvez <code>éditer</code> le déploiement et changer <code>.spec.template.spec.containers[0].image</code> de <code>nginx: 1.7.9</code> à <code>nginx: 1.9.1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment edited
</span></span></code></pre></div></li><li><p>Pour voir l'état du déploiement, exécutez:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
</span></span></code></pre></div><p>ou</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment &#34;nginx-deployment&#34; successfully rolled out
</span></span></code></pre></div></li></ol><p>Obtenez plus de détails sur votre déploiement mis à jour:</p><ul><li><p>Une fois le déploiement réussi, vous pouvez afficher le déploiement en exécutant <code>kubectl get deployments</code>.
La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   3/3     3            3           36s
</span></span></code></pre></div></li><li><p>Exécutez <code>kubectl get rs</code> pour voir que le déploiement a mis à jour les pods en créant un nouveau ReplicaSet et en le redimensionnant jusqu'à 3 replicas, ainsi qu'en réduisant l'ancien ReplicaSet à 0 réplicas.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>nginx-deployment-1564180365   3         3         3       6s
</span></span><span style=display:flex><span>nginx-deployment-2035384211   0         0         0       36s
</span></span></code></pre></div></li><li><p>L'exécution de <code>kubectl get pods</code> ne devrait désormais afficher que les nouveaux pods:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                                READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>nginx-deployment-1564180365-khku8   1/1       Running   0          14s
</span></span><span style=display:flex><span>nginx-deployment-1564180365-nacti   1/1       Running   0          14s
</span></span><span style=display:flex><span>nginx-deployment-1564180365-z9gth   1/1       Running   0          14s
</span></span></code></pre></div><p>La prochaine fois que vous souhaitez mettre à jour ces pods, il vous suffit de mettre à jour le modèle de pod de déploiement à nouveau.</p><p>Le déploiement garantit que seul un certain nombre de pods sont en panne pendant leur mise à jour.
Par défaut, il garantit qu'au moins 75% du nombre souhaité de pods sont en place (25% max indisponible).</p><p>Le déploiement garantit également que seul un certain nombre de pods sont créés au-dessus du nombre souhaité de pods.
Par défaut, il garantit qu'au plus 125% du nombre de pods souhaité sont en hausse (surtension maximale de 25%).</p><p>Par exemple, si vous regardez attentivement le déploiement ci-dessus, vous verrez qu'il a d'abord créé un nouveau pod, puis supprimé certains anciens pods et en a créé de nouveaux.
Il ne tue pas les anciens Pods tant qu'un nombre suffisant de nouveaux Pods n'est pas apparu, et ne crée pas de nouveaux Pods tant qu'un nombre suffisant de Pods anciens n'a pas été tué.
Il s'assure qu'au moins 2 pods sont disponibles et qu'au maximum 4 pods au total sont disponibles.</p></li><li><p>Obtenez les détails de votre déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployments
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:                   nginx-deployment
</span></span><span style=display:flex><span>Namespace:              default
</span></span><span style=display:flex><span>CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
</span></span><span style=display:flex><span>Labels:                 app=nginx
</span></span><span style=display:flex><span>Annotations:            deployment.kubernetes.io/revision=2
</span></span><span style=display:flex><span>Selector:               app=nginx
</span></span><span style=display:flex><span>Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
</span></span><span style=display:flex><span>StrategyType:           RollingUpdate
</span></span><span style=display:flex><span>MinReadySeconds:        0
</span></span><span style=display:flex><span>RollingUpdateStrategy:  25% max unavailable, 25% max surge
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>    Labels:  app=nginx
</span></span><span style=display:flex><span>    Containers:
</span></span><span style=display:flex><span>    nginx:
</span></span><span style=display:flex><span>        Image:        nginx:1.9.1
</span></span><span style=display:flex><span>        Port:         80/TCP
</span></span><span style=display:flex><span>        Environment:  &lt;none&gt;
</span></span><span style=display:flex><span>        Mounts:       &lt;none&gt;
</span></span><span style=display:flex><span>    Volumes:        &lt;none&gt;
</span></span><span style=display:flex><span>    Conditions:
</span></span><span style=display:flex><span>    Type           Status  Reason
</span></span><span style=display:flex><span>    ----           ------  ------
</span></span><span style=display:flex><span>    Available      True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>    Progressing    True    NewReplicaSetAvailable
</span></span><span style=display:flex><span>    OldReplicaSets:  &lt;none&gt;
</span></span><span style=display:flex><span>    NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)
</span></span><span style=display:flex><span>    Events:
</span></span><span style=display:flex><span>    Type    Reason             Age   From                   Message
</span></span><span style=display:flex><span>    ----    ------             ----  ----                   -------
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
</span></span></code></pre></div><p>Ici, vous voyez que lorsque vous avez créé le déploiement pour la première fois, il a créé un ReplicaSet (nginx-deployment-2035384211) et l'a mis à l'échelle directement jusqu'à 3 réplicas.
Lorsque vous avez mis à jour le déploiement, il a créé un nouveau ReplicaSet (nginx-deployment-1564180365) et l'a mis à l'échelle jusqu'à 1, puis a réduit l'ancien ReplicaSet à 2, de sorte qu'au moins 2 pods étaient disponibles et au plus 4 pods ont été créés à chaque fois.
Il a ensuite poursuivi la montée en puissance du nouveau et de l'ancien ReplicaSet, avec la même stratégie de mise à jour continue.
Enfin, vous aurez 3 réplicas disponibles dans le nouveau ReplicaSet, et l'ancien ReplicaSet est réduit à 0.</p></li></ul><h3 id=rollover>Rollover (alias plusieurs mises à jour en vol)</h3><p>Chaque fois qu'un nouveau déploiement est observé par le contrôleur de déploiement, un ReplicaSet est créé pour afficher les pods souhaités.
Si le déploiement est mis à jour, le ReplicaSet existant qui contrôle les pods dont les étiquettes correspondent à <code>.spec.selector</code> mais dont le modèle ne correspond pas à <code>.spec.template</code> est réduit.
Finalement, le nouveau ReplicaSet est mis à l'échelle à <code>.spec.replicas</code> et tous les anciens ReplicaSets sont mis à l'échelle à 0.</p><p>Si vous mettez à jour un déploiement alors qu'un déploiement existant est en cours, le déploiement crée un nouveau ReplicaSet conformément à la mise à jour et commence à le mettre à l'échelle, et arrête de mettre à jour le ReplicaSet qu'il augmentait précédemment - il l'ajoutera à sa liste de anciens ReplicaSets et commencera à le réduire.</p><p>Par exemple, supposons que vous créez un déploiement pour créer 5 répliques de <code>nginx: 1.7.9</code>, puis mettez à jour le déploiement pour créer 5 répliques de <code>nginx: 1.9.1</code>, alors que seulement 3 répliques de <code>nginx:1.7.9</code> avait été créés.
Dans ce cas, le déploiement commence immédiatement à tuer les 3 pods <code>nginx: 1.7.9</code> qu'il avait créés et commence à créer des pods <code>nginx: 1.9.1</code>.
Il n'attend pas que les 5 répliques de <code>nginx: 1.7.9</code> soient créées avant de changer de cap.</p><h3 id=mises-à-jour-du-sélecteur-de-labels>Mises à jour du sélecteur de labels</h3><p>Il est généralement déconseillé de mettre à jour le sélecteur de labels et il est suggéré de planifier vos sélecteurs à l'avance.
Dans tous les cas, si vous devez effectuer une mise à jour du sélecteur de labels, soyez très prudent et assurez-vous d'avoir saisi toutes les implications.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Dans la version d'API <code>apps/v1</code>, le sélecteur de label d'un déploiement est immuable après sa création.</div><ul><li>Les ajouts de sélecteur nécessitent que les labels de template de pod dans la spécification de déploiement soient également mises à jour avec les nouveaux labels, sinon une erreur de validation est renvoyée.
Cette modification ne se chevauche pas, ce qui signifie que le nouveau sélecteur ne sélectionne pas les ReplicaSets et les pods créés avec l'ancien sélecteur, ce qui entraîne la perte de tous les anciens ReplicaSets et la création d'un nouveau ReplicaSet.</li><li>Les mises à jour du sélecteur modifient la valeur existante dans une clé de sélection - entraînent le même comportement que les ajouts.</li><li>La suppression de sélecteur supprime une clé existante du sélecteur de déploiement - ne nécessite aucune modification dans les labels du template de pod.
Les ReplicaSets existants ne sont pas orphelins et aucun nouveau ReplicaSet n'est créé, mais notez que le label supprimé existe toujours dans tous les Pods et ReplicaSets existants.</li></ul><h2 id=annulation-d-un-déploiement>Annulation d'un déploiement</h2><p>Parfois, vous souhaiterez peut-être annuler un déploiement; par exemple, lorsque le déploiement n'est pas stable, comme en cas d'échecs à répétition (CrashLoopBackOff).
Par défaut, tout l'historique des déploiements d'un déploiement est conservé dans le système afin que vous puissiez le restaurer à tout moment (vous pouvez le modifier en modifiant la limite de l'historique des révisions).</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> La révision d'un déploiement est créée lorsque le déploiement d'un déploiement est déclenché.
Cela signifie qu'une nouvelle révision est créée si et seulement si le template de pod de déploiement (<code>.spec.template</code>) est modifié, par exemple si vous mettez à jour les labels ou les images de conteneur du template.
D'autres mises à jour, telles que la mise à l'échelle du déploiement, ne créent pas de révision de déploiement, de sorte que vous puissiez faciliter la mise à l'échelle manuelle ou automatique simultanée.
Cela signifie que lorsque vous revenez à une révision antérieure, seule la partie du template de pod de déploiement est annulée.</div><ul><li><p>Supposons que vous ayez fait une faute de frappe lors de la mise à jour du déploiement, en mettant le nom de l'image sous la forme <code>nginx:1.91</code> au lieu de <code>nginx: 1.9.1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.91 --record<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment image updated
</span></span></code></pre></div></li><li><p>Le déploiement est bloqué.
Vous pouvez le vérifier en vérifiant l'état du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
</span></span></code></pre></div></li><li><p>Appuyez sur Ctrl-C pour arrêter la surveillance d'état de déploiement ci-dessus.
Pour plus d'informations sur les déploiements bloqués, <a href=#deployment-status>en savoir plus ici</a>.</p></li><li><p>Vous voyez que le nombre d'anciens réplicas (<code>nginx-deployment-1564180365</code> et <code>nginx-deployment-2035384211</code>) est 2, et les nouveaux réplicas (<code>nginx-deployment-3066724191</code>) est 1.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>nginx-deployment-1564180365   3         3         3       25s
</span></span><span style=display:flex><span>nginx-deployment-2035384211   0         0         0       36s
</span></span><span style=display:flex><span>nginx-deployment-3066724191   1         1         0       6s
</span></span></code></pre></div></li><li><p>En regardant les pods créés, vous voyez que 1 pod créé par le nouveau ReplicaSet est coincé dans une boucle pour récupérer son image:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                                READY     STATUS             RESTARTS   AGE
</span></span><span style=display:flex><span>nginx-deployment-1564180365-70iae   1/1       Running            0          25s
</span></span><span style=display:flex><span>nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
</span></span><span style=display:flex><span>nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
</span></span><span style=display:flex><span>nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le contrôleur de déploiement arrête automatiquement le mauvais déploiement et arrête la mise à l'échelle du nouveau ReplicaSet.
Cela dépend des paramètres rollingUpdate (<code>maxUnavailable</code> spécifiquement) que vous avez spécifiés.
Kubernetes définit par défaut la valeur à 25%.</div></li><li><p>Obtenez la description du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:           nginx-deployment
</span></span><span style=display:flex><span>Namespace:      default
</span></span><span style=display:flex><span>CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
</span></span><span style=display:flex><span>Labels:         app=nginx
</span></span><span style=display:flex><span>Selector:       app=nginx
</span></span><span style=display:flex><span>Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable
</span></span><span style=display:flex><span>StrategyType:       RollingUpdate
</span></span><span style=display:flex><span>MinReadySeconds:    0
</span></span><span style=display:flex><span>RollingUpdateStrategy:  25% max unavailable, 25% max surge
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:  app=nginx
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   nginx:
</span></span><span style=display:flex><span>    Image:        nginx:1.91
</span></span><span style=display:flex><span>    Port:         80/TCP
</span></span><span style=display:flex><span>    Host Port:    0/TCP
</span></span><span style=display:flex><span>    Environment:  &lt;none&gt;
</span></span><span style=display:flex><span>    Mounts:       &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:        &lt;none&gt;
</span></span><span style=display:flex><span>Conditions:
</span></span><span style=display:flex><span>  Type           Status  Reason
</span></span><span style=display:flex><span>  ----           ------  ------
</span></span><span style=display:flex><span>  Available      True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>  Progressing    True    ReplicaSetUpdated
</span></span><span style=display:flex><span>OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)
</span></span><span style=display:flex><span>NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  FirstSeen LastSeen    Count   From                    SubObjectPath   Type        Reason              Message
</span></span><span style=display:flex><span>  --------- --------    -----   ----                    -------------   --------    ------              -------
</span></span><span style=display:flex><span>  1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
</span></span><span style=display:flex><span>  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
</span></span><span style=display:flex><span>  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
</span></span><span style=display:flex><span>  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
</span></span><span style=display:flex><span>  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1
</span></span><span style=display:flex><span>  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
</span></span><span style=display:flex><span>  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
</span></span><span style=display:flex><span>  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
</span></span></code></pre></div><p>Pour résoudre ce problème, vous devez revenir à une version précédente de Deployment qui est stable.</p></li></ul><h3 id=vérification-de-l-historique-de-déploiement-d-un-déploiement>Vérification de l'historique de déploiement d'un déploiement</h3><p>Suivez les étapes ci-dessous pour vérifier l'historique de déploiement:</p><ol><li><p>Tout d'abord, vérifiez les révisions de ce déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployments &#34;nginx-deployment&#34;
</span></span><span style=display:flex><span>REVISION    CHANGE-CAUSE
</span></span><span style=display:flex><span>1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml --record=true
</span></span><span style=display:flex><span>2           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true
</span></span><span style=display:flex><span>3           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.91 --record=true
</span></span></code></pre></div><p><code>CHANGE-CAUSE</code> est copié de l'annotation de déploiement <code>kubernetes.io/change-cause</code> dans ses révisions lors de la création.
Vous pouvez spécifier le message<code>CHANGE-CAUSE</code> en:</p><ul><li>Annoter le déploiement avec <code>kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause="image mis à jour en 1.9.1"</code></li><li>Ajoutez le drapeau <code>--record</code> pour enregistrer la commande <code>kubectl</code> qui apporte des modifications à la ressource.</li><li>Modification manuelle du manifeste de la ressource.</li></ul></li><li><p>Pour voir les détails de chaque révision, exécutez:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment --revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployments &#34;nginx-deployment&#34; revision 2
</span></span><span style=display:flex><span>  Labels:       app=nginx
</span></span><span style=display:flex><span>          pod-template-hash=1159050644
</span></span><span style=display:flex><span>  Annotations:  kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   nginx:
</span></span><span style=display:flex><span>    Image:      nginx:1.9.1
</span></span><span style=display:flex><span>    Port:       80/TCP
</span></span><span style=display:flex><span>     QoS Tier:
</span></span><span style=display:flex><span>        cpu:      BestEffort
</span></span><span style=display:flex><span>        memory:   BestEffort
</span></span><span style=display:flex><span>    Environment Variables:      &lt;none&gt;
</span></span><span style=display:flex><span>  No volumes.
</span></span></code></pre></div></li></ol><h3 id=revenir-à-une-révision-précédente>Revenir à une révision précédente</h3><p>Suivez les étapes ci-dessous pour restaurer le déploiement de la version actuelle à la version précédente, qui est la version 2.</p><ol><li><p>Vous avez maintenant décidé d'annuler le déploiement actuel et le retour à la révision précédente:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment
</span></span></code></pre></div><p>Alternativement, vous pouvez revenir à une révision spécifique en la spécifiant avec <code>--to-revision</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment
</span></span></code></pre></div><p>Pour plus de détails sur les commandes liées au déploiement, lisez <a href=/docs/reference/generated/kubectl/kubectl-commands#rollout><code>kubectl rollout</code></a>.</p><p>Le déploiement est maintenant rétabli à une précédente révision stable.
Comme vous pouvez le voir, un événement <code>DeploymentRollback</code> pour revenir à la révision 2 est généré à partir du contrôleur de déploiement.</p></li><li><p>Vérifiez si la restauration a réussi et que le déploiement s'exécute comme prévu, exécutez:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   3/3     3            3           30m
</span></span></code></pre></div></li><li><p>Obtenez la description du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:                   nginx-deployment
</span></span><span style=display:flex><span>Namespace:              default
</span></span><span style=display:flex><span>CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
</span></span><span style=display:flex><span>Labels:                 app=nginx
</span></span><span style=display:flex><span>Annotations:            deployment.kubernetes.io/revision=4
</span></span><span style=display:flex><span>                        kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true
</span></span><span style=display:flex><span>Selector:               app=nginx
</span></span><span style=display:flex><span>Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
</span></span><span style=display:flex><span>StrategyType:           RollingUpdate
</span></span><span style=display:flex><span>MinReadySeconds:        0
</span></span><span style=display:flex><span>RollingUpdateStrategy:  25% max unavailable, 25% max surge
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:  app=nginx
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   nginx:
</span></span><span style=display:flex><span>    Image:        nginx:1.9.1
</span></span><span style=display:flex><span>    Port:         80/TCP
</span></span><span style=display:flex><span>    Host Port:    0/TCP
</span></span><span style=display:flex><span>    Environment:  &lt;none&gt;
</span></span><span style=display:flex><span>    Mounts:       &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:        &lt;none&gt;
</span></span><span style=display:flex><span>Conditions:
</span></span><span style=display:flex><span>  Type           Status  Reason
</span></span><span style=display:flex><span>  ----           ------  ------
</span></span><span style=display:flex><span>  Available      True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>  Progressing    True    NewReplicaSetAvailable
</span></span><span style=display:flex><span>OldReplicaSets:  &lt;none&gt;
</span></span><span style=display:flex><span>NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type    Reason              Age   From                   Message
</span></span><span style=display:flex><span>  ----    ------              ----  ----                   -------
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
</span></span><span style=display:flex><span>  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment &#34;nginx-deployment&#34; to revision 2
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
</span></span></code></pre></div></li></ol><h2 id=mise-à-l-échelle-d-un-déploiement>Mise à l'échelle d'un déploiement</h2><p>Vous pouvez mettre à l'échelle un déploiement à l'aide de la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment.v1.apps/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment scaled
</span></span></code></pre></div><p>En supposant que l'<a href=/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>horizontal Pod autoscaling</a> est activé dans votre cluster, vous pouvez configurer une mise à l'échelle automatique pour votre déploiement et choisir le nombre minimum et maximum de pods que vous souhaitez exécuter en fonction de l'utilisation du processeur de vos pods existants.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment.v1.apps/nginx-deployment --min<span style=color:#666>=</span><span style=color:#666>10</span> --max<span style=color:#666>=</span><span style=color:#666>15</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>80</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment scaled
</span></span></code></pre></div><h3 id=mise-à-l-échelle-proportionnelle>Mise à l'échelle proportionnelle</h3><p>Les déploiements RollingUpdate prennent en charge l'exécution simultanée de plusieurs versions d'une application.
Lorsque vous ou un autoscaler mettez à l'échelle un déploiement RollingUpdate qui se trouve au milieu d'un déploiement (en cours ou en pause), le contrôleur de déploiement équilibre les réplicas supplémentaires dans les ReplicaSets actifs existants (ReplicaSets avec pods) afin d'atténuer le risque.
Ceci est appelé <em>mise à l'échelle proportionnelle</em>.</p><p>Par exemple, vous exécutez un déploiement avec 10 réplicas, <a href=#max-surge>maxSurge</a>=3, et <a href=#max-unavailable>maxUnavailable</a>=2.</p><ul><li><p>Assurez-vous que les 10 réplicas de votre déploiement sont en cours d'exécution.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment     10        10        10           10          50s
</span></span></code></pre></div></li><li><p>Vous effectuez une mise à jour vers une nouvelle image qui s'avère impossible à résoudre depuis l'intérieur du cluster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:sometag
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment image updated
</span></span></code></pre></div></li><li><p>La mise à jour de l'image démarre un nouveau déploiement avec ReplicaSet <code>nginx-deployment-1989198191</code>, mais elle est bloquée en raison de l'exigence <code>maxUnavailable</code> que vous avez mentionnée ci-dessus.
Découvrez l'état du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-deployment-1989198191   5         5         0         9s
</span></span><span style=display:flex><span>nginx-deployment-618515232    8         8         8         1m
</span></span></code></pre></div></li><li><p>Ensuite, une nouvelle demande de mise à l'échelle pour le déploiement arrive.
La mise à l'échelle automatique incrémente les réplicas de déploiement à 15.
Le contrôleur de déploiement doit décider où ajouter ces 5 nouvelles répliques.
Si vous n'utilisiez pas la mise à l'échelle proportionnelle, les 5 seraient ajoutés dans le nouveau ReplicaSet.
Avec une mise à l'échelle proportionnelle, vous répartissez les répliques supplémentaires sur tous les ReplicaSets.
Des proportions plus importantes vont aux ReplicaSets avec le plus de répliques et des proportions plus faibles vont aux ReplicaSets avec moins de replicas.
Tous les restes sont ajoutés au ReplicaSet avec le plus de répliques.
Les ReplicaSets avec zéro réplicas ne sont pas mis à l'échelle.</p></li></ul><p>Dans notre exemple ci-dessus, 3 répliques sont ajoutées à l'ancien ReplicaSet et 2 répliques sont ajoutées au nouveau ReplicaSet.
Le processus de déploiement devrait éventuellement déplacer toutes les répliques vers le nouveau ReplicaSet, en supposant que les nouvelles répliques deviennent saines.
Pour confirmer cela, exécutez:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment     15        18        7            8           7m
</span></span></code></pre></div><p>Le statut de déploiement confirme la façon dont les réplicas ont été ajoutés à chaque ReplicaSet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-deployment-1989198191   7         7         0         7m
</span></span><span style=display:flex><span>nginx-deployment-618515232    11        11        11        7m
</span></span></code></pre></div><h2 id=pause-et-reprise-d-un-déploiement>Pause et reprise d'un déploiement</h2><p>Vous pouvez suspendre un déploiement avant de déclencher une ou plusieurs mises à jour, puis le reprendre.
Cela vous permet d'appliquer plusieurs correctifs entre la pause et la reprise sans déclencher de déploiements inutiles.</p><ul><li><p>Par exemple, avec un déploiement qui vient d'être créé:
Obtenez les détails du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx     3         3         3            3           1m
</span></span></code></pre></div><p>Obtenez le statut de déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-2142116321   3         3         3         1m
</span></span></code></pre></div></li><li><p>Mettez le déploiement en pause en exécutant la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout pause deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment paused
</span></span></code></pre></div></li><li><p>Mettez ensuite à jour l'image du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.9.1
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment image updated
</span></span></code></pre></div></li><li><p>Notez qu'aucun nouveau déploiement n'a commencé:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployments &#34;nginx&#34;
</span></span><span style=display:flex><span>REVISION  CHANGE-CAUSE
</span></span><span style=display:flex><span>1   &lt;none&gt;
</span></span></code></pre></div></li><li><p>Obtenez l'état de déploiement pour vous assurer que le déploiement est correctement mis à jour:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-2142116321   3         3         3         2m
</span></span></code></pre></div></li><li><p>Vous pouvez effectuer autant de mises à jour que vous le souhaitez, par exemple, mettre à jour les ressources qui seront utilisées:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> resources deployment.v1.apps/nginx-deployment -c<span style=color:#666>=</span>nginx --limits<span style=color:#666>=</span><span style=color:#b8860b>cpu</span><span style=color:#666>=</span>200m,memory<span style=color:#666>=</span>512Mi
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment resource requirements updated
</span></span></code></pre></div><p>L'état initial du déploiement avant de le suspendre continuera de fonctionner, mais les nouvelles mises à jour du déploiement n'auront aucun effet tant que le déploiement sera suspendu.</p></li><li><p>Finalement, reprenez le déploiement et observez un nouveau ReplicaSet à venir avec toutes les nouvelles mises à jour:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout resume deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment resumed
</span></span></code></pre></div></li><li><p>Regardez l'état du déploiement jusqu'à ce qu'il soit terminé.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs -w
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-2142116321   2         2         2         2m
</span></span><span style=display:flex><span>nginx-3926361531   2         2         0         6s
</span></span><span style=display:flex><span>nginx-3926361531   2         2         1         18s
</span></span><span style=display:flex><span>nginx-2142116321   1         2         2         2m
</span></span><span style=display:flex><span>nginx-2142116321   1         2         2         2m
</span></span><span style=display:flex><span>nginx-3926361531   3         2         1         18s
</span></span><span style=display:flex><span>nginx-3926361531   3         2         1         18s
</span></span><span style=display:flex><span>nginx-2142116321   1         1         1         2m
</span></span><span style=display:flex><span>nginx-3926361531   3         3         1         18s
</span></span><span style=display:flex><span>nginx-3926361531   3         3         2         19s
</span></span><span style=display:flex><span>nginx-2142116321   0         1         1         2m
</span></span><span style=display:flex><span>nginx-2142116321   0         1         1         2m
</span></span><span style=display:flex><span>nginx-2142116321   0         0         0         2m
</span></span><span style=display:flex><span>nginx-3926361531   3         3         3         20s
</span></span></code></pre></div></li><li><p>Obtenez le statut du dernier déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-2142116321   0         0         0         2m
</span></span><span style=display:flex><span>nginx-3926361531   3         3         3         28s
</span></span></code></pre></div></li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous ne pouvez pas annuler un déploiement suspendu avant de le reprendre.</div><h2 id=statut-de-déploiement>Statut de déploiement</h2><p>Un déploiement entre dans différents états au cours de son cycle de vie.
Il peut être <a href=#progressing-deployment>progressant</a> lors du déploiement d'un nouveau ReplicaSet, il peut être <a href=#complete-deployment>effectué</a>, ou il peut <a href=#failed-deployment>ne pas progresser</a>.</p><h3 id=progression-du-déploiement>Progression du déploiement</h3><p>Kubernetes marque un déploiement comme <em>progressing</em> lorsqu'une des tâches suivantes est effectuée:</p><ul><li>Le déploiement crée un nouveau ReplicaSet.</li><li>Le déploiement augmente son nouveau ReplicaSet.</li><li>Le déploiement réduit ses anciens ReplicaSet.</li><li>De nouveaux pods deviennent prêts ou disponibles (prêt pour au moins <a href=#min-ready-seconds>MinReadySeconds</a>).</li></ul><p>Vous pouvez surveiller la progression d'un déploiement à l'aide de <code>kubectl rollout status</code>.</p><h3 id=déploiement-effectué>Déploiement effectué</h3><p>Kubernetes marque un déploiement comme <em>effectué</em> lorsqu'il présente les caractéristiques suivantes:</p><ul><li>Toutes les répliques associées au déploiement ont été mises à jour vers la dernière version que vous avez spécifiée, ce qui signifie que toutes les mises à jour que vous avez demandées ont été effectuées.</li><li>Toutes les répliques associées au déploiement sont disponibles.</li><li>Aucune ancienne réplique pour le déploiement n'est en cours d'exécution.</li></ul><p>Vous pouvez vérifier si un déploiement est terminé en utilisant <code>kubectl rollout status</code>.
Si le déploiement s'est terminé avec succès, <code>kubectl rollout status</code> renvoie un code de sortie de 0.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Waiting for rollout to finish: 2 of 3 updated replicas are available...
</span></span><span style=display:flex><span>deployment &#34;nginx-deployment&#34; successfully rolled out
</span></span><span style=display:flex><span>$ echo $?
</span></span><span style=display:flex><span>0
</span></span></code></pre></div><h3 id=déploiement-échoué>Déploiement échoué</h3><p>Votre déploiement peut rester bloqué en essayant de déployer son nouveau ReplicaSet sans jamais terminer.
Cela peut se produire en raison de certains des facteurs suivants:</p><ul><li>Quota insuffisant</li><li>Échecs de la sonde de préparation</li><li>Erreurs d'extraction d'image</li><li>Permissions insuffisantes</li><li>Plages limites</li><li>Mauvaise configuration de l'exécution de l'application</li></ul><p>Vous pouvez détecter cette condition en spécifiant un paramètre d'échéance dans votre spécification de déploiement:
(<a href=#progress-deadline-seconds><code>.spec.progressDeadlineSeconds</code></a>).
<code>.spec.progressDeadlineSeconds</code> indique le nombre de secondes pendant lesquelles le contrôleur de déploiement attend avant d'indiquer (dans l'état de déploiement) que la progression du déploiement est au point mort.</p><p>La commande <code>kubectl</code> suivante définit la spécification avec <code>progressDeadlineSeconds</code> pour que le contrôleur signale l'absence de progression pour un déploiement après 10 minutes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch deployment.v1.apps/nginx-deployment -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;progressDeadlineSeconds&#34;:600}}&#39;</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment patched
</span></span></code></pre></div><p>Une fois le délai dépassé, le contrôleur de déploiement ajoute un <code>DeploymentCondition</code> avec les attributs suivants aux <code>.status.conditions</code> du déploiement:</p><ul><li>Type=Progressing</li><li>Status=False</li><li>Reason=ProgressDeadlineExceeded</li></ul><p>Voir les <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties>conventions Kubernetes API</a> pour plus d'informations sur les conditions d'état.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Kubernetes ne prend aucune mesure sur un déploiement bloqué, sauf pour signaler une condition d'état avec <code>Reason=ProgressDeadlineExceeded</code>.
Les orchestrateurs de niveau supérieur peuvent en tirer parti et agir en conséquence, par exemple, restaurer le déploiement vers sa version précédente.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si vous suspendez un déploiement, Kubernetes ne vérifie pas la progression par rapport à votre échéance spécifiée.
Vous pouvez suspendre un déploiement en toute sécurité au milieu d'un déploiement et reprendre sans déclencher la condition de dépassement du délai.</div><p>Vous pouvez rencontrer des erreurs transitoires avec vos déploiements, soit en raison d'un délai d'attente bas que vous avez défini, soit en raison de tout autre type d'erreur pouvant être traité comme transitoire.
Par exemple, supposons que votre quota soit insuffisant.
Si vous décrivez le déploiement, vous remarquerez la section suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&lt;...&gt;
</span></span><span style=display:flex><span>Conditions:
</span></span><span style=display:flex><span>  Type            Status  Reason
</span></span><span style=display:flex><span>  ----            ------  ------
</span></span><span style=display:flex><span>  Available       True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>  Progressing     True    ReplicaSetUpdated
</span></span><span style=display:flex><span>  ReplicaFailure  True    FailedCreate
</span></span><span style=display:flex><span>&lt;...&gt;
</span></span></code></pre></div><p>Si vous exécutez <code>kubectl get deployment nginx-deployment -o yaml</code>, l'état de déploiement est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>availableReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:39Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:39Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>Replica set &#34;nginx-deployment-4262182780&#34; is progressing.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>ReplicaSetUpdated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Progressing<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:42Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:42Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>Deployment has minimum availability.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>MinimumReplicasAvailable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Available<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:39Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:39Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message: &#39;Error creating</span>:<span style=color:#bbb> </span>pods &#34;nginx-deployment-4262182780-&#34; is forbidden: exceeded quota:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>object-counts, requested: pods=1, used: pods=3, limited</span>:<span style=color:#bbb> </span>pods=2&#39;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>FailedCreate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ReplicaFailure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>unavailableReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Finalement, une fois la date limite de progression du déploiement dépassée, Kubernetes met à jour le statut et la raison de la condition de progression:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Conditions:
</span></span><span style=display:flex><span>  Type            Status  Reason
</span></span><span style=display:flex><span>  ----            ------  ------
</span></span><span style=display:flex><span>  Available       True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>  Progressing     False   ProgressDeadlineExceeded
</span></span><span style=display:flex><span>  ReplicaFailure  True    FailedCreate
</span></span></code></pre></div><p>Vous pouvez résoudre un problème de quota insuffisant en réduisant votre déploiement, en réduisant d'autres contrôleurs que vous exécutez ou en augmentant le quota de votre namespace.
Si vous remplissez les conditions de quota et que le contrôleur de déploiement termine ensuite le déploiement de déploiement, vous verrez la mise à jour de l'état du déploiement avec une condition réussie (<code>Status=True</code> et <code>Reason=NewReplicaSetAvailable</code>).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Conditions:
</span></span><span style=display:flex><span>  Type          Status  Reason
</span></span><span style=display:flex><span>  ----          ------  ------
</span></span><span style=display:flex><span>  Available     True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>  Progressing   True    NewReplicaSetAvailable
</span></span></code></pre></div><p><code>Type=Available</code> avec <code>Status=True</code> signifie que votre déploiement a une disponibilité minimale.
La disponibilité minimale est dictée par les paramètres spécifiés dans la stratégie de déploiement.
<code>Type=Progressing</code> avec <code>Status=True</code> signifie que votre déploiement est soit au milieu d'un déploiement et qu'il progresse ou qu'il a terminé avec succès sa progression et que les nouvelles répliques minimales requises sont disponibles (voir la raison de la condition pour les détails - dans notre cas, <code>Reason=NewReplicaSetAvailable</code> signifie que le déploiement est terminé).</p><p>Vous pouvez vérifier si un déploiement n'a pas pu progresser en utilisant <code>kubectl rollout status</code>.
<code>kubectl rollout status</code> renvoie un code de sortie différent de zéro si le déploiement a dépassé le délai de progression.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
</span></span><span style=display:flex><span>error: deployment &#34;nginx&#34; exceeded its progress deadline
</span></span><span style=display:flex><span>$ echo $?
</span></span><span style=display:flex><span>1
</span></span></code></pre></div><h3 id=agir-sur-un-déploiement-échoué>Agir sur un déploiement échoué</h3><p>Toutes les actions qui s'appliquent à un déploiement complet s'appliquent également à un déploiement ayant échoué.
Vous pouvez le mettre à l'échelle à la hausse/baisse, revenir à une révision précédente ou même la suspendre si vous devez appliquer plusieurs réglages dans le modèle de pod de déploiement.</p><h2 id=politique-de-nettoyage>Politique de nettoyage</h2><p>Vous pouvez définir le champ <code>.spec.revisionHistoryLimit</code> dans un déploiement pour spécifier le nombre d'anciens ReplicaSets pour ce déploiement que vous souhaitez conserver.
Le reste sera effacé en arrière-plan.
Par défaut, c'est 10.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> La définition explicite de ce champ sur 0 entraînera le nettoyage de tout l'historique de votre déploiement, de sorte que le déploiement ne pourra pas revenir en arrière.</div><h2 id=déploiement-des-canaries>Déploiement des Canaries</h2><p>Si vous souhaitez déployer des versions sur un sous-ensemble d'utilisateurs ou de serveurs à l'aide du déploiement, vous pouvez créer plusieurs déploiements, un pour chaque version, en suivant le modèle canari décrit dans <a href=/docs/concepts/cluster-administration/manage-deployment/#canary-deployments>gestion des ressources</a>.</p><h2 id=écriture-d-une-spécification-de-déploiement>Écriture d'une spécification de déploiement</h2><p>Comme pour toutes les autres configurations Kubernetes, un déploiement a besoin des champs <code>apiVersion</code>, <code>kind</code> et <code>metadata</code>.
Pour des informations générales sur l'utilisation des fichiers de configuration, voir <a href=/docs/tutorials/stateless-application/run-stateless-application-deployment/>déploiement d'applications</a>, configuration des conteneurs, et <a href=/docs/concepts/overview/working-with-objects/object-management/>Utilisation de kubectl pour gérer les ressources</a>.</p><p>Un déploiement nécessite également un <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> section</a>.</p><h3 id=pod-template>Pod Template</h3><p>Les <code>.spec.template</code> et <code>.spec.selector</code> sont les seuls champs obligatoires du <code>.spec</code>.</p><p>Le <code>.spec.template</code> est un <a href=/fr/docs/concepts/workloads/pods/pod-overview/#pod-templates>Pod template</a>.
Il a exactement le même schéma qu'un <a href=/fr/docs/concepts/workloads/pods/pod/>Pod</a>, sauf qu'il est imbriqué et n'a pas de <code>apiVersion</code> ou de <code>kind</code>.</p><p>En plus des champs obligatoires pour un pod, un Pod Template dans un déploiement doit spécifier des labels appropriées et une stratégie de redémarrage appropriée.
Pour les labels, assurez-vous de ne pas chevaucher l'action d'autres contrôleurs.
Voir <a href=#selector>sélecteur</a>).</p><p>Seulement un <a href=/fr/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>.spec.template.spec.restartPolicy</code></a> égal à <code>Always</code> est autorisé, ce qui est la valeur par défaut s'il n'est pas spécifié.</p><h3 id=répliques>Répliques</h3><p><code>.spec.replicas</code> est un champ facultatif qui spécifie le nombre de pods souhaités.
Il vaut par défaut 1.</p><h3 id=sélecteur>Sélecteur</h3><p><code>.spec.selector</code> est un champ obligatoire qui spécifie un <a href=/docs/concepts/overview/working-with-objects/labels/>sélecteur de labels</a> pour les pods ciblés par ce déploiement.</p><p><code>.spec.selector</code> doit correspondre <code>.spec.template.metadata.labels</code>, ou il sera rejeté par l'API.</p><p>Dans la version d'API <code>apps/v1</code>, <code>.spec.selector</code> et <code>.metadata.labels</code> ne sont pas définis par défaut sur <code>.spec.template.metadata.labels</code> s'ils ne sont pas définis.
Ils doivent donc être définis explicitement.
Notez également que <code>.spec.selector</code> est immuable après la création du déploiement dans <code>apps/v1</code>.</p><p>Un déploiement peut mettre fin aux pods dont les étiquettes correspondent au sélecteur si leur modèle est différent de <code>.spec.template</code> ou si le nombre total de ces pods dépasse <code>.spec.replicas</code>.
Il fait apparaître de nouveaux pods avec <code>.spec.template</code> si le nombre de pods est inférieur au nombre souhaité.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous ne devez pas créer d'autres pods dont les labels correspondent à ce sélecteur, soit directement, en créant un autre déploiement, soit en créant un autre contrôleur tel qu'un ReplicaSet ou un ReplicationController.
Si vous le faites, le premier déploiement pense qu'il a créé ces autres pods.
Kubernetes ne vous empêche pas de le faire.</div><p>Si vous avez plusieurs contrôleurs qui ont des sélecteurs qui se chevauchent, les contrôleurs se battront entre eux et ne se comporteront pas correctement.</p><h3 id=stratégie>Stratégie</h3><p><code>.spec.strategy</code> spécifie la stratégie utilisée pour remplacer les anciens pods par de nouveaux.
<code>.spec.strategy.type</code> peut être "Recreate" ou "RollingUpdate".
"RollingUpdate" est la valeur par défaut.</p><h4 id=déploiment-recreate>Déploiment Recreate</h4><p>Tous les pods existants sont tués avant que de nouveaux ne soient créés lorsque <code>.spec.strategy.type==Recreate</code>.</p><h4 id=déploiement-de-mise-à-jour-continue>Déploiement de mise à jour continue</h4><p>Le déploiement met à jour les pods dans une <a href=/docs/tasks/run-application/rolling-update-replication-controller/>mise à jour continue</a> quand <code>.spec.strategy.type==RollingUpdate</code>.
Vous pouvez spécifier <code>maxUnavailable</code> et <code>maxSurge</code> pour contrôler le processus de mise à jour continue.</p><h5 id=max-non-disponible>Max non disponible</h5><p><code>.spec.strategy.rollingUpdate.maxUnavailable</code> est un champ facultatif qui spécifie le nombre maximal de pods qui peuvent être indisponibles pendant le processus de mise à jour.
La valeur peut être un nombre absolu (par exemple, 5) ou un pourcentage des pods souhaités (par exemple, 10%).
Le nombre absolu est calculé à partir du pourcentage en arrondissant vers le bas.
La valeur ne peut pas être 0 si <code>.spec.strategy.rollingUpdate.maxSurge</code> est 0.
La valeur par défaut est 25%.</p><p>Par exemple, lorsque cette valeur est définie sur 30%, l'ancien ReplicaSet peut être réduit à 70% des pods souhaités immédiatement au démarrage de la mise à jour continue.
Une fois que les nouveaux pods sont prêts, l'ancien ReplicaSet peut être réduit davantage, suivi d'une augmentation du nouveau ReplicaSet, garantissant que le nombre total de pods disponibles à tout moment pendant la mise à jour est d'au moins 70% des pods souhaités.</p><h5 id=max-surge>Max Surge</h5><p><code>.spec.strategy.rollingUpdate.maxSurge</code> est un champ facultatif qui spécifie le nombre maximal de pods pouvant être créés sur le nombre de pods souhaité.
La valeur peut être un nombre absolu (par exemple, 5) ou un pourcentage des pods souhaités (par exemple, 10%).
La valeur ne peut pas être 0 si <code>MaxUnavailable</code> est 0.
Le nombre absolu est calculé à partir du pourcentage en arrondissant.
La valeur par défaut est 25%.</p><p>Par exemple, lorsque cette valeur est définie sur 30%, le nouveau ReplicaSet peut être mis à l'échelle immédiatement au démarrage de la mise à jour continue, de sorte que le nombre total d'anciens et de nouveaux pods ne dépasse pas 130% des pods souhaités.
Une fois que les anciens pods ont été détruits, le nouveau ReplicaSet peut être augmenté davantage, garantissant que le nombre total de pods en cours d'exécution à tout moment pendant la mise à jour est au maximum de 130% des pods souhaités.</p><h3 id=progress-deadline-seconds>Progress Deadline Seconds</h3><p><code>.spec.progressDeadlineSeconds</code> est un champ facultatif qui spécifie le nombre de secondes pendant lesquelles vous souhaitez attendre que votre déploiement progresse avant que le système ne signale que le déploiement a <a href=#failed-deployment>échoué</a> - refait surface comme une condition avec <code>Type=Progressing</code>, <code>Status=False</code> et <code>Reason=ProgressDeadlineExceeded</code> dans l'état de la ressource.
Le contrôleur de déploiement continuera de réessayer le déploiement.
À l'avenir, une fois la restauration automatique implémentée, le contrôleur de déploiement annulera un déploiement dès qu'il observera une telle condition.</p><p>S'il est spécifié, ce champ doit être supérieur à <code>.spec.minReadySeconds</code>.</p><h3 id=min-ready-seconds>Min Ready Seconds</h3><p><code>.spec.minReadySeconds</code> est un champ facultatif qui spécifie le nombre minimum de secondes pendant lequel un pod nouvellement créé doit être prêt sans qu'aucun de ses conteneurs ne plante, pour qu'il soit considéré comme disponible.
Cette valeur par défaut est 0 (le pod sera considéré comme disponible dès qu'il sera prêt).
Pour en savoir plus sur le moment où un pod est considéré comme prêt, consultez <a href=/fr/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Sondes de conteneur</a>.</p><h3 id=rollback-to>Rollback To</h3><p>Le champ <code>.spec.rollbackTo</code> est obsolète dans les versions d'API <code>extensions/v1beta1</code> et <code>apps/v1beta1</code> et n'est plus pris en charge dans les versions d'API commençant par <code>apps/v1beta2</code>.
Utilisez, <code>kubectl rollout undo</code> pour <a href=#revenir-%C3%A0-une-r%C3%A9vision-pr%C3%A9c%C3%A9dente>Revenir à une révision précédente</a>.</p><h3 id=limite-de-l-historique-des-révisions>Limite de l'historique des révisions</h3><p>L'historique de révision d'un déploiement est stocké dans les ReplicaSets qu'il contrôle.</p><p><code>.spec.revisionHistoryLimit</code> est un champ facultatif qui spécifie le nombre d'anciens ReplicaSets à conserver pour permettre la restauration.
Ces anciens ReplicaSets consomment des ressources dans <code>etcd</code> et encombrent la sortie de <code>kubectl get rs</code>.
La configuration de chaque révision de déploiement est stockée dans ses ReplicaSets; par conséquent, une fois un ancien ReplicaSet supprimé, vous perdez la possibilité de revenir à cette révision du déploiement.
Par défaut, 10 anciens ReplicaSets seront conservés, mais sa valeur idéale dépend de la fréquence et de la stabilité des nouveaux déploiements.</p><p>Plus précisément, la définition de ce champ à zéro signifie que tous les anciens ReplicaSets avec 0 réplicas seront nettoyés.
Dans ce cas, un nouveau panneau déroulant Déploiement ne peut pas être annulé, car son historique de révision est nettoyé.</p><h3 id=paused>Paused</h3><p><code>.spec.paused</code> est un champ booléen facultatif pour suspendre et reprendre un déploiement.
La seule différence entre un déploiement suspendu et un autre qui n'est pas suspendu, c'est que toute modification apportée au <code>PodTemplateSpec</code> du déploiement suspendu ne déclenchera pas de nouveaux déploiements tant qu'il sera suspendu.
Un déploiement n'est pas suspendu par défaut lors de sa création.</p><h2 id=alternative-aux-déploiements>Alternative aux déploiements</h2><h3 id=kubectl-rolling-update>kubectl rolling-update</h3><p><a href=/docs/reference/generated/kubectl/kubectl-commands#rolling-update><code>kubectl rolling-update</code></a> met à jour les pods et les ReplicationControllers de la même manière.
Mais les déploiements sont recommandés, car ils sont déclaratifs, côté serveur et ont des fonctionnalités supplémentaires, telles que la restauration de toute révision précédente même après la mise à jour progressive..</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6d72299952c37ca8cc61b416e5bdbcd4>3 - StatefulSets</h1><p>StatefulSet est l'objet de l'API de charge de travail utilisé pour gérer des applications avec état (<em>stateful</em>).</p><p>Gère le déploiement et la mise à l'échelle d'un ensemble de <a class=glossary-tooltip title='Le plus petit et le plus simple des objets Kubernetes. Un Pod est un ensemble de conteneurs fonctionnant sur votre cluster.' data-toggle=tooltip data-placement=top href=/fr/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a>, <em>et fournit des garanties sur l'ordre et l'unicité</em> de ces Pods.</p><p>Comme un <a class=glossary-tooltip title='Objet API gérant une application répliquée.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Déploiement>Déploiement</a>, un StatefulSet gère des Pods qui sont basés sur une même spécification de conteneur. Contrairement à un Deployment, un StatefulSet maintient une identité pour chacun de ces Pods. Ces Pods sont créés à partir de la même spec, mais ne sont pas interchangeables : chacun a un identifiant persistant qu'il garde à travers tous ses re-scheduling.</p><p>Si vous voulez utiliser des volumes de stockage pour fournir de la persistance à votre charge de travail, vous pouvez utiliser un StatefulSet comme partie de la solution. Même si des Pods individuels d'un StatefulSet sont susceptibles d'échouer, les identifiants persistants des Pods rendent plus facile de faire correspondre les volumes existants aux nouveaux Pods remplaçant ceux ayant échoué.</p><h2 id=utiliser-des-statefulsets>Utiliser des StatefulSets</h2><p>Les StatefulSets sont utiles pour des applications qui nécessitent une ou plusieurs des choses suivantes :</p><ul><li>Des identifiants réseau stables et uniques.</li><li>Un stockage persistant stable.</li><li>Un déploiement et une mise à l'échelle ordonnés et contrôlés.</li><li>Des mises à jour continues (<em>rolling update</em>) ordonnées et automatisées.</li></ul><p>Ci-dessus, stable est synonyme de persistance suite au (re)scheduling de Pods.
Si une application ne nécessite aucun identifiant stable ou de déploiement, suppression ou
mise à l'échelle stables, vous devriez déployer votre application en utilisant un objet de charge de travail
fournissant un ensemble de réplicas sans état (<em>stateless</em>).</p><p>Un <a href=/fr/docs/concepts/workloads/controllers/deployment/>Deployment</a> ou
<a href=/fr/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> peut être mieux adapté pour vos applications sans état.</p><h2 id=limitations>Limitations</h2><ul><li>Le stockage pour un Pod donné doit être provisionné soit par un <a href=https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/README.md>approvisionneur de PersistentVolume</a> basé sur un <code>storage class</code> donné, soit pré-provisionné par un admin.</li><li>Supprimer et/ou réduire l'échelle d'un StatefulSet à zéro ne supprimera <em>pas</em> les volumes associés avec le StatefulSet. Ceci est fait pour garantir la sécurité des données, ce qui a généralement plus de valeur qu'une purge automatique de toutes les ressources relatives à un StatefulSet.</li><li>Les StatefulSets nécessitent actuellement un <a href=/fr/docs/concepts/services-networking/service/#headless-services>Service Headless</a> qui est responsable de l'identité réseau des Pods. Vous êtes responsable de la création de ce Service.</li><li>Les StatefulSets ne fournissent aucune garantie de la terminaison des pods lorsqu'un StatefulSet est supprimé. Pour avoir une terminaison ordonnée et maîtrisée des pods du StatefulSet, il est possible de réduire l'échelle du StatefulSet à 0 avant de le supprimer.</li><li>Lors de l'utilisation de <a href=#rolling-updates>Rolling Updates</a> avec la
<a href=#politiques-de-gestion-dun-pod>Politique de gestion des Pods</a> par défaut (<code>OrderedReady</code>),
il est possible de tomber dans un état indéfini nécessitant une
<a href=#rollback-forc%C3%A9>intervention manuelle pour réparer</a>.</li></ul><h2 id=composants>Composants</h2><p>L'exemple ci-dessous décrit les composants d'un StatefulSet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># doit correspondre à .spec.template.metadata.labels</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># est 1 par défaut</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># doit correspondre à .spec.selector.matchLabels</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-storage-class&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>Dans l'exemple ci-dessus :</p><ul><li>Un Service Headless, appelé <code>nginx</code>, est utilisé pour contrôler le domaine réseau.</li><li>Le StatefulSet, appelé <code>web</code>, a une Spec indiquant que 3 réplicas du container nginx seront démarrés dans des Pods.</li><li>Le <code>volumeClaimTemplates</code> fournira un stockage stable utilisant des <a href=/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a> provisionnés par un approvisionneur de PersistentVolume.</li></ul><p>Le nom d'un objet StatefulSet doit être un
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nom de sous-domaine DNS</a> valide.</p><h2 id=sélecteur-de-pod>Sélecteur de Pod</h2><p>Vous devez renseigner le champ <code>.spec.selector</code> d'un StatefulSet pour qu'il corresponde aux labels de son <code>.spec.template.metadata.labels</code>. Avant Kubernetes 1.8, le champ <code>.spec.selector</code> était mis par défaut s'il était omis. Pour les versions 1.8 et ultérieures, ne pas spécifier de sélecteur de Pod résulte en une erreur de validation lors de la création du StatefulSet.</p><h2 id=identité-du-pod>Identité du Pod</h2><p>Les Pods d'un StatefulSet ont une identité unique comprenant un ordinal, une identité réseau stable et un stockage stable.
L'identité est accrochée au Pod, indépendamment du noeud sur lequel il est (re)programmé.</p><h3 id=index-ordinal>Index Ordinal</h3><p>Pour un StatefulSet avec N réplicas, chaque Pod du StatefulSet se verra assigné un ordinal entier, de 0 à N-1,
unique sur l'ensemble des pods.</p><h3 id=id-réseau-stable>ID réseau stable</h3><p>Chaque Pod dans un StatefulSet dérive son nom d'hôte du nom du StatefulSet
et de l'ordinal du Pod. Le modèle pour le nom d'hôte généré est
<code>$(nom statefulset)-$(ordinal)</code>. L'exemple ci-dessus créera trois Pods
nommés <code>web-0,web-1,web-2</code>.
Un StatefulSet peut utiliser un <a href=/docs/concepts/services-networking/service/#headless-services>Service Headless</a>
pour contrôler le domaine de ses Pods. Le domaine pris en charge par ce Service prend la forme :
<code>$(nom service).$(namespace).svc.cluster.local</code>, où "cluster.local" est le domaine du cluster.
Chaque fois qu'un Pod est créé, il obtient un sous-domaine DNS correspondant, prenant la forme :
<code>$(nom pod).$(domaine du service gouvernant)</code>, où le service gouvernant est défini par le
champ <code>serviceName</code> du StatefulSet.</p><p>En fonction de la façon dont est configuré le DNS dans votre cluster, vous ne pourrez peut-être pas rechercher immédiatement
le nom DNS d'un pod nouvellement exécuté. Ce problème peut se produire lorsque d'autres clients dans le
cluster ont déjà envoyé des requêtes pour le nom d'hôte du Pod avant sa création.
La mise en cache négative (normale pour le DNS) signifie que les résultats des recherches précédentes ayant échoué sont
mémorisés et réutilisés, même après que le Pod ait démarré, pendant au moins quelques secondes.</p><p>Si vous avez besoin de découvrir les Pods rapidement après leur création, vous avez plusieurs options :</p><ul><li>Interrogez directement l'API Kubernetes (par exemple, à l'aide d'un watch) plutôt que de vous fier aux recherches DNS.</li><li>Réduisez le temps de mise en cache dans votre fournisseur de DNS Kubernetes (cela signifie généralement modifier le ConfigMap de CoreDNS, qui met actuellement en cache pendant 30 secondes).</li></ul><p>Comme mentionné dans la section <a href=#limitations>limitations</a>, vous êtes responsable de
créer le <a href=/docs/concepts/services-networking/service/#headless-services>Service Headless</a>
responsable de l'identité réseau des Pods.</p><p>Voici quelques exemples de choix pour le domaine du cluster, le nom du service,
le nom du StatefulSet et comment cela affecte les noms DNS des pods du StatefulSet.</p><table><thead><tr><th>Domaine Cluster</th><th>Service (ns/nom)</th><th>StatefulSet (ns/nom)</th><th>Domaine StatefulSet</th><th>DNS Pod</th><th>Nom d'hôte</th></tr></thead><tbody><tr><td>cluster.local</td><td>default/nginx</td><td>default/web</td><td>nginx.default.svc.cluster.local</td><td>web-{0..N-1}.nginx.default.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>cluster.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.cluster.local</td><td>web-{0..N-1}.nginx.foo.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>kube.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.kube.local</td><td>web-{0..N-1}.nginx.foo.svc.kube.local</td><td>web-{0..N-1}</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le domaine cluster sera <code>cluster.local</code> à moins qu'il soit
<a href=/docs/concepts/services-networking/dns-pod-service/>configuré autrement</a>.</div><h3 id=stockage-stable>Stockage stable</h3><p>Kubernetes crée un <a href=/docs/concepts/storage/persistent-volumes/>PersistentVolume</a> pour chaque
VolumeClaimTemplate. Dans l'exemple nginx ci-dessus, chaque Pod se verra affecter un unique PersistentVolume
avec un StorageClass de <code>my-storage-class</code> et 1 Gib de stockage provisionné. Si aucun StorageClass
n'est spécifié, alors le StorageClass par défaut sera utilisé. Lorsqu'un Pod est (re)schedulé
sur un noeud, ses <code>volumeMounts</code> montent les PersistentVolumes associés aux<br>PersistentVolumeClaims. Notez que les PersistentVolumes associés avec les PersistentVolumeClaims des Pods
ne sont pas supprimés lorsque les Pods, ou le StatefulSet, sont supprimés.
Ceci doit être fait manuellement.</p><h3 id=étiquette-du-nom-de-pod>Étiquette du nom de Pod</h3><p>Lorsque le StatefulSet <a class=glossary-tooltip title="Boucle de contrôle surveillant l'état partagé du cluster à travers l'apiserver et effectuant des changements en essayant de déplacer l'état actuel vers l'état désiré." data-toggle=tooltip data-placement=top href=/docs/admin/kube-controller-manager/ target=_blank aria-label=Contrôleur>Contrôleur</a> crée un Pod,
il ajoute une étiquette, <code>statefulset.kubernetes.io/pod-name</code>, renseignée avec le nom du Pod.
Cette étiquette vous permet d'attacher un Service à un Pod spécifique du StatefulSet.</p><h2 id=garanties-de-déploiement-et-de-mise-à-l-échelle>Garanties de déploiement et de mise à l'échelle</h2><ul><li>Pour un StatefulSet avec N réplicas, lorsque les Pods sont déployés, ils sont créés de manière séquentielle, dans l'ordre {0..N-1}.</li><li>Lorsque les Pods sont supprimés, ils sont terminés dans l'ordre inverse, {N-1..0}.</li><li>Avant qu'une opération de mise à l'échelle soit appliquée à un Pod, tous ses prédécesseurs doivent être Running et Ready.</li><li>Avant qu'un Pod soit terminé, tous ses successeurs doivent être complètement arrêtés.</li></ul><p>Le StatefulSet ne devrait pas spécifier un <code>pod.Spec.TerminationGracePeriodSeconds</code> à 0. Cette pratique
est dangereuse et fortement déconseillée. Pour plus d'explications, veuillez vous référer à <a href=/docs/tasks/run-application/force-delete-stateful-set-pod/>forcer la suppression de Pods de StatefulSet</a>.</p><p>Lorsque l'exemple nginx ci-dessus est créé, trois Pods seront déployés dans l'ordre
web-0, web-1, web-2. web-1 ne sera pas déployé avant que web-0 soit
<a href=/fr/docs/concepts/workloads/pods/pod-lifecycle/>Running et Ready</a>, et web-2 ne sera pas déployé avant que
web-1 soit Running et Ready. Si web-0 venait à échouer, après que web-1 soit Running et Ready, mais avant que
web-2 soit lancé, web-2 ne serait pas lancé avant que web-0 soit correctement relancé et redevienne Running et Ready.</p><p>Si un utilisateur venait à mettre à l'échelle l'exemple déployé en patchant le StatefulSet pour que
<code>replicas=1</code>, web-2 serait terminé en premier. web-1 ne serait pas terminé avant que web-2
ne soit complètement arrêté et supprimé. Si web-0 venait à échouer après que web-2 soit terminé et complètement arrêté,
mais avant que web-1 soit terminé, web-1 ne serait pas terminé avant que web-0 soit Running et Ready.</p><h3 id=politiques-de-gestion-d-un-pod>Politiques de gestion d'un Pod</h3><p>Dans Kubernetes 1.7 et ultérieurs, le StatefulSet vous permet d'assouplir ses garanties d'ordre,
tout en préservant ses garanties d'unicité et d'identité via son champ <code>.spec.podManagementPolicy</code>.</p><h4 id=gestion-de-pod-orderedready>Gestion de Pod OrderedReady</h4><p>La gestion de Pod <code>OrderedReady</code> est la valeur par défaut pour les StatefulSets. Il implémente le comportement décrit <a href=#garanties-de-d%C3%A9ploiment-et-de-mise-%C3%A0-l-%C3%A9chelle>ci-dessus</a>.</p><h4 id=gestion-de-pod-parallel>Gestion de Pod Parallel</h4><p>La gestion de Pod <code>Parallel</code> indique au contrôleur de StatefulSet de lancer ou
terminer tous les Pods en parallèle, et de ne pas attendre que les Pods deviennent Running
et Ready ou complètement terminés avant de lancer ou terminer un autre
Pod. Cette option affecte seulement le comportement pour les opérations de mise à l'échelle.
Les mises à jour ne sont pas affectées.</p><h2 id=stratégies-de-mise-à-jour>Stratégies de mise à jour</h2><p>Dans Kubernetes 1.7 et ultérieurs, le champ <code>.spec.updateStrategy</code> d'un StatefulSet vous permet
de configurer et désactiver les rolling updates automatisés pour les conteneurs, étiquettes,
requête/limites de ressources, et annotations pour les Pods d'un StatefulSet.</p><h3 id=on-delete>On Delete</h3><p>La stratégie de mise à jour <code>OnDelete</code> implémente l'ancien comportement (1.6 et précédents). Lorsque
<code>.spec.updateStrategy.type</code> d'un StatefulSet est mis à <code>OnDelete</code>, le contrôleur de StatefulSet
ne mettra pas à jour automatiquement les Pods dans un StatefulSet.
Les utilisateurs doivent supprimer manuellement les Pods pour forcer le contrôleur à créer de nouveaux
Pods qui réflètent les modifications faites à un <code>.spec.template</code> d'un StatefulSet.</p><h3 id=rolling-updates>Rolling Updates</h3><p>La stratégie de mise à jour <code>RollingUpdate</code> implémente le rolling update automatisé pour les Pods d'un
StatefulSet. C'est la stratégie par défaut lorsque <code>.spec.updateStrategy</code> n'est pas spécifié.
Lorsqu'un <code>.spec.updateStrategy.type</code> d'un StatefulSet est mis à <code>RollingUpdate</code>, le contrôleur de
StatefulSet va supprimer et recréer chaque Pod d'un StatefulSet. Il va procéder dans le même ordre
que pour la terminaison d'un Pod (de l'ordinal le plus grand au plus petit), mettant à jour chaque Pod,
un seul à la fois. Il va attendre qu'un Pod mis à jour soit Running et Ready avant de mettre à jour
son prédécesseur.</p><h4 id=partitions>Partitions</h4><p>La stratégie de mise à jour <code>RollingUpdate</code> peut être partitionnée, en spécifiant une
<code>.spec.updateStrategy.rollingUpdate.partition</code>. Si une partition est spécifiée, tous les Pods ayant un
ordinal plus grand ou égal à la partition seront mis à jour lorsque le
<code>.spec.template</code> du StatefulSet sera mis à jour. Tous les Pods ayant un ordinal inférieur à la partition
ne sera pas mis à jour, et, même s'ils sont supprimés, ils seront recréés avec l'ancienne version. Si une
<code>.spec.updateStrategy.rollingUpdate.partition</code> d'un StatefulSet est plus grand que son <code>.spec.replicas</code>,
les mises à jour de son <code>.spec.template</code> ne seront pas propagés à ses Pods.
Dans la plupart des cas vous n'aurez pas à utiliser de partition, mais elles sont utiles si vous désirez
organiser une mise à jour, déployer une version canari, ou effectuer un déploiement par étapes.</p><h4 id=rollback-forcé>Rollback forcé</h4><p>En utilisant des <a href=#rolling-updates>Rolling Updates</a> avec la
<a href=#politiques-de-gestion-dun-pod>politique de gestion d'un Pod</a> par défaut (<code>OrderedReady</code>),
il est possible de se retrouver dans un état inconsistant nécessitant une intervention manuelle pour réparation.</p><p>Si vous mettez à jour le template de Pod dans une configuration qui ne devient jamais Running et
Ready (par exemple, du fait d'un mauvais binaire ou d'une erreur de configuration au niveau de l'application),
le StatefulSet va arrêter le rollout et attendre.</p><p>Dans cet état, il n'est pas suffisant de revenir à une bonne configuration du template de Pod.
En raison d'une <a href=https://github.com/kubernetes/kubernetes/issues/67250>erreur connue</a>,
le StatefulSet va continuer à attendre que le Pod en échec Pod devienne Ready
(ce qui n'arrive jamais) avant qu'il tente de revenir à la bonne configuration.</p><p>Après être revenu au bon template, vous devez aussi supprimer tous les Pods que le StatefulSet
avait déjà essayé de démarrer avec la mauvaise configuration.
Le StatefulSet va alors commencer à recréer les Pods en utilisant le bon template.</p><h2 id=a-suivre>A suivre</h2><ul><li>Suivre un exemple de <a href=/docs/tutorials/stateful-application/basic-stateful-set/>déploiement d'une application stateful</a>.</li><li>Suivre un exemple de <a href=/docs/tutorials/stateful-application/cassandra/>déploiement de Cassandra avec des Stateful Sets</a>.</li><li>Suivre un exemple d'<a href=/docs/tasks/run-application/run-replicated-stateful-application/>exécution d'une application stateful redondante</a>.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/fr/docs/home/>Accueil</a>
<a class=text-white href=/fr/blog/>Blog</a>
<a class=text-white href=/fr/partners/>Partenaires</a>
<a class=text-white href=/fr/community/>Communauté</a>
<a class=text-white href=/fr/case-studies/>Études de cas</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>