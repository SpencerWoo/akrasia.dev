<!doctype html><html lang=fr class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/fr/docs/concepts/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Concepts | Kubernetes</title><meta property="og:title" content="Concepts"><meta property="og:description" content="Concepts Kubernetes"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/fr/docs/concepts/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Concepts"><meta itemprop=description content="Concepts Kubernetes"><meta name=twitter:card content="summary"><meta name=twitter:title content="Concepts"><meta name=twitter:description content="Concepts Kubernetes"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Concepts Kubernetes"><meta property="og:description" content="Concepts Kubernetes"><meta name=twitter:description content="Concepts Kubernetes"><meta property="og:url" content="https://kubernetes.io/fr/docs/concepts/"><meta property="og:title" content="Concepts"><meta name=twitter:title content="Concepts"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/fr/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/fr/docs/>Documentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/blog/>Blog de Kubernetes</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/partners/>Partenaires</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/community/>Communauté</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/case-studies/>Études de cas</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/fr/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/fr/docs/concepts/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/fr/docs/concepts/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/fr/docs/concepts/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/fr/docs/concepts/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/fr/docs/concepts/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Français (French)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/>日本語 (Japanese)</a>
<a class=dropdown-item href=/it/docs/concepts/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/concepts/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/concepts/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/concepts/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Version imprimable multipages.
<a href=# onclick="return print(),!1">Cliquer ici pour imprimer</a>.</p><p><a href=/fr/docs/concepts/>Retour à la version par défaut</a>.</p></div><h1 class=title>Concepts</h1><div class=lead>Concepts Kubernetes</div><ul><li>1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>Vue d'ensemble</a></li><ul><li>1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Qu'est-ce-que Kubernetes ?</a></li><li>1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Composants de Kubernetes</a></li><li>1.3: <a href=#pg-110f33530cf761140cb1dab536baef04>Utilisation des objets Kubernetes</a></li><ul><li>1.3.1: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Namespaces</a></li></ul></ul><li>2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>Architecture de Kubernetes</a></li><ul><li>2.1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Noeuds</a></li><li>2.2: <a href=#pg-63e7fdf87ba61eb2586bb8c625c23506>Communication Master-Node</a></li><li>2.3: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Concepts sous-jacents au Cloud Controller Manager</a></li></ul><li>3: <a href=#pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>Les conteneurs</a></li><ul><li>3.1: <a href=#pg-16042b4652ad19e565c7263824029a43>Images</a></li><li>3.2: <a href=#pg-a858027489648786a3b16264e451272b>Classe d'exécution (Runtime Class)</a></li><li>3.3: <a href=#pg-643212488f778acf04bebed65ba34441>L'environnement du conteneur</a></li><li>3.4: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>Hooks de cycle de vie de conteneurs</a></li></ul><li>4: <a href=#pg-d52aadda80edd9f8c514cfe2321363c2>Workloads</a></li><ul><li>4.1: <a href=#pg-4d68b0ccf9c683e6368ffdcc40c838d4>Pods</a></li><ul><li>4.1.1: <a href=#pg-37afa6c66c74400d1579f10faf55e5b6>Aperçu du Pod</a></li><li>4.1.2: <a href=#pg-99cce294fe789317ee684a6e1f07f20f>Pods</a></li><li>4.1.3: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>Cycle de vie d'un Pod</a></li><li>4.1.4: <a href=#pg-c8d62295ca703fdcef1aaf89fb4c916a>Contraintes de propagation de topologie pour les Pods</a></li><li>4.1.5: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>Init Containers</a></li></ul><li>4.2: <a href=#pg-89637410cacae45a36ab1cc278c482eb>Contrôleurs</a></li><ul><li>4.2.1: <a href=#pg-d459b930218774655fa7fd1620625539>ReplicaSet</a></li><li>4.2.2: <a href=#pg-a2dc0393e0c4079e1c504b6429844e86>Déploiements</a></li><li>4.2.3: <a href=#pg-6d72299952c37ca8cc61b416e5bdbcd4>StatefulSets</a></li></ul></ul><li>5: <a href=#pg-0a0a7eca3e302a3c08f8c85e15d337fd>Services, Equilibreur de charge, et Réseau</a></li><ul><li>5.1: <a href=#pg-f51db1097575de8072afe1f5b156a70c>EndpointSlices</a></li><li>5.2: <a href=#pg-5701136fd2ce258047b6ddc389112352>Service</a></li><li>5.3: <a href=#pg-91cb8a4438b003df11bc1c426a81b756>DNS pour les services et les pods</a></li><li>5.4: <a href=#pg-199bcc92443dbc9bed44819467d7eb75>Ingress</a></li></ul><li>6: <a href=#pg-f018f568c6723865753f150c3c59bdda>Stockage</a></li><ul><li>6.1: <a href=#pg-27795584640a03bd2024f1fe3b3ab754>Volumes</a></li><li>6.2: <a href=#pg-ffd12528a12882b282e1bd19e29f9e75>Volumes persistants</a></li></ul><li>7: <a href=#pg-275bea454e1cf4c5adeca4058b5af988>Configuration</a></li><ul><li>7.1: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secrets</a></li></ul><li>8: <a href=#pg-712cb3c03ff14a39e5a83a6d9b71d203>Sécurité</a></li><ul></ul><li>9: <a href=#pg-ac9161c6d952925b083ad9602b4e8e7f>Politiques</a></li><ul></ul><li>10: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>Administration d'un cluster</a></li><ul><li>10.1: <a href=#pg-fb494ea3b1874bd753dcd11c3f35c2dc>Vue d'ensemble de l'administration d'un cluster</a></li><li>10.2: <a href=#pg-2bf9a93ab5ba014fb6ff70b22c29d432>Certificats</a></li><li>10.3: <a href=#pg-c4b1e87a84441f8a90699a345ce48d68>Architecture de Journalisation d'évènements (logging)</a></li></ul><li>11: <a href=#pg-7e0d97616b15e2c383c6a0a96ec442cb>Extensions Kubernetes</a></li><ul><li>11.1: <a href=#pg-0af41d3bd7c785621b58b7564793396a>Extensions de l'API Kubernetes</a></li><ul></ul><li>11.2: <a href=#pg-c8937cdc9df96f3328becf04f8211292>Extensions compute, stockage et réseau</a></li><ul></ul></ul></ul><div class=content><p>La section Concepts vous aide à mieux comprendre les composants du système Kubernetes et les abstractions que Kubernetes utilise pour représenter votre cluster.
Elle vous aide également à mieux comprendre le fonctionnement de Kubernetes en général.</p><h2 id=vue-d-ensemble>Vue d'ensemble</h2><p>Pour utiliser Kubernetes, vous utilisez <em>les objets de l'API Kubernetes</em> pour décrire <em>l'état souhaité</em> de votre cluster: quelles applications ou autres processus que vous souhaitez exécuter, quelles images de conteneur elles utilisent, le nombre de réplicas, les ressources réseau et disque que vous mettez à disposition, et plus encore.
Vous définissez l'état souhaité en créant des objets à l'aide de l'API Kubernetes, généralement via l'interface en ligne de commande, <code>kubectl</code>.
Vous pouvez également utiliser l'API Kubernetes directement pour interagir avec le cluster et définir ou modifier l'état souhaité.</p><p>Une fois que vous avez défini l'état souhaité, le <em>plan de contrôle Kubernetes</em> (control plane en anglais) permet de faire en sorte que l'état actuel du cluster corresponde à l'état souhaité.
Pour ce faire, Kubernetes effectue automatiquement diverses tâches, telles que le démarrage ou le redémarrage de conteneurs, la mise à jour du nombre de réplicas d'une application donnée, etc.
Le control plane Kubernetes comprend un ensemble de processus en cours d'exécution sur votre cluster:</p><ul><li>Le <strong>maître Kubernetes</strong> (Kubernetes master en anglais) qui est un ensemble de trois processus qui s'exécutent sur un seul nœud de votre cluster, désigné comme nœud maître (master node en anglais). Ces processus sont: <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>, <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> et <a href=/docs/admin/kube-scheduler/>kube-scheduler</a>.</li><li>Chaque nœud non maître de votre cluster exécute deux processus:<ul><li><strong><a href=/docs/admin/kubelet/>kubelet</a></strong>, qui communique avec le Kubernetes master.</li><li><strong><a href=/docs/admin/kube-proxy/>kube-proxy</a></strong>, un proxy réseau reflétant les services réseau Kubernetes sur chaque nœud.</li></ul></li></ul><h2 id=objets-kubernetes>Objets Kubernetes</h2><p>Kubernetes contient un certain nombre d'abstractions représentant l'état de votre système: applications et processus conteneurisés déployés, leurs ressources réseau et disque associées, ainsi que d'autres informations sur les activités de votre cluster.
Ces abstractions sont représentées par des objets de l'API Kubernetes; consultez <a href=/docs/concepts/abstractions/overview/>Vue d'ensemble des objets Kubernetes</a> pour plus d'informations.</p><p>Les objets de base de Kubernetes incluent:</p><ul><li><a href=/docs/concepts/workloads/pods/pod-overview/>Pod</a></li><li><a href=/docs/concepts/services-networking/service/>Service</a></li><li><a href=/docs/concepts/storage/volumes/>Volume</a></li><li><a href=/docs/concepts/overview/working-with-objects/namespaces/>Namespace</a></li></ul><p>En outre, Kubernetes contient un certain nombre d'abstractions de niveau supérieur appelées Contrôleurs.
Les contrôleurs s'appuient sur les objets de base et fournissent des fonctionnalités supplémentaires.</p><p>Voici quelques exemples:</p><ul><li><a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a></li><li><a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li><li><a href=/docs/concepts/workloads/controllers/jobs-run-to-completion/>Job</a></li></ul><h2 id=kubernetes-control-plane>Kubernetes control plane</h2><p>Les différentes parties du control plane Kubernetes, telles que les processus Kubernetes master et kubelet, déterminent la manière dont Kubernetes communique avec votre cluster.
Le control plane conserve un enregistrement de tous les objets Kubernetes du système et exécute des boucles de contrôle continues pour gérer l'état de ces objets.
À tout moment, les boucles de contrôle du control plane répondent aux modifications du cluster et permettent de faire en sorte que l'état réel de tous les objets du système corresponde à l'état souhaité que vous avez fourni.</p><p>Par exemple, lorsque vous utilisez l'API Kubernetes pour créer un objet Deployment, vous fournissez un nouvel état souhaité pour le système.
Le control plane Kubernetes enregistre la création de cet objet et exécute vos instructions en lançant les applications requises et en les planifiant vers des nœuds de cluster, afin que l'état actuel du cluster corresponde à l'état souhaité.</p><h3 id=kubernetes-master>Kubernetes master</h3><p>Le Kubernetes master est responsable du maintien de l'état souhaité pour votre cluster.
Lorsque vous interagissez avec Kubernetes, par exemple en utilisant l'interface en ligne de commande <code>kubectl</code>, vous communiquez avec le master Kubernetes de votre cluster.</p><blockquote><p>Le "master" fait référence à un ensemble de processus gérant l'état du cluster.
En règle générale, tous les processus sont exécutés sur un seul nœud du cluster.
Ce nœud est également appelé master.
Le master peut également être répliqué pour la disponibilité et la redondance.</p></blockquote><h3 id=noeuds-kubernetes>Noeuds Kubernetes</h3><p>Les nœuds d’un cluster sont les machines (serveurs physiques, machines virtuelles, etc.) qui exécutent vos applications et vos workflows.
Le master node Kubernetes contrôle chaque noeud; vous interagirez rarement directement avec les nœuds.</p><h4 id=metadonnées-des-objets-kubernetes>Metadonnées des objets Kubernetes</h4><ul><li><a href=/docs/concepts/overview/working-with-objects/annotations/>Annotations</a></li></ul><h2 id=a-suivre>A suivre</h2><p>Si vous souhaitez écrire une page de concept, consultez
<a href=/docs/home/contribute/page-templates/>Utilisation de modèles de page</a>
pour plus d'informations sur le type de page pour la documentation d'un concept.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>1 - Vue d'ensemble</h1><div class=lead>Vue d'ensemble Kubernetes</div></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>1.1 - Qu'est-ce-que Kubernetes ?</h1><div class=lead>Description de Kubernetes</div><p>Cette page est une vue d'ensemble de Kubernetes.</p><p>Kubernetes est une plate-forme open-source extensible et portable pour la gestion de charges de travail (workloads) et de services conteneurisés.
Elle favorise à la fois l'écriture de configuration déclarative (declarative configuration) et l'automatisation.
C'est un large écosystème en rapide expansion.
Les services, le support et les outils Kubernetes sont largement disponibles.</p><p>Google a rendu open-source le projet Kubernetes en 2014.
Le développement de Kubernetes est basé sur une <a href=https://research.google.com/pubs/pub43438.html>décennie et demie d’expérience de Google avec la gestion de la charge et de la mise à l'échelle (scale) en production</a>, associée aux meilleures idées et pratiques de la communauté.</p><h2 id=pourquoi-ai-je-besoin-de-kubernetes-et-que-peut-il-faire>Pourquoi ai-je besoin de Kubernetes et que peut-il faire ?</h2><p>Kubernetes a un certain nombre de fonctionnalités. Il peut être considéré comme:</p><ul><li>une plate-forme de conteneurs</li><li>une plate-forme de microservices</li><li>une plate-forme cloud portable
et beaucoup plus.</li></ul><p>Kubernetes fournit un environnement de gestion <strong>focalisé sur le conteneur</strong> (container-centric).
Il orchestre les ressources machines (computing), la mise en réseau et l’infrastructure de stockage sur les workloads des utilisateurs.
Cela permet de se rapprocher de la simplicité des Platform as a Service (PaaS) avec la flexibilité des solutions d'Infrastructure as a Service (IaaS), tout en gardant de la portabilité entre les différents fournisseurs d'infrastructures (providers).</p><h2 id=comment-kubernetes-est-il-une-plate-forme>Comment Kubernetes est-il une plate-forme ?</h2><p>Même si Kubernetes fournit de nombreuses fonctionnalités, il existe toujours de nouveaux scénarios qui bénéficieraient de fonctionnalités complémentaires.
Ces workflows spécifiques à une application permettent d'accélérer la vitesse de développement.
Si l'orchestration fournie de base est acceptable pour commencer, il est souvent nécessaire d'avoir une automatisation robuste lorsque l'on doit la faire évoluer.
C'est pourquoi Kubernetes a également été conçu pour servir de plate-forme et favoriser la construction d’un écosystème de composants et d’outils facilitant le déploiement, la mise à l’échelle et la gestion des applications.</p><p><a href=/docs/concepts/overview/working-with-objects/labels/>Les Labels</a> permettent aux utilisateurs d'organiser leurs ressources comme ils/elles le souhaitent.
<a href=/docs/concepts/overview/working-with-objects/annotations/>Les Annotations</a> autorisent les utilisateurs à définir des informations personnalisées sur les ressources pour faciliter leurs workflows et fournissent un moyen simple aux outils de gérer la vérification d'un état (checkpoint state).</p><p>De plus, le <a href=/docs/concepts/overview/components/>plan de contrôle Kubernetes (control
plane)</a> est construit sur les mêmes <a href=/docs/reference/using-api/api-overview/>APIs</a> que celles accessibles aux développeurs et utilisateurs.
Les utilisateurs peuvent écrire leurs propres contrôleurs (controllers), tels que les <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/scheduler.md>ordonnanceurs (schedulers)</a>,
avec <a href=/docs/concepts/api-extension/custom-resources/>leurs propres APIs</a> qui peuvent être utilisés par un <a href=/docs/user-guide/kubectl-overview/>outil en ligne de commande</a>.</p><p>Ce choix de <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md>conception</a> a permis de construire un ensemble d'autres systèmes par dessus Kubernetes.</p><h2 id=ce-que-kubernetes-n-est-pas>Ce que Kubernetes n'est pas</h2><p>Kubernetes n’est pas une solution PaaS (Platform as a Service).
Kubernetes opérant au niveau des conteneurs plutôt qu'au niveau du matériel, il fournit une partie des fonctionnalités des offres PaaS, telles que le déploiement, la mise à l'échelle, l'équilibrage de charge (load balancing), la journalisation (logging) et la surveillance (monitoring).
Cependant, Kubernetes n'est pas monolithique.
Ces implémentations par défaut sont optionnelles et interchangeables. Kubernetes fournit les bases permettant de construire des plates-formes orientées développeurs, en laissant la possibilité à l'utilisateur de faire ses propres choix.</p><p>Kubernetes:</p><ul><li>Ne limite pas les types d'applications supportées. Kubernetes prend en charge des workloads extrêmement diverses, dont des applications stateless, stateful ou orientées traitement de données (data-processing).
Si l'application peut fonctionner dans un conteneur, elle devrait fonctionner correctement sur Kubernetes.</li><li>Ne déploie pas de code source et ne build pas d'application non plus. Les workflows d'Intégration Continue, de Livraison Continue et de Déploiement Continu (CI/CD) sont réalisés en fonction de la culture d'entreprise, des préférences ou des pré-requis techniques.</li><li>Ne fournit pas nativement de services au niveau applicatif tels que des middlewares (e.g., message buses), des frameworks de traitement de données (par exemple, Spark), des bases de données (e.g., mysql), caches, ou systèmes de stockage clusterisés (e.g., Ceph).
Ces composants peuvent être lancés dans Kubernetes et/ou être accessibles à des applications tournant dans Kubernetes via des mécaniques d'intermédiation tel que Open Service Broker.</li><li>N'impose pas de solutions de logging, monitoring, ou alerting.
Kubernetes fournit quelques intégrations primaires et des mécanismes de collecte et export de métriques.</li><li>Ne fournit ou n'impose un langague/système de configuration (e.g., <a href=https://github.com/google/jsonnet>jsonnet</a>).
Il fournit une API déclarative qui peut être ciblée par n'importe quelle forme de spécifications déclaratives.</li><li>Ne fournit ou n'adopte aucune mécanique de configuration des machines, de maintenance, de gestion ou de contrôle de la santé des systèmes.</li></ul><p>De plus, Kubernetes n'est pas vraiment un <em>système d'orchestration</em>. En réalité, il élimine le besoin d'orchestration.
Techniquement, l'<em>orchestration</em> se définit par l'exécution d'un workflow spécifié : premièrement faire A, puis B, puis C.
Kubernetes quant à lui est composé d'un ensemble de processus de contrôle qui pilotent l'état courant vers l'état désiré.
Peu importe comment on arrive du point A au point C.
Un contrôle centralisé n'est pas non plus requis.
Cela aboutit à un système plus simple à utiliser et plus puissant, robuste, résiliant et extensible.</p><h2 id=pourquoi-les-conteneurs>Pourquoi les conteneurs ?</h2><p>Vous cherchez des raisons d'utiliser des conteneurs ?</p><p><img src=/images/docs/why_containers.svg alt="Pourquoi les conteneurs ?"></p><p>L'<em>ancienne façon (old way)</em> de déployer des applications consistait à installer les applications sur un hôte en utilisant les systèmes de gestions de paquets natifs.
Cela avait pour principale inconvénient de lier fortement les exécutables, la configuration, les librairies et le cycle de vie de chacun avec l'OS.
Il est bien entendu possible de construire une image de machine virtuelle (VM) immuable pour arriver à produire des publications (rollouts) ou retours arrières (rollbacks), mais les VMs sont lourdes et non-portables.</p><p>La <em>nouvelle façon (new way)</em> consiste à déployer des conteneurs basés sur une virtualisation au niveau du système d'opération (operation-system-level) plutôt que de la virtualisation hardware.
Ces conteneurs sont isolés les uns des autres et de l'hôte :
ils ont leurs propres systèmes de fichiers, ne peuvent voir que leurs propres processus et leur usage des ressources peut être contraint.
Ils sont aussi plus faciles à construire que des VMs, et vu qu'ils sont décorrélés de l'infrastructure sous-jacente et du système de fichiers de l'hôte, ils sont aussi portables entre les différents fournisseurs de Cloud et les OS.</p><p>Étant donné que les conteneurs sont petits et rapides, une application peut être packagée dans chaque image de conteneurs.
Cette relation application-image tout-en-un permet de bénéficier de tous les bénéfices des conteneurs. Avec les conteneurs, des images immuables de conteneurs peuvent être créées au moment du build/release plutôt qu'au déploiement, vu que chaque application ne dépend pas du reste de la stack applicative et n'est pas liée à l'environnement de production.
La génération d'images de conteneurs au moment du build permet d'obtenir un environnement constant qui peut être déployé tant en développement qu'en production. De la même manière, les conteneurs sont bien plus transparents que les VMs, ce qui facilite le monitoring et le management.
Cela est particulièrement vrai lorsque le cycle de vie des conteneurs est géré par l'infrastructure plutôt que caché par un gestionnaire de processus à l'intérieur du conteneur. Avec une application par conteneur, gérer ces conteneurs équivaut à gérer le déploiement de son application.</p><p>Résumé des bénéfices des conteneurs :</p><ul><li><strong>Création et déploiement agile d'applications</strong> :
Augmente la simplicité et l'efficacité de la création d'images par rapport à l'utilisation d'images de VM.</li><li><strong>Développement, intégration et déploiement Continus</strong>:
Fournit un processus pour constuire et déployer fréquemment et de façon fiable avec la capacité de faire des rollbacks rapides et simples (grâce à l'immuabilité de l'image).</li><li><strong>Séparation des besoins entre Dev et Ops</strong>:
Création d'images applicatives au moment du build plutôt qu'au déploiement, tout en séparant l'application de l'infrastructure.</li><li><strong>Observabilité</strong>
Informations venant non seulement du système d'exploitation sous-jacent mais aussi des signaux propres de l'application.</li><li><strong>Consistance entre les environnements de développement, tests et production</strong>:
Fonctionne de la même manière que ce soit sur un poste local que chez un fournisseur d'hébergement / dans le Cloud.</li><li><strong>Portabilité entre Cloud et distribution système</strong>:
Fonctionne sur Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine, et n'importe où.</li><li><strong>Gestion centrée Application</strong>:
Bascule le niveau d'abstraction d'une virtualisation hardware liée à l'OS à une logique de ressources orientée application.</li><li><strong><a href=https://martinfowler.com/articles/microservices.html>Micro-services</a> faiblement couplés, distribués, élastiques</strong>:
Les applications sont séparées en petits morceaux indépendants et peuvent être déployées et gérées dynamiquement -- pas une stack monolithique dans une seule machine à tout faire.</li><li><strong>Isolation des ressources</strong>:
Performances de l'application prédictibles.</li><li><strong>Utilisation des ressources</strong>:
Haute efficacité et densité.</li></ul><h2 id=qu-est-ce-que-kubernetes-signifie-k8s>Qu'est-ce-que Kubernetes signifie ? K8s ?</h2><p>Le nom <strong>Kubernetes</strong> tire son origine du grec ancien, signifiant <em>capitaine</em> ou <em>pilote</em> et est la racine de <em>gouverneur</em> et <a href="http://www.etymonline.com/index.php?term=cybernetics">cybernetic</a>. <em>K8s</em> est l'abbréviation dérivée par le remplacement des 8 lettres "ubernete" par "8".</p><h2 id=a-suivre>A suivre</h2><ul><li>Prêt à <a href=/docs/setup/>commencer</a> ?</li><li>Pour plus de détails, voir la <a href=/docs/home/>documentation Kubernetes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>1.2 - Composants de Kubernetes</h1><p>Ce document résume les divers composants binaires requis pour livrer
un cluster Kubernetes fonctionnel.</p><h2 id=composants-master>Composants Master</h2><p>Les composants Master fournissent le plan de contrôle (control plane) du cluster.
Les composants Master prennent des décisions globales à propos du cluster (par exemple, la planification (scheduling)).
Ils détectent et répondent aux événements du cluster (par exemple, démarrer un nouveau <a class=glossary-tooltip title='Le plus petit et le plus simple des objets Kubernetes. Un Pod est un ensemble de conteneurs fonctionnant sur votre cluster.' data-toggle=tooltip data-placement=top href=/fr/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> lorsque le champ <code>replicas</code> d'un déploiement n'est pas satisfait).</p><p>Les composants Master peuvent être exécutés sur n'importe quelle machine du cluster. Toutefois,
par soucis de simplicité, les scripts de mise en route démarrent typiquement tous les composants master sur la
même machine et n'exécutent pas de conteneurs utilisateur sur cette machine.
Voir <a href=/docs/admin/high-availability/>Construire des Clusters en Haute Disponibilité</a> pour une configuration d'exemple en multi-master-VM.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>Composant sur le master qui expose l'API Kubernetes. Il s'agit du front-end pour le plan de contrôle Kubernetes.</p><p>Il est conçu pour une mise à l'échelle horizontale, ce qui veut dire qu'il met à l'échelle en déployant des instances supplémentaires. Voir <a href=/docs/admin/high-availability/>Construire des Clusters en Haute Disponibilité</a>.</p><h3 id=etcd>etcd</h3><p>Base de données clé-valeur consistante et hautement disponible utilisée comme mémoire de sauvegarde pour toutes les données du cluster.</p><p>Si votre cluster Kubernetes utilise etcd comme mémoire de sauvegarde, assurez-vous d'avoir un plan de
<a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>back up</a> pour ces données.</p><p>Vous pouvez trouver plus d'informations à propos d'etcd dans la <a href=https://etcd.io/docs/>documentation</a> officielle.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Composant sur le master qui surveille les pods nouvellement créés qui ne sont pas assignés à un nœud et sélectionne un nœud sur lequel ils vont s'exécuter.</p><p>Les facteurs pris en compte pour les décisions de planification (scheduling) comprennent les exigences individuelles et collectives en ressources, les contraintes matérielles/logicielles/politiques, les spécifications d'affinité et d'anti-affinité, la localité des données, les interférences entre charges de travail et les dates limites.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Composant du master qui exécute les <a class=glossary-tooltip title="Boucle de contrôle surveillant l'état partagé du cluster à travers l'apiserver et effectuant des changements en essayant de déplacer l'état actuel vers l'état désiré." data-toggle=tooltip data-placement=top href=/docs/admin/kube-controller-manager/ target=_blank aria-label=contrôleurs>contrôleurs</a>.</p><p>Logiquement, chaque <a class=glossary-tooltip title="Boucle de contrôle surveillant l'état partagé du cluster à travers l'apiserver et effectuant des changements en essayant de déplacer l'état actuel vers l'état désiré." data-toggle=tooltip data-placement=top href=/docs/admin/kube-controller-manager/ target=_blank aria-label=contrôleur>contrôleur</a> est un processus à part mais,
pour réduire la complexité, les contrôleurs sont tous compilés dans un seul binaire et s'exécutent dans un seul processus.</p><p>Ces contrôleurs incluent :</p><ul><li>Node Controller : Responsable de détecter et apporter une réponse lorsqu'un nœud tombe en panne.</li><li>Replication Controller : Responsable de maintenir le bon nombre de pods pour chaque objet
ReplicationController dans le système.</li><li>Endpoints Controller : Remplit les objets Endpoints (c'est-à-dire joint les Services et Pods).</li><li>Service Account & Token Controllers : Créent des comptes par défaut et des jetons d'accès à l'API
pour les nouveaux namespaces.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3><p>Le <a href=/docs/tasks/administer-cluster/running-cloud-controller/>cloud-controller-manager</a> exécute les contrôleurs
qui interagissent avec les fournisseurs cloud sous-jacents. Le binaire du cloud-controller-manager est une
fonctionnalité alpha introduite dans la version 1.6 de Kubernetes.</p><p>Le cloud-controller-manager exécute seulement les boucles spécifiques des fournisseurs cloud.
Vous devez désactiver ces boucles de contrôleurs dans le kube-controller-manager.
Vous pouvez désactiver les boucles de contrôleurs en définissant la valeur du flag <code>--cloud-provider</code> à <code>external</code> lors du démarrage du kube-controller-manager.</p><p>Le cloud-controller-manager permet au code du fournisseur cloud et au code de Kubernetes d'évoluer indépendamment l'un de l'autre.
Dans des versions antérieures, le code de base de Kubernetes dépendait du code spécifique du fournisseur cloud pour la fonctionnalité. Dans des versions ultérieures, le code spécifique des fournisseurs cloud devrait être maintenu par les fournisseurs cloud eux-mêmes et lié au cloud-controller-manager lors de l'exécution de Kubernetes.</p><p>Les contrôleurs suivants ont des dépendances vers des fournisseurs cloud :</p><ul><li>Node Controller : Pour vérifier le fournisseur de cloud afin de déterminer si un nœud a été supprimé dans le cloud après avoir cessé de répondre</li><li>Route Controller : Pour mettre en place des routes dans l'infrastructure cloud sous-jacente</li><li>Service Controller : Pour créer, mettre à jour et supprimer les load balancers des fournisseurs cloud</li><li>Volume Controller : Pour créer, attacher et monter des Volumes, et interagir avec le fournisseur cloud pour orchestrer les volumes.</li></ul><h2 id=composants-de-nœud>Composants de nœud</h2><p>Les composants de nœud (Node components) s'exécutent sur chaque nœud, en maintenant les pods en exécution
et en fournissant l'environnement d'exécution Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Un agent qui s'exécute sur chaque nœud du cluster. Il s'assure que les conteneurs fonctionnent dans un pod.</p><p>Le kubelet prend un ensemble de PodSpecs fournis par divers mécanismes et s'assure du fonctionnement et de la santé des conteneurs décrits dans ces PodSpecs. Le kubelet ne gère que les conteneurs créés par Kubernetes.</p><h3 id=kube-proxy>kube-proxy</h3><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> est un
proxy réseau qui s'exécute sur chaque nœud du cluster et implémente une partie du
concept Kubernetes de <a class=glossary-tooltip title="Un moyen d'exposer une application s'exécutant sur un ensemble de pods en tant que service réseau." data-toggle=tooltip data-placement=top href=/fr/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>.</p><p>kube-proxy maintient les règles réseau sur les nœuds. Ces règles réseau permettent
une communication réseau vers les Pods depuis des sessions réseau à l'intérieur ou à l'extérieur
du cluster.</p><p>kube-proxy utilise la couche de filtrage de paquets du système d'exploitation s'il y en a une et qu'elle est disponible. Sinon, kube-proxy transmet le trafic lui-même.</p><h3 id=container-runtime>Container Runtime</h3><p>L'environnement d'exécution de conteneurs est le logiciel responsable de l'exécution des conteneurs.</p><p>Kubernetes est compatible avec plusieurs environnements d'exécution de conteneur: <a href=http://www.docker.com>Docker</a>,
<a href=https://containerd.io>containerd</a>, <a href=https://cri-o.io/>cri-o</a>,
<a href=https://github.com/kubernetes-incubator/rktlet>rktlet</a> ainsi que toute implémentation de <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=addons>Addons</h2><p>Les addons utilisent les ressources Kubernetes (<a class=glossary-tooltip title="S'assure qu'une copie d'un Pod s'exécute sur un ensemble de nœuds d'un cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>, <a class=glossary-tooltip title='Objet API gérant une application répliquée.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Déploiement>Déploiement</a>, etc)
pour implémenter des fonctionnalités cluster. Comme ces derniers fournissent des fonctionnalités au niveau
du cluster, les ressources dans des namespaces pour les addons appartiennent au namespace <code>kube-system</code>.</p><p>Les addons sélectionnés sont décrits ci-dessous. Pour une liste étendue des addons disponibles, voir la page
<a href=/docs/concepts/cluster-administration/addons/>Addons</a>.</p><h3 id=dns>DNS</h3><p>Tandis que les autres addons ne sont pas strictement requis, tous les clusters Kubernetes devraient avoir un
<a href=/fr/docs/concepts/services-networking/dns-pod-service/>DNS cluster</a> car de nombreux exemples en dépendent.</p><p>Le DNS Cluster est un serveur DNS, en plus des autres serveurs DNS dans votre environnement, qui sert
les enregistrements DNS pour les services Kubernetes.</p><p>Les conteneurs démarrés par Kubernetes incluent automatiquement ce serveur DNS dans leurs recherches DNS.</p><h3 id=interface-utilisateur-web-dashboard>Interface utilisateur Web (Dashboard)</h3><p>Le <a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> est une interface utilisateur web à but général pour les clusters Kubernetes. Il permet aux utilisateurs de gérer et de dépanner aussi bien des
applications s'exécutant dans le cluster que le cluster lui-même.</p><h3 id=la-surveillance-des-ressources-de-conteneur>La surveillance des ressources de conteneur</h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>La surveillance des ressources de conteneur</a> enregistre des métriques chronologiques génériques à propos des conteneurs dans une base de données centrale et
fournit une interface utilisateur pour parcourir ces données.</p><h3 id=le-logging-au-niveau-cluster>Le logging au niveau cluster</h3><p>Un mécanisme de <a href=/docs/concepts/cluster-administration/logging/>logging au niveau cluster</a> est chargé
de sauvegarder les logs des conteneurs dans un magasin de logs central avec une interface de recherche/navigation.</p><h2 id=a-suivre>A suivre</h2><ul><li>En savoir plus sur les <a href=/fr/docs/concepts/architecture/nodes/>Nœuds</a></li><li>En savoir plus sur <a href=/docs/concepts/scheduling/kube-scheduler/>kube-scheduler</a></li><li>Lire la <a href=https://etcd.io/docs/>documentation officielle d'etcd</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>1.3 - Utilisation des objets Kubernetes</h1></div><div class=td-content><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>1.3.1 - Namespaces</h1><p>Kubernetes prend en charge plusieurs clusters virtuels présents sur le même cluster physique.
Ces clusters virtuels sont appelés namespaces (espaces de nommage en français).</p><h2 id=quand-utiliser-plusieurs-namespaces>Quand utiliser plusieurs namespaces</h2><p>Les namespaces sont destinés à être utilisés dans les environnements ayant de nombreux utilisateurs répartis en plusieurs équipes ou projets. Pour les clusters de quelques dizaines d'utilisateurs, vous n'avez pas
besoin d'utiliser de namespaces. Commencez à utiliser des namespaces lorsque vous avez
besoin des fonctionnalités qu'ils fournissent.</p><p>Les namespaces sont des groupes de noms. Ils fournissent un modèle d'isolation de nommage des ressources. Les noms des ressources doivent être uniques dans un namespace,
mais pas dans l'ensemble des namespaces. Les namespaces ne peuvent pas être imbriqués les uns dans les autres et chaque ressource Kubernetes ne peut se trouver que dans un seul namespace.</p><p>Les namespaces sont un moyen de répartir les ressources d'un cluster entre plusieurs utilisateurs (via <a href=/docs/concepts/policy/resource-quotas/>quota de ressources</a>).</p><p>Dans les futures versions de Kubernetes, les objets du même namespace auront les mêmes
stratégies de contrôle d'accès par défaut.</p><p>Il n'est pas nécessaire d'utiliser plusieurs namespaces juste pour séparer des ressources légèrement différentes, telles que les versions du même logiciel: utiliser les <a href=/docs/user-guide/labels>labels</a> pour distinguer les
ressources dans le même namespace.</p><h2 id=utilisation-des-namespaces>Utilisation des namespaces</h2><p>La création et la suppression des namespaces sont décrites dans la <a href=/docs/admin/namespaces>Documentation du guide d'administration pour les namespaces</a>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Évitez de créer des namespaces avec le préfixe <code>kube-</code>, car il est réservé aux namespaces système de Kubernetes.</div><h3 id=affichage-des-namespaces>Affichage des namespaces</h3><p>Dans un cluster vous pouvez lister les namespaces actuels à l'aide de :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
</code></pre><p>Kubernetes démarre avec quatre namespaces initiaux:</p><ul><li><code>default</code> Le namespace par défaut pour les objets sans mention d'autre namespace</li><li><code>kube-system</code> Le namespace pour les objets créés par Kubernetes lui-même</li><li><code>kube-public</code> Ce namespace est créé automatiquement et est visible par tous les utilisateurs (y compris ceux qui ne sont pas authentifiés). Ce namespace est principalement réservé à l'utilisation du cluster, au cas où certaines ressources devraient être disponibles publiquement dans l'ensemble du cluster. L'aspect public de ce namespace n'est qu'une convention, pas une exigence.</li><li><code>kube-node-lease</code> Ce namespace contient les objets de bail associés à chaque nœud, ce qui améliore les performances des pulsations du nœud à mesure que le cluster évolue.</li></ul><h3 id=définition-du-namespaces-pour-une-requête>Définition du namespaces pour une requête</h3><p>Pour définir le namespace pour une requête en cours, utilisez l'indicateur <code>--namespace</code>.</p><p>Par exemple:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id=spécifier-un-namespace>Spécifier un namespace</h3><p>Vous pouvez enregistrer de manière permanente le namespace à utiliser pour toutes les commandes kubectl à suivre.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Validez-le</span>
</span></span><span style=display:flex><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id=namespaces-et-dns>Namespaces et DNS</h2><p>Lorsque vous créez un <a href=/fr/docs/concepts/services-networking/service/>Service</a>, il crée une <a href=/fr/docs/concepts/services-networking/dns-pod-service/>entrée DNS</a> correspondante.
Cette entrée est de la forme <code>&lt;nom-service>.&lt;nom-namespace>.svc.cluster.local</code>, ce qui signifie
que si un conteneur utilise simplement <code>&lt;nom-service></code>, il résoudra le service qui
est local à son namespace. Ceci est utile pour utiliser la même configuration pour
plusieurs namespaces tels que le Développement, la Qualification et la Production. Si vous voulez naviguer
entre plusieurs namespaces, vous devez utiliser le nom de domaine complet (FQDN ou nom de domaine complètement qualifié en français).</p><h2 id=tous-les-objets-ne-se-trouvent-pas-dans-un-namespace>Tous les objets ne se trouvent pas dans un namespace</h2><p>La plupart des ressources Kubernetes (par exemple, pods, services, contrôleurs de réplication et autres) sont
dans des namespaces. Cependant, les ressources de type namespace ne sont pas elles-mêmes dans un namespace.
Et les ressources de bas niveau, telles que les <a href=/docs/admin/node>nœuds</a> et les volumes persistants, ne se trouvent dans aucun namespace.</p><p>Pour voir quelles ressources Kubernetes sont et ne sont pas dans un namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Dans un namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Pas dans un namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h2 id=a-suivre>A suivre</h2><ul><li>En savoir plus sur <a href=/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace>créer un nouveau namespace</a>.</li><li>En savoir plus sur <a href=/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace>suppression d'un namespace</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>2 - Architecture de Kubernetes</h1><div class=lead>Architecture Kubernetes</div></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>2.1 - Noeuds</h1><div class=lead>Concept Noeud Kubernetes</div><p>Un nœud est une machine de travail dans Kubernetes, connue auparavant sous le nom de <code>minion</code>.
Un nœud peut être une machine virtuelle ou une machine physique, selon le cluster.
Chaque nœud contient les services nécessaires à l'exécution de <a href=/docs/concepts/workloads/pods/pod/>pods</a> et est géré par les composants du master.
Les services sur un nœud incluent le <a href=/docs/concepts/overview/components/#node-components>container runtime</a>, kubelet et kube-proxy.
Consultez la section <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Le Nœud Kubernetes</a> dans le document de conception de l'architecture pour plus de détails.</p><h2 id=statut-du-nœud>Statut du nœud</h2><p>Le statut d'un nœud contient les informations suivantes:</p><ul><li><a href=#addresses>Addresses</a></li><li><a href=#condition>Condition</a></li><li><a href=#capacity>Capacity</a></li><li><a href=#info>Info</a></li></ul><p>Chaque section est décrite en détail ci-dessous.</p><h3 id=adresses>Adresses</h3><p>L'utilisation de ces champs varie en fonction de votre fournisseur de cloud ou de votre configuration physique.</p><ul><li>HostName: Le nom d'hôte tel que rapporté par le noyau du nœud. Peut être remplacé via le paramètre kubelet <code>--hostname-override</code>.</li><li>ExternalIP: En règle générale, l'adresse IP du nœud pouvant être routé en externe (disponible de l'extérieur du cluster).</li><li>InternalIP: En règle générale, l'adresse IP du nœud pouvant être routé uniquement dans le cluster.</li></ul><h3 id=condition>Condition</h3><p>Le champ <code>conditions</code> décrit le statut de tous les nœuds <code>Running</code>.</p><table><thead><tr><th>Node Condition</th><th>Description</th></tr></thead><tbody><tr><td><code>OutOfDisk</code></td><td><code>True</code> si l'espace disponible sur le nœud est insuffisant pour l'ajout de nouveaux pods, sinon <code>False</code></td></tr><tr><td><code>Ready</code></td><td><code>True</code> si le noeud est sain et prêt à accepter des pods, <code>False</code> si le noeud n'est pas sain et n'accepte pas de pods, et <code>Unknown</code> si le contrôleur de noeud n'a pas reçu d'information du noeud depuis <code>node-monitor-grace-period</code> (la valeur par défaut est de 40 secondes)</td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> s'il existe une pression sur la mémoire du noeud, c'est-à-dire si la mémoire du noeud est faible; autrement <code>False</code></td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> s'il existe une pression sur le nombre de processus, c'est-à-dire s'il y a trop de processus sur le nœud; autrement <code>False</code></td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> s'il existe une pression sur la taille du disque, c'est-à-dire si la capacité du disque est faible; autrement <code>False</code></td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> si le réseau pour le noeud n'est pas correctement configuré, sinon <code>False</code></td></tr></tbody></table><p>La condition de noeud est représentée sous la forme d'un objet JSON.
Par exemple, la réponse suivante décrit un nœud sain.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Si le statut de l'état Ready reste <code>Unknown</code> ou <code>False</code> plus longtemps que <code>pod-eviction-timeout</code>, un argument est passé au <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> et les pods sur le nœud sont programmés pour être supprimés par le contrôleur du nœud.
Le délai d’expulsion par défaut est de <strong>cinq minutes</strong>..
Dans certains cas, lorsque le nœud est inaccessible, l'apiserver est incapable de communiquer avec le kubelet sur le nœud.
La décision de supprimer les pods ne peut pas être communiquée au kublet tant que la communication avec l'apiserver n'est pas rétablie.
Entre-temps, les pods dont la suppression est planifiée peuvent continuer à s'exécuter sur le nœud inaccessible.</p><p>Dans les versions de Kubernetes antérieures à 1.5, le contrôleur de noeud <a href=/docs/concepts/workloads/pods/pod/#force-deletion-of-pods>forcait la suppression</a> de ces pods inaccessibles de l'apiserver.
Toutefois, dans la version 1.5 et ultérieure, le contrôleur de noeud ne force pas la suppression des pods tant qu'il n'est pas confirmé qu'ils ont cessé de fonctionner dans le cluster.
Vous pouvez voir que les pods en cours d'exécution sur un nœud inaccessible sont dans l'état <code>Terminating</code> ou<code> Unknown</code>.
Dans les cas où Kubernetes ne peut pas déduire de l'infrastructure sous-jacente si un nœud a définitivement quitté un cluster, l'administrateur du cluster peut avoir besoin de supprimer l'objet nœud à la main.
La suppression de l'objet nœud de Kubernetes entraîne la suppression de tous les objets Pod exécutés sur le nœud de l'apiserver et libère leurs noms.</p><p>Dans la version 1.12, la fonctionnalité <code>TaintNodesByCondition</code> est promue en version bêta, ce qui permet au contrôleur de cycle de vie du nœud de créer automatiquement des <a href=/docs/concepts/configuration/taint-and-toleration/>marquages</a> (taints en anglais) qui représentent des conditions.
De même, l'ordonnanceur ignore les conditions lors de la prise en compte d'un nœud; au lieu de cela, il regarde les taints du nœud et les tolérances d'un pod.</p><p>Les utilisateurs peuvent désormais choisir entre l'ancien modèle de planification et un nouveau modèle de planification plus flexible.
Un pod qui n’a aucune tolérance est programmé selon l’ancien modèle.
Mais un pod qui tolère les taints d'un nœud particulier peut être programmé sur ce nœud.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> L'activation de cette fonctionnalité crée un léger délai entre le moment où une condition est observée et le moment où une taint est créée.
Ce délai est généralement inférieur à une seconde, mais il peut augmenter le nombre de pods programmés avec succès mais rejetés par le kubelet.</div><h3 id=capacité>Capacité</h3><p>Décrit les ressources disponibles sur le nœud: CPU, mémoire et nombre maximal de pods pouvant être planifiés sur le nœud.</p><h3 id=info>Info</h3><p>Informations générales sur le noeud, telles que la version du noyau, la version de Kubernetes (versions de kubelet et kube-proxy), la version de Docker (si utilisée), le nom du système d'exploitation.
Les informations sont collectées par Kubelet à partir du noeud.</p><h2 id=gestion>Gestion</h2><p>Contrairement aux <a href=/docs/concepts/workloads/pods/>pods</a> et aux [services] (/docs/concepts/services-networking/service/), un nœud n'est pas créé de manière inhérente par Kubernetes: il est créé de manière externe par un cloud tel que Google Compute Engine, ou bien il existe dans votre pool de machines physiques ou virtuelles.
Ainsi, lorsque Kubernetes crée un nœud, il crée un objet qui représente le nœud.
Après la création, Kubernetes vérifie si le nœud est valide ou non.
Par exemple, si vous essayez de créer un nœud à partir du contenu suivant:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kubernetes crée un objet noeud en interne (la représentation) et valide le noeud en vérifiant son intégrité en fonction du champ <code>metadata.name</code>.
Si le nœud est valide, c'est-à-dire si tous les services nécessaires sont en cours d'exécution, il est éligible pour exécuter un pod.
Sinon, il est ignoré pour toute activité de cluster jusqu'à ce qu'il devienne valide.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Kubernetes conserve l'objet pour le nœud non valide et vérifie s'il devient valide.
Vous devez explicitement supprimer l'objet Node pour arrêter ce processus.</div><p>Actuellement, trois composants interagissent avec l'interface de noeud Kubernetes: le contrôleur de noeud, kubelet et kubectl.</p><h3 id=contrôleur-de-nœud>Contrôleur de nœud</h3><p>Le contrôleur de noeud (node controller en anglais) est un composant du master Kubernetes qui gère divers aspects des noeuds.</p><p>Le contrôleur de nœud a plusieurs rôles dans la vie d'un nœud.
La première consiste à affecter un bloc CIDR au nœud lorsqu’il est enregistré (si l’affectation CIDR est activée).</p><p>La seconde consiste à tenir à jour la liste interne des nœuds du contrôleur de nœud avec la liste des machines disponibles du fournisseur de cloud.
Lorsqu'il s'exécute dans un environnement de cloud, chaque fois qu'un nœud est en mauvaise santé, le contrôleur de nœud demande au fournisseur de cloud si la machine virtuelle de ce nœud est toujours disponible.
Sinon, le contrôleur de nœud supprime le nœud de sa liste de nœuds.</p><p>La troisième est la surveillance de la santé des nœuds.
Le contrôleur de noeud est responsable de la mise à jour de la condition NodeReady de NodeStatus vers ConditionUnknown lorsqu'un noeud devient inaccessible (le contrôleur de noeud cesse de recevoir des heartbeats pour une raison quelconque, par exemple en raison d'une panne du noeud), puis de l'éviction ultérieure de tous les pods du noeud. (en utilisant une terminaison propre) si le nœud continue d’être inaccessible.
(Les délais d'attente par défaut sont de 40 secondes pour commencer à signaler ConditionUnknown et de 5 minutes après cela pour commencer à expulser les pods.)</p><p>Le contrôleur de nœud vérifie l'état de chaque nœud toutes les <code>--node-monitor-period</code> secondes.</p><p>Dans les versions de Kubernetes antérieures à 1.13, NodeStatus correspond au heartbeat du nœud.
À partir de Kubernetes 1.13, la fonctionnalité de bail de nœud (node lease en anglais) est introduite en tant que fonctionnalité alpha (feature gate <code>NodeLease</code>, <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md>KEP-0009</a>).
Lorsque la fonction de node lease est activée, chaque noeud a un objet <code>Lease</code> associé dans le namespace <code>kube-node-lease</code> qui est renouvelé périodiquement par le noeud, et NodeStatus et le node lease sont traités comme des heartbeat du noeud.
Les node leases sont renouvelés fréquemment lorsque NodeStatus est signalé de nœud à master uniquement lorsque des modifications ont été apportées ou que suffisamment de temps s'est écoulé (la valeur par défaut est 1 minute, ce qui est plus long que le délai par défaut de 40 secondes pour les nœuds inaccessibles).
Étant donné qu'un node lease est beaucoup plus léger qu'un NodeStatus, cette fonctionnalité rends le heartbeat d'un nœud nettement moins coûteux, tant du point de vue de l'évolutivité que des performances.</p><p>Dans Kubernetes 1.4, nous avons mis à jour la logique du contrôleur de noeud afin de mieux gérer les cas où un grand nombre de noeuds rencontrent des difficultés pour atteindre le master (par exemple parce que le master a un problème de réseau).
À partir de la version 1.4, le contrôleur de noeud examine l’état de tous les noeuds du cluster lorsqu’il prend une décision concernant l’éviction des pods.</p><p>Dans la plupart des cas, le contrôleur de noeud limite le taux d’expulsion à <code>--node-eviction-rate</code> (0,1 par défaut) par seconde, ce qui signifie qu’il n’expulsera pas les pods de plus d’un nœud toutes les 10 secondes.</p><p>Le comportement d'éviction de noeud change lorsqu'un noeud d'une zone de disponibilité donnée devient défaillant.
Le contrôleur de nœud vérifie quel pourcentage de nœuds de la zone est défaillant (la condition NodeReady est ConditionUnknown ou ConditionFalse) en même temps.
Si la fraction de nœuds défaillant est au moins <code>--unhealthy-zone-threshold</code> (valeur par défaut de 0,55), le taux d'expulsion est réduit: si le cluster est petit (c'est-à-dire inférieur ou égal à <code>--large-cluster-size-threshold</code> noeuds - valeur par défaut 50) puis les expulsions sont arrêtées, sinon le taux d'expulsion est réduit à <code>--secondary-node-eviction-rate</code> (valeur par défaut de 0,01) par seconde.</p><p>Ces stratégies sont implémentées par zone de disponibilité car une zone de disponibilité peut être partitionnée à partir du master, tandis que les autres restent connectées.
Si votre cluster ne s'étend pas sur plusieurs zones de disponibilité de fournisseur de cloud, il n'existe qu'une seule zone de disponibilité (la totalité du cluster).</p><p>L'une des principales raisons de la répartition de vos nœuds entre les zones de disponibilité est de pouvoir déplacer la charge de travail vers des zones saines lorsqu'une zone entière tombe en panne.
Par conséquent, si tous les nœuds d’une zone sont défaillants, le contrôleur de nœud expulse à la vitesse normale <code>--node-eviction-rate</code>.
Le cas pathologique se produit lorsque toutes les zones sont complètement défaillantes (c'est-à-dire qu'il n'y a pas de nœuds sains dans le cluster).
Dans ce cas, le contrôleur de noeud suppose qu'il existe un problème de connectivité au master et arrête toutes les expulsions jusqu'à ce que la connectivité soit restaurée.</p><p>À partir de Kubernetes 1.6, NodeController est également responsable de l'expulsion des pods s'exécutant sur des noeuds avec des marques <code>NoExecute</code>, lorsque les pods ne tolèrent pas ces marques.
De plus, en tant que fonctionnalité alpha désactivée par défaut, NodeController est responsable de l'ajout de marques correspondant aux problèmes de noeud tels que les noeuds inaccessibles ou non prêts.
Voir <a href=/docs/concepts/configuration/taint-and-toleration/>cette documentation</a> pour plus de détails sur les marques <code>NoExecute</code> et cette fonctionnalité alpha.</p><p>À partir de la version 1.8, le contrôleur de noeud peut être chargé de créer des tâches représentant les conditions de noeud.
Ceci est une fonctionnalité alpha de la version 1.8.</p><h3 id=auto-enregistrement-des-nœuds>Auto-enregistrement des nœuds</h3><p>Lorsque l'indicateur de kubelet <code>--register-node</code> est à true (valeur par défaut), le kubelet tente de s'enregistrer auprès du serveur d'API.
C'est le modèle préféré, utilisé par la plupart des distributions Linux.</p><p>Pour l'auto-enregistrement (self-registration en anglais), le kubelet est lancé avec les options suivantes:</p><ul><li><code>--kubeconfig</code> - Chemin d'accès aux informations d'identification pour s'authentifier auprès de l'apiserver.</li><li><code>--cloud-provider</code> - Comment lire les métadonnées d'un fournisseur de cloud sur lui-même.</li><li><code>--register-node</code> - Enregistrement automatique avec le serveur API.</li><li><code>--register-with-taints</code> - Enregistrez le noeud avec la liste donnée de marques (séparés par des virgules <code>&lt;key>=&lt;value>:&lt;effect></code>). Sans effet si <code>register-node</code> est à false.</li><li><code>--node-ip</code> - Adresse IP du noeud.</li><li><code>--node-labels</code> - Labels à ajouter lors de l’enregistrement du noeud dans le cluster (voir Restrictions des labels appliquées par le <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>plugin NodeRestriction admission</a> dans les versions 1.13+).</li><li><code>--node-status-update-frequency</code> - Spécifie la fréquence à laquelle kubelet publie le statut de nœud sur master.</li></ul><p>Quand le mode <a href=/docs/reference/access-authn-authz/node/>autorisation de nœud</a> et <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>plugin NodeRestriction admission</a> sont activés, les kubelets sont uniquement autorisés à créer / modifier leur propre ressource de noeud.</p><h4 id=administration-manuelle-de-noeuds>Administration manuelle de noeuds</h4><p>Un administrateur de cluster peut créer et modifier des objets de nœud.</p><p>Si l'administrateur souhaite créer des objets de noeud manuellement, définissez l'argument de kubelet: <code>--register-node=false</code>.</p><p>L'administrateur peut modifier les ressources du nœud (quel que soit le réglage de <code>--register-node</code>).
Les modifications comprennent la définition de labels sur le nœud et son marquage comme non programmable.</p><p>Les étiquettes sur les nœuds peuvent être utilisées avec les sélecteurs de nœuds sur les pods pour contrôler la planification. Par exemple, pour contraindre un pod à ne pouvoir s'exécuter que sur un sous-ensemble de nœuds.</p><p>Marquer un nœud comme non planifiable empêche la planification de nouveaux pods sur ce nœud, mais n'affecte pas les pods existants sur le nœud.
Ceci est utile comme étape préparatoire avant le redémarrage d'un nœud, etc. Par exemple, pour marquer un nœud comme non programmable, exécutez la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Les pods créés par un contrôleur DaemonSet contournent le planificateur Kubernetes et ne respectent pas l'attribut unschedulable sur un nœud.
Cela suppose que les démons appartiennent à la machine même si celle-ci est en cours de vidage des applications pendant qu'elle se prépare au redémarrage.</div><h3 id=capacité-de-nœud>Capacité de nœud</h3><p>La capacité du nœud (nombre de CPU et quantité de mémoire) fait partie de l’objet Node.
Normalement, les nœuds s'enregistrent et indiquent leur capacité lors de la création de l'objet Node.
Si vous faites une <a href=#manual-node-administration>administration manuelle de nœud</a>, alors vous devez définir la capacité du nœud lors de l'ajout d'un nœud.</p><p>Le scheduler Kubernetes veille à ce qu'il y ait suffisamment de ressources pour tous les pods d'un noeud.
Il vérifie que la somme des demandes des conteneurs sur le nœud n'est pas supérieure à la capacité du nœud.
Cela inclut tous les conteneurs lancés par le kubelet, mais pas les conteneurs lancés directement par le <a href=/docs/concepts/overview/components/#noeud-composants>conteneur runtime</a>, ni aucun processus exécuté en dehors des conteneurs.</p><p>Si vous souhaitez réserver explicitement des ressources pour des processus autres que Pod, suivez ce tutoriel pour: <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>réserver des ressources pour les démons système</a>.</p><h2 id=api-object>API Object</h2><p>L'objet Node est une ressource de niveau supérieur dans l'API REST de Kubernetes.
Plus de détails sur l'objet API peuvent être trouvés à l'adresse suivante: <a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>Node API object</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-63e7fdf87ba61eb2586bb8c625c23506>2.2 - Communication Master-Node</h1><div class=lead>Communication Master-Node Kubernetes</div><p>Ce document répertorie les canaux de communication entre l'API du noeud maître (apiserver of master node en anglais) et le reste du cluster Kubernetes.
L'objectif est de permettre aux utilisateurs de personnaliser leur installation afin de sécuriser la configuration réseau, de sorte que le cluster puisse être exécuté sur un réseau non approuvé (ou sur des adresses IP entièrement publiques d'un fournisseur de cloud).</p><h2 id=communication-du-cluster-vers-le-master>Communication du Cluster vers le Master</h2><p>Tous les canaux de communication du cluster au master se terminent à l'apiserver (aucun des autres composants principaux n'est conçu pour exposer des services distants).
Dans un déploiement typique, l'apiserver est configuré pour écouter les connexions distantes sur un port HTTPS sécurisé (443) avec un ou plusieurs types d'<a href=/docs/reference/access-authn-authz/authentication/>authentification</a> client.
Une ou plusieurs formes d'<a href=/docs/reference/access-authn-authz/authorization/>autorisation</a> devraient être activées, notamment si les <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>requêtes anonymes</a> ou <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>jeton de compte de service</a> sont autorisés.</p><p>Le certificat racine public du cluster doit être configuré pour que les nœuds puissent se connecter en toute sécurité à l'apiserver avec des informations d'identification client valides.
Par exemple, dans un déploiement GKE par défaut, les informations d'identification client fournies au kubelet sont sous la forme d'un certificat client.
Consultez <a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>amorçage TLS de kubelet</a> pour le provisioning automatisé des certificats de client Kubelet.</p><p>Les pods qui souhaitent se connecter à l'apiserver peuvent le faire de manière sécurisée en utilisant un compte de service afin que Kubernetes injecte automatiquement le certificat racine public et un jeton de support valide dans le pod lorsqu'il est instancié.
Le service <code>kubernetes</code> (dans tous les namespaces) est configuré avec une adresse IP virtuelle redirigée (via kube-proxy) vers le point de terminaison HTTPS sur l'apiserver.</p><p>Les composants du master communiquent également avec l'apiserver du cluster via le port sécurisé.</p><p>Par conséquent, le mode de fonctionnement par défaut pour les connexions du cluster (nœuds et pods s'exécutant sur les nœuds) au master est sécurisé par défaut et peut s'exécuter sur des réseaux non sécurisés et/ou publics.</p><h2 id=communication-du-master-vers-le-cluster>Communication du Master vers le Cluster</h2><p>Il existe deux voies de communication principales du master (apiserver) au cluster.
La première est du processus apiserver au processus kubelet qui s'exécute sur chaque nœud du cluster.
La seconde part de l'apiserver vers n'importe quel nœud, pod ou service via la fonctionnalité proxy de l'apiserver.</p><h3 id=communication-de-l-apiserver-vers-le-kubelet>Communication de l'apiserver vers le kubelet</h3><p>Les connexions de l'apiserver au kubelet sont utilisées pour:</p><ul><li>Récupérer les logs des pods.</li><li>S'attacher (via kubectl) à des pods en cours d'exécution.</li><li>Fournir la fonctionnalité de transfert de port du kubelet.</li></ul><p>Ces connexions se terminent au point de terminaison HTTPS du kubelet.
Par défaut, l'apiserver ne vérifie pas le certificat du kubelet, ce qui rend la connexion sujette aux attaques de type "man-in-the-middle", et <strong>non sûre</strong> sur des réseaux non approuvés et/ou publics.</p><p>Pour vérifier cette connexion, utilisez l'argument <code>--kubelet-certificate-authority</code> pour fournir à l'apiserver un ensemble de certificats racine à utiliser pour vérifier le certificat du kubelet.</p><p>Si ce n'est pas possible, utilisez <a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/>SSH tunneling</a> entre l'apiserver et le kubelet si nécessaire pour éviter la connexion sur un réseau non sécurisé ou public.</p><p>Finalement, l'<a href=/docs/admin/kubelet-authentication-authorization/>authentification et/ou autorisation du Kubelet</a> devrait être activée pour sécuriser l'API kubelet.</p><h3 id=apiserver-vers-nodes-pods-et-services>apiserver vers nodes, pods et services</h3><p>Les connexions de l'apiserver à un nœud, à un pod ou à un service sont définies par défaut en connexions HTTP.
Elles ne sont donc ni authentifiées ni chiffrées.
Elles peuvent être exécutées sur une connexion HTTPS sécurisée en préfixant <code>https:</code> au nom du nœud, du pod ou du service dans l'URL de l'API.
Cependant ils ne valideront pas le certificat fourni par le point de terminaison HTTPS ni ne fourniront les informations d'identification du client.
De plus, aucune garantie d'intégrité n'est fournie.
Ces connexions <strong>ne sont actuellement pas sûres</strong> pour fonctionner sur des réseaux non sécurisés et/ou publics.</p><h3 id=ssh-tunnels>SSH Tunnels</h3><p>Kubernetes prend en charge les tunnels SSH pour protéger les communications master -> cluster.
Dans cette configuration, l'apiserver initie un tunnel SSH vers chaque nœud du cluster (en se connectant au serveur ssh sur le port 22) et transmet tout le trafic destiné à un kubelet, un nœud, un pod ou un service via un tunnel.
Ce tunnel garantit que le trafic n'est pas exposé en dehors du réseau dans lequel les nœuds sont en cours d'exécution.</p><p>Les tunnels SSH étant actuellement obsolètes, vous ne devriez pas choisir de les utiliser à moins de savoir ce que vous faites.
Un remplacement pour ce canal de communication est en cours de conception.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>2.3 - Concepts sous-jacents au Cloud Controller Manager</h1><p>Le concept de cloud controller manager (CCM) (ne pas confondre avec le binaire) a été créé à l'origine pour permettre au code de fournisseur spécifique de cloud et au noyau Kubernetes d'évoluer indépendamment les uns des autres.
Le gestionnaire de contrôleur de cloud fonctionne aux côtés d'autres composants principaux, tels que le gestionnaire de contrôleur Kubernetes, le serveur d'API et le planificateur.
Il peut également être démarré en tant qu’addon Kubernetes, auquel cas il s’exécute sur Kubernetes.</p><p>La conception du gestionnaire de contrôleur de cloud repose sur un mécanisme de plugin qui permet aux nouveaux fournisseurs de cloud de s'intégrer facilement à Kubernetes à l'aide de plugins.
Des plans sont en place pour intégrer de nouveaux fournisseurs de cloud sur Kubernetes et pour migrer les fournisseurs de cloud de l'ancien modèle vers le nouveau modèle CCM.</p><p>Ce document discute des concepts derrière le cloud controller manager et donne des détails sur ses fonctions associées.</p><p>Voici l'architecture d'un cluster Kubernetes sans le cloud controller manager:</p><p><img src=/images/docs/pre-ccm-arch.png alt="Pre CCM Kube Arch"></p><h2 id=conception>Conception</h2><p>Dans le diagramme précédent, Kubernetes et le fournisseur de cloud sont intégrés via plusieurs composants différents:</p><ul><li>Kubelet</li><li>Kubernetes controller manager</li><li>Kubernetes API server</li></ul><p>Le CCM consolide toute la logique dépendante du cloud des trois composants précédents pour créer un point d’intégration unique avec le cloud.
La nouvelle architecture avec le CCM se présente comme suit:</p><p><img src=/images/docs/post-ccm-arch.png alt="CCM Kube Arch"></p><h2 id=composants-du-ccm>Composants du CCM</h2><p>Le CCM rompt certaines fonctionnalités du Kubernetes Controller Manager (KCM) et les exécute en tant que processus séparé.
Plus précisément, il sépare les contrôleurs du KCM qui dépendent du cloud.
Le KCM comporte les boucles de contrôle dépendant du cloud suivantes:</p><ul><li>Contrôleur de nœud</li><li>Contrôleur de volume</li><li>Contrôleur de route</li><li>Contrôleur de service</li></ul><p>Dans la version 1.9, le CCM exécute les contrôleurs suivants de la liste précédente:</p><ul><li>Contrôleur de nœud</li><li>Contrôleur de route</li><li>Contrôleur de service</li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le contrôleur de volume a été délibérément choisi pour ne pas faire partie de CCM.
En raison de la complexité du processus et des efforts déployés pour supprimer la logique de volume spécifique au fournisseur, il a été décidé que le contrôleur de volume ne serait pas déplacé vers CCM.</div><p>Le plan initial de prise en charge des volumes à l'aide de CCM consistait à utiliser des volumes Flex pour prendre en charge des volumes pouvant être connectés.
Cependant, un effort concurrentiel appelé CSI est prévu pour remplacer Flex.</p><p>Compte tenu de cette dynamique, nous avons décidé d'avoir une mesure de transition intermédiaire jusqu'à ce que le CSI soit prêt.</p><h2 id=fonctions-du-ccm>Fonctions du CCM</h2><p>Le CCM hérite ses fonctions des composants de Kubernetes qui dépendent d'un fournisseur de cloud.
Cette section est structurée en fonction de ces composants.</p><h3 id=1-kubernetes-controller-manager>1. Kubernetes controller manager</h3><p>La majorité des fonctions du CCM sont dérivées du KCM.
Comme indiqué dans la section précédente, le CCM exécute les boucles de contrôle suivantes:</p><ul><li>Contrôleur de nœud</li><li>Contrôleur de route</li><li>Contrôleur de service</li></ul><h4 id=contrôleur-de-nœud>Contrôleur de nœud</h4><p>Le contrôleur de noeud est responsable de l'initialisation d'un noeud en obtenant des informations sur les noeuds s'exécutant dans le cluster auprès du fournisseur de cloud.
Le contrôleur de noeud exécute les fonctions suivantes:</p><ol><li>Il initialise le nœud avec des labels de zone/région spécifiques au cloud.</li><li>Il initialise le nœud avec des détails d'instance spécifiques au cloud, tels que le type et la taille de l'instance.</li><li>Il obtient les adresses réseau et le nom d'hôte du nœud.</li><li>Si un nœud ne répond plus, le controlleur vérifie avec le cloud pour voir s'il a été supprimé du cloud.
Si le nœud a été supprimé du cloud, le controlleur supprime l'objet Kubernetes Node.</li></ol><h4 id=contrôleur-de-route>Contrôleur de route</h4><p>Le contrôleur de route est responsable de la configuration appropriée des itinéraires dans le cloud afin que les conteneurs situés sur différents nœuds du cluster Kubernetes puissent communiquer entre eux.
Le contrôleur de route ne s'applique qu'aux clusters Google Compute Engine.</p><h4 id=contrôleur-de-service>Contrôleur de service</h4><p>Le contrôleur de service est chargé d'écouter les événements de création, de mise à jour et de suppression de service.
En fonction de l'état actuel des services dans Kubernetes, il configure les équilibreurs de charge dans le cloud (tels que ELB, Google LB ou Oracle Cloud Infrastructure LB) pour refléter l'état des services dans Kubernetes.
De plus, cela garantit que les services de base des services pour les load balancers dans le cloud sont à jour.</p><h3 id=2-kubelet>2. Kubelet</h3><p>Le contrôleur de noeud contient les fonctionnalités du kubelet dépendant du cloud.
Avant l'introduction du CCM, la sous-unité était responsable de l'initialisation d'un nœud avec des détails spécifiques au cloud, tels que les adresses IP, les étiquettes de région / zone et les informations de type d'instance.
L’introduction du CCM a déplacé cette opération d’initialisation du kubelet vers le CCM.</p><p>Dans ce nouveau modèle, le kubelet initialise un nœud sans informations spécifiques au cloud.
Cependant, il ajoute un marquage au nœud nouvellement créé, qui rend le nœud non planifiable jusqu'à ce que le CCM initialise le nœud avec des informations spécifiques au cloud.
Il supprime ensuite ce marquage.</p><h2 id=mécanisme-de-plugin>Mécanisme de plugin</h2><p>Le cloud controller manager utilise des interfaces Go pour autoriser la mise en œuvre d'implémentations depuis n'importe quel cloud.
Plus précisément, il utilise l'interface CloudProvider définie <a href=https://github.com/kubernetes/cloud-provider/blob/9b77dc1c384685cb732b3025ed5689dd597a5971/cloud.go#L42-L62>ici</a>.</p><p>La mise en œuvre des quatre contrôleurs partagés soulignés ci-dessus, ainsi que certaines configurations ainsi que l'interface partagée du fournisseur de cloud, resteront dans le noyau Kubernetes.
Les implémentations spécifiques aux fournisseurs de cloud seront construites en dehors du noyau et implémenteront les interfaces définies dans le noyau.</p><p>Pour plus d’informations sur le développement de plugins, consultez <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Developing Cloud Controller Manager</a>.</p><h2 id=autorisation>Autorisation</h2><p>Cette section détaille les accès requis par le CCM sur divers objets API pour effectuer ses opérations.</p><h3 id=contrôleur-de-nœud-1>Contrôleur de nœud</h3><p>Le contrôleur de noeud ne fonctionne qu'avec les objets de noeud.
Il nécessite un accès complet aux objets Node via get, list, create, update, patch, watch et delete.</p><p>v1/Node:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=contrôleur-de-route-1>Contrôleur de route</h3><p>Le contrôleur de route écoute les évenements de création d'objet Node et configure les routes de manière appropriée.
Cela nécessite un accès get aux objets Node.</p><p>v1/Node:</p><ul><li>Get</li></ul><h3 id=contrôleur-de-service-1>Contrôleur de Service</h3><p>Le contrôleur de service écoute les évenements de création, suppression et mises à jour des objets Service et configure les endpoints pour ces Services de manière appropriée.</p><p>Pour accéder aux Services, il faut les accès list et watch.
Pour mettre à jour les Services, il faut les accès patch et update.</p><p>Pour configurer des points de terminaison pour les services, vous devez avoir accès au create, list, get, watch, et update.</p><p>v1/Service:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=autres>Autres</h3><p>La mise en œuvre du CCM nécessite un accès pour créer des événements, et pour garantir un fonctionnement sécurisé, un accès est nécessaire pour créer ServiceAccounts.</p><p>v1/Event:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p>v1/ServiceAccount:</p><ul><li>Create</li></ul><p>Le ClusterRole RBAC pour le CCM ressemble à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=implémentations-des-fournisseurs-de-cloud>Implémentations des fournisseurs de cloud</h2><p>Les fournisseurs de cloud suivants ont implémenté leur CCM:</p><ul><li><a href=https://github.com/digitalocean/digitalocean-cloud-controller-manager>Digital Ocean</a></li><li><a href=https://github.com/oracle/oci-cloud-controller-manager>Oracle</a></li><li><a href=https://github.com/kubernetes/cloud-provider-azure>Azure</a></li><li><a href=https://github.com/kubernetes/cloud-provider-gcp>GCP</a></li><li><a href=https://github.com/kubernetes/cloud-provider-aws>AWS</a></li><li><a href=https://github.com/baidu/cloud-provider-baiducloud>BaiduCloud</a></li><li><a href=https://github.com/linode/linode-cloud-controller-manager>Linode</a></li><li><a href=https://github.com/scaleway/scaleway-cloud-controller-manager>Scaleway</a></li></ul><h2 id=administration-de-cluster>Administration de cluster</h2><p>Des instructions complètes pour la configuration et l'exécution du CCM sont fournies <a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>ici</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>3 - Les conteneurs</h1><div class=lead>Conteneurs Kubernetes</div></div><div class=td-content><h1 id=pg-16042b4652ad19e565c7263824029a43>3.1 - Images</h1><div class=lead>Images conteneur Kubernetes</div><p>Vous créez une image Docker et la poussez dans un registre avant de la référencer depuis un pod Kubernetes.</p><p>La propriété <code>image</code> d'un conteneur utilise la même syntaxe que la commande <code>docker</code>, y compris pour les registres privés et les tags.</p><h2 id=mettre-à-jour-des-images>Mettre à jour des images</h2><p>La politique de récupération par défaut est <code>IfNotPresent</code>, Kubelet ne récupère alors pas une image si elle est déjà présente sur le nœud.
Si vous voulez forcer une récupération à chaque fois, vous pouvez faire une des actions suivantes :</p><ul><li>définissez <code>imagePullPolicy</code> du conteneur à <code>Always</code>.</li><li>omettez <code>imagePullPolicy</code> et utilisez <code>:latest</code> comme tag pour l'image à utiliser.</li><li>omettez <code>imagePullPolicy</code> et le tag de l'image à utiliser.</li><li>activez l'admission controller <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a>.</li></ul><p>Notez que vous devez éviter d'utiliser le tag <code>:latest</code>, voir <a href=/docs/concepts/configuration/overview/#container-images>Bonnes pratiques pour la configuration</a> pour plus d'informations.</p><h2 id=créer-des-images-multi-architecture-à-partir-de-manifestes>Créer des images multi-architecture à partir de manifestes</h2><p>La CLI Docker prend maintenant en charge la commande <code>docker manifest</code> avec des sous-commandes comme <code>create</code>, <code>annotate</code> et <code>push</code>. Ces commandes peuvent être utilisées pour construire et pousser les manifestes. Vous pouvez utiliser <code>docker manifest inspect</code> pour voir le manifeste.</p><p>Vous pouvez voir la documentation Docker ici :
<a href=https://docs.docker.com/edge/engine/reference/commandline/manifest/>https://docs.docker.com/edge/engine/reference/commandline/manifest/</a></p><p>Voici comment nous l'utilisons dans notre outil de build:
<a href="https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&i=nope&files=&repos=">https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&i=nope&files=&repos=</a></p><p>Ces commandes se basent et sont implémentées purement sur la CLI Docker. Vous devrez soit éditer <code>$HOME/.docker/config.json</code> et définir la clé <code>experimental</code> à <code>enabled</code> ou vous pouvez simplement définir la variable d'environnement <code>DOCKER_CLI_EXPERIMENTAL</code> à <code>enabled</code> lorsque vous appelez les commandes de la CLI.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Veuillez utiliser les versions <em>18.06 ou ultérieure</em>, les versions antérieures ayant des bugs ou ne prenant pas en charge l'option <code>experimental</code> pour la ligne de commande. Par exemple <a href=https://github.com/docker/cli/issues/1135>https://github.com/docker/cli/issues/1135</a> cause des problèmes sous <code>containerd</code>.</div><p>Si vous avez des problèmes en téléchargeant des manifestes viciés, nettoyez les anciens manifestes dans <code>$HOME/.docker/manifests</code> pour recommencer de zéro.</p><p>Pour Kubernetes, nous avons historiquement utilisé des images avec des suffixes <code>-$(ARCH)</code>. Pour une rétrocompatibilité, veuillez générer les anciennes images avec des suffixes. Par exemple, l'image <code>pause</code> qui a le manifeste pour toutes les architetures et l'image <code>pause-amd64</code> qui est rétrocompatible
pour d'anciennes configurations ou des fichiers YAML qui auraient codé en dur les images avec des suffixes.</p><h2 id=utiliser-un-registre-privé>Utiliser un registre privé</h2><p>Les registres privés peuvent demander des clés pour pouvoir lire leurs images.</p><p>Ces certificats peuvent être fournis de différentes manières :</p><ul><li>En utilisant la Google Container Registry<ul><li>par cluster</li><li>automatiqueent configuré dans Google Compute Engine ou Google Kubernetes Engine</li><li>tous les pods peuvent lire le registre privé du projet</li></ul></li><li>En utilisant Amazon Elastic Container Registry (ECR)<ul><li>utilise les rôles et politiques IAM pour contrôler l'accès aux dépôts ECR</li><li>rafraîchit automatiquement les certificats de login ECR</li></ul></li><li>En utilisant Oracle Cloud Infrastructure Registry (OCIR)<ul><li>utilise les rôles et politiques IAM pour contrôler l'accès aux dépôts OCIR</li></ul></li><li>En utilisant Azure Container Registry (ACR)</li><li>En utilisant IBM Cloud Container Registry<ul><li>utilise les rôles et politiques IAM pour contrôler l'accès à l'IBM Cloud Container Registry</li></ul></li><li>En configurant les nœuds pour s'authentifier auprès d'un registre privé<ul><li>tous les pods peuvent lire les registres privés configurés</li><li>nécessite la configuration des nœuds par un administrateur du cluster</li></ul></li><li>En utilisant des images pré-chargées<ul><li>tous les pods peuvent utiliser toutes les images mises en cache sur un nœud</li><li>nécessite l'accès root à tous les nœuds pour la mise en place</li></ul></li><li>En spécifiant ImagePullSecrets dans un Pod<ul><li>seuls les pods fournissant ses propres clés peuvent accéder au registre privé</li></ul></li></ul><p>Chaque option est décrite plus en détails ci-dessous.</p><h3 id=utiliser-la-google-container-registry>Utiliser la Google Container Registry</h3><p>Kubernetes prend en charge nativement la <a href=https://cloud.google.com/tools/container-registry/>Google Container
Registry (GCR)</a>, lorsqu'il s'exécute dans Google Compute
Engine (GCE). Si vous exécutez votre cluster dans GCE ou Google Kubernetes Engine, utilisez simplement le nom complet de l'image (par ex. gcr.io/my_project/image:tag).</p><p>Tous les pods dans un cluster auront un accès en lecture aux images dans le registre.</p><p>Kubelet va s'authentifier auprès de GCR en utilisant le compte de service Google de l'instance.
Le compte de service dans l'instance aura un <code>https://www.googleapis.com/auth/devstorage.read_only</code>,
afin qu'il puisse récupérer depuis le GCR du projet mais qu'il ne puisse pas pousser une image.</p><h3 id=utiliser-amazon-elastic-container-registry>Utiliser Amazon Elastic Container Registry</h3><p>Kubernetes prend en charge nativement <a href=https://aws.amazon.com/ecr/>Amazon Elastic Container Registry</a>, lorsque les nœuds sont des instances de AWS EC2.</p><p>Utilisez simplement le nom complet de l'image (par ex. <code>ACCOUNT.dkr.ecr.REGION.amazonaws.com/imagename:tag</code>)
dans la définition du Pod.</p><p>Tous les utilisateurs du cluster qui peuvent créer des pods auront la possibilité
d'exécuter des pods qui utilisent n'importe quelle image du registre ECR.</p><p>Kubelet va aller chercher et rafraîchir périodiquement les certificats ECR. Les permissions suivantes sont requises par kubelet :</p><ul><li><code>ecr:GetAuthorizationToken</code></li><li><code>ecr:BatchCheckLayerAvailability</code></li><li><code>ecr:GetDownloadUrlForLayer</code></li><li><code>ecr:GetRepositoryPolicy</code></li><li><code>ecr:DescribeRepositories</code></li><li><code>ecr:ListImages</code></li><li><code>ecr:BatchGetImage</code></li></ul><p>Exigences :</p><ul><li>Vous devez utiliser kubelet version <code>v1.2.0</code> ou ultérieure. (exécutez par ex. <code>/usr/bin/kubelet --version=true</code>).</li><li>Si vos nœuds sont dans une région différente de votre registre, vous devez utiliser la version <code>v1.3.0</code> ou ultérieure.</li><li>ECR doit être disponible dans votre région.</li></ul><p>Dépannage :</p><ul><li>Vérifiez toutes les exigences ci-dessus.</li><li>Copiez les certificats de $REGION (par ex. <code>us-west-2</code>) sur votre poste de travail. Connectez-vous en SSH sur l'hôte et exécutez Docker manuellement avec ces certificats. Est-ce que ça marche ?</li><li>Vérifiez que kubelet s'exécute avec <code>--cloud-provider=aws</code>.</li><li>Augmentez la verbosité des logs de kubelet à au moins 3 et recherchez dans les logs de kubelet (par exemple avec <code>journalctl -u kubelet</code>) des lignes similaires à :</li></ul><ul><li><ul><li><code>aws_credentials.go:109] unable to get ECR credentials from cache, checking ECR API</code></li></ul></li><li><ul><li><code>aws_credentials.go:116] Got ECR credentials from ECR API for &lt;AWS account ID for ECR>.dkr.ecr.&lt;AWS region>.amazonaws.com</code></li></ul></li></ul><h3 id=utiliser-azure-container-registry-acr>Utiliser Azure Container Registry (ACR)</h3><p>En utilisant <a href=https://azure.microsoft.com/en-us/services/container-registry/>Azure Container Registry</a>
vous pouvez vous authentifier en utilisant soit un utilisateur admin soit un service principal.
Dans les deux cas, l'authentification est faite via l'authentification standard de Docker. Ces instructions assument l'outil en ligne de commande <a href=https://github.com/azure/azure-cli>azure-cli</a>.</p><p>Vous devez d'abord créer un registre et générer des certificats, la documentation complète pour cela peut être touvée dans la <a href=https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli>documentation de Azure container registry</a>.</p><p>Une fois votre registre de conteneurs créé, vous utiliserez les certificats suivants pour vous connecter :</p><ul><li><code>DOCKER_USER</code> : service principal ou utilisateur admin</li><li><code>DOCKER_PASSWORD</code>: mot de passe du service principal ou utilisateur admin</li><li><code>DOCKER_REGISTRY_SERVER</code>: <code>${un-nom-de-registre}.azurecr.io</code></li><li><code>DOCKER_EMAIL</code>: <code>${une-adresse-email}</code></li></ul><p>Une fois que vous avez défini ces variables, vous pouvez
<a href=/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>configurer un Secret Kubernetes et l'utiliser pour déployer un Pod</a>.</p><h3 id=utiliser-ibm-cloud-container-registry>Utiliser IBM Cloud Container Registry</h3><p>IBM Cloud Container Registry fournit un registre d'images multi-tenant privé que vous pouvez utiliser pour stocker et partager de manière sécurisée vos images. Par défaut, les images de votre registre privé sont scannées par le Vulnerability Advisor intégré pour détecter des failles de sécurité et des vulnérabilités potentielles. Les utilisateurs de votre compte IBM Cloud peuvent accéder à vos images, ou vous pouvez des rôles et politiques IAM pour fournir l'accès aux namespaces de l'IBM Cloud Container Registry.</p><p>Pour installer le plugin du CLI de IBM Cloud Container Registry et créer un namespace pour vos images, voir <a href="https://cloud.ibm.com/docs/Registry?topic=registry-getting-started">Débuter avec IBM Cloud Container Registry</a>.</p><p>Si vous utilisez le même compte et la même région, vous pouvez déployer des images stockées dans IBM Cloud Container Registry vers la namespace <code>default</code> de votre cluster IBM Cloud Kubernetes Service sans configuration supplémentaire, voir <a href="https://cloud.ibm.com/docs/containers?topic=containers-images">Construire des conteneurs à partir d'images</a>. Pour les autres options de configuration, voir <a href="https://cloud.ibm.com/docs/containers?topic=containers-registry#cluster_registry_auth">Comprendre comment autoriser votre cluster à télécharger des images depuis un registre</a>.</p><h3 id=configurer-les-nœuds-pour-s-authentifier-auprès-d-un-registre-privé>Configurer les nœuds pour s'authentifier auprès d'un registre privé</h3><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si vous travaillez dans Google Kubernetes Engine, vous trouverez un <code>.dockercfg</code> sur chaque nœud avec les certificats pour Google Container Registry. Vous ne pourrez pas utiliser cette méthode.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si vous travaillez dans AWS EC2 et utilisez EC2 Container Registry (ECR), kubelet sur chaque nœud va gérer et mettre à jour les certificats du login ECR. Vous ne pourrez pas utiliser cette méthode.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Cette méthode est utilisable si vous avez le contrôle sur la configuration des nœuds. Elle ne marchera pas
correctement sur GCE, et sur tout autre fournisseur cloud qui fait du remplacement de nœud automatique.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Kubernetes prend pour l'instant en charge uniquement les sections <code>auths</code> et <code>HttpHeaders</code> de la config docker. Cela veut dire que les aides aux certificats (<code>credHelpers</code> ou <code>credsStore</code>) ne sont pas pris en charge.</div><p>Docker stocke les clés pour les regisres privés dans le fichier <code>$HOME/.dockercfg</code> ou <code>$HOME/.docker/config.json</code>. Si vous placez le même fichier dans un des chemins de recherche ci-dessous, kubelet l'utilise comme fournisseur de clés lorsque les images sont récupérées.</p><ul><li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li><li><code>{cwd of kubelet}/config.json</code></li><li><code>${HOME}/.docker/config.json</code></li><li><code>/.docker/config.json</code></li><li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li><li><code>{cwd of kubelet}/.dockercfg</code></li><li><code>${HOME}/.dockercfg</code></li><li><code>/.dockercfg</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous pouvez avoir à définir <code>HOME=/root</code> explicitement dans votre fichier d'environnement pour kubelet.</div><p>Voici les étapes recommandées pour configurer vos nœuds pour qu'ils utilisent un registre privé. Dans cet exemple, exécutez-les sur votre poste de travail :</p><ol><li>Exécutez <code>docker login [server]</code> pour chaque jeu de certificats que vous désirez utiliser. Ceci met à jour <code>$HOME/.docker/config.json</code>.</li><li>Examinez <code>$HOME/.docker/config.json</code> dans un éditeur pour vous assurer qu'il contient uniquement les certificats que vous désirez utiliser.</li><li>Récupérez la liste de vos nœuds, par exemple :<ul><li>si vous voulez connaître les noms : <code>nodes=$(kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}')</code></li><li>si vous voulez connaître les IPs : <code>nodes=$(kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}')</code></li></ul></li><li>Copiez votre fichier <code>.docker/config.json</code> local dans un des chemins de recherche ci-dessus.<ul><li>par exemple : <code>for n in $nodes; do scp ~/.docker/config.json root@$n:/var/lib/kubelet/config.json; done</code></li></ul></li></ol><p>Vérifiez en créant un pod utilisant une image privée, par ex. :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: test-image-privee-1
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: utilise-image-privee
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: $NOM_IMAGE_PRIVEE
</span></span></span><span style=display:flex><span><span style=color:#b44>      imagePullPolicy: Always
</span></span></span><span style=display:flex><span><span style=color:#b44>      command: [ &#34;echo&#34;, &#34;SUCCESS&#34; ]
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><pre tabindex=0><code>pod/test-image-privee-1 created
</code></pre><p>Si tout fonctionne, alors, après quelques instants, vous pouvez exécuter :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs test-image-privee-1
</span></span></code></pre></div><p>et voir que la commande affiche :</p><pre tabindex=0><code>SUCCESS
</code></pre><p>Si vous suspectez que la commande a échouée, vous pouvez exécuter :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pods/test-image-privee-1 | grep <span style=color:#b44>&#39;Failed&#39;</span>
</span></span></code></pre></div><p>En cas d'échec, l'affichage sera similaire à :</p><pre tabindex=0><code>  Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image &#34;user/privaterepo:v1&#34;: Error: image user/privaterepo:v1 not found
</code></pre><p>Vous devez vous assurer que tous les nœuds du cluster ont le même fichier <code>.docker/config.json</code>. Dans le cas contraire, les pods vont s'exécuter sur certains nœuds et échouer sur d'autres. Par exemple, si vous utilisez l'autoscaling des nœuds, alors chaque modèle d'instance doit inclure le fichier <code>.docker/config.json</code> ou monter un disque le contenant.</p><p>Tous les pods auront un accès en lecture aux images d'un registre privé dès que les clés du registre privé sont ajoutées au fichier <code>.docker/config.json</code>.</p><h3 id=images-pré-chargées>Images pré-chargées</h3><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si vous travaillez dans Google Kubernetes Engine, vous trouverez un <code>.dockercfg</code> sur chaque nœud avec les certificats pour Google Container Registry. Vous ne pourrez pas utiliser cette méthode.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Cette méthode est utilisable si vous avez le contrôle sur la configuration des nœuds. Elle ne marchera pas
correctement sur GCE, et sur tout autre fournisseur cloud qui fait du remplacement de nœud automatique.</div><p>Par défaut, kubelet essaiera de récupérer chaque image depuis le registre spécifié.
Cependant, si la propriété <code>imagePullPolicy</code> du conteneur est <code>IfNotPresent</code> ou <code>Never</code>,
alors une image locale est utilisée (respectivement de préférence ou exclusivement).</p><p>Si vous désirez vous reposer sur des images pré-chargées pour éviter l'authentification à un registre,
vous devez vous assurer que tous les nœuds du cluster ont les mêmes images pré-chargées.</p><p>Ceci peut être utilisé pour pré-charger certaines images pour gagner du temps, ou comme une alternative à l'authentification à un registre privé.</p><p>Tous les pods auront un accès en lecture aux images pré-chargées.</p><h3 id=spécifier-imagepullsecrets-dans-un-pod>Spécifier ImagePullSecrets dans un Pod</h3><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Cette méthode est actuellement la méthode recommandée pour Google Kubernetes Engine, GCE, et tout autre fournisseur de cloud où la création de nœuds est automatisée.</div><p>Kubernetes permet de spécifier des clés de registre dans un pod.</p><h4 id=créer-un-secret-avec-une-config-docker>Créer un Secret avec une config Docker</h4><p>Exécutez la commande suivante, en substituant les valeurs en majuscule :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>SERVEUR_REGISTRE_DOCKER --docker-username<span style=color:#666>=</span>UTILISATEUR_DOCKER --docker-password<span style=color:#666>=</span>MOT_DE_PASSE_DOCKER --docker-email<span style=color:#666>=</span>EMAIL_DOCKER
</span></span><span style=display:flex><span>secret/myregistrykey created.
</span></span></code></pre></div><p>Si vous avez déjà un fichier de clés Docker, alors, plutôt que d'utiliser la commande ci-dessus,
vous pouvez importer le fichier de clés comme un Secret Kubernetes.
<a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>Créer un Secret basé sur des clés Docker existantes</a> explique comment s'y prendre.
Ceci est particulièrement utile si vous utilisez plusieurs registres privés, <code>kubectl create secret docker-registry</code> créant un Secret ne fonctionnant qu'avec un seul registre privé.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Les pods peuvent référencer des pull secrets dans leur propre namespace uniquement,
ces étapes doivent donc être faites pour chaque namespace.</div><h4 id=se-référer-à-un-imagepullsecrets-dans-un-pod>Se référer à un imagePullSecrets dans un Pod</h4><p>Vous pouvez maintenant créer des pods qui référencent ce secret en ajoutant une section <code>imagePullSecrets</code>
dans la définition du pod.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Ceci doit être fait pour chaque pod utilisant un registre privé.</p><p>Cependant, la définition de ce champ peut être automatisé en définissant <code>imagePullSecrets</code>
dans une ressource <a href=/docs/user-guide/service-accounts>serviceAccount</a>.
Voyez <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Ajouter un ImagePullSecrets à un Service Account</a> pour des instructions détaillées.</p><p>Vous pouvez utiliser cette méthode en conjonction avec un <code>.docker/config.json</code> par nœud. Les certificats seront alors regroupés. Cette approche fonctionnera dans Google Kubernetes Engine.</p><h3 id=cas-d-utilisation>Cas d'utilisation</h3><p>Il y a plusieurs solutions pour configurer des registres privés. Voici quelques cas d'utilisation classiques et des propositions de solutions.</p><ol><li>Cluster exécutant uniquement des images non propriétaires (par ex. open-source). Inutile de protéger les images.<ul><li>Utilisez des images publiques dans le Hub Docker.<ul><li>Pas de configuration requise.</li><li>Dans GCE/Google Kubernetes Engine, un miroir local est automatiquement utilisé pour améliorer la vitesse et la disponibilité.</li></ul></li></ul></li><li>Cluster exécutant quelques images propriétaires qui doivent être protégées de l'extérieur de l'entreprise, mais visibles pour tous les utilisteurs du cluster.<ul><li>Utilisez un <a href=https://docs.docker.com/registry/>registre Docker</a> hébergé privé.<ul><li>Il peut être hébergé sur le <a href=https://hub.docker.com/signup>Hub Docker</a>, ou ailleurs.</li><li>Configurez manuellement .docker/config.json sur caque nœud comme décrit ci-dessus.</li></ul></li><li>Ou, utilisez un registre privé interne derrière votre pare-feu avec un accès ouvert en lecture.<ul><li>Aucune configuration Kubernetes n'est nécessaire.</li></ul></li><li>Ou, dans GCE/Google Kubernetes Engine, utilisez le Google Container Registry du projet.<ul><li>Cela fonctionnera mieux pour l'autoscaling du cluster que la configuration manuelle des nœuds.</li></ul></li><li>Ou, dans un cluster où le changement de la configuration des nœuds est difficile, utilisez <code>imagePullSecrets</code>.</li></ul></li><li>Cluster avec des images propriétaires, dont quelques-unes nécessitent un contrôle d'accès plus strict.<ul><li>Assurez-vous que <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>l'admission controller AlwaysPullImages</a> est actif. Autrement, tous les Pods ont potentiellement accès à toutes les images.</li><li>Déplacez les données sensibles dans une ressource "Secret", plutôt que de les intégrer dans une image.</li></ul></li><li>Un cluster multi-tenant où chaque <em>tenant</em> doit avoir son propre registre privé.<ul><li>Assurez-vous que <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>l'admission controller AlwaysPullImages</a> est actif. Autrement, tous les Pods ont potentiellement accès à toutes les images.</li><li>Utilisez un registre privé nécessitant l'autorisation.</li><li>Générez des certificats de registre pour chaque <em>tenant</em>, placez-les dans des secrets, et placez ces secrets dans les namespaces de chaque <em>tenant</em>.
pod - Le <em>tenant</em> ajoute ce secret dans les imagePullSecrets de chaque pod.</li></ul></li></ol><p>Si vous devez accéder à plusieurs registres, vous pouvez créer un secret pour chaque registre.
Kubelet va fusionner tous les <code>imagePullSecrets</code> dans un unique <code>.docker/config.json</code> virtuel.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a858027489648786a3b16264e451272b>3.2 - Classe d'exécution (Runtime Class)</h1><div class=lead>Classe d'execution conteneur pour Kubernetes</div><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>Cette page décrit la ressource RuntimeClass et le mécanisme de sélection d'exécution (runtime).</p><h2 id=runtime-class>Runtime Class</h2><p>La RuntimeClass est une fonctionnalité alpha permettant de sélectionner la configuration d'exécution du conteneur
à utiliser pour exécuter les conteneurs d'un pod.</p><h3 id=installation>Installation</h3><p>En tant que nouvelle fonctionnalité alpha, certaines étapes de configuration supplémentaires doivent
être suivies pour utiliser la RuntimeClass:</p><ol><li>Activer la fonctionnalité RuntimeClass (sur les apiservers et les kubelets, nécessite la version 1.12+)</li><li>Installer la RuntimeClass CRD</li><li>Configurer l'implémentation CRI sur les nœuds (dépend du runtime)</li><li>Créer les ressources RuntimeClass correspondantes</li></ol><h4 id=1-activer-runtimeclass-feature-gate-portail-de-fonctionnalité>1. Activer RuntimeClass feature gate (portail de fonctionnalité)</h4><p>Voir <a href=/docs/reference/command-line-tools-reference/feature-gates/>Feature Gates</a> pour une explication
sur l'activation des feature gates. La <code>RuntimeClass</code> feature gate doit être activée sur les API servers <em>et</em>
les kubelets.</p><h4 id=2-installer-la-crd-runtimeclass>2. Installer la CRD RuntimeClass</h4><p>La RuntimeClass <a href=/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a> (CRD) se trouve dans le répertoire addons du dépôt
Git Kubernetes: <a href=https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/runtimeclass/runtimeclass_crd.yaml>kubernetes/cluster/addons/runtimeclass/runtimeclass_crd.yaml</a></p><p>Installer la CRD avec <code>kubectl apply -f runtimeclass_crd.yaml</code>.</p><h4 id=3-configurer-l-implémentation-cri-sur-les-nœuds>3. Configurer l'implémentation CRI sur les nœuds</h4><p>Les configurations à sélectionner avec RuntimeClass dépendent de l'implémentation CRI. Consultez
la documentation correspondante pour votre implémentation CRI pour savoir comment le configurer.
Comme c'est une fonctionnalité alpha, tous les CRI ne prennent pas encore en charge plusieurs RuntimeClasses.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> La RuntimeClass suppose actuellement une configuration de nœud homogène sur l'ensemble du cluster
(ce qui signifie que tous les nœuds sont configurés de la même manière en ce qui concerne les environnements d'exécution de conteneur). Toute hétérogénéité (configuration variable) doit être
gérée indépendamment de RuntimeClass via des fonctions de planification (scheduling features) (voir <a href=/docs/concepts/configuration/assign-pod-node/>Affectation de pods sur les nœuds</a>).</div><p>Les configurations ont un nom <code>RuntimeHandler</code> correspondant , référencé par la RuntimeClass.
Le RuntimeHandler doit être un sous-domaine DNS valide selon la norme RFC 1123 (alphanumériques + <code>-</code> et <code>.</code> caractères).</p><h4 id=4-créer-les-ressources-runtimeclass-correspondantes>4. Créer les ressources RuntimeClass correspondantes</h4><p>Les configurations effectuées à l'étape 3 doivent chacune avoir un nom <code>RuntimeHandler</code> associé, qui
identifie la configuration. Pour chaque RuntimeHandler (et optionellement les handlers vides <code>""</code>),
créez un objet RuntimeClass correspondant.</p><p>La ressource RuntimeClass ne contient actuellement que 2 champs significatifs: le nom RuntimeClass
(<code>metadata.name</code>) et le RuntimeHandler (<code>spec.runtimeHandler</code>). la définition de l'objet ressemble à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1alpha1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># La RuntimeClass est définie dans le groupe d&#39;API node.k8s.io</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Le nom avec lequel la RuntimeClass sera référencée</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># La RuntimeClass est une ressource non cantonnées à un namespace</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeHandler</span>:<span style=color:#bbb> </span>myconfiguration <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Le nom de la configuration CRI correspondante</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Il est recommandé de limiter les opérations d'écriture sur la RuntimeClass (create/update/patch/delete) à
l'administrateur du cluster. C'est la configuration par défault. Voir <a href=/docs/reference/access-authn-authz/authorization/>Vue d'ensemble d'autorisation</a> pour plus de détails.</div><h3 id=usage>Usage</h3><p>Une fois que les RuntimeClasses sont configurées pour le cluster, leur utilisation est très simple.
Spécifiez <code>runtimeClassName</code> dans la spécficiation du pod. Par exemple:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Cela indiquera à la kubelet d'utiliser la RuntimeClass spécifiée pour exécuter ce pod. Si la
RuntimeClass n'existe pas, ou si la CRI ne peut pas exécuter le handler correspondant, le pod passera finalement à
<a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>l'état</a> <code>failed</code>. Recherchez
<a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>l'événement</a> correspondant pour un
message d'erreur.</p><p>Si aucun <code>runtimeClassName</code> n'est spécifié, le RuntimeHandler par défault sera utilisé, qui équivaut
au comportement lorsque la fonctionnalité RuntimeClass est désactivée.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-643212488f778acf04bebed65ba34441>3.3 - L'environnement du conteneur</h1><div class=lead>L'environnement du conteneur Kubernetes</div><p>Cette page décrit les ressources disponibles pour les conteneurs dans l'environnement de conteneur.</p><h2 id=l-environnement-du-conteneur>L'environnement du conteneur</h2><p>L’environnement Kubernetes conteneur fournit plusieurs ressources importantes aux conteneurs:</p><ul><li>Un système de fichier, qui est une combinaison d'une <a href=/docs/concepts/containers/images/>image</a> et un ou plusieurs <a href=/docs/concepts/storage/volumes/>volumes</a>.</li><li>Informations sur le conteneur lui-même.</li><li>Informations sur les autres objets du cluster.</li></ul><h3 id=informations-sur-le-conteneur>Informations sur le conteneur</h3><p>Le nom d'<em>hôte</em> d'un conteneur est le nom du pod dans lequel le conteneur est en cours d'exécution.
Il est disponible via la commande <code>hostname</code> ou
<a href=http://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a>
dans libc.</p><p>Le nom du pod et le namespace sont disponibles en tant que variables d'environnement via
<a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>l'API downward</a>.</p><p>Les variables d'environnement définies par l'utilisateur à partir de la définition de pod sont également disponibles pour le conteneur,
de même que toutes les variables d'environnement spécifiées de manière statique dans l'image Docker.</p><h3 id=informations-sur-le-cluster>Informations sur le cluster</h3><p>Une liste de tous les services en cours d'exécution lors de la création d'un conteneur est disponible pour ce conteneur en tant que variables d'environnement.
Ces variables d'environnement correspondent à la syntaxe des liens Docker.</p><p>Pour un service nommé <em>foo</em> qui correspond à un conteneur <em>bar</em>,
les variables suivantes sont définies:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;l<span>&#39;</span>hôte sur lequel le service est exécuté&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;le port sur lequel le service fonctionne&gt;
</span></span></code></pre></div><p>Les services ont des adresses IP dédiées et sont disponibles pour le conteneur avec le DNS,
si le <a href=http://releases.k8s.io/master/cluster/addons/dns/>module DNS</a> est activé. </p><h2 id=a-suivre>A suivre</h2><ul><li>En savoir plus sur <a href=/docs/concepts/containers/container-lifecycle-hooks/>les hooks du cycle de vie d'un conteneur</a>.</li><li>Acquérir une expérience pratique
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>en attachant les handlers aux événements du cycle de vie du conteneur</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e6941d969d81540208a3e78bc56f43bc>3.4 - Hooks de cycle de vie de conteneurs</h1><p>Cette page décrit comment un conteneur pris en charge par kubelet peut utiliser
le framework de Hooks de cycle de vie de conteneurs pour exécuter du code déclenché par des
événements durant son cycle de vie.</p><h2 id=aperçu>Aperçu</h2><p>De manière similaire à quantité de frameworks de langages de programmation qui ont des hooks
de cycle de vie de composants, comme Angular, Kubernetes fournit aux conteneurs
des hooks de cycle de vie.
Les hooks permettent à un conteneur d'être au courant d'événements durant son cycle de vie
et d'exécuter du code implémenté dans un handler lorsque le hook de cycle de vie correspondant
est exécuté.</p><h2 id=hooks-de-conteneurs>Hooks de conteneurs</h2><p>Il existe deux hooks exposés aux conteneurs :</p><p><code>PostStart</code></p><p>Ce hook s'exécute immédiatement après qu'un conteneur soit créé.
Cependant, il n'y a aucune garantie que le hook s'exécute avant l'ENTRYPOINT du conteneur.
Aucun paramètre n'est passé au handler.</p><p><code>PreStop</code></p><p>Ce hook est appelé immédiatement avant qu'un conteneur se termine, en raison d'un appel à l'API
ou d'un événement comme un échec de la liveness probe, un droit de préemption, un conflit de ressources ou autres.
Un appel au hook preStop échoue si le conteneur est déjà dans l'état terminé ou complété.
Il est bloquant, ce qui veut dire qu'il est synchrone, et doit donc se terminer avant que l'appel pour supprimer le conteneur soit envoyé.
Aucun paramètre n'est passé au handler.</p><p>Une description plus précise du comportement de l'arrêt peut être trouvé dans
<a href=/fr/docs/concepts/workloads/pods/pod/#arr%C3%AAt-de-pods>Arrêt de Pods</a>.</p><h3 id=implémentation-d-un-handler-de-hook>Implémentation d'un handler de hook</h3><p>Les conteneurs peuvent accéder à un hook en implémentant et enregistrant un handler pour ce hook.
Il existe deux types de handlers de hook pouvant être implémentés pour des conteneurs :</p><ul><li>Exec - Exécute une commande donnée, comme <code>pre-stop.sh</code>, dans les cgroups et namespaces du conteneur.
Les ressources consommées par la commande sont comptabilisées pour le conteneur.</li><li>HTTP - Exécute une requête HTTP sur un endpoint spécifique du conteneur.</li></ul><h3 id=exécution-d-un-handler-de-hook>Exécution d'un handler de hook</h3><p>Lorsqu'un hook de cycle de vie de conteneur est appelé,
le système de gestion de Kubernetes exécute le handler dans le conteneur enregistré
pour ce hook.</p><p>Les appels aux handlers de hook sont synchrones dans le contexte du pod contenant le conteneur.
Ceci veut dire que pour un hook <code>PostStart</code>,
bien que l'ENTRYPOINT du conteneur et le hook soient lancés de manière asynchrone, si le hook prend trop de temps à s'exécuter ou se bloque,
le conteneur ne peut pas atteindre l'état <code>running</code>.</p><p>Le comportement est similaire pour un hook <code>PreStop</code>.
Si le hook se bloque durant l'exécution,
la phase du Pod reste en état <code>Terminating</code> et le hook est tué après <code>terminationGracePeriodSeconds</code> que le pod se termine.
Si un hook <code>PostStart</code> ou <code>PreStop</code> échoue,
le conteneur est tué.</p><p>Les utilisateurs doivent rendre leurs handlers de hook aussi légers que possible.
Il existe des cas, cependant, où de longues commandes ont un intérêt,
comme pour enregistrer un état avant de stopper un conteneur.</p><h3 id=garanties-de-déclenchement-d-un-hook>Garanties de déclenchement d'un hook</h3><p>La politique de déclenchement d'un hook est <em>au moins une fois</em>,
ce qui veut dire qu'un hook peut être déclenché plus d'une fois pour un événement donné,
comme <code>PostStart</code> ou <code>PreStop</code>.
Il appartient à l'implémentation du hook de prendre en compte correctement ce comportement.</p><p>En général, un seul déclenchement est fait.
Si, par exemple, un récepteur de hook HTTP est hors service et ne peut pas
prendre en charge du trafic, il n'y a aucune tentative de renvoi.
Dans quelques rares cas, cependant, un double envoi peut se produire.
Par exemple, si kubelet redémarre au milieu d'un déclenchement de hook,
le hook pourrait être re-déclenché après que kubelet redémarre.</p><h3 id=débugger-des-handlers-de-hook>Débugger des handlers de hook</h3><p>Les logs pour un handler de hook ne sont pas exposés dans les événements du Pod.
Si un handler échoue pour une raison particulière, il envoie un événement.
Pour <code>PostStart</code>, c'est l'événement <code>FailedPostStartHook</code>
et pour <code>PreStop</code>, c'est l'événement <code>FailedPreStopHook</code>.
Vous pouvez voir ces événements en exécutant <code>kubectl describe pod &lt;pod_name></code>.
Voici un exemple d'affichage d'événements lors de l'exécution de cette commande :</p><pre tabindex=0><code>Events:
  FirstSeen  LastSeen  Count  From                                                   SubObjectPath          Type      Reason               Message
  ---------  --------  -----  ----                                                   -------------          --------  ------               -------
  1m         1m        1      {default-scheduler }                                                          Normal    Scheduled            Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulling              pulling image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Created              Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined]
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulled               Successfully pulled image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Started              Started container with docker id 5c6a256a2567
  38s        38s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1
  37s        37s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1
  38s        37s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}                         Warning   FailedSync           Error syncing pod, skipping: failed to &#34;StartContainer&#34; for &#34;main&#34; with RunContainerError: &#34;PostStart handler: Error executing in Docker Container: 1&#34;
  1m         22s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Warning   FailedPostStartHook
</code></pre><h2 id=a-suivre>A suivre</h2><ul><li>En savoir plus sur l'<a href=/fr/docs/concepts/containers/container-environment/>Environnement d'un conteneur</a>.</li><li>Entraînez-vous à
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>attacher des handlers de conteneurs à des événements de cycle de vie</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d52aadda80edd9f8c514cfe2321363c2>4 - Workloads</h1><div class=lead>Comprendre les Pods, le plus petit objet déployable sur Kubernetes, et les abstractions de haut niveaux vous permettant de les lancer.</div><p>Un workload (charge de travail) est une application fonctionnant sur Kubernetes. Que votre workload soit un composant unique ou un agrégat de composants, sur Kubernetes celui-ci fonctionnera dans une série de pods. Dans Kubernetes, un Pod represente un ensemble de conteneur (containers) en fonctionnement sur votre cluster.</p><p>Les pods Kubernetes ont un cycle de vie définit (defined lifecycle). Par exemple, quand un pod est en fonction sur votre cluster et qu’une panne critique survient sur le noeud (node) où se situe ce pod, tous les pods du noeud seront en échec. Kubernetes traite ce niveau d’échec comme un état final :
Vous devez créer un nouveau Pod pour retrouver l’état initial même si le noeud redevient sain.</p><p>Cependant, pour vous simplifier la vie, vous n’avez pas a gérer chaque Pod directement. Vous pouvez utiliser une ressource workload qui gère votre groupe de pods à votre place. Ces ressources configurent des controleurs (controllers) qui s’assurent que le bon nombre et le bon type de pod soit en fonction pour égaler l’état que vous avez spécifié.</p><p>Kubernetes fournit plusieurs ressources workload pré-faites :</p><ul><li><a href=/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a> et <a href=/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>
(qui remplacent l’ancienne ressource <a class=glossary-tooltip title='A (deprecated) API object that manages a replicated application.' data-toggle=tooltip data-placement=top href='/fr/docs/reference/glossary/?all=true#term-replication-controller' target=_blank aria-label=ReplicationController>ReplicationController</a>)).
Le <code>Deployment</code> (déploiement) est une bonne approche pour manager une application stateless sur votre cluster, tous les <code>Pods</code> d’un <code>Deployment</code> sont interchangeables et peuvent être remplacés si besoin.</li><li>Le <a href=/docs/concepts/workloads/controllers/statefulset/><code>StatefulSet</code></a> vous permet de lancer un ou plusieurs Pods en relation qui garde plus ou moins la trace de leurs état.
Par exemple si votre workload enregistre des données de façon persistente, vous pouvez lancer un <code>StatefulSet</code> qui fera le lien entre les <code>Pods</code> et un volume persistent (<a href=/docs/concepts/storage/persistent-volumes/><code>PersistentVolume</code></a>).
Votre code, présent dans les <code>Pods</code> du <code>StatefulSet</code>, peut répliquer des données dans les autres <code>Pods</code> qui sont dans le même <code>StatefulSet</code>,
pour améliorer la résilience global.</li><li>Le <a href=/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a> permet de définir les <code>Pods</code> qui effectuent des actions sur le noeud local.
Ceux-ci peuvent être fondamental aux opérations de votre cluster, comme un outil d’aide réseau, ou peuvent faire part d’un module complémentaire (add-on).
Pour chaque nouveau noeud ajouté au cluster, le controle plane organise l'ajout d'un <code>Pod</code> pour ce <code>DaemonSet</code> sur le nouveau noeud.</li><li>Les <a href=/docs/concepts/workloads/controllers/job/><code>Job</code></a> et <a href=/docs/concepts/workloads/controllers/cron-jobs/><code>CronJob</code></a> sont des taches lancées jusqu’à accomplissement puis s’arrêtent. Les <code>Jobs</code> réprésentent une tâche ponctuelle, les <code>CronJob</code> sont des tâches récurrentes planifiés.</li></ul><p>Dans l’écosystème étendu de Kubernetes, vous pouvez trouver des ressources workload de fournisseurs tiers qui offrent des fonctionnalités supplémentaires.
L’utilisation d’un <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/><code>CustomResourceDefinition</code></a> permet d’ajouter une ressource workload d’un fournisseur tiers si vous souhaitez rajouter une fonctionnalité ou un comportement spécifique qui ne fait pas partie du noyau de Kubernetes.
Par exemple, si vous voulez lancer un groupe de <code>Pods</code> pour votre application mais que vous devez arrêter leurs fonctionnement tant qu’ils ne sont pas tous disponibles, alors vous pouvez implémenter ou installer une extension qui permet cette fonctionnalité.</p><h2 id=a-suivre>A suivre</h2><p>Vous pouvez continuer la lecture des ressources, vous pouvez aussi apprendre à connaitre les taches qui leurs sont liées :</p><ul><li>Lancer une <a href=/docs/tasks/run-application/run-stateless-application-deployment/>application stateless en utilisant un <code>Deployment</code></a>.</li><li>Lancer une application statefull, soit comme <a href=/docs/tasks/run-application/run-single-instance-stateful-application/>instance unique</a>
ou alors comme un <a href=/docs/tasks/run-application/run-replicated-stateful-application/>ensemble répliqué</a>.</li><li>Lancer une <a href=/docs/tasks/job/automated-tasks-with-cron-jobs/>tâche automatisée avec un <code>CronJob</code></a>.</li></ul><p>Pour en apprendre plus sur les méchanismes de Kubernetes, de séparation du code et de la configuration,
allez voir <a href=/docs/concepts/configuration/>Configuration</a>.</p><p>Il y a deux concepts supportés qui fournissent un contexte sur le sujet : comment Kubernetes gère les pods pour les applications :</p><ul><li>Le <a href=/docs/concepts/workloads/controllers/garbage-collection/>ramasse-miettes</a>, fait le ménage dans votre cluster après qu’une de <em>vos ressource</em> soit supprimé.</li><li>Le <a href=/docs/concepts/workloads/controllers/ttlafterfinished/>temps de vie d’un controlleur éteint</a> supprime les Jobs une fois qu’un temps définit soit passé après son accomplissement.</li></ul><p>Une fois que votre application est lancée, vous souhaitez peut etre la rendre disponible sur internet comme un <a href=/docs/concepts/services-networking/service/>Service</a> ou comme une application web uniquement en utilsant un <a href=/docs/concepts/services-networking/ingress>Ingress</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4d68b0ccf9c683e6368ffdcc40c838d4>4.1 - Pods</h1></div><div class=td-content><h1 id=pg-37afa6c66c74400d1579f10faf55e5b6>4.1.1 - Aperçu du Pod</h1><div class=lead>Pod Concept Kubernetes</div><p>Cette page fournit un aperçu du <code>Pod</code>, l'objet déployable le plus petit dans le modèle d'objets Kubernetes.</p><h2 id=comprendre-les-pods>Comprendre les Pods</h2><p>Un <em>Pod</em> est l'unité d'exécution de base d'une application Kubernetes--l'unité la plus petite et la plus simple dans le modèle d'objets de Kubernetes--que vous créez ou déployez. Un Pod représente des process en cours d'exécution dans votre <a class=glossary-tooltip title='Un ensemble de machines, appelées des "nœuds", qui exécutent des applications conteneurisées gérées par Kubernetes.' data-toggle=tooltip data-placement=top href='/fr/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=cluster>cluster</a>.</p><p>Un Pod encapsule un conteneur applicatif (ou, dans certains cas, plusieurs conteneurs), des ressources de stockage, une identité réseau (adresse IP) unique, ainsi que des options qui contrôlent comment le ou les conteneurs doivent s'exécuter. Un Pod représente une unité de déploiement : <em>une instance unique d'une application dans Kubernetes</em>, qui peut consister soit en un unique <a class=glossary-tooltip title='Une image exécutable légère et portable qui contient le logiciel et toutes ses dépendances.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=container>container</a> soit en un petit nombre de conteneurs qui sont étroitement liés et qui partagent des ressources.</p><blockquote><p><a href=https://www.docker.com>Docker</a> est le runtime de conteneurs le plus courant utilisé dans un Pod Kubernetes, mais les Pods prennent également en charge d'autres <a href=/docs/setup/production-environment/container-runtimes/>runtimes de conteneurs</a>.</p></blockquote><p>Les Pods dans un cluster Kubernetes peuvent être utilisés de deux manières différentes :</p><ul><li><strong>les Pods exécutant un conteneur unique</strong>. Le modèle "un-conteneur-par-Pod" est le cas d'utilisation Kubernetes le plus courant ; dans ce cas, vous pouvez voir un Pod comme un wrapper autour d'un conteneur unique, et Kubernetes gère les Pods plutôt que directement les conteneurs.</li><li><strong>les Pods exécutant plusieurs conteneurs devant travailler ensemble</strong>. Un Pod peut encapsuler une application composée de plusieurs conteneurs co-localisés qui sont étroitement liés et qui doivent partager des ressources. Ces conteneurs co-localisés pourraient former une unique unité de service cohésive--un conteneur servant des fichiers d'un volume partagé au public, alors qu'un conteneur "sidecar" séparé rafraîchit ou met à jour ces fichiers. Le Pod enveloppe ensemble ces conteneurs et ressources de stockage en une entité maniable de base.</li></ul><p>Chaque Pod est destiné à exécuter une instance unique d'une application donnée. Si vous désirez mettre à l'échelle votre application horizontalement, (pour fournir plus de ressources au global en exécutant plus d'instances), vous devez utiliser plusieurs Pods, un pour chaque instance. Dans Kubernetes, on parle typiquement de <em>réplication</em>. Des Pods répliqués sont en général créés et gérés en tant que groupe par une ressource de charge de travail et son <a class=glossary-tooltip title="Boucle de contrôle surveillant l'état partagé du cluster à travers l'apiserver et effectuant des changements en essayant de déplacer l'état actuel vers l'état désiré." data-toggle=tooltip data-placement=top href=/docs/admin/kube-controller-manager/ target=_blank aria-label=_contrôleur_>_contrôleur_</a>. Voir <a href=#pods-et-controleurs>Pods et contrôleurs</a> pour plus d'informations.</p><h3 id=comment-les-pods-gèrent-plusieurs-conteneurs>Comment les Pods gèrent plusieurs conteneurs</h3><p>Les Pods sont conçus pour supporter plusieurs process coopérants (sous forme de conteneurs) qui forment une unité de service cohésive. Les conteneurs d'un même Pod sont automatiquement co-localisés et co-programmés sur la même machine physique ou virtuelle dans le cluster. Ces conteneurs peuvent partager des ressources et dépendances, communiquer entre eux, et coordonner quand et comment ils sont arrêtés.</p><p>Notez que grouper plusieurs conteneurs co-localisés et co-gérés dans un unique Pod est un cas d'utilisation relativement avancé. Vous devez utiliser ce pattern seulement dans des instances spécifiques dans lesquelles vos conteneurs sont étroitement liés. Par exemple, vous pourriez avoir un conteneur qui agit comme un serveur web pour des fichiers contenus dans un volume partagé, et un conteneur "sidecar" séparé qui met à jour ces fichiers depuis une source externe, comme dans le diagramme suivant :</p><figure><img src=/images/docs/pod.svg alt="example pod diagram" width=50%></figure><p>Certains Pods ont des <a class=glossary-tooltip title="Un ou plusieurs conteneurs d'initialisation qui doivent être exécutés jusqu'à la fin, avant l'exécution de tout conteneur d'application." data-toggle=tooltip data-placement=top href='/fr/docs/reference/glossary/?all=true#term-init-container' target=_blank aria-label='init containers'>init containers</a> en plus d'<a class=glossary-tooltip title="Un conteneur utilisé pour exécuter une partie d'une charge de travail, comparable à un init conteneur." data-toggle=tooltip data-placement=top href='/fr/docs/reference/glossary/?all=true#term-app-container' target=_blank aria-label='app containers'>app containers</a>. Les Init containers s'exécutent et terminent avant que les conteneurs d'application soient démarrés.</p><p>Les Pods fournissent deux types de ressources partagées pour leurs conteneurs : <em>réseau</em> et <em>stockage</em>.</p><h4 id=réseau>Réseau</h4><p>Chaque Pod se voit assigner une adresse IP unique pour chaque famille d'adresses. Tous les conteneurs d'un Pod partagent le même namespace réseau, y compris l'adresse IP et les ports réseau. Les conteneurs <em>à l'intérieur d'un Pod</em> peuvent communiquer entre eux en utilisant <code>localhost</code>. Lorsque les conteneurs dans un Pod communiquent avec des entités <em>en dehors du Pod</em>, ils doivent coordonner comment ils utilisent les ressources réseau partagées (comme les ports).</p><h4 id=stockage>Stockage</h4><p>Un Pod peut spécifier un jeu de <a class=glossary-tooltip title="Un répertoire contenant des données, accessible aux conteneurs d'un pod." data-toggle=tooltip data-placement=top href=/fr/docs/concepts/storage/volumes/ target=_blank aria-label=volumes>volumes</a> de stockage partagés. Tous les conteneurs dans le Pod peuvent accéder aux volumes partagés, permettant à ces conteneurs de partager des données. Les volumes permettent aussi les données persistantes d'un Pod de survivre au cas où un des conteneurs doit être redémarré. Voir <a href=/docs/concepts/storage/volumes/>Volumes</a> pour plus d'informations sur la façon dont Kubernetes implémente le stockage partagé dans un Pod.</p><h2 id=travailler-avec-des-pods>Travailler avec des Pods</h2><p>Vous aurez rarement à créer directement des Pods individuels dans Kubernetes--même des Pods à un seul conteneur. Ceci est dû au fait que les Pods sont conçus comme des entités relativement éphémères et jetables. Lorsqu'un Pod est créé (directement par vous ou indirectement par un <a class=glossary-tooltip title="Boucle de contrôle surveillant l'état partagé du cluster à travers l'apiserver et effectuant des changements en essayant de déplacer l'état actuel vers l'état désiré." data-toggle=tooltip data-placement=top href=/docs/admin/kube-controller-manager/ target=_blank aria-label=_contrôleur_>_contrôleur_</a>), il est programmé pour s'exécuter sur un <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a> dans votre cluster. Le Pod reste sur ce nœud jusqu'à ce que le process se termine, l'objet pod soit supprimé, le pod soit <em>expulsé</em> par manque de ressources, ou le nœud soit en échec.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Redémarrer un conteneur dans un Pod ne doit pas être confondu avec redémarrer un Pod. Un Pod n'est pas un process, mais un environnement pour exécuter un conteneur. Un Pod persiste jusqu'à ce qu'il soit supprimé.</div><p>Les Pods ne se guérissent pas par eux-mêmes. Si un Pod est programmé sur un Nœud qui échoue, ou si l'opération de programmation elle-même échoue, le Pod est supprimé ; de plus, un Pod ne survivra pas à une expulsion due à un manque de ressources ou une mise en maintenance du Nœud. Kubernetes utilise une abstraction de plus haut niveau, appelée un <em>contrôleur</em>, qui s'occupe de gérer les instances de Pods relativement jetables. Ainsi, même s'il est possible d'utiliser des Pods directement, il est beaucoup plus courant dans Kubernetes de gérer vos Pods en utilisant un contrôleur.</p><h3 id=pods-et-contrôleurs>Pods et contrôleurs</h3><p>Vous pouvez utiliser des ressources de charges de travail pour créer et gérer plusieurs Pods pour vous. Un contrôleur pour la ressource gère la réplication,
le plan de déploiement et la guérison automatique en cas de problèmes du Pod. Par exemple, si un noeud est en échec, un contrôleur note que les Pods de ce noeud
ont arrêté de fonctionner et créent des Pods pour les remplacer. L'ordonnanceur place le Pod de remplacement sur un noeud en fonctionnement.</p><p>Voici quelques exemples de ressources de charges de travail qui gèrent un ou plusieurs Pods :</p><ul><li><a class=glossary-tooltip title='Objet API gérant une application répliquée.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a></li><li><a class=glossary-tooltip title="Gère le déploiement et la mise à l'échelle d'un ensemble de Pods, avec un stockage durable et des identifiants persistants pour chaque Pod." data-toggle=tooltip data-placement=top href=/fr/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a></li><li><a class=glossary-tooltip title="S'assure qu'une copie d'un Pod s'exécute sur un ensemble de nœuds d'un cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a></li></ul><h2 id=templates-de-pod>Templates de Pod</h2><p>Les Templates de Pod sont des spécifications pour créer des Pods, et sont inclus dans les ressources de charges de travail comme
les <a href=/fr/docs/concepts/workloads/controllers/deployment/>Deployments</a>, les <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/>Jobs</a> et
les <a href=/docs/concepts/workloads/controllers/daemonset/>DaemonSets</a>.</p><p>Chaque contrôleur pour une ressource de charges de travail utilise le template de pod à l'intérieur de l'objet pour créer les Pods. Le template de pod fait partie de l'état désiré de la ressource de charges de travail que vous avez utilisé pour exécuter votre application.</p><p>L'exemple ci-dessous est un manifest pour un Job simple avec un <code>template</code> qui démarre un conteneur. Le conteneur dans ce Pod affiche un message puis se met en pause.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Ceci est un template de pod</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo &#34;Hello, Kubernetes!&#34; &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Le template de pod se termine ici</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Modifier le template de pod ou changer pour un nouvau template de pod n'a pas d'effet sur les pods déjà existants. Les Pods ne reçoivent pas une mise à jour
du template directement ; au lieu de cela, un nouveau Pod est créé pour correspondre au nouveau template de pod.</p><p>Par exemple, un contrôleur de Deployment s'assure que les Pods en cours d'exécution correspondent au template de pod en cours. Si le template est mis à jour,
le contrôleur doit supprimer les pods existants et créer de nouveaux Pods avec le nouveau template. Chaque contrôleur de charges de travail implémente ses propres
règles pour gérer les changements du template de Pod.</p><p>Sur les noeuds, le <a class=glossary-tooltip title="Un agent qui s'exécute sur chaque nœud du cluster. Il s'assure que les conteneurs fonctionnent dans un pod." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> n'observe ou ne gère pas directement les détails concernant les templates de pods et leurs mises à jours ; ces détails sont abstraits. Cette abstraction et cette séparation des préoccupations simplifie la sémantique du système, et rend possible l'extension du comportement du cluster sans changer le code existant.</p><h2 id=a-suivre>A suivre</h2><ul><li>En savoir plus sur les <a href=/docs/concepts/workloads/pods/pod/>Pods</a></li><li><a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System Toolkit: Patterns for Composite Containers</a> explique les dispositions courantes pour des Pods avec plusieurs conteneurs</li><li>En savoir plus sur le comportement des Pods :<ul><li><a href=/docs/concepts/workloads/pods/pod/#termination-of-pods>Terminaison d'un Pod</a></li><li><a href=/docs/concepts/workloads/pods/pod-lifecycle/>Cycle de vie d'un Pod</a></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-99cce294fe789317ee684a6e1f07f20f>4.1.2 - Pods</h1><p>Les <em>Pods</em> sont les plus petites unités informatiques déployables
qui peuvent être créées et gérées dans Kubernetes.</p><h2 id=qu-est-ce-qu-un-pod>Qu'est-ce qu'un pod ?</h2><p>Un <em>pod</em> (terme anglo-saxon décrivant un groupe de baleines ou une gousse de pois) est un groupe d'un ou plusieurs conteneurs
(comme des conteneurs Docker), ayant du stockage/réseau partagé, et une spécification
sur la manière d'exécuter ces conteneurs. Les éléments d'un pod sont toujours co-localisés
et co-ordonnancés, et s'exécutent dans un contexte partagé. Un pod modélise un
"hôte logique" spécifique à une application - il contient un ou plusieurs conteneurs applicatifs
qui sont étroitement liés — dans un monde pré-conteneurs, être exécuté sur la même machine
physique ou virtuelle signifierait être exécuté sur le même hôte logique.</p><p>Bien que Kubernetes prenne en charge d'autres runtimes de conteneurs que Docker, Docker est le runtime
le plus connu, et cela aide à décrire des pods en termes Docker.</p><p>Le contexte partagé d'un pod est un ensemble de namespaces Linux, cgroups, et
potentiellement d'autres facettes d'isolation - les mêmes choses qui isolent un conteneur Docker.
Dans le contexte d'un pod, les applications individuelles peuvent se voir appliquer d'autres sous-isolations.</p><p>Les conteneurs d'un pod partagent une adresse IP et un espace de ports, et peuvent communiquer via <code>localhost</code>.
Ils peuvent aussi communiquer entre eux en utilisant des communications inter-process standard comme
les sémaphores SystemV ou la mémoire partagée POSIX. Les conteneurs appartenant à des pods distincts ont des adresses IP
distinctes et ne peuvent pas communiquer par IPC sans <a href=/docs/concepts/policy/pod-security-policy/>configuration spécifique</a>. Ces conteneurs communiquent en général entre eux via les adresses IP de leurs pods.</p><p>Les applications à l'intérieur d'un pod ont aussi accès à des volumes partagés,
qui sont définis dans le cadre d'un pod et sont mis à disposition pour être montés
dans le système de fichiers de chaque application.</p><p>En terme de concepts <a href=https://www.docker.com/>Docker</a>, un pod est modélisé par un groupe de conteneurs Docker
ayant des namespaces et des <a href=/docs/concepts/storage/volumes/>volumes</a> partagés.</p><p>Tout comme des conteneurs applicatifs individuels, les pods sont considérés comme des entités relativement éphémères (plutôt que durables).
Comme discuté dans <a href=/docs/concepts/workloads/pods/pod-lifecycle/>Cycle de vie d'un pod</a>, les pods sont créés, des ID uniques (UID) leurs sont assignés,
et ils sont ordonnancés sur des nœuds où il restent jusqu'à leur arrêt (selon la politique de redémarrage) ou suppression.
Si un nœud meurt, les pods ordonnancés sur ce nœud sont programmés pour être terminés, après un délai d'attente. Un pod donné (défini par un UID)
n'est pas "re-ordonnancé" sur un nouveau nœud ; par contre, il peut être remplacé par un pod identique,
ayant le même nom si désiré, mais avec un nouvel UID (voir <a href=/docs/concepts/workloads/controllers/replicationcontroller/>replication
controller</a> pour plus de détails).</p><p>Lorsque quelque chose, comme un volume, a le même cycle de vie qu'un pod, il existe aussi longtemps
que le pod (avec l'UID donné) existe. Si ce pod est supprimé pour une quelconque raison, même si un remplaçant
identique est recréé, la chose liée (par ex. le volume) est aussi détruite et créée à nouveau.</p><figure><img src=/images/docs/pod.svg width=50%><figcaption><h4>pod diagram</h4></figcaption></figure><p><em>Un pod multi-conteneurs contenant un extracteur de fichiers et un serveur web
utilisant un volume persistant comme espace de stockage partagé entre les conteneurs.</em></p><h2 id=intérêts-des-pods>Intérêts des pods</h2><h3 id=gestion>Gestion</h3><p>Les pods fournissent une unité de service cohérente afin d'avoir un modèle coopératif entre plusieurs processus.
Ils simplifient le déploiement et la gestion d'applications
en fournissant une abstraction de plus haut niveau que l'ensemble des applications les constituant.
Les pods servent d'unité de déploiement, de mise à l'échelle horizontale, et de réplication.
La co-localisation (co-ordonnancement), la fin partagée (par ex. l'arrêt),
la réplication coordonnée, le partage de ressources et la gestion des dépendances sont
traités automatiquement pour les conteneurs dans un pod.</p><h3 id=partage-de-ressources-et-communication>Partage de ressources et communication</h3><p>Les pods permettent le partage de ressources et la communication entre ses constituants.</p><p>Les applications dans un pod utilisent toutes le même réseau (même adresse IP et espace de ports)
et peuvent donc "se trouver" entre elles et communiquer en utilisant <code>localhost</code>.
À cause de cela, les applications dans un pod doivent coordonner leurs usages de ports.
Chaque pod a une adresse IP dans un réseau plat partagé ayant un accès complet
aux autres hôtes et pods à travers le réseau.</p><p>Le nom d'hôte est défini avec le nom du pod pour les conteneurs applicatifs à l'intérieur du pod.
<a href=/docs/concepts/cluster-administration/networking/>Plus de détails sur le réseau</a>.</p><p>En plus de définir les conteneurs applicatifs s'exécutant dans le pod, le pod spécifie
un ensemble de volumes de stockage partagés. Les volumes permettent aux données de survivre
aux redémarrages de conteneurs et d'être partagés entre les applications d'un même pod.</p><h2 id=cas-d-utilisation-de-pods>Cas d'utilisation de pods</h2><p>Des pods peuvent être utilisés pour héberger verticalement des piles applicatives intégrées (par ex. LAMP),
mais leur principal intérêt est la mise en place de programmes auxiliaires co-localisés et co-gérés, comme :</p><ul><li>systèmes de gestion de contenu, chargeurs de fichiers et de données, gestionnaires de cache local, etc.</li><li>sauvegarde de log et checkpoint, compression, rotation, prise d'instantanés, etc.</li><li>data change watchers, log tailers, adaptateurs de logs et monitoring, éditeurs d'événements, etc.</li><li>proxies, bridges et adaptateurs</li><li>contrôleurs, gestionnaires, configurateurs et gestionnaires de mise à jour</li></ul><p>Des pods individuels ne sont pas destinés à exécuter plusieurs instances de la même application, en général.</p><p>Pour une explication plus détaillée, voir <a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System ToolKit: Patterns for
Composite
Containers</a>.</p><h2 id=alternatives-envisagées>Alternatives envisagées</h2><p><em>Pourquoi ne pas simplement exécuter plusieurs programmes dans un unique conteneur (Docker) ?</em></p><ol><li>Transparence. Rendre les conteneurs à l'intérieur du pod visibles par l'infrastucture
permet à l'infrastucture de fournir des services à ces conteneurs,
comme la gestion des processus et le monitoring des ressources. Ceci
apporte un certain nombre de facilités aux utilisateurs.</li><li>Découpler les dépendances logicielles. Les conteneurs individuels peuvent être
versionnés, reconstruits et redéployés de manière indépendante. Kubernetes pourrait
même un jour prendre en charge la mise à jour à chaud de conteneurs individuels.</li><li>Facilité d'utilisation. Les utilisateurs n'ont pas besoin d'exécuter leur propre gestionnaire
de processus, de se soucier de la propagation de signaux et de codes de sortie, etc.</li><li>Efficacité. L'infrastructure prenant plus de responsabilités, les conteneurs peuvent être plus légers.</li></ol><p><em>Pourquoi ne pas prendre en charge le co-ordonnancement de conteneurs basé sur les affinités ?</em></p><p>Cette approche pourrait fournir la co-localisation, mais ne fournirait pas la plupart
des bénéfices des pods, comme le partage de ressources, IPC, la garantie d'une fin partagée et une gestion simplifiée.</p><h2 id=durabilité-des-pods-ou-manque-de>Durabilité des pods (ou manque de)</h2><p>Les pods ne doivent pas être considérés comme des entités durables. Ils ne survivent pas à des erreurs d'ordonnancement, à un nœud en échec
ou à d'autres expulsions, suite à un manque de ressources ou une mise en maintenance d'un nœud.</p><p>En général, les utilisateurs n'ont pas à créer directement des pods. Ils doivent presque toujours
utiliser des contrôleurs, même pour des singletons, comme par exemple des <a href=/docs/concepts/workloads/controllers/deployment/>Deployments</a>.
Les contrôleurs fournissent l'auto-guérison à l'échelle du cluster, ainsi que la réplication et la gestion des déploiements (rollout).
Les contrôleurs comme <a href=/docs/concepts/workloads/controllers/statefulset.md>StatefulSet</a>
peuvent aussi prendre en charge des pods avec état (stateful).</p><p>L'utilisation d'APIs collectives comme principale primitive exposée à l'utilisateur est courante dans les systèmes d'ordonnancement de clusters, comme <a href=https://research.google.com/pubs/pub43438.html>Borg</a>, <a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a>, <a href=http://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a>, et <a href=http://www.slideshare.net/Docker/aravindnarayanan-facebook140613153626phpapp02-37588997>Tupperware</a>.</p><p>Un Pod est exposé en tant que primitive afin de faciliter :</p><ul><li>la connexion du scheduler et du contrôleur</li><li>la possibilité d'opérations au niveau du pod sans besoin de passer par des APIs au niveau du contrôleur</li><li>le découplage du cycle de fin d'un pod de celui d'un contrôleur, comme pour l'amorçage (bootstrapping)</li><li>le découplage des contrôleurs et des services — le contrôleur d'endpoints examine uniquement des pods</li><li>la composition claire des fonctionnalités niveau Kubelet et des fonctionnalités niveau cluster — concrètement, Kubelet est le "contrôleur de pods"</li><li>les applications hautement disponibles, qui attendront que les pods soient remplacés avant leur arrêt et au moins avant leur suppression, comme dans les cas d'éviction programmée ou de pré-chargement d'image.</li></ul><h2 id=arrêt-de-pods>Arrêt de pods</h2><p>Les pods représentant des processus s'exécutant sur des nœuds d'un cluster, il est important de permettre à ces processus de se terminer proprement
lorsqu'ils ne sont plus nécessaires (plutôt que d'être violemment tués avec un signal KILL et n'avoir aucune chance de libérer ses ressources). Les
utilisateurs doivent pouvoir demander une suppression et savoir quand les processus se terminent, mais aussi être capable de s'assurer que la suppression
est réellement effective. Lorsqu'un utilisateur demande la suppression d'un pod, le système enregistre le délai de grâce prévu avant que le pod puisse
être tué de force, et qu'un signal TERM soit envoyé au processus principal de chaque conteneur. Une fois la période de grâce expirée, le signal KILL
est envoyé à ces processus, et le pod est alors supprimé de l'API server. Si Kubelet ou le gestionnaire de conteneurs est redémarré lors de l'attente de l'arrêt des processus, l'arrêt sera réessayé avec la période de grâce complète.</p><p>Un exemple de déroulement :</p><ol><li>Un utilisateur envoie une commande pour supprimer un Pod, avec une période de grâce par défaut (30s)</li><li>Le Pod dans l'API server est mis à jour avec le temps au delà duquel le Pod est considéré "mort" ainsi que la période de grâce.</li><li>Le Pod est affiché comme "Terminating" dans les listes des commandes client</li><li>(en même temps que 3) Lorsque Kubelet voit qu'un Pod a été marqué "Terminating", le temps ayant été mis en 2, il commence le processus de suppression du pod.<ol><li>Si un des conteneurs du Pod a défini un <a href=/fr/docs/concepts/containers/container-lifecycle-hooks/#hook-details>preStop hook</a>, il est exécuté à l'intérieur du conteneur. Si le <code>preStop</code> hook est toujours en cours d'exécution à la fin de la période de grâce, l'étape 2 est invoquée avec une courte (2 secondes) période de grâce supplémentaire une seule fois. Vous devez modifier <code>terminationGracePeriodSeconds</code> si le hook <code>preStop</code> a besoin de plus de temps pour se terminer.</li><li>Le signal TERM est envoyé aux conteneurs. Notez que tous les conteneurs du Pod ne recevront pas le signal TERM en même temps et il peut être nécessaire de définir des <code>preStop</code> hook si l'ordre d'arrêt est important.</li></ol></li><li>(en même temps que 3) Le Pod est supprimé des listes d'endpoints des services, et n'est plus considéré comme faisant partie des pods en cours d'exécution pour les contrôleurs de réplication. Les Pods s'arrêtant lentement ne peuvent pas continuer à servir du trafic, les load balancers (comme le service proxy) les supprimant de leurs rotations.</li><li>Lorsque la période de grâce expire, les processus s'exécutant toujours dans le Pod sont tués avec SIGKILL.</li><li>Kubelet va supprimer le Pod dans l'API server en indiquant une période de grâce de 0 (suppression immédiate). Le Pod disparaît de l'API et n'est plus visible par le client.</li></ol><p>Par défaut, toutes les suppressions ont une période de grâce de 30 secondes. La commande <code>kubectl delete</code> prend en charge l'option <code>--grace-period=&lt;secondes></code> permettant à l'utilisateur de spécifier sa propre valeur. La valeur <code>0</code> <a href=/docs/concepts/workloads/pods/pod/#force-deletion-of-pods>force la suppression</a> du pod. Avec kubectl version >= 1.5, vous devez spécifier un flag supplémentaire <code>--force</code> avec <code>--grace-period=0</code> pour pouvoir forcer la suppression.</p><h3 id=suppression-forcée-de-pods>Suppression forcée de pods</h3><p>La suppression forcée d'un pod est définie comme la suppression immédiate d'un pod de l'état du cluster et d'etcd. Lorqu'une suppression forcée est effectuée, l'apiserver n'attend pas la confirmation de kubelet que le pod a été terminé sur le nœud sur lequel il s'exécutait. Il supprime le pod de l'API immédiatement pour qu'un nouveau pod puisse être créé avec le même nom. Sur le nœud, les pods devant se terminer immédiatement se verront donner une courte période de grâce avant d'être tués de force.</p><p>Les suppressions forcées peuvent être potentiellement dangereuses pour certains pods et doivent être effectuées avec précaution. Dans le cas de pods d'un StatefulSet, veuillez vous référer à la documentation pour <a href=/docs/tasks/run-application/force-delete-stateful-set-pod/>supprimer des Pods d'un StatefulSet</a>.</p><h2 id=mode-privilégié-pour-les-conteneurs-d-un-pod>Mode privilégié pour les conteneurs d'un pod</h2><p>Depuis Kubernetes v1.1, tout conteneur d'un pod peut activer le mode privilégié, en utilisant le flag <code>privileged</code> du <code>SecurityContext</code> de la spec du conteneur. Ceci est utile pour les conteneurs voulant utiliser les capacités de Linux comme manipuler la pile réseau ou accéder aux périphériques. Les processus dans un tel conteneur ont pratiquement les mêmes privilèges que les processus en dehors d'un conteneur. En mode privilégié, il doit être plus facile d'écrire des plugins réseau et volume en tant que pods séparés ne devant pas être compilés dans kubelet.</p><p>Si le master exécute Kubernetes v1.1 ou supérieur, et les nœuds exécutent une version antérieure à v1.1, les nouveaux pods privilégiés seront acceptés par l'api-server, mais ne seront pas lancés. Il resteront en état "pending".
Si l'utilisateur appelle <code>kubectl describe pod FooPodName</code>, l'utilisateur peut voir la raison pour laquelle le pod est en état "pending". La table d'événements dans la sortie de la commande "describe" indiquera :
<code>Error validating pod "FooPodName"."FooPodNamespace" from api, ignoring: spec.containers[0].securityContext.privileged: forbidden '&lt;*>(0xc2089d3248)true'</code></p><p>Si le master exécute une version antérieure à v1.1, les pods privilégiés ne peuvent alors pas être créés. Si l'utilisateur tente de créer un pod ayant un conteneur privilégié, l'utilisateur obtiendra l'erreur suivante :
<code>The Pod "FooPodName" is invalid. spec.containers[0].securityContext.privileged: forbidden '&lt;*>(0xc20b222db0)true'</code></p><h2 id=objet-de-l-api>Objet de l'API</h2><p>Le Pod est une ressource au plus haut niveau dans l'API REST Kubernetes. Plus de détails sur l'objet de l'API peuvent être trouvés à :
<a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>Objet de l'API Pod</a>.</p><p>Lorsque vous créez un manifest pour un objet Pod, soyez certain que le nom spécifié est un <a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nom de sous-domaine DNS</a> valide.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c3c2b9cf30915ec9d46c147201da3332>4.1.3 - Cycle de vie d'un Pod</h1><p>Cette page décrit le cycle de vie d'un Pod.</p><h2 id=phase-du-pod>Phase du Pod</h2><p>Le champ <code>status</code> d'un Pod est un objet
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>,
contenant un champ <code>phase</code>.</p><p>La phase d'un Pod est un résumé simple et de haut niveau de l'étape à laquelle le Pod se trouve
dans son cycle de vie.
La phase n'est pas faite pour être un cumul complet d'observations de l'état
du conteneur ou du Pod, ni pour être une machine à état compréhensible.</p><p>Le nombre et la signification des valeurs de phase d'un pod sont soigneusement gardés.
Hormis ce qui est documenté ici, rien ne doit être supposé sur des Pods
ayant une valeur de <code>phase</code> donnée.</p><p>Voici les valeurs possibles pour <code>phase</code> :</p><table><thead><tr><th style=text-align:left>Valeur</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><code>Pending</code></td><td style=text-align:left>Le Pod a été accepté par Kubernetes, mais une ou plusieurs images de conteneurs n'ont pas encore été créées. Ceci inclut le temps avant d'être affecté ainsi que le temps à télécharger les images à travers le réseau, ce qui peut prendre un certain temps.</td></tr><tr><td style=text-align:left><code>Running</code></td><td style=text-align:left>Le pod a été affecté à un nœud et tous les conteneurs ont été créés. Au moins un conteneur est toujours en cours d'exécution, ou est en train de démarrer ou redémarrer.</td></tr><tr><td style=text-align:left><code>Succeeded</code></td><td style=text-align:left>Tous les conteneurs du pod ont terminé avec succès et ne seront pas redémarrés.</td></tr><tr><td style=text-align:left><code>Failed</code></td><td style=text-align:left>Tous les conteneurs d'un pod ont terminé, et au moins un conteneur a terminé en échec : soit le conteneur a terminé avec un status non zéro, soit il a été arrêté par le système.</td></tr><tr><td style=text-align:left><code>Unknown</code></td><td style=text-align:left>Pour quelque raison l'état du pod ne peut pas être obtenu, en général en cas d'erreur de communication avec l'hôte du Pod.</td></tr></tbody></table><h2 id=conditions-du-pod>Conditions du Pod</h2><p>Un Pod a un PodStatus, qui contient un tableau de
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podcondition-v1-core>PodConditions</a>
à travers lesquelles le Pod est ou non passé. Chaque élément
du tableau de PodCondition a six champs possibles :</p><ul><li><p>Le champ <code>lastProbeTime</code> fournit un timestamp auquel la condition du Pod
a été sondée pour la dernière fois.</p></li><li><p>Le champ <code>lastTransitionTime</code> fournit un timestamp auquel le Pod a changé de statut
pour la dernière fois.</p></li><li><p>Le champ <code>message</code> est un message lisible indiquant les détails de la transition.</p></li><li><p>Le champ <code>reason</code> est une raison unique, en un seul mot et en CamelCase de la transition
vers la dernière condition.</p></li><li><p>Le champ <code>status</code> est une chaîne de caractères avec les valeurs possibles "<code>True</code>", "<code>False</code>", et "<code>Unknown</code>".</p></li><li><p>Le champ <code>type</code> est une chaîne de caractères ayant une des valeurs suivantes :</p><ul><li><code>PodScheduled</code> : le Pod a été affecté à un nœud ;</li><li><code>Ready</code> : le Pod est prêt à servir des requêtes et doit être rajouté aux équilibreurs
de charge de tous les Services correspondants ;</li><li><code>Initialized</code> : tous les <a href=/fr/docs/concepts/workloads/pods/init-containers>init containers</a>
ont démarré correctement ;</li><li><code>ContainersReady</code> : tous les conteneurs du Pod sont prêts.</li></ul></li></ul><h2 id=sondes-du-conteneur>Sondes du Conteneur</h2><p>Une <a href=/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core>Sonde</a> (Probe) est un diagnostic
exécuté périodiquement par <a href=/docs/admin/kubelet/>kubelet</a>
sur un Conteneur. Pour exécuter un diagnostic, kubelet appelle un
<a href=https://godoc.org/k8s.io/kubernetes/pkg/api/v1#Handler>Handler</a> implémenté par
le Conteneur. Il existe trois types de handlers :</p><ul><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#execaction-v1-core>ExecAction</a>:
Exécute la commande spécifiée à l'intérieur du Conteneur. Le diagnostic
est considéré réussi si la commande se termine avec un code de retour de 0.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#tcpsocketaction-v1-core>TCPSocketAction</a>:
Exécute un contrôle TCP sur l'adresse IP du Conteneur et sur un port spécifié.
Le diagnostic est considéré réussi si le port est ouvert.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#httpgetaction-v1-core>HTTPGetAction</a>:
Exécute une requête HTTP Get sur l'adresse IP du Conteneur et sur un port et
un chemin spécifiés. Le diagnostic est considéré réussi si la réponse a un code
de retour supérieur ou égal à 200 et inférieur à 400.</p></li></ul><p>Chaque sonde a un résultat parmi ces trois :</p><ul><li>Success: Le Conteneur a réussi le diagnostic.</li><li>Failure: Le Conteneur a échoué au diagnostic.</li><li>Unknown: L'exécution du diagnostic a échoué, et donc aucune action ne peut être prise.</li></ul><p>kubelet peut optionnellement exécuter et réagir à trois types de sondes sur des conteneurs
en cours d'exécution :</p><ul><li><p><code>livenessProbe</code> : Indique si le Conteneur est en cours d'exécution. Si
la liveness probe échoue, kubelet tue le Conteneur et le Conteneur
est soumis à sa <a href=#politique-de-redemarrage>politique de redémarrage</a> (restart policy).
Si un Conteneur ne fournit pas de liveness probe, l'état par défaut est <code>Success</code>.</p></li><li><p><code>readinessProbe</code> : Indique si le Conteneur est prêt à servir des requêtes.
Si la readiness probe échoue, le contrôleur de points de terminaison (Endpoints)
retire l'adresse IP du Pod des points de terminaison de tous les Services
correspodant au Pod. L'état par défaut avant le délai initial est
<code>Failure</code>. Si le Conteneur ne fournit pas de readiness probe, l'état par
défaut est <code>Success</code>.</p></li><li><p><code>startupProbe</code>: Indique si l'application à l'intérieur du conteneur a démarré.
Toutes les autres probes sont désactivées si une starup probe est fournie,
jusqu'à ce qu'elle réponde avec succès. Si la startup probe échoue, le kubelet
tue le conteneur, et le conteneur est assujetti à sa <a href=#politique-de-redemarrage>politique de redémarrage</a>.
Si un conteneur ne fournit pas de startup probe, l'état par défaut est <code>Success</code>.</p></li></ul><h3 id=quand-devez-vous-utiliser-une-liveness-probe>Quand devez-vous utiliser une liveness probe ?</h3><p>Si le process de votre Conteneur est capable de crasher de lui-même lorsqu'il
rencontre un problème ou devient inopérant, vous n'avez pas forcément besoin
d'une liveness probe ; kubelet va automatiquement exécuter l'action correcte
en accord avec la politique de redémarrage (<code>restartPolicy</code>) du Pod.</p><p>Si vous désirez que votre Conteneur soit tué et redémarré si une sonde échoue, alors
spécifiez une liveness probe et indiquez une valeur pour <code>restartPolicy</code> à Always
ou OnFailure.</p><h3 id=quand-devez-vous-utiliser-une-readiness-probe>Quand devez-vous utiliser une readiness probe ?</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>Si vous voulez commencer à envoyer du trafic à un Pod seulement lorsqu'une sonde
réussit, spécifiez une readiness probe. Dans ce cas, la readiness probe peut être
la même que la liveness probe, mais l'existence de la readiness probe dans la spec
veut dire que le Pod va démarrer sans recevoir aucun trafic et va commencer
à recevoir du trafic après que la sonde réussisse.
Si votre Conteneur doit charger une grande quantité de données, des fichiers de
configuration ou exécuter des migrations au démarrage, spécifiez une readiness probe.</p><p>Si vous désirez que le Conteneur soit capable de se mettre en maintenance tout seul, vous
pouvez spécifier une readiness probe qui vérifie un point de terminaison spécifique au
readiness et différent de la liveness probe.</p><p>Notez que si vous voulez uniquement être capable de dérouter les requêtes lorsque
le Pod est supprimé, vous n'avez pas forcément besoin d'une readiness probe; lors
de sa suppression, le Pod se met automatiquement dans un état non prêt, que la
readiness probe existe ou non.
Le Pod reste dans le statut non prêt le temps que les Conteneurs du Pod s'arrêtent.</p><h3 id=quand-devez-vous-utiliser-une-startup-probe>Quand devez-vous utiliser une startup probe ?</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>Si votre conteneur démarre habituellement en plus de <code>initialDelaySeconds + failureThreshold × periodSeconds</code>,
vous devriez spécifier une startup probe qui vérifie le même point de terminaison que la liveness probe. La valeur par défaut pour <code>periodSeconds</code> est 30s.
Vous devriez alors mettre sa valeur <code>failureThreshold</code> suffisamment haute pour permettre au conteneur de démarrer, sans changer les valeurs par défaut de la liveness probe. Ceci aide à se protéger de deadlocks.</p><p>Pour plus d'informations sur la manière de mettre en place une liveness, readiness ou startup probe,
voir <a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Configurer des Liveness, Readiness et Startup Probes</a>.</p><h2 id=statut-d-un-pod-et-d-un-conteneur>Statut d'un Pod et d'un Conteneur</h2><p>Pour des informations détaillées sur le statut d'un Pod et d'un Conteneur, voir
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>
et
<a href=/docs/reference/generated/kubernetes-api/v1.25/#containerstatus-v1-core>ContainerStatus</a>.
Notez que l'information rapportée comme statut d'un Pod dépend du
<a href=/docs/reference/generated/kubernetes-api/v1.25/#containerstatus-v1-core>ContainerState</a> actuel.</p><h2 id=états-d-un-conteneur>États d'un Conteneur</h2><p>Une fois que le Pod est assigné à un nœud par le scheduler, kubelet commence
à créer les conteneurs en utilisant le runtime de conteneurs. Il existe trois états possibles
pour les conteneurs : en attente (Waiting), en cours d'exécution (Running) et terminé (Terminated). Pour vérifier l'état d'un conteneur, vous pouvez utiliser <code>kubectl describe pod [POD_NAME]</code>. L'état est affiché pour chaque conteneur du Pod.</p><ul><li><p><code>Waiting</code> : état du conteneur par défaut. Si le conteneur n'est pas dans un état Running ou Terminated, il est dans l'état Waiting. Un conteneur dans l'état Waiting exécute
les opérations nécessaires, comme télécharger les images, appliquer des Secrets, etc. À côté
de cet état, un message et une raison sur l'état sont affichés pour vous fournir plus
d'informations.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>State</span>:<span style=color:#bbb>          </span>Waiting<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>Reason</span>:<span style=color:#bbb>       </span>ErrImagePull<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p><code>Running</code> : Indique que le conteneur s'exécute sans problème. Le hook <code>postStart</code> (s'il existe) est exécuté avant que le conteneur entre dans l'état Running. Cet état affiche aussi le moment auquel le conteneur est entré dans l'état Running.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>State</span>:<span style=color:#bbb>          </span>Running<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>Started</span>:<span style=color:#bbb>      </span>Wed, 30 Jan 2019 16:46:38 +0530<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p><code>Terminated</code>: Indique que le conteneur a terminé son exécution et s'est arrêté.
Un conteneur entre dans cet état lorsqu'il s'est exécuté avec succès ou lorsqu'il a
échoué pour une raison quelconque. De plus, une raison et un code de retour sont affichés,
ainsi que les moments de démarrage et d'arrêt du conteneur. Avant qu'un conteneur entre
dans l'état Terminated, le hook <code>preStop</code> est exécuté (s'il existe).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>State</span>:<span style=color:#bbb>          </span>Terminated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Reason</span>:<span style=color:#bbb>       </span>Completed<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Exit Code</span>:<span style=color:#bbb>    </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Started</span>:<span style=color:#bbb>      </span>Wed, 30 Jan 2019 11:45:26 +0530<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Finished</span>:<span style=color:#bbb>     </span>Wed, 30 Jan 2019 11:45:26 +0530<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span></span></span></code></pre></div></li></ul><h2 id=pod-readiness-gate>Pod readiness</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><p>Votre application peut injecter des données dans <code>PodStatus</code>.</p><p><em>Pod readiness</em>. Pour utiliser cette fonctionnalité, remplissez <code>readinessGates</code> dans le PodSpec avec
une liste de conditions supplémentaires que le kubelet évalue pour la disponibilité du Pod.</p><p>Les Readiness gates sont déterminées par l'état courant des champs <code>status.condition</code> du Pod.
Si Kubernetes ne peut pas trouver une telle condition dans le champs <code>status.conditions</code> d'un Pod, the statut de la condition
est mise par défaut à "<code>False</code>".</p><p>Voici un exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readinessGates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>conditionType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready <span style=color:#bbb> </span><span style=color:#080;font-style:italic># une PodCondition intégrée</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># une PodCondition supplémentaire</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://abcd...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Les conditions du Pod que vous ajoutez doivent avoir des noms qui sont conformes au <a href=/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set>format des étiquettes</a> de Kubernetes.</p><h3 id=statut-pod-disponibilité>Statut de la disponibilité d'un Pod</h3><p>La commande <code>kubectl patch</code> ne peut pas patcher le statut d'un objet.
Pour renseigner ces <code>status.conditions</code> pour le pod, les applications et
<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operators>operators</a> doivent utiliser l'action <code>PATCH</code>.
Vous pouvez utiliser une <a href=/docs/reference/using-api/client-libraries/>bibliothèque client Kubernetes</a> pour
écrire du code qui renseigne les conditions particulières pour la disponibilité dun Pod.</p><p>Pour un Pod utilisant des conditions particulières, ce Pod est considéré prêt <strong>seulement</strong>
lorsque les deux déclarations ci-dessous sont vraies :</p><ul><li>Tous les conteneurs du Pod sont prêts.</li><li>Toutes les conditions spécifiées dans <code>ReadinessGates</code> sont <code>True</code>.</li></ul><p>Lorsque les conteneurs d'un Pod sont prêts mais qu'au moins une condition particulière
est manquante ou <code>False</code>, le kubelet renseigne la condition du Pod à <code>ContainersReady</code>.</p><h2 id=politique-de-redémarrage>Politique de redémarrage</h2><p>La structure PodSpec a un champ <code>restartPolicy</code> avec comme valeur possible
Always, OnFailure et Never. La valeur par défaut est Always.
<code>restartPolicy</code> s'applique à tous les Conteneurs du Pod. <code>restartPolicy</code> s'applique
seulement aux redémarrages des Conteneurs par kubelet sur le même nœud. Des conteneurs
terminés qui sont redémarrés par kubelet sont redémarrés avec un délai exponentiel
(10s, 20s, 40s ...) plafonné à cinq minutes, qui est réinitialisé après dix minutes
d'exécution normale. Comme discuté dans le
<a href=/docs/user-guide/pods/#durability-of-pods-or-lack-thereof>document sur les Pods</a>,
une fois attaché à un nœud, un Pod ne sera jamais rattaché à un autre nœud.</p><h2 id=durée-de-vie-d-un-pod>Durée de vie d'un Pod</h2><p>En général, les Pods restent jusqu'à ce qu'un humain ou un process de
<a class=glossary-tooltip title="Boucle de contrôle surveillant l'état partagé du cluster à travers l'apiserver et effectuant des changements en essayant de déplacer l'état actuel vers l'état désiré." data-toggle=tooltip data-placement=top href=/docs/admin/kube-controller-manager/ target=_blank aria-label=contrôleur>contrôleur</a> les supprime explicitement.</p><p>Le plan de contrôle nettoie les Pods terminés (avec une phase à <code>Succeeded</code> ou
<code>Failed</code>), lorsque le nombre de Pods excède le seuil configuré
(determiné par <code>terminated-pod-gc-threshold</code> dans le kube-controller-manager).
Ceci empêche une fuite de ressources lorsque les Pods sont créés et supprimés au fil du temps.</p><p>Il y a différents types de ressources pour créer des Pods :</p><ul><li><p>Utilisez un <a class=glossary-tooltip title='Objet API gérant une application répliquée.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Déploiement>Déploiement</a>,
<a class=glossary-tooltip title='ReplicaSet ensures that a specified number of Pod replicas are running at one time' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a> ou <a class=glossary-tooltip title="Gère le déploiement et la mise à l'échelle d'un ensemble de Pods, avec un stockage durable et des identifiants persistants pour chaque Pod." data-toggle=tooltip data-placement=top href=/fr/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>
pour les Pods qui ne sont pas censés terminer, par exemple des serveurs web.</p></li><li><p>Utilisez un <a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>
pour les Pods qui sont censés se terminer une fois leur tâche accomplie. Les Jobs sont appropriés
seulement pour des Pods ayant <code>restartPolicy</code> égal à OnFailure ou Never.</p></li><li><p>Utilisez un <a class=glossary-tooltip title="S'assure qu'une copie d'un Pod s'exécute sur un ensemble de nœuds d'un cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>
pour les Pods qui doivent s'exécuter sur chaque noeud éligible.</p></li></ul><p>Toutes les ressources de charges de travail contiennent une PodSpec. Il est recommandé de créer
la ressource de charges de travail appropriée et laisser le contrôleur de la ressource créer les Pods
pour vous, plutôt que de créer directement les Pods vous-même.</p><p>Si un nœud meurt ou est déconnecté du reste du cluster, Kubernetes applique
une politique pour mettre la <code>phase</code> de tous les Pods du nœud perdu à Failed.</p><h2 id=exemples>Exemples</h2><h3 id=exemple-avancé-de-liveness-probe>Exemple avancé de liveness probe</h3><p>Les Liveness probes sont exécutées par kubelet, toutes les requêtes sont donc faites
dans l'espace réseau de kubelet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># lorsque &#34;host&#34; n&#39;est pas défini, &#34;PodIP&#34; sera utilisé</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># host: my-host</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># lorsque &#34;scheme&#34; n&#39;est pas défini, &#34;HTTP&#34; sera utilisé. &#34;HTTP&#34; et &#34;HTTPS&#34; sont les seules valeurs possibles</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># scheme: HTTPS</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>X-Custom-Header<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>Awesome<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=exemples-d-états>Exemples d'états</h3><ul><li><p>Un Pod est en cours d'exécution et a un Conteneur. Le conteneur se termine avec succès.</p><ul><li>Écriture d'un événement de complétion.</li><li>Si <code>restartPolicy</code> est :<ul><li>Always : Redémarrage du Conteneur ; la <code>phase</code> du Pod reste à Running.</li><li>OnFailure : la <code>phase</code> du Pod passe à Succeeded.</li><li>Never : la <code>phase</code> du Pod passe à Succeeded.</li></ul></li></ul></li><li><p>Un Pod est en cours d'exécution et a un Conteneur. Le conteneur se termine en erreur.</p><ul><li>Écriture d'un événement d'échec.</li><li>Si <code>restartPolicy</code> est :<ul><li>Always : Redémarrage du Conteneur ; la <code>phase</code> du Pod reste à Running.</li><li>OnFailure : Redémarrage du Conteneur ; la <code>phase</code> du Pod reste à Running.</li><li>Never : la <code>phase</code> du Pod passe à Failed.</li></ul></li></ul></li><li><p>Un Pod est en cours d'exécution et a deux Conteneurs. Le conteneur 1 termine en erreur.</p><ul><li>Écriture d'un événement d'échec.</li><li>Si <code>restartPolicy</code> est :<ul><li>Always : Redémarrage du Conteneur ; la <code>phase</code> du Pod reste à Running.</li><li>OnFailure : Redémarrage du Conteneur ; la <code>phase</code> du Pod reste à Running.</li><li>Never : Le Conteneur n'est pas redémarré ; la <code>phase</code> du Pod reste à Running.</li></ul></li><li>Si Container 1 est arrêté, et Conteneur 2 se termine :<ul><li>Écriture d'un événement d'échec.</li><li>Si <code>restartPolicy</code> est :<ul><li>Always : Redémarrage du Conteneur ; la <code>phase</code> du Pod reste à Running.</li><li>OnFailure : Redémarrage du Conteneur ; la <code>phase</code> du Pod reste à Running.</li><li>Never : la <code>phase</code> du Pod passe à Failed.</li></ul></li></ul></li></ul></li><li><p>Un Pod est en cours d'exécution et a un Conteneur. Le Conteneur n'a plus assez de mémoire.</p><ul><li>Le Conteneur se termine en erreur.</li><li>Écriture d'un événement OOM.</li><li>Si <code>restartPolicy</code> est :<ul><li>Always : Redémarrage du Conteneur ; la <code>phase</code> du Pod reste à Running.</li><li>OnFailure : Redémarrage du Conteneur ; la <code>phase</code> du Pod reste à Running.</li><li>Never : Écriture d'un événement d'erreur ; la <code>phase</code> du Pod passe à Failed.</li></ul></li></ul></li><li><p>Le Pod est en cours d'exécution, et un disque meurt.</p><ul><li>Tous les conteneurs sont tués.</li><li>Écriture d'un événement approprié.</li><li>La <code>phase</code> du Pod devient Failed.</li><li>Si le Pod s'exécute sous un contrôleur, le Pod est recréé ailleurs.</li></ul></li><li><p>Le Pod est en cours d'exécution et son nœud est segmenté.</p><ul><li>Le contrôleur de Nœud attend un certain temps.</li><li>Le contrôleur de Nœud passe la <code>phase</code> du Pod à Failed.</li><li>Si le Pod s'exécute sous un contrôleur, le Pod est recréé ailleurs.</li></ul></li></ul><h2 id=a-suivre>A suivre</h2><ul><li><p>Apprenez par la pratique
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>attacher des handlers à des événements de cycle de vie d'un conteneur</a>.</p></li><li><p>Apprenez par la pratique
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>configurer des liveness, readiness et startup probes</a>.</p></li><li><p>En apprendre plus sur les <a href=/docs/concepts/containers/container-lifecycle-hooks/>hooks de cycle de vie d'un Conteneur</a>.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c8d62295ca703fdcef1aaf89fb4c916a>4.1.4 - Contraintes de propagation de topologie pour les Pods</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Vous pouvez utiliser des <em>contraintes de propagation de topologie</em> pour contrôler comment les <a class=glossary-tooltip title='Le plus petit et le plus simple des objets Kubernetes. Un Pod est un ensemble de conteneurs fonctionnant sur votre cluster.' data-toggle=tooltip data-placement=top href=/fr/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a> sont propagés à travers votre cluster parmi les domaines de défaillance comme les régions, zones, noeuds et autres domaines de topologie définis par l'utilisateur. Ceci peut aider à mettre en place de la haute disponibilité et à utiliser efficacement les ressources.</p><h2 id=conditions-préalables>Conditions préalables</h2><h3 id=autoriser-la-feature-gate>Autoriser la Feature Gate</h3><p>La <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> <code>EvenPodsSpread</code> doit être autorisée pour
<a class=glossary-tooltip title="Composant sur le master qui expose l'API Kubernetes. Il s'agit du front-end pour le plan de contrôle Kubernetes." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label="l'API Server">l'API Server</a> <strong>et</strong> le
<a class=glossary-tooltip title="Composant sur le master qui surveille les pods nouvellement créés qui ne sont pas assignés à un nœud et sélectionne un nœud sur lequel ils vont s'exécuter." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a>.</p><h3 id=labels-de-noeuds>Labels de noeuds</h3><p>Les contraintes de propagation de topologie reposent sur les labels de noeuds pour identifier le ou les domaines de topologie dans lesquels se trouve chacun des noeuds. Par exemple, un noeud pourrait avoir les labels: <code>node=node1,zone=us-east-1a,region=us-east-1</code></p><p>Supposons que vous ayez un cluster de 4 noeuds ayant les labels suivants:</p><pre tabindex=0><code>NAME    STATUS   ROLES    AGE     VERSION   LABELS
node1   Ready    &lt;none&gt;   4m26s   v1.16.0   node=node1,zone=zoneA
node2   Ready    &lt;none&gt;   3m58s   v1.16.0   node=node2,zone=zoneA
node3   Ready    &lt;none&gt;   3m17s   v1.16.0   node=node3,zone=zoneB
node4   Ready    &lt;none&gt;   2m43s   v1.16.0   node=node4,zone=zoneB
</code></pre><p>Une vue logique du cluster est celle-ci :</p><pre tabindex=0><code>+---------------+---------------+
|     zoneA     |     zoneB     |
+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+
</code></pre><p>Plutôt que d'appliquer des labels manuellement, vous pouvez aussi réutiliser les <a href=/docs/reference/kubernetes-api/labels-annotations-taints/>labels réputés</a> qui sont créés et renseignés automatiquement dans la plupart des clusters.</p><h2 id=contraintes-de-propagation-pour-les-pods>Contraintes de propagation pour les Pods</h2><h3 id=api>API</h3><p>Le champ <code>pod.spec.topologySpreadConstraints</code> est introduit dans 1.16 comme suit :</p><pre tabindex=0><code>apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  topologySpreadConstraints:
    - maxSkew: &lt;integer&gt;
      minDomains: &lt;integer&gt;
      topologyKey: &lt;string&gt;
      whenUnsatisfiable: &lt;string&gt;
      labelSelector: &lt;object&gt;
</code></pre><p>Vous pouvez définir une ou plusieurs <code>topologySpreadConstraint</code> pour indiquer au kube-scheduler comment placer chaque nouveau Pod par rapport aux Pods déjà existants dans votre cluster. Les champs sont :</p><ul><li><strong>maxSkew</strong> décrit le degré avec lequel les Pods peuvent être inégalement distribués. C'est la différence maximale permise entre le nombre de Pods correspondants entre deux quelconques domaines de topologie d'un type donné. Il doit être supérieur à zéro.</li><li><strong>topologyKey</strong> est la clé des labels de noeuds. Si deux noeuds sont étiquettés avec cette clé et ont des valeurs égales pour ce label, le scheduler considère les deux noeuds dans la même topologie. Le scheduler essaie de placer un nombre équilibré de Pods dans chaque domaine de topologie.</li><li><strong>whenUnsatisfiable</strong> indique comment traiter un Pod qui ne satisfait pas les contraintes de propagation :<ul><li><code>DoNotSchedule</code> (défaut) indique au scheduler de ne pas le programmer.</li><li><code>ScheduleAnyway</code> indique au scheduler de le programmer, tout en priorisant les noeuds minimisant le biais (<em>skew</em>).</li></ul></li><li><strong>labelSelector</strong> est utilisé pour touver les Pods correspondants. Les Pods correspondants à ce sélecteur de labels sont comptés pour déterminer le nombre de Pods dans leurs domaines de topologie correspodants. Voir <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>Sélecteurs de labels</a> pour plus de détails.</li></ul><p>Vous pouvez en savoir plus sur ces champ en exécutant <code>kubectl explain Pod.spec.topologySpreadConstraints</code>.</p><h3 id=exemple-une-topologyspreadconstraint>Exemple : Une TopologySpreadConstraint</h3><p>Supposons que vous ayez un cluster de 4 noeuds où 3 Pods étiquettés <code>foo:bar</code> sont placés sur node1, node2 et node3 respectivement (<code>P</code> représente un Pod) :</p><pre tabindex=0><code>+---------------+---------------+
|     zoneA     |     zoneB     |
+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+
|   P   |   P   |   P   |       |
+-------+-------+-------+-------+
</code></pre><p>Si nous voulons qu'un nouveau Pod soit uniformément réparti avec les Pods existants à travers les zones, la spec peut être :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/topology-spread-constraints/one-constraint.yaml download=pods/topology-spread-constraints/one-constraint.yaml><code>pods/topology-spread-constraints/one-constraint.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-topology-spread-constraints-one-constraint-yaml")' title="Copy pods/topology-spread-constraints/one-constraint.yaml to clipboard"></img></div><div class=includecode id=pods-topology-spread-constraints-one-constraint-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p><code>topologyKey: zone</code> implique que la distribution uniforme sera uniquement appliquée pour les noeuds ayant le label "zone:&lt;any value>" présent. <code>whenUnsatisfiable: DoNotSchedule</code> indique au scheduler de laisser le Pod dans l'état Pending si le Pod entrant ne peut pas satisfaire la contrainte.</p><p>Si le scheduler plaçait ce Pod entrant dans "zoneA", la distribution des Pods deviendrait [3, 1], et le biais serait de 2 (3 - 1) - ce qui va à l'encontre de <code>maxSkew: 1</code>. Dans cet exemple, le Pod entrant peut uniquement être placé dans "zoneB":</p><pre tabindex=0><code>+---------------+---------------+      +---------------+---------------+
|     zoneA     |     zoneB     |      |     zoneA     |     zoneB     |
+-------+-------+-------+-------+      +-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |  OR  | node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+      +-------+-------+-------+-------+
|   P   |   P   |   P   |   P   |      |   P   |   P   |  P P  |       |
+-------+-------+-------+-------+      +-------+-------+-------+-------+
</code></pre><p>Vous pouvez ajuster la spec du Pod pour pour répondre à divers types d'exigences :</p><ul><li>Changez <code>maxSkew</code> pour une valeur plus grande comme "2" pour que le Pod entrant puisse aussi être placé dans la "zoneA".</li><li>Changez <code>topologyKey</code> pour "node" pour distribuer les Pods uniformément à travers les noeuds et non plus les zones. Dans l'exemple ci-dessus, si <code>maxSkew</code> reste à "1", le Pod entrant peut être uniquement placé dans "node4".</li><li>Changez <code>whenUnsatisfiable: DoNotSchedule</code> en <code>whenUnsatisfiable: ScheduleAnyway</code> pour s'assurer que le Pod est toujours programmable (en supposant que les autres APIs de scheduling soient satisfaites). Cependant, il sera de préférence placé dans la topologie de domaine ayant le moins de Pods correspondants. (Prenez note que cette préférence est normalisée conjointement avec d'autres priorités de scheduling interne comme le ratio d'usage de ressources, etc.)</li></ul><h3 id=example-plusieurs-topologyspreadconstraints>Example: Plusieurs TopologySpreadConstraints</h3><p>Cela s'appuie sur l'exemple précédent. Supposons que vous ayez un cluster de 4 noeuds où 3 Pods étiquetés <code>foo:bar</code> sont placés sur node1, node2 et node3 respectivement (<code>P</code> représente un Pod):</p><pre tabindex=0><code>+---------------+---------------+
|     zoneA     |     zoneB     |
+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+
|   P   |   P   |   P   |       |
+-------+-------+-------+-------+
</code></pre><p>Vous pouvez utiliser 2 TopologySpreadConstraints pour contrôler la répartition des Pods aussi bien dans les zones que dans les noeuds :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/topology-spread-constraints/two-constraints.yaml download=pods/topology-spread-constraints/two-constraints.yaml><code>pods/topology-spread-constraints/two-constraints.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-topology-spread-constraints-two-constraints-yaml")' title="Copy pods/topology-spread-constraints/two-constraints.yaml to clipboard"></img></div><div class=includecode id=pods-topology-spread-constraints-two-constraints-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>node<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dans ce cas, pour satisfaire la première contrainte, le Pod entrant peut uniquement être placé dans "zoneB" ; alors que pour satisfaire la seconde contrainte, le Pod entrant peut uniquement être placé dans "node4". Le résultat étant l'intersection des résultats des 2 contraintes, l'unique option possible est de placer le Pod entrant dans "node4".</p><p>Plusieurs contraintes peuvent entraîner des conflits. Supposons que vous ayez un cluster de 3 noeuds couvrant 2 zones :</p><pre tabindex=0><code>+---------------+-------+
|     zoneA     | zoneB |
+-------+-------+-------+
| node1 | node2 | node3 |
+-------+-------+-------+
|  P P  |   P   |  P P  |
+-------+-------+-------+
</code></pre><p>Si vous appliquez "two-constraints.yaml" à ce cluster, vous noterez que "mypod" reste dans l'état <code>Pending</code>. Cela parce que : pour satisfaire la première contrainte, "mypod" peut uniquement être placé dans "zoneB"; alors que pour satisfaire la seconde contrainte, "mypod" peut uniquement être placé sur "node2". Ainsi, le résultat de l'intersection entre "zoneB" et "node2" ne retourne rien.</p><p>Pour surmonter cette situation, vous pouvez soit augmenter <code>maxSkew</code>, soit modifier une des contraintes pour qu'elle utilise <code>whenUnsatisfiable: ScheduleAnyway</code>.</p><h3 id=conventions>Conventions</h3><p>Il existe quelques conventions implicites qu'il est intéressant de noter ici :</p><ul><li><p>Seuls le Pods du même espace de noms que le Pod entrant peuvent être des candidats pour la correspondance.</p></li><li><p>Les noeuds sans label <code>topologySpreadConstraints[*].topologyKey</code> seront ignorés. Cela induit que :</p><ol><li>les Pods localisés sur ces noeuds n'impactent pas le calcul de <code>maxSkew</code> - dans l'exemple ci-dessus, supposons que "node1" n'a pas de label "zone", alors les 2 Pods ne seront pas comptés, et le Pod entrant sera placé dans "zoneA".</li><li>le Pod entrant n'a aucune chance d'être programmé sur ce type de noeuds - dans l'exemple ci-dessus, supposons qu'un "node5" portant un label <code>{zone-typo: zoneC}</code> joigne le cluster ; il sera ignoré, en raison de l'absence de label "zone".</li></ol></li><li><p>Faites attention à ce qui arrive lorsque le <code>topologySpreadConstraints[*].labelSelector</code> du Pod entrant ne correspond pas à ses propres labels. Dans l'exemple ci-dessus, si nous supprimons les labels du Pod entrant, il sera toujours placé dans "zoneB" car les contraintes sont toujours satisfaites. Cependant, après le placement, le degré de déséquilibre du cluster reste inchangé - zoneA contient toujours 2 Pods ayant le label {foo:bar}, et zoneB contient 1 Pod cayant le label {foo:bar}. Si ce n'est pas ce que vous attendez, nous recommandons que <code>topologySpreadConstraints[*].labelSelector</code> du workload corresponde à ses propres labels.</p></li><li><p>Si le Pod entrant a défini <code>spec.nodeSelector</code> ou <code>spec.affinity.nodeAffinity</code>, les noeuds non correspondants seront ignorés.</p><p>Supposons que vous ayez un cluster de 5 noeuds allant de zoneA à zoneC :</p><pre tabindex=0><code>+---------------+---------------+-------+
|     zoneA     |     zoneB     | zoneC |
+-------+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 | node5 |
+-------+-------+-------+-------+-------+
|   P   |   P   |   P   |       |       |
+-------+-------+-------+-------+-------+
</code></pre><p>et vous savez que "zoneC" doit être exclue. Dans ce cas, vous pouvez écrire le yaml ci-dessous, pour que "mypod" soit placé dans "zoneB" plutôt que dans "zoneC". <code>spec.nodeSelector</code> est pris en compte de la même manière.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml download=pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml><code>pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-topology-spread-constraints-one-constraint-with-nodeaffinity-yaml")' title="Copy pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml to clipboard"></img></div><div class=includecode id=pods-topology-spread-constraints-one-constraint-with-nodeaffinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>NotIn<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- zoneC<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1<span style=color:#bbb>
    </span></span></span></code></pre></div></div></div></li></ul><h3 id=contraintes-par-défaut-au-niveau-du-cluster>Contraintes par défaut au niveau du cluster</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [alpha]</code></div><p>Il est possible de définir des contraintes de propagation de topologie par défaut pour un cluster. Les contraintes de propagation de topologie sont appliquées à un Pod si et seulement si :</p><ul><li>Il ne définit aucune contrainte dans son <code>.spec.topologySpreadConstraints</code>.</li><li>Il appartient à un service, replication controller, replica set ou stateful set.</li></ul><p>Les contraintes par défaut peuvent être définies comme arguments du plugin <code>PodTopologySpread</code>
dans un <a href=/docs/reference/scheduling/profiles>profil de scheduling</a>.
Les contraintes sont spécifiées avec la même <a href=#api>API ci-dessus</a>, à l'exception que
<code>labelSelector</code> doit être vide. Les sélecteurs sont calculés à partir des services,
replication controllers, replica sets ou stateful sets auxquels le Pod appartient.</p><p>Un exemple de configuration pourrait ressembler à :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1alpha2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>default-scheduler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodTopologySpread<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>defaultConstraints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>ScheduleAnyway<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le score produit par les contraintes de scheduling par défaut peuvent rentrer en conflit avec le score
produit par le <a href=/docs/reference/scheduling/profiles/#scheduling-plugins>plugin <code>DefaultPodTopologySpread</code></a>.
Il est recommandé de désactiver ce plugin dans le profil de scheduling lorsque vous utilisez des contraintes
par défaut pour <code>PodTopologySpread</code>.</div><h2 id=comparaison-avec-podaffinity-podantiaffinity>Comparaison avec PodAffinity/PodAntiAffinity</h2><p>Dans Kubernetes, les directives relatives aux "Affinités" contrôlent comment les Pods sont
programmés - plus regroupés ou plus dispersés.</p><ul><li>Pour <code>PodAffinity</code>, vous pouvez essayer de regrouper un certain nombre de Pods dans des domaines de topologie qualifiés,</li><li>Pour <code>PodAntiAffinity</code>, seulement un Pod peut être programmé dans un domaine de topologie unique.</li></ul><p>La fonctionnalité "EvenPodsSpread" fournit des options flexibles pour distribuer des Pods uniformément sur différents domaines de topologie - pour mettre en place de la haute disponibilité ou réduire les coûts. Cela peut aussi aider
au rolling update des charges de travail et à la mise à l'échelle de réplicas. Voir <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/895-pod-topology-spread#motivation>Motivations</a> pour plus de détails.</p><h2 id=limitations-connues>Limitations connues</h2><p>En version 1.18, pour laquelle cette fonctionnalité est en Beta, il y a quelques limitations connues :</p><ul><li>Réduire un Déploiement peut résulter en une distrubution désiquilibrée des Pods.</li><li>Les Pods correspondants sur des noeuds taintés sont respectés. Voir <a href=https://github.com/kubernetes/kubernetes/issues/80921>Issue 80921</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>4.1.5 - Init Containers</h1><p>Cette page fournit une vue d'ensemble des <em>conteneurs d'initialisation</em> (init containers) : des conteneurs spécialisés qui s'exécutent avant les conteneurs d'application dans un <a class=glossary-tooltip title='Le plus petit et le plus simple des objets Kubernetes. Un Pod est un ensemble de conteneurs fonctionnant sur votre cluster.' data-toggle=tooltip data-placement=top href=/fr/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>.
Les init containers peuvent contenir des utilitaires ou des scripts d'installation qui ne sont pas présents dans une image d'application.</p><p>Vous pouvez spécifier des init containers dans la spécification du Pod à côté du tableau <code>containers</code> (qui décrit les conteneurs d'application)</p><h2 id=comprendre-les-init-containers>Comprendre les init containers</h2><p>Un <a class=glossary-tooltip title='Le plus petit et le plus simple des objets Kubernetes. Un Pod est un ensemble de conteneurs fonctionnant sur votre cluster.' data-toggle=tooltip data-placement=top href=/fr/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> peut avoir plusieurs conteneurs exécutant des applications mais peut aussi avoir un ou plusieurs init containers, qui sont exécutés avant que les conteneurs d'application ne démarrent.</p><p>Les init containers se comportent comme les conteneurs réguliers, avec quelques différences :</p><ul><li>Les init containers s'exécutent toujours jusqu'à la complétion.</li><li>Chaque init container doit se terminer avec succès avant que le prochain ne démarre.</li></ul><p>Si le init container d'un Pod échoue, Kubernetes redémarre le Pod à répétition jusqu'à ce que le init container se termine avec succès.
Cependant, si le Pod a une <code>restartPolicy</code> à "Never", Kubernetes ne redémarre pas le Pod.</p><p>Afin de spécifier un init container pour un Pod, il faut ajouter le champ <code>initContainers</code> dans la spécification du Pod, comme un
tableau d'objets de type <a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Container</a>, au même niveau que le tableau d'applications <code>containers</code>.
Le statut des init containers est retourné dans le champ <code>.status.initContainerStatuses</code>
comme un tableau des statuts du conteneur (comparable au champ <code>.status.containerStatuses</code>).</p><h3 id=différences-avec-les-conteneurs-réguliers>Différences avec les conteneurs réguliers</h3><p>Les init containers supportent tous les champs et fonctionnalités des conteneurs d'application
incluant les limites de ressources, les volumes et les paramètres de sécurité.
Cependant, les demandes de ressources pour un init container sont gérées différemment des
limites de ressources, tel que documenté dans <a href=#ressources>Ressources</a>.</p><p>De plus, les init containers ne supportent pas les readiness probes parce que ces conteneurs
s'exécutent jusqu'au bout avant que le Pod soit prêt.</p><p>Si l'on spécifie plusieurs init containers pour un Pod, Kubelet exécute chaque
init container de manière séquentielle.
Chaque init container doit se terminer avec succès avant que le prochain ne puisse s'exécuter.
Lorsque tous les init containers se sont exécutés jusqu'au bout, Kubelet initialise
les conteneurs d'application pour le Pod et les exécute comme d'habitude.</p><h2 id=utiliser-les-init-containers>Utiliser les init containers</h2><p>Puisque les init containers ont des images séparées des conteneurs d'application,
ils apportent certains avantages pour du code de mise en route :</p><ul><li>Les init containers peuvent contenir des utilitaires ou du code de configuration personnalisé
qui ne sont pas présents dans une image d'application.
Par exemple, il n'y a pas besoin de faire hériter une image d'une autre (<code>FROM</code>) seulement pour utiliser
un outil comme <code>sed</code>, <code>awk</code>, <code>python</code>, ou <code>dig</code> pendant l'installation.</li><li>Les init containers peuvent exécuter en toute sécurité des utilitaires qui rendraient moins sécurisée une image de conteneur d'application.</li><li>Les rôles "builder" et "deployer" d'une image d'application peuvent travailler indépendamment sans qu'il n'y ait besoin
de créer conjointement une seule image d'application.</li><li>Les init containers peuvent s'exécuter avec une vue du système de fichiers différente de celle des conteneurs d'application dans le même Pod. Par conséquent, on peut leur donner accès aux <a class=glossary-tooltip title='Stores sensitive information, such as passwords, OAuth tokens, and ssh keys.' data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/secret/ target=_blank aria-label=Secrets>Secrets</a>, auxquels les conteneurs d'application n'ont pas accès.</li><li>Puisque les init containers s'exécutent jusqu'à la complétion avant qu'un conteneur d'application ne démarre, les init containers
offrent un mécanisme pour bloquer ou retarder le démarrage d'un conteneur d'application tant qu'un ensemble de préconditions n'est pas respecté. Une fois que les préconditions sont respectées, tous les conteneurs d'application dans un Pod peuvent démarrer en parallèle.</li></ul><h3 id=exemples>Exemples</h3><p>Voici plusieurs idées pour utiliser les init containers :</p><ul><li><p>Attendre qu'un <a class=glossary-tooltip title="Un moyen d'exposer une application s'exécutant sur un ensemble de pods en tant que service réseau." data-toggle=tooltip data-placement=top href=/fr/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a> soit créé,
en utilisant une commande shell d'une ligne telle que :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>{</span>1..100<span style=color:#666>}</span>; <span style=color:#a2f;font-weight:700>do</span> sleep 1; <span style=color:#a2f;font-weight:700>if</span> dig myservice; <span style=color:#a2f;font-weight:700>then</span> <span style=color:#a2f>exit</span> 0; <span style=color:#a2f;font-weight:700>fi</span>; <span style=color:#a2f;font-weight:700>done</span>; <span style=color:#a2f>exit</span> <span style=color:#666>1</span>
</span></span></code></pre></div></li><li><p>Enregistrer ce Pod à un serveur distant depuis l'API downward avec une commande telle que :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X POST http://<span style=color:#b8860b>$MANAGEMENT_SERVICE_HOST</span>:<span style=color:#b8860b>$MANAGEMENT_SERVICE_PORT</span>/register -d <span style=color:#b44>&#39;instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)&#39;</span>
</span></span></code></pre></div></li><li><p>Attendre un certain temps avant de démarrer le conteneur d'application avec une commande telle que :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sleep <span style=color:#666>60</span>
</span></span></code></pre></div></li><li><p>Cloner un dépôt Git dans un <a class=glossary-tooltip title="Un répertoire contenant des données, accessible aux conteneurs d'un pod." data-toggle=tooltip data-placement=top href=/fr/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a></p></li><li><p>Placer des valeurs dans un fichier de configuration et exécuter un outil de templating pour générer
dynamiquement un fichier de configuration pour le conteneur d'application principal.
Par exemple, placer la valeur <code>POD_IP</code> dans une configuration et générer le fichier de configuration de l'application principale
en utilisant Jinja.</p></li></ul><h4 id=les-init-containers-en-utilisation>Les init containers en utilisation</h4><p>Cet exemple définit un simple Pod possédant deux init containers.
Le premier attend <code>myservice</code> et le second attend <code>mydb</code>. Une fois que les deux
init containers terminent leur exécution, le Pod exécute le conteneur d'application décrit dans sa section <code>spec</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo &#34;L&#39;&#39;app s&#39;&#39;exécute!&#34; &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo en attente de myservice; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo en attente de mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Les fichiers YAML suivants résument les services <code>mydb</code> et <code>myservice</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Vous pouvez démarrer ce Pod en exécutant :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f myapp.yaml
</span></span></code></pre></div><pre tabindex=0><code>pod/myapp-pod created
</code></pre><p>Et vérifier son statut avec :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><pre tabindex=0><code>NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre><p>ou pour plus de détails :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe -f myapp.yaml
</span></span></code></pre></div><pre tabindex=0><code>Name:          myapp-pod
Namespace:     default
[...]
Labels:        app.kubernetes.io/name=MyApp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634
</code></pre><p>Pour voir les logs des init containers dans ce Pod, exécuter :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># Inspecter le premier init container</span>
</span></span><span style=display:flex><span>kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># Inspecter le second init container</span>
</span></span></code></pre></div><p>À ce stade, ces init containers attendent de découvrir les services nommés
<code>mydb</code> et <code>myservice</code>.</p><p>Voici une configuration que vous pouvez utiliser pour faire apparaître ces Services :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Pour créer les services <code>mydb</code> et <code>myservice</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f services.yaml
</span></span></code></pre></div><pre tabindex=0><code>service/myservice created
service/mydb created
</code></pre><p>Vous verrez ensuite que ces init containers se terminent et que le Pod <code>myapp-pod</code> évolue vers l'état "Running" (en exécution) :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><pre tabindex=0><code>NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          9m
</code></pre><p>Cet exemple simple devrait suffire à vous inspirer pour créer vos propres init containers.
<a href=#a-suivre>A suivre</a> contient un lien vers un exemple plus détaillé.</p><h2 id=comportement-détaillé>Comportement détaillé</h2><p>Pendant le démarrage d'un Pod, chaque init container démarre en ordre, après que le réseau
et les volumes ont été initialisés. Chaque conteneur doit se terminer avec succès avant que le prochain
ne démarre. Si un conteneur n'arrive pas à démarrer à cause d'un problème d'exécution ou
se termine avec un échec, il est redémarré selon la <code>restartPolicy</code> du Pod.
Toutefois, si la <code>restartPolicy</code> du Pod est configurée à "Always", les init containers utilisent la <code>restartPolicy</code> "OnFailure".</p><p>Un Pod ne peut pas être <code>Ready</code> tant que tous les init containers ne se sont pas exécutés avec succès.
Les ports d'un init container ne sont pas agrégés sous un Service. Un Pod qui s'initialise
est dans l'état <code>Pending</code> mais devrait avoir une condition <code>Initialized</code> configurée à "true".</p><p>Si le Pod <a href=#raisons-du-red%C3%A9marrage-d-un-pod>redémarre</a> ou est redémarré, tous les init containers
doivent s'exécuter à nouveau.</p><p>Les changements aux spec d'un init containers sont limités au champ image du conteneur.
Changer le champ image d'un init container équivaut à redémarrer le Pod.</p><p>Puisque les init containers peuvent être redémarrés, réessayés ou ré-exécutés,
leur code doit être idempotent. En particulier, le code qui écrit dans des fichiers sur <code>EmptyDirs</code>
devrait être préparé à la possibilité qu'un fichier de sortie existe déjà.</p><p>Les init containers ont tous les champs d'un conteneur d'application.
Cependant, Kubernetes interdit l'utilisation de <code>readinessProbe</code> parce que les init containers
ne peuvent pas définir une "readiness" distincte de la complétion. Ceci est appliqué lors de la validation.</p><p>L'utilisation de <code>activeDeadlineSeconds</code> sur le Pod et <code>livenessProbe</code> sur le conteneur
permet d'empêcher les init containers d'échouer tout le temps.
La deadline active inclut les init containers.</p><p>Le nom de chaque application et init container dans un Pod doit être unique; une erreur de validation
est générée pour tout conteneur partageant un nom avec un autre.</p><h3 id=ressources>Ressources</h3><p>Étant donné l'ordonnancement et l'exécution des init containers, les règles suivantes s'appliquent pour l'utilisation des ressources :</p><ul><li>La plus haute requête ou limite particulière de ressource définie pour tous les init containers
est la <em>limite/requête d'initialisation effective</em></li><li>La <em>limite/requête effective</em> d'un Pod pour une ressource est la plus haute parmis :<ul><li>la somme de toutes les requêtes/limites des conteneurs d'application pour une ressource</li><li>la limite/requête d'initialisation effective pour une ressource</li></ul></li><li>Le Scheduling est effectué sur la base des requêtes/limites effectives, ce qui signifie
que les init containers peuvent réserver des ressources pour l'initialisation qui ne sont pas utilisées durant le
cycle de vie du Pod.</li><li>La QoS (qualité de service) tierce de la <em>QoS tierce effective</em> d'un Pod est la QoS tierce aussi bien pour les init containers
que pour les conteneurs d'application.</li></ul><p>Les quotas et limites sont appliqués sur la base de la requête/limite effective d'un Pod.</p><p>Les groupes de contrôle au niveau du Pod (<a class=glossary-tooltip title="Un groupe de processus Linux avec des options d'isolation, de suivi, et de limites des ressources." data-toggle=tooltip data-placement=top href='/fr/docs/reference/glossary/?all=true#term-cgroup' target=_blank aria-label=cgroups>cgroups</a>) sont basés sur la requête/limite effective de Pod, la même que
celle du scheduler.</p><h3 id=raisons-du-redémarrage-d-un-pod>Raisons du redémarrage d'un Pod</h3><p>Un Pod peut redémarrer, ce qui cause la ré-exécution des init containers, pour les raisons suivantes :</p><ul><li>Un utilisateur met à jour les spécifications du Pod, ce qui cause le changement de l'image de l'init container.
Tout changement à l'image du init container redémarre le Pod. Les changements au conteneur d'application entraînent seulement le
redémarrage du conteneur d'application.</li><li>Le conteneur d'infrastructure Pod est redémarré. Ceci est peu commun et serait effectué par une personne ayant un accès root aux nœuds.</li><li>Tous les conteneurs dans un Pod sont terminés tandis que <code>restartPolicy</code> est configurée à "Always", ce qui force le redémarrage, et l'enregistrement de complétion du init container a été perdu à cause d'une opération de garbage collection (récupération de mémoire).</li></ul><h2 id=a-suivre>A suivre</h2><ul><li>Lire à propos de la <a href=/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container>création d'un Pod ayant un init container</a></li><li>Apprendre à <a href=/docs/tasks/debug/debug-application/debug-init-containers/>debugger les init containers</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-89637410cacae45a36ab1cc278c482eb>4.2 - Contrôleurs</h1></div><div class=td-content><h1 id=pg-d459b930218774655fa7fd1620625539>4.2.1 - ReplicaSet</h1><p>Un ReplicaSet (ensemble de réplicas en français) a pour but de maintenir un ensemble stable de Pods à un moment donné.
Cet objet est souvent utilisé pour garantir la disponibilité d'un certain nombre identique de Pods.</p><h2 id=comment-un-replicaset-fonctionne>Comment un ReplicaSet fonctionne</h2><p>Un ReplicaSet est défini avec des champs, incluant un selecteur qui spécifie comment identifier les Pods qu'il peut posséder,
un nombre de replicas indiquant le nombre de Pods qu'il doit maintenir et un modèle de Pod spécifiant les données que les
nouveaux Pods que le replicatSet va créer jusqu'au nombre de replicas demandé.</p><p>Un ReplicaSet va atteindre son objectif en créant et supprimant des Pods pour atteindre le nombre de réplicas désirés.
Quand un ReplicaSet a besoin de créer de nouveaux Pods, il utilise alors son Pod template.</p><p>Le lien d'un ReplicaSet à ses Pods est fait par le champ <a href=/docs/concepts/workloads/controllers/garbage-collection/#owners-and-dependents>metadata.ownerReferences</a>,
qui spécifie la ressource de l'objet par lequel il est détenu. Tous les Pods acquis par un ReplicaSet ont leurs propres informations d'identification de leur Replicaset, avec leur propre champ ownerReferences. C'est par ce lien que le ReplicaSet connait l'état des Pods qu'il maintient et agit en fonction de ces derniers.</p><p>Un ReplicaSet identifie des nouveaux Pods à acquérir en utilisant son selecteur.
Si il y a un Pod qui n'a pas de OwnerReference ou que OwnerReference n'est pas un controller et qu'il correspond à un sélecteur de ReplicaSet, il va immédiatement être acquis par ce ReplicaSet.</p><h2 id=quand-utiliser-un-replicaset>Quand utiliser un ReplicaSet ?</h2><p>Un ReplicaSet garantit qu’un nombre spécifié de réplicas de Pod soient exécutés à un moment donné.
Cependant, un Deployment est un concept de plus haut niveau qui gère les ReplicaSets et
fournit des mises à jour déclaratives aux Pods ainsi que de nombreuses autres fonctionnalités utiles.
Par conséquent, nous vous recommandons d’utiliser des Deployments au lieu d’utiliser directement des ReplicaSets, sauf si
vous avez besoin d'une orchestration personnalisée des mises à jour ou si vous n'avez pas besoin de mises à jour.</p><p>Cela signifie qu'il est possible que vous n'ayez jamais besoin de manipuler des objets ReplicaSet :
utilisez plutôt un déploiement et définissez votre application dans la section spec.</p><h2 id=exemple>Exemple</h2><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/controllers/frontend.yaml download=controllers/frontend.yaml><code>controllers/frontend.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-frontend-yaml")' title="Copy controllers/frontend.yaml to clipboard"></img></div><div class=includecode id=controllers-frontend-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># modify replicas according to your case</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-frontend:v3<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Enregistrer ce manifeste dans <code>frontend.yaml</code> et le soumettre à un cluster Kubernetes va créer le ReplicaSet défini et les pods qu’il gère.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>Vous pouvez ensuite récupérer les ReplicaSets actuellement déployés :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>Et voir le frontend que vous avez créé :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME       DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>frontend   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       6s
</span></span></code></pre></div><p>Vous pouvez également vérifier l'état du ReplicaSet :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe rs/frontend
</span></span></code></pre></div><p>Et vous verrez une sortie similaire à :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:		frontend
</span></span><span style=display:flex><span>Namespace:	default
</span></span><span style=display:flex><span>Selector:	<span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend,tier in <span style=color:#666>(</span>frontend<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Labels:		<span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
</span></span><span style=display:flex><span>		<span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
</span></span><span style=display:flex><span>Annotations:	&lt;none&gt;
</span></span><span style=display:flex><span>Replicas:	<span style=color:#666>3</span> current / <span style=color:#666>3</span> desired
</span></span><span style=display:flex><span>Pods Status:	<span style=color:#666>3</span> Running / <span style=color:#666>0</span> Waiting / <span style=color:#666>0</span> Succeeded / <span style=color:#666>0</span> Failed
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:       <span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
</span></span><span style=display:flex><span>                <span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   php-redis:
</span></span><span style=display:flex><span>    Image:      gcr.io/google_samples/gb-frontend:v3
</span></span><span style=display:flex><span>    Port:       80/TCP
</span></span><span style=display:flex><span>    Requests:
</span></span><span style=display:flex><span>      cpu:      100m
</span></span><span style=display:flex><span>      memory:   100Mi
</span></span><span style=display:flex><span>    Environment:
</span></span><span style=display:flex><span>      GET_HOSTS_FROM:   dns
</span></span><span style=display:flex><span>    Mounts:             &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:              &lt;none&gt;
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  FirstSeen    LastSeen    Count    From                SubobjectPath    Type        Reason            Message
</span></span><span style=display:flex><span>  ---------    --------    -----    ----                -------------    --------    ------            -------
</span></span><span style=display:flex><span>  1m           1m          <span style=color:#666>1</span>        <span style=color:#666>{</span>replicaset-controller <span style=color:#666>}</span>             Normal      SuccessfulCreate  Created pod: frontend-qhloh
</span></span><span style=display:flex><span>  1m           1m          <span style=color:#666>1</span>        <span style=color:#666>{</span>replicaset-controller <span style=color:#666>}</span>             Normal      SuccessfulCreate  Created pod: frontend-dnjpy
</span></span><span style=display:flex><span>  1m           1m          <span style=color:#666>1</span>        <span style=color:#666>{</span>replicaset-controller <span style=color:#666>}</span>             Normal      SuccessfulCreate  Created pod: frontend-9si5l
</span></span></code></pre></div><p>Et enfin, vous pourrez afficher les Pods déployés :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get Pods
</span></span></code></pre></div><p>Vous devriez voir des informations sur les Pods avec une sortie similaire à :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-9si5l   1/1       Running   <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-dnjpy   1/1       Running   <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-qhloh   1/1       Running   <span style=color:#666>0</span>          1m
</span></span></code></pre></div><p>Vous pouvez également vérifier que la OwnerReference de ces pods est définie sur le frontend ReplicaSet.
Pour ce faire, récupérez le yaml de l’un des pods :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods frontend-9si5l -o yaml
</span></span></code></pre></div><p>La sortie sera similaire à celle-ci, avec les informations de l'interface ReplicaSet frontend définies dans le champ ownerReferences des métadonnées:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Pod
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  creationTimestamp: 2019-01-31T17:20:41Z
</span></span><span style=display:flex><span>  generateName: frontend-
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    tier: frontend
</span></span><span style=display:flex><span>  name: frontend-9si5l
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  ownerReferences:
</span></span><span style=display:flex><span>  - apiVersion: extensions/v1beta1
</span></span><span style=display:flex><span>    blockOwnerDeletion: <span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>    controller: <span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>    kind: ReplicaSet
</span></span><span style=display:flex><span>    name: frontend
</span></span><span style=display:flex><span>    uid: 892a2330-257c-11e9-aecd-025000000001
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=acquisitions-de-pod-en-dehors-du-template>Acquisitions de Pod en dehors du template</h2><p>Bien que vous puissiez créer des pods manuellement sans problème, il est fortement recommandé de s’assurer que ces pods n'ont pas de
labels correspondant au sélecteur de l’un de vos ReplicaSets. Car un ReplicaSet n’est pas limité
à posséder les pods spécifiés par son modèle - il peut acquérir d’autres pods de la manière spécifiée dans les sections précédentes.</p><p>Prenez l'exemple précédent de ReplicaSet, ainsi que les pods spécifiés dans le manifeste suivant :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/pod-rs.yaml download=pods/pod-rs.yaml><code>pods/pod-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-rs-yaml")' title="Copy pods/pod-rs.yaml to clipboard"></img></div><div class=includecode id=pods-pod-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:2.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:1.0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Ces pods n’ayant pas de contrôleur (ni d’objet) en tant que référence propriétaire, ils correspondent au sélecteur de du ReplicaSet frontend, ils seront donc immédiatement acquis par ce ReplicaSet.</p><p>Supposons que vous créiez les pods une fois le ReplicaSet frontend déployé et qui a déjà déployé ses replicas de Pods initiaux afin de
remplir son exigence de nombre de replicas :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>Les nouveaux pods seront acquis par le ReplicaSet, puis immédiatement terminés car le ReplicaSet dépasserait alors le compte désiré.</p><p>En récupérant les pods :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get Pods
</span></span></code></pre></div><p>La sortie montre que les nouveaux pods sont soit déjà terminés, soit en voie de l'être :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY   STATUS        RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-9si5l   1/1     Running       <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-dnjpy   1/1     Running       <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-qhloh   1/1     Running       <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>pod2             0/1     Terminating   <span style=color:#666>0</span>          4s
</span></span></code></pre></div><p>Cependant, si vous créez d'abord les pods :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>Et puis créez le ReplicaSet :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>Vous verrez que le ReplicaSet a acquis les pods et n'a créé que les nouveaux Pods manquants, conformément à ses spécifications,
jusqu'au nombre souhaité de Pods. En récupérant les Pods :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get Pods
</span></span></code></pre></div><p>La sortie va donner :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY   STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-pxj4r   1/1     Running   <span style=color:#666>0</span>          5s
</span></span><span style=display:flex><span>pod1             1/1     Running   <span style=color:#666>0</span>          13s
</span></span><span style=display:flex><span>pod2             1/1     Running   <span style=color:#666>0</span>          13s
</span></span></code></pre></div><p>De cette manière, un ReplicaSet peut avoir un ensemble de Pods hétérogène.</p><h2 id=écrire-un-manifest-de-replicaset>Écrire un manifest de ReplicaSet</h2><p>Comme avec tous les autres objets API Kubernetes, un ReplicaSet a besoin des champs <code>apiVersion</code>, <code>kind</code> et <code>metadata</code>.
Pour ReplicaSets, l'attribut <code>kind</code> est toujours ReplicaSet.</p><p>Dans Kubernetes 1.9, la version de l'API <code>apps/v1</code> pour le type ReplicaSet est la version actuelle et activée par défaut. La version de l'API <code>apps/v1beta2</code> est obsolète.</p><p>Reportez-vous aux premières lignes de l'exemple <code>frontend.yaml</code> pour obtenir des conseils.</p><p>Un ReplicaSet a également besoin de <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> section</a>.</p><h3 id=pod-template>Pod Template</h3><p>L'attribut <code>.spec.template</code> est un <a href=/docs/concepts/workloads/Pods/pod-overview/#pod-templates>modèle de pod</a> qui requiert d'avoir des labels. Dans notre exemple <code>frontend.yaml</code>, nous avons un label : <code>tier: frontend</code>.
Il faut faire attention à ne pas avoir des selecteurs que d'autres controllers utilisent, afin d'éviter que le ReplicaSet n'adopte ce pod.</p><p>Pour le champ <a href=/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy>restart policy</a>,
<code>.spec.template.spec.restartPolicy</code>, la seule valeur autorisée est <code>Always</code>, qui est la valeur par défaut.</p><h3 id=sélecteur-de-pod>Sélecteur de Pod</h3><p>Le champ <code>.spec.selector</code> est un <a href=/docs/concepts/overview/working-with-objects/labels/>label selector</a>. Tel que discuté
<a href=#how-a-replicaset-works>précédemment</a>, ce sont les labels utilisés pour identifier les Pods potentiels à acquérir. Dans notre
exemple avec <code>frontend.yaml</code>, le sélecteur était :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>matchLabels:
</span></span><span style=display:flex><span>	tier: frontend
</span></span></code></pre></div><p>Dans le ReplicaSet, <code>.spec.template.metadata.labels</code> doit correspondre à <code>spec.selector</code>, ou sinon il sera rejeté par l'API.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Pour 2 ReplicaSets spécifiant le même <code>.spec.selector</code> mais différents <code>.spec.template.metadata.labels</code> et <code>.spec.template.spec</code>, chaque ReplicaSet ignore les pods créés par l'autre ReplicaSet.</div><h3 id=replicas>Replicas</h3><p>Vous pouvez spécifier le nombre de pods à exécuter simultanément en définissant <code>.spec.replicas</code>. Le ReplicaSet va créer/supprimer
ses pods pour correspondre à ce nombre.</p><p>Si vous ne spécifiez pas <code>.spec.replicas</code>, la valeur par défaut est 1.</p><h2 id=travailler-avec-des-replicasets>Travailler avec des ReplicaSets</h2><h3 id=suppression-d-un-replicaset-et-de-ses-pods>Suppression d'un ReplicaSet et de ses pods</h3><p>Pour supprimer un ReplicaSet et tous ses pods, utilisez <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>. The <a href=/docs/concepts/workloads/controllers/garbage-collection/>Garbage collector</a> supprime automatiquement tous les pods associés par défaut.</p><p>Lors de l’utilisation de l’API REST ou de la bibliothèque <code>client-go</code>, vous devez définir <code>propagationPolicy</code> sur <code>Background</code> ou <code>Foreground</code> dans
l'option -d.
Par exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><h3 id=supprimer-juste-un-replicaset>Supprimer juste un ReplicaSet</h3><p>Vous pouvez supprimer un ReplicaSet sans affecter ses pods à l’aide de <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a> avec l'option <code>--cascade=false</code>.
Lorsque vous utilisez l'API REST ou la bibliothèque <code>client-go</code>, vous devez définir <code>propagationPolicy</code> sur <code>Orphan</code>.
Par exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>Une fois l’original supprimé, vous pouvez créer un nouveau ReplicaSet pour le remplacer. Tant que l'ancien et le nouveau <code>.spec.selector</code> sont identiques, le nouveau adoptera les anciens Pods.
Cependant, le ReplicaSet ne fera aucun effort pour que les pods existants correspondent à un nouveau Pod template.
Pour mettre à jour les Pods à une nouvelle spec de manière contrôlée, utilisez un
<a href=/docs/concepts/workloads/controllers/deployment/#creating-a-deployment>Deployment</a>, car les ReplicaSets ne supportent pas de rolling update directement.</p><h3 id=isoler-les-pods-d-un-replicaset>Isoler les pods d'un ReplicaSet</h3><p>Vous pouvez supprimer les pods d'un ReplicaSet en modifiant leurs labels. Cette technique peut être utilisée pour enlever les pods
pour le débogage, récupération de données, etc. Les pods ainsi supprimés seront automatiquement remplacés
(en supposant que le nombre de réplicas n’est pas également modifié).</p><h3 id=scaling-d-un-replicaset>Scaling d'un ReplicaSet</h3><p>Un ReplicaSet peut facilement être scalé en mettant simplement à jour le champ <code>.spec.replicas</code>. Le contrôleur ReplicaSet
garantit que le nombre souhaité de pods avec un sélecteur de label correspondant soient disponibles et opérationnels.</p><h3 id=replicaset-en-tant-que-horizontal-pod-autoscaler-target>ReplicaSet en tant que Horizontal Pod Autoscaler Target</h3><p>Un ReplicaSet peut également être une cible pour
<a href=/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscalers (HPA)</a>.
Un ReplicaSet peut être mis à l'échelle automatiquement par un HPA. Voici un exemple HPA qui cible
le ReplicaSet que nous avons créé dans l'exemple précédent.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/controllers/hpa-rs.yaml download=controllers/hpa-rs.yaml><code>controllers/hpa-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-hpa-rs-yaml")' title="Copy controllers/hpa-rs.yaml to clipboard"></img></div><div class=includecode id=controllers-hpa-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-scaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Enregistrer ce manifeste dans <code>hpa-rs.yaml</code> et le soumettre à un cluster Kubernetes devrait
créer le HPA défini qui scale automatiquement le ReplicaSet cible en fonction de l'utilisation du processeur
des pods répliqués.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/hpa-rs.yaml
</span></span></code></pre></div><p>Vous pouvez aussi utiliser la commande <code>kubectl autoscale</code> pour accomplir la même chose.
(et c'est plus facile !)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale rs frontend --max<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><h2 id=alternatives-au-replicaset>Alternatives au ReplicaSet</h2><h3 id=deployment-recommandé>Deployment (recommandé)</h3><p>Le <a href=/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a> est un object qui peut posséder les ReplicaSets et les mettres à jour ainsi que leurs Pods de façon déclarative, côté serveur et avec des rolling updates.</p><p>Alors que les ReplicaSets peuvent être utilisés indépendamment, ils sont principalement utilisés aujourd'hui par Deployments comme mécanisme pour orchestrer la création, suppresion et mises à jour des Pods.
Lorsque vous utilisez des Deployments, vous n’aurez plus à vous soucier de la gestion des ReplicaSets ainsi créés.
Les déploiements possèdent et gèrent leurs ReplicaSets.
C'est pourquoi il est recommandé d’utiliser les déploiements lorsque vous voulez des ReplicaSets.</p><h3 id=pods-nus>Pods nus</h3><p>Contrairement au cas où un utilisateur a créé directement des pods, un ReplicaSet remplace les pods supprimés ou terminés pour quelque raison que ce soit, par exemple en cas de défaillance d'un nœud ou de maintenance de nœud perturbateur, telle qu'une mise à jour kernel. Pour cette raison, nous vous recommandons d'utiliser un ReplicaSet même si votre application ne nécessite qu'un seul pod. Pensez-y de la même manière qu’un superviseur de processus, mais il supervise plusieurs pods sur plusieurs nœuds au lieu de processus individuels sur un seul nœud. Un ReplicaSet délègue les redémarrages de conteneurs locaux à un agent du nœud (par exemple, Kubelet ou Docker).</p><h3 id=job>Job</h3><p>Utilisez un <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/><code>Job</code></a> au lieu d'un ReplicaSet pour les pods qui doivent se terminer seuls
(c'est à dire des batch jobs).</p><h3 id=daemonset>DaemonSet</h3><p>Utilisez un <a href=/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a> au lieu d’un ReplicaSet pour les pods qui fournissent une
fonction au niveau du noeud, comme le monitoring ou la gestion des logs de ce noeud. Ces pods ont une durée de vie qui est liée
durée de vie d’une machine : le pod doit être en cours d’exécution sur la machine avant le démarrage des autres Pods et sont
sûrs de se terminer lorsque la machine est prête à être redémarrée/arrêtée.</p><h3 id=replicationcontroller>ReplicationController</h3><p>Les ReplicaSets sont les successeurs de <a href=/docs/concepts/workloads/controllers/replicationcontroller/><em>ReplicationControllers</em></a>.
Les deux servent le même objectif et se comportent de la même manière, à la différence près que ReplicationController ne prend pas en charge les
les exigences de sélecteur décrites dans le <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>labels user guide</a>.
En tant que tels, les ReplicaSets sont préférés aux ReplicationControllers.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a2dc0393e0c4079e1c504b6429844e86>4.2.2 - Déploiements</h1><p>Un <em>Deployment</em> (déploiement en français) fournit des mises à jour déclaratives pour <a href=/fr/docs/concepts/workloads/pods/pod/>Pods</a> et <a href=/fr/docs/concepts/workloads/controllers/replicaset/>ReplicaSets</a>.</p><p>Vous décrivez un <em>état désiré</em> dans un déploiement et le <a class=glossary-tooltip title="Boucle de contrôle surveillant l'état partagé du cluster à travers l'apiserver et effectuant des changements en essayant de déplacer l'état actuel vers l'état désiré." data-toggle=tooltip data-placement=top href=/docs/admin/kube-controller-manager/ target=_blank aria-label=controlleur>controlleur</a> déploiement change l'état réel à l'état souhaité à un rythme contrôlé.
Vous pouvez définir des Deployments pour créer de nouveaux ReplicaSets, ou pour supprimer des déploiements existants et adopter toutes leurs ressources avec de nouveaux déploiements.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Ne gérez pas les ReplicaSets appartenant à un Deployment.
Pensez à ouvrir un ticket dans le dépot Kubernetes principal si votre cas d'utilisation n'est pas traité ci-dessous.</div><h2 id=cas-d-utilisation>Cas d'utilisation</h2><p>Voici des cas d'utilisation typiques pour les déploiements:</p><ul><li><a href=#cr%C3%A9ation-dun-d%C3%A9ploiement>Créer un déploiement pour déployer un ReplicaSet</a>.
Le ReplicaSet crée des pods en arrière-plan.
Vérifiez l'état du déploiement pour voir s'il réussit ou non.</li><li><a href=#mise-%C3%A0-jour-dun-d%C3%A9ploiement>Déclarez le nouvel état des Pods</a> en mettant à jour le PodTemplateSpec du déploiement.
Un nouveau ReplicaSet est créé et le déploiement gère le déplacement des pods de l'ancien ReplicaSet vers le nouveau à un rythme contrôlé.
Chaque nouveau ReplicaSet met à jour la révision du déploiement.</li><li><a href=#annulation-dun-d%C3%A9ploiement>Revenir à une révision de déploiement antérieure</a> si l'état actuel du déploiement n'est pas stable.
Chaque restauration met à jour la révision du déploiement.</li><li><a href=#mise-%C3%A0-l%C3%A9chelle-dun-d%C3%A9ploiement>Augmentez le déploiement pour traiter plus de charge</a>.</li><li><a href=#pause-et-reprise-dun-d%C3%A9ploiement>Suspendre le déploiement</a> d'appliquer plusieurs correctifs à son PodTemplateSpec, puis de le reprendre pour démarrer un nouveau déploiement.</li><li><a href=#statut-de-d%C3%A9ploiement>Utiliser l'état du déploiement</a> comme indicateur qu'un déploiement est bloqué.</li><li><a href=#politique-de-nettoyage>Nettoyer les anciens ReplicaSets</a> dont vous n'avez plus besoin.</li></ul><h2 id=création-d-un-déploiement>Création d'un déploiement</h2><p>Voici un exemple de déploiement.
Il crée un ReplicaSet pour faire apparaître trois pods <code>nginx</code>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/controllers/nginx-deployment.yaml download=controllers/nginx-deployment.yaml><code>controllers/nginx-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-nginx-deployment-yaml")' title="Copy controllers/nginx-deployment.yaml to clipboard"></img></div><div class=includecode id=controllers-nginx-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dans cet exemple:</p><ul><li><p>Un déploiement nommé <code>nginx-deployment</code> est créé, indiqué par le champ <code>.metadata.name</code>.</p></li><li><p>Le déploiement crée trois pods répliqués, indiqués par le champ <code>replicas</code>.</p></li><li><p>Le champ <code>selector</code> définit comment le déploiement trouve les pods à gérer.
Dans ce cas, vous sélectionnez simplement un label définie dans le template de pod (<code>app:nginx</code>).
Cependant, des règles de sélection plus sophistiquées sont possibles, tant que le modèle de pod satisfait lui-même la règle.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le champ <code>matchLabels</code> est une table de hash {clé, valeur}.
Une seule {clé, valeur} dans la table <code>matchLabels</code> est équivalente à un élément de <code>matchExpressions</code>, dont le champ clé est "clé", l'opérateur est "In" et le tableau de valeurs contient uniquement "valeur".
Toutes les exigences, à la fois de <code>matchLabels</code> et de <code>matchExpressions</code>, doivent être satisfaites pour correspondre.</div></li><li><p>Le champ <code>template</code> contient les sous-champs suivants:</p><ul><li>Les Pods reçoivent le label <code>app:nginx</code> dans le champ <code>labels</code>.</li><li>La spécification du template de pod dans le champ <code>.template.spec</code>, indique que les pods exécutent un conteneur, <code>nginx</code>, qui utilise l'image <code>nginx</code> <a href=https://hub.docker.com/>Docker Hub</a> à la version 1.7.9.</li><li>Créez un conteneur et nommez-le <code>nginx</code> en utilisant le champ <code>name</code>.</li></ul></li></ul><p>Suivez les étapes ci-dessous pour créer le déploiement ci-dessus:</p><p>Avant de commencer, assurez-vous que votre cluster Kubernetes est opérationnel.</p><ol><li><p>Créez le déploiement en exécutant la commande suivante:</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous pouvez spécifier l'indicateur <code>--record</code> pour écrire la commande exécutée dans l'annotation de ressource <code>kubernetes.io/change-cause</code>.
C'est utile pour une future introspection.
Par exemple, pour voir les commandes exécutées dans chaque révision de déploiement.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml
</span></span></code></pre></div></li><li><p>Exécutez <code>kubectl get deployments</code> pour vérifier si le déploiement a été créé.
Si le déploiement est toujours en cours de création, la sortie est similaire à:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   0/3     <span style=color:#666>0</span>            <span style=color:#666>0</span>           1s
</span></span></code></pre></div><p>Lorsque vous inspectez les déploiements de votre cluster, les champs suivants s'affichent:</p><ul><li><code>NAME</code> répertorie les noms des déploiements dans le cluster.</li><li><code>DESIRED</code> affiche le nombre souhaité de <em>répliques</em> de l'application, que vous définissez lorsque vous créez le déploiement.
C'est l'<em>état désiré</em>.</li><li><code>CURRENT</code> affiche le nombre de réplicas en cours d'exécution.</li><li><code>UP-TO-DATE</code> affiche le nombre de réplicas qui ont été mises à jour pour atteindre l'état souhaité.</li><li><code>AVAILABLE</code> affiche le nombre de réplicas de l'application disponibles pour vos utilisateurs.</li><li><code>AGE</code> affiche la durée d'exécution de l'application.</li></ul><p>Notez que le nombre de réplicas souhaitées est de 3 selon le champ <code>.spec.replicas</code>.</p></li><li><p>Pour voir l'état du déploiement, exécutez:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Waiting <span style=color:#a2f;font-weight:700>for</span> rollout to finish: <span style=color:#666>2</span> out of <span style=color:#666>3</span> new replicas have been updated...
</span></span><span style=display:flex><span>deployment <span style=color:#b44>&#34;nginx-deployment&#34;</span> successfully rolled out
</span></span></code></pre></div></li><li><p>Exécutez à nouveau <code>kubectl get deployments</code> quelques secondes plus tard.
La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   3/3     3            3           18s
</span></span></code></pre></div><p>Notez que le déploiement a créé les trois répliques et que toutes les répliques sont à jour (elles contiennent le dernier modèle de pod) et disponibles.</p></li><li><p>Pour voir le ReplicaSet (<code>rs</code>) créé par le déploiement, exécutez <code>kubectl get rs</code>.
La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>nginx-deployment-75675f5897   3         3         3       18s
</span></span></code></pre></div><p>Notez que le nom du ReplicaSet est toujours formaté comme: <code>[DEPLOYMENT-NAME]-[RANDOM-STRING]</code>.
La chaîne aléatoire est générée aléatoirement et utilise le pod-template-hash comme graine.</p></li><li><p>Pour voir les labels générées automatiquement pour chaque Pod, exécutez <code>kubectl get pods --show-labels</code>.
La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                                READY     STATUS    RESTARTS   AGE       LABELS
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-7ci7o   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-kzszj   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-qqcnn   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
</span></span></code></pre></div></li></ol><p>Le ReplicaSet créé garantit qu'il y a trois pods <code>nginx</code>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous devez spécifier un sélecteur approprié et des labels de template de pod dans un déploiement (dans ce cas, <code>app: nginx</code>).
Ne superposez pas les étiquettes ou les sélecteurs avec d'autres contrôleurs (y compris d'autres déploiements et StatefulSets).
Kubernetes n'empêche pas les chevauchements de noms, et si plusieurs contrôleurs ont des sélecteurs qui se chevauchent, ces contrôleurs peuvent entrer en conflit et se comporter de façon inattendue.</div><h3 id=étiquette-pod-template-hash>Étiquette pod-template-hash</h3><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Ne modifiez pas ce label.</div><p>Le label <code>pod-template-hash</code> est ajoutée par le contrôleur de déploiement à chaque ReplicaSet créé ou adopté par un déploiement.</p><p>Ce label garantit que les ReplicaSets enfants d'un déploiement ne se chevauchent pas.
Il est généré en hachant le <code>PodTemplate</code> du ReplicaSet et en utilisant le hachage résultant comme valeur de label qui est ajoutée au sélecteur ReplicaSet, aux labels de template de pod et dans tous les pods existants que le ReplicaSet peut avoir.</p><h2 id=mise-à-jour-d-un-déploiement>Mise à jour d'un déploiement</h2><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le re-déploiement d'un déploiement est déclenché si et seulement si le modèle de pod du déploiement (c'est-à-dire <code>.spec.template</code>) est modifié, par exemple si les labels ou les images de conteneur du template sont mis à jour.
D'autres mises à jour, telles que la mise à l'échelle du déploiement, ne déclenchent pas de rollout.</div><p>Suivez les étapes ci-dessous pour mettre à jour votre déploiement:</p><ol><li><p>Mettons à jour les pods nginx pour utiliser l'image <code>nginx: 1.9.1</code> au lieu de l'image <code>nginx: 1.7.9</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl --record deployment.apps/nginx-deployment <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.9.1
</span></span></code></pre></div><p>ou utilisez la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.9.1 --record
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment image updated
</span></span></code></pre></div><p>Alternativement, vous pouvez <code>éditer</code> le déploiement et changer <code>.spec.template.spec.containers[0].image</code> de <code>nginx: 1.7.9</code> à <code>nginx: 1.9.1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment edited
</span></span></code></pre></div></li><li><p>Pour voir l'état du déploiement, exécutez:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
</span></span></code></pre></div><p>ou</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment &#34;nginx-deployment&#34; successfully rolled out
</span></span></code></pre></div></li></ol><p>Obtenez plus de détails sur votre déploiement mis à jour:</p><ul><li><p>Une fois le déploiement réussi, vous pouvez afficher le déploiement en exécutant <code>kubectl get deployments</code>.
La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   3/3     3            3           36s
</span></span></code></pre></div></li><li><p>Exécutez <code>kubectl get rs</code> pour voir que le déploiement a mis à jour les pods en créant un nouveau ReplicaSet et en le redimensionnant jusqu'à 3 replicas, ainsi qu'en réduisant l'ancien ReplicaSet à 0 réplicas.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>nginx-deployment-1564180365   3         3         3       6s
</span></span><span style=display:flex><span>nginx-deployment-2035384211   0         0         0       36s
</span></span></code></pre></div></li><li><p>L'exécution de <code>kubectl get pods</code> ne devrait désormais afficher que les nouveaux pods:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                                READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>nginx-deployment-1564180365-khku8   1/1       Running   0          14s
</span></span><span style=display:flex><span>nginx-deployment-1564180365-nacti   1/1       Running   0          14s
</span></span><span style=display:flex><span>nginx-deployment-1564180365-z9gth   1/1       Running   0          14s
</span></span></code></pre></div><p>La prochaine fois que vous souhaitez mettre à jour ces pods, il vous suffit de mettre à jour le modèle de pod de déploiement à nouveau.</p><p>Le déploiement garantit que seul un certain nombre de pods sont en panne pendant leur mise à jour.
Par défaut, il garantit qu'au moins 75% du nombre souhaité de pods sont en place (25% max indisponible).</p><p>Le déploiement garantit également que seul un certain nombre de pods sont créés au-dessus du nombre souhaité de pods.
Par défaut, il garantit qu'au plus 125% du nombre de pods souhaité sont en hausse (surtension maximale de 25%).</p><p>Par exemple, si vous regardez attentivement le déploiement ci-dessus, vous verrez qu'il a d'abord créé un nouveau pod, puis supprimé certains anciens pods et en a créé de nouveaux.
Il ne tue pas les anciens Pods tant qu'un nombre suffisant de nouveaux Pods n'est pas apparu, et ne crée pas de nouveaux Pods tant qu'un nombre suffisant de Pods anciens n'a pas été tué.
Il s'assure qu'au moins 2 pods sont disponibles et qu'au maximum 4 pods au total sont disponibles.</p></li><li><p>Obtenez les détails de votre déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployments
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:                   nginx-deployment
</span></span><span style=display:flex><span>Namespace:              default
</span></span><span style=display:flex><span>CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
</span></span><span style=display:flex><span>Labels:                 app=nginx
</span></span><span style=display:flex><span>Annotations:            deployment.kubernetes.io/revision=2
</span></span><span style=display:flex><span>Selector:               app=nginx
</span></span><span style=display:flex><span>Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
</span></span><span style=display:flex><span>StrategyType:           RollingUpdate
</span></span><span style=display:flex><span>MinReadySeconds:        0
</span></span><span style=display:flex><span>RollingUpdateStrategy:  25% max unavailable, 25% max surge
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>    Labels:  app=nginx
</span></span><span style=display:flex><span>    Containers:
</span></span><span style=display:flex><span>    nginx:
</span></span><span style=display:flex><span>        Image:        nginx:1.9.1
</span></span><span style=display:flex><span>        Port:         80/TCP
</span></span><span style=display:flex><span>        Environment:  &lt;none&gt;
</span></span><span style=display:flex><span>        Mounts:       &lt;none&gt;
</span></span><span style=display:flex><span>    Volumes:        &lt;none&gt;
</span></span><span style=display:flex><span>    Conditions:
</span></span><span style=display:flex><span>    Type           Status  Reason
</span></span><span style=display:flex><span>    ----           ------  ------
</span></span><span style=display:flex><span>    Available      True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>    Progressing    True    NewReplicaSetAvailable
</span></span><span style=display:flex><span>    OldReplicaSets:  &lt;none&gt;
</span></span><span style=display:flex><span>    NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)
</span></span><span style=display:flex><span>    Events:
</span></span><span style=display:flex><span>    Type    Reason             Age   From                   Message
</span></span><span style=display:flex><span>    ----    ------             ----  ----                   -------
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
</span></span><span style=display:flex><span>    Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
</span></span></code></pre></div><p>Ici, vous voyez que lorsque vous avez créé le déploiement pour la première fois, il a créé un ReplicaSet (nginx-deployment-2035384211) et l'a mis à l'échelle directement jusqu'à 3 réplicas.
Lorsque vous avez mis à jour le déploiement, il a créé un nouveau ReplicaSet (nginx-deployment-1564180365) et l'a mis à l'échelle jusqu'à 1, puis a réduit l'ancien ReplicaSet à 2, de sorte qu'au moins 2 pods étaient disponibles et au plus 4 pods ont été créés à chaque fois.
Il a ensuite poursuivi la montée en puissance du nouveau et de l'ancien ReplicaSet, avec la même stratégie de mise à jour continue.
Enfin, vous aurez 3 réplicas disponibles dans le nouveau ReplicaSet, et l'ancien ReplicaSet est réduit à 0.</p></li></ul><h3 id=rollover>Rollover (alias plusieurs mises à jour en vol)</h3><p>Chaque fois qu'un nouveau déploiement est observé par le contrôleur de déploiement, un ReplicaSet est créé pour afficher les pods souhaités.
Si le déploiement est mis à jour, le ReplicaSet existant qui contrôle les pods dont les étiquettes correspondent à <code>.spec.selector</code> mais dont le modèle ne correspond pas à <code>.spec.template</code> est réduit.
Finalement, le nouveau ReplicaSet est mis à l'échelle à <code>.spec.replicas</code> et tous les anciens ReplicaSets sont mis à l'échelle à 0.</p><p>Si vous mettez à jour un déploiement alors qu'un déploiement existant est en cours, le déploiement crée un nouveau ReplicaSet conformément à la mise à jour et commence à le mettre à l'échelle, et arrête de mettre à jour le ReplicaSet qu'il augmentait précédemment - il l'ajoutera à sa liste de anciens ReplicaSets et commencera à le réduire.</p><p>Par exemple, supposons que vous créez un déploiement pour créer 5 répliques de <code>nginx: 1.7.9</code>, puis mettez à jour le déploiement pour créer 5 répliques de <code>nginx: 1.9.1</code>, alors que seulement 3 répliques de <code>nginx:1.7.9</code> avait été créés.
Dans ce cas, le déploiement commence immédiatement à tuer les 3 pods <code>nginx: 1.7.9</code> qu'il avait créés et commence à créer des pods <code>nginx: 1.9.1</code>.
Il n'attend pas que les 5 répliques de <code>nginx: 1.7.9</code> soient créées avant de changer de cap.</p><h3 id=mises-à-jour-du-sélecteur-de-labels>Mises à jour du sélecteur de labels</h3><p>Il est généralement déconseillé de mettre à jour le sélecteur de labels et il est suggéré de planifier vos sélecteurs à l'avance.
Dans tous les cas, si vous devez effectuer une mise à jour du sélecteur de labels, soyez très prudent et assurez-vous d'avoir saisi toutes les implications.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Dans la version d'API <code>apps/v1</code>, le sélecteur de label d'un déploiement est immuable après sa création.</div><ul><li>Les ajouts de sélecteur nécessitent que les labels de template de pod dans la spécification de déploiement soient également mises à jour avec les nouveaux labels, sinon une erreur de validation est renvoyée.
Cette modification ne se chevauche pas, ce qui signifie que le nouveau sélecteur ne sélectionne pas les ReplicaSets et les pods créés avec l'ancien sélecteur, ce qui entraîne la perte de tous les anciens ReplicaSets et la création d'un nouveau ReplicaSet.</li><li>Les mises à jour du sélecteur modifient la valeur existante dans une clé de sélection - entraînent le même comportement que les ajouts.</li><li>La suppression de sélecteur supprime une clé existante du sélecteur de déploiement - ne nécessite aucune modification dans les labels du template de pod.
Les ReplicaSets existants ne sont pas orphelins et aucun nouveau ReplicaSet n'est créé, mais notez que le label supprimé existe toujours dans tous les Pods et ReplicaSets existants.</li></ul><h2 id=annulation-d-un-déploiement>Annulation d'un déploiement</h2><p>Parfois, vous souhaiterez peut-être annuler un déploiement; par exemple, lorsque le déploiement n'est pas stable, comme en cas d'échecs à répétition (CrashLoopBackOff).
Par défaut, tout l'historique des déploiements d'un déploiement est conservé dans le système afin que vous puissiez le restaurer à tout moment (vous pouvez le modifier en modifiant la limite de l'historique des révisions).</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> La révision d'un déploiement est créée lorsque le déploiement d'un déploiement est déclenché.
Cela signifie qu'une nouvelle révision est créée si et seulement si le template de pod de déploiement (<code>.spec.template</code>) est modifié, par exemple si vous mettez à jour les labels ou les images de conteneur du template.
D'autres mises à jour, telles que la mise à l'échelle du déploiement, ne créent pas de révision de déploiement, de sorte que vous puissiez faciliter la mise à l'échelle manuelle ou automatique simultanée.
Cela signifie que lorsque vous revenez à une révision antérieure, seule la partie du template de pod de déploiement est annulée.</div><ul><li><p>Supposons que vous ayez fait une faute de frappe lors de la mise à jour du déploiement, en mettant le nom de l'image sous la forme <code>nginx:1.91</code> au lieu de <code>nginx: 1.9.1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.91 --record<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment image updated
</span></span></code></pre></div></li><li><p>Le déploiement est bloqué.
Vous pouvez le vérifier en vérifiant l'état du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
</span></span></code></pre></div></li><li><p>Appuyez sur Ctrl-C pour arrêter la surveillance d'état de déploiement ci-dessus.
Pour plus d'informations sur les déploiements bloqués, <a href=#deployment-status>en savoir plus ici</a>.</p></li><li><p>Vous voyez que le nombre d'anciens réplicas (<code>nginx-deployment-1564180365</code> et <code>nginx-deployment-2035384211</code>) est 2, et les nouveaux réplicas (<code>nginx-deployment-3066724191</code>) est 1.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>nginx-deployment-1564180365   3         3         3       25s
</span></span><span style=display:flex><span>nginx-deployment-2035384211   0         0         0       36s
</span></span><span style=display:flex><span>nginx-deployment-3066724191   1         1         0       6s
</span></span></code></pre></div></li><li><p>En regardant les pods créés, vous voyez que 1 pod créé par le nouveau ReplicaSet est coincé dans une boucle pour récupérer son image:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                                READY     STATUS             RESTARTS   AGE
</span></span><span style=display:flex><span>nginx-deployment-1564180365-70iae   1/1       Running            0          25s
</span></span><span style=display:flex><span>nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
</span></span><span style=display:flex><span>nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
</span></span><span style=display:flex><span>nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le contrôleur de déploiement arrête automatiquement le mauvais déploiement et arrête la mise à l'échelle du nouveau ReplicaSet.
Cela dépend des paramètres rollingUpdate (<code>maxUnavailable</code> spécifiquement) que vous avez spécifiés.
Kubernetes définit par défaut la valeur à 25%.</div></li><li><p>Obtenez la description du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:           nginx-deployment
</span></span><span style=display:flex><span>Namespace:      default
</span></span><span style=display:flex><span>CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
</span></span><span style=display:flex><span>Labels:         app=nginx
</span></span><span style=display:flex><span>Selector:       app=nginx
</span></span><span style=display:flex><span>Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable
</span></span><span style=display:flex><span>StrategyType:       RollingUpdate
</span></span><span style=display:flex><span>MinReadySeconds:    0
</span></span><span style=display:flex><span>RollingUpdateStrategy:  25% max unavailable, 25% max surge
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:  app=nginx
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   nginx:
</span></span><span style=display:flex><span>    Image:        nginx:1.91
</span></span><span style=display:flex><span>    Port:         80/TCP
</span></span><span style=display:flex><span>    Host Port:    0/TCP
</span></span><span style=display:flex><span>    Environment:  &lt;none&gt;
</span></span><span style=display:flex><span>    Mounts:       &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:        &lt;none&gt;
</span></span><span style=display:flex><span>Conditions:
</span></span><span style=display:flex><span>  Type           Status  Reason
</span></span><span style=display:flex><span>  ----           ------  ------
</span></span><span style=display:flex><span>  Available      True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>  Progressing    True    ReplicaSetUpdated
</span></span><span style=display:flex><span>OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)
</span></span><span style=display:flex><span>NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  FirstSeen LastSeen    Count   From                    SubObjectPath   Type        Reason              Message
</span></span><span style=display:flex><span>  --------- --------    -----   ----                    -------------   --------    ------              -------
</span></span><span style=display:flex><span>  1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
</span></span><span style=display:flex><span>  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
</span></span><span style=display:flex><span>  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
</span></span><span style=display:flex><span>  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
</span></span><span style=display:flex><span>  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1
</span></span><span style=display:flex><span>  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
</span></span><span style=display:flex><span>  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
</span></span><span style=display:flex><span>  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
</span></span></code></pre></div><p>Pour résoudre ce problème, vous devez revenir à une version précédente de Deployment qui est stable.</p></li></ul><h3 id=vérification-de-l-historique-de-déploiement-d-un-déploiement>Vérification de l'historique de déploiement d'un déploiement</h3><p>Suivez les étapes ci-dessous pour vérifier l'historique de déploiement:</p><ol><li><p>Tout d'abord, vérifiez les révisions de ce déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployments &#34;nginx-deployment&#34;
</span></span><span style=display:flex><span>REVISION    CHANGE-CAUSE
</span></span><span style=display:flex><span>1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml --record=true
</span></span><span style=display:flex><span>2           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true
</span></span><span style=display:flex><span>3           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.91 --record=true
</span></span></code></pre></div><p><code>CHANGE-CAUSE</code> est copié de l'annotation de déploiement <code>kubernetes.io/change-cause</code> dans ses révisions lors de la création.
Vous pouvez spécifier le message<code>CHANGE-CAUSE</code> en:</p><ul><li>Annoter le déploiement avec <code>kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause="image mis à jour en 1.9.1"</code></li><li>Ajoutez le drapeau <code>--record</code> pour enregistrer la commande <code>kubectl</code> qui apporte des modifications à la ressource.</li><li>Modification manuelle du manifeste de la ressource.</li></ul></li><li><p>Pour voir les détails de chaque révision, exécutez:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment --revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployments &#34;nginx-deployment&#34; revision 2
</span></span><span style=display:flex><span>  Labels:       app=nginx
</span></span><span style=display:flex><span>          pod-template-hash=1159050644
</span></span><span style=display:flex><span>  Annotations:  kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   nginx:
</span></span><span style=display:flex><span>    Image:      nginx:1.9.1
</span></span><span style=display:flex><span>    Port:       80/TCP
</span></span><span style=display:flex><span>     QoS Tier:
</span></span><span style=display:flex><span>        cpu:      BestEffort
</span></span><span style=display:flex><span>        memory:   BestEffort
</span></span><span style=display:flex><span>    Environment Variables:      &lt;none&gt;
</span></span><span style=display:flex><span>  No volumes.
</span></span></code></pre></div></li></ol><h3 id=revenir-à-une-révision-précédente>Revenir à une révision précédente</h3><p>Suivez les étapes ci-dessous pour restaurer le déploiement de la version actuelle à la version précédente, qui est la version 2.</p><ol><li><p>Vous avez maintenant décidé d'annuler le déploiement actuel et le retour à la révision précédente:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment
</span></span></code></pre></div><p>Alternativement, vous pouvez revenir à une révision spécifique en la spécifiant avec <code>--to-revision</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment
</span></span></code></pre></div><p>Pour plus de détails sur les commandes liées au déploiement, lisez <a href=/docs/reference/generated/kubectl/kubectl-commands#rollout><code>kubectl rollout</code></a>.</p><p>Le déploiement est maintenant rétabli à une précédente révision stable.
Comme vous pouvez le voir, un événement <code>DeploymentRollback</code> pour revenir à la révision 2 est généré à partir du contrôleur de déploiement.</p></li><li><p>Vérifiez si la restauration a réussi et que le déploiement s'exécute comme prévu, exécutez:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   3/3     3            3           30m
</span></span></code></pre></div></li><li><p>Obtenez la description du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:                   nginx-deployment
</span></span><span style=display:flex><span>Namespace:              default
</span></span><span style=display:flex><span>CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
</span></span><span style=display:flex><span>Labels:                 app=nginx
</span></span><span style=display:flex><span>Annotations:            deployment.kubernetes.io/revision=4
</span></span><span style=display:flex><span>                        kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true
</span></span><span style=display:flex><span>Selector:               app=nginx
</span></span><span style=display:flex><span>Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
</span></span><span style=display:flex><span>StrategyType:           RollingUpdate
</span></span><span style=display:flex><span>MinReadySeconds:        0
</span></span><span style=display:flex><span>RollingUpdateStrategy:  25% max unavailable, 25% max surge
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:  app=nginx
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   nginx:
</span></span><span style=display:flex><span>    Image:        nginx:1.9.1
</span></span><span style=display:flex><span>    Port:         80/TCP
</span></span><span style=display:flex><span>    Host Port:    0/TCP
</span></span><span style=display:flex><span>    Environment:  &lt;none&gt;
</span></span><span style=display:flex><span>    Mounts:       &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:        &lt;none&gt;
</span></span><span style=display:flex><span>Conditions:
</span></span><span style=display:flex><span>  Type           Status  Reason
</span></span><span style=display:flex><span>  ----           ------  ------
</span></span><span style=display:flex><span>  Available      True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>  Progressing    True    NewReplicaSetAvailable
</span></span><span style=display:flex><span>OldReplicaSets:  &lt;none&gt;
</span></span><span style=display:flex><span>NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type    Reason              Age   From                   Message
</span></span><span style=display:flex><span>  ----    ------              ----  ----                   -------
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
</span></span><span style=display:flex><span>  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment &#34;nginx-deployment&#34; to revision 2
</span></span><span style=display:flex><span>  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
</span></span></code></pre></div></li></ol><h2 id=mise-à-l-échelle-d-un-déploiement>Mise à l'échelle d'un déploiement</h2><p>Vous pouvez mettre à l'échelle un déploiement à l'aide de la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment.v1.apps/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment scaled
</span></span></code></pre></div><p>En supposant que l'<a href=/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>horizontal Pod autoscaling</a> est activé dans votre cluster, vous pouvez configurer une mise à l'échelle automatique pour votre déploiement et choisir le nombre minimum et maximum de pods que vous souhaitez exécuter en fonction de l'utilisation du processeur de vos pods existants.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment.v1.apps/nginx-deployment --min<span style=color:#666>=</span><span style=color:#666>10</span> --max<span style=color:#666>=</span><span style=color:#666>15</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>80</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment scaled
</span></span></code></pre></div><h3 id=mise-à-l-échelle-proportionnelle>Mise à l'échelle proportionnelle</h3><p>Les déploiements RollingUpdate prennent en charge l'exécution simultanée de plusieurs versions d'une application.
Lorsque vous ou un autoscaler mettez à l'échelle un déploiement RollingUpdate qui se trouve au milieu d'un déploiement (en cours ou en pause), le contrôleur de déploiement équilibre les réplicas supplémentaires dans les ReplicaSets actifs existants (ReplicaSets avec pods) afin d'atténuer le risque.
Ceci est appelé <em>mise à l'échelle proportionnelle</em>.</p><p>Par exemple, vous exécutez un déploiement avec 10 réplicas, <a href=#max-surge>maxSurge</a>=3, et <a href=#max-unavailable>maxUnavailable</a>=2.</p><ul><li><p>Assurez-vous que les 10 réplicas de votre déploiement sont en cours d'exécution.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment     10        10        10           10          50s
</span></span></code></pre></div></li><li><p>Vous effectuez une mise à jour vers une nouvelle image qui s'avère impossible à résoudre depuis l'intérieur du cluster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:sometag
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment image updated
</span></span></code></pre></div></li><li><p>La mise à jour de l'image démarre un nouveau déploiement avec ReplicaSet <code>nginx-deployment-1989198191</code>, mais elle est bloquée en raison de l'exigence <code>maxUnavailable</code> que vous avez mentionnée ci-dessus.
Découvrez l'état du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-deployment-1989198191   5         5         0         9s
</span></span><span style=display:flex><span>nginx-deployment-618515232    8         8         8         1m
</span></span></code></pre></div></li><li><p>Ensuite, une nouvelle demande de mise à l'échelle pour le déploiement arrive.
La mise à l'échelle automatique incrémente les réplicas de déploiement à 15.
Le contrôleur de déploiement doit décider où ajouter ces 5 nouvelles répliques.
Si vous n'utilisiez pas la mise à l'échelle proportionnelle, les 5 seraient ajoutés dans le nouveau ReplicaSet.
Avec une mise à l'échelle proportionnelle, vous répartissez les répliques supplémentaires sur tous les ReplicaSets.
Des proportions plus importantes vont aux ReplicaSets avec le plus de répliques et des proportions plus faibles vont aux ReplicaSets avec moins de replicas.
Tous les restes sont ajoutés au ReplicaSet avec le plus de répliques.
Les ReplicaSets avec zéro réplicas ne sont pas mis à l'échelle.</p></li></ul><p>Dans notre exemple ci-dessus, 3 répliques sont ajoutées à l'ancien ReplicaSet et 2 répliques sont ajoutées au nouveau ReplicaSet.
Le processus de déploiement devrait éventuellement déplacer toutes les répliques vers le nouveau ReplicaSet, en supposant que les nouvelles répliques deviennent saines.
Pour confirmer cela, exécutez:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment     15        18        7            8           7m
</span></span></code></pre></div><p>Le statut de déploiement confirme la façon dont les réplicas ont été ajoutés à chaque ReplicaSet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-deployment-1989198191   7         7         0         7m
</span></span><span style=display:flex><span>nginx-deployment-618515232    11        11        11        7m
</span></span></code></pre></div><h2 id=pause-et-reprise-d-un-déploiement>Pause et reprise d'un déploiement</h2><p>Vous pouvez suspendre un déploiement avant de déclencher une ou plusieurs mises à jour, puis le reprendre.
Cela vous permet d'appliquer plusieurs correctifs entre la pause et la reprise sans déclencher de déploiements inutiles.</p><ul><li><p>Par exemple, avec un déploiement qui vient d'être créé:
Obtenez les détails du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx     3         3         3            3           1m
</span></span></code></pre></div><p>Obtenez le statut de déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-2142116321   3         3         3         1m
</span></span></code></pre></div></li><li><p>Mettez le déploiement en pause en exécutant la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout pause deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment paused
</span></span></code></pre></div></li><li><p>Mettez ensuite à jour l'image du déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.9.1
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment image updated
</span></span></code></pre></div></li><li><p>Notez qu'aucun nouveau déploiement n'a commencé:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployments &#34;nginx&#34;
</span></span><span style=display:flex><span>REVISION  CHANGE-CAUSE
</span></span><span style=display:flex><span>1   &lt;none&gt;
</span></span></code></pre></div></li><li><p>Obtenez l'état de déploiement pour vous assurer que le déploiement est correctement mis à jour:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-2142116321   3         3         3         2m
</span></span></code></pre></div></li><li><p>Vous pouvez effectuer autant de mises à jour que vous le souhaitez, par exemple, mettre à jour les ressources qui seront utilisées:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> resources deployment.v1.apps/nginx-deployment -c<span style=color:#666>=</span>nginx --limits<span style=color:#666>=</span><span style=color:#b8860b>cpu</span><span style=color:#666>=</span>200m,memory<span style=color:#666>=</span>512Mi
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment resource requirements updated
</span></span></code></pre></div><p>L'état initial du déploiement avant de le suspendre continuera de fonctionner, mais les nouvelles mises à jour du déploiement n'auront aucun effet tant que le déploiement sera suspendu.</p></li><li><p>Finalement, reprenez le déploiement et observez un nouveau ReplicaSet à venir avec toutes les nouvelles mises à jour:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout resume deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment resumed
</span></span></code></pre></div></li><li><p>Regardez l'état du déploiement jusqu'à ce qu'il soit terminé.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs -w
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-2142116321   2         2         2         2m
</span></span><span style=display:flex><span>nginx-3926361531   2         2         0         6s
</span></span><span style=display:flex><span>nginx-3926361531   2         2         1         18s
</span></span><span style=display:flex><span>nginx-2142116321   1         2         2         2m
</span></span><span style=display:flex><span>nginx-2142116321   1         2         2         2m
</span></span><span style=display:flex><span>nginx-3926361531   3         2         1         18s
</span></span><span style=display:flex><span>nginx-3926361531   3         2         1         18s
</span></span><span style=display:flex><span>nginx-2142116321   1         1         1         2m
</span></span><span style=display:flex><span>nginx-3926361531   3         3         1         18s
</span></span><span style=display:flex><span>nginx-3926361531   3         3         2         19s
</span></span><span style=display:flex><span>nginx-2142116321   0         1         1         2m
</span></span><span style=display:flex><span>nginx-2142116321   0         1         1         2m
</span></span><span style=display:flex><span>nginx-2142116321   0         0         0         2m
</span></span><span style=display:flex><span>nginx-3926361531   3         3         3         20s
</span></span></code></pre></div></li><li><p>Obtenez le statut du dernier déploiement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME               DESIRED   CURRENT   READY     AGE
</span></span><span style=display:flex><span>nginx-2142116321   0         0         0         2m
</span></span><span style=display:flex><span>nginx-3926361531   3         3         3         28s
</span></span></code></pre></div></li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous ne pouvez pas annuler un déploiement suspendu avant de le reprendre.</div><h2 id=statut-de-déploiement>Statut de déploiement</h2><p>Un déploiement entre dans différents états au cours de son cycle de vie.
Il peut être <a href=#progressing-deployment>progressant</a> lors du déploiement d'un nouveau ReplicaSet, il peut être <a href=#complete-deployment>effectué</a>, ou il peut <a href=#failed-deployment>ne pas progresser</a>.</p><h3 id=progression-du-déploiement>Progression du déploiement</h3><p>Kubernetes marque un déploiement comme <em>progressing</em> lorsqu'une des tâches suivantes est effectuée:</p><ul><li>Le déploiement crée un nouveau ReplicaSet.</li><li>Le déploiement augmente son nouveau ReplicaSet.</li><li>Le déploiement réduit ses anciens ReplicaSet.</li><li>De nouveaux pods deviennent prêts ou disponibles (prêt pour au moins <a href=#min-ready-seconds>MinReadySeconds</a>).</li></ul><p>Vous pouvez surveiller la progression d'un déploiement à l'aide de <code>kubectl rollout status</code>.</p><h3 id=déploiement-effectué>Déploiement effectué</h3><p>Kubernetes marque un déploiement comme <em>effectué</em> lorsqu'il présente les caractéristiques suivantes:</p><ul><li>Toutes les répliques associées au déploiement ont été mises à jour vers la dernière version que vous avez spécifiée, ce qui signifie que toutes les mises à jour que vous avez demandées ont été effectuées.</li><li>Toutes les répliques associées au déploiement sont disponibles.</li><li>Aucune ancienne réplique pour le déploiement n'est en cours d'exécution.</li></ul><p>Vous pouvez vérifier si un déploiement est terminé en utilisant <code>kubectl rollout status</code>.
Si le déploiement s'est terminé avec succès, <code>kubectl rollout status</code> renvoie un code de sortie de 0.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Waiting for rollout to finish: 2 of 3 updated replicas are available...
</span></span><span style=display:flex><span>deployment &#34;nginx-deployment&#34; successfully rolled out
</span></span><span style=display:flex><span>$ echo $?
</span></span><span style=display:flex><span>0
</span></span></code></pre></div><h3 id=déploiement-échoué>Déploiement échoué</h3><p>Votre déploiement peut rester bloqué en essayant de déployer son nouveau ReplicaSet sans jamais terminer.
Cela peut se produire en raison de certains des facteurs suivants:</p><ul><li>Quota insuffisant</li><li>Échecs de la sonde de préparation</li><li>Erreurs d'extraction d'image</li><li>Permissions insuffisantes</li><li>Plages limites</li><li>Mauvaise configuration de l'exécution de l'application</li></ul><p>Vous pouvez détecter cette condition en spécifiant un paramètre d'échéance dans votre spécification de déploiement:
(<a href=#progress-deadline-seconds><code>.spec.progressDeadlineSeconds</code></a>).
<code>.spec.progressDeadlineSeconds</code> indique le nombre de secondes pendant lesquelles le contrôleur de déploiement attend avant d'indiquer (dans l'état de déploiement) que la progression du déploiement est au point mort.</p><p>La commande <code>kubectl</code> suivante définit la spécification avec <code>progressDeadlineSeconds</code> pour que le contrôleur signale l'absence de progression pour un déploiement après 10 minutes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch deployment.v1.apps/nginx-deployment -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;progressDeadlineSeconds&#34;:600}}&#39;</span>
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deployment.apps/nginx-deployment patched
</span></span></code></pre></div><p>Une fois le délai dépassé, le contrôleur de déploiement ajoute un <code>DeploymentCondition</code> avec les attributs suivants aux <code>.status.conditions</code> du déploiement:</p><ul><li>Type=Progressing</li><li>Status=False</li><li>Reason=ProgressDeadlineExceeded</li></ul><p>Voir les <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties>conventions Kubernetes API</a> pour plus d'informations sur les conditions d'état.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Kubernetes ne prend aucune mesure sur un déploiement bloqué, sauf pour signaler une condition d'état avec <code>Reason=ProgressDeadlineExceeded</code>.
Les orchestrateurs de niveau supérieur peuvent en tirer parti et agir en conséquence, par exemple, restaurer le déploiement vers sa version précédente.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si vous suspendez un déploiement, Kubernetes ne vérifie pas la progression par rapport à votre échéance spécifiée.
Vous pouvez suspendre un déploiement en toute sécurité au milieu d'un déploiement et reprendre sans déclencher la condition de dépassement du délai.</div><p>Vous pouvez rencontrer des erreurs transitoires avec vos déploiements, soit en raison d'un délai d'attente bas que vous avez défini, soit en raison de tout autre type d'erreur pouvant être traité comme transitoire.
Par exemple, supposons que votre quota soit insuffisant.
Si vous décrivez le déploiement, vous remarquerez la section suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&lt;...&gt;
</span></span><span style=display:flex><span>Conditions:
</span></span><span style=display:flex><span>  Type            Status  Reason
</span></span><span style=display:flex><span>  ----            ------  ------
</span></span><span style=display:flex><span>  Available       True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>  Progressing     True    ReplicaSetUpdated
</span></span><span style=display:flex><span>  ReplicaFailure  True    FailedCreate
</span></span><span style=display:flex><span>&lt;...&gt;
</span></span></code></pre></div><p>Si vous exécutez <code>kubectl get deployment nginx-deployment -o yaml</code>, l'état de déploiement est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>availableReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:39Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:39Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>Replica set &#34;nginx-deployment-4262182780&#34; is progressing.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>ReplicaSetUpdated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Progressing<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:42Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:42Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>Deployment has minimum availability.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>MinimumReplicasAvailable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Available<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:39Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span>2016-10-04T12:25:39Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message: &#39;Error creating</span>:<span style=color:#bbb> </span>pods &#34;nginx-deployment-4262182780-&#34; is forbidden: exceeded quota:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>object-counts, requested: pods=1, used: pods=3, limited</span>:<span style=color:#bbb> </span>pods=2&#39;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>FailedCreate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ReplicaFailure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>unavailableReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Finalement, une fois la date limite de progression du déploiement dépassée, Kubernetes met à jour le statut et la raison de la condition de progression:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Conditions:
</span></span><span style=display:flex><span>  Type            Status  Reason
</span></span><span style=display:flex><span>  ----            ------  ------
</span></span><span style=display:flex><span>  Available       True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>  Progressing     False   ProgressDeadlineExceeded
</span></span><span style=display:flex><span>  ReplicaFailure  True    FailedCreate
</span></span></code></pre></div><p>Vous pouvez résoudre un problème de quota insuffisant en réduisant votre déploiement, en réduisant d'autres contrôleurs que vous exécutez ou en augmentant le quota de votre namespace.
Si vous remplissez les conditions de quota et que le contrôleur de déploiement termine ensuite le déploiement de déploiement, vous verrez la mise à jour de l'état du déploiement avec une condition réussie (<code>Status=True</code> et <code>Reason=NewReplicaSetAvailable</code>).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Conditions:
</span></span><span style=display:flex><span>  Type          Status  Reason
</span></span><span style=display:flex><span>  ----          ------  ------
</span></span><span style=display:flex><span>  Available     True    MinimumReplicasAvailable
</span></span><span style=display:flex><span>  Progressing   True    NewReplicaSetAvailable
</span></span></code></pre></div><p><code>Type=Available</code> avec <code>Status=True</code> signifie que votre déploiement a une disponibilité minimale.
La disponibilité minimale est dictée par les paramètres spécifiés dans la stratégie de déploiement.
<code>Type=Progressing</code> avec <code>Status=True</code> signifie que votre déploiement est soit au milieu d'un déploiement et qu'il progresse ou qu'il a terminé avec succès sa progression et que les nouvelles répliques minimales requises sont disponibles (voir la raison de la condition pour les détails - dans notre cas, <code>Reason=NewReplicaSetAvailable</code> signifie que le déploiement est terminé).</p><p>Vous pouvez vérifier si un déploiement n'a pas pu progresser en utilisant <code>kubectl rollout status</code>.
<code>kubectl rollout status</code> renvoie un code de sortie différent de zéro si le déploiement a dépassé le délai de progression.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
</span></span><span style=display:flex><span>error: deployment &#34;nginx&#34; exceeded its progress deadline
</span></span><span style=display:flex><span>$ echo $?
</span></span><span style=display:flex><span>1
</span></span></code></pre></div><h3 id=agir-sur-un-déploiement-échoué>Agir sur un déploiement échoué</h3><p>Toutes les actions qui s'appliquent à un déploiement complet s'appliquent également à un déploiement ayant échoué.
Vous pouvez le mettre à l'échelle à la hausse/baisse, revenir à une révision précédente ou même la suspendre si vous devez appliquer plusieurs réglages dans le modèle de pod de déploiement.</p><h2 id=politique-de-nettoyage>Politique de nettoyage</h2><p>Vous pouvez définir le champ <code>.spec.revisionHistoryLimit</code> dans un déploiement pour spécifier le nombre d'anciens ReplicaSets pour ce déploiement que vous souhaitez conserver.
Le reste sera effacé en arrière-plan.
Par défaut, c'est 10.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> La définition explicite de ce champ sur 0 entraînera le nettoyage de tout l'historique de votre déploiement, de sorte que le déploiement ne pourra pas revenir en arrière.</div><h2 id=déploiement-des-canaries>Déploiement des Canaries</h2><p>Si vous souhaitez déployer des versions sur un sous-ensemble d'utilisateurs ou de serveurs à l'aide du déploiement, vous pouvez créer plusieurs déploiements, un pour chaque version, en suivant le modèle canari décrit dans <a href=/docs/concepts/cluster-administration/manage-deployment/#canary-deployments>gestion des ressources</a>.</p><h2 id=écriture-d-une-spécification-de-déploiement>Écriture d'une spécification de déploiement</h2><p>Comme pour toutes les autres configurations Kubernetes, un déploiement a besoin des champs <code>apiVersion</code>, <code>kind</code> et <code>metadata</code>.
Pour des informations générales sur l'utilisation des fichiers de configuration, voir <a href=/docs/tutorials/stateless-application/run-stateless-application-deployment/>déploiement d'applications</a>, configuration des conteneurs, et <a href=/docs/concepts/overview/working-with-objects/object-management/>Utilisation de kubectl pour gérer les ressources</a>.</p><p>Un déploiement nécessite également un <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> section</a>.</p><h3 id=pod-template>Pod Template</h3><p>Les <code>.spec.template</code> et <code>.spec.selector</code> sont les seuls champs obligatoires du <code>.spec</code>.</p><p>Le <code>.spec.template</code> est un <a href=/fr/docs/concepts/workloads/pods/pod-overview/#pod-templates>Pod template</a>.
Il a exactement le même schéma qu'un <a href=/fr/docs/concepts/workloads/pods/pod/>Pod</a>, sauf qu'il est imbriqué et n'a pas de <code>apiVersion</code> ou de <code>kind</code>.</p><p>En plus des champs obligatoires pour un pod, un Pod Template dans un déploiement doit spécifier des labels appropriées et une stratégie de redémarrage appropriée.
Pour les labels, assurez-vous de ne pas chevaucher l'action d'autres contrôleurs.
Voir <a href=#selector>sélecteur</a>).</p><p>Seulement un <a href=/fr/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>.spec.template.spec.restartPolicy</code></a> égal à <code>Always</code> est autorisé, ce qui est la valeur par défaut s'il n'est pas spécifié.</p><h3 id=répliques>Répliques</h3><p><code>.spec.replicas</code> est un champ facultatif qui spécifie le nombre de pods souhaités.
Il vaut par défaut 1.</p><h3 id=sélecteur>Sélecteur</h3><p><code>.spec.selector</code> est un champ obligatoire qui spécifie un <a href=/docs/concepts/overview/working-with-objects/labels/>sélecteur de labels</a> pour les pods ciblés par ce déploiement.</p><p><code>.spec.selector</code> doit correspondre <code>.spec.template.metadata.labels</code>, ou il sera rejeté par l'API.</p><p>Dans la version d'API <code>apps/v1</code>, <code>.spec.selector</code> et <code>.metadata.labels</code> ne sont pas définis par défaut sur <code>.spec.template.metadata.labels</code> s'ils ne sont pas définis.
Ils doivent donc être définis explicitement.
Notez également que <code>.spec.selector</code> est immuable après la création du déploiement dans <code>apps/v1</code>.</p><p>Un déploiement peut mettre fin aux pods dont les étiquettes correspondent au sélecteur si leur modèle est différent de <code>.spec.template</code> ou si le nombre total de ces pods dépasse <code>.spec.replicas</code>.
Il fait apparaître de nouveaux pods avec <code>.spec.template</code> si le nombre de pods est inférieur au nombre souhaité.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous ne devez pas créer d'autres pods dont les labels correspondent à ce sélecteur, soit directement, en créant un autre déploiement, soit en créant un autre contrôleur tel qu'un ReplicaSet ou un ReplicationController.
Si vous le faites, le premier déploiement pense qu'il a créé ces autres pods.
Kubernetes ne vous empêche pas de le faire.</div><p>Si vous avez plusieurs contrôleurs qui ont des sélecteurs qui se chevauchent, les contrôleurs se battront entre eux et ne se comporteront pas correctement.</p><h3 id=stratégie>Stratégie</h3><p><code>.spec.strategy</code> spécifie la stratégie utilisée pour remplacer les anciens pods par de nouveaux.
<code>.spec.strategy.type</code> peut être "Recreate" ou "RollingUpdate".
"RollingUpdate" est la valeur par défaut.</p><h4 id=déploiment-recreate>Déploiment Recreate</h4><p>Tous les pods existants sont tués avant que de nouveaux ne soient créés lorsque <code>.spec.strategy.type==Recreate</code>.</p><h4 id=déploiement-de-mise-à-jour-continue>Déploiement de mise à jour continue</h4><p>Le déploiement met à jour les pods dans une <a href=/docs/tasks/run-application/rolling-update-replication-controller/>mise à jour continue</a> quand <code>.spec.strategy.type==RollingUpdate</code>.
Vous pouvez spécifier <code>maxUnavailable</code> et <code>maxSurge</code> pour contrôler le processus de mise à jour continue.</p><h5 id=max-non-disponible>Max non disponible</h5><p><code>.spec.strategy.rollingUpdate.maxUnavailable</code> est un champ facultatif qui spécifie le nombre maximal de pods qui peuvent être indisponibles pendant le processus de mise à jour.
La valeur peut être un nombre absolu (par exemple, 5) ou un pourcentage des pods souhaités (par exemple, 10%).
Le nombre absolu est calculé à partir du pourcentage en arrondissant vers le bas.
La valeur ne peut pas être 0 si <code>.spec.strategy.rollingUpdate.maxSurge</code> est 0.
La valeur par défaut est 25%.</p><p>Par exemple, lorsque cette valeur est définie sur 30%, l'ancien ReplicaSet peut être réduit à 70% des pods souhaités immédiatement au démarrage de la mise à jour continue.
Une fois que les nouveaux pods sont prêts, l'ancien ReplicaSet peut être réduit davantage, suivi d'une augmentation du nouveau ReplicaSet, garantissant que le nombre total de pods disponibles à tout moment pendant la mise à jour est d'au moins 70% des pods souhaités.</p><h5 id=max-surge>Max Surge</h5><p><code>.spec.strategy.rollingUpdate.maxSurge</code> est un champ facultatif qui spécifie le nombre maximal de pods pouvant être créés sur le nombre de pods souhaité.
La valeur peut être un nombre absolu (par exemple, 5) ou un pourcentage des pods souhaités (par exemple, 10%).
La valeur ne peut pas être 0 si <code>MaxUnavailable</code> est 0.
Le nombre absolu est calculé à partir du pourcentage en arrondissant.
La valeur par défaut est 25%.</p><p>Par exemple, lorsque cette valeur est définie sur 30%, le nouveau ReplicaSet peut être mis à l'échelle immédiatement au démarrage de la mise à jour continue, de sorte que le nombre total d'anciens et de nouveaux pods ne dépasse pas 130% des pods souhaités.
Une fois que les anciens pods ont été détruits, le nouveau ReplicaSet peut être augmenté davantage, garantissant que le nombre total de pods en cours d'exécution à tout moment pendant la mise à jour est au maximum de 130% des pods souhaités.</p><h3 id=progress-deadline-seconds>Progress Deadline Seconds</h3><p><code>.spec.progressDeadlineSeconds</code> est un champ facultatif qui spécifie le nombre de secondes pendant lesquelles vous souhaitez attendre que votre déploiement progresse avant que le système ne signale que le déploiement a <a href=#failed-deployment>échoué</a> - refait surface comme une condition avec <code>Type=Progressing</code>, <code>Status=False</code> et <code>Reason=ProgressDeadlineExceeded</code> dans l'état de la ressource.
Le contrôleur de déploiement continuera de réessayer le déploiement.
À l'avenir, une fois la restauration automatique implémentée, le contrôleur de déploiement annulera un déploiement dès qu'il observera une telle condition.</p><p>S'il est spécifié, ce champ doit être supérieur à <code>.spec.minReadySeconds</code>.</p><h3 id=min-ready-seconds>Min Ready Seconds</h3><p><code>.spec.minReadySeconds</code> est un champ facultatif qui spécifie le nombre minimum de secondes pendant lequel un pod nouvellement créé doit être prêt sans qu'aucun de ses conteneurs ne plante, pour qu'il soit considéré comme disponible.
Cette valeur par défaut est 0 (le pod sera considéré comme disponible dès qu'il sera prêt).
Pour en savoir plus sur le moment où un pod est considéré comme prêt, consultez <a href=/fr/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Sondes de conteneur</a>.</p><h3 id=rollback-to>Rollback To</h3><p>Le champ <code>.spec.rollbackTo</code> est obsolète dans les versions d'API <code>extensions/v1beta1</code> et <code>apps/v1beta1</code> et n'est plus pris en charge dans les versions d'API commençant par <code>apps/v1beta2</code>.
Utilisez, <code>kubectl rollout undo</code> pour <a href=#revenir-%C3%A0-une-r%C3%A9vision-pr%C3%A9c%C3%A9dente>Revenir à une révision précédente</a>.</p><h3 id=limite-de-l-historique-des-révisions>Limite de l'historique des révisions</h3><p>L'historique de révision d'un déploiement est stocké dans les ReplicaSets qu'il contrôle.</p><p><code>.spec.revisionHistoryLimit</code> est un champ facultatif qui spécifie le nombre d'anciens ReplicaSets à conserver pour permettre la restauration.
Ces anciens ReplicaSets consomment des ressources dans <code>etcd</code> et encombrent la sortie de <code>kubectl get rs</code>.
La configuration de chaque révision de déploiement est stockée dans ses ReplicaSets; par conséquent, une fois un ancien ReplicaSet supprimé, vous perdez la possibilité de revenir à cette révision du déploiement.
Par défaut, 10 anciens ReplicaSets seront conservés, mais sa valeur idéale dépend de la fréquence et de la stabilité des nouveaux déploiements.</p><p>Plus précisément, la définition de ce champ à zéro signifie que tous les anciens ReplicaSets avec 0 réplicas seront nettoyés.
Dans ce cas, un nouveau panneau déroulant Déploiement ne peut pas être annulé, car son historique de révision est nettoyé.</p><h3 id=paused>Paused</h3><p><code>.spec.paused</code> est un champ booléen facultatif pour suspendre et reprendre un déploiement.
La seule différence entre un déploiement suspendu et un autre qui n'est pas suspendu, c'est que toute modification apportée au <code>PodTemplateSpec</code> du déploiement suspendu ne déclenchera pas de nouveaux déploiements tant qu'il sera suspendu.
Un déploiement n'est pas suspendu par défaut lors de sa création.</p><h2 id=alternative-aux-déploiements>Alternative aux déploiements</h2><h3 id=kubectl-rolling-update>kubectl rolling-update</h3><p><a href=/docs/reference/generated/kubectl/kubectl-commands#rolling-update><code>kubectl rolling-update</code></a> met à jour les pods et les ReplicationControllers de la même manière.
Mais les déploiements sont recommandés, car ils sont déclaratifs, côté serveur et ont des fonctionnalités supplémentaires, telles que la restauration de toute révision précédente même après la mise à jour progressive..</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6d72299952c37ca8cc61b416e5bdbcd4>4.2.3 - StatefulSets</h1><p>StatefulSet est l'objet de l'API de charge de travail utilisé pour gérer des applications avec état (<em>stateful</em>).</p><p>Gère le déploiement et la mise à l'échelle d'un ensemble de <a class=glossary-tooltip title='Le plus petit et le plus simple des objets Kubernetes. Un Pod est un ensemble de conteneurs fonctionnant sur votre cluster.' data-toggle=tooltip data-placement=top href=/fr/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a>, <em>et fournit des garanties sur l'ordre et l'unicité</em> de ces Pods.</p><p>Comme un <a class=glossary-tooltip title='Objet API gérant une application répliquée.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Déploiement>Déploiement</a>, un StatefulSet gère des Pods qui sont basés sur une même spécification de conteneur. Contrairement à un Deployment, un StatefulSet maintient une identité pour chacun de ces Pods. Ces Pods sont créés à partir de la même spec, mais ne sont pas interchangeables : chacun a un identifiant persistant qu'il garde à travers tous ses re-scheduling.</p><p>Si vous voulez utiliser des volumes de stockage pour fournir de la persistance à votre charge de travail, vous pouvez utiliser un StatefulSet comme partie de la solution. Même si des Pods individuels d'un StatefulSet sont susceptibles d'échouer, les identifiants persistants des Pods rendent plus facile de faire correspondre les volumes existants aux nouveaux Pods remplaçant ceux ayant échoué.</p><h2 id=utiliser-des-statefulsets>Utiliser des StatefulSets</h2><p>Les StatefulSets sont utiles pour des applications qui nécessitent une ou plusieurs des choses suivantes :</p><ul><li>Des identifiants réseau stables et uniques.</li><li>Un stockage persistant stable.</li><li>Un déploiement et une mise à l'échelle ordonnés et contrôlés.</li><li>Des mises à jour continues (<em>rolling update</em>) ordonnées et automatisées.</li></ul><p>Ci-dessus, stable est synonyme de persistance suite au (re)scheduling de Pods.
Si une application ne nécessite aucun identifiant stable ou de déploiement, suppression ou
mise à l'échelle stables, vous devriez déployer votre application en utilisant un objet de charge de travail
fournissant un ensemble de réplicas sans état (<em>stateless</em>).</p><p>Un <a href=/fr/docs/concepts/workloads/controllers/deployment/>Deployment</a> ou
<a href=/fr/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> peut être mieux adapté pour vos applications sans état.</p><h2 id=limitations>Limitations</h2><ul><li>Le stockage pour un Pod donné doit être provisionné soit par un <a href=https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/README.md>approvisionneur de PersistentVolume</a> basé sur un <code>storage class</code> donné, soit pré-provisionné par un admin.</li><li>Supprimer et/ou réduire l'échelle d'un StatefulSet à zéro ne supprimera <em>pas</em> les volumes associés avec le StatefulSet. Ceci est fait pour garantir la sécurité des données, ce qui a généralement plus de valeur qu'une purge automatique de toutes les ressources relatives à un StatefulSet.</li><li>Les StatefulSets nécessitent actuellement un <a href=/fr/docs/concepts/services-networking/service/#headless-services>Service Headless</a> qui est responsable de l'identité réseau des Pods. Vous êtes responsable de la création de ce Service.</li><li>Les StatefulSets ne fournissent aucune garantie de la terminaison des pods lorsqu'un StatefulSet est supprimé. Pour avoir une terminaison ordonnée et maîtrisée des pods du StatefulSet, il est possible de réduire l'échelle du StatefulSet à 0 avant de le supprimer.</li><li>Lors de l'utilisation de <a href=#rolling-updates>Rolling Updates</a> avec la
<a href=#politiques-de-gestion-dun-pod>Politique de gestion des Pods</a> par défaut (<code>OrderedReady</code>),
il est possible de tomber dans un état indéfini nécessitant une
<a href=#rollback-forc%C3%A9>intervention manuelle pour réparer</a>.</li></ul><h2 id=composants>Composants</h2><p>L'exemple ci-dessous décrit les composants d'un StatefulSet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># doit correspondre à .spec.template.metadata.labels</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># est 1 par défaut</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># doit correspondre à .spec.selector.matchLabels</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-storage-class&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>Dans l'exemple ci-dessus :</p><ul><li>Un Service Headless, appelé <code>nginx</code>, est utilisé pour contrôler le domaine réseau.</li><li>Le StatefulSet, appelé <code>web</code>, a une Spec indiquant que 3 réplicas du container nginx seront démarrés dans des Pods.</li><li>Le <code>volumeClaimTemplates</code> fournira un stockage stable utilisant des <a href=/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a> provisionnés par un approvisionneur de PersistentVolume.</li></ul><p>Le nom d'un objet StatefulSet doit être un
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nom de sous-domaine DNS</a> valide.</p><h2 id=sélecteur-de-pod>Sélecteur de Pod</h2><p>Vous devez renseigner le champ <code>.spec.selector</code> d'un StatefulSet pour qu'il corresponde aux labels de son <code>.spec.template.metadata.labels</code>. Avant Kubernetes 1.8, le champ <code>.spec.selector</code> était mis par défaut s'il était omis. Pour les versions 1.8 et ultérieures, ne pas spécifier de sélecteur de Pod résulte en une erreur de validation lors de la création du StatefulSet.</p><h2 id=identité-du-pod>Identité du Pod</h2><p>Les Pods d'un StatefulSet ont une identité unique comprenant un ordinal, une identité réseau stable et un stockage stable.
L'identité est accrochée au Pod, indépendamment du noeud sur lequel il est (re)programmé.</p><h3 id=index-ordinal>Index Ordinal</h3><p>Pour un StatefulSet avec N réplicas, chaque Pod du StatefulSet se verra assigné un ordinal entier, de 0 à N-1,
unique sur l'ensemble des pods.</p><h3 id=id-réseau-stable>ID réseau stable</h3><p>Chaque Pod dans un StatefulSet dérive son nom d'hôte du nom du StatefulSet
et de l'ordinal du Pod. Le modèle pour le nom d'hôte généré est
<code>$(nom statefulset)-$(ordinal)</code>. L'exemple ci-dessus créera trois Pods
nommés <code>web-0,web-1,web-2</code>.
Un StatefulSet peut utiliser un <a href=/docs/concepts/services-networking/service/#headless-services>Service Headless</a>
pour contrôler le domaine de ses Pods. Le domaine pris en charge par ce Service prend la forme :
<code>$(nom service).$(namespace).svc.cluster.local</code>, où "cluster.local" est le domaine du cluster.
Chaque fois qu'un Pod est créé, il obtient un sous-domaine DNS correspondant, prenant la forme :
<code>$(nom pod).$(domaine du service gouvernant)</code>, où le service gouvernant est défini par le
champ <code>serviceName</code> du StatefulSet.</p><p>En fonction de la façon dont est configuré le DNS dans votre cluster, vous ne pourrez peut-être pas rechercher immédiatement
le nom DNS d'un pod nouvellement exécuté. Ce problème peut se produire lorsque d'autres clients dans le
cluster ont déjà envoyé des requêtes pour le nom d'hôte du Pod avant sa création.
La mise en cache négative (normale pour le DNS) signifie que les résultats des recherches précédentes ayant échoué sont
mémorisés et réutilisés, même après que le Pod ait démarré, pendant au moins quelques secondes.</p><p>Si vous avez besoin de découvrir les Pods rapidement après leur création, vous avez plusieurs options :</p><ul><li>Interrogez directement l'API Kubernetes (par exemple, à l'aide d'un watch) plutôt que de vous fier aux recherches DNS.</li><li>Réduisez le temps de mise en cache dans votre fournisseur de DNS Kubernetes (cela signifie généralement modifier le ConfigMap de CoreDNS, qui met actuellement en cache pendant 30 secondes).</li></ul><p>Comme mentionné dans la section <a href=#limitations>limitations</a>, vous êtes responsable de
créer le <a href=/docs/concepts/services-networking/service/#headless-services>Service Headless</a>
responsable de l'identité réseau des Pods.</p><p>Voici quelques exemples de choix pour le domaine du cluster, le nom du service,
le nom du StatefulSet et comment cela affecte les noms DNS des pods du StatefulSet.</p><table><thead><tr><th>Domaine Cluster</th><th>Service (ns/nom)</th><th>StatefulSet (ns/nom)</th><th>Domaine StatefulSet</th><th>DNS Pod</th><th>Nom d'hôte</th></tr></thead><tbody><tr><td>cluster.local</td><td>default/nginx</td><td>default/web</td><td>nginx.default.svc.cluster.local</td><td>web-{0..N-1}.nginx.default.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>cluster.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.cluster.local</td><td>web-{0..N-1}.nginx.foo.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>kube.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.kube.local</td><td>web-{0..N-1}.nginx.foo.svc.kube.local</td><td>web-{0..N-1}</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le domaine cluster sera <code>cluster.local</code> à moins qu'il soit
<a href=/docs/concepts/services-networking/dns-pod-service/>configuré autrement</a>.</div><h3 id=stockage-stable>Stockage stable</h3><p>Kubernetes crée un <a href=/docs/concepts/storage/persistent-volumes/>PersistentVolume</a> pour chaque
VolumeClaimTemplate. Dans l'exemple nginx ci-dessus, chaque Pod se verra affecter un unique PersistentVolume
avec un StorageClass de <code>my-storage-class</code> et 1 Gib de stockage provisionné. Si aucun StorageClass
n'est spécifié, alors le StorageClass par défaut sera utilisé. Lorsqu'un Pod est (re)schedulé
sur un noeud, ses <code>volumeMounts</code> montent les PersistentVolumes associés aux<br>PersistentVolumeClaims. Notez que les PersistentVolumes associés avec les PersistentVolumeClaims des Pods
ne sont pas supprimés lorsque les Pods, ou le StatefulSet, sont supprimés.
Ceci doit être fait manuellement.</p><h3 id=étiquette-du-nom-de-pod>Étiquette du nom de Pod</h3><p>Lorsque le StatefulSet <a class=glossary-tooltip title="Boucle de contrôle surveillant l'état partagé du cluster à travers l'apiserver et effectuant des changements en essayant de déplacer l'état actuel vers l'état désiré." data-toggle=tooltip data-placement=top href=/docs/admin/kube-controller-manager/ target=_blank aria-label=Contrôleur>Contrôleur</a> crée un Pod,
il ajoute une étiquette, <code>statefulset.kubernetes.io/pod-name</code>, renseignée avec le nom du Pod.
Cette étiquette vous permet d'attacher un Service à un Pod spécifique du StatefulSet.</p><h2 id=garanties-de-déploiement-et-de-mise-à-l-échelle>Garanties de déploiement et de mise à l'échelle</h2><ul><li>Pour un StatefulSet avec N réplicas, lorsque les Pods sont déployés, ils sont créés de manière séquentielle, dans l'ordre {0..N-1}.</li><li>Lorsque les Pods sont supprimés, ils sont terminés dans l'ordre inverse, {N-1..0}.</li><li>Avant qu'une opération de mise à l'échelle soit appliquée à un Pod, tous ses prédécesseurs doivent être Running et Ready.</li><li>Avant qu'un Pod soit terminé, tous ses successeurs doivent être complètement arrêtés.</li></ul><p>Le StatefulSet ne devrait pas spécifier un <code>pod.Spec.TerminationGracePeriodSeconds</code> à 0. Cette pratique
est dangereuse et fortement déconseillée. Pour plus d'explications, veuillez vous référer à <a href=/docs/tasks/run-application/force-delete-stateful-set-pod/>forcer la suppression de Pods de StatefulSet</a>.</p><p>Lorsque l'exemple nginx ci-dessus est créé, trois Pods seront déployés dans l'ordre
web-0, web-1, web-2. web-1 ne sera pas déployé avant que web-0 soit
<a href=/fr/docs/concepts/workloads/pods/pod-lifecycle/>Running et Ready</a>, et web-2 ne sera pas déployé avant que
web-1 soit Running et Ready. Si web-0 venait à échouer, après que web-1 soit Running et Ready, mais avant que
web-2 soit lancé, web-2 ne serait pas lancé avant que web-0 soit correctement relancé et redevienne Running et Ready.</p><p>Si un utilisateur venait à mettre à l'échelle l'exemple déployé en patchant le StatefulSet pour que
<code>replicas=1</code>, web-2 serait terminé en premier. web-1 ne serait pas terminé avant que web-2
ne soit complètement arrêté et supprimé. Si web-0 venait à échouer après que web-2 soit terminé et complètement arrêté,
mais avant que web-1 soit terminé, web-1 ne serait pas terminé avant que web-0 soit Running et Ready.</p><h3 id=politiques-de-gestion-d-un-pod>Politiques de gestion d'un Pod</h3><p>Dans Kubernetes 1.7 et ultérieurs, le StatefulSet vous permet d'assouplir ses garanties d'ordre,
tout en préservant ses garanties d'unicité et d'identité via son champ <code>.spec.podManagementPolicy</code>.</p><h4 id=gestion-de-pod-orderedready>Gestion de Pod OrderedReady</h4><p>La gestion de Pod <code>OrderedReady</code> est la valeur par défaut pour les StatefulSets. Il implémente le comportement décrit <a href=#garanties-de-d%C3%A9ploiment-et-de-mise-%C3%A0-l-%C3%A9chelle>ci-dessus</a>.</p><h4 id=gestion-de-pod-parallel>Gestion de Pod Parallel</h4><p>La gestion de Pod <code>Parallel</code> indique au contrôleur de StatefulSet de lancer ou
terminer tous les Pods en parallèle, et de ne pas attendre que les Pods deviennent Running
et Ready ou complètement terminés avant de lancer ou terminer un autre
Pod. Cette option affecte seulement le comportement pour les opérations de mise à l'échelle.
Les mises à jour ne sont pas affectées.</p><h2 id=stratégies-de-mise-à-jour>Stratégies de mise à jour</h2><p>Dans Kubernetes 1.7 et ultérieurs, le champ <code>.spec.updateStrategy</code> d'un StatefulSet vous permet
de configurer et désactiver les rolling updates automatisés pour les conteneurs, étiquettes,
requête/limites de ressources, et annotations pour les Pods d'un StatefulSet.</p><h3 id=on-delete>On Delete</h3><p>La stratégie de mise à jour <code>OnDelete</code> implémente l'ancien comportement (1.6 et précédents). Lorsque
<code>.spec.updateStrategy.type</code> d'un StatefulSet est mis à <code>OnDelete</code>, le contrôleur de StatefulSet
ne mettra pas à jour automatiquement les Pods dans un StatefulSet.
Les utilisateurs doivent supprimer manuellement les Pods pour forcer le contrôleur à créer de nouveaux
Pods qui réflètent les modifications faites à un <code>.spec.template</code> d'un StatefulSet.</p><h3 id=rolling-updates>Rolling Updates</h3><p>La stratégie de mise à jour <code>RollingUpdate</code> implémente le rolling update automatisé pour les Pods d'un
StatefulSet. C'est la stratégie par défaut lorsque <code>.spec.updateStrategy</code> n'est pas spécifié.
Lorsqu'un <code>.spec.updateStrategy.type</code> d'un StatefulSet est mis à <code>RollingUpdate</code>, le contrôleur de
StatefulSet va supprimer et recréer chaque Pod d'un StatefulSet. Il va procéder dans le même ordre
que pour la terminaison d'un Pod (de l'ordinal le plus grand au plus petit), mettant à jour chaque Pod,
un seul à la fois. Il va attendre qu'un Pod mis à jour soit Running et Ready avant de mettre à jour
son prédécesseur.</p><h4 id=partitions>Partitions</h4><p>La stratégie de mise à jour <code>RollingUpdate</code> peut être partitionnée, en spécifiant une
<code>.spec.updateStrategy.rollingUpdate.partition</code>. Si une partition est spécifiée, tous les Pods ayant un
ordinal plus grand ou égal à la partition seront mis à jour lorsque le
<code>.spec.template</code> du StatefulSet sera mis à jour. Tous les Pods ayant un ordinal inférieur à la partition
ne sera pas mis à jour, et, même s'ils sont supprimés, ils seront recréés avec l'ancienne version. Si une
<code>.spec.updateStrategy.rollingUpdate.partition</code> d'un StatefulSet est plus grand que son <code>.spec.replicas</code>,
les mises à jour de son <code>.spec.template</code> ne seront pas propagés à ses Pods.
Dans la plupart des cas vous n'aurez pas à utiliser de partition, mais elles sont utiles si vous désirez
organiser une mise à jour, déployer une version canari, ou effectuer un déploiement par étapes.</p><h4 id=rollback-forcé>Rollback forcé</h4><p>En utilisant des <a href=#rolling-updates>Rolling Updates</a> avec la
<a href=#politiques-de-gestion-dun-pod>politique de gestion d'un Pod</a> par défaut (<code>OrderedReady</code>),
il est possible de se retrouver dans un état inconsistant nécessitant une intervention manuelle pour réparation.</p><p>Si vous mettez à jour le template de Pod dans une configuration qui ne devient jamais Running et
Ready (par exemple, du fait d'un mauvais binaire ou d'une erreur de configuration au niveau de l'application),
le StatefulSet va arrêter le rollout et attendre.</p><p>Dans cet état, il n'est pas suffisant de revenir à une bonne configuration du template de Pod.
En raison d'une <a href=https://github.com/kubernetes/kubernetes/issues/67250>erreur connue</a>,
le StatefulSet va continuer à attendre que le Pod en échec Pod devienne Ready
(ce qui n'arrive jamais) avant qu'il tente de revenir à la bonne configuration.</p><p>Après être revenu au bon template, vous devez aussi supprimer tous les Pods que le StatefulSet
avait déjà essayé de démarrer avec la mauvaise configuration.
Le StatefulSet va alors commencer à recréer les Pods en utilisant le bon template.</p><h2 id=a-suivre>A suivre</h2><ul><li>Suivre un exemple de <a href=/docs/tutorials/stateful-application/basic-stateful-set/>déploiement d'une application stateful</a>.</li><li>Suivre un exemple de <a href=/docs/tutorials/stateful-application/cassandra/>déploiement de Cassandra avec des Stateful Sets</a>.</li><li>Suivre un exemple d'<a href=/docs/tasks/run-application/run-replicated-stateful-application/>exécution d'une application stateful redondante</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0a0a7eca3e302a3c08f8c85e15d337fd>5 - Services, Equilibreur de charge, et Réseau</h1><div class=lead>Service Reseau Kubernetes</div></div><div class=td-content><h1 id=pg-f51db1097575de8072afe1f5b156a70c>5.1 - EndpointSlices</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p><em>EndpointSlices</em> offrent une méthode simple pour suivre les Endpoints d'un réseau au sein d'un cluster de Kubernetes. Ils offrent une alternative plus évolutive et extensible aux Endpoints.</p><h2 id=endpointslice-resource>Ressource pour EndpointSlice</h2><p>Dans Kubernetes, un EndpointSlice contient des références à un ensemble de Endpoints.
Le controleur d'EndpointSlice crée automatiquement des EndpointSlices pour un Service quand un <a class=glossary-tooltip title='Allows users to filter a list of resources based on labels.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=sélecteur>sélecteur</a> est spécifié.
Ces EndpointSlices vont inclure des références à n'importe quels Pods qui correspondent aux selecteurs de Service.
EndpointSlices groupent ensemble les Endpoints d'un réseau par combinaisons uniques de Services et de Ports.</p><p>Par exemple, voici un échantillon d'une ressource EndpointSlice pour le Kubernetes Service <code>exemple</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>discovery.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EndpointSlice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exemple-abc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-name</span>:<span style=color:#bbb> </span>exemple<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>addressType</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>endpoints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>pod-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topology</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>node-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>topology.kubernetes.io/zone</span>:<span style=color:#bbb> </span>us-west2-a<span style=color:#bbb>
</span></span></span></code></pre></div><p>Les EndpointSlices gérés par le contrôleur d'EndpointSlice n'auront, par défaut, pas plus de 100 Endpoints chacun.
En dessous de cette échelle, EndpointSlices devraient mapper 1:1 les Endpoints et les Services et devraient avoir une performance similaire.</p><p>EndpointSlices peuvent agir en tant que source de vérité pour kube-proxy quand il s'agit du routage d'un trafic interne.
Lorsqu'ils sont activés, ils devraient offrir une amélioration de performance pour les services qui ont une grand quantité d'Endpoints.</p><h3 id=types-d-addresses>Types d'addresses</h3><p>Les EndpointSlices supportent 3 types d'addresses :</p><ul><li>IPv4</li><li>IPv6</li><li>FQDN (Fully Qualified Domain Name) - [nom de domaine entièrement qualifié]</li></ul><h3 id=topologie>Topologie</h3><p>Chaque Endpoint dans un EndpointSlice peut contenir des informations de topologie pertinentes.
Ceci est utilisé pour indiquer où se trouve un Endpoint, qui contient les informations sur le Node, zone et région correspondantes. Lorsque les valeurs sont disponibles, les labels de Topologies suivants seront définis par le contrôleur EndpointSlice:</p><ul><li><code>kubernetes.io/hostname</code> - Nom du Node sur lequel l'Endpoint se situe.</li><li><code>topology.kubernetes.io/zone</code> - Zone dans laquelle l'Endpoint se situe.</li><li><code>topology.kubernetes.io/region</code> - Région dans laquelle l'Endpoint se situe.</li></ul><p>Le contrôleur EndpointSlice surveille les Services et les Pods pour assurer que leurs correspondances avec les EndpointSlices sont à jour.
Le contrôleur gère les EndpointSlices pour tous les Services qui ont un sélecteur - [référence: <a class=glossary-tooltip title='Allows users to filter a list of resources based on labels.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=sélecteur>sélecteur</a>] - specifié. Celles-ci représenteront les IPs des Pods qui correspondent au sélecteur.</p><h3 id=capacité-d-endpointslices>Capacité d'EndpointSlices</h3><p>Les EndpointSlices sont limités à une capacité de 100 Endpoints chacun, par défaut. Vous pouvez configurer ceci avec l'indicateur <code>--max-endpoints-per-slice</code> <a class=glossary-tooltip title='Composant du master qui exécute les contrôleurs.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> jusqu'à un maximum de 1000.</p><h3 id=distribution-d-endpointslices>Distribution d'EndpointSlices</h3><p>Chaque EndpointSlice a un ensemble de ports qui s'applique à tous les Endpoints dans la ressource.
Lorsque les ports nommés sont utilisés pour un Service, les Pods peuvent se retrouver avec différents ports cibles pour le même port nommé, nécessitant différents EndpointSlices.</p><p>Le contrôleur essaie de remplir les EndpointSlices aussi complètement que possible, mais ne les rééquilibre pas activement. La logique du contrôleur est assez simple:</p><ol><li>Itérer à travers les EndpointSlices existants, retirer les Endpoints qui ne sont plus voulus et mettre à jour les Endpoints qui ont changé.</li><li>Itérer à travers les EndpointSlices qui ont été modifiés dans la première étape et les remplir avec n'importe quel Endpoint nécéssaire.</li><li>S'il reste encore des Endpoints nouveaux à ajouter, essayez de les mettre dans une slice qui n'a pas été changée et/ou en créer une nouvelle.</li></ol><p>Par-dessus tout, la troisième étape priorise la limitation de mises à jour d'EndpointSlice sur une distribution complètement pleine d'EndpointSlices. Par exemple, s'il y avait 10 nouveaux Endpoints à ajouter et 2 EndpointSlices qui peuvent contenir 5 Endpoints en plus chacun; cette approche créera un nouveau EndpointSlice au lieu de remplir les EndpointSlice existants. C'est à dire, une seule création EndpointSlice est préférable à plusieurs mises à jour d'EndpointSlices.</p><p>Avec kube-proxy exécuté sur chaque Node et surveillant EndpointSlices, chaque changement d'un EndpointSlice devient relativement coûteux puisqu'ils seront transmis à chaque Node du cluster.
Cette approche vise à limiter le nombre de modifications qui doivent être envoyées à chaque Node, même si ça peut causer plusieurs EndpointSlices non remplis.</p><p>En pratique, cette distribution bien peu idéale devrait être rare. La plupart des changements traités par le contrôleur EndpointSlice seront suffisamment petits pour tenir dans un EndpointSlice existant, et sinon, un nouveau EndpointSlice aurait probablement été bientôt nécessaire de toute façon. Les mises à jour continues des déploiements fournissent également une compaction naturelle des EndpointSlices avec tous leurs pods et les Endpoints correspondants qui se feront remplacer.</p><h2 id=motivation>Motivation</h2><p>L'API des Endpoints fournit une méthode simple et facile à suivre pour les Endpoints dans Kubernetes. Malheureusement, comme les clusters Kubernetes et Services sont devenus plus grands, les limitations de cette API sont devenues plus visibles. Plus particulièrement, celles-ci comprennent des limitations liées au dimensionnement vers un plus grand nombre d'Endpoints d'un réseau.</p><p>Puisque tous les Endpoints d'un réseau pour un Service ont été stockés dans une seule ressource Endpoints, ces ressources pourraient devenir assez lourdes. Cela affecte les performances des composants Kubernetes (notamment le plan de contrôle) et cause une grande quantité de trafic réseau et de traitements lorsque les Endpoints changent. Les EndpointSlices aident à atténuer ces problèmes ainsi qu'à fournir une plate-forme extensible pour des fonctionnalités supplémentaires telles que le routage topologique.</p><h2 id=a-suivre>A suivre</h2><ul><li><a href=/docs/tasks/administer-cluster/enabling-endpointslices>Activer EndpointSlices</a></li><li>Lire <a href=/docs/concepts/services-networking/connect-applications-service/>Connecter des applications aux Services</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5701136fd2ce258047b6ddc389112352>5.2 - Service</h1>Une manière abstraite d'exposer une application s'exécutant sur un ensemble de <a class=glossary-tooltip title='Le plus petit et le plus simple des objets Kubernetes. Un Pod est un ensemble de conteneurs fonctionnant sur votre cluster.' data-toggle=tooltip data-placement=top href=/fr/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a> en tant que service réseau.<p>Avec Kubernetes, vous n'avez pas besoin de modifier votre application pour utiliser un mécanisme de découverte de services inconnu.
Kubernetes donne aux pods leurs propres adresses IP et un nom DNS unique pour un ensemble de pods, et peut équilibrer la charge entre eux.</p><h2 id=motivation>Motivation</h2><p>Les <a class=glossary-tooltip title='Le plus petit et le plus simple des objets Kubernetes. Un Pod est un ensemble de conteneurs fonctionnant sur votre cluster.' data-toggle=tooltip data-placement=top href=/fr/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a> Kubernetes sont mortels.
Ils naissent et lorsqu'ils meurent, ils ne ressuscitent pas.
Si vous utilisez un <a class=glossary-tooltip title='Objet API gérant une application répliquée.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Déploiement>Déploiement</a> pour exécuter votre application, il peut créer et détruire dynamiquement des pods.</p><p>Chaque pod obtient sa propre adresse IP, mais dans un déploiement, l'ensemble de pods s'exécutant en un instant peut être différent de l'ensemble de pods exécutant cette application un instant plus tard.</p><p>Cela conduit à un problème: si un ensemble de pods (appelez-les «backends») fournit des fonctionnalités à d'autres pods (appelez-les «frontends») à l'intérieur de votre cluster, comment les frontends peuvent-ils trouver et suivre l'adresse IP à laquelle se connecter, afin que le frontend puisse utiliser la partie backend de la charge de travail?</p><p>C'est là où les <em>Services</em> rentrent en jeu.</p><h2 id=service-resource>La ressource Service</h2><p>Dans Kubernetes, un service est une abstraction qui définit un ensemble logique de pods et une politique permettant d'y accéder (parfois ce modèle est appelé un micro-service).
L'ensemble des pods ciblés par un service est généralement déterminé par un <a class=glossary-tooltip title='Allows users to filter a list of resources based on labels.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector>selector</a> (voir <a href=#services-without-selectors>ci-dessous</a> pourquoi vous voudrez peut-être un service <em>sans</em> un sélecteur).</p><p>Par exemple, considérons un backend de traitement d'image sans état qui s'exécute avec 3 replicas.
Ces réplicas sont fongibles et les frontends ne se soucient pas du backend qu'ils utilisent.
Bien que les pods réels qui composent l'ensemble backend puissent changer, les clients frontends ne devraient pas avoir besoin de le savoir, pas plus qu'ils ne doivent suivre eux-mêmes l'ensemble des backends.</p><p>L'abstraction du service permet ce découplage.</p><h3 id=découverte-de-services-native-du-cloud>Découverte de services native du cloud</h3><p>Si vous pouvez utiliser les API Kubernetes pour la découverte de services dans votre application, vous pouvez interroger l'<a class=glossary-tooltip title="Composant sur le master qui expose l'API Kubernetes. Il s'agit du front-end pour le plan de contrôle Kubernetes." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API server'>API server</a> pour les Endpoints, qui sont mis à jour chaque fois que l'ensemble des pods d'un service change.</p><p>Pour les applications non natives, Kubernetes propose des moyens de placer un port réseau ou un load balancer entre votre application et les modules backend.</p><h2 id=définition-d-un-service>Définition d'un service</h2><p>Un service dans Kubernetes est un objet REST, semblable à un pod.
Comme tous les objets REST, vous pouvez effectuer un <code>POST</code> d'une définition de service sur le serveur API pour créer une nouvelle instance.</p><p>Par exemple, supposons que vous ayez un ensemble de pods qui écoutent chacun sur le port TCP 9376 et portent une étiquette <code>app.kubernetes.io/name=MyApp</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Cette spécification crée un nouvel objet Service nommé «my-service», qui cible le port TCP 9376 sur n'importe quel pod avec l'étiquette «app.kubernetes.io/name=MyApp».</p><p>Kubernetes attribue à ce service une adresse IP (parfois appelé l'"IP cluster"), qui est utilisé par les proxies Service (voir <a href=#virtual-ips-and-service-proxies>IP virtuelles et proxy de service</a>).</p><p>Le contrôleur de service recherche en continu les pods qui correspondent à son sélecteur, puis POST toutes les mises à jour d'un objet Endpoint également appelé "my-service".</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Un service peut mapper <em>n'importe quel</em> <code>port</code> entrant vers un <code>targetPort</code>.
Par défaut et pour plus de commodité, le <code>targetPort</code> a la même valeur que le champ <code>port</code>.</div><p>Les définitions de port dans les pods ont des noms, et vous pouvez référencer ces noms dans l'attribut <code>targetPort</code> d'un service.
Cela fonctionne même s'il existe un mélange de pods dans le service utilisant un seul nom configuré, avec le même protocole réseau disponible via différents numéros de port.
Cela offre beaucoup de flexibilité pour déployer et faire évoluer vos services.
Par exemple, vous pouvez modifier les numéros de port que les pods exposent dans la prochaine version de votre logiciel principal, sans casser les clients.</p><p>Le protocole par défaut pour les services est TCP; vous pouvez également utiliser tout autre <a href=#protocol-support>protocole pris en charge</a>.</p><p>Comme de nombreux services doivent exposer plus d'un port, Kubernetes prend en charge plusieurs définitions de port sur un objet Service.
Chaque définition de port peut avoir le même protocole, ou un autre.</p><h3 id=services-sans-sélecteurs>Services sans sélecteurs</h3><p>Les services abritent le plus souvent l'accès aux pods Kubernetes, mais ils peuvent également abstraire d'autres types de backends.
Par exemple:</p><ul><li>Vous voulez avoir un cluster de base de données externe en production, mais dans votre environnement de test, vous utilisez vos propres bases de données.</li><li>Vous souhaitez pointer votre service vers un service dans un autre <a class=glossary-tooltip title='An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a> ou sur un autre cluster.</li><li>Vous migrez une charge de travail vers Kubernetes.
Lors de l'évaluation de l'approche, vous exécutez uniquement une partie de vos backends dans Kubernetes.</li></ul><p>Dans n'importe lequel de ces scénarios, vous pouvez définir un service <em>sans</em> un sélecteur de pod.
Par exemple:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Étant donné que ce service n'a pas de sélecteur, l'objet Endpoint correspondant n'est <em>pas</em> créé automatiquement.
Vous pouvez mapper manuellement le service à l'adresse réseau et au port où il s'exécute, en ajoutant manuellement un objet Endpoint:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subsets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>192.0.2.42</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Les IP de noeud final ne doivent pas être: loopback (127.0.0.0/8 pour IPv4, ::1/128 pour IPv6), ou link-local (169.254.0.0/16 et 224.0.0.0/24 pour IPv4, fe80::/64 pour IPv6).</p><p>Les adresses IP de noeud final ne peuvent pas être les adresses IP de cluster d'autres services Kubernetes, car <a class=glossary-tooltip title="kube-proxy est un proxy réseau qui s'exécute sur chaque nœud du cluster." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a> ne prend pas en charge les adresses IP virtuelles en tant que destination.</p></div><p>L'accès à un service sans sélecteur fonctionne de la même manière que s'il avait un sélecteur.
Dans l'exemple ci-dessus, le trafic est routé vers le Endpoint unique défini dans le YAML: <code>192.0.2.42:9376</code> (TCP).</p><p>Un service ExternalName est un cas spécial de service qui n'a pas de sélecteurs et utilise des noms DNS à la place.
Pour plus d'informations, consultez la section <a href=#externalname>ExternalName</a> plus loin dans ce document.</p><h3 id=endpoint-slices>Endpoint Slices</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p>Un Endpoint Slices est une ressource API qui peut fournir une alternative plus évolutive au Endpoints.
Bien que conceptuellement assez similaire aux Endpoints, les Endpoint Slices permettent la distribution des endpoints réseau sur plusieurs ressources.
Par défaut, un Endpoint Slice est considéré comme "plein" une fois qu'il atteint 100 endpoints, au delà, des Endpoint Slices addtionnels seront crées pour stocker tout autre endpoints.</p><p>Les Endpoint Slices fournissent des attributs et des fonctionnalités supplémentaires qui sont décrits en détail dans <a href=/docs/concepts/services-networking/endpoint-slices/>Endpoint Slices</a>.</p><h2 id=ip-virtuelles-et-proxy-de-service>IP virtuelles et proxy de service</h2><p>Chaque nœud d'un cluster Kubernetes exécute un <code>kube-proxy</code>.
<code>kube-proxy</code> est responsable de l'implémentation d'une forme d'IP virtuelle pour les <code>Services</code> qui ne sont pas de type <a href=#externalname><code>ExternalName</code></a>.</p><h3 id=pourquoi-ne-pas-utiliser-le-dns-round-robin>Pourquoi ne pas utiliser le DNS round-robin ?</h3><p>Une question qui apparaît de temps en temps est pourquoi Kubernetes s'appuie sur le proxy pour transférer le trafic entrant vers les backends.
Et les autres approches?
Par exemple, serait-il possible de configurer des enregistrements DNS qui ont plusieurs valeurs A (ou AAAA pour IPv6), et de s'appuyer sur la résolution de nom à tour de rôle (round-robin)?</p><p>Il existe plusieurs raisons d'utiliser le proxy pour les services:</p><ul><li>Il existe une longue histoire d'implémentations DNS ne respectant pas les TTL d'enregistrement et mettant en cache les résultats des recherches de noms après leur expiration.</li><li>Certaines applications n'effectuent des recherches DNS qu'une seule fois et mettent en cache les résultats indéfiniment.</li><li>Même si les applications et les bibliothèques ont fait une bonne résolution, les TTL faibles ou nuls sur les enregistrements DNS pourraient imposer une charge élevée sur DNS qui devient alors difficile à gérer.</li></ul><h3 id=proxy-mode-userspace>User space proxy mode</h3><p>Dans ce mode, kube-proxy surveille le maître Kubernetes pour l'ajout et la suppression d'objets Service et Endpoint.
Pour chaque service, il ouvre un port (choisi au hasard) sur le nœud local.
Toutes les connexions à ce "port proxy" sont transmises par proxy à l'un des modules backend du service (comme indiqué via les Endpoints).
kube-proxy prend en compte le paramètre <code>SessionAffinity</code> du service pour décider quel pod backend utiliser.</p><p>Enfin, le proxy de l'espace utilisateur installe des règles iptables qui capturent le trafic vers le service <code>clusterIP</code> (qui est virtuel) et <code>port</code>.
Les règles redirigent ce trafic vers le port proxy qui fait office de proxy pour le Pod de backend.</p><p>Par défaut, kube-proxy en mode espace utilisateur choisit un backend via un algorithme round-robin.</p><p><img src=/images/docs/services-userspace-overview.svg alt="Diagramme de vue d'ensemble des services pour le proxy de l'espace utilisateur"></p><h3 id=proxy-mode-iptables><code>iptables</code> proxy mode</h3><p>Dans ce mode, kube-proxy surveille le plan de contrôle Kubernetes pour l'ajout et la suppression d'objets Service et Endpoint.
Pour chaque service, il installe des règles iptables, qui capturent le trafic vers le «clusterIP» et le «port» du service, et redirigent ce trafic vers l'un des ensembles principaux du service.
Pour chaque objet Endpoint, il installe des règles iptables qui sélectionnent un Pod de backend.</p><p>Par défaut, kube-proxy en mode iptables choisit un backend au hasard.</p><p>L'utilisation d'iptables pour gérer le trafic a un coût système inférieur, car le trafic est géré par Linux netfilter sans avoir besoin de basculer entre l'espace utilisateur et l'espace noyau.
Cette approche est également susceptible d'être plus fiable.</p><p>Si kube-proxy s'exécute en mode iptables et que le premier pod sélectionné ne répond pas, la connexion échoue.
C'est différent du mode espace utilisateur: dans ce scénario, kube-proxy détecterait que la connexion au premier pod avait échoué et réessayerait automatiquement avec un pod backend différent.</p><p>Vous pouvez utiliser les <a href=/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>readiness probes</a> d'un Pod pour vérifier que les pods backend fonctionnent correctement, de sorte que kube-proxy en mode iptables ne voit que les backends testés comme sains.
Cela signifie que vous évitez d'envoyer du trafic via kube-proxy vers un pod connu pour avoir échoué.</p><p><img src=/images/docs/services-iptables-overview.svg alt="Diagramme de présentation des services pour le proxy iptables"></p><h3 id=proxy-mode-ipvs>IPVS proxy mode</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [stable]</code></div><p>En mode <code>ipvs</code>, kube-proxy surveille les Services et Endpoints Kubernetes. kube-proxy appelle l'interface <code>netlink</code> pour créer les règles IPVS en conséquence et synchronise périodiquement les règles IPVS avec les Services et Endpoints Kubernetes.
Cette boucle de contrôle garantit que l'état IPVS correspond à l'état souhaité.
Lors de l'accès à un service, IPVS dirige le trafic vers l'un des pods backend.</p><p>Le mode proxy IPVS est basé sur des fonctions hooks de netfilter qui est similaire au mode iptables, mais utilise la table de hachage comme structure de données sous-jacente et fonctionne dans l'espace du noyau.
Cela signifie que kube-proxy en mode IPVS redirige le trafic avec une latence plus faible que kube-proxy en mode iptables, avec de bien meilleures performances lors de la synchronisation des règles de proxy.
Par rapport aux autres modes proxy, le mode IPVS prend également en charge un débit plus élevé de trafic réseau.</p><p>IPVS offre plus d'options pour équilibrer le trafic vers les pods d'arrière-plan; ceux-ci sont:</p><ul><li><code>rr</code>: round-robin</li><li><code>lc</code>: least connection (plus petit nombre de connexions ouvertes)</li><li><code>dh</code>: destination hashing</li><li><code>sh</code>: source hashing</li><li><code>sed</code>: shortest expected delay</li><li><code>nq</code>: never queue</li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Pour exécuter kube-proxy en mode IPVS, vous devez rendre IPVS Linux disponible sur le nœud avant de démarrer kube-proxy.</p><p>Lorsque kube-proxy démarre en mode proxy IPVS, il vérifie si les modules du noyau IPVS sont disponibles.
Si les modules du noyau IPVS ne sont pas détectés, alors kube-proxy revient à fonctionner en mode proxy iptables.</p></div><p><img src=/images/docs/services-ipvs-overview.svg alt="Diagramme de vue d'ensemble des services pour le proxy IPVS"></p><p>Dans ces modèles de proxy, le trafic lié à l'IP: Port du service est dirigé vers un backend approprié sans que les clients ne sachent quoi que ce soit sur Kubernetes, les services ou les pods.</p><p>Si vous souhaitez vous assurer que les connexions d'un client particulier sont transmises à chaque fois au même pod, vous pouvez sélectionner l'affinité de session en fonction des adresses IP du client en définissant <code>service.spec.sessionAffinity</code> sur" ClientIP "(la valeur par défaut est" None").
Vous pouvez également définir la durée maximale de session persistante en définissant <code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> de manière appropriée (la valeur par défaut est 10800, ce qui correspond à 3 heures).</p><h2 id=services-multi-ports>Services multi-ports</h2><p>Pour certains services, vous devez exposer plusieurs ports.
Kubernetes vous permet de configurer plusieurs définitions de port sur un objet Service.
Lorsque vous utilisez plusieurs ports pour un service, vous devez donner tous vos noms de ports afin qu'ils ne soient pas ambigus.
Par exemple:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Comme pour tous les <a class=glossary-tooltip title='A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/names target=_blank aria-label=names>names</a> Kubernetes en général, les noms de ports ne doivent contenir que des caractères alphanumériques en minuscules et <code>-</code>.
Les noms de port doivent également commencer et se terminer par un caractère alphanumérique.</p><p>Par exemple, les noms <code>123-abc</code> et <code>web</code> sont valides, mais <code>123_abc</code> et <code>-web</code> ne le sont pas.</p></div><h2 id=choisir-sa-propre-adresse-ip>Choisir sa propre adresse IP</h2><p>Vous pouvez spécifier votre propre adresse IP de cluster dans le cadre d'une demande de création de Service.
Pour ce faire, définissez le champ <code>.spec.clusterIP</code>.
Par exemple, si vous avez déjà une entrée DNS existante que vous souhaitez réutiliser, ou des systèmes existants qui sont configurés pour une adresse IP spécifique et difficiles à reconfigurer.</p><p>L'adresse IP que vous choisissez doit être une adresse IPv4 ou IPv6 valide dans la plage CIDR <code>service-cluster-ip-range</code> configurée pour le serveur API.
Si vous essayez de créer un service avec une valeur d'adresse de clusterIP non valide, le serveur API retournera un code d'état HTTP 422 pour indiquer qu'il y a un problème.</p><h2 id=découvrir-les-services>Découvrir les services</h2><p>Kubernetes prend en charge 2 modes principaux de recherche d'un service: les variables d'environnement et DNS.</p><h3 id=variables-d-environnement>Variables d'environnement</h3><p>Lorsqu'un pod est exécuté sur un nœud, le kubelet ajoute un ensemble de variables d'environnement pour chaque service actif.
Il prend en charge à la fois les variables <a href=https://docs.docker.com/userguide/dockerlinks/>Docker links</a> (voir <a href=http://releases.k8s.io/master/pkg/kubelet/envvars/envvars.go#L49>makeLinkVariables</a>) et plus simplement les variables <code>{SVCNAME}_SERVICE_HOST</code> et <code>{SVCNAME}_SERVICE_PORT</code>, où le nom du service est en majuscules et les tirets sont convertis en underscore.</p><p>Par exemple, le service <code>redis-master</code> qui expose le port TCP 6379 et a reçu l'adresse IP de cluster 10.0.0.11, produit les variables d'environnement suivantes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_SERVICE_HOST</span><span style=color:#666>=</span>10.0.0.11
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_SERVICE_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PROTO</span><span style=color:#666>=</span>tcp
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_ADDR</span><span style=color:#666>=</span>10.0.0.11
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Lorsque vous avez un pod qui doit accéder à un service et que vous utilisez la méthode des variables d'environnement pour publier le port et l'IP du cluster sur les pods clients, vous devez créer le service <em>avant</em> que les pods clients n'existent.
Sinon, ces pods clients n'auront pas leurs variables d'environnement remplies.</p><p>Si vous utilisez uniquement DNS pour découvrir l'IP du cluster pour un service, vous n'avez pas à vous soucier de ce problème de commande.</p></div><h3 id=dns>DNS</h3><p>Vous pouvez (et devriez presque toujours) configurer un service DNS pour votre cluster Kubernetes à l'aide d'un <a href=/docs/concepts/cluster-administration/addons/>add-on</a>.</p><p>Un serveur DNS prenant en charge les clusters, tel que CoreDNS, surveille l'API Kubernetes pour les nouveaux services et crée un ensemble d'enregistrements DNS pour chacun.
Si le DNS a été activé dans votre cluster, tous les pods devraient automatiquement être en mesure de résoudre les services par leur nom DNS.</p><p>Par exemple, si vous avez un service appelé <code>"my-service"</code> dans un namespace Kubernetes <code>"my-ns"</code>, le plan de contrôle et le service DNS agissant ensemble et créent un enregistrement DNS pour <code>"my-service.my-ns"</code>.
Les Pods dans le Namespace <code>"my-ns"</code> devrait être en mesure de le trouver en faisant simplement une recherche de nom pour <code>my-service</code> (<code>"my-service.my-ns"</code> fonctionnerait également).</p><p>Les pods dans d'autres namespaces doivent utiliser le nom de <code>my-service.my-ns</code>.
Ces noms seront résolus en IP de cluster attribuée pour le service.</p><p>Kubernetes prend également en charge les enregistrements DNS SRV (Service) pour les ports nommés.
Si le service <code>"my-service.my-ns"</code> a un port nommé <code>http</code> avec un protocole défini sur <code>TCP</code>, vous pouvez effectuer une requête DNS SRV pour <code>_http._tcp.my-service.my-ns</code> pour découvrir le numéro de port de <code>http</code>, ainsi que l'adresse IP.</p><p>Le serveur DNS Kubernetes est le seul moyen d'accéder aux services <code>ExternalName</code>.
Vous pouvez trouver plus d'informations sur la résolution de <code>ExternalName</code> dans <a href=/docs/concepts/services-networking/dns-pod-service/>DNS Pods et Services</a>.</p><h2 id=headless-services>Headless Services</h2><p>Parfois, vous n'avez pas besoin de load-balancing et d'une seule IP de Service.
Dans ce cas, vous pouvez créer ce que l'on appelle des services "headless", en spécifiant explicitement "None" pour l'IP du cluster (<code>.spec.clusterIP</code>).</p><p>Vous pouvez utiliser un service headless pour interfacer avec d'autres mécanismes de découverte de service, sans être lié à l'implémentation de Kubernetes.</p><p>Pour les services headless, une IP de cluster n'est pas allouée, kube-proxy ne gère pas ces services et aucun load-balancing ou proxy n'est effectué par la plateforme pour eux.
La configuration automatique de DNS dépend de la définition ou non de sélecteurs par le service:</p><h3 id=avec-sélecteurs>Avec sélecteurs</h3><p>Pour les services headless qui définissent des sélecteurs, le controlleur des Endpoints crée des enregistrements <code>Endpoints</code> dans l'API, et modifie la configuration DNS pour renvoyer des enregistrements (adresses) qui pointent directement vers les <code>Pods</code> visés par le <code>Service</code>.</p><h3 id=sans-sélecteurs>Sans sélecteurs</h3><p>Pour les services headless qui ne définissent pas de sélecteurs, le contrôleur des Endpoints ne crée pas d'enregistrements <code>Endpoints</code>.
Cependant, le système DNS recherche et configure soit:</p><ul><li>Enregistrements CNAME pour les services de type <a href=#externalname><code>ExternalName</code></a>.</li><li>Un enregistrement pour tous les «Endpoints» qui partagent un nom avec le Service, pour tous les autres types.</li></ul><h2 id=publishing-services-service-types>Services de publication (ServiceTypes)</h2><p>Pour certaines parties de votre application (par exemple, les frontaux), vous souhaiterez peut-être exposer un service sur une adresse IP externe, qui est en dehors de votre cluster.</p><p>Les «ServiceTypes» de Kubernetes vous permettent de spécifier le type de service que vous souhaitez.
La valeur par défaut est «ClusterIP».</p><p>Les valeurs de <code>Type</code> et leurs comportements sont:</p><ul><li><code>ClusterIP</code>: Expose le service sur une IP interne au cluster.
Le choix de cette valeur rend le service uniquement accessible à partir du cluster.
Il s'agit du <code>ServiceType</code> par défaut.</li><li><a href=#type-nodeport><code>NodePort</code></a>: Expose le service sur l'IP de chaque nœud sur un port statique (le <code>NodePort</code>).
Un service <code>ClusterIP</code>, vers lequel le service <code>NodePort</code> est automatiquement créé.
Vous pourrez contacter le service <code>NodePort</code>, depuis l'extérieur du cluster, en demandant <code>&lt;NodeIP>: &lt;NodePort></code>.</li><li><a href=#loadbalancer><code>LoadBalancer</code></a>: Expose le service en externe à l'aide de l'équilibreur de charge d'un fournisseur de cloud.
Les services <code>NodePort</code> et <code>ClusterIP</code>, vers lesquels les itinéraires de l'équilibreur de charge externe, sont automatiquement créés.</li><li><a href=#externalname><code>ExternalName</code></a>: Mappe le service au contenu du champ <code>externalName</code> (par exemple <code>foo.bar.example.com</code>), en renvoyant un enregistrement <code>CNAME</code> avec sa valeur.
Aucun proxy d'aucune sorte n'est mis en place.<div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous avez besoin de CoreDNS version 1.7 ou supérieure pour utiliser le type <code>ExternalName</code>.</div></li></ul><p>Vous pouvez également utiliser <a href=/fr/docs/concepts/services-networking/ingress>Ingress</a> pour exposer votre service.
Ingress n'est pas un type de service, mais il sert de point d'entrée pour votre cluster.
Il vous permet de consolider vos règles de routage en une seule ressource car il peut exposer plusieurs services sous la même adresse IP.</p><h3 id=type-nodeport>Type NodePort</h3><p>Si vous définissez le champ <code>type</code> sur<code> NodePort</code>, le plan de contrôle Kubernetes alloue un port à partir d'une plage spécifiée par l'indicateur <code>--service-node-port-range</code> (par défaut: 30000-32767).
Chaque nœud assure le proxy de ce port (le même numéro de port sur chaque nœud) vers votre service.
Votre service signale le port alloué dans son champ <code>.spec.ports[*].nodePort</code>.</p><p>Si vous souhaitez spécifier une ou des adresses IP particulières pour proxyfier le port, vous pouvez définir l'indicateur <code>--nodeport-addresses</code> dans kube-proxy sur des blocs IP particuliers; cela est pris en charge depuis Kubernetes v1.10.
Cet indicateur prend une liste délimitée par des virgules de blocs IP (par exemple 10.0.0.0/8, 192.0.2.0/25) pour spécifier les plages d'adresses IP que kube-proxy doit considérer comme locales pour ce nœud.</p><p>Par exemple, si vous démarrez kube-proxy avec l'indicateur <code>--nodeport-addresses=127.0.0.0/8</code>, kube-proxy sélectionne uniquement l'interface de boucle locale pour les services NodePort.
La valeur par défaut pour <code>--nodeport-addresses</code> est une liste vide.
Cela signifie que kube-proxy doit prendre en compte toutes les interfaces réseau disponibles pour NodePort (qui est également compatible avec les versions antérieures de Kubernetes).</p><p>Si vous voulez un numéro de port spécifique, vous pouvez spécifier une valeur dans le champ <code>nodePort</code>.
Le plan de contrôle vous attribuera ce port ou signalera l'échec de la transaction API.
Cela signifie que vous devez vous occuper vous-même des éventuelles collisions de ports.
Vous devez également utiliser un numéro de port valide, celui qui se trouve dans la plage configurée pour l'utilisation de NodePort.</p><p>L'utilisation d'un NodePort vous donne la liberté de configurer votre propre solution d'équilibrage de charge, de configurer des environnements qui ne sont pas entièrement pris en charge par Kubernetes, ou même d'exposer directement les adresses IP d'un ou plusieurs nœuds.</p><p>Notez que ce service est visible en tant que <code>&lt;NodeIP>: spec.ports[*].nodePort</code> et <code>.spec.clusterIP: spec.ports[*].Port</code>.
(Si l'indicateur <code>--nodeport-addresses</code> dans kube-proxy est défini, <nodeip>serait filtré NodeIP(s).)</p><h3 id=loadbalancer>Type LoadBalancer</h3><p>Sur les fournisseurs de cloud qui prennent en charge les load balancers externes, la définition du champ <code>type</code> sur<code> LoadBalancer</code> provisionne un load balancer pour votre service.
La création réelle du load balancer se produit de manière asynchrone et les informations sur le load balancer provisionné sont publiées dans le champ <code>.status.loadBalancer</code>.
Par exemple:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.171.239</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>192.0.2.127</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Le trafic provenant du load balancer externe est dirigé vers les Pods backend.
Le fournisseur de cloud décide de la répartition de la charge.</p><p>Certains fournisseurs de cloud vous permettent de spécifier le <code>loadBalancerIP</code>.
Dans ces cas, le load balancer est créé avec le <code>loadBalancerIP</code> spécifié par l'utilisateur.
Si le champ <code>loadBalancerIP</code> n'est pas spécifié, le loadBalancer est configuré avec une adresse IP éphémère.
Si vous spécifiez un <code>loadBalancerIP</code> mais que votre fournisseur de cloud ne prend pas en charge la fonctionnalité, le champ <code>loadBalancerIP</code> que vous définissez est ignoré.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si vous utilisez SCTP, voir le <a href=#caveat-sctp-loadbalancer-service-type>caveat</a> ci-dessous sur le type de service <code>LoadBalancer</code>.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Sur <strong>Azure</strong>, si vous souhaitez utiliser un type public spécifié par l'utilisateur <code>loadBalancerIP</code>, vous devez d'abord créer une ressource d'adresse IP publique de type statique.
Cette ressource d'adresse IP publique doit se trouver dans le même groupe de ressources que les autres ressources créées automatiquement du cluster.
Par exemple, <code>MC_myResourceGroup_myAKSCluster_eastus</code>.</p><p>Spécifiez l'adresse IP attribuée en tant que loadBalancerIP.
Assurez-vous d'avoir mis à jour le securityGroupName dans le fichier de configuration du fournisseur de cloud.
Pour plus d'informations sur le dépannage <code>CreatingLoadBalancerFailed</code> relatif aux permissions consultez: <a href=https://docs.microsoft.com/en-us/azure/aks/static-ip>Use a static IP address with the Azure Kubernetes Service (AKS) load balancer</a> ou <a href=https://github.com/Azure/AKS/issues/357>CreatingLoadBalancerFailed on AKS cluster with advanced networking</a>.</p></div><h4 id=load-balancer-interne>Load Balancer interne</h4><p>Dans un environnement mixte, il est parfois nécessaire d'acheminer le trafic des services à l'intérieur du même bloc d'adresse réseau (virtuel).</p><p>Dans un environnement DNS à horizon divisé, vous auriez besoin de deux services pour pouvoir acheminer le trafic externe et interne vers vos endpoints.</p><p>Vous pouvez y parvenir en ajoutant une des annotations suivantes à un service.
L'annotation à ajouter dépend du fournisseur de services cloud que vous utilisez.</p><ul class="nav nav-tabs" id=service-tabs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#service-tabs-0 role=tab aria-controls=service-tabs-0 aria-selected=true>Default</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-1 role=tab aria-controls=service-tabs-1>GCP</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-2 role=tab aria-controls=service-tabs-2>AWS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-3 role=tab aria-controls=service-tabs-3>Azure</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-4 role=tab aria-controls=service-tabs-4>OpenStack</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-5 role=tab aria-controls=service-tabs-5>Baidu Cloud</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-6 role=tab aria-controls=service-tabs-6>Tencent Cloud</a></li></ul><div class=tab-content id=service-tabs><div id=service-tabs-0 class="tab-pane show active" role=tabpanel aria-labelledby=service-tabs-0><p><p>Sélectionnez l'un des onglets.</p></div><div id=service-tabs-1 class=tab-pane role=tabpanel aria-labelledby=service-tabs-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cloud.google.com/load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Internal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-2 class=tab-pane role=tabpanel aria-labelledby=service-tabs-2><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-3 class=tab-pane role=tabpanel aria-labelledby=service-tabs-3><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/azure-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-4 class=tab-pane role=tabpanel aria-labelledby=service-tabs-4><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/openstack-internal-load-balancer</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-5 class=tab-pane role=tabpanel aria-labelledby=service-tabs-5><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/cce-load-balancer-internal-vpc</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-6 class=tab-pane role=tabpanel aria-labelledby=service-tabs-6><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internal-subnetid</span>:<span style=color:#bbb> </span>subnet-xxxxx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h4 id=ssl-support-on-aws>Prise en charge TLS sur AWS</h4><p>Pour une prise en charge partielle de TLS / SSL sur des clusters exécutés sur AWS, vous pouvez ajouter trois annotations à un service <code>LoadBalancer</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-cert</span>:<span style=color:#bbb> </span>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012<span style=color:#bbb>
</span></span></span></code></pre></div><p>Le premier spécifie l'ARN du certificat à utiliser.
Il peut s'agir soit d'un certificat d'un émetteur tiers qui a été téléchargé sur IAM, soit d'un certificat créé dans AWS Certificate Manager.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>(https|http|ssl|tcp)<span style=color:#bbb>
</span></span></span></code></pre></div><p>La deuxième annotation spécifie le protocole utilisé par un pod.
Pour HTTPS et SSL, l'ELB s'attend à ce que le pod s'authentifie sur la connexion chiffrée, à l'aide d'un certificat.</p><p>HTTP et HTTPS sélectionnent le proxy de couche 7: l'ELB met fin à la connexion avec l'utilisateur, analyse les en-têtes et injecte l'en-tête <code>X-Forwarded-For</code> avec l'adresse IP de l'utilisateur (les pods ne voient que l'adresse IP de l'ELB à l'autre extrémité de sa connexion) lors du transfert des demandes.</p><p>TCP et SSL sélectionnent le proxy de couche 4: l'ELB transfère le trafic sans modifier les en-têtes.</p><p>Dans un environnement à usage mixte où certains ports sont sécurisés et d'autres non chiffrés, vous pouvez utiliser les annotations suivantes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-ports</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;443,8443&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Dans l'exemple ci-dessus, si le service contenait trois ports, «80», «443» et «8443», alors «443» et «8443» utiliseraient le certificat SSL, mais «80» serait simplement un proxy HTTP.</p><p>A partir de Kubernetes v1.9, vous pouvez utiliser des <a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html>stratégies SSL AWS prédéfinies</a> avec des écouteurs HTTPS ou SSL pour vos services.
Pour voir quelles politiques sont disponibles, vous pouvez utiliser l'outil de ligne de commande <code>aws</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>aws elb describe-load-balancer-policies --query <span style=color:#b44>&#39;PolicyDescriptions[].PolicyName&#39;</span>
</span></span></code></pre></div><p>Vous pouvez ensuite spécifier l'une de ces stratégies à l'aide de l'annotation "<code>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</code>"; par exemple:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ELBSecurityPolicy-TLS-1-2-2017-01&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=prise-en-charge-du-protocole-proxy-sur-aws>Prise en charge du protocole PROXY sur AWS</h4><p>Pour activer <a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>protocole PROXY</a> prise en charge des clusters exécutés sur AWS, vous pouvez utiliser l'annotation de service suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Depuis la version 1.3.0, l'utilisation de cette annotation s'applique à tous les ports mandatés par l'ELB et ne peut pas être configurée autrement.</p><h4 id=journaux-d-accès-elb-sur-aws>Journaux d'accès ELB sur AWS</h4><p>Il existe plusieurs annotations pour gérer les journaux d'accès aux services ELB sur AWS.</p><p>L'annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</code> contrôle si les journaux d'accès sont activés.</p><p>L'annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</code> contrôle l'intervalle en minutes pour la publication des journaux d'accès.
Vous pouvez spécifier un intervalle de 5 ou 60 minutes.</p><p>L'annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</code> contrôle le nom du bucket Amazon S3 où les journaux d'accès au load balancer sont stockés.</p><p>L'annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</code> spécifie la hiérarchie logique que vous avez créée pour votre bucket Amazon S3.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Spécifie si les journaux d&#39;accès sont activés pour le load balancer</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># L&#39;intervalle de publication des journaux d&#39;accès.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Vous pouvez spécifier un intervalle de 5 ou 60 (minutes).</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Le nom du bucket Amazon S3 où les journaux d&#39;accès sont stockés</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket-prefix/prod&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># La hiérarchie logique que vous avez créée pour votre bucket Amazon S3, par exemple `my-bucket-prefix/prod`</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=drainage-de-connexion-sur-aws>Drainage de connexion sur AWS</h4><p>Le drainage des connexions pour les ELB classiques peut être géré avec l'annotation <code>service.beta.kubernetes.io / aws-load-balancer-connection-draining-enabled</code> définie sur la valeur <code>true</code>.
L'annotation <code>service.beta.kubernetes.io / aws-load-balancer-connection-draining-timeout</code> peut également être utilisée pour définir la durée maximale, en secondes, pour garder les connexions existantes ouvertes avant de désenregistrer les instances.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=autres-annotations-elb>Autres annotations ELB</h4><p>Il existe d'autres annotations pour gérer les Elastic Load Balancers décrits ci-dessous.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Délai, en secondes, pendant lequel la connexion peut être inactive (aucune donnée n&#39;a été envoyée via la connexion) avant d&#39;être fermée par le load balancer</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Spécifie si le load balancing inter-zones est activé pour le load balancer</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;environment=prod,owner=devops&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Une liste de paires clé-valeur séparées par des virgules qui seront enregistrées en tant que balises supplémentaires dans l&#39;ELB.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Nombre de contrôles de santé successifs réussis requis pour qu&#39;un backend soit considéré comme sain pour le trafic.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># La valeur par défaut est 2, doit être comprise entre 2 et 10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Nombre de contrôles de santé infructueux requis pour qu&#39;un backend soit considéré comme inapte pour le trafic.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># La valeur par défaut est 6, doit être comprise entre 2 et 10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Intervalle approximatif, en secondes, entre les contrôles d&#39;intégrité d&#39;une instance individuelle.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># La valeur par défaut est 10, doit être comprise entre 5 et 300</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Durée, en secondes, pendant laquelle aucune réponse ne signifie l&#39;échec d&#39;un contrôle de santé.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Cette valeur doit être inférieure à la valeur service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># La valeur par défaut est 5, doit être comprise entre 2 et 60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-extra-security-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sg-53fae93f,sg-42efd82e&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Une liste de groupes de sécurité supplémentaires à ajouter à l&#39;ELB</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=aws-nlb-support>Prise en charge du load balancer réseau sur AWS</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code></div><p>Pour utiliser un load balancer réseau sur AWS, utilisez l'annotation <code>service.beta.kubernetes.io/aws-load-balancer-type</code> avec la valeur définie sur <code>nlb</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nlb&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> NLB ne fonctionne qu'avec certaines classes d'instance; voir la <a href=http://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets>documentation AWS</a> sur Elastic Load Balancing pour une liste des types d'instances pris en charge.</div><p>Contrairement aux équilibreurs de charge élastiques classiques, les équilibreurs de charge réseau (NLB) transfèrent l'adresse IP du client jusqu'au nœud.
Si un service est <code>.spec.externalTrafficPolicy</code> est réglé sur <code>Cluster</code>, l'adresse IP du client n'est pas propagée aux pods finaux.</p><p>En définissant <code>.spec.externalTrafficPolicy</code> à <code>Local</code>, les adresses IP des clients sont propagées aux pods finaux, mais cela peut entraîner une répartition inégale du trafic.
Les nœuds sans pods pour un service LoadBalancer particulier échoueront au contrôle de santé du groupe cible NLB sur le <code>.spec.healthCheckNodePort</code> attribué automatiquement et ne recevront aucun trafic.</p><p>Pour obtenir un trafic uniforme, utilisez un DaemonSet ou spécifiez un <a href=/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity>pod anti-affinity</a> pour ne pas localiser sur le même noeud.</p><p>Vous pouvez également utiliser les services NLB avec l'annotation <a href=/docs/concepts/services-networking/service/#internal-load-balancer>load balancer internal</a>.</p><p>Pour que le trafic client atteigne des instances derrière un NLB, les groupes de sécurité du nœud sont modifiés avec les règles IP suivantes:</p><table><thead><tr><th>Rule</th><th>Protocol</th><th>Port(s)</th><th>IpRange(s)</th><th>IpRange Description</th></tr></thead><tbody><tr><td>Health Check</td><td>TCP</td><td>NodePort(s) (<code>.spec.healthCheckNodePort</code> for <code>.spec.externalTrafficPolicy = Local</code>)</td><td>VPC CIDR</td><td>kubernetes.io/rule/nlb/health=&lt;loadBalancerName></td></tr><tr><td>Client Traffic</td><td>TCP</td><td>NodePort(s)</td><td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td><td>kubernetes.io/rule/nlb/client=&lt;loadBalancerName></td></tr><tr><td>MTU Discovery</td><td>ICMP</td><td>3,4</td><td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td><td>kubernetes.io/rule/nlb/mtu=&lt;loadBalancerName></td></tr></tbody></table><p>Afin de limiter les IP clientes pouvant accéder à l'équilibreur de charge réseau, spécifiez <code>loadBalancerSourceRanges</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancerSourceRanges</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;143.231.0.0/16&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si <code>.spec.loadBalancerSourceRanges</code> n'est pas défini, Kubernetes autorise le trafic de <code>0.0.0.0/0</code> vers les groupes de sécurité des nœuds.
Si les nœuds ont des adresses IP publiques, sachez que le trafic non NLB peut également atteindre toutes les instances de ces groupes de sécurité modifiés.</div><h4 id=autres-annotations-clb-sur-tencent-kubernetes-engine-tke>Autres annotations CLB sur Tencent Kubernetes Engine (TKE)</h4><p>Il existe d'autres annotations pour la gestion des équilibreurs de charge cloud sur TKE, comme indiqué ci-dessous.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Lier des load balancers avec des nœuds spécifiques</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-backends-label</span>:<span style=color:#bbb> </span>key in (value1, value2)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ID d&#39;un load balancer existant</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>service.kubernetes.io/tke-existed-lbid：lb-6swtxxxx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Paramètres personnalisés pour le load balancer (LB), ne prend pas encore en charge la modification du type LB</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/service.extensiveParameters</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Paramètres personnalisés pour le listener LB</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/service.listenerParameters</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Spécifie le type de Load balancer;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># valeurs valides: classic (Classic Cloud Load Balancer) ou application (Application Cloud Load Balancer)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/loadbalance-type</span>:<span style=color:#bbb> </span>xxxxx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Spécifie la méthode de facturation de la bande passante du réseau public;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># valid values: TRAFFIC_POSTPAID_BY_HOUR(bill-by-traffic) and BANDWIDTH_POSTPAID_BY_HOUR (bill-by-bandwidth).</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internet-charge-type</span>:<span style=color:#bbb> </span>xxxxxx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Spécifie la valeur de bande passante (plage de valeurs: [1,2000] Mbps).</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internet-max-bandwidth-out</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Lorsque cette annotation est définie, les équilibreurs de charge n&#39;enregistrent que les nœuds sur lesquels le pod s&#39;exécute, sinon tous les nœuds seront enregistrés.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/local-svc-only-bind-node-with-pod</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=externalname>Type ExternalName</h3><p>Les services de type ExternalName mappent un service à un nom DNS, et non à un sélecteur standard tel que <code>my-service</code> ou <code>cassandra</code>.
Vous spécifiez ces services avec le paramètre <code>spec.externalName</code>.</p><p>Cette définition de service, par exemple, mappe le service <code>my-service</code> dans l'espace de noms<code> prod</code> à <code>my.database.example.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>prod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ExternalName<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalName</span>:<span style=color:#bbb> </span>my.database.example.com<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> ExternalName accepte une chaîne d'adresse IPv4, mais en tant que noms DNS composés de chiffres, et non en tant qu'adresse IP.
Les noms externes qui ressemblent aux adresses IPv4 ne sont pas résolus par CoreDNS ou ingress-nginx car ExternalName est destiné à spécifier un nom DNS canonique.
Pour coder en dur une adresse IP, pensez à utiliser des <a href=#headless-services>Services headless</a>.</div><p>Lors de la recherche de l'hôte <code>my-service.prod.svc.cluster.local</code>, le service DNS du cluster renvoie un enregistrement<code> CNAME</code> avec la valeur <code>my.database.example.com</code>.
L'accès à «mon-service» fonctionne de la même manière que les autres services, mais avec la différence cruciale que la redirection se produit au niveau DNS plutôt que via un proxy ou un transfert.
Si vous décidez ultérieurement de déplacer votre base de données dans votre cluster, vous pouvez démarrer ses pods, ajouter des sélecteurs ou des Endpoints appropriés et modifier le <code>type</code> du service.</p><div class="alert alert-danger warning callout" role=alert><strong>Attention:</strong><p>Vous pouvez rencontrer des difficultés à utiliser ExternalName pour certains protocoles courants, notamment HTTP et HTTPS.
Si vous utilisez ExternalName, le nom d'hôte utilisé par les clients à l'intérieur de votre cluster est différent du nom référencé par ExternalName.</p><p>Pour les protocoles qui utilisent des noms d'hôtes, cette différence peut entraîner des erreurs ou des réponses inattendues.
Les requêtes HTTP auront un en-tête <code>Host:</code> que le serveur d'origine ne reconnaît pas; Les serveurs TLS ne pourront pas fournir de certificat correspondant au nom d'hôte auquel le client s'est connecté.</p></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Cette section est redevable à l'article <a href=https://akomljen.com/kubernetes-tips-part-1/>Kubernetes Tips - Part 1</a> d'<a href=https://akomljen.com/>Alen Komljen</a>.</div><h3 id=ip-externes>IP externes</h3><p>S'il existe des adresses IP externes qui acheminent vers un ou plusieurs nœuds de cluster, les services Kubernetes peuvent être exposés sur ces "IP externes".
Le trafic qui pénètre dans le cluster avec l'IP externe (en tant qu'IP de destination), sur le port de service, sera routé vers l'un des Endpoints de service.
Les <code>externalIPs</code> ne sont pas gérées par Kubernetes et relèvent de la responsabilité de l'administrateur du cluster.</p><p>Dans la spécification de service, «externalIPs» peut être spécifié avec n'importe lequel des «ServiceTypes».
Dans l'exemple ci-dessous, "<code>my-service</code>" peut être consulté par les clients sur "<code>80.11.12.10:80</code>" (<code>externalIP:port</code>)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalIPs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#666>80.11.12.10</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=lacunes>Lacunes</h2><p>Le proxy fonctionnant dans l'espace utilisateur pour les VIP peut fonctionner à petite ou moyenne échelle, mais montrera ses limites dans de très grands clusters avec des milliers de services.
La <a href=http://issue.k8s.io/1107>proposition de conception originale pour les portails</a> a plus de détails à ce sujet.</p><p>L'utilisation du proxy de l'espace utilisateur masque l'adresse IP source d'un paquet accédant à un service.
Cela rend certains types de filtrage réseau (pare-feu) impossibles.
Le mode proxy iptables n'obscurcit pas les adresses IP source dans le cluster, mais il affecte toujours les clients passant par un <code>LoadBalancer</code> ou un <code>NodePort</code>.</p><p>Le champ <code>Type</code> est conçu comme une fonctionnalité imbriquée - chaque niveau s'ajoute au précédent.
Cela n'est pas strictement requis sur tous les fournisseurs de cloud (par exemple, Google Compute Engine n'a pas besoin d'allouer un <code>NodePort</code> pour faire fonctionner <code>LoadBalancer</code>, mais AWS le fait) mais l'API actuelle le requiert.</p><h2 id=the-gory-details-of-virtual-ips>Implémentation IP virtuelle</h2><p>Les informations précédentes devraient être suffisantes pour de nombreuses personnes qui souhaitent simplement utiliser les Services.
Cependant, il se passe beaucoup de choses dans les coulisses qui méritent d'être comprises.</p><h3 id=éviter-les-collisions>Éviter les collisions</h3><p>L'une des principales philosophies de Kubernetes est que vous ne devez pas être exposé à des situations qui pourraient entraîner l'échec de vos actions sans aucune faute de votre part.
Pour la conception de la ressource Service, cela signifie de ne pas vous faire choisir votre propre numéro de port si ce choix pourrait entrer en collision avec le choix de quelqu'un d'autre.
C'est un échec d'isolement.</p><p>Afin de vous permettre de choisir un numéro de port pour vos Services, nous devons nous assurer qu'aucun deux Services ne peuvent entrer en collision.
Kubernetes le fait en attribuant à chaque service sa propre adresse IP.</p><p>Pour garantir que chaque service reçoit une adresse IP unique, un allocateur interne met à jour atomiquement une carte d'allocation globale dans <a class=glossary-tooltip title='Base de données clé-valeur consistante et hautement disponible utilisée comme mémoire de sauvegarde pour toutes les données du cluster.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a> avant de créer chaque service.
L'objet de mappage doit exister dans le registre pour que les services obtiennent des affectations d'adresse IP, sinon les créations échoueront avec un message indiquant qu'une adresse IP n'a pas pu être allouée.</p><p>Dans le plan de contrôle, un contrôleur d'arrière-plan est responsable de la création de cette carte (nécessaire pour prendre en charge la migration à partir d'anciennes versions de Kubernetes qui utilisaient le verrouillage en mémoire).
Kubernetes utilise également des contrôleurs pour vérifier les affectations non valides (par exemple en raison d'une intervention de l'administrateur) et pour nettoyer les adresses IP allouées qui ne sont plus utilisées par aucun service.</p><h3 id=ips-and-vips>Service IP addresses</h3><p>Contrairement aux adresses IP des pods, qui acheminent réellement vers une destination fixe, les adresses IP des services ne sont pas réellement répondues par un seul hôte.
Au lieu de cela, kube-proxy utilise iptables (logique de traitement des paquets sous Linux) pour définir les adresses IP <em>virtual</em> qui sont redirigées de manière transparente selon les besoins.
Lorsque les clients se connectent au VIP, leur trafic est automatiquement transporté vers un Endpoint approprié.
Les variables d'environnement et DNS pour les services sont en fait remplis en termes d'adresse IP virtuelle (et de port) du service.</p><p>kube-proxy prend en charge trois modes proxy — espace utilisateur, iptables et IPVS — qui fonctionnent chacun légèrement différemment.</p><h4 id=userspace>Userspace</h4><p>À titre d'exemple, considérons l'application de traitement d'image décrite ci-dessus.
Lorsque le service backend est créé, le maître Kubernetes attribue une adresse IP virtuelle, par exemple 10.0.0.1.
En supposant que le port de service est 1234, le service est observé par toutes les instances kube-proxy dans le cluster.
Lorsqu'un proxy voit un nouveau service, il ouvre un nouveau port aléatoire, établit une redirection iptables de l'adresse IP virtuelle vers ce nouveau port et commence à accepter les connexions sur celui-ci.</p><p>Lorsqu'un client se connecte à l'adresse IP virtuelle du service, la règle iptables entre en jeu et redirige les paquets vers le propre port du proxy.
Le “Service proxy” choisit un backend, et commence le proxy du trafic du client vers le backend.</p><p>Cela signifie que les propriétaires de services peuvent choisir le port de leur choix sans risque de collision.
Les clients peuvent simplement se connecter à une adresse IP et à un port, sans savoir à quels pods ils accèdent réellement.</p><h4 id=iptables>iptables</h4><p>Considérons à nouveau l'application de traitement d'image décrite ci-dessus.
Lorsque le service backend est créé, le plan de contrôle Kubernetes attribue une adresse IP virtuelle, par exemple 10.0.0.1.
En supposant que le port de service est 1234, le service est observé par toutes les instances de kube-proxy dans le cluster.
Lorsqu'un proxy voit un nouveau service, il installe une série de règles iptables qui redirigent de l'adresse IP virtuelle vers des règles par service.
Les règles par service sont liées aux règles des Endpoints qui redirigent le trafic (à l'aide du NAT de destination) vers les backends.</p><p>Lorsqu'un client se connecte à l'adresse IP virtuelle du service, la règle iptables entre en jeu.
Un backend est choisi (soit en fonction de l'affinité de la session, soit au hasard) et les paquets sont redirigés vers le backend.
Contrairement au proxy de l'espace utilisateur, les paquets ne sont jamais copiés dans l'espace utilisateur, le proxy de kube n'a pas besoin d'être exécuté pour que l'adresse IP virtuelle fonctionne et les nœuds voient le trafic provenant de l'adresse IP du client non modifiée.</p><p>Ce même flux de base s'exécute lorsque le trafic arrive via un port de nœud ou via un load balancer, bien que dans ces cas, l'adresse IP du client soit modifiée.</p><h4 id=ipvs>IPVS</h4><p>Les opérations iptables ralentissent considérablement dans un cluster à grande échelle, par exemple 10000 services.
IPVS est conçu pour l'équilibrage de charge et basé sur des tables de hachage dans le noyau.
Ainsi, vous pouvez obtenir une cohérence des performances dans un grand nombre de services à partir d'un kube-proxy basé sur IPVS.
De plus, kube-proxy basé sur IPVS a des algorithmes d'équilibrage de charge plus sophistiqués (le moins de connexions, localité, pondéré, persistance).</p><h2 id=objet-api>Objet API</h2><p>Le service est une ressource de niveau supérieur dans l'API REST Kubernetes.
Vous pouvez trouver plus de détails sur l'objet API sur: <a href=/docs/reference/generated/kubernetes-api/v1.25/#service-v1-core>Service API object</a>.</p><h2 id=protocol-support>Protocoles pris en charge</h2><h3 id=tcp>TCP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>Vous pouvez utiliser TCP pour tout type de service, et c'est le protocole réseau par défaut.</p><h3 id=udp>UDP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>Vous pouvez utiliser UDP pour la plupart des services.
Pour Services de type LoadBalancer, la prise en charge UDP dépend du fournisseur de cloud offrant cette fonctionnalité.</p><h3 id=http>HTTP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.1 [stable]</code></div><p>Si votre fournisseur de cloud le prend en charge, vous pouvez utiliser un service dans le mode LoadBalancer pour configurer le proxy inverse HTTP / HTTPS externe, transmis au Endpoints du Service.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous pouvez aussi utiliser <a class=glossary-tooltip title="Un objet API qui gère l'accès externe aux services d'un cluster, typiquement HTTP." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/ingress/ target=_blank aria-label=Ingress>Ingress</a> à la place du service pour exposer les services HTTP/HTTPS.</div><h3 id=protocole-proxy>Protocole PROXY</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.1 [stable]</code></div><p>Si votre fournisseur de cloud le prend en charge(eg, <a href=/docs/concepts/cluster-administration/cloud-providers/#aws>AWS</a>), vous pouvez utiliser un service en mode LoadBalancer pour configurer un load balancer en dehors de Kubernetes lui-même, qui transmettra les connexions préfixées par <a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>PROXY protocol</a>.</p><p>Le load balancer enverra une première série d'octets décrivant la connexion entrante, similaire à cet exemple</p><pre tabindex=0><code>PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n
</code></pre><p>suivi des données du client.</p><h3 id=sctp>SCTP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>Kubernetes prend en charge SCTP en tant que valeur de «protocole» dans les définitions de Service, Endpoint, NetworkPolicy et Pod en tant que fonctionnalité alpha.
Pour activer cette fonction, l'administrateur du cluster doit activer le flag <code>SCTPSupport</code> sur l'apiserver, par exemple, <code>--feature-gates=SCTPSupport=true,…</code>.</p><p>When the feature gate is enabled, you can set the <code>protocol</code> field of a Service, Endpoint, NetworkPolicy or Pod to <code>SCTP</code>.
Kubernetes sets up the network accordingly for the SCTP associations, just like it does for TCP connections.</p><h4 id=caveat-sctp-overview>Avertissements</h4><h5 id=caveat-sctp-multihomed>Prise en charge des associations SCTP multi-hôtes</h5><div class="alert alert-danger warning callout" role=alert><strong>Attention:</strong><p>La prise en charge des associations SCTP multi-hôtes nécessite que le plug-in CNI puisse prendre en charge l'attribution de plusieurs interfaces et adresses IP à un pod.</p><p>Le NAT pour les associations SCTP multi-hôtes nécessite une logique spéciale dans les modules de noyau correspondants.</p></div><h5 id=caveat-sctp-loadbalancer-service-type>Service avec type=LoadBalancer</h5><div class="alert alert-danger warning callout" role=alert><strong>Attention:</strong> Vous ne pouvez créer un service de type LoadBalancer avec SCTP que si le fournisseur de load balancer supporte SCTP comme protocole.
Sinon, la demande de création de service est rejetée.
L'ensemble actuel de fournisseurs de load balancer cloud (Azure, AWS, CloudStack, GCE, OpenStack) ne prennent pas en charge SCTP.</div><h5 id=caveat-sctp-windows-os>Windows</h5><div class="alert alert-danger warning callout" role=alert><strong>Attention:</strong> SCTP n'est pas pris en charge sur les nœuds Windows.</div><h5 id=caveat-sctp-kube-proxy-userspace>Userspace kube-proxy</h5><div class="alert alert-danger warning callout" role=alert><strong>Attention:</strong> Le kube-proxy ne prend pas en charge la gestion des associations SCTP lorsqu'il est en mode userspace.</div><h2 id=futurs-développements>Futurs développements</h2><p>À l'avenir, la stratégie de proxy pour les services peut devenir plus nuancée que le simple équilibrage alterné, par exemple master-elected ou sharded.
Nous prévoyons également que certains services auront des load balancer «réels», auquel cas l'adresse IP virtuelle y transportera simplement les paquets.</p><p>Le projet Kubernetes vise à améliorer la prise en charge des services L7 (HTTP).</p><p>Le projet Kubernetes prévoit d'avoir des modes d'entrée plus flexibles pour les services, qui englobent les modes ClusterIP, NodePort et LoadBalancer actuels et plus encore.</p><h2 id=a-suivre>A suivre</h2><ul><li>Voir <a href=/docs/concepts/services-networking/connect-applications-service/>Connecting Applications with Services</a></li><li>Voir <a href=/docs/concepts/services-networking/ingress/>Ingress</a></li><li>Voir <a href=/docs/concepts/services-networking/endpoint-slices/>Endpoint Slices</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-91cb8a4438b003df11bc1c426a81b756>5.3 - DNS pour les services et les pods</h1><div class=lead>DNS services pods Kubernetes</div><p>Cette page fournit une vue d'ensemble du support DNS par Kubernetes.</p><h2 id=introduction>Introduction</h2><p>Kubernetes planifie un pod et un service DNS sur le cluster et configure
les kubelets pour indiquer à chaque conteneur d'utiliser l'adresse IP du service DNS pour résoudre les noms DNS.</p><h3 id=quels-composants-obtiennent-des-noms-dns>Quels composants obtiennent des noms DNS?</h3><p>Chaque service défini dans le cluster (y compris le serveur DNS lui-même) a un nom DNS. Par défaut, la liste de recherche DNS du client d'un pod inclura le namespace (espace de nommage) du pod et le domaine par défaut du cluster. C'est mieux
illustré par un exemple :</p><p>Supposons un service nommé <code>foo</code> dans le namespace Kubernetes <code>bar</code>. Un pod en cours d'exécution dans le namespace <code>bar</code> peut rechercher ce service en faisant simplement une requête DNS "foo". Un pod qui tourne dans le namespace <code>quux</code> peut rechercher ce service en effectuant une requête DNS <code>foo.bar</code>.</p><p>Les sections suivantes détaillent les types d’enregistrement et la structure supportée par Kubernetes. Toute autre structure ou noms ou requêtes qui fonctionnent sont
considérés comme des détails d'implémentation et peuvent changer sans préavis.
Pour une spécification plus à jour, voir
<a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>Découverte des services basée sur le DNS Kubernetes</a>.</p><h2 id=services>Services</h2><h3 id=enregistrement-a>Enregistrement A</h3><p>Les services "normaux" (pas sans en-tête) se voient attribuer un enregistrement DNS A, et ont un nom sous la forme : <code>mon-service.mon-namespace.svc.cluster.local</code>. La résolution de ce nom donne l'adresse <code>ClusterIP</code> du service.</p><p>Les Services "Headless" (ou sans en-tête, c'est à dire sans ClusterIP) auront également un enregistrement type A, donc un nom sous la forme : <code>mon-service.mon-namespace.svc.cluster.local</code>. Contrairement aux Services Normaux, cela résout l'ensemble des adresses IP des pods sélectionnés par le Service.
On s'attend à ce que les clients consomment l'ensemble ou utilisent le standard de sélection round-robin de l'ensemble.</p><h3 id=enregistrement-srv>Enregistrement SRV</h3><p>Les enregistrements SRV sont créés pour les ports nommés faisant partie des services normaux ou <a href=/docs/concepts/services-networking/service/#headless-services>Headless (sans en-tête)</a>.
Pour chaque port nommé, l'enregistrement SRV aurait la forme
<code>_mon-nom-de-port._mon-protocole-de-port.mon-service.mon-namespace.svc.cluster.local</code>.
Pour un service régulier, cela se traduit par le numéro de port et le nom de domaine :
<code>mon-service.mon-namespace.svc.cluster.local</code>.
Pour un service sans en-tête, cela pourrait être résolu en plusieurs réponses, une réponse pour chaque pod lié à ce service et qui contient le numéro de port, ainsi le nom de domaine du pod est sous la forme <code>nom-auto-genere.mon-service.mon-namespace.svc.cluster.local</code>.</p><h2 id=pods>Pods</h2><h3 id=enregistrement-a-1>Enregistrement A</h3><p>Lorsque cette option est activée, un enregistrement DNS A est attribué aux pods sous la forme <code>adresse-ip-du-pod.mon-namespace.pod.cluster.local</code>.</p><p>Par exemple, un pod avec l’IP <code>1.2.3.4</code> dans le namespace (espace de nommage) <code>default</code> avec un nom DNS de <code>cluster.local</code> aurait une entrée : <code>1-2-3-4.default.pod.cluster.local</code>.</p><h3 id=nom-d-hôte-et-sous-domaine-d-un-pod>Nom d'hôte et sous-domaine d'un pod</h3><p>Actuellement, lorsqu'un pod est créé, son nom d'hôte a la valeur <code>metadata.name</code> du pod.</p><p>La spécification du pod a un champ optionnel <code>hostname</code>, qui peut être utilisé pour spécifier la valeur du nom d'hôte du pod. Quand c'est spécifié, ce dernier a la priorité sur le nom du pod. Par exemple, si un pod a un <code>hostname</code> ayant la valeur "<code>mon-hote</code>", son nom d'hôte sera "<code>mon-hote</code>".</p><p>La spécification du pod a également un champ optionnel <code>subdomain</code> qui peut être utilisé pour spécifier son sous-domaine. Par exemple, un pod avec une valeur "<code>foo</code>" du champ <code>hostname</code> et une valeur "<code>bar</code>" du champ <code>subdomain</code>, dans le namespace "<code>mon-namespace</code>", aura un nom de domaine (FQDN) "<code>foo.bar.mon-namespace.svc.cluster.local</code>".</p><p>Exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sous-domaine-par-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb> </span><span style=color:#080;font-style:italic># En vrai, cette définition de port est à titre d&#39;exemple, nous n&#39;avons pas vraiment besoin de ports pour cette application.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>sous-domaine-par-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>sous-domaine-par-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span></code></pre></div><p>Si un service sans en-tête (headless) est dans le même namespace que son pod et avec le même nom que le sous-domaine, le serveur KubeDNS du cluster renvoie également un enregistrement A pour le nom d’hôte (hostname) du pod.
Par exemple, si un pod dont le nom d’hôte est "<code> busybox-1</code>" et le sous-domaine est "<code>sous-domaine-par-default</code>", et un service sans en-tête nommé "<code>sous-domaine-par-default</code>" dans le même namespace, le pod verra son propre nom de domaine complet "<code>busybox-1.sous-domaine-par-default.mon-namespace.svc.cluster.local</code>". Le DNS sert un enregistrement A portant ce nom, et pointant vers l'adresse IP du pod. Les deux Pods "<code>busybox1</code>" et "<code> busybox2</code>" peuvent avoir leurs enregistrements A distincts.</p><p>L’objet Endpoints peut spécifier le <code>hostname</code> pour n’importe quelle adresse d'endpoint (noeud final), avec son adresse IP.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Etant donné que les enregistrements A ne sont pas créés pour les noms de pods, le <code>hostname</code> est requis pour la création de l'enregistrement A du pod. Un pod sans <code>hostname</code> mais avec <code>subdomain</code> (sous domaine) ne créera que l'enregistrement A pour le service sans en-tête (<code>sous-domaine-par-default.mon-namespace.svc.cluster.local</code>), pointant vers l'adresse IP du pod.</div><h3 id=politique-dns-du-pod>Politique DNS du Pod</h3><p>Les stratégies DNS peuvent être définies par pod. Actuellement, Kubernetes supporte des stratégies DNS qui sont spécifiques au pod. Ces politiques sont spécifiées dans le
Champ <code>dnsPolicy</code> de la spécification du pod.</p><ul><li>"<code>Default</code>" : le pod hérite de la configuration de résolution des noms du node (noeud) sur lequel ce même pod est en train de tourner.
Voir <a href=/docs/tasks/administer-cluster/dns-custom-nameservers/#inheriting-dns-from-the-node>discussion liée</a> pour plus de détails.</li><li>"<code>ClusterFirst</code>" : toute requête DNS ne correspondant pas au suffixe du domaine configuré dans le cluster, tel que "<code>www.kubernetes.io</code>", sera transmise au serveur en amont hérité du node (noeud). Les administrateurs du cluster peuvent configurer des serveurs DNS supplémentaires que ce soit des serveurs secondaires (locaux) ou des vrais serveurs récursifs en amont pour faire la résolution.
  Voir <a href=/docs/tasks/administer-cluster/dns-custom-nameservers/#impacts-on-pods>discussion liée</a> pour plus de détails sur la manière dont les requêtes DNS sont traitées dans ces cas.</li><li>"<code>ClusterFirstWithHostNet</code>" : pour les pods exécutés avec <code>hostNetwork</code>, vous devez explicitement définir sa politique DNS "<code>ClusterFirstWithHostNet</code>".</li><li>"<code>None</code>" : une nouvelle valeur optionnelle introduite dans Kubernetes v1.9 (Beta dans v1.10). Elle permet à un pod d’ignorer les configurations DNS de l’environnement Kubernetes. Ainsi, toutes les configurations DNS sont supposées être fournies dans le champ <code>dnsConfig</code> de la spécification du pod.
  Voir la sous-section <a href=#dns-config>Config DNS</a> ci-dessous.</li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> "Default" n'est pas la stratégie DNS par défaut. Si <code>dnsPolicy</code> n'est pas explicitement spécifié, <code>ClusterFirst</code> sera utilisé.</div><p>L’exemple ci-dessous montre un pod avec une stratégie DNS "<code>ClusterFirstWithHostNet</code>" car il a le champ <code>hostNetwork</code> défini à <code>true</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirstWithHostNet<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=configuration-dns-du-pod>Configuration DNS du pod</h3><p>Kubernetes v1.9 introduit une fonctionnalité Alpha (version beta de v1.10) qui permet aux utilisateurs d'avoir plus de contrôle sur les paramètres DNS d'un pod. Cette fonctionnalité est activée par défaut dans la version 1.10.
Pour activer cette fonctionnalité dans la version 1.9, l'administrateur du cluster doit activer la feature gate (porte de fonctionnalité) <code>CustomPodDNS</code> sur les serveurs apiserver et kubelet, par exemple, "<code>--feature-gates=CustomPodDNS=true,...</code>".
Lorsque la fonction est activée, les utilisateurs peuvent mettre le champ <code>dnsPolicy</code> d’un pod à "<code>None</code>" et ils peuvent rajouter un nouveau champ <code>dnsConfig</code> à la spécification du pod.</p><p>Le champ <code>dnsConfig</code> est facultatif et peut fonctionner avec toute configuration <code>dnsPolicy</code>.
Cependant, quand <code>dnsPolicy</code> du pod est réglé sur "<code>None</code>", le champ <code>dnsConfig</code> doit être explicitement spécifié.</p><p>Vous trouverez ci-dessous les propriétés qu'un utilisateur peut spécifier dans le champ <code>dnsConfig</code>:</p><ul><li><code>nameservers</code> : liste d'adresses IP qui seront utilisées comme serveurs DNS pour le Pod. Il peut y avoir au plus 3 adresses IP spécifiées. Quand le champ <code>dnsPolicy</code> du Pod est mis à "<code>None</code>", la liste doit contenir au moins une adresse IP, sinon cette propriété est facultative.
  Les serveurs listés seront combinés avec les nameservers (serveurs de noms) de base générés à partir de la stratégie DNS spécifiée, tout en supprimant les adresses en double.</li><li><code>searches</code> : liste des domaines de recherche DNS pour la recherche du nom d'hôte dans le pod.
  Cette propriété est facultative. Si elle est spécifiée, la liste fournie sera fusionnée avec les noms de domaine de recherche de base générés à partir de la stratégie DNS choisie.
  Les noms de domaine en double sont supprimés.
  Kubernetes permet au plus 6 domaines de recherche.</li><li><code>options</code>: une liste optionnelle d'objets où chaque objet peut avoir une propriété <code>name</code> (obligatoire) et une propriété <code>value</code> (facultatif). Le contenu de cette propriété sera fusionné avec les options générées à partir de la stratégie DNS spécifiée.
  Les entrées en double sont supprimées.</li></ul><p>Voici un exemple de Pod avec des configurations DNS personnalisées :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exemple-dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;None&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nameservers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#666>1.2.3.4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>searches</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- ns1.svc.cluster.local<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- mon.dns.search.suffix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>options</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ndots<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>edns0<span style=color:#bbb>
</span></span></span></code></pre></div><p>Lorsque le Pod ci-dessus est créé, le conteneur <code>test</code> obtient le contenu suivant dans son fichier <code>/etc/resolv.conf</code> :</p><pre tabindex=0><code>nameserver 1.2.3.4
search ns1.svc.cluster.local mon.dns.search.suffix
options ndots:2 edns0
</code></pre><p>Pour la configuration IPv6, le chemin de recherche et le serveur de noms doivent être configurés comme suit :</p><pre tabindex=0><code>$ kubectl exec -it exemple-dns -- cat /etc/resolv.conf
nameserver fd00:79:30::a
search default.svc.cluster.local svc.cluster.local cluster.local
options ndots:5
</code></pre><h2 id=a-suivre>A suivre</h2><p>Pour obtenir des recommendations sur l’administration des configurations DNS, consultez
<a href=/docs/tasks/administer-cluster/dns-custom-nameservers/>Configurer le service DNS</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-199bcc92443dbc9bed44819467d7eb75>5.4 - Ingress</h1><p>Un Ingress est un objet Kubernetes qui gère l'accès externe aux services dans un cluster, généralement du trafic HTTP.</p><p>Un Ingress peut fournir un équilibrage de charge, une terminaison TLS et un hébergement virtuel basé sur un nom.</p><h2 id=terminologie>Terminologie</h2><p>Par souci de clarté, ce guide définit les termes suivants :</p><ul><li>Nœud (Node) : une seule machine virtuelle ou physique dans un cluster Kubernetes.</li><li>Cluster : groupe de nœuds protégés par un pare-feu du trafic provenant d'Internet et constituant les principales ressources de calcul gérées par Kubernetes.</li><li>Routeur Edge : routeur appliquant la stratégie de pare-feu pour votre cluster. Il peut s’agir d’une passerelle gérée par un fournisseur de cloud ou d’un matériel physique.</li><li>Réseau de cluster : ensemble de liens, logiques ou physiques, facilitant la communication au sein d'un cluster selon le <a href=/docs/concepts/cluster-administration/networking/>modèle de réseau Kubernetes</a>.</li><li>Service : un Kubernetes <a href=/docs/concepts/services-networking/service/>Service</a> identifiant un ensemble de pods à l'aide de sélecteurs d'étiquettes. Sauf indication contraire, les services sont supposés avoir des adresses IP virtuelles routables uniquement dans le réseau du cluster.</li></ul><h2 id=qu-est-ce-qu-un-ingress>Qu'est-ce qu'un Ingress ?</h2><p>Ingress (ou une entrée réseau), ajouté à Kubernetes v1.1, expose les routes HTTP et HTTPS de l'extérieur du cluster à des
<a href=/docs/concepts/services-networking/service/ target=_blank>services</a> au sein du cluster.
Le routage du trafic est contrôlé par des règles définies sur la ressource Ingress.</p><pre tabindex=0><code class=language-none data-lang=none>    internet
        |
   [ Ingress ]
   --|-----|--
   [ Services ]
</code></pre><p>Un Ingress peut être configuré pour donner aux services des URLs accessibles de l'extérieur, un équilibrage du trafic de charge externe, la terminaison SSL/TLS et un hébergement virtuel basé sur le nom. Un <a href=/docs/concepts/services-networking/ingress-controllers>contrôleur d'Ingress</a> est responsable de l'exécution de l'Ingress, généralement avec un load-balancer (équilibreur de charge), bien qu'il puisse également configurer votre routeur périphérique ou des interfaces supplémentaires pour aider à gérer le trafic.</p><p>Un Ingress n'expose pas de ports ni de protocoles arbitraires. Exposer des services autres que HTTP et HTTPS à Internet généralement utilise un service de type <a href=/docs/concepts/services-networking/service/#nodeport>Service.Type=NodePort</a> ou <a href=/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a>.</p><h2 id=conditions-préalables>Conditions préalables</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.1 [beta]</code></div><p>Avant de commencer à utiliser un Ingress, vous devez comprendre certaines choses. Un Ingress est une ressource en "version Beta".</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Vous devez avoir un <a href=/docs/concepts/services-networking/ingress-controllers>contrôleur d'Ingress</a> pour lancer un Ingress. Seule, la création d'une ressource Ingress n'a aucun effet.</div><p>GCE/GKE (Google Cloud Engine / Google Kubernetes Engine) déploie un contrôleur d’Ingress sur le master (le maître de kubernetes). Revoir les <a href=https://github.com/kubernetes/ingress-gce/blob/master/BETA_LIMITATIONS.md#glbc-beta-limitations>limitations beta</a> de ce contrôleur si vous utilisez GCE/GKE.</p><p>Dans les environnements autres que GCE/GKE, vous devrez peut-être <a href=https://kubernetes.github.io/ingress-nginx/deploy/>déployer un contrôleur d'Ingress</a>. Il y a un certain nombre de <a href=/docs/concepts/services-networking/ingress-controllers>contrôleurs d'Ingress</a> parmi lesquels vous pouvez choisir.</p><h3 id=avant-de-commencer>Avant de commencer</h3><p>Dans l’idéal, tous les contrôleurs d’Ingress devraient correspondre à cette spécification. Cependant le fonctionnement est légèrement différent d'un contrôleur à un autre (en fonction de son implémentation).</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Assurez-vous de consulter la documentation de votre contrôleur d’Ingress pour bien comprendre les mises en garde à prendre en compte au moment de le choisir.</div><h2 id=la-ressource-ingress>La ressource Ingress</h2><p>Exemple de ressource Ingress minimale :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/testpath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Comme pour toutes les autres ressources Kubernetes, un Ingress (une entrée) a besoin des champs <code>apiVersion</code>, <code>kind</code> et <code>metadata</code>.
 Pour des informations générales sur l'utilisation des fichiers de configuration, voir <a href=/docs/tasks/run-application/run-stateless-application-deployment/>déployer des applications</a>, <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>configurer des conteneurs</a>, <a href=/docs/concepts/cluster-administration/manage-deployment/>gestion des ressources</a>.
 Ingress utilise fréquemment des annotations pour configurer certaines options en fonction du contrôleur Ingress, dont un exemple
 est l'annotation <a href=https://github.com/kubernetes/ingress-nginx/blob/master/docs/examples/rewrite/README.md>rewrite-target</a>.
 Différents <a href=/docs/concepts/services-networking/ingress-controllers>Ingress controller</a> prennent en charge différentes annotations. Consultez la documentation du contrôleur Ingress de votre choix pour savoir quelles annotations sont prises en charge.</p><p>La <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>spécification de la ressource Ingress</a> dispose de toutes les informations nécessaires pour configurer un loadbalancer ou un serveur proxy. Plus important encore, il
contient une liste de règles d'appariement de toutes les demandes entrantes. La ressource Ingress ne supporte que les règles pour diriger le trafic HTTP.</p><h3 id=ingress-rules>Ingress rules</h3><p>Chaque règle http contient les informations suivantes :</p><ul><li>Un hôte optionnel. Dans cet exemple, aucun hôte n'est spécifié. La règle s'applique donc à tous les appels entrants.
  Le trafic HTTP via l'adresse IP est spécifié. Si un hôte est fourni (par exemple,
  foo.bar.com), les règles s’appliquent à cet hôte.</li><li>une liste de chemins (par exemple, /testpath), chacun étant associé à un backend associé défini par un <code>serviceName</code> et <code>servicePort</code>. L’hôte et le chemin doivent correspondre au contenu d’une demande entrante avant que le load-balancer ne dirige le trafic vers le service référencé.</li><li>Un backend est une combinaison de noms de services et de ports, comme décrit dans
<a href=/docs/concepts/services-networking/service/>services doc</a>. Les requêtes HTTP (et HTTPS) envoyées à l'Ingress correspondant à l'hôte et au chemin de la règle seront envoyées au backend indiqué.</li></ul><p>Un backend par défaut est souvent configuré dans un contrôleur d’Ingress qui traite toutes les demandes qui ne correspondent à aucun chemin dans la spécification.</p><h3 id=backend-par-défaut>Backend par défaut</h3><p>Un Ingress sans règles envoie tout le trafic à un seul backend par défaut. Le backend par défaut est généralement une option de configuration du <a href=/docs/concepts/services-networking/ingress-controllers>Contrôleur d'ingress</a> et n'est pas spécifié dans vos ressources Ingress.</p><p>Si aucun des hôtes ou chemins ne correspond à la demande HTTP dans les objets Ingress, le trafic est routé vers votre backend par défaut.</p><h2 id=types-d-ingress>Types d'Ingress</h2><h3 id=ingress-pour-service-unique>Ingress pour service unique</h3><p>Il existe des concepts Kubernetes qui vous permettent d’exposer un seul service.
(voir <a href=#alternatives>alternatives</a>). Vous pouvez également le faire avec un Ingress en spécifiant un <em>backend par défaut</em> sans règles.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultBackend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>testsvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Si vous le créez en utilisant <code>kubectl create -f</code>, vous devriez voir :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress test-ingress
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME           HOSTS     ADDRESS           PORTS     AGE
</span></span><span style=display:flex><span>test-ingress   *         107.178.254.228   <span style=color:#666>80</span>        59s
</span></span></code></pre></div><p>Où <code>107.178.254.228</code> est l’adresse IP allouée par le contrôleur d’Ingress pour satisfaire cette entrée.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Les contrôleurs d'Ingress et les load-balancers peuvent prendre une minute ou deux pour allouer une adresse IP.
Jusque-là, vous verrez souvent l’adresse listée sous la forme <code>&lt;pending></code> (en attente).</div><h3 id=fanout-simple>Fanout simple</h3><p>Une configuration de type fanout achemine le trafic d'une adresse IP unique vers plusieurs services, en se basant sur l'URI HTTP demandée. Une entrée vous permet de garder le nombre de loadbalancers au minimum. Par exemple, une configuration comme :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>foo.bar.com -&gt; 178.91.123.132 -&gt; / foo    service1:4200
</span></span><span style=display:flex><span>                                 / bar    service2:8080
</span></span></code></pre></div><p>ceci nécessitera un Ingress défini comme suit :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>simple-fanout-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>4200</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Lorsque vous créez l'ingress avec <code>kubectl create -f</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress simple-fanout-example
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:             simple-fanout-example
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Address:          178.91.123.132
</span></span><span style=display:flex><span>Default backend:  default-http-backend:80 <span style=color:#666>(</span>10.8.2.3:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Rules:
</span></span><span style=display:flex><span>  Host         Path  Backends
</span></span><span style=display:flex><span>  ----         ----  --------
</span></span><span style=display:flex><span>  foo.bar.com
</span></span><span style=display:flex><span>               /foo   service1:4200 <span style=color:#666>(</span>10.8.0.90:4200<span style=color:#666>)</span>
</span></span><span style=display:flex><span>               /bar   service2:8080 <span style=color:#666>(</span>10.8.0.91:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Annotations:
</span></span><span style=display:flex><span>  nginx.ingress.kubernetes.io/rewrite-target:  /
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type     Reason  Age                From                     Message
</span></span><span style=display:flex><span>  ----     ------  ----               ----                     -------
</span></span><span style=display:flex><span>  Normal   ADD     22s                loadbalancer-controller  default/test
</span></span></code></pre></div><p>Le contrôleur d’Ingress fournit une implémentation spécifique aux load-balancers qui satisfait l'Ingress, tant que les services (<code>s1</code>, <code>s2</code>) existent.
Lorsque cela est fait, vous pouvez voir l’adresse du load-balancer sur le champ d'adresse.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> En fonction du <a href=/docs/concepts/services-networking/ingress-controllers>Contrôleur d'ingress</a> que vous utilisez, vous devrez peut-être
créer un backend http par défaut <a href=/docs/concepts/services-networking/service/>Service</a>.</div><h3 id=hébergement-virtuel-basé-sur-le-nom>Hébergement virtuel basé sur le nom</h3><p>Les hôtes virtuels basés sur des noms prennent en charge le routage du trafic HTTP vers plusieurs noms d'hôte basés sur la même adresse IP.</p><pre tabindex=0><code class=language-none data-lang=none>foo.bar.com --|                 |-&gt; foo.bar.com s1:80
              | 178.91.123.132  |
bar.foo.com --|                 |-&gt; bar.foo.com s2:80
</code></pre><p>L’Ingress suivant indique au load-balancer de router les requêtes en fonction de <a href=https://tools.ietf.org/html/rfc7230#section-5.4>En-tête du hôte</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Si vous créez une ressource Ingress sans aucun hôte défini dans les règles, tout trafic Web à destination de l'adresse IP de votre contrôleur d'Ingress peut être mis en correspondance sans qu'un hôte virtuel basé sur le nom ne soit requis. Par exemple, la ressource Ingress suivante acheminera le trafic demandé pour <code>first.bar.com</code> au <code>service1</code>, <code>second.foo.com</code> au <code>service2</code>, et à tout trafic à l'adresse IP sans nom d'hôte défini dans la demande (c'est-à-dire sans en-tête de requête présenté) au <code>service3</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>first.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>second.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=tls>TLS</h3><p>Vous pouvez sécuriser un Ingress en définissant un <a href=/docs/concepts/configuration/secret>secret</a> qui contient une clé privée et un certificat TLS. Actuellement, l'Ingress prend seulement en charge l'unique port TLS, 443, et suppose une terminaison TLS. Si la section de configuration TLS dans un Ingress spécifie différents hôtes, ils seront multiplexés sur le même port en fonction du nom d’hôte spécifié via l'extension SNI TLS (à condition que le contrôleur d’Ingress prenne en charge SNI). Le secret de TLS doit contenir les clés <code>tls.crt</code> et <code>tls.key</code> contenant le certificat et clé privée à utiliser pour TLS, par exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>base64 encoded cert<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>base64 encoded key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></span></span></code></pre></div><p>Référencer ce secret dans un Ingress indiquera au contrôleur d'Ingress de sécuriser le canal du client au load-balancer à l'aide de TLS. Vous devez vous assurer que le secret TLS que vous avez créé provenait d'un certificat contenant un Common Name (CN), aussi appelé nom de domaine pleinement qualifié (FQDN), pour <code>https-example.foo.com</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/service/networking/tls-example-ingress.yaml download=service/networking/tls-example-ingress.yaml><code>service/networking/tls-example-ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-tls-example-ingress-yaml")' title="Copy service/networking/tls-example-ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-tls-example-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>tls-example-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>hosts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- https-example.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>https-example.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Les fonctionnalités TLS prisent en charge par les différents contrôleurs peuvent être différentes. Veuillez vous référer à la documentation sur
<a href=https://git.k8s.io/ingress-nginx/README.md#https>nginx</a>,
<a href=https://git.k8s.io/ingress-gce/README.md#frontend-https>GCE</a>,
ou tout autre contrôleur d’Ingress spécifique à la plate-forme pour comprendre le fonctionnement de TLS dans votre environnement.</div><h3 id=l-équilibrage-de-charge>L'équilibrage de charge</h3><p>Un contrôleur d’Ingress est démarré avec certains paramètres de politique d’équilibrage de charge
qui s'appliquent à toutes les entrées, tels que l'algorithme d'équilibrage de la charge, le régime de pondérations des backends, et d'autres.
Les concepts un peu plus avancés d'équilibrage de charge (p. ex. sessions persistantes, pondérations dynamiques) ne sont pas encore exposés pour l'Ingress. Vous pouvez toujours obtenir ces fonctionnalités via le <a href=https://github.com/kubernetes/ingress-nginx>service loadbalancer</a>.</p><p>Il est également intéressant de noter que même si les health checks (contrôles de santé) ne sont pas exposés directement via l'Ingress, il existe des concepts parallèles dans Kubernetes, tels que <a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>readiness probes</a> qui vous permettent d'obtenir le même résultat final. Veuillez consulter les documents spécifiques au contrôleur pour voir comment il gère les health checks. (<a href=https://git.k8s.io/ingress-nginx/README.md>nginx</a>,<a href=https://git.k8s.io/ingress-gce/README.md#health-checks>GCE</a>).</p><h2 id=mise-à-jour-d-un-ingress>Mise à jour d'un Ingress</h2><p>Pour mettre à jour un Ingress existant afin d'ajouter un nouvel hôte, vous pouvez le mettre à jour en modifiant la ressource :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:             <span style=color:#a2f>test</span>
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Address:          178.91.123.132
</span></span><span style=display:flex><span>Default backend:  default-http-backend:80 <span style=color:#666>(</span>10.8.2.3:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Rules:
</span></span><span style=display:flex><span>  Host         Path  Backends
</span></span><span style=display:flex><span>  ----         ----  --------
</span></span><span style=display:flex><span>  foo.bar.com
</span></span><span style=display:flex><span>               /foo   s1:80 <span style=color:#666>(</span>10.8.0.90:80<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Annotations:
</span></span><span style=display:flex><span>  nginx.ingress.kubernetes.io/rewrite-target:  /
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type     Reason  Age                From                     Message
</span></span><span style=display:flex><span>  ----     ------  ----               ----                     -------
</span></span><span style=display:flex><span>  Normal   ADD     35s                loadbalancer-controller  default/test
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><p>Cela devrait faire apparaître un éditeur avec le yaml existant, modifiez-le pour inclure le nouvel hôte :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>s1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.baz.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>s2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>..<span style=color:#bbb>
</span></span></span></code></pre></div><p>L'enregistrement du yaml mettra à jour la ressource dans le serveur d'API, ce qui devrait indiquer au contrôleur d'Ingress de reconfigurer le load-balancer.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:             <span style=color:#a2f>test</span>
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Address:          178.91.123.132
</span></span><span style=display:flex><span>Default backend:  default-http-backend:80 <span style=color:#666>(</span>10.8.2.3:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Rules:
</span></span><span style=display:flex><span>  Host         Path  Backends
</span></span><span style=display:flex><span>  ----         ----  --------
</span></span><span style=display:flex><span>  foo.bar.com
</span></span><span style=display:flex><span>               /foo   s1:80 <span style=color:#666>(</span>10.8.0.90:80<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  bar.baz.com
</span></span><span style=display:flex><span>               /foo   s2:80 <span style=color:#666>(</span>10.8.0.91:80<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Annotations:
</span></span><span style=display:flex><span>  nginx.ingress.kubernetes.io/rewrite-target:  /
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type     Reason  Age                From                     Message
</span></span><span style=display:flex><span>  ----     ------  ----               ----                     -------
</span></span><span style=display:flex><span>  Normal   ADD     45s                loadbalancer-controller  default/test
</span></span></code></pre></div><p>Vous pouvez obtenir le même résultat en appelant <code>kubectl replace -f</code> sur un fichier Ingress yaml modifié.</p><h2 id=échec-dans-les-zones-de-disponibilité>Échec dans les zones de disponibilité</h2><p>Les techniques permettant de répartir le trafic sur plusieurs domaines de défaillance diffèrent d'un fournisseur de cloud à l'autre.
Veuillez consulter la documentation du <a href=/docs/concepts/services-networking/ingress-controllers>Contrôleur d'ingress</a> pour plus de détails. Vous pouvez également vous référer à la <a href=/docs/concepts/cluster-administration/federation/>documentation de la fédération</a> pour plus d'informations sur le déploiement d'Ingress dans un cluster fédéré.</p><h2 id=travail-futur>Travail futur</h2><p>Suivez <a href=https://github.com/kubernetes/community/tree/master/sig-network>SIG network</a> (groupe d'intérêt spécial Réseau) pour plus de détails sur l'évolution de l'Ingress et des ressources associées. Vous pouvez également suivre le <a href=https://github.com/kubernetes/ingress/tree/master>Dépôt Ingress</a> pour plus de détails sur l'évolution des différents contrôleurs d’Ingress.</p><h2 id=alternatives>Alternatives</h2><p>Vous pouvez exposer un service de plusieurs manières sans impliquer directement la ressource Ingress :</p><ul><li>Utilisez <a href=/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a></li><li>Utilisez <a href=/docs/concepts/services-networking/service/#nodeport>Service.Type=NodePort</a></li><li>Utilisez un <a href=https://git.k8s.io/contrib/for-demos/proxy-to-service>Proxy du port</a></li></ul><h2 id=a-suivre>A suivre</h2><ul><li><a href=/docs/tasks/access-application-cluster/ingress-minikube>Configurer Ingress sur Minikube avec le contrôleur NGINX</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f018f568c6723865753f150c3c59bdda>6 - Stockage</h1></div><div class=td-content><h1 id=pg-27795584640a03bd2024f1fe3b3ab754>6.1 - Volumes</h1><p>Les fichiers sur disque dans un conteneur sont éphémères, ce qui présente des problèmes pour
des applications non-triviales lorsqu'elles s'exécutent dans des conteneurs. Premièrement, lorsqu'un
conteneur plante, kubelet va le redémarrer mais les fichiers seront perdus - le conteneur démarre
avec un état propre. Deuxièmement, lorsque plusieurs conteneurs s'exécutent ensemble dans un <code>Pod</code>,
il est souvent nécessaire de partager des fichiers entre ces conteneurs. L'abstraction Kubernetes
<code>Volume</code> résout ces deux problèmes.</p><p>Une connaissance des <a href=/fr/docs/concepts/workloads/pods/pod>Pods</a> est suggérée.</p><h2 id=contexte>Contexte</h2><p>Docker a également un concept de <a href=https://docs.docker.com/storage/>volumes</a>, bien qu'il
soit, dans une certaine mesure, plus relâché et moins géré.
Avec Docker, un volume est simplement un dossier sur le disque ou dans un autre conteneur.
Les durées de vie ne sont pas gérées et, jusqu'à très récemment, seuls les volumes supportés par un disque local l'étaient.
Docker fournit maintenant des pilotes de volume, mais la fonctionnalité est très limitée pour le moment (par exemple, à partir de Docker 1.7, seulement un pilote de volume est autorisé par conteneur et il n'est pas possible de passer des paramètres aux volumes).</p><p>Un volume Kubernetes, en revanche, a une durée de vie explicite - la même que le Pod qui l'inclut.
Par conséquent, un volume survit aux conteneurs qui s'exécutent à l'intérieur du Pod et les données sont préservées lorsque le conteneur redémarre.
Bien sûr, lorsqu'un Pod cesse d'exister, le volume va également cesser d'exister.
Peut-être plus important encore, Kubernetes supporte de nombreux types de volumes et un Pod peut en utiliser plusieurs simultanément.</p><p>À la base, un volume est juste un dossier, contenant possiblement des données, qui est accessible aux conteneurs dans un Pod. La manière dont ce dossier est créé, le support qui le sauvegarde et son contenu sont déterminés par le type de volume utilisé.</p><p>Pour utiliser un volume, un Pod spécifie les volumes à fournir au Pod (le champ <code>.spec.volumes</code>)
et où les monter dans les conteneurs (le champ <code>.spec.containers.volumeMounts</code>).</p><p>Un processus dans un conteneur a une vue système de fichiers composée de son image et de ses volumes Docker.
L'<a href=https://docs.docker.com/userguide/dockerimages/>image Docker</a> est à la racine de la hiérarchie du système de fichiers et tous les volumes sont montés sur les chemins spécifiés dans l'image.
Les volumes ne peuvent pas être montés sur d'autres volumes ou avoir des liens physiques vers d'autres volumes.
Chaque conteneur dans le Pod doit spécifier indépendamment où monter chaque volume.</p><h2 id=types-de-volumes>Types de Volumes</h2><p>Kubernetes supporte plusieurs types de Volumes:</p><ul><li><a href=#awselasticblockstore>awsElasticBlockStore</a></li><li><a href=#azuredisk>azureDisk</a></li><li><a href=#azurefile>azureFile</a></li><li><a href=#cephfs>cephfs</a></li><li><a href=#cinder>cinder</a></li><li><a href=#configmap>configMap</a></li><li><a href=#csi>csi</a></li><li><a href=#downwardapi>downwardAPI</a></li><li><a href=#emptydir>emptyDir</a></li><li><a href=#fc>fc (fibre channel)</a></li><li><a href=#flexVolume>flexVolume</a></li><li><a href=#flocker>flocker</a></li><li><a href=#gcepersistentdisk>gcePersistentDisk</a></li><li><a href=#gitrepo>gitRepo (deprecated)</a></li><li><a href=#glusterfs>glusterfs</a></li><li><a href=#hostpath>hostPath</a></li><li><a href=#iscsi>iscsi</a></li><li><a href=#local>local</a></li><li><a href=#nfs>nfs</a></li><li><a href=#persistentvolumeclaim>persistentVolumeClaim</a></li><li><a href=#projected>projected</a></li><li><a href=#portworxvolume>portworxVolume</a></li><li><a href=#quobyte>quobyte</a></li><li><a href=#rbd>rbd</a></li><li><a href=#scaleio>scaleIO</a></li><li><a href=#secret>secret</a></li><li><a href=#storageos>storageos</a></li><li><a href=#vspherevolume>vsphereVolume</a></li></ul><p>Toute contribution supplémentaire est la bienvenue.</p><h3 id=awselasticblockstore>awsElasticBlockStore</h3><p>Un type de volume <code>awsElasticBlockStore</code> monte un <a href=http://aws.amazon.com/ebs/>Volume EBS</a> d'Amazon Web Services (AWS) dans un Pod.
À la différence de <code>emptyDir</code>, qui est écrasé lorsqu'un Pod est supprimé, le contenu d'un volume EBS
est préservé et le volume est seulement démonté. Cela signifie qu'un volume EBS peut être prérempli avec des données et que les données peuvent être transmises entre les Pods.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez créer un volume EBS avec la commande <code>aws ec2 create-volume</code> ou l'API AWS avant de pouvoir l'utiliser.</div><p>Des restrictions existent lorsque l'on utilise un volume <code>awsElasticBlockStore</code> :</p><ul><li>les nœuds dans lesquels les Pods s'exécutent doivent être des instances AWS EC2</li><li>ces instances doivent être dans la même région et la même zone de disponibilité que le volume EBS</li><li>EBS supporte uniquement le montage d'un volume par une seule instance EC2</li></ul><h4 id=création-d-un-volume-ebs>Création d'un volume EBS</h4><p>Avant que vous puissiez utiliser un volume EBS dans un Pod, vous devez le créer.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>aws ec2 create-volume --availability-zone<span style=color:#666>=</span>eu-west-1a --size<span style=color:#666>=</span><span style=color:#666>10</span> --volume-type<span style=color:#666>=</span>gp2
</span></span></code></pre></div><p>Assurez-vous que la zone correspond à la zone de votre grappe de serveurs (cluster).
(Et vérifiez aussi que la taille et le type du volume EBS conviennent à votre utilisation!)</p><h4 id=exemple-de-configuration-aws-ebs>Exemple de configuration AWS EBS</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Ce volume AWS EBS doit déjà exister.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>awsElasticBlockStore</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span>&lt;volume-id&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=migration-csi>Migration CSI</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [alpha]</code></div><p>La fonctionnalité de migration CSI pour awsElasticBlockStore, lorsque activée, fixe toutes les opérations de plugin depuis le plugin "in-tree" vers le pilote de l'interface CSI (Container Storage Interface) <code>ebs.csi.aws.com</code>.
Afin d'utiliser cette fonctionnalité, le <a href=https://github.com/kubernetes-sigs/aws-ebs-csi-driver>Pilote AWS EBS CSI</a> doit être installé dans le cluster et les fonctionnalités Alpha <code>CSIMigration</code> et <code>CSIMigrationAWS</code> doivent être activées.</p><h3 id=azuredisk>azureDisk</h3><p>Un type de volume <code>azureDisk</code> est utilisé pour monter un disque de données (<a href=https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-linux-about-disks-vhds/>Data Disk</a>) dans un Pod.</p><p>Plus de détails sont disponibles <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_disk/README.md>ici</a>.</p><h4 id=migration-csi-1>Migration CSI</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [alpha]</code></div><p>La fonctionnalité de migration CSI pour azureDisk, lorsque activée, fixe toutes les opérations de plugin depuis le plugin "in-tree" vers le pilote de l'interface CSI (Container Storage Interface) <code>disk.csi.azure.com</code>.
Afin d'utiliser cette fonctionnalité, le <a href=https://github.com/kubernetes-sigs/azuredisk-csi-driver>Pilote Azure Disk CSI</a> doit être installé dans le cluster et les fonctionnalités Alpha <code>CSIMigration</code> et <code>CSIMigrationAzureDisk</code> doivent être activées.</p><h3 id=azurefile>azureFile</h3><p>Un type de volume <code>azureFile</code> est utilisé pour monter un volume de fichier Microsoft Azure (SMB 2.1 et 3.0) dans un Pod.</p><p>Plus de détails sont disponibles <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_file/README.md>ici</a>.</p><h4 id=migration-csi-2>Migration CSI</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [alpha]</code></div><p>La fonctionnalité de migration CSI pour azureFile, lorsque activée, fixe toutes les opérations de plugin depuis le plugin "in-tree" vers le pilote de l'interface CSI (Container Storage Interface) <code>file.csi.azure.com</code>.
Afin d'utiliser cette fonctionnalité, le <a href=https://github.com/kubernetes-sigs/azurefile-csi-driver>Pilote Azure File CSI</a> doit être installé dans le cluster et les fonctionnalités Alpha <code>CSIMigration</code> et <code>CSIMigrationAzureFile</code> doivent être activées.</p><h3 id=cephfs>cephfs</h3><p>Un volume <code>cephfs</code> permet de monter un volume CephFS existant dans un Pod.
Contrairement à <code>emptyDir</code>, qui est écrasé quand un Pod est supprimé, le contenu d'un volume <code>cephfs</code> est préservé et le volume est simplement démonté.
Cela signifie qu'un volume CephFS peut être prérempli avec des données et ces données peuvent être transmises entre les Pods.
CephFS peut être monté plusieurs fois en écriture simultanément.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez exécuter votre propre serveur Ceph avec le partage exporté avant de pouvoir l'utiliser.</div><p>Voir <a href=https://github.com/kubernetes/examples/tree/master/volumes/cephfs/>l'exemple CephFS</a> pour plus de détails.</p><h3 id=cinder>cinder</h3><div class="alert alert-info note callout" role=alert><strong>Note:</strong> prérequis : Kubernetes avec le fournisseur infonuagique OpenStack (OpenStack Cloud Provider) configuré.
Pour la configuration cloudprovider, se référer à <a href=https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/#openstack>cloud provider openstack</a>.</div><p><code>cinder</code> est utilisé pour monter un volume Cinder OpenStack dans un Pod.</p><h4 id=exemple-de-configuration-d-un-volume-cinder>Exemple de configuration d'un volume Cinder</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Ce volume OpenStack doit déjà exister.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cinder</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span>&lt;volume-id&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=migration-csi-3>Migration CSI</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [alpha]</code></div><p>La fonctionnalité de migration CSI pour Cinder, lorsque activée, fixe toutes les opérations de plugin depuis le plugin "in-tree" vers le pilote de l'interface CSI (Container Storage Interface) <code>cinder.csi.openstack.org</code>.
Afin d'utiliser cette fonctionnalité, le <a href=https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/using-cinder-csi-plugin.md>Pilote Cinder CSI</a> doit être installé dans le cluster et les fonctionnalités Alpha <code>CSIMigration</code> et <code>CSIMigrationOpenStack</code> doivent être activées.</p><h3 id=configmap>configMap</h3><p>La ressource <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/><code>configMap</code></a> fournit un moyen d'injecter des données de configuration dans les Pods.
Les données stockées dans un objet <code>ConfigMap</code> peuvent être référencées dans un volume de type <code>configMap</code>
et être ensuite consommées par des applications conteneurisées s'exécutant dans un Pod.</p><p>Lorsque l'on référence un objet <code>configMap</code>, on peut simplement fournir son nom dans le volume
pour le référencer. On peut également personnaliser le chemin pour utiliser une entrée spécifique dans
la ConfigMap. Par exemple, pour monter la ConfigMap <code>log-config</code> sur un Pod appelé <code>configmap-pod</code>,
vous pourriez utiliser le YAML suivant :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span></code></pre></div><p>La ConfigMap <code>log-config</code> est montée comme un volume et tout le contenu stocké dans son entrée <code>log_level</code>
est monté dans le Pod au chemin "<code>/etc/config/log_level</code>".
À noter que ce chemin est dérivé du <code>mountPath</code> du volume et le <code>path</code> est étiqueté avec la clef <code>log_level</code>.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez créer une <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a> avant de pouvoir l'utiliser.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Un conteneur utilisant une ConfigMap en tant que montage de volume <a href=#using-subpath>subPath</a> ne recevra pas les mises à jour de la ConfigMap.</div><h3 id=downwardapi>downwardAPI</h3><p>Un volume <code>downwardAPI</code> est utilisé pour rendre disponibles aux applications les données de l'API Downward.
Il monte un dossier et écrit les données demandées dans des fichiers de texte brut.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Un conteneur utilisant l'API Downward en tant que montage de volume <a href=#using-subpath>subPath</a> ne recevra pas les mises à jour de l'API Downward.</div><p>Voir <a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>l'exemple de volume <code>downwardAPI</code></a> pour plus de détails.</p><h3 id=emptydir>emptyDir</h3><p>Un volume <code>emptyDir</code> est d'abord créé lorsqu'un Pod est assigné à un nœud et existe aussi longtemps que le Pod s'exécute sur ce nœud.
Comme le nom l'indique, le volume est initialement vide. Les conteneurs dans le Pod peuvent tous lire et écrire les mêmes fichiers dans le volume <code>emptyDir</code>, bien que ce volume puisse être monté sur le même ou différents chemins dans chaque conteneur.
Lorsqu'un Pod est supprimé d'un nœud pour une raison quelconque, les données dans le <code>emptyDir</code> sont supprimées à jamais.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Un conteneur qui plante ne retire <em>PAS</em> un Pod d'un nœud, ainsi, les données présentes dans un <code>emptyDir</code> sont protégées en cas de plantage du conteneur.</div><p>Des cas d'utilisation pour un <code>emptyDir</code> peuvent être :</p><ul><li>un espace de travail, par exemple pour un tri fusion sur disque.</li><li>l'établissement d'un point de reprise d'un long calcul à des fins de récupération des données après un crash.</li><li>le stockage de fichiers qu'un conteneur de gestion de contenu va chercher pendant qu'un conteneur serveur web expose les données.</li></ul><p>Par défaut, les volumes <code>emptyDir</code> sont stockés sur tout médium supporté par le nœud - que ce soit un disque dur, un disque SSD ou un stockage réseau, dépendamment de l'environnement.
Cependant, vous pouvez définir le champ <code>emptyDir.medium</code> à <code>"Memory"</code> pour indiquer à Kubernetes de monter un tmpfs (système de fichiers supporté par la RAM) pour vous à la place.
Tandis que tmpfs est très rapide, soyez conscient qu'au contraire des disques, un tmpfs est effacé au redémarrage du nœud et tous les fichiers que vous écrivez seront comptabilisés dans la limite de mémoire de votre conteneur.</p><h4 id=exemple-de-pod>Exemple de Pod</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/cache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=fc>fc (fibre channel)</h3><p>Un volume <code>fc</code> permet à un volume Fibre Channel existant d'être monté dans un Pod.
Vous pouvez spécifier une ou plusieurs cibles World Wide Names en utilisant le paramètre
<code>targetWWNs</code> dans votre configuration de volume.
Si plusieurs WWNs sont spécifiés, targetWWNs s'attend à ce que ces WWNs proviennent de connexions multi-path.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez configurer un zonage FC SAN pour allouer et masquer au préalable ces LUNs (volumes) aux cibles WWNs afin que les hôtes Kubernetes puissent y accéder.</div><p>Voir <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/fibre_channel>l'exemple FC</a> pour plus de détails.</p><h3 id=flocker>flocker</h3><p><a href=https://github.com/ClusterHQ/flocker>Flocker</a> est un gestionnaire de volumes de données en cluster open-source. Il assure la gestion et l'orchestration de volumes de données supportés par divers serveurs de stockage.</p><p>Un volume <code>flocker</code> permet de monter un ensemble de données Flocker dans un Pod.
Si l'ensemble de données n'existe pas déjà dans Flocker, il doit d'abord être créé avec la CLI Flocker ou en utilisant l'API Flocker.
Si l'ensemble de données existe déjà, il sera réattaché par Flocker au nœud sur lequel le Pod est planifié.
Cela signifie que les données peuvent être transmises entre les Pods selon les besoins.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez exécuter votre propre installation de Flocker avant de pouvoir l'utiliser.</div><p>Voir <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/flocker>l'exemple Flocker</a> pour plus de détails.</p><h3 id=gcepersistentdisk>gcePersistentDisk</h3><p>Un volume <code>gcePersistentDisk</code> monte un <a href=http://cloud.google.com/compute/docs/disks>Disque Persistant</a> Google Compute Engine (GCE) dans un Pod.
À la différence d'un <code>emptyDir</code>, qui est écrasé lorsqu'un Pod est supprimé, le contenu d'un disque persistant est préservé et le volume est simplement démonté. Cela signifie qu'un disque persistant peut être prérempli avec des données et que ces données peuvent être transmises entre les Pods.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez créer un disque persistant en utilisant <code>gcloud</code>, l'API GCE ou l'interface utilisateur avant de pouvoir utiliser ce disque.</div><p>Des restrictions existent lors de l'utilisation d'un <code>gcePersistentDisk</code>:</p><ul><li>les nœuds sur lesquels les Pods s'exécutent doivent être des machines virtuelles (VMs) GCE.</li><li>ces VMs doivent se trouver dans le même projet et la même zone GCE que le disque persistant</li></ul><p>Une fonctionnalité des disques persistants est qu'ils peuvent être montés en lecture seule par plusieurs consommateurs simultanément.
Cela signifie que vous pouvez préremplir un disque persistant avec votre jeu de données et l'exposer en parallèle à partir d'autant de Pods que nécessaire.
Malheureusement, les disques persistants peuvent seulement être montés par un seul consommateur en mode lecture-écriture - les écritures simultanées ne sont pas autorisées.</p><p>Utiliser un disque persistant dans un Pod contrôlé par un ReplicationController échouera à moins que le disque persistant soit en lecture seule ou que le nombre de répliques soit de 0 ou 1.</p><h4 id=création-d-un-disque-persistant>Création d'un disque persistant</h4><p>Avant de pouvoir utiliser un disque persistant GCE avec un Pod, vous devez le créer.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB --zone<span style=color:#666>=</span>us-central1-a my-data-disk
</span></span></code></pre></div><h4 id=exemple-de-pod-1>Exemple de Pod</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Ce disque persistant GCE doit déjà exister.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=disques-persistants-régionaux>Disques persistants régionaux</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code></div><p>La fonctionnalité de disques persistants régionaux (<a href=https://cloud.google.com/compute/docs/disks/#repds>Regional Persistent Disks</a>) permet la création de disques persistants disponibles dans deux zones à l'intérieur d'une même région.
Afin d'utiliser cette fonctionnalité, le volume doit être provisionné en tant que PersistentVolume; le référencement du volume directement depuis un Pod n'est pas supporté.</p><h4 id=provisionnement-manuel-d-un-disque-persistant-régional-en-tant-que-persistentvolume>Provisionnement manuel d'un disque persistant régional en tant que PersistentVolume</h4><p>Le provisionnement dynamique est possible en utilisant une <a href=/docs/concepts/storage/storage-classes/#gce-pd>StorageClass pour un disque persistant GCE</a>.
Avant de créer un PersistentVolume, vous devez créer le disque persistant :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud beta compute disks create --size<span style=color:#666>=</span>500GB my-data-disk
</span></span><span style=display:flex><span>    --region us-central1
</span></span><span style=display:flex><span>    --replica-zones us-central1-a,us-central1-b
</span></span></code></pre></div><p>Exemple de spec PersistentVolume :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>failure-domain.beta.kubernetes.io/zone</span>:<span style=color:#bbb> </span>us-central1-a__us-central1-b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>400Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=migration-csi-4>Migration CSI</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [alpha]</code></div><p>La fonctionnalité de migration CSI pour un disque persistant GCE, lorsque activée, fixe toutes les opérations de plugin depuis le plugin "in-tree" vers le pilote de l'interface CSI (Container Storage Interface) <code>pd.csi.storage.gke.io</code>.
Afin d'utiliser cette fonctionnalité, le <a href=https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/using-cinder-csi-plugin.md>Pilote CSI de disque persistant GCE</a> doit être installé dans le cluster et les fonctionnalités Alpha <code>CSIMigration</code> et <code>CSIMigrationGCE</code> doivent être activées.</p><h3 id=gitrepo>gitRepo (obsolète)</h3><div class="alert alert-danger warning callout" role=alert><strong>Attention:</strong> Le type de volume gitRepo est obsolète. Pour provisionner un conteneur avec un dépôt git, il faut monter un <a href=#emptydir>EmptyDir</a> dans un InitContainer qui clone le dépôt en utilisant git, ensuite, monter le <a href=#emptydir>EmptyDir</a> dans le conteneur du Pod.</div><p>Un volume <code>gitRepo</code> est un exemple de ce qui peut être réalisé en tant que plugin de volume.
Cela monte un dossier vide et clone un dépôt git à l'intérieur, à la disposition d'un Pod.
Dans le futur, de tels volumes pourraient être déplacé vers un modèle encore plus découplé plutôt qu'étendre l'API Kubernetes pour chaque cas d'utilisation.</p><p>Voici un exemple d'un volume gitRepo :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mypath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gitRepo</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>repository</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;git@somewhere:me/my-git-repository.git&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>revision</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;22f1d8406d464b0c0874075539c1f2e96c253775&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=glusterfs>glusterfs</h3><p>Un volume <code>glusterfs</code> permet à un volume <a href=http://www.gluster.org>Glusterfs</a> (un système de fichiers en réseau open
source) d'être monté dans un Pod. À la différence d'un <code>emptyDir</code>, qui est écrasé lorsqu'un Pod est supprimé. le contenu d'un volume <code>glusterfs</code> est préservé et le volume est simplement démonté.
Cela signifie qu'un volume glusterfs peut être prérempli avec des données et que ces données peuvent être transmises entre les Pods.
GlusterFS peut être monté plusieurs fois en écriture simultanément.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez exécuter votre propre installation de GlusterFS avant de pouvoir l'utiliser.</div><p>Voir <a href=https://github.com/kubernetes/examples/tree/master/volumes/glusterfs>l'exemple GlusterFS</a> pour plus de détails.</p><h3 id=hostpath>hostPath</h3><p>Un volume <code>hostPath</code> monte un fichier ou un dossier depuis le système de fichiers du nœud hôte à l'intérieur d'un Pod.
Ce ne sera pas requis pour la plupart des Pods, mais cela offre une puissante solution de secours pour certaines applications.</p><p>Par exemple, des utilisations du <code>hostPath</code> peuvent être :</p><ul><li>exécuter un conteneur qui nécessite l'accès aux éléments internes de Docker; utiliser un <code>hostPath</code> de <code>/var/lib/docker</code></li><li>exécuter cAdvisor dans un conteneur; utiliser un <code>hostPath</code> de <code>/sys</code></li><li>autoriser un Pod à spécifier si un <code>hostPath</code> donné devrait exister avant la mise en exécution du Pod, s'il devrait être créé et en tant que quoi il devrait exister.</li></ul><p>En plus de la propriété requise <code>path</code>, un utilisateur peut optionnellement spécifier un <code>type</code> pour un volume <code>hostPath</code>.</p><p>Les valeurs supportées pour le champ <code>type</code> sont les suivantes :</p><table><thead><tr><th style=text-align:left>Valeur</th><th style=text-align:left>Comportement</th></tr></thead><tbody><tr><td style=text-align:left></td><td style=text-align:left>Une chaîne de caractères vide (par défaut) sert à la rétrocompatibilité, ce qui signifie qu'aucune vérification ne sera effectuée avant de monter le volume hostPath.</td></tr><tr><td style=text-align:left><code>DirectoryOrCreate</code></td><td style=text-align:left>Si rien n'existe au chemin fourni, un dossier vide y sera créé au besoin avec les permissions définies à 0755, avec le même groupe et la même possession que Kubelet.</td></tr><tr><td style=text-align:left><code>Directory</code></td><td style=text-align:left>Un dossier doit exister au chemin fourni</td></tr><tr><td style=text-align:left><code>FileOrCreate</code></td><td style=text-align:left>Si rien n'existe au chemin fourni, un fichier vide y sera créé au besoin avec les permissions définies à 0644, avec le même groupe et la même possession que Kubelet.</td></tr><tr><td style=text-align:left><code>File</code></td><td style=text-align:left>Un fichier doit exister au chemin fourni</td></tr><tr><td style=text-align:left><code>Socket</code></td><td style=text-align:left>Un socket UNIX doit exister au chemin fourni</td></tr><tr><td style=text-align:left><code>CharDevice</code></td><td style=text-align:left>Un périphérique en mode caractère doit exister au chemin fourni</td></tr><tr><td style=text-align:left><code>BlockDevice</code></td><td style=text-align:left>Un périphérique en mode bloc doit exister au chemin fourni</td></tr></tbody></table><p>Une attention particulière doit être portée lors de l'utilisation de ce type de volume car :</p><ul><li>les Pods avec une configuration identique (tels que ceux créés depuis un podTemplate) peuvent se comporter différemment sur des nœuds différents à cause de fichiers différents sur les nœuds.</li><li>lorsque Kubernetes ajoute une planification tenant compte des ressources, comme prévu, il ne pourra pas prendre en compte les ressources utilisées par un <code>hostPath</code>.</li><li>les fichiers ou dossiers créés sur les hôtes sous-jacents ne sont accessibles en écriture que par root. Vous devez soit exécuter votre programme en tant que root dans un <a href=/docs/user-guide/security-context>conteneur privilégié</a> ou modifier les permissions du fichier sur l'hôte pour pouvoir écrire dans un volume <code>hostPath</code>.</li></ul><h4 id=exemple-de-pod-2>Exemple de Pod</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># chemin du dossier sur l&#39;hôte</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ce champ est optionnel</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Directory<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=iscsi>iscsi</h3><p>Un volume <code>iscsi</code> permet à un volume existant iSCSI (SCSI over IP) d'être monté dans un Pod.
À la différence d'un <code>emptyDir</code>, qui est écrasé lorsqu'un Pod est supprimé, le contenu d'un volume <code>iscsi</code> est préservé et le volume est simplement démonté.
Cela signifie qu'un volume iscsi peut être prérempli avec des données que ces données peuvent être transmises entre les Pods.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez exécuter votre propre serveur iSCSI avec le volume créé avant de pouvoir l'utiliser.</div><p>Une fonctionnalité de iSCSI est qu'il peut être monté en lecture seule par plusieurs consommateurs simultanément.
Cela signifie que vous pouvez préremplir un volume avec votre jeu de données et l'exposer en parallèle à partir d'autant de Pods que nécessaire.
Malheureusement, les volumes iSCSI peuvent seulement être montés par un seul consommateur en mode lecture-écriture - les écritures simultanées ne sont pas autorisées.</p><p>Voir <a href=https://github.com/kubernetes/examples/tree/master/volumes/iscsi>l'exemple iSCSI</a> pour plus de détails.</p><h3 id=local>local</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><p>Un volume <code>local</code> représente un périphérique de stockage local monté tels qu'un disque, une partition ou un dossier.</p><p>Les volumes locaux peuvent seulement être utilisés comme un PersistentVolume créé statiquement.
Le provisionnement dynamique n'est pas encore supporté.</p><p>Comparés aux volumes <code>hostPath</code>, les volumes locaux peuvent être utilisés de manière durable et portable sans planifier manuellement des Pods sur les nœuds, puisque le système est conscient des contraintes de nœud du volume en examinant l'affinité de nœud sur le PersistentVolume.</p><p>Toutefois, les volumes locaux sont encore sujets à la disponibilité du nœud sous-jacent et ne conviennent pas à toutes les applications. Si un nœud devient "en mauvaise santé" (unhealthy), alors le volume local deviendra également inaccessible et un Pod qui l'utilise ne sera pas en mesure de s'exécuter. Les applications qui utilisent des volumes locaux doivent être en mesure de tolérer cette disponibilité réduite, ainsi que de potentielles pertes de données, dépendamment des caractéristiques de durabilité du disque sous-jacent.</p><p>L'exemple suivant traite d'une spec d'un PersistentVolume utilisant un volume <code>local</code> et une <code>nodeAffinity</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>100Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># le champ volumeMode requiert l&#39;activation de la &#34;feature gate&#34; Alpha BlockVolume</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>local</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/mnt/disks/ssd1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/hostname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- example-node<span style=color:#bbb>
</span></span></span></code></pre></div><p>La <code>nodeAffinity</code> d'un PersistentVolume est requise lors de l'utilisation de volumes locaux.
Cela permet au planificateur (scheduler) Kubernetes de planifier correctement des Pods utilisant des volumes locaux aux bons nœuds.</p><p>Le <code>volumeMode</code> d'un PersistentVolume peut maintenant être configuré à "Block" (au lieu de la valeur par défaut "Filesystem") pour exposer le volume local en tant que périphérique bloc brut (raw block device).
Le champ <code>volumeMode</code> requiert l'activation de la "feature gate" Alpha <code>BlockVolume</code>.</p><p>Lors de l'utilisation des volumes locaux, il est recommandé de créer une StorageClass avec <code>volumeBindingMode</code> configuré à <code>WaitForFirstConsumer</code>. Voir <a href=/docs/concepts/storage/storage-classes/#local>l'exemple</a>. Retarder la liaison (binding) du volume garantit que la décision de liaison du PersistentVolumeClaim sera également évaluée avec toutes les autres contraintes de nœud que le Pod peut avoir, tels que les exigences en ressources du nœud, les sélecteurs de nœud, leur affinité et leur anti-affinité.</p><p>Un provisionneur statique externe peut être exécuté séparément pour une gestion améliorée du cycle de vie du volume local.
Noter que ce provisionneur ne supporte pas encore le provisionnement dynamique. Pour un exemple sur la façon d'exécuter un provisionneur externe local, voir le <a href=https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner>guide utilisateur de provisionneur de volume local</a>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le PersistentVolume local requiert un nettoyage manuel et une suppression par l'utilisateur si le provisionneur statique n'est pas utilisé pour gérer le cycle de vie du volume.</div><h3 id=nfs>nfs</h3><p>Un volume <code>nfs</code> permet à un partage NFS (Network File System) existant d'être monté dans un Pod.
À la différence d'un <code>emptyDir</code>, qui est écrasé lorsqu'un Pod est supprimé, le contenu d'un volume <code>nfs</code> est préservé et le volume est simplement démonté.
Cela signifie qu'un volume NFS peut être prérempli avec des données et que les données peuvent être transmises entre les Pods. NFS peut être monté plusieurs fois en écriture simultanément.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez exécuter votre propre serveur NFS avec le partage exporté avant de pouvoir l'utiliser.</div><p>Voir <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/nfs>l'exemple NFS</a> pour plus de détails.</p><h3 id=persistentvolumeclaim>persistentVolumeClaim</h3><p>Un volume <code>persistentVolumeClaim</code> est utilisé pour monter un <a href=/docs/concepts/storage/persistent-volumes/>PersistentVolume</a> dans un Pod. Les PersistentVolumes sont une manière pour les utilisateurs de "revendiquer" un stockage durable (comme un PersistentDisk GCE ou un volume iSCSI) sans savoir les détails d'un environnement cloud particulier.</p><p>Voir <a href=/docs/concepts/storage/persistent-volumes/>l'exemple PersistentVolumes</a> pour plus de détails.</p><h3 id=projected>projected</h3><p>Un volume <code>projected</code> mappe plusieurs sources de volume existantes dans le même dossier.</p><p>Actuellement, les types de sources de volume suivantes peuvent être projetés :</p><ul><li><a href=#secret><code>secret</code></a></li><li><a href=#downwardapi><code>downwardAPI</code></a></li><li><a href=#configmap><code>configMap</code></a></li><li><code>serviceAccountToken</code></li></ul><p>Toutes les sources doivent se trouver dans le même namespace que celui du Pod. Pour plus de détails, voir le <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/all-in-one-volume.md>document de conception tout-en-un </a>.</p><p>La projection des jetons de compte de service (service account) est une fonctionnalité introduite dans Kubernetes 1.11 et promue en Beta dans la version 1.12.
Pour activer cette fonctionnalité dans la version 1.11, il faut configurer explicitement la <a href=/docs/reference/command-line-tools-reference/feature-gates/>"feature gate" <code>TokenRequestProjection</code></a> à "True".</p><h4 id=exemple-d-un-pod-avec-un-secret-une-api-downward-et-une-configmap>Exemple d'un Pod avec un secret, une API downward et une configmap.</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;labels&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.labels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cpu_limit&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-config<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=exemple-d-un-pod-avec-plusieurs-secrets-avec-une-configuration-de-mode-de-permission-autre-que-celle-par-défaut>Exemple d'un Pod avec plusieurs secrets avec une configuration de mode de permission autre que celle par défaut.</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>511</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Chaque source de volume projeté est listée dans la spec, sous <code>sources</code>. Les paramètres sont à peu près les mêmes avec deux exceptions :</p><ul><li>Pour les secrets, le champ <code>secretName</code> a été changé par <code>name</code> pour être consistant avec le nommage des ConfigMap.</li><li>Le <code>defaultMode</code> peut seulement être spécifié au niveau projeté et non pour chaque source de volume. Cependant, tel qu'illustré au-dessus, il est possible de configurer explicitement le <code>mode</code> pour chaque projection individuelle.</li></ul><p>Lorsque la fonctionnalité <code>TokenRequestProjection</code> est activée, vous pouvez injecter le jeton pour le <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>service account</a> courant dans un Pod au chemin spécifié. Ci-dessous, un exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sa-token-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/service-account&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>api<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span></span></span></code></pre></div><p>Le pod d'exemple possède un volume projeté contenant le jeton injecté du service account.
Ce jeton peut être utilisé par des conteneurs de Pod pour accéder au service d'API Kubernetes API, par exemple.
Le champ <code>audience</code> contient l'audience-cible du jeton.
Un destinataire du jeton doit s'identifier avec un identificateur spécifié dans l'audience du jeton, sinon il doit rejeter le jeton. Ce champ est facultatif et sa valeur par défaut est l'identifiant du serveur API.</p><p>Le champ <code>expirationSeconds</code> est la durée de validité attendue du jeton de service account.
Sa valeur par défaut est de 1 heure et doit être au moins de 10 minutes (600 secondes). Un administrateur peut aussi limiter sa valeur maximum en spécifiant l'option <code>--service-account-max-token-expiration</code> pour le serveur API.
Le champ <code>path</code> spécifie un chemin relatif au point de montage du volume projeté.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Un conteneur utilisant une source de volume projeté en tant que point de montage de volume <a href=#using-subpath>subPath</a> ne recevra pas de mises à jour pour ces sources de volume.</div><h3 id=portworxvolume>portworxVolume</h3><p>Un <code>portworxVolume</code> est une couche de stockage bloc élastique qui s'exécute de manière hyperconvergée avec Kubernetes.
<a href=https://portworx.com/use-case/kubernetes-storage/>Portworx</a> donne l'empreinte digitale d'un stockage dans un serveur, tiers basés sur les capacités et agrège la capacité sur plusieurs serveurs. Portworx s'exécute en invité sur des machines virtuelles ou sur des nœuds Linux bare metal.</p><p>Un <code>portworxVolume</code> peut être créé dynamiquement à travers Kubernetes ou il peut également être pré-provisionné et référencé à l'intérieur d'un Pod Kubernetes.
Voici un exemple de Pod référençant un PortworxVolume pré-provisionné :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-portworx-volume-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Ce volume Portworx doit déjà exister.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>portworxVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pxvol&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;fs-type&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Il faut s'assurer d'avoir un PortworxVolume existant avec le nom <code>pxvol</code> avant de l'utiliser dans le Pod.</div><p>Plus de détails et d'exemples peuvent être trouvé <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/portworx/README.md>ici</a>.</p><h3 id=quobyte>quobyte</h3><p>Un volume <code>quobyte</code> permet à un volume existant <a href=http://www.quobyte.com>Quobyte</a> d'être monté dans un Pod.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez exécuter votre propre configuration Quobyte avec les volumes créés avant de pouvoir l'utiliser.</div><p>Quobyte supporte le <a class=glossary-tooltip title="L'Interface de Stockage de Conteneurs (CSI, de l'anglais Container Storage Interface) définit une interface normalisée pour exposer les systèmes de stockage aux conteneurs." data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label='Container Storage Interface'>Container Storage Interface</a>.
CSI est le plugin recommandé pour utiliser les volumes Quobyte volumes dans Kubernetes. Le projet GitHub Quobyte dispose <a href=https://github.com/quobyte/quobyte-csi#quobyte-csi>d'instructions</a> pour déployer Quobyte en utilisant CSI, avec des exemples.</p><h3 id=rbd>rbd</h3><p>Un volume <code>rbd</code> permet à un volume périphérique bloc Rados (<a href=http://ceph.com/docs/master/rbd/rbd/>Rados Block
Device</a>) d'être monté dans un Pod.
À la différence d'un <code>emptyDir</code>, qui est écrasé lorsqu'un Pod est supprimé, le contenu d'un volume <code>rbd</code> est préservé et le volume est simplement démonté.
Cela signifie qu'un volume RBD peut être prérempli avec des données et que ces données peuvent être transmises entre les Pods.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez exécuter votre propre installation Ceph avant de pouvoir utiliser RBD.</div><p>Une fonctionnalité de RBD est qu'il peut être monté en lecture seule par plusieurs consommateurs simultanément.
Cela signifie que vous pouvez préremplir un volume avec votre jeu de données et l'exposer en parallèle à partir d'autant de Pods que nécessaire.
Malheureusement, les volumes RBD peuvent seulement être montés par un seul consommateur en mode lecture-écriture - les écritures simultanées ne sont pas autorisées.</p><p>Voir <a href=https://github.com/kubernetes/examples/tree/master/volumes/rbd>l'exemple RBD</a> pour plus de détails.</p><h3 id=scaleio>scaleIO</h3><p>ScaleIO est une plateforme de stockage logicielle qui peut utiliser du matériel physique existant pour créer des clusters de stockage bloc partagé en réseau évolutif.
Le plugin de volume <code>scaleIO</code> permet aux Pods déployés d'accéder à des volumes ScaleIO existants (ou il peut provisionner dynamiquement de nouveaux volumes pour des revendications de volumes persistants, voir <a href=/docs/concepts/storage/persistent-volumes/#scaleio>ScaleIO Persistent Volumes</a>).</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez exécuter un cluster ScaleIO déjà configuré avec les volumes créés avant de pouvoir les utiliser.</div><p>L'exemple suivant montre une configuration de Pod avec ScaleIO :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scaleIO</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>gateway</span>:<span style=color:#bbb> </span>https://localhost:443/api<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>system</span>:<span style=color:#bbb> </span>scaleio<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protectionDomain</span>:<span style=color:#bbb> </span>sd0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storagePool</span>:<span style=color:#bbb> </span>sp1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>vol-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sio-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>xfs<span style=color:#bbb>
</span></span></span></code></pre></div><p>Pour plus de détails, consulter <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/scaleio>les exemples ScaleIO</a>.</p><h3 id=secret>secret</h3><p>Un volume <code>secret</code> est utilisé pour fournir des informations sensibles, comme des mots de passe, aux Pods.
Vous pouvez stocker des secrets dans l'API Kubernetes et les monter en tant que fichiers pour être utilisés par les Pods sans les coupler directement avec Kubernetes. Les volumes <code>secret</code> sont supportés par tmpfs (un système de fichiers en RAM) pour qu'ils ne soient jamais écrits sur du stockage non volatil.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez créer un secret dans l'API Kubernetes avant de pouvoir l'utiliser.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Un conteneur utilisant un secret en tant que point de montage de volume <a href=#using-subpath>subPath</a> ne recevra pas les mises à jour des secrets.</div><p>Les secrets sont décrits plus en détails <a href=/docs/user-guide/secrets>ici</a>.</p><h3 id=storageos>storageOS</h3><p>Un volume <code>storageos</code> permet à un volume <a href=https://www.storageos.com>StorageOS</a> existant d'être monté dans un Pod.</p><p>StorageOS s'exécute en tant que conteneur dans l'environnement Kubernetes en rendant le stockage local ou attaché accessible depuis n'importe quel nœud dans le cluster Kubernetes.
Les données peuvent être répliquées pour se protéger des défaillances de nœuds.
Les techniques d'allocation fine et dynamique et de compression peuvent améliorer l'utilisation et réduire les coûts.</p><p>À la base, StorageOS fournit un stockage bloc aux conteneurs accessible via un système de fichiers.</p><p>Le conteneur StorageOS requiert Linux 64-bit et n'a pas besoin de dépendances supplémentaires.
Une licence développeur libre est disponible.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez exécuter le conteneur StorageOS sur chaque nœud qui souhaite accéder aux volumes StorageOS ou qui veut contribuer à la
capacité de stockage du pool.
Pour les instructions d'installation, consulter la <a href=https://docs.storageos.com>documentation StorageOS</a>.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-storageos-redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>kubernetes/redis:v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MASTER<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/redis-master-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageos</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Le volume `redis-vol01` doit déjà exister dans StorageOS, dans le namespace `default`.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>redis-vol01<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>Pour plus d'informations incluant le provisionnement dynamique (Dynamic Provisioning) et les réclamations de volume persistant (Persistent Volume Claims), consulter les <a href=https://github.com/kubernetes/examples/blob/master/volumes/storageos>exemples StorageOS</a>.</p><h3 id=vspherevolume>vsphereVolume</h3><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Prérequis : Kubernetes avec vSphere Cloud Provider configuré. Pour la configuration cloudprovider,
se référer au <a href=https://vmware.github.io/vsphere-storage-for-kubernetes/documentation/>guide de mise en marche vSphere</a>.</div><p>Un volume <code>vsphereVolume</code> est utilisé pour monter un volume vSphere VMDK dans un Pod. Le contenu d'un volume est préservé lorsqu'il est démonté. Il supporte les banques de données (datastore) VMFS and VSAN.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Vous devez créer VMDK en utilisant une des méthodes suivantes avant de l'utiliser avec un Pod.</div><h4 id=création-d-un-volume-vmdk>Création d'un volume VMDK</h4><p>Choisir une des méthodes suivantes pour créer un VMDK.</p><ul class="nav nav-tabs" id=tabs-volumes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabs-volumes-0 role=tab aria-controls=tabs-volumes-0 aria-selected=true>Création en utilisant vmkfstools</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-volumes-1 role=tab aria-controls=tabs-volumes-1>Création en utilisant vmware-vdiskmanager</a></li></ul><div class=tab-content id=tabs-volumes><div id=tabs-volumes-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabs-volumes-0><p><p>Premièrement, se connecter en ssh dans l'ESX, ensuite, utiliser la commande suivante pour créer un VMDK :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vmkfstools -c 2G /vmfs/volumes/DatastoreName/volumes/myDisk.vmdk
</span></span></code></pre></div></div><div id=tabs-volumes-1 class=tab-pane role=tabpanel aria-labelledby=tabs-volumes-1><p><p>Utiliser la commande suivante pour créer un VMDK:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vmware-vdiskmanager -c -t <span style=color:#666>0</span> -s 40GB -a lsilogic myDisk.vmdk
</span></span></code></pre></div></div></div><h4 id=exemple-de-configuration-vsphere-vmdk>Exemple de configuration vSphere VMDK</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-vmdk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-vmdk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Ce volume VMDK doit déjà exister.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>vsphereVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;[DatastoreName] volumes/myDisk&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>Plus d'exemples sont disponibles <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>ici</a>.</p><h2 id=utilisation-de-subpath>Utilisation de subPath</h2><p>Parfois, il est utile de partager un volume pour plusieurs utilisations dans un même Pod.
La propriété <code>volumeMounts.subPath</code> peut être utilisée pour spécifier un sous-chemin à l'intérieur du volume référencé au lieu de sa racine.</p><p>Voici un exemple d'un Pod avec une stack LAMP (Linux Apache Mysql PHP) utilisant un unique volume partagé.
Le contenu HTML est mappé à son dossier <code>html</code> et les bases de données seront stockées dans son dossier <code>mysql</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-lamp-site<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;rootpasswd&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>php:7.0-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/www/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>my-lamp-site-data<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=utilisation-d-un-subpath-avec-des-variables-d-environnement-étendues>Utilisation d'un subPath avec des variables d'environnement étendues</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code></div><p>Utiliser le champ <code>subPathExpr</code> pour construire des noms de dossier <code>subPath</code> depuis les variables d'environnement de l'API Downward.
Avant d'utiliser cette fonctionnalité, vous devez activer la "feature gate" <code>VolumeSubpathEnvExpansion</code>.
Les propriétés <code>subPath</code> et <code>subPathExpr</code> sont mutuellement exclusives.</p><p>Dans cet exemple, un Pod utilise <code>subPathExpr</code> pour créer un dossier <code>pod1</code> à l'intérieur du volume hostPath <code>/var/log/pods</code>, en utilisant le nom du pod depuis l'API Downward.
Le dossier hôte <code>/var/log/pods/pod1</code> est monté sur <code>/logs</code> dans le conteneur.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>POD_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while [ true ]; do echo &#39;Hello&#39;; sleep 10; done | tee -a /logs/hello.txt&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/logs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>subPathExpr</span>:<span style=color:#bbb> </span>$(POD_NAME)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/pods<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=ressources>Ressources</h2><p>Le support de stockage (Disk, SSD, etc.) d'un volume <code>emptyDir</code> est déterminé par le support du système de fichiers
contenant le dossier racine de kubelet (typiquement <code>/var/lib/kubelet</code>).
Il n'y a pas de limite sur l'espace qu'un volume <code>emptyDir</code> ou <code>hostPath</code> peut consommer
et pas d'isolation entre les conteneurs ou entre les Pods.</p><p>Dans le futur, il est prévu que les volumes <code>emptyDir</code> et <code>hostPath</code> soient en mesure de demander une certaine quantité d'espace en utilisant une spécification de <a href=/docs/user-guide/compute-resources>ressource</a> et de sélectionner un type de support à utiliser, pour les clusters qui ont plusieurs types de support.</p><h2 id=plugins-de-volume-out-of-tree>Plugins de volume Out-of-Tree</h2><p>Les plugins de volume Out-of-tree incluent l'interface CSI (Container Storage Interface) et FlexVolume.
Ils permettent aux fournisseurs de stockage de créer des plugins de stockage personnalisés sans les ajouter au dépôt Kubernetes.</p><p>Avant l'introduction de l'interface CSI et FlexVolume, tous les plugins de volume (tels que les types de volume listés plus haut) étaient "in-tree", ce qui signifie qu'ils étaient construits, liés, compilés et livrés avec les binaires de base Kubernetes et étendent l'API Kubernetes de base.
Cela signifiait que l'ajout d'un nouveau système de stockage à Kubernetes (un plugin de volume) requérait de vérifier le code dans le dépôt de base de Kubernetes.</p><p>CSI et FlexVolume permettent à des plugins de volume d'être développés indépendamment de la base de code Kubernetes et déployés (installés) sur des clusters Kubernetes en tant qu'extensions.</p><p>Pour les fournisseurs de stockage qui cherchent à créer un plugin de volume "out-of-tree", se référer à <a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>cette FAQ</a>.</p><h3 id=csi>CSI</h3><p>L'interface <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>Container Storage Interface</a> (CSI) définit une interface standard pour les systèmes d'orchestration de conteneurs (comme Kubernetes) pour exposer des systèmes de stockage arbitraires aux charges de travail de leurs conteneurs.</p><p>Pour plus d'informations, lire la <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md>proposition de conception CSI</a>.</p><p>Le support CSI a été introduit en alpha à partir de Kubernetes v1.9, a évolué en beta dans Kubernetes v1.10 et est en disponibilité générale (GA) depuis Kubernetes v1.13.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le support des versions spec CSI 0.2 et 0.3 sont obsolètes dans Kubernetes v1.13 et seront retirés dans une version future.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Les pilotes CSI peuvent ne pas être compatibles avec toutes les versions de Kubernetes.
Vérifier la documentation des pilotes CSI spécifiques pour les étapes de déploiement supportées pour chaque version de Kubernetes et la matrice de compatibilité.</div><p>Une fois qu'un pilote de volume CSI compatible est déployé dans un cluster Kubernetes, les utilisateurs peuvent
utiliser le type de volume <code>csi</code> pour attacher, monter, etc.., les volumes exposés par le pilote CSI.</p><p>Le type de volume <code>csi</code> ne supporte pas de référence directe depuis un Pod et ne peut être référencé seulement dans un Pod que par un objet <code>PersistentVolumeClaim</code>.</p><p>Les champs suivants sont disponibles aux administrateurs de stockage pour configurer un volume persistant CSI :</p><ul><li><code>driver</code>: Une valeur texte qui spécifie le nom du pilote de volume à utiliser.
Cette valeur doit correspondre à la valeur retournée dans le <code>GetPluginInfoResponse</code> par le pilote CSI tel que défini dans la
<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#getplugininfo>spec CSI</a>.
Elle est utilisée par Kubernetes pour identifier le pilote CSI à appeler et par les composants du pilote CSI
pour identifier quels objets PV appartiennent au pilote CSI.</li><li><code>volumeHandle</code>: Une valeur texte qui identifie le volume de manière unique. Cette valeur doit correspondre à la valeur retournée dans le champ <code>volume.id</code> de <code>CreateVolumeResponse</code> par le pilote CSI tel que défini dans la <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>spec CSI</a>.
La valeur est passée en tant que <code>volume_id</code> sur tous les appels au pilote de volume CSI lorsque le volume est référencé.</li><li><code>readOnly</code>: Une valeur booléenne optionnelle indiquant si le volume doit être
"ControllerPublished" (attaché) en lecture seule. La valeur par défaut est "false". Cette valeur est passées au pilote CSI
via le champ <code>readonly</code> dans le <code>ControllerPublishVolumeRequest</code>.</li><li><code>fsType</code>: Si le <code>VolumeMode</code> du PV est <code>Filesystem</code>, alors ce champ peut être utilisé pour spécifier le système de fichiers
qui devrait être utilisé pour monter le volume. Si le volume n'a pas été formaté et que le formatage est supporté, cette valeur sera
utilisée pour formater le volume.
Cette valeur est passée au pilote CSI driver via le champ <code>VolumeCapability</code> de
<code>ControllerPublishVolumeRequest</code>, <code>NodeStageVolumeRequest</code>, et
<code>NodePublishVolumeRequest</code>.</li><li><code>volumeAttributes</code>: Un tableau associatif (map) string vers string qui spécifie les propriétés statiques d'un volume. Ce tableau associatif doit correspondre à celui retourné dans le champ
<code>volume.attributes</code> du <code>CreateVolumeResponse</code> par le pilote CSI tel que défini dans
la <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>spec CSI</a>.
Le tableau associatif est passé au pilote CSI via le champ <code>volume_attributes</code> dans la <code>ControllerPublishVolumeRequest</code>, <code>NodeStageV olumeRequest</code>, et <code>NodePublishVolumeRequest</code>.</li><li><code>controllerPublishSecretRef</code>: Une référence de l'objet de type secret contenant des informations sensibles à passer
au driver CSI pour compléter les appels CSI <code>ControllerPublishVolume</code> et <code>ControllerUnpublishVolume</code>.
Ce champ est optionnel et peut être vide si aucun secret n'est requis.
Si l'objet secret contient plus qu'un secret, tous les secrets sont passés.</li><li><code>nodeStageSecretRef</code>: Une référence à l'objet de type secret contenant des informations sensibles à passer au pilote CSI
pour compléter l'appel CSI <code>NodeStageVolume</code>. Ce champ est optionnel et peut être vide si aucun secret n'est requis.
Si l'objet secret contient plus qu'un secret, tous les secrets sont passés.</li><li><code>nodePublishSecretRef</code>: Une référence vers l'objet de type secret contenant des informations sensibles à passer au pilote CSI
pour compléter l'appel CSI <code>NodePublishVolume</code>. Ce champ est optionnel et peut être vide si aucun secret n'est requis.
Si l'objet secret contient plus qu'un secret, tous les secrets sont passés.</li></ul><h4 id=support-de-volume-bloc-brut-csi>Support de volume bloc brut CSI</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [beta]</code></div><p>À partir de la version 1.11, CSI a introduit le support des volumes bloc bruts, qui s'appuient
sur la fonctionnalité de volume bloc brut introduite dans une version précédente de Kubernetes.
Cette fonctionnalité va permettre aux fournisseurs avec des pilotes CSI externes d'implémenter le support pour les volumes bloc bruts
dans les charges de travail Kubernetes.</p><p>Le support volume bloc CSI est une "feature-gate", mais est activée par défaut. Les deux
"feature gates" qui doivent être activées pour cette fonctionnalité sont <code>BlockVolume</code> et <code>CSIBlockVolume</code>.</p><p>Apprenez comment <a href=/docs/concepts/storage/persistent-volumes/#raw-block-volume-support>configurer votre PV/PVC avec le support de volume bloc brut</a>.</p><h4 id=volumes-csi-éphémères>Volumes CSI éphémères</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [alpha]</code></div><p>Cette fonctionnalité permet aux volumes CSI d'être embarqués directement dans la spécification du Pod au lieu de celle d'un PersistentVolume. Les Volumes spécifiés de cette manière sont éphémères et ne persistent pas lorsque le Pod redémarre.</p><p>Exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/data&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-inline-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1000000&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-inline-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>csi</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>inline.storage.kubernetes.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeAttributes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span></code></pre></div><p>Cette fonctionnalité requiert l'activation de la "feature gate" CSIInlineVolume :</p><pre tabindex=0><code>--feature-gates=CSIInlineVolume=true
</code></pre><p>Les volumes éphémères CSI sont seulement supportés par un sous-ensemble des pilotes CSI. La liste des pilotes CSI est disponible <a href=https://kubernetes-csi.github.io/docs/drivers.html>ici</a>.</p><h1 id=ressources-pour-développeur>Ressources pour développeur</h1><p>Pour plus d'informations sur la manière de développer un pilote CSI, se référer à la <a href=https://kubernetes-csi.github.io/docs/>documentation kubernetes-csi</a></p><h4 id=migration-de-pilotes-csi-depuis-des-plugins-in-tree>Migration de pilotes CSI depuis des plugins "in-tree"</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [alpha]</code></div><p>La fonctionnalité de migration CSI, lorsque activée, dirige les opérations sur les plugins "in-tree" existants vers les plugins CSI correspondants (qui sont sensés être installés et configurés).
Cette fonctionnalité implémente la logique de translation nécessaire et les fixations nécessaires pour rerouter les opérations
de manière transparente. En conséquence, les opérateurs n'ont pas à effectuer de changements de configuration aux classes de stockage (Storage Classes) existantes, PV ou PVC (référençant aux plugins "in-tree") lors de la transition vers un pilote CSI qui remplace un plugin "in-tree".</p><p>Dans l'état alpha, les opérations et fonctionnalités qui sont supportées incluent provisionnement/suppression, attachement/détachement, montage/démontage et le redimensionnement des volumes.</p><p>Les plugins "in-tree" qui supportent la migration CSI et qui ont un pilote CSI correspondant implémenté sont listés dans la section "Types de volumes" au-dessus.</p><h3 id=flexVolume>FlexVolume</h3><p>FlexVolume est une interface de plugin "out-of-tree" qui existe dans Kubernetes depuis la version 1.2 (avant CSI).
Elle utilise un modèle basé sur exec pour s'interfacer avec les pilotes. Les binaires de pilote FlexVolume doivent être installés dans un chemin de volume de plugin prédéfini sur chaque nœud (et dans certains cas le nœud maître).</p><p>Les Pods interagissent avec les pilotes FlexVolume à travers le plugin "in-tree" <code>flexvolume</code>
Plus de détails sont disponibles <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md>ici</a>.</p><h2 id=propagation-de-montage>Propagation de montage</h2><p>La propagation de montage permet à des volumes partagés montés par un conteneur à d'autres conteneurs dans un même Pod, ou même à d'autres Pods dans le même nœud.</p><p>La propagation de montage d'un volume est contrôlée par le champ <code>mountPropagation</code> dans Container.volumeMounts.
Ses valeurs sont :</p><ul><li><p><code>None</code> - Ce montage de volume ne recevra aucun montage subséquent qui est monté à ce volume ou n'importe lequel de ses sous-dossiers par l'hôte. De la même manière, aucun montage créé par le conteneur ne sera visible sur l'hôte. C'est le mode par défaut.</p><p>Ce mode équivaut à une propagation de montage <code>private</code> tel que décrit dans la <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>documentation du noyau Linux</a></p></li><li><p><code>HostToContainer</code> - Ce montage de volume recevra les montages subséquents qui sont montés sur ce volume ou n'importe lequel de ses sous-dossiers.</p><p>En d'autres termes, si l'hôte monte quoi que ce soit dans le montage de volume, le conteneur va le voir monté à cet endroit.</p><p>De manière similaire, si un Pod avec la propagation de montage <code>Bidirectional</code> vers le même volume y monte quoi que ce soit,
le conteneur avec la propagation de montage <code>HostToContainer</code> le verra.</p><p>Ce mode est équivalent à la propagation de montage <code>rslave</code> tel que décrit dans la
<a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>documentation du noyau Linux</a></p></li><li><p><code>Bidirectional</code> - Ce montage de volume se comporte de la même manière que le montage <code>HostToContainer</code>.
De plus, tous les montages de volume créés par le conteneur seront propagés à l'hôte et à tous les conteneurs des autres Pods qui utilisent le même volume.</p><p>Un cas d'utilisation typique pour ce mode est un Pod avec un FlexVolume ou un pilote CSI, ou un Pod qui nécessite de monter quelque chose sur l'hôte en utilisant un volume <code>hostPath</code>.</p><p>Ce mode est équivalent à une propagation de montage <code>rshared</code> tel que décrit dans la
<a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>documentation du noyau Linux</a></p></li></ul><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> La propagation de montage <code>Bidirectional</code> peut être dangereuse. Elle peut endommager le système d'exploitation hôte
et est donc autorisée seulement dans des conteneurs privilégiés.
Il est fortement recommandé d'être familier avec le comportement du noyau Linux.
De plus, tous les montages de volume créés par des conteneurs dans des Pods doivent être détruits (démontés) par les conteneurs lors de la terminaison.</div><h3 id=configuration>Configuration</h3><p>Avant que la propagation de montage puisse fonctionner correctement sur certains déploiements (CoreOS,
RedHat/Centos, Ubuntu) le partage de montage doit être correctement configuré dans Docker tel qu'illustré ci-dessous :</p><p>Modifiez le fichier de service <code>systemd</code> de votre Docker. Configurez votre <code>MountFlags</code> comme suit :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>MountFlags</span><span style=color:#666>=</span>shared
</span></span></code></pre></div><p>Ou bien retirez <code>MountFlags=slave</code> si présent. Redémarrez ensuite le démon Docker :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart docker
</span></span></code></pre></div><h2 id=a-suivre>A suivre</h2><ul><li>Suivez un exemple de <a href=/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>déploiement de WordPress et MySQL avec des volumes persistants</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ffd12528a12882b282e1bd19e29f9e75>6.2 - Volumes persistants</h1><p>Ce document décrit l'état actuel de <code>PersistentVolumes</code> dans Kubernetes.
Une connaissance des <a href=/fr/docs/concepts/storage/volumes/>volumes</a> est suggérée.</p><h2 id=introduction>Introduction</h2><p>La gestion du stockage est un problème distinct de la gestion des instances de calcul.
Le sous-système <code>PersistentVolume</code> fournit une API pour les utilisateurs et les administrateurs qui abstrait les détails de la façon dont le stockage est fourni et de la façon dont il est utilisé.
Pour ce faire, nous introduisons deux nouvelles ressources API: <code>PersistentVolume</code> et <code>PersistentVolumeClaim</code>.</p><p>Un <code>PersistentVolume</code> (PV) est un élément de stockage dans le cluster qui a été provisionné par un administrateur ou provisionné dynamiquement à l'aide de <a href=/docs/concepts/storage/storage-classes/>Storage Classes</a>.
Il s'agit d'une ressource dans le cluster, tout comme un nœud est une ressource de cluster.
Les PV sont des plugins de volume comme Volumes, mais ont un cycle de vie indépendant de tout pod individuel qui utilise le PV.
Cet objet API capture les détails de l'implémentation du stockage, que ce soit NFS, iSCSI ou un système de stockage spécifique au fournisseur de cloud.</p><p>Un <code>PersistentVolumeClaim</code> (PVC) est une demande de stockage par un utilisateur.
Il est similaire à un Pod.
Les pods consomment des ressources de noeud et les PVC consomment des ressources PV.
Les pods peuvent demander des niveaux spécifiques de ressources (CPU et mémoire).
Les PVC peuvent demander une taille et des modes d'accès spécifiques (par exemple, ils peuvent être montés une fois en lecture/écriture ou plusieurs fois en lecture seule).</p><p>Alors que les <code>PersistentVolumeClaims</code> permettent à un utilisateur de consommer des ressources de stockage abstraites, il est courant que les utilisateurs aient besoin de <code>PersistentVolumes</code> avec des propriétés et des performances variables pour différents problèmes.
Les administrateurs de cluster doivent être en mesure d'offrir une variété de <code>PersistentVolumes</code> qui diffèrent de bien des façons plus que la taille et les modes d'accès, sans exposer les utilisateurs aux détails de la façon dont ces volumes sont mis en œuvre.
Pour ces besoins, il existe la ressource <code>StorageClass</code>.</p><p>Voir la <a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>procédure détaillée avec des exemples</a>.</p><h2 id=cycle-de-vie-d-un-pv-et-d-un-pvc>Cycle de vie d'un PV et d'un PVC</h2><p>Les PV sont des ressources du cluster.
Les PVC sont des demandes pour ces ressources et agissent également comme des contrôles de réclamation pour la ressource.
L'interaction entre les PV et les PVC suit ce cycle de vie:</p><h3 id=provisionnement>Provisionnement</h3><p>Les PV peuvent être provisionnés de deux manières: statiquement ou dynamiquement.</p><h4 id=provisionnement-statique>Provisionnement statique</h4><p>Un administrateur de cluster crée un certain nombre de PV.
Ils contiennent les détails du stockage réel, qui est disponible pour une utilisation par les utilisateurs du cluster.
Ils existent dans l'API Kubernetes et sont disponibles pour la consommation.</p><h4 id=provisionnement-dynamique>Provisionnement dynamique</h4><p>Lorsqu'aucun des PV statiques créés par l'administrateur ne correspond au <code>PersistentVolumeClaim</code> d'un utilisateur, le cluster peut essayer de provisionner dynamiquement un volume spécialement pour le PVC.
Ce provisionnement est basé sur les <code>StorageClasses</code>: le PVC doit demander une <a href=/docs/concepts/storage/storage-classes/>storage class</a> et l'administrateur doit avoir créé et configuré cette classe pour que l'approvisionnement dynamique se produise.
Les PVC qui demandent la classe <code>""</code> désactive le provisionnement dynamique pour eux-mêmes.</p><p>Pour activer le provisionnement de stockage dynamique basé sur la classe de stockage, l'administrateur de cluster doit activer le <code>DefaultStorageClass</code> dans l'<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass>contrôleur d'admission</a> sur le serveur API.
Cela peut être fait, par exemple, en veillant à ce que <code>DefaultStorageClass</code> figure parmi la liste de valeurs séparées par des virgules pour l'option <code>--enable-admission-plugins</code> du composant serveur API.
Pour plus d'informations sur les options de ligne de commande du serveur API, consultez la documentation <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>.</p><h3 id=liaison>Liaison</h3><p>Un utilisateur crée, ou dans le cas d'un provisionnement dynamique, a déjà créé, un <code>PersistentVolumeClaim</code> avec une quantité spécifique de stockage demandée et avec certains modes d'accès.
Une boucle de contrôle dans le maître surveille les nouveaux PVC, trouve un PV correspondant (si possible) et les lie ensemble.
Si un PV a été dynamiquement provisionné pour un nouveau PVC, la boucle liera toujours ce PV au PVC.
Sinon, l'utilisateur obtiendra toujours au moins ce qu'il a demandé, mais le volume peut être supérieur à ce qui a été demandé.
Une fois liées, les liaisons <code>PersistentVolumeClaim</code> sont exclusives, quelle que soit la façon dont elles ont été liées.
Une liaison PVC-PV est une relation 1-à-1.</p><p>Les PVC resteront non liés indéfiniment s'il n'existe pas de volume correspondant.
Le PVC sera lié à mesure que les volumes correspondants deviendront disponibles.
Par exemple, un cluster provisionné avec de nombreux PV 50Gi ne correspondrait pas à un PVC demandant 100Gi.
Le PVC peut être lié lorsqu'un PV 100Gi est ajouté au cluster.</p><h3 id=utilisation>Utilisation</h3><p>Les Pods utilisent les PVC comme des volumes.
Le cluster inspecte le PVC pour trouver le volume lié et monte ce volume pour un Pod.
Pour les volumes qui prennent en charge plusieurs modes d'accès, l'utilisateur spécifie le mode souhaité lors de l'utilisation de leur PVC comme volume dans un Pod.</p><p>Une fois qu'un utilisateur a un PVC et que ce PVC est lié, le PV lié appartient à l'utilisateur aussi longtemps qu'il en a besoin.
Les utilisateurs planifient des pods et accèdent à leurs PV revendiqués en incluant un <code>persistentVolumeClaim</code> dans le bloc de volumes de leur Pod <a href=#claims-as-volumes>Voir ci-dessous pour les détails de la syntaxe</a>.</p><h3 id=protection-de-l-objet-de-stockage-en-cours-d-utilisation>Protection de l'objet de stockage en cours d'utilisation</h3><p>Le but de la fonction de protection des objets de stockage utilisés est de garantir que les revendications de volume persistantes (PVC) en cours d'utilisation par un Pod et les volumes persistants (PV) liés aux PVC ne sont pas supprimées du système, car cela peut entraîner des pertes de données.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le PVC est utilisé activement par un pod lorsqu'il existe un objet Pod qui utilise le PVC.</div><p>Si un utilisateur supprime un PVC en cours d'utilisation par un pod, le PVC n'est pas supprimé immédiatement.
L'élimination du PVC est différée jusqu'à ce que le PVC ne soit plus activement utilisé par les pods.
De plus, si un administrateur supprime un PV lié à un PVC, le PV n'est pas supprimé immédiatement.
L'élimination du PV est différée jusqu'à ce que le PV ne soit plus lié à un PVC.</p><p>Vous pouvez voir qu'un PVC est protégé lorsque son état est <code>Terminating</code> et la liste <code>Finalizers</code> inclus <code>kubernetes.io/pvc-protection</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl describe pvc hostpath
</span></span><span style=display:flex><span>Name:          hostpath
</span></span><span style=display:flex><span>Namespace:     default
</span></span><span style=display:flex><span>StorageClass:  example-hostpath
</span></span><span style=display:flex><span>Status:        Terminating
</span></span><span style=display:flex><span>Volume:
</span></span><span style=display:flex><span>Labels:        &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:   volume.beta.kubernetes.io/storage-class=example-hostpath
</span></span><span style=display:flex><span>               volume.beta.kubernetes.io/storage-provisioner=example.com/hostpath
</span></span><span style=display:flex><span>Finalizers:    [kubernetes.io/pvc-protection]
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Vous pouvez voir qu'un PV est protégé lorsque son état est <code>Terminating</code> et la liste <code>Finalizers</code> inclus <code>kubernetes.io/pv-protection</code> aussi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl describe pv task-pv-volume
</span></span><span style=display:flex><span>Name:            task-pv-volume
</span></span><span style=display:flex><span>Labels:          type=local
</span></span><span style=display:flex><span>Annotations:     &lt;none&gt;
</span></span><span style=display:flex><span>Finalizers:      [kubernetes.io/pv-protection]
</span></span><span style=display:flex><span>StorageClass:    standard
</span></span><span style=display:flex><span>Status:          Available
</span></span><span style=display:flex><span>Claim:
</span></span><span style=display:flex><span>Reclaim Policy:  Delete
</span></span><span style=display:flex><span>Access Modes:    RWO
</span></span><span style=display:flex><span>Capacity:        1Gi
</span></span><span style=display:flex><span>Message:
</span></span><span style=display:flex><span>Source:
</span></span><span style=display:flex><span>    Type:          HostPath (bare host directory volume)
</span></span><span style=display:flex><span>    Path:          /tmp/data
</span></span><span style=display:flex><span>    HostPathType:
</span></span><span style=display:flex><span>Events:            &lt;none&gt;
</span></span></code></pre></div><h3 id=récupération-des-volumes>Récupération des volumes</h3><p>Lorsqu'un utilisateur a terminé avec son volume, il peut supprimer les objets PVC de l'API qui permet la récupération de la ressource.
La politique de récupération pour un <code>PersistentVolume</code> indique au cluster ce qu'il doit faire du volume une fois qu'il a été libéré de son PVC.
Actuellement, les volumes peuvent être conservés, recyclés ou supprimés.</p><h4 id=volumes-conservés>Volumes conservés</h4><p>La politique de récupération <code>Retain</code> permet la récupération manuelle de la ressource.
Lorsque le <code>PersistentVolumeClaim</code> est supprimé, le <code>PersistentVolume</code> existe toujours et le volume est considéré comme «libéré».
Mais il n'est pas encore disponible pour une autre demande car les données du demandeur précédent restent sur le volume.
Un administrateur peut récupérer manuellement le volume en procédant comme suit.</p><ol><li>Supprimer le <code>PersistentVolume</code>.
L'actif de stockage associé dans une infrastructure externe (comme un volume AWS EBS, GCE PD, Azure Disk ou Cinder) existe toujours après la suppression du PV.</li><li>Nettoyez manuellement les données sur l'actif de stockage associé en conséquence.</li><li>Supprimez manuellement l'actif de stockage associé ou, si vous souhaitez réutiliser le même actif de stockage, créez un nouveau <code>PersistentVolume</code> avec la définition de l'actif de stockage.</li></ol><h4 id=volumes-supprimés>Volumes supprimés</h4><p>Pour les plug-ins de volume qui prennent en charge la stratégie de récupération <code>Delete</code>, la suppression supprime à la fois l'objet <code>PersistentVolume</code> de Kubernetes, ainsi que l'actif de stockage associé dans l'infrastructure externe, tel qu'un volume AWS EBS, GCE PD, Azure Disk ou Cinder.
Les volumes qui ont été dynamiquement provisionnés héritent de la <a href=#politique-de-r%C3%A9cup%C3%A9ration>politique de récupération de leur <code>StorageClass</code></a>, qui par défaut est <code>Delete</code>.
L'administrateur doit configurer la <code>StorageClass</code> selon les attentes des utilisateurs; sinon, le PV doit être édité ou corrigé après sa création.
Voir <a href=/docs/tasks/administer-cluster/change-pv-reclaim-policy/>Modifier la politique de récupération d'un PersistentVolume</a>.</p><h4 id=volumes-recyclés>Volumes recyclés</h4><div class="alert alert-danger warning callout" role=alert><strong>Attention:</strong> La politique de récupération <code>Recycle</code> est obsolète.
Au lieu de cela, l'approche recommandée consiste à utiliser l'approvisionnement dynamique.</div><p>Si elle est prise en charge par le plug-in de volume sous-jacent, la stratégie de récupération <code>Recycle</code> effectue un nettoyage de base (<code>rm -rf /thevolume/*</code>) sur le volume et le rend à nouveau disponible pour une nouvelle demande.</p><p>Cependant, un administrateur peut configurer un modèle de module de recyclage personnalisé à l'aide des arguments de ligne de commande du gestionnaire de contrôleur Kubernetes, comme décrit <a href=/docs/admin/kube-controller-manager/>ici</a>.
Le modèle de pod de recycleur personnalisé doit contenir une définition de <code>volumes</code>, comme le montre l'exemple ci-dessous:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/any/path/it/will/be/replaced<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/scrub<span style=color:#bbb>
</span></span></span></code></pre></div><p>Cependant, le chemin particulier spécifié dans la partie <code>volumes</code> du template personnalisé de Pod est remplacée par le chemin particulier du volume qui est recyclé.</p><h3 id=redimensionnement-des-pvc>Redimensionnement des PVC</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>La prise en charge du redimensionnement des PersistentVolumeClaims (PVCs) est désormais activée par défaut.
Vous pouvez redimensionner les types de volumes suivants:</p><ul><li>gcePersistentDisk</li><li>awsElasticBlockStore</li><li>Cinder</li><li>glusterfs</li><li>rbd</li><li>Azure File</li><li>Azure Disk</li><li>Portworx</li><li>FlexVolumes</li><li>CSI</li></ul><p>Vous ne pouvez redimensionner un PVC que si le champ <code>allowVolumeExpansion</code> de sa classe de stockage est défini sur true.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Pour demander un volume plus important pour un PVC, modifiez l'objet PVC et spécifiez une taille plus grande.
Cela déclenche l'expansion du volume qui soutient le <code>PersistentVolume</code> sous-jacent.
Un nouveau <code>PersistentVolume</code> n'est jamais créé pour satisfaire la demande.
Au lieu de cela, un volume existant est redimensionné.</p><h4 id=redimensionnement-de-volume-csi>Redimensionnement de volume CSI</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [stable]</code></div><p>La prise en charge du redimensionnement des volumes CSI est activée par défaut, mais elle nécessite également un pilote CSI spécifique pour prendre en charge le redimensionnement des volumes.
Reportez-vous à la documentation du pilote CSI spécifique pour plus d'informations.</p><h4 id=redimensionner-un-volume-contenant-un-système-de-fichiers>Redimensionner un volume contenant un système de fichiers</h4><p>Vous ne pouvez redimensionner des volumes contenant un système de fichiers que si le système de fichiers est XFS, Ext3 ou Ext4.</p><p>Lorsqu'un volume contient un système de fichiers, le système de fichiers n'est redimensionné que lorsqu'un nouveau pod utilise le <code>PersistentVolumeClaim</code> en mode ReadWrite.
L'extension du système de fichiers est effectuée au démarrage d'un pod ou lorsqu'un pod est en cours d'exécution et que le système de fichiers sous-jacent prend en charge le redimensionnement en ligne.</p><p>FlexVolumes autorise le redimensionnement si le pilote est défini avec la capacité <code>requiresFSResize</code> sur <code>true</code>.
Le FlexVolume peut être redimensionné au redémarrage du pod.</p><h4 id=redimensionnement-d-un-persistentvolumeclaim-en-cours-d-utilisation>Redimensionnement d'un PersistentVolumeClaim en cours d'utilisation</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Redimensionner un PVCs à chaud est disponible en version bêta depuis Kubernetes 1.15 et en version alpha depuis 1.11.
La fonctionnalité <code>ExpandInUsePersistentVolumes</code> doit être activée, ce qui est le cas automatiquement pour de nombreux clusters de fonctionnalités bêta.
Se référer à la documentation de la <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> pour plus d'informations.</div><p>Dans ce cas, vous n'avez pas besoin de supprimer et de recréer un pod ou un déploiement qui utilise un PVC existant.
Tout PVC en cours d'utilisation devient automatiquement disponible pour son pod dès que son système de fichiers a été étendu.
Cette fonctionnalité n'a aucun effet sur les PVC qui ne sont pas utilisés par un pod ou un déploiement.
Vous devez créer un pod qui utilise le PVC avant que l'extension puisse se terminer.</p><p>Semblable à d'autres types de volume - les volumes FlexVolume peuvent également être étendus lorsqu'ils sont utilisés par un pod.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le redimensionnement de FlexVolume n'est possible que lorsque le pilote sous-jacent prend en charge le redimensionnement.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> L'augmentation des volumes EBS est une opération longue.
En outre, il existe un quota par volume d'une modification toutes les 6 heures.</div><h2 id=types-de-volumes-persistants>Types de volumes persistants</h2><p>Les types <code>PersistentVolume</code> sont implémentés en tant que plugins.
Kubernetes prend actuellement en charge les plugins suivants:</p><ul><li>GCEPersistentDisk</li><li>AWSElasticBlockStore</li><li>AzureFile</li><li>AzureDisk</li><li>CSI</li><li>FC (Fibre Channel)</li><li>FlexVolume</li><li>Flocker</li><li>NFS</li><li>iSCSI</li><li>RBD (Ceph Block Device)</li><li>CephFS</li><li>Cinder (OpenStack block storage)</li><li>Glusterfs</li><li>VsphereVolume</li><li>Quobyte Volumes</li><li>HostPath (Test de nœud unique uniquement -- le stockage local n'est en aucun cas pris en charge et NE FONCTIONNERA PAS dans un cluster à plusieurs nœuds)</li><li>Portworx Volumes</li><li>ScaleIO Volumes</li><li>StorageOS</li></ul><h2 id=volumes-persistants>Volumes persistants</h2><p>Chaque PV contient une spécification et un état, qui sont les spécifications et l'état du volume.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0003<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Recycle<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- hard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- nfsvers=4.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nfs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/tmp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.2</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Des logiciels additionnels supportant un type de montage de volume pourraient être nécessaires afin d'utiliser un PersistentVolume depuis un cluster.
Dans l'exemple d'un PersistentVolume de type NFS, le logiciel additionnel <code>/sbin/mount.nfs</code> est requis pour permettre de monter des systèmes de fichiers de type NFS.</div><h3 id=capacité>Capacité</h3><p>Généralement, un PV aura une capacité de stockage spécifique.
Ceci est réglé en utilisant l'attribut <code>capacity</code> des PV.
Voir le Kubernetes <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>modèle de ressource</a> pour comprendre les unités attendues par <code>capacity</code>.</p><p>Actuellement, la taille du stockage est la seule ressource qui peut être définie ou demandée.
Les futurs attributs peuvent inclure les IOPS, le débit, etc.</p><h3 id=mode-volume>Mode volume</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code></div><p>Avant Kubernetes 1.9, tous les plug-ins de volume créaient un système de fichiers sur le volume persistant.
Maintenant, vous pouvez définir la valeur de <code>volumeMode</code> sur <code>block</code> pour utiliser un périphérique de bloc brut, ou <code>filesystem</code> pour utiliser un système de fichiers.
<code>filesystem</code> est la valeur par défaut si la valeur est omise.
Il s'agit d'un paramètre API facultatif.</p><h3 id=modes-d-accès>Modes d'accès</h3><p>Un <code>PersistentVolume</code> peut être monté sur un hôte de n'importe quelle manière prise en charge par le fournisseur de ressources.
Comme indiqué dans le tableau ci-dessous, les fournisseurs auront des capacités différentes et les modes d'accès de chaque PV sont définis sur les modes spécifiques pris en charge par ce volume particulier.
Par exemple, NFS peut prendre en charge plusieurs clients en lecture/écriture, mais un PV NFS spécifique peut être exporté sur le serveur en lecture seule.
Chaque PV dispose de son propre ensemble de modes d'accès décrivant les capacités spécifiques de ce PV.</p><p>Les modes d'accès sont:</p><ul><li>ReadWriteOnce -- le volume peut être monté en lecture-écriture par un seul nœud</li><li>ReadOnlyMany -- le volume peut être monté en lecture seule par plusieurs nœuds</li><li>ReadWriteMany -- le volume peut être monté en lecture-écriture par de nombreux nœuds</li></ul><p>Dans la CLI, les modes d'accès sont abrégés comme suit:</p><ul><li>RWO - ReadWriteOnce</li><li>ROX - ReadOnlyMany</li><li>RWX - ReadWriteMany</li></ul><blockquote><p><strong>Important!</strong> Un volume ne peut être monté qu'en utilisant un seul mode d'accès à la fois, même s'il prend en charge plusieurs.
Par exemple, un GCEPersistentDisk peut être monté en tant que ReadWriteOnce par un seul nœud ou ReadOnlyMany par plusieurs nœuds, mais pas en même temps.</p></blockquote><table><thead><tr><th style=text-align:center>Volume Plugin</th><th style=text-align:center>ReadWriteOnce</th><th style=text-align:center>ReadOnlyMany</th><th style=text-align:center>ReadWriteMany</th></tr></thead><tbody><tr><td style=text-align:center>AWSElasticBlockStore</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>AzureFile</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:center>AzureDisk</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>CephFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:center>Cinder</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>CSI</td><td style=text-align:center>dépend du pilote</td><td style=text-align:center>dépend du pilote</td><td style=text-align:center>dépend du pilote</td></tr><tr><td style=text-align:center>FC</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>FlexVolume</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>dépend du pilote</td></tr><tr><td style=text-align:center>Flocker</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>GCEPersistentDisk</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>Glusterfs</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:center>HostPath</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>iSCSI</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>Quobyte</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:center>NFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:center>RBD</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>VsphereVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>- (fonctionne lorsque les pods sont colocalisés)</td></tr><tr><td style=text-align:center>PortworxVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:center>ScaleIO</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>StorageOS</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr></tbody></table><h3 id=classe>Classe</h3><p>Un PV peut avoir une classe, qui est spécifiée en définissant l'attribut <code>storageClassName</code> sur le nom d'une <a href=/docs/concepts/storage/storage-classes/>StorageClass</a>.
Un PV d'une classe particulière ne peut être lié qu'à des PVC demandant cette classe.
Un PV sans <code>storageClassName</code> n'a pas de classe et ne peut être lié qu'à des PVC qui ne demandent aucune classe particulière.</p><p>Dans le passé, l'annotation <code>volume.beta.kubernetes.io/storage-class</code> a été utilisé à la place de l'attribut <code>storageClassName</code>.
Cette annotation fonctionne toujours; cependant, il deviendra complètement obsolète dans une future version de Kubernetes.</p><h3 id=politique-de-récupération>Politique de récupération</h3><p>Les politiques de récupération actuelles sont:</p><ul><li>Retain -- remise en état manuelle</li><li>Recycle -- effacement de base (<code>rm -rf /thevolume/*</code>)</li><li>Delete -- l'élément de stockage associé tel qu'AWS EBS, GCE PD, Azure Disk ou le volume OpenStack Cinder est supprimé</li></ul><p>Actuellement, seuls NFS et HostPath prennent en charge le recyclage.
Les volumes AWS EBS, GCE PD, Azure Disk et Cinder prennent en charge la suppression.</p><h3 id=options-de-montage>Options de montage</h3><p>Un administrateur Kubernetes peut spécifier des options de montage supplémentaires pour quand un <code>PersistentVolume</code> est monté sur un nœud.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Tous les types de volumes persistants ne prennent pas en charge les options de montage.</div><p>Les types de volume suivants prennent en charge les options de montage:</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>AzureFile</li><li>CephFS</li><li>Cinder (OpenStack block storage)</li><li>GCEPersistentDisk</li><li>Glusterfs</li><li>NFS</li><li>Quobyte Volumes</li><li>RBD (Ceph Block Device)</li><li>StorageOS</li><li>VsphereVolume</li><li>iSCSI</li></ul><p>Les options de montage ne sont pas validées, donc le montage échouera simplement si l'une n'est pas valide.</p><p>Dans le passé, l'annotation <code>volume.beta.kubernetes.io/mount-options</code> était utilisée à la place de l'attribut <code>mountOptions</code>.
Cette annotation fonctionne toujours; cependant, elle deviendra complètement obsolète dans une future version de Kubernetes.</p><h3 id=affinité-des-nœuds>Affinité des nœuds</h3><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Pour la plupart des types de volume, vous n'avez pas besoin de définir ce champ.
Il est automatiquement rempli pour les volumes bloc de type <a href=/docs/concepts/storage/volumes/#awselasticblockstore>AWS EBS</a>, <a href=/docs/concepts/storage/volumes/#gcepersistentdisk>GCE PD</a> et <a href=/docs/concepts/storage/volumes/#azuredisk>Azure Disk</a>.
Vous devez définir explicitement ceci pour les volumes <a href=/docs/concepts/storage/volumes/#local>locaux</a>.</div><p>Un PV peut spécifier une <a href=/docs/reference/generated/kubernetes-api/v1.25/#volumenodeaffinity-v1-core>affinité de nœud</a> pour définir les contraintes qui limitent les nœuds à partir desquels ce volume est accessible.
Les pods qui utilisent un PV seront uniquement planifiés sur les nœuds sélectionnés par l'affinité de nœud.</p><h3 id=phase>Phase</h3><p>Un volume sera dans l'une des phases suivantes:</p><ul><li>Available -- une ressource libre qui n'est pas encore liée à une demande</li><li>Bound -- le volume est lié à une demande</li><li>Released -- la demande a été supprimée, mais la ressource n'est pas encore récupérée par le cluster</li><li>Failed -- le volume n'a pas réussi sa récupération automatique</li></ul><p>Le CLI affichera le nom du PVC lié au PV.</p><h2 id=persistentvolumeclaims>PersistentVolumeClaims</h2><p>Chaque PVC contient une spécification et un état, qui sont les spécifications et l'état de la réclamation.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>8Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>release</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: environment, operator: In, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=modes-d-accès-1>Modes d'accès</h3><p>Les PVC utilisent les mêmes conventions que les volumes lorsque vous demandez un stockage avec des modes d'accès spécifiques.</p><h3 id=modes-de-volume>Modes de volume</h3><p>Les PVC utilisent la même convention que les volumes pour indiquer la consommation du volume en tant que système de fichiers ou périphérique de bloc.</p><h3 id=ressources>Ressources</h3><p>Les PVC, comme les pods, peuvent demander des quantités spécifiques d'une ressource.
Dans ce cas, la demande concerne le stockage.
Le même <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>modèle de ressource</a> s'applique aux volumes et aux PVC.</p><h3 id=sélecteur>Sélecteur</h3><p>Les PVC peuvent spécifier un <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>sélecteur de labels</a> pour filtrer davantage l'ensemble des volumes.
Seuls les volumes dont les étiquettes correspondent au sélecteur peuvent être liés au PVC.
Le sélecteur peut comprendre deux champs:</p><ul><li><code>matchLabels</code> - le volume doit avoir un label avec cette valeur</li><li><code>matchExpressions</code> - une liste des exigences définies en spécifiant la clé, la liste des valeurs et l'opérateur qui relie la clé et les valeurs.
Les opérateurs valides incluent In, NotIn, Exists et DoesNotExist.</li></ul><p>Toutes les exigences, à la fois de <code>matchLabels</code> et de <code>matchExpressions</code> doivent toutes être satisfaites pour correspondre (application d'un opérateur booléen ET).</p><h3 id=classe-1>Classe</h3><p>Un PVC peut demander une classe particulière en spécifiant le nom d'une <a href=/docs/concepts/storage/storage-classes/>StorageClass</a> en utilisant l'attribut <code>storageClassName</code>.
Seuls les PV de la classe demandée, ceux ayant le même <code>storageClassName</code> que le PVC, peuvent être liés au PVC.</p><p>Les PVC n'ont pas nécessairement à demander une classe.
Un PVC avec son attribut <code>storageClassName</code> égal à <code>""</code> est toujours interprété comme demandant un PV sans classe, il ne peut donc être lié qu'à des PV sans classe (pas d'annotation ou une annotation égal à <code>""</code>).
Un PVC sans <code>storageClassName</code> n'est pas tout à fait la même et est traité différemment par le cluster, selon que le <a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code> admission plugin</a> est activé.</p><ul><li>Si le plug-in d'admission est activé, l'administrateur peut spécifier une valeur par défaut <code>StorageClass</code>.
Tous les PVC qui n'ont pas de <code>storageClassName</code> ne peuvent être liés qu'aux PV de cette valeur par défaut.
La spécification d'une <code>StorageClass</code> par défaut se fait en définissant l'annotation <code>storageclass.kubernetes.io/is-default-class</code> égal à <code>true</code> dans un objet <code>StorageClass</code>.
Si l'administrateur ne spécifie pas de valeur par défaut, le cluster répond à la création de PVC comme si le plug-in d'admission était désactivé.
Si plusieurs valeurs par défaut sont spécifiées, le plugin d'admission interdit la création de tous les PVC.</li><li>Si le plugin d'admission est désactivé, il n'y a aucune notion de défaut <code>StorageClass</code>.
Tous les PVC qui n'ont pas <code>storageClassName</code> peut être lié uniquement aux PV qui n'ont pas de classe.
Dans ce cas, les PVC qui n'ont pas <code>storageClassName</code> sont traités de la même manière que les PVC qui ont leur <code>storageClassName</code> égal à <code>""</code>.</li></ul><p>Selon la méthode d'installation, une <code>StorageClass</code> par défaut peut être déployée sur un cluster Kubernetes par le gestionnaire d'extensions pendant l'installation.</p><p>Lorsqu'un PVC spécifie un <code>selector</code> en plus de demander une <code>StorageClass</code>, les exigences sont ET ensemble: seul un PV de la classe demandée et avec les labels demandées peut être lié au PVC.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Actuellement, un PVC avec un <code>selector</code> non vide ne peut pas avoir un PV provisionné dynamiquement pour cela.</div><p>Dans le passé, l'annotation <code>volume.beta.kubernetes.io/storage-class</code> a été utilisé au lieu de l'attribut <code>storageClassName</code>.
Cette annotation fonctionne toujours; cependant, elle ne sera pas pris en charge dans une future version de Kubernetes.</p><h2 id=pvc-sous-forme-de-volumes>PVC sous forme de volumes</h2><p>Les pods accèdent au stockage en utilisant le PVC comme volume.
Les PVC et les pods qui les utilisent doivent exister dans le même namespace.
Le cluster trouve le PVC dans le namespace où se trouve le pod et l'utilise pour obtenir le <code>PersistentVolume</code> visé par le PVC.
Le volume est ensuite monté sur l'hôte et dans le pod.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=remarque-au-sujet-des-namespaces>Remarque au sujet des namespaces</h3><p>Les liaisons <code>PersistentVolumes</code> sont exclusives, et comme les objets <code>PersistentVolumeClaims</code> sont des objets vivant dans un namespace donné, le montage de PVC avec les modes "Many" (<code>ROX</code>, <code>RWX</code>) n'est possible qu'au sein d'un même namespace.</p><h2 id=prise-en-charge-du-volume-de-bloc-brut>Prise en charge du volume de bloc brut</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code></div><p>Les plug-ins de volume suivants prennent en charge les volumes de blocs bruts, y compris l'approvisionnement dynamique, le cas échéant:</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>FC (Fibre Channel)</li><li>GCEPersistentDisk</li><li>iSCSI</li><li>Local volume</li><li>RBD (Ceph Block Device)</li><li>VsphereVolume (alpha)</li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Seuls les volumes FC et iSCSI prennent en charge les volumes de blocs bruts dans Kubernetes 1.9.
La prise en charge des plugins supplémentaires a été ajoutée dans 1.10.</div><h3 id=volumes-persistants-utilisant-un-volume-de-bloc-brut>Volumes persistants utilisant un volume de bloc brut</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fc</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetWWNs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;50060e801049cfd1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lun</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=revendication-de-volume-persistant-demandant-un-volume-de-bloc-brut>Revendication de volume persistant demandant un volume de bloc brut</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=spécification-de-pod-ajoutant-le-chemin-du-périphérique-de-bloc-brut-dans-le-conteneur>Spécification de pod ajoutant le chemin du périphérique de bloc brut dans le conteneur</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-block-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fc-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:26<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;tail -f /dev/null&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeDevices</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>devicePath</span>:<span style=color:#bbb> </span>/dev/xvda<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Lorsque vous ajoutez un périphérique de bloc brut pour un pod, vous spécifiez le chemin de périphérique dans le conteneur au lieu d'un chemin de montage.</div><h3 id=lier-des-volumes-bloc-bruts>Lier des volumes bloc bruts</h3><p>Si un utilisateur demande un volume de bloc brut en l'indiquant à l'aide du champ <code>volumeMode</code> dans la spécification <code>PersistentVolumeClaim</code>, les règles de liaison diffèrent légèrement des versions précédentes qui ne considéraient pas ce mode comme faisant partie de la spécification.
Voici un tableau des combinaisons possibles que l'utilisateur et l'administrateur peuvent spécifier pour demander un périphérique de bloc brut.
Le tableau indique si le volume sera lié ou non compte tenu des combinaisons:
Matrice de liaison de volume pour les volumes provisionnés statiquement:</p><p>| PV volumeMode | PVC volumeMode | Result |
|---------------|-:-:------------|--:------|
| unspecified | unspecified | BIND |
| unspecified | Block | NO BIND |
| unspecified | Filesystem | BIND |
| Block | unspecified | NO BIND |
| Block | Block | BIND |
| Block | Filesystem | NO BIND |
| Filesystem | Filesystem | BIND |
| Filesystem | Block | NO BIND |
| Filesystem | unspecified | BIND |</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Seuls les volumes provisionnés statiquement sont pris en charge pour la version alpha.
Les administrateurs doivent prendre en compte ces valeurs lorsqu'ils travaillent avec des périphériques de bloc brut.</div><h2 id=snapshot-et-restauration-de-volumes>Snapshot et restauration de volumes</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>La fonction de snapshot de volume a été ajoutée pour prendre en charge uniquement les plug-ins de volume CSI.
Pour plus de détails, voir <a href=/docs/concepts/storage/volume-snapshots/>volume snapshots</a>.</p><p>Pour activer la prise en charge de la restauration d'un volume à partir d'un snapshot de volume, activez la fonctionnalité <code>VolumeSnapshotDataSource</code> sur l'apiserver et le controller-manager.</p><h3 id=créer-du-pvc-à-partir-d-un-snapshot-de-volume>Créer du PVC à partir d'un snapshot de volume</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restore-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>csi-hostpath-sc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=clonage-de-volume>Clonage de volume</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code></div><p>La fonctionnalité de clonage de volume a été ajoutée pour prendre en charge uniquement les plug-ins de volume CSI.
Pour plus de détails, voir <a href=/docs/concepts/storage/volume-pvc-datasource/>clonage de volume</a>.</p><p>Pour activer la prise en charge du clonage d'un volume à partir d'une source de données PVC, activez la propriété <code>VolumePVCDataSource</code> sur l'apiserver et le controller-manager.</p><h3 id=créer-un-pvc-à-partir-d-un-pvc-existant>Créer un PVC à partir d'un PVC existant</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloned-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>my-csi-plugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>existing-src-pvc-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=écriture-d-une-configuration-portable>Écriture d'une configuration portable</h2><p>Si vous écrivez des templates de configuration ou des exemples qui s'exécutent sur une large gamme de clusters et nécessitent un stockage persistant, il est recommandé d'utiliser le modèle suivant:</p><ul><li>Incluez des objets <code>PersistentVolumeClaim</code> dans votre ensemble de config (aux côtés de <code>Deployments</code>, <code>ConfigMaps</code>, etc.).</li><li>N'incluez pas d'objets <code>PersistentVolume</code> dans la configuration, car l'utilisateur qui instancie la configuration peut ne pas être autorisé à créer des <code>PersistentVolumes</code>.</li><li>Donnez à l'utilisateur la possibilité de fournir un nom de classe de stockage lors de l'instanciation du template.<ul><li>Si l'utilisateur fournit un nom de classe de stockage, mettez cette valeur dans le champ <code>persistentVolumeClaim.storageClassName</code>.
Cela entraînera le PVC pour utiliser la bonne classe de stockage si le cluster a cette <code>StorageClasses</code> activé par l'administrateur.</li><li>Si l'utilisateur ne fournit pas de nom de classe de stockage, laissez le champ <code>persistentVolumeClaim.storageClassName</code> à zéro.
Cela entraînera un PV à être automatiquement provisionné pour l'utilisateur avec la <code>StorageClass</code> par défaut dans le cluster.
De nombreux environnements de cluster ont une <code>StorageClass</code> par défaut installée, où les administrateurs peuvent créer leur propre <code>StorageClass</code> par défaut.</li></ul></li><li>Dans votre outillage, surveillez les PVCs qui ne sont pas liés après un certain temps et signalez-le à l'utilisateur, car cela peut indiquer que le cluster n'a pas de support de stockage dynamique (auquel cas l'utilisateur doit créer un PV correspondant) ou que le cluster n'a aucun système de stockage (auquel cas l'utilisateur ne peut pas déployer de configuration nécessitant des PVCs).</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-275bea454e1cf4c5adeca4058b5af988>7 - Configuration</h1></div><div class=td-content><h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>7.1 - Secrets</h1><p>Les objets <code>secret</code> de Kubernetes vous permettent de stocker et de gérer des informations sensibles, telles que les mots de passe, les jetons OAuth et les clés ssh.
Mettre ces informations dans un <code>secret</code> est plus sûr et plus flexible que de le mettre en dur dans la définition d'un <a class=glossary-tooltip title='Le plus petit et le plus simple des objets Kubernetes. Un Pod est un ensemble de conteneurs fonctionnant sur votre cluster.' data-toggle=tooltip data-placement=top href=/fr/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> ou dans une <a class=glossary-tooltip title="Instance stockée d'un conteneur qui contient un ensemble de logiciels nécessaires à l'exécution d'une application." data-toggle=tooltip data-placement=top href='/fr/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='container image'>container image</a>.
Voir <a href=https://github.com/kubernetes/design-proposals-archive/blob/main/auth/secrets.md>Document de conception des secrets</a> pour plus d'informations.</p><h2 id=présentation-des-secrets>Présentation des secrets</h2><p>Un secret est un objet qui contient une petite quantité de données sensibles telles qu'un mot de passe, un jeton ou une clé.
De telles informations pourraient autrement être placées dans une spécification de pod ou dans une image; le placer dans un objet secret permet de mieux contrôler la façon dont il est utilisé et réduit le risque d'exposition accidentelle.</p><p>Les utilisateurs peuvent créer des secrets et le système crée également des secrets.</p><p>Pour utiliser un secret, un pod doit référencer le secret.
Un secret peut être utilisé avec un pod de deux manières: sous forme de fichiers dans un <a class=glossary-tooltip title="Un répertoire contenant des données, accessible aux conteneurs d'un pod." data-toggle=tooltip data-placement=top href=/fr/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a> monté sur un ou plusieurs de ses conteneurs, ou utilisé par kubelet lorsque vous récupérez des images pour le pod.</p><h3 id=secrets-intégrés>Secrets intégrés</h3><h4 id=les-comptes-de-service-créent-et-attachent-automatiquement-des-secrets-avec-les-informations-d-identification-de-l-api>Les comptes de service créent et attachent automatiquement des secrets avec les informations d'identification de l'API</h4><p>Kubernetes crée automatiquement des secrets qui contiennent des informations d'identification pour accéder à l'API et il modifie automatiquement vos pods pour utiliser ce type de secret.</p><p>La création et l'utilisation automatiques des informations d'identification de l'API peuvent être désactivées ou remplacées si vous le souhaitez.
Cependant, si tout ce que vous avez à faire est d'accéder en toute sécurité à l'apiserver, il s'agit de la méthode recommandée.</p><p>Voir la documentation des <a href=/docs/tasks/configure-pod-container/configure-service-account/>Compte de service</a> pour plus d'informations sur le fonctionnement des comptes de service.</p><h3 id=créer-vos-propres-secrets>Créer vos propres secrets</h3><h4 id=créer-un-secret-avec-kubectl-create-secret>Créer un secret avec kubectl create secret</h4><p>Supposons que certains pods doivent accéder à une base de données.
Le nom d'utilisateur et le mot de passe que les pods doivent utiliser se trouvent dans les fichiers <code>./username.txt</code> et <code>./password.txt</code> sur votre machine locale.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Create files needed for rest of example.</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> &gt; ./username.txt
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> &gt; ./password.txt
</span></span></code></pre></div><p>La commande <code>kubectl create secret</code> regroupe ces fichiers dans un secret et crée l'objet sur l'Apiserver.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic db-user-pass --from-file<span style=color:#666>=</span>./username.txt --from-file<span style=color:#666>=</span>./password.txt
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>secret &#34;db-user-pass&#34; created
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Les caractères spéciaux tels que <code>$</code>, <code>\</code>, <code>*</code>, et <code>!</code> seront interprétés par votre <a href=https://en.wikipedia.org/wiki/Shell_(computing)>shell</a> et nécessitent d'être échappés.
Dans les shells les plus courants, le moyen le plus simple d'échapper au mot de passe est de l'entourer de guillemets simples (<code>'</code>).
Par exemple, si votre mot de passe réel est <code>S!B\*d$zDsb</code>, vous devez exécuter la commande de cette façon:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl create secret generic dev-db-secret --from-literal=username=devuser --from-literal=password=&#39;S!B\*d$zDsb&#39;
</span></span></code></pre></div><p>Vous n'avez pas besoin d'échapper les caractères spéciaux dans les mots de passe des fichiers (<code>--from-file</code>).</p></div><p>Vous pouvez vérifier que le secret a été créé comme ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                  TYPE                                  DATA      AGE
</span></span><span style=display:flex><span>db-user-pass          Opaque                                2         51s
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl describe secrets/db-user-pass
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:            db-user-pass
</span></span><span style=display:flex><span>Namespace:       default
</span></span><span style=display:flex><span>Labels:          &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:     &lt;none&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Type:            Opaque
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data
</span></span><span style=display:flex><span>====
</span></span><span style=display:flex><span>password.txt:    12 bytes
</span></span><span style=display:flex><span>username.txt:    5 bytes
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> <code>kubectl get</code> et <code>kubectl describe</code> évitent d'afficher le contenu d'un secret par défaut.
Il s'agit de protéger le secret contre une exposition accidentelle à un spectateur de l'écran ou contre son stockage dans un journal de terminal.</div><p>Voir <a href=#decoding-a-secret>décoder un secret</a> pour voir le contenu d'un secret.</p><h4 id=création-manuelle-d-un-secret>Création manuelle d'un secret</h4><p>Vous pouvez également créer un secret dans un fichier d'abord, au format json ou yaml, puis créer cet objet.
Le <a href=/docs/reference/generated/kubernetes-api/v1.25/#secret-v1-core>secret</a> contient deux table de hachage: <code>data</code> et <code>stringData</code>.
Le champ <code>data</code> est utilisé pour stocker des données arbitraires, encodées en base64.
Le champ <code>stringData</code> est fourni pour plus de commodité et vous permet de fournir des données secrètes sous forme de chaînes non codées.</p><p>Par exemple, pour stocker deux chaînes dans un secret à l'aide du champ <code>data</code>, convertissez-les en base64 comme suit:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> | base64
</span></span><span style=display:flex><span><span style=color:#b8860b>YWRtaW4</span><span style=color:#666>=</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> | base64
</span></span><span style=display:flex><span>MWYyZDFlMmU2N2Rm
</span></span></code></pre></div><p>Écrivez un secret qui ressemble à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><p>Maintenant, créez le secret en utilisant <a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl apply -f ./secret.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>secret &#34;mysecret&#34; created
</span></span></code></pre></div><p>Pour certains scénarios, vous pouvez utiliser le champ <code>stringData</code> à la place.
Ce champ vous permet de mettre une chaîne non codée en base64 directement dans le secret, et la chaîne sera codée pour vous lorsque le secret sera créé ou mis à jour.</p><p>Un exemple pratique de cela pourrait être le suivant: vous déployez une application qui utilise un secret pour stocker un fichier de configuration.
Vous souhaitez remplir des parties de ce fichier de configuration pendant votre processus de déploiement.</p><p>Si votre application utilise le fichier de configuration suivant:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiUrl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my.api.com/api/v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;password&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Vous pouvez stocker cela dans un secret en utilisant ce qui suit:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    apiUrl: &#34;https://my.api.com/api/v1&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    username: {{username}}
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    password: {{password}}</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>Votre outil de déploiement pourrait alors remplacer les variables de modèle <code>{{username}}</code> et <code>{{password}}</code> avant d'exécuter <code>kubectl apply</code>.</p><p><code>stringData</code> est un champ de commodité en écriture seule.
Il n'est jamais affiché lors de la récupération des secrets.
Par exemple, si vous exécutez la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl get secret mysecret -o yaml
</span></span></code></pre></div><p>La sortie sera similaire à:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:40:59Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7225&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>c280ad2e-e916-11e8-98f2-025000000001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IHt7dXNlcm5hbWV9fQpwYXNzd29yZDoge3twYXNzd29yZH19<span style=color:#bbb>
</span></span></span></code></pre></div><p>Si un champ est spécifié à la fois dans <code>data</code> et <code>stringData</code>, la valeur de <code>stringData</code> est utilisée.
Par exemple, la définition de secret suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>administrateur<span style=color:#bbb>
</span></span></span></code></pre></div><p>Donnera le secret suivant:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:46:46Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7579&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>91460ecb-e917-11e8-98f2-025000000001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW5pc3RyYXRldXI=<span style=color:#bbb>
</span></span></span></code></pre></div><p>Où <code>YWRtaW5pc3RyYXRldXI=</code> décode en <code>administrateur</code>.</p><p>Les clés de <code>data</code> et <code>stringData</code> doivent être composées de caractères alphanumériques, '-', '_' ou '.'.</p><p><strong>Encoding Note:</strong> Les valeurs JSON et YAML sérialisées des données secrètes sont codées sous forme de chaînes base64.
Les sauts de ligne ne sont pas valides dans ces chaînes et doivent être omis.
Lors de l'utilisation de l'utilitaire <code>base64</code> sur Darwin / macOS, les utilisateurs doivent éviter d'utiliser l'option <code>-b</code> pour diviser les longues lignes.
Inversement, les utilisateurs Linux <em>devraient</em> ajouter l'option <code>-w 0</code> aux commandes <code>base64</code> ou le pipeline <code>base64 | tr -d '\ n'</code> si l'option <code>-w</code> n'est pas disponible.</p><h4 id=création-d-un-secret-à-partir-du-générateur>Création d'un secret à partir du générateur</h4><p>Kubectl prend en charge <a href=/docs/tasks/manage-kubernetes-objects/kustomization/>la gestion des objets à l'aide de Kustomize</a> depuis 1.14.
Avec cette nouvelle fonctionnalité, vous pouvez également créer un secret à partir de générateurs, puis l'appliquer pour créer l'objet sur l'Apiserver.
Les générateurs doivent être spécifiés dans un <code>kustomization.yaml</code> à l'intérieur d'un répertoire.</p><p>Par exemple, pour générer un secret à partir des fichiers <code>./username.txt</code> et <code>./password.txt</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Create a kustomization.yaml file with SecretGenerator</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>secretGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: db-user-pass
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - username.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>  - password.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Appliquez le répertoire de personnalisation pour créer l'objet secret.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ kubectl apply -k .
</span></span><span style=display:flex><span>secret/db-user-pass-96mffmfh4k created
</span></span></code></pre></div><p>Vous pouvez vérifier que le secret a été créé comme ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ kubectl get secrets
</span></span><span style=display:flex><span>NAME                             TYPE                                  DATA      AGE
</span></span><span style=display:flex><span>db-user-pass-96mffmfh4k          Opaque                                2         51s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ kubectl describe secrets/db-user-pass-96mffmfh4k
</span></span><span style=display:flex><span>Name:            db-user-pass
</span></span><span style=display:flex><span>Namespace:       default
</span></span><span style=display:flex><span>Labels:          &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:     &lt;none&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Type:            Opaque
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data
</span></span><span style=display:flex><span>====
</span></span><span style=display:flex><span>password.txt:    12 bytes
</span></span><span style=display:flex><span>username.txt:    5 bytes
</span></span></code></pre></div><p>Par exemple, pour générer un secret à partir des littéraux <code>username=admin</code> et <code>password=secret</code>, vous pouvez spécifier le générateur de secret dans <code>kustomization.yaml</code> comme:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Create a kustomization.yaml file with SecretGenerator</span>
</span></span><span style=display:flex><span>$ cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>secretGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: db-user-pass
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - username=admin
</span></span></span><span style=display:flex><span><span style=color:#b44>  - password=secret
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Appliquer le repertoire kustomization pour créer l'objet secret.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ kubectl apply -k .
</span></span><span style=display:flex><span>secret/db-user-pass-dddghtt9b5 created
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le nom des secrets généré a un suffixe ajouté en hachant le contenu.
Cela garantit qu'un nouveau secret est généré chaque fois que le contenu est modifié.</div><h4 id=décoder-un-secret>Décoder un secret</h4><p>Les secrets peuvent être récupérés via la command <code>kubectl get secret</code>.
Par exemple, pour récupérer le secret créé dans la section précédente:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret mysecret -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-01-22T18:41:56Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;164619&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>cfee02d6-c137-11e5-8d73-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><p>Décodez le champ du mot de passe:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;MWYyZDFlMmU2N2Rm&#39;</span> | base64 --decode
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>1f2d1e2e67df
</span></span></code></pre></div><h4 id=modification-d-un-secret>Modification d'un secret</h4><p>Un secret existant peut être modifié avec la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl edit secrets mysecret
</span></span></code></pre></div><p>Cela ouvrira l'éditeur configuré par défaut et permettra de mettre à jour les valeurs secrètes codées en base64 dans le champ <code>data</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># Please edit the object below. Lines beginning with a &#39;#&#39; will be ignored,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># and an empty file will abort the edit. If an error occurs while saving this file will be</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># reopened with the relevant failures.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>{<span style=color:#bbb> </span>... }<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-01-22T18:41:56Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;164619&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>cfee02d6-c137-11e5-8d73-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=utiliser-les-secrets>Utiliser les secrets</h2><p>Les secrets peuvent être montés en tant que volumes de données ou être exposés en tant que <a class=glossary-tooltip title="Les variables d'environnement de conteneur sont des paires nom=valeur qui fournissent des informations utiles aux conteneurs fonctionnant au sein d'un Pod." data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment-variables/ target=_blank aria-label="variables d'environnement">variables d'environnement</a> à utiliser par un conteneur dans un Pod.
Ils peuvent également être utilisés par d'autres parties du système, sans être directement exposés aux Pods.
Par exemple, ils peuvent détenir des informations d'identification que d'autres parties du système doivent utiliser pour interagir avec des systèmes externes en votre nom.</p><h3 id=utilisation-de-secrets-comme-fichiers-d-un-pod>Utilisation de secrets comme fichiers d'un pod</h3><p>Pour consommer un secret dans un volume dans un pod:</p><ol><li>Créez un secret ou utilisez-en un déjà existant.
Plusieurs Pods peuvent référencer le même secret.</li><li>Modifiez la définition de votre Pod pour ajouter un volume sous <code>.spec.volumes[]</code>.
Nommez le volume et ayez un champ <code>.spec.volumes[].secret.secretName</code> égal au nom de l'objet secret.</li><li>Ajouter un <code>.spec.containers[].volumeMounts[]</code> à chaque conteneur qui a besoin du secret.
Spécifier <code>.spec.containers[].volumeMounts[].readOnly = true</code> et <code>.spec.containers[].volumeMounts[].mountPath</code> à un nom de répertoire inutilisé où vous souhaitez que les secrets apparaissent.</li><li>Modifiez votre image et/ou votre ligne de commande pour que le programme recherche les fichiers dans ce répertoire.
Chaque clé de la carte secrète <code>data</code> devient le nom de fichier sous <code>mountPath</code>.</li></ol><p>Voici un exemple de pod qui monte un secret dans un volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span></code></pre></div><p>Chaque secret que vous souhaitez utiliser doit être mentionné dans <code>.spec.volumes</code>.</p><p>S'il y a plusieurs conteneurs dans le pod, alors chaque conteneur a besoin de son propre bloc <code>volumeMounts</code>, mais un seul <code>.spec.volumes</code> est nécessaire par secret.</p><p>Vous pouvez regrouper de nombreux fichiers en un seul secret ou utiliser de nombreux secrets, selon le cas.</p><h3 id=projection-de-clés-secrètes-vers-des-chemins-spécifiques>Projection de clés secrètes vers des chemins spécifiques</h3><p>Nous pouvons également contrôler les chemins dans le volume où les clés secrètes sont projetées.
Vous pouvez utiliser le champ <code>.spec.volumes []. Secret.items</code> pour changer le chemin cible de chaque clé:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span></code></pre></div><p>Que se passera-t-il:</p><ul><li><code>username</code> est stocké dans le fichier <code>/etc/foo/my-group/my-username</code> au lieu de <code>/etc/foo/username</code>.</li><li><code>password</code> n'est pas projeté</li></ul><p>Si <code>.spec.volumes[].secret.items</code> est utilisé, seules les clés spécifiées dans <code>items</code> sont projetées.
Pour consommer toutes les clés du secret, toutes doivent être répertoriées dans le champ <code>items</code>.
Toutes les clés répertoriées doivent exister dans le secret correspondant.
Sinon, le volume n'est pas créé.</p><h3 id=autorisations-de-fichiers-secrets>Autorisations de fichiers secrets</h3><p>Vous pouvez également spécifier les bits de mode d'autorisation des fichiers contenant les parties d'un secret.
Si vous n'en spécifiez pas, <code>0644</code> est utilisé par défaut.
Vous pouvez spécifier un mode par défaut pour tout le volume secret et remplacer par clé si nécessaire.</p><p>Par exemple, vous pouvez spécifier un mode par défaut comme celui-ci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>256</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ensuite, le secret sera monté sur <code>/etc/foo</code> et tous les fichiers créés par le montage de volume secret auront la permission <code>0400</code>.</p><p>Notez que la spécification JSON ne prend pas en charge la notation octale, utilisez donc la valeur 256 pour les autorisations 0400.
Si vous utilisez yaml au lieu de json pour le pod, vous pouvez utiliser la notation octale pour spécifier les autorisations de manière plus naturelle.</p><p>Vous pouvez aussi utiliser un mapping, comme dans l'exemple précédent, et spécifier des autorisations différentes pour différents fichiers comme celui-ci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>511</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Dans ce cas, le fichier résultant <code>/etc/foo/my-group/my-username</code> aura la valeur d'autorisation de <code>0777</code>.
En raison des limitations JSON, vous devez spécifier le mode en notation décimale.</p><p>Notez que cette valeur d'autorisation peut être affichée en notation décimale si vous la lisez plus tard.</p><h3 id=consommer-des-valeurs-secrètes-à-partir-de-volumes>Consommer des valeurs secrètes à partir de volumes</h3><p>À l'intérieur du conteneur qui monte un volume secret, les clés secrètes apparaissent sous forme de fichiers et les valeurs secrètes sont décodées en base 64 et stockées à l'intérieur de ces fichiers.
C'est le résultat des commandes exécutées à l'intérieur du conteneur de l'exemple ci-dessus:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /etc/foo/
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>username
</span></span><span style=display:flex><span>password
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/username
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>admin
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/password
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>1f2d1e2e67df
</span></span></code></pre></div><p>Le programme dans un conteneur est responsable de la lecture des secrets des fichiers.</p><h3 id=les-secrets-montés-sont-mis-à-jour-automatiquement>Les secrets montés sont mis à jour automatiquement</h3><p>Lorsqu'un secret déjà consommé dans un volume est mis à jour, les clés projetées sont finalement mises à jour également.
Kubelet vérifie si le secret monté est récent à chaque synchronisation périodique.
Cependant, il utilise son cache local pour obtenir la valeur actuelle du Secret.
Le type de cache est configurable à l'aide de le champ <code>ConfigMapAndSecretChangeDetectionStrategy</code> dans la structure <a href=https://github.com/kubernetes/kubernetes/blob/main/staging/src/k8s.io/kubelet/config/v1beta1/types.go>KubeletConfiguration</a>.
Il peut être soit propagé via watch (par défaut), basé sur ttl, ou simplement redirigé toutes les requêtes vers directement kube-apiserver.
Par conséquent, le délai total entre le moment où le secret est mis à jour et le moment où de nouvelles clés sont projetées sur le pod peut être aussi long que la période de synchronisation du kubelet + le délai de propagation du cache, où le délai de propagation du cache dépend du type de cache choisi (cela équivaut au delai de propagation du watch, ttl du cache, ou bien zéro).</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Un conteneur utilisant un secret comme un volume <a href=/docs/concepts/storage/volumes#using-subpath>subPath</a> monté ne recevra pas de mises à jour secrètes.</div><h3 id=utilisation-de-secrets-comme-variables-d-environnement>Utilisation de secrets comme variables d'environnement</h3><p>Pour utiliser un secret dans une <a class=glossary-tooltip title="Les variables d'environnement de conteneur sont des paires nom=valeur qui fournissent des informations utiles aux conteneurs fonctionnant au sein d'un Pod." data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment-variables/ target=_blank aria-label="variable d'environnement">variable d'environnement</a> dans un pod:</p><ol><li>Créez un secret ou utilisez-en un déjà existant.
Plusieurs pods peuvent référencer le même secret.</li><li>Modifiez la définition de votre pod dans chaque conteneur où vous souhaitez utiliser la valeur d'une clé secrète pour ajouter une variable d'environnement pour chaque clé secrète que vous souhaitez consommer.
La variable d'environnement qui consomme la clé secrète doit remplir le nom et la clé du secret dans <code>env[].valueFrom.secretKeyRef</code>.</li><li>Modifiez votre image et/ou votre ligne de commande pour que le programme recherche des valeurs dans les variables d'environnement spécifiées</li></ol><p>Voici un exemple de pod qui utilise des secrets de variables d'environnement:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=consommation-de-valeurs-secrètes-à-partir-de-variables-d-environnement>Consommation de valeurs secrètes à partir de variables d'environnement</h3><p>À l'intérieur d'un conteneur qui consomme un secret dans des variables d'environnement, les clés secrètes apparaissent comme des variables d'environnement normales contenant les valeurs décodées en base64 des données secrètes.
C'est le résultat des commandes exécutées à l'intérieur du conteneur de l'exemple ci-dessus:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_USERNAME</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>admin
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_PASSWORD</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>1f2d1e2e67df
</span></span></code></pre></div><h3 id=utilisation-des-imagepullsecrets>Utilisation des imagePullSecrets</h3><p>Un <code>imagePullSecret</code> est un moyen de transmettre un secret qui contient un mot de passe de registre d'images Docker (ou autre) au Kubelet afin qu'il puisse extraire une image privée au nom de votre Pod.</p><h4 id=spécification-manuelle-d-une-imagepullsecret>Spécification manuelle d'une imagePullSecret</h4><p>L'utilisation de <code>imagePullSecrets</code> est décrite dans la <a href=/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>documentation des images</a></p><h3 id=arranging-for-imagepullsecrets-to-be-automatically-attached>Arranging for imagePullSecrets to be Automatically Attached</h3><p>Vous pouvez créer manuellement un <code>imagePullSecret</code> et le référencer à partir d'un <code>serviceAccount</code>.
Tous les pods créés avec ce <code>serviceAccount</code> ou cette valeur par défaut pour utiliser ce <code>serviceAccount</code>, verront leur champ <code>imagePullSecret</code> défini sur celui du compte de service.
Voir <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Ajouter ImagePullSecrets à un compte de service</a> pour une explication détaillée de ce processus.</p><h3 id=montage-automatique-de-secrets-créés-manuellement>Montage automatique de secrets créés manuellement</h3><p>Les secrets créés manuellement (par exemple, un contenant un jeton pour accéder à un compte github) peuvent être automatiquement associés aux pods en fonction de leur compte de service.
Voir <a href=/docs/tasks/inject-data-application/podpreset/>Injection d'informations dans des pods à l'aide d'un PodPreset</a> pour une explication détaillée de ce processus.</p><h2 id=details>Details</h2><h3 id=restrictions>Restrictions</h3><p>Les sources de volume secrètes sont validées pour garantir que la référence d'objet spécifiée pointe réellement vers un objet de type Secret.
Par conséquent, un secret doit être créé avant tous les pods qui en dépendent.</p><p>Les objets API secrets résident dans un <a class=glossary-tooltip title='An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Ils ne peuvent être référencés que par des pods dans le même espace de noms.</p><p>Les secrets individuels sont limités à 1 Mo de taille.
C'est pour décourager la création de très grands secrets qui épuiseraient la mémoire de l'apiserver et du kubelet.
Cependant, la création de nombreux petits secrets pourrait également épuiser la mémoire.
Des limites plus complètes sur l'utilisation de la mémoire en raison de secrets sont une fonctionnalité prévue.</p><p>Kubelet prend uniquement en charge l'utilisation des secrets pour les pods qu'il obtient du serveur API.
Cela inclut tous les pods créés à l'aide de kubectl, ou indirectement via un contrôleur de réplication.
Il n'inclut pas les pods créés via les drapeaux kubelet <code>--manifest-url</code>, ou <code>--config</code>, ou son API REST (ce ne sont pas des moyens courants de créer des Pods).</p><p>Les secrets doivent être créés avant d'être consommés dans les pods en tant que variables d'environnement, sauf s'ils sont marqués comme facultatifs.
Les références à des secrets qui n'existent pas empêcheront le pod de démarrer.</p><p>Les références via <code>secretKeyRef</code> à des clés qui n'existent pas dans un Secret nommé empêcheront le pod de démarrer.</p><p>Les secrets utilisés pour remplir les variables d'environnement via <code>envFrom</code> qui ont des clés considérées comme des noms de variables d'environnement non valides verront ces clés ignorées.
Le pod sera autorisé à démarrer.
Il y aura un événement dont la raison est <code>InvalidVariableNames</code> et le message contiendra la liste des clés invalides qui ont été ignorées.
L'exemple montre un pod qui fait référence au / mysecret par défaut qui contient 2 clés invalides, 1badkey et 2alsobad.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
</span></span><span style=display:flex><span>0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</span></span></code></pre></div><h3 id=cycle-de-vie-de-l-intéraction-secret-et-pod>Cycle de vie de l'intéraction Secret et Pod</h3><p>Lorsqu'un pod est créé via l'API, il n'est pas vérifié s'il existe un secret référencé.
Une fois qu'un pod est programmé, le kubelet tentera de récupérer la valeur secrète.
Si le secret ne peut pas être récupéré parce qu'il n'existe pas ou en raison d'un manque temporaire de connexion au serveur API, kubelet réessayera périodiquement.
Il rapportera un événement sur le pod expliquant la raison pour laquelle il n'a pas encore démarré.
Une fois le secret récupéré, le kubelet créera et montera un volume le contenant.
Aucun des conteneurs du pod ne démarre tant que tous les volumes du pod ne sont pas montés.</p><h2 id=cas-d-utilisation>Cas d'utilisation</h2><h3 id=cas-d-utilisation-pod-avec-clés-ssh>Cas d'utilisation: pod avec clés SSH</h3><p>Créez un kustomization.yaml avec un <code>SecretGenerator</code> contenant quelques clés SSH:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>secret &#34;ssh-key-secret&#34; created
</span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Réfléchissez bien avant d'envoyer vos propres clés SSH: d'autres utilisateurs du cluster peuvent avoir accès au secret.
Utilisez un compte de service que vous souhaitez rendre accessible à tous les utilisateurs avec lesquels vous partagez le cluster Kubernetes et que vous pouvez révoquer s'ils sont compromis.</div><p>Nous pouvons maintenant créer un pod qui référence le secret avec la clé SSH et le consomme dans un volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Lorsque la commande du conteneur s'exécute, les morceaux de la clé seront disponibles dans:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/etc/secret-volume/ssh-publickey
</span></span><span style=display:flex><span>/etc/secret-volume/ssh-privatekey
</span></span></code></pre></div><p>Le conteneur est alors libre d'utiliser les données secrètes pour établir une connexion SSH.</p><h3 id=cas-d-utilisation-pods-avec-informations-d-identification-de-prod-test>Cas d'utilisation: pods avec informations d'identification de prod/test</h3><p>Faites un fichier kustomization.yaml avec un SecretGenerator.</p><p>Cet exemple illustre un Pod qui consomme un secret contenant des informations d'identification de prod et un autre Pod qui consomme un secret avec des informations d'identification d'environnement de test.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>secret &#34;prod-db-secret&#34; created
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>secret &#34;test-db-secret&#34; created
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Caractères spéciaux tels que <code>$</code>, <code>\</code>, <code>*</code>, et <code>!</code> seront interprétés par votre <a href=https://en.wikipedia.org/wiki/Shell_(computing)>shell</a> et nécessitent d'être échappés.
Dans les shells les plus courants, le moyen le plus simple d'échapper au mot de passe est de l'entourer de guillemets simples (<code>'</code>).
Par exemple, si votre mot de passe réel est <code>S!B\*d$zDsb</code>, vous devez exécuter la commande de cette façon:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl create secret generic dev-db-secret --from-literal=username=devuser --from-literal=password=&#39;S!B\*d$zDsb&#39;
</span></span></code></pre></div><p>Vous n'avez pas besoin d'échapper les caractères spéciaux dans les mots de passe des fichiers (<code>--from-file</code>).</p></div><p>Maintenant, faites les pods:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: List
</span></span></span><span style=display:flex><span><span style=color:#b44>items:
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: prod-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: prod-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: prod-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: test-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: test-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: test-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Ajoutez les pods à la même kustomization.yaml</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Appliquez tous ces objets sur l'Apiserver avec</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><p>Les deux conteneurs auront les fichiers suivants présents sur leurs systèmes de fichiers avec les valeurs pour l'environnement de chaque conteneur:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/etc/secret-volume/username
</span></span><span style=display:flex><span>/etc/secret-volume/password
</span></span></code></pre></div><p>Notez comment les spécifications pour les deux pods ne diffèrent que dans un champ; cela facilite la création de pods avec différentes capacités à partir d'un template de pod commun.</p><p>Vous pouvez encore simplifier la spécification du pod de base en utilisant deux comptes de service: un appelé, disons, <code>prod-user</code> avec le secret <code>prod-db-secret</code>, et un appelé, <code>test-user</code> avec le secret <code>test-db-secret</code>.
Ensuite, la spécification du pod peut être raccourcie, par exemple:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=cas-d-utilisation-dotfiles-dans-un-volume-secret>Cas d'utilisation: Dotfiles dans un volume secret</h3><p>Afin de masquer des données (c'est-à-dire dans un fichier dont le nom commence par un point), il suffit de faire commencer cette clé par un point.
Par exemple, lorsque le secret suivant est monté dans un volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Le <code>secret-volume</code> contiendra un seul fichier, appelé <code>.secret-file</code>, et le <code>dotfile-test-container</code> aura ce fichier présent au chemin <code>/etc/secret-volume/.secret-file</code>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Les fichiers commençant par des points sont masqués de la sortie de <code>ls -l</code>; vous devez utiliser <code>ls -la</code> pour les voir lors de la liste du contenu du répertoire.</div><h3 id=cas-d-utilisation-secret-visible-pour-un-conteneur-dans-un-pod>Cas d'utilisation: secret visible pour un conteneur dans un pod</h3><p>Envisagez un programme qui doit gérer les requêtes HTTP, effectuer une logique métier complexe, puis signer certains messages avec un HMAC.
Parce qu'il a une logique d'application complexe, il pourrait y avoir un exploit de lecture de fichier à distance inaperçu dans le serveur, qui pourrait exposer la clé privée à un attaquant.</p><p>Cela pourrait être divisé en deux processus dans deux conteneurs: un conteneur frontal qui gère l'interaction utilisateur et la logique métier, mais qui ne peut pas voir la clé privée; et un conteneur de signataire qui peut voir la clé privée, et répond aux demandes de signature simples du frontend (par exemple sur le réseau localhost).</p><p>Avec cette approche partitionnée, un attaquant doit maintenant inciter le serveur d'applications à faire quelque chose d'assez arbitraire, ce qui peut être plus difficile que de lui faire lire un fichier.</p><h2 id=les-meilleures-pratiques>Les meilleures pratiques</h2><h3 id=clients-qui-utilisent-l-api-secrets>Clients qui utilisent l'API secrets</h3><p>Lors du déploiement d'applications qui interagissent avec l'API secrets, l'accès doit être limité à l'aide de <a href=/docs/reference/access-authn-authz/authorization/>politiques d'autorisation</a> telles que <a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>.</p><p>Les secrets contiennent souvent des valeurs qui couvrent un spectre d'importance, dont beaucoup peuvent provoquer des escalades au sein de Kubernetes (par exemple, les jetons de compte de service) et vers les systèmes externes.
Même si une application individuelle peut raisonner sur la puissance des secrets avec lesquels elle s'attend à interagir, d'autres applications dans le même namespace peuvent rendre ces hypothèses invalides.</p><p>Pour ces raisons, les requêtes <code>watch</code> et <code>list</code> pour les secrets dans un namespace sont des capacités extrêmement puissantes et doivent être évitées, puisque la liste des secrets permet aux clients d'inspecter les valeurs de tous les secrets qui se trouvent dans ce namespace.
La capacité à effectuer un <code>watch</code> ou <code>list</code> des secrets dans un cluster doit être réservé uniquement aux composants les plus privilégiés au niveau du système.</p><p>Les applications qui ont besoin d'accéder à l'API secrets doivent effectuer des requêtes <code>get</code> sur les secrets dont elles ont besoin.
Cela permet aux administrateurs de restreindre l'accès à tous les secrets tout en donnant <a href=/docs/reference/access-authn-authz/rbac/#referring-to-resources>accès en liste blanche aux instances individuelles</a> dont l'application a besoin.</p><p>Pour des performances améliorées sur une boucle <code>get</code>, les clients peuvent concevoir des ressources qui font référence à un secret puis <code>watch</code> la ressource, demandant à nouveau le secret lorsque la ressource change.
De plus, un <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/bulk_watch.md>"bulk watch" API</a> laisse les clients <code>watch</code> des ressources individuelles ont également été proposées et seront probablement disponibles dans les prochaines versions de Kubernetes.</p><h2 id=propriétés-de-sécurité>Propriétés de sécurité</h2><h3 id=protections>Protections</h3><p>Étant donné que les objets secrets peuvent être créés indépendamment des Pods qui les utilisent, il y a moins de risques que le secret soit exposé pendant la création, la visualisation et la modification des Pods.
Le système peut également prendre des précautions supplémentaires avec les objets secrets, comme éviter de les écrire sur le disque lorsque cela est possible.</p><p>Un secret n'est envoyé à un nœud que si un module sur ce nœud l'exige.
Kubelet stocke le secret dans un <code>tmpfs</code> afin que le secret ne soit pas écrit sur le stockage sur disque.
Une fois que le pod qui dépend du secret est supprimé, kubelet supprimera également sa copie locale des données secrètes.</p><p>Il peut y avoir des secrets pour plusieurs pods sur le même nœud.
Cependant, seuls les secrets qu'un pod demande sont potentiellement visibles dans ses conteneurs.
Par conséquent, un pod n'a pas accès aux secrets d'un autre pod.</p><p>Il peut y avoir plusieurs conteneurs dans un pod.
Cependant, chaque conteneur d'un pod doit demander le volume secret dans ses <code>volumesMounts</code> pour qu'il soit visible dans le conteneur.
Cela peut être utilisé pour construire des <a href=#use-case-secret-visible-to-one-container-in-a-pod>partitions de sécurité au niveau du pod</a>.</p><p>Sur la plupart des distributions gérées par le projet Kubernetes, la communication entre l'utilisateur vers l'apiserver et entre l'apiserver et les kubelets est protégée par SSL/TLS.
Les secrets sont protégés lorsqu'ils sont transmis sur ces canaux.</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code></div><p>Vous pouvez activer le <a href=/docs/tasks/administer-cluster/encrypt-data/>chiffrement au repos</a> pour les données secrètes, afin que les secrets ne soient pas stockés en clair dans <a class=glossary-tooltip title='Base de données clé-valeur consistante et hautement disponible utilisée comme mémoire de sauvegarde pour toutes les données du cluster.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>.</p><h3 id=risques>Risques</h3><ul><li>Dans le serveur API, les données secrètes sont stockées dans <a class=glossary-tooltip title='Base de données clé-valeur consistante et hautement disponible utilisée comme mémoire de sauvegarde pour toutes les données du cluster.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>; par conséquent:<ul><li>Les administrateurs doivent activer le chiffrement au repos pour les données du cluster (nécessite la version 1.13 ou ultérieure)</li><li>Les administrateurs devraient limiter l'accès à etcd aux utilisateurs administrateurs</li><li>Les administrateurs peuvent vouloir effacer/détruire les disques utilisés par etcd lorsqu'ils ne sont plus utilisés</li><li>Si vous exécutez etcd dans un cluster, les administrateurs doivent s'assurer d'utiliser SSL/TLS pour la communication peer-to-peer etcd.</li></ul></li><li>Si vous configurez le secret via un fichier manifeste (JSON ou YAML) qui a les données secrètes codées en base64, partager ce fichier ou l'archiver dans un dépot de source signifie que le secret est compromis.
L'encodage Base64 <em>n'est pas</em> une méthode de chiffrement, il est considéré comme identique au texte brut.</li><li>Les applications doivent toujours protéger la valeur du secret après l'avoir lu dans le volume, comme ne pas le mettre accidentellement dans un journal ou le transmettre à une partie non fiable.</li><li>Un utilisateur qui peut créer un pod qui utilise un secret peut également voir la valeur de ce secret.
Même si la stratégie apiserver ne permet pas à cet utilisateur de lire l'objet secret, l'utilisateur peut créer un pod qui expose le secret.</li><li>Actuellement, toute personne disposant des droit root sur n'importe quel nœud peut lire <em>n'importe quel</em> secret depuis l'apiserver, en usurpant l'identité du kubelet.
Il est prévu de n'envoyer des secrets qu'aux nœuds qui en ont réellement besoin, pour limiter l'impact d'un exploit root sur un seul nœud.</li></ul><h2 id=a-suivre>A suivre</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-712cb3c03ff14a39e5a83a6d9b71d203>8 - Sécurité</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-ac9161c6d952925b083ad9602b4e8e7f>9 - Politiques</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-285a3785fd3d20f437c28d87ca4dadca>10 - Administration d'un cluster</h1><div class=lead>Administration cluster Kubernetes</div></div><div class=td-content><h1 id=pg-fb494ea3b1874bd753dcd11c3f35c2dc>10.1 - Vue d'ensemble de l'administration d'un cluster</h1><div class=lead>Administration cluster Kubernetes</div><p>La vue d'ensemble de l'administration d'un cluster est destinée à toute personne créant ou administrant un cluster Kubernetes.
Il suppose une certaine familiarité avec les <a href=/docs/concepts/>concepts</a> de Kubernetes.</p><h2 id=planifier-le-déploiement-d-un-cluster>Planifier le déploiement d'un cluster</h2><p>Voir le guide: <a href=/fr/docs/setup/pick-right-solution/>choisir la bonne solution</a> pour des exemples de planification, de mise en place et de configuration de clusters Kubernetes. Les solutions répertoriées dans cet article s'appellent des <em>distributions</em>.</p><p>Avant de choisir un guide, voici quelques considérations:</p><ul><li>Voulez-vous simplement essayer Kubernetes sur votre machine ou voulez-vous créer un cluster haute disponibilité à plusieurs nœuds? Choisissez les distributions les mieux adaptées à vos besoins.</li><li><strong>Si vous recherchez la haute disponibilité</strong>, apprenez à configurer des <a href=/docs/concepts/cluster-administration/federation/>clusters multi zones</a>.</li><li>Utiliserez-vous <strong>un cluster Kubernetes hébergé</strong>, comme <a href=https://cloud.google.com/kubernetes-engine/>Google Kubernetes Engine</a>, ou <strong>hébergerez-vous votre propre cluster</strong>?</li><li>Votre cluster sera-t-il <strong>on-premises</strong>, ou <strong>sur un cloud (IaaS)</strong>? Kubernetes ne prend pas directement en charge les clusters hybrides. Cependant, vous pouvez configurer plusieurs clusters.</li><li><strong>Si vous configurez Kubernetes on-premises</strong>, choisissez le <a href=/docs/concepts/cluster-administration/networking/>modèle réseau</a> qui vous convient le mieux.</li><li>Voulez-vous faire tourner Kubernetes sur du <strong>bare metal</strong> ou sur des <strong>machines virtuelles (VMs)</strong>?</li><li>Voulez-vous <strong>simplement faire tourner un cluster</strong>, ou vous attendez-vous à faire du <strong>développement actif sur le code du projet Kubernetes</strong>? Dans ce dernier cas, choisissez une distribution activement développée. Certaines distributions n’utilisent que des versions binaires, mais offrent une plus grande variété de choix.</li><li>Familiarisez-vous avec les <a href=/docs/admin/cluster-components/>composants</a> nécessaires pour faire tourner un cluster.</li></ul><p>A noter: Toutes les distributions ne sont pas activement maintenues. Choisissez des distributions qui ont été testées avec une version récente de Kubernetes.</p><h2 id=gérer-un-cluster>Gérer un cluster</h2><ul><li><p><a href=/docs/tasks/administer-cluster/cluster-management/>Gérer un cluster</a> décrit plusieurs rubriques relatives au cycle de vie d’un cluster: création d’un nouveau cluster, mise à niveau des nœuds maître et des workers de votre cluster, maintenance des nœuds (mises à niveau du noyau, par exemple) et mise à niveau de la version de l’API Kubernetes d’un cluster en cours d’exécution.</p></li><li><p>Apprenez comment <a href=/docs/concepts/nodes/node/>gérer les nœuds</a>.</p></li><li><p>Apprenez à configurer et gérer les <a href=/docs/concepts/policy/resource-quotas/>quotas de ressources</a> pour les clusters partagés.</p></li></ul><h2 id=sécuriser-un-cluster>Sécuriser un cluster</h2><ul><li><p>La rubrique <a href=/docs/concepts/cluster-administration/certificates/>Certificats</a> décrit les étapes à suivre pour générer des certificats à l’aide de différentes suites d'outils.</p></li><li><p>L' <a href=/docs/concepts/containers/container-environment/>Environnement de conteneur dans Kubernetes</a> décrit l'environnement des conteneurs gérés par Kubelet sur un nœud Kubernetes.</p></li><li><p>Le <a href=/docs/reference/access-authn-authz/controlling-access/>Contrôle de l'accès à l'API Kubernetes</a> explique comment configurer les autorisations pour les utilisateurs et les comptes de service.</p></li><li><p>La rubrique <a href=/docs/reference/access-authn-authz/authentication/>Authentification</a> explique l'authentification dans Kubernetes, y compris les différentes options d'authentification.</p></li><li><p><a href=/docs/reference/access-authn-authz/authorization/>Autorisations</a> est distinct de l'authentification et contrôle le traitement des appels HTTP.</p></li><li><p><a href=/docs/reference/access-authn-authz/admission-controllers/>Utiliser les Admission Controllers</a> explique les plug-ins qui interceptent les requêtes adressées au serveur d'API Kubernetes après authentification et autorisation.</p></li><li><p><a href=/docs/concepts/cluster-administration/sysctl-cluster/>Utiliser Sysctls dans un cluster Kubernetes</a> explique aux administrateurs comment utiliser l'outil de ligne de commande <code>sysctl</code> pour définir les paramètres du noyau.</p></li><li><p><a href=/docs/tasks/debug-application-cluster/audit/>Auditer</a> explique comment interagir avec les journaux d'audit de Kubernetes.</p></li></ul><h3 id=sécuriser-la-kubelet>Sécuriser la Kubelet</h3><ul><li><a href=/docs/concepts/architecture/master-node-communication/>Communication Master-Node</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS bootstrapping</a></li><li><a href=/docs/admin/kubelet-authentication-authorization/>Kubelet authentification/autorisations</a></li></ul><h2 id=services-de-cluster-optionnels>Services de cluster optionnels</h2><ul><li><p><a href=/docs/concepts/services-networking/dns-pod-service/>Integration DNS</a> décrit comment résoudre un nom DNS directement vers un service Kubernetes.</p></li><li><p><a href=/docs/concepts/cluster-administration/logging/>Journalisation des évènements et surveillance de l'activité du cluster</a> explique le fonctionnement de la journalisation des évènements dans Kubernetes et son implémentation.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf9a93ab5ba014fb6ff70b22c29d432>10.2 - Certificats</h1><div class=lead>Certifications cluster Kubernetes</div><p>Lorsque vous utilisez l'authentification par certificats client, vous pouvez générer des certificats
manuellement grâce à <code>easyrsa</code>, <code>openssl</code> ou <code>cfssl</code>.</p><h3 id=easyrsa>easyrsa</h3><p><strong>easyrsa</strong> peut générer manuellement des certificats pour votre cluster.</p><ol><li><p>Téléchargez, décompressez et initialisez la version corrigée de easyrsa3.</p><pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
tar xzf easy-rsa.tar.gz
cd easy-rsa-master/easyrsa3
./easyrsa init-pki
</code></pre></li><li><p>Générez une CA. (<code>--batch</code> pour le mode automatique. <code>--req-cn</code> CN par défaut à utiliser)</p><pre><code>./easyrsa --batch &quot;--req-cn=${MASTER_IP}@`date +%s`&quot; build-ca nopass
</code></pre></li><li><p>Générer un certificat de serveur et une clé.
L' argument <code>--subject-alt-name</code> définit les adresses IP et noms DNS possibles par lesquels l'API
serveur peut être atteind. La <code>MASTER_CLUSTER_IP</code> est généralement la première adresse IP du CIDR des services
qui est spécifié en tant qu'argument <code>--service-cluster-ip-range</code> pour l'API Server et
le composant controller manager. L'argument <code>--days</code> est utilisé pour définir le nombre de jours
après lesquels le certificat expire.
L’exemple ci-dessous suppose également que vous utilisez <code>cluster.local</code> par défaut comme
nom de domaine DNS.</p><pre><code>./easyrsa --subject-alt-name=&quot;IP:${MASTER_IP},&quot;\
&quot;IP:${MASTER_CLUSTER_IP},&quot;\
&quot;DNS:kubernetes,&quot;\
&quot;DNS:kubernetes.default,&quot;\
&quot;DNS:kubernetes.default.svc,&quot;\
&quot;DNS:kubernetes.default.svc.cluster,&quot;\
&quot;DNS:kubernetes.default.svc.cluster.local&quot; \
--days=10000 \
build-server-full server nopass
</code></pre></li><li><p>Copiez <code>pki/ca.crt</code>, <code>pki/issued/server.crt</code>, et <code>pki/private/server.key</code> dans votre répertoire.</p></li><li><p>Personnalisez et ajoutez les lignes suivantes aux paramètres de démarrage de l'API Server:</p><pre><code>--client-ca-file=/yourdirectory/ca.crt
--tls-cert-file=/yourdirectory/server.crt
--tls-private-key-file=/yourdirectory/server.key
</code></pre></li></ol><h3 id=openssl>openssl</h3><p><strong>openssl</strong> peut générer manuellement des certificats pour votre cluster.</p><ol><li><p>Générez ca.key en 2048bit:</p><pre><code>openssl genrsa -out ca.key 2048
</code></pre></li><li><p>A partir de la clé ca.key générez ca.crt (utilisez -days pour définir la durée du certificat):</p><pre><code>openssl req -x509 -new -nodes -key ca.key -subj &quot;/CN=${MASTER_IP}&quot; -days 10000 -out ca.crt
</code></pre></li><li><p>Générez server.key en 2048bit:</p><pre><code>openssl genrsa -out server.key 2048
</code></pre></li><li><p>Créez un fichier de configuration pour générer une demande de signature de certificat (CSR).
Assurez-vous de remplacer les valeurs marquées par des "&lt; >" (par exemple, <code>&lt;MASTER_IP></code>)
avec des valeurs réelles avant de l'enregistrer dans un fichier (par exemple, <code>csr.conf</code>).
Notez que la valeur de <code>MASTER_CLUSTER_IP</code> est celle du service Cluster IP pour l'
API Server comme décrit dans la sous-section précédente.
L’exemple ci-dessous suppose également que vous utilisez <code>cluster.local</code> par défaut comme
nom de domaine DNS.</p><pre><code>[ req ]
default_bits = 2048
prompt = no
default_md = sha256
req_extensions = req_ext
distinguished_name = dn

[ dn ]
C = &lt;country&gt;
ST = &lt;state&gt;
L = &lt;city&gt;
O = &lt;organization&gt;
OU = &lt;organization unit&gt;
CN = &lt;MASTER_IP&gt;

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster
DNS.5 = kubernetes.default.svc.cluster.local
IP.1 = &lt;MASTER_IP&gt;
IP.2 = &lt;MASTER_CLUSTER_IP&gt;

[ v3_ext ]
authorityKeyIdentifier=keyid,issuer:always
basicConstraints=CA:FALSE
keyUsage=keyEncipherment,dataEncipherment
extendedKeyUsage=serverAuth,clientAuth
subjectAltName=@alt_names
</code></pre></li><li><p>Générez la demande de signature de certificat basée sur le fichier de configuration:</p><pre><code>openssl req -new -key server.key -out server.csr -config csr.conf
</code></pre></li><li><p>Générez le certificat de serveur en utilisant ca.key, ca.crt et server.csr:</p><pre><code>openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key \
-CAcreateserial -out server.crt -days 10000 \
-extensions v3_ext -extfile csr.conf
</code></pre></li><li><p>Vérifiez le certificat:</p><pre><code>openssl x509  -noout -text -in ./server.crt
</code></pre></li></ol><p>Enfin, ajoutez les mêmes paramètres aux paramètres de démarrage de l'API Server.</p><h3 id=cfssl>cfssl</h3><p><strong>cfssl</strong> est un autre outil pour la génération de certificat.</p><ol><li><p>Téléchargez, décompressez et préparez les outils de ligne de commande comme indiqué ci-dessous.
Notez que vous devrez peut-être adapter les exemples de commandes en fonction du matériel,
de l'architecture et de la version de cfssl que vous utilisez.</p><pre><code>curl -L https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -o cfssl
chmod +x cfssl
curl -L https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -o cfssljson
chmod +x cfssljson
curl -L https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -o cfssl-certinfo
chmod +x cfssl-certinfo
</code></pre></li><li><p>Créez un répertoire pour contenir les artefacts et initialiser cfssl:</p><pre><code>mkdir cert
cd cert
../cfssl print-defaults config &gt; config.json
../cfssl print-defaults csr &gt; csr.json
</code></pre></li><li><p>Créez un fichier JSON pour générer le fichier d'autorité de certification, par exemple, <code>ca-config.json</code>:</p><pre><code>{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;8760h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [
          &quot;signing&quot;,
          &quot;key encipherment&quot;,
          &quot;server auth&quot;,
          &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;8760h&quot;
      }
    }
  }
}
</code></pre></li><li><p>Créez un fichier JSON pour la demande de signature de certificat de l'autorité de certification, par exemple,
<code>ca-csr.json</code>. Assurez-vous de remplacer les valeurs marquées par des "&lt; >" par
les vraies valeurs que vous voulez utiliser.</p><pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;:[{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre></li><li><p>Générez la clé de CA (<code>ca-key.pem</code>) et le certificat (<code>ca.pem</code>):</p><pre><code>../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca
</code></pre></li><li><p>Créer un fichier JSON pour générer des clés et des certificats pour l'API Server,
par exemple, <code>server-csr.json</code>. Assurez-vous de remplacer les valeurs entre "&lt; >" par
les vraies valeurs que vous voulez utiliser. <code>MASTER_CLUSTER_IP</code> est le service Cluster IP
de l'API Server, comme décrit dans la sous-section précédente.
L’exemple ci-dessous suppose également que vous utilisez <code>cluster.local</code> par défaut comme
nom de domaine DNS.</p><pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;hosts&quot;: [
    &quot;127.0.0.1&quot;,
    &quot;&lt;MASTER_IP&gt;&quot;,
    &quot;&lt;MASTER_CLUSTER_IP&gt;&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local&quot;
  ],
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre></li><li><p>Générez la clé et le certificat pour l'API Server, qui sont par défaut
sauvegardés respectivement dans les fichiers <code>server-key.pem</code> et<code> server.pem</code>:</p><pre><code>../cfssl gencert -ca=ca.pem -ca-key=ca-key.pem \
--config=ca-config.json -profile=kubernetes \
server-csr.json | ../cfssljson -bare server
</code></pre></li></ol><h2 id=distribuer-un-certificat-auto-signé>Distribuer un certificat auto-signé</h2><p>Un client peut refuser de reconnaître un certificat auto-signé comme valide.
Pour un déploiement hors production ou pour un déploiement exécuté derrière un
pare-feu d'entreprise, vous pouvez distribuer un certificat auto-signé à tous les clients et
actualiser la liste locale pour les certificats valides.</p><p>Sur chaque client, effectuez les opérations suivantes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt
</span></span><span style=display:flex><span>$ sudo update-ca-certificates
</span></span><span style=display:flex><span>Updating certificates in /etc/ssl/certs...
</span></span><span style=display:flex><span><span style=color:#666>1</span> added, <span style=color:#666>0</span> removed; <span style=color:#a2f;font-weight:700>done</span>.
</span></span><span style=display:flex><span>Running hooks in /etc/ca-certificates/update.d....
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>.
</span></span></code></pre></div><h2 id=api-pour-les-certificats>API pour les certificats</h2><p>Vous pouvez utiliser l’API <code>certificates.k8s.io</code> pour faire créer des
Certificats x509 à utiliser pour l'authentification, comme documenté
<a href=/docs/tasks/tls/managing-tls-in-a-cluster>ici</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c4b1e87a84441f8a90699a345ce48d68>10.3 - Architecture de Journalisation d'évènements (logging)</h1><p>La journalisation des évènements systèmes et d'applications peut aider à
comprendre ce qui se passe dans un cluster. Les journaux sont particulièrement
utiles pour débogguer les problèmes et surveiller l'activité du cluster. La
plupart des applications modernes ont un mécanisme de journalisation
d'évènements, et la plupart des environnements d'exécution de conteneurs ont été
conçus pour supporter la journalisation des évènements. La méthode de
journalisation la plus facile et la plus répandue pour des applications
conteneurisées est d'écrire dans les flux de sortie standard et d'erreur
(<code>stdout</code> et <code>stderr</code>).</p><p>Malgré cela, la fonctionnalité de journalisation fournie nativement par
l'environnement d'exécution de conteneurs n'est pas suffisante comme solution
complète de journalisation. Quand un conteneur crashe, quand un Pod est expulsé
ou quand un nœud disparaît, il est utile de pouvoir accéder au journal
d'événements de l'application. C'est pourquoi les journaux doivent avoir leur
propre espace de stockage et un cycle de vie indépendamment des nœuds, Pods ou
conteneurs. Ce concept est appelé <em>journalisation des évènements au niveau du
cluster</em> (cluster-level-logging). Un backend dédié pour stocker, analyser et
faire des requêtes est alors nécessaire. Kubernetes n'offre pas nativement de
solution de stockage pour les journaux mais il est possible d'intégrer de
nombreuses solutions de journalisation d'évènements dans un cluster Kubernetes.</p><p>L'architecture de journalisation des évènements au niveau du cluster est décrite
en considérant qu'un backend de journalisation est présent à l'intérieur ou à
l'extérieur du cluster. Même sans avoir l'intention de journaliser les
évènements au niveau du cluster, il est intéressant de savoir comment les
journaux sont conservés et gérés au niveau d'un nœud.</p><h2 id=journalisation-simple-d-évènements-dans-kubernetes>Journalisation simple d'évènements dans Kubernetes</h2><p>Dans cette section, on va utiliser un exemple simple de journalisation
d'évènements avec le flux de sortie standard. Cette démonstration utilise un
manifeste pour un Pod avec un seul conteneur qui écrit du texte sur le flux
de sortie standard toutes les secondes.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/debug/counter-pod.yaml download=debug/counter-pod.yaml><code>debug/counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("debug-counter-pod-yaml")' title="Copy debug/counter-pod.yaml to clipboard"></img></div><div class=includecode id=debug-counter-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#39;i=0; while true; do echo &#34;$i: $(date)&#34;; i=$((i+1)); sleep 1; done&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Pour lancer ce Pod, utilisez la commande suivante :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/debug/counter-pod.yaml
</span></span></code></pre></div><p>Le résultat est :</p><pre tabindex=0><code>pod/counter created
</code></pre><p>Pour récupérer les événements du conteneur d'un pod, utilisez la commande
<code>kubectl logs</code> de la manière suivante :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter
</span></span></code></pre></div><p>Le résultat est :</p><pre tabindex=0><code>0: Mon Jan  1 00:00:00 UTC 2001
1: Mon Jan  1 00:00:01 UTC 2001
2: Mon Jan  1 00:00:02 UTC 2001
...
</code></pre><p>Utilisez <code>kubectl logs</code> pour récupérer les évènements de l'instanciation
précédente d'un Pod en utilisant l'option <code>--previous</code> quand par exemple le
conteneur a crashé.</p><p>Si le Pod a plusieurs conteneurs, il faut spécifier le nom du conteneur dont on
veut récupérer le journal d'évènement. Dans notre exemple le conteneur s'appelle
<code>count</code> donc vous pouvez utiliser <code>kubectl logs counter count</code>. Plus de détails
dans la [documentation de <code>kubectl logs</code>] (/docs/reference/generated/kubectl/kubectl-commands#logs)</p><h2 id=journalisation-d-évènements-au-niveau-du-nœud>Journalisation d'évènements au niveau du nœud</h2><p><img src=/images/docs/user-guide/logging/logging-node-level.png alt="Journalisation d'évènements au niveau dunœud"></p><p>Tout ce qu'une application conteneurisée écrit sur <code>stdout</code> ou <code>stderr</code> est pris
en compte et redirigé par l'environnement d'exécution des conteneurs. Par exemple,
Docker redirige ces deux flux vers un <a href=https://docs.docker.com/config/containers/logging/configure/>driver de journalisation
(EN)</a> qui est
configuré dans Kubernetes pour écrire dans un fichier au format json.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le driver json de Docker traite chaque ligne comme un message
différent. Avec ce driver il n'y a pas de support direct pour des messages
multi-lignes. Il faut donc traiter les messages multi-lignes au niveau de
l'agent de journalisation ou plus en amont encore.</div><p>Par défaut quand un conteneur redémarre, le kubelet ne conserve le journal que
du dernier conteneur terminé. Quand un Pod est expulsé d'un nœud, tous ses
conteneurs sont aussi expulsés avec leurs journaux d'évènements.</p><p>Quand on utilise la journalisation d'évènements au niveau du nœud, il faut
prendre garde à mettre en place une politique de rotation des journaux adéquate
afin qu'ils n'utilisent pas tout l'espace de stockage du nœud. Kubernetes n'a
pas en charge la rotation des journaux, c'est à l'outil de déploiement de le
prendre en compte.</p><p>Par exemple, dans les clusters Kubernetes déployés avec le script <code>kube-up.sh</code>
<a href=https://linux.die.net/man/8/logrotate><code>logrotate</code></a> est configuré pour
s'exécuter toutes les heures. Il est aussi possible de configurer
l'environnement d'exécution des conteneurs pour que la rotation des journaux
s'exécute automatiquement, e.g. en utilisant le paramètre <code>log-opt</code> de Docker.
Dans le script <code>kube-up.sh</code>, c'est cette méthode qui est utilisée pour des
images COS sur GCP et sinon c'est la première méthode dans tous les autres cas.
Quelle que soit la méthode choisie par <code>kube-up.sh</code> la rotation est configurée par
défaut quand la taille d'un journal atteint 10 Mo.</p><p>Ce <a href=https://github.com/kubernetes/kubernetes/blob/main/cluster/gce/gci/configure-helper.sh>script</a> montre de manière détaillée comment <code>kube-up.sh</code>
met en place la journalisation d'évènements pour des images COS sur GCP.</p><p>Quand <a href=/docs/reference/generated/kubectl/kubectl-commands#logs><code>kubectl logs</code></a>
s'exécute comme dans le premier exemple de journalisation simple le kubelet du
nœud gère la requête et lit directement depuis le fichier de journal et retourne
son contenu dans la réponse.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si un système externe a effectué la rotation des journaux, seul le
contenu du dernier fichier journal sera disponible avec <code>kubectl logs</code>. Par
exemple quand le journal atteint 10 Mo, <code>logrotate</code> effectue une rotation, il y a
alors 2 fichers, un de 10 Mo et un de vide, à ce moment là <code>kubectl logs</code>
retournera une réponse vide.</div><h3 id=journalisation-des-évènements-des-composants-système>Journalisation des évènements des composants système</h3><p>Il y a deux types de composants système selon qu'ils s'exécutent dans un
conteneur ou pas.</p><p>Par exemple :</p><ul><li>Le scheduler Kubernetes et kube-proxy s'exécutent dans un conteneur.</li><li>Kubelet et l'environnement d'exécution de conteneurs, comme par exemple
Docker, ne s'exécutent pas dans un conteneur.</li></ul><p>Sur les systèmes avec systemd, kubelet et l'environnement d'exécution de
conteneurs écrivent dans journald. Si systemd n'est pas présent, ils écrivent
dans un fichier <code>.log</code> dans le répertoire <code>/var/log</code>.</p><p>Les composants système qui s'exécutent dans un conteneur écrivent toujours dans
le répertoire <code>/var/log</code>, en contournant le mécanisme de journalisation par
défaut. Ils utilisent la bibliothèque de journalisation <a href=https://github.com/kubernetes/klog>klog</a>. Les
conventions pour la sévérité des évènements pour ces composants se trouvent dans
cette [documentation sur les conventions de journalisation des évènements dans
kubernetes]
(<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md)>https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md)</a>.</p><p>De la même manière que les journaux des conteneurs, les journaux des composants
systèmes doivent avoir une politique de rotation. Dans un cluster créé avec
le script <code>kube-up.sh</code>, les journaux ont une rotation journalière ou quand leur
taille atteint 100 Mo.</p><h2 id=architecture-de-journalisation-des-évènements-au-niveau-du-cluster>Architecture de journalisation des évènements au niveau du cluster</h2><p>Kubernetes ne fournit pas de solution native pour la journalisation des
évènements au niveau du cluster. Mais il y a différentes approches qui peuvent
être considérées :</p><ul><li>Utiliser un agent de journalisation au niveau du nœud sur chacun des nœuds.</li><li>Inclure un conteneur side-car pour journaliser les évènements du Pod
applicatif.</li><li>Envoyer les évènements directement a un backend depuis l'application.</li></ul><h3 id=utiliser-un-agent-de-journalisation-au-niveau-du-nœud>Utiliser un agent de journalisation au niveau du nœud</h3><p><img src=/images/docs/user-guide/logging/logging-with-node-agent.png alt="Utiliser un agent de journalisation au niveau dunœud"></p><p>Vous pouvez implémenter une journalisation au niveau du cluster en incluant un
<em>agent de journalisation au niveau du nœud</em> sur chacun des nœuds. L'agent de
journalisation est un outil dédié qui met à disposition ou envoie les journaux à
un backend. Communément l'agent de journalisation est un conteneur qui a accès
au répertoire qui contient les journaux des conteneurs applicatifs sur ce nœud.</p><p>Comme l'agent de journalisation doit s'exécuter sur chacun des nœuds, on utilise
soit un DaemonSet, soit un manifeste de Pod, soit un processus dédié natif sur
le nœud. Ces deux dernières options sont obsolètes et fortement découragées.</p><p>Utiliser un agent de journalisation au niveau du nœud est l'approche la plus
commune et recommandée pour un cluster Kubernetes parce qu'un seul agent par
nœud est créé et qu'aucune modification dans l'application n'est nécessaire.
Mais cette approche <em>ne fonctionne correctement que pour les flux standards de
sortie et d'erreurs des applications</em>.</p><p>Kubernetes ne définit pas d'agent de journalisation, mais deux agents de
journalisation optionnels sont fournis avec la version de Kubernetes :
<a href=/docs/user-guide/logging/stackdriver>Stackdriver (EN)</a> pour utiliser sur
Google Cloud Platform, et <a href=/docs/user-guide/logging/elasticsearch>Elasticsearch
(EN)</a>. Les deux utilisent
<a href=http://www.fluentd.org/>fluentd</a> avec une configuration spécifique comme agent
sur le nœud. Les liens précédents fournissent plus d'informations et les
instructions pour les utiliser et configurer.</p><h3 id=inclure-un-conteneur-side-car-pour-journaliser-les-évènements-du-pod-applicatif>Inclure un conteneur side-car pour journaliser les évènements du Pod applicatif</h3><p>Vous pouvez utiliser un conteneur side-car d'une des manières suivantes :</p><ul><li>Le conteneur side-car diffuse les journaux de l'application sur son propre
<code>stdout</code>.</li><li>Le conteneur side-car exécute un agent de journalisation qui est configuré
pour récupérer les journaux du conteneur applicatif.</li></ul><h4 id=conteneur-side-car-diffusant-streaming-sidecar-container>Conteneur side-car diffusant (Streaming sidecar container)</h4><p><img src=/images/docs/user-guide/logging/logging-with-streaming-sidecar.png alt="Conteneur side-cardiffusant"></p><p>Comme le conteneur side-car diffuse les journaux sur ses propres flux <code>stdout</code>
et <code>stderr</code>, on peut bénéficier du kubelet et de l'agent de journalisation qui
s'exécute déjà sur chaque nœud. Les conteneurs side-car lisent les journaux
depuis un fichier, un socket ou bien journald. Chaque conteneur side-car écrit
son journal sur son propre flux <code>stdout</code> ou <code>stderr</code>.</p><p>Cette méthode permet de séparer les flux de journaux de différentes
parties de votre application même si elles ne supportent pas d'écrire sur
<code>stdout</code> ou <code>stderr</code>. La logique de rediriger les journaux est minime et
le surcoût est non significatif. De plus comme les flux standards <code>stdout</code> et
<code>stderr</code> sont gérés par kubelet, les outils natifs comme <code>kubectl logs</code> peuvent
être utilisés.</p><p>Regardez l'exemple qui suit.</p><p>Un Pod exécute un unique conteneur et ce conteneur écrit dans deux fichiers de
journaux différents en utilisant deux format différents. Voici le manifeste du
Pod :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/admin/logging/two-files-counter-pod.yaml download=admin/logging/two-files-counter-pod.yaml><code>admin/logging/two-files-counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-yaml")' title="Copy admin/logging/two-files-counter-pod.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Il serait très désordonné d'avoir des évènements avec des formats différents
dans le même journal en redirigeant les évènements dans le flux de sortie
<code>stdout</code> d'un seul conteneur. Il est plutôt souhaitable d'utiliser deux
conteneurs side-car, un pour chaque type de journaux. Chaque conteneur side-car
suit un des fichiers et renvoie les évènements sur son propre <code>stdout</code>.</p><p>Ci-dessous se trouve le manifeste pour un Pod avec deux conteneurs side-car.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/admin/logging/two-files-counter-pod-streaming-sidecar.yaml download=admin/logging/two-files-counter-pod-streaming-sidecar.yaml><code>admin/logging/two-files-counter-pod-streaming-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-streaming-sidecar-yaml")' title="Copy admin/logging/two-files-counter-pod-streaming-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-streaming-sidecar-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -f /var/log/1.log&#39;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -f /var/log/2.log&#39;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Quand ce Pod s'exécute, chaque journal peut être diffusé séparément en
utilisant les commandes suivantes :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter count-log-1
</span></span></code></pre></div><pre tabindex=0><code>0: Mon Jan  1 00:00:00 UTC 2001
1: Mon Jan  1 00:00:01 UTC 2001
2: Mon Jan  1 00:00:02 UTC 2001
...
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter count-log-2
</span></span></code></pre></div><pre tabindex=0><code>Mon Jan  1 00:00:00 UTC 2001 INFO 0
Mon Jan  1 00:00:01 UTC 2001 INFO 1
Mon Jan  1 00:00:02 UTC 2001 INFO 2
...
</code></pre><p>L'agent au niveau du nœud installé dans le cluster récupère les deux flux de
journaux sans aucune configuration supplémentaire. Il est possible de configurer
l'agent pour qu'il analyse syntaxiquement les évènements en fonction du
conteneur source.</p><p>Notez que bien que la consommation en CPU et mémoire soit faible ( de l'ordre de
quelques milicores pour la CPU et quelques mégaoctets pour la mémoire), ecrire
les évènements dans un fichier et les envoyer ensuite dans <code>stdout</code> peut doubler
l'espace disque utilisé. Quand une application écrit dans un seul fichier de
journal, il est préférable de configurer <code>/dev/stdout</code> comme destination plutôt
que d'implémenter un conteneur side-car diffusant.</p><p>Les conteneurs side-car peuvent être utilisés pour faire la rotation des
journaux quand l'application n'en est pas capable elle-même. Un exemple serait
un petit conteneur side-car qui effectuerait cette rotation périodiquement.
Toutefois, il est recommandé d'utiliser <code>stdout</code> et <code>stderr</code> directement et de
laisser la rotation et les politiques de rétentions au kubelet.</p><h3 id=conteneur-side-car-avec-un-agent-de-journalisation>Conteneur side-car avec un agent de journalisation</h3><p><img src=/images/docs/user-guide/logging/logging-with-sidecar-agent.png alt="Conteneur side-car avec un agent dejournalisation"></p><p>Quand un agent de journalisation au niveau du nœud n'est pas assez flexible pour
votre utilisation, vous pouvez créer un conteneur side-car avec un agent de
journalisation séparé que vous avez configuré spécialement pour qu'il s'exécute
avec votre application.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Utiliser un agent de journalisation dans un conteneur side-car peut entraîner
une consommation de ressources significative. De plus vous n'avez plus accès aux
journaux avec la commande <code>kubectl</code> parce qu'ils ne sont plus gérés par
kubelet.</div><p>Comme exemple, vous pouvez utiliser
<a href=/docs/tasks/debug-application-cluster/logging-stackdriver/>Stackdriver</a> où
fluentd est l'agent de journalisation. Ci-dessous se trouvent deux
configurations qui implémentent cette méthode.</p><p>Le premier fichier contient un
<a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a> pour
configurer fluentd.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/admin/logging/fluentd-sidecar-config.yaml download=admin/logging/fluentd-sidecar-config.yaml><code>admin/logging/fluentd-sidecar-config.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-fluentd-sidecar-config-yaml")' title="Copy admin/logging/fluentd-sidecar-config.yaml to clipboard"></img></div><div class=includecode id=admin-logging-fluentd-sidecar-config-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fluentd.conf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type tail
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      format none
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      path /var/log/1.log
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      pos_file /var/log/1.log.pos
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      tag count.format1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type tail
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      format none
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      path /var/log/2.log
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      pos_file /var/log/2.log.pos
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      tag count.format2
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;match **&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type google_cloud
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/match&gt;</span><span style=color:#bbb>    
</span></span></span></code></pre></div></div></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> La configuration de fluentd est hors du cadre de cet article. Vous trouverez
des informations pour configurer fluentd dans la <a href=http://docs.fluentd.org/>documentation officielle de
fluentd</a>.</div><p>Le second fichier est un manifeste pour un Pod avec un conteneur side-car qui
exécute fluentd. Le Pod monte un volume où fluentd peut récupérer sa
configuration.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/admin/logging/two-files-counter-pod-agent-sidecar.yaml download=admin/logging/two-files-counter-pod-agent-sidecar.yaml><code>admin/logging/two-files-counter-pod-agent-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-agent-sidecar-yaml")' title="Copy admin/logging/two-files-counter-pod-agent-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-agent-sidecar-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/fluentd-gcp:1.30<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>FLUENTD_ARGS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>-c /etc/fluentd-config/fluentd.conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/fluentd-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Apres quelques minutes, les évènements apparaîtront dans l'interface de
Stackdriver.</p><p>Ce n'est qu'un exemple et vous pouvez remplacer fluentd par n'importe quel
agent de journalisation qui lit depuis n'importe quelle source de votre
application.</p><h3 id=envoyer-les-évènements-directement-depuis-l-application>Envoyer les évènements directement depuis l'application.</h3><p><img src=/images/docs/user-guide/logging/logging-from-application.png alt="Envoyer les évènements directement a un backend depuisl'application."></p><p>Vous pouvez implémenter la journalisation au niveau cluster en mettant à
disposition ou en envoyant les journaux directement depuis chaque application;
Toutefois l'implémentation de ce mécanisme de journalisation est hors du cadre
de Kubernetes.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7e0d97616b15e2c383c6a0a96ec442cb>11 - Extensions Kubernetes</h1></div><div class=td-content><h1 id=pg-0af41d3bd7c785621b58b7564793396a>11.1 - Extensions de l'API Kubernetes</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-c8937cdc9df96f3328becf04f8211292>11.2 - Extensions compute, stockage et réseau</h1></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/fr/docs/home/>Accueil</a>
<a class=text-white href=/fr/blog/>Blog</a>
<a class=text-white href=/fr/partners/>Partenaires</a>
<a class=text-white href=/fr/community/>Communauté</a>
<a class=text-white href=/fr/case-studies/>Études de cas</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>