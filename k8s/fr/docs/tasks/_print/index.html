<!doctype html><html lang=fr class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/tasks/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/tasks/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/><link rel=alternate hreflang=hi href=https://kubernetes.io/hi/docs/tasks/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/tasks/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/fr/docs/tasks/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Tâches | Kubernetes</title><meta property="og:title" content="Tâches"><meta property="og:description" content="Solution professionnelle d’orchestration de conteneurs"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/fr/docs/tasks/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Tâches"><meta itemprop=description content="Solution professionnelle d’orchestration de conteneurs"><meta name=twitter:card content="summary"><meta name=twitter:title content="Tâches"><meta name=twitter:description content="Solution professionnelle d’orchestration de conteneurs"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Interface web (Dashboard) Utilisation de la ligne de commande kubectl Configuration des Pods et des Conteneurs Exécution d'applications Executez des jobs Accéder aux applications dans un cluster Monitoring, Logging, and Debugging Accéder à l'API Kubernetes Utiliser TLS Administration d'un cluster Administration d'une fédération Gestion des applications avec état Gestion des démons cluster Gestion des GPU Gestion des HugePages A suivre Cette section de la documentation de Kubernetes contient des pages qui montrent comment effectuer des tâches individuelles."><meta property="og:description" content="Interface web (Dashboard) Utilisation de la ligne de commande kubectl Configuration des Pods et des Conteneurs Exécution d'applications Executez des jobs Accéder aux applications dans un cluster Monitoring, Logging, and Debugging Accéder à l'API Kubernetes Utiliser TLS Administration d'un cluster Administration d'une fédération Gestion des applications avec état Gestion des démons cluster Gestion des GPU Gestion des HugePages A suivre Cette section de la documentation de Kubernetes contient des pages qui montrent comment effectuer des tâches individuelles."><meta name=twitter:description content="Interface web (Dashboard) Utilisation de la ligne de commande kubectl Configuration des Pods et des Conteneurs Exécution d'applications Executez des jobs Accéder aux applications dans un cluster Monitoring, Logging, and Debugging Accéder à l'API Kubernetes Utiliser TLS Administration d'un cluster Administration d'une fédération Gestion des applications avec état Gestion des démons cluster Gestion des GPU Gestion des HugePages A suivre Cette section de la documentation de Kubernetes contient des pages qui montrent comment effectuer des tâches individuelles."><meta property="og:url" content="https://kubernetes.io/fr/docs/tasks/"><meta property="og:title" content="Tâches"><meta name=twitter:title content="Tâches"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/fr/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/fr/docs/>Documentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/blog/>Blog de Kubernetes</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/partners/>Partenaires</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/community/>Communauté</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/fr/case-studies/>Études de cas</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/fr/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/fr/docs/tasks/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/fr/docs/tasks/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/fr/docs/tasks/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/fr/docs/tasks/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/fr/docs/tasks/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Français (French)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tasks/>English</a>
<a class=dropdown-item href=/zh-cn/docs/tasks/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/tasks/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/tasks/>日本語 (Japanese)</a>
<a class=dropdown-item href=/de/docs/tasks/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/tasks/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/tasks/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/tasks/>Bahasa Indonesia</a>
<a class=dropdown-item href=/hi/docs/tasks/>हिन्दी (Hindi)</a>
<a class=dropdown-item href=/pl/docs/tasks/>Polski (Polish)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Version imprimable multipages.
<a href=# onclick="return print(),!1">Cliquer ici pour imprimer</a>.</p><p><a href=/fr/docs/tasks/>Retour à la version par défaut</a>.</p></div><h1 class=title>Tâches</h1><ul><li>1: <a href=#pg-57bf66f59d9a642b82eebeabbc66470b>Outils d'installation</a></li><ul><li>1.1: <a href=#pg-bbdc530b292ab4074d1dfe69feafb3e7>Installer et configurer kubectl</a></li><li>1.2: <a href=#pg-2142bfe0834f1bf8f47887f85adba495>Installer Minikube</a></li></ul><li>2: <a href=#pg-34a810f1516ad9d99b2697e36e9b0d0f>Administration d'un cluster</a></li><ul><li>2.1: <a href=#pg-8e16d69617b175d61e2e7a6e1642c9d6>Administration avec kubeadm</a></li><ul></ul><li>2.2: <a href=#pg-47be5dd51f686017f1766e6ec7aa6f41>Gestion de la mémoire du CPU et des ressources d'API</a></li><ul></ul><li>2.3: <a href=#pg-8c31aafd38fad5b0de0bd191758d6f93>Installation d'un fournisseur de politiques de réseau</a></li><ul></ul><li>2.4: <a href=#pg-9585dc0efb0450fd68728e7511754717>Développer un Cloud Controller Manager</a></li><li>2.5: <a href=#pg-ce4cd28c8feb9faa783e79b48af37961>Kubernetes cloud-controller-manager</a></li></ul><li>3: <a href=#pg-f5da33b976758a9183018c421eb83f58>Configuration des Pods et des conteneurs</a></li><ul><li>3.1: <a href=#pg-e6dd9300cf3a955f7cdfe77fb5d15292>Allouer des ressources mémoire aux conteneurs et aux pods</a></li><li>3.2: <a href=#pg-8555af270ae7122cc0464bab3f5d1609>Allouer des ressources CPU aux conteneurs et aux pods</a></li><li>3.3: <a href=#pg-904cea8c8efd5c0d33adbfe579ec2dd2>Configurer la qualité de service pour les pods</a></li><li>3.4: <a href=#pg-4219ac6ab56a3b88d20305083d57d03c>Affecter des ressources supplémentaires à un conteneur</a></li><li>3.5: <a href=#pg-484833fb880d1e179cc2965d15f84da5>Configurer un pod en utilisant un volume pour le stockage</a></li><li>3.6: <a href=#pg-2c0d882359718c4c69c67099bed2156c>Configurer les comptes de service pour les pods</a></li><li>3.7: <a href=#pg-d385b86a7cb496d3b1c3b2a47280ca70>Récupération d'une image d'un registre privé</a></li><li>3.8: <a href=#pg-eb54daf87df373096b5e830680194dfc>Configurer les Liveness, Readiness et Startup Probes</a></li><li>3.9: <a href=#pg-bbc17480da6d051c696489654c64064a>Assigner des pods aux nœuds</a></li><li>3.10: <a href=#pg-1e7baac1825631a5af5d2aebcf059249>Configurer l'initialisation du pod</a></li><li>3.11: <a href=#pg-ed34e761c3dbd00fa79577fa78e30020>Configurer un pod pour utiliser une ConfigMap</a></li><li>3.12: <a href=#pg-3d7b9cb24a647c36ba63f7a02ec49010>Partager l'espace de nommage des processus entre les conteneurs d'un Pod</a></li><li>3.13: <a href=#pg-1bb997c61a85de753d9994e7a312a291>Convertir un fichier Docker Compose en ressources Kubernetes</a></li></ul><li>4: <a href=#pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>Gérez vos objets Kubernetes</a></li><ul></ul><li>5: <a href=#pg-866924fa095f897ede8dfdcab9e97942>Injection des données dans les applications</a></li><ul></ul><li>6: <a href=#pg-a78a5e7e765fd8c49c8f7c0d72499f72>Exécution des applications</a></li><ul></ul><li>7: <a href=#pg-ca3bc4e31dfe46d5044a3b93eb804ee9>Exécution des jobs</a></li><ul></ul><li>8: <a href=#pg-b74b959f5a531003dd0653dfbfc2e88b>Accès aux applications dans un cluster</a></li><ul><li>8.1: <a href=#pg-777447042cd4e81df3fa5beb3357a485>Tableau de bord (Dashboard)</a></li><li>8.2: <a href=#pg-5a233e14205d77fe1294917d2da6f876>Configurer l'accès à plusieurs clusters</a></li><li>8.3: <a href=#pg-48e8f306f919c5b81265e265a2b76ab4>Lister toutes les images de conteneur exécutées dans un cluster</a></li></ul><li>9: <a href=#pg-f6a755efe831d24956501e4bcd49ff96>Monitoring, Logging et Debugging</a></li><ul><li>9.1: <a href=#pg-9713ac27b6d9e3034033200d968221f2>Obtenez un shell dans un conteneur en cours d'exécution</a></li></ul><li>10: <a href=#pg-fd78dc15c135dedc24438431769d4d5b>Extensions de Kubernetes</a></li><ul><li>10.1: <a href=#pg-5b9d7df11699e8cb1a5a4414ff770efe>Utilisation des ressources personnalisées</a></li><ul></ul></ul><li>11: <a href=#pg-d3c88a8663f58e9ec0bed73faff5b670>TLS</a></li><ul></ul><li>12: <a href=#pg-40e9293a348cfa50147082afc09ff77f>Fédération</a></li><ul><li>12.1: <a href=#pg-b61e5206fb2a30cabe2857ed4aaf7944>Administration du Control Plane de la fédération</a></li><ul></ul></ul><li>13: <a href=#pg-ba58efa15c6d46f10e34d799be220965>Gestion des démons du cluster</a></li><ul></ul><li>14: <a href=#pg-5266308e17490aeee8b018316bf47e03>Installation du catalogue de services</a></li><ul></ul></ul><div class=content><nav id=TableOfContents><ul><li><a href=#dashboard>Interface web (Dashboard)</a></li><li><a href=#utilisation-de-la-ligne-de-commande-kubectl>Utilisation de la ligne de commande kubectl</a></li><li><a href=#configuration-des-pods-et-des-conteneurs>Configuration des Pods et des Conteneurs</a></li><li><a href=#exécution-d-applications>Exécution d'applications</a></li><li><a href=#executez-des-jobs>Executez des jobs</a></li><li><a href=#accéder-aux-applications-dans-un-cluster>Accéder aux applications dans un cluster</a></li><li><a href=#monitoring-logging-and-debugging>Monitoring, Logging, and Debugging</a></li><li><a href=#accéder-à-l-api-kubernetes>Accéder à l'API Kubernetes</a></li><li><a href=#utiliser-tls>Utiliser TLS</a></li><li><a href=#administration-d-un-cluster>Administration d'un cluster</a></li><li><a href=#administration-d-une-fédération>Administration d'une fédération</a></li><li><a href=#gestion-des-applications-avec-état>Gestion des applications avec état</a></li><li><a href=#gestion-des-démons-cluster>Gestion des démons cluster</a></li><li><a href=#gestion-des-gpu>Gestion des GPU</a></li><li><a href=#gestion-des-hugepages>Gestion des HugePages</a></li><li><a href=#a-suivre>A suivre</a></li></ul></nav><p>Cette section de la documentation de Kubernetes contient des pages qui montrent comment effectuer des tâches individuelles.
Une page montre comment effectuer une seule chose, généralement en donnant une courte séquence d'étapes.</p><h2 id=dashboard>Interface web (Dashboard)</h2><p>Déployer et accéder au dashboard web de votre cluster pour vous aider à le gérer et administrer un cluster Kubernetes.</p><h2 id=utilisation-de-la-ligne-de-commande-kubectl>Utilisation de la ligne de commande kubectl</h2><p>Installez et configurez l’outil en ligne de commande <code>kubectl</code> utilisé pour gérer directement les clusters Kubernetes.</p><h2 id=configuration-des-pods-et-des-conteneurs>Configuration des Pods et des Conteneurs</h2><p>Effectuer des tâches de configuration courantes pour les pods et les conteneurs.</p><h2 id=exécution-d-applications>Exécution d'applications</h2><p>Effectuez des tâches courantes de gestion des applications, telles que les mises à jour progressives, l'injection de données dans les pods et la mise à l'échelle automatique des pods.</p><h2 id=executez-des-jobs>Executez des jobs</h2><p>Exécuter des jobs en utilisant un traitement parallèle</p><h2 id=accéder-aux-applications-dans-un-cluster>Accéder aux applications dans un cluster</h2><p>Configuration du load balancing, du port forwarding, ou mise en place d'un firewall ou la configuration DNS pour accéder aux applications dans un cluster.</p><h2 id=monitoring-logging-and-debugging>Monitoring, Logging, and Debugging</h2><p>Mettre en place le monitoring et le logging pour diagnostiquer un cluster ou debugguer une application conteneurisée.</p><h2 id=accéder-à-l-api-kubernetes>Accéder à l'API Kubernetes</h2><p>Apprenez diverses méthodes pour accéder directement à l'API Kubernetes.</p><h2 id=utiliser-tls>Utiliser TLS</h2><p>Configurer votre application pour faire confiance à et utiliser le certificat racine de votre Certificate Authority (CA).</p><h2 id=administration-d-un-cluster>Administration d'un cluster</h2><p>Apprenez les tâches courantes pour administrer un cluster.</p><h2 id=administration-d-une-fédération>Administration d'une fédération</h2><p>Configurez les composants dans une fédération de cluster.</p><h2 id=gestion-des-applications-avec-état>Gestion des applications avec état</h2><p>Effectuez des taches communes pour gérer des applications avec état, notamment la mise à l'échelle, la suppression et le debugging des objets StatefulSets.</p><h2 id=gestion-des-démons-cluster>Gestion des démons cluster</h2><p>Effectuez des tâches courantes pour gérer un DaemonSet, telles que la mise à jour progressive.</p><h2 id=gestion-des-gpu>Gestion des GPU</h2><p>Configurer des GPUs NVIDIA pour les utiliser dans des noeuds dans un cluster.</p><h2 id=gestion-des-hugepages>Gestion des HugePages</h2><p>Configuration des huge pages comme une ressource planifiable dans un cluster.</p><h2 id=a-suivre>A suivre</h2><p>Si vous souhaitez écrire une page, consultez
<a href=/docs/home/contribute/create-pull-request/>Création d'une PullRequest de documentation</a>.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-57bf66f59d9a642b82eebeabbc66470b>1 - Outils d'installation</h1></div><div class=td-content><h1 id=pg-bbdc530b292ab4074d1dfe69feafb3e7>1.1 - Installer et configurer kubectl</h1><div class=lead>Installation et configuration de kubectl</div><p>L'outil en ligne de commande de kubernetes, <a href=/docs/user-guide/kubectl/>kubectl</a>, vous permet d'exécuter des commandes dans les clusters Kubernetes. Vous pouvez utiliser kubectl pour déployer des applications, inspecter et gérer les ressources du cluster et consulter les logs. Pour une liste complète des opérations kubectl, voir <a href=/fr/docs/reference/kubectl/overview/>Aperçu de kubectl</a>.</p><h2 id=pré-requis>Pré-requis</h2><p>Vous devez utiliser une version de kubectl qui différe seulement d'une version mineure de la version de votre cluster. Par exemple, un client v1.2 doit fonctionner avec un master v1.1, v1.2 et v1.3. L'utilisation de la dernière version de kubectl permet d'éviter des problèmes imprévus.</p><h2 id=installer-kubectl-sur-linux>Installer kubectl sur Linux</h2><h3 id=installer-le-binaire-de-kubectl-avec-curl-sur-linux>Installer le binaire de kubectl avec curl sur Linux</h3><ol><li><p>Téléchargez la dernière release avec la commande :</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
</code></pre><p>Pour télécharger une version spécifique, remplacez <code>$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)</code> avec la version spécifique.</p><p>Par exemple, pour télécharger la version v1.25.0 sur Linux, tapez :</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/linux/amd64/kubectl
</code></pre></li><li><p>Rendez le binaire kubectl exécutable.</p><pre tabindex=0><code>chmod +x ./kubectl
</code></pre></li><li><p>Déplacez le binaire dans votre PATH.</p><pre tabindex=0><code>sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre></li><li><p>Testez pour vous assurer que la version que vous avez installée est à jour:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><h3 id=installation-à-l-aide-des-gestionnaires-des-paquets-natifs>Installation à l'aide des gestionnaires des paquets natifs</h3><ul class="nav nav-tabs" id=kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-install-0 role=tab aria-controls=kubectl-install-0 aria-selected=true>Ubuntu, Debian or HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-install-1 role=tab aria-controls=kubectl-install-1>CentOS, RHEL or Fedora</a></li></ul><div class=tab-content id=kubectl-install><div id=kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-install-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo apt-get update <span style=color:#666>&amp;&amp;</span> sudo apt-get install -y apt-transport-https
</span></span><span style=display:flex><span>curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb https://apt.kubernetes.io/ kubernetes-xenial main&#34;</span> | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
</span></span><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y kubectl
</span></span></code></pre></div></div><div id=kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-install-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo cat <span style=color:#b44>&lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
</span></span></span><span style=display:flex><span><span style=color:#b44>[kubernetes]
</span></span></span><span style=display:flex><span><span style=color:#b44>name=Kubernetes
</span></span></span><span style=display:flex><span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
</span></span></span><span style=display:flex><span><span style=color:#b44>enabled=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>repo_gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>sudo yum install -y kubectl
</span></span></code></pre></div></div></div><h3 id=installation-avec-des-gestionnaires-de-paquets-alternatifs>Installation avec des gestionnaires de paquets alternatifs</h3><ul class="nav nav-tabs" id=other-kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#other-kubectl-install-0 role=tab aria-controls=other-kubectl-install-0 aria-selected=true>Snap</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#other-kubectl-install-1 role=tab aria-controls=other-kubectl-install-1>Homebrew</a></li></ul><div class=tab-content id=other-kubectl-install><div id=other-kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=other-kubectl-install-0><p><p>Si vous êtes sur Ubuntu ou une autre distribution Linux qui supporte le gestionnaire de paquets <a href=https://snapcraft.io/docs/core/install>snap</a>, kubectl est disponible comme application <a href=https://snapcraft.io/>snap</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>snap install kubectl --classic
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div></div><div id=other-kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=other-kubectl-install-1><p><p>Si vous êtes sur Linux et que vous utiliser <a href=https://docs.brew.sh/Homebrew-on-Linux>Homebrew</a> comme gestionnaire de paquets, kubectl est disponible. <a href=https://docs.brew.sh/Homebrew-on-Linux#install>installation</a></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew install kubectl
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div></div></div><h2 id=installer-kubectl-sur-macos>Installer kubectl sur macOS</h2><h3 id=installer-le-binaire-kubectl-avec-curl-sur-macos>Installer le binaire kubectl avec curl sur macOS</h3><ol><li><p>Téléchargez la dernière version:</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl
</code></pre><p>Pour télécharger une version spécifique, remplacez <code>$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)</code> avec la version spécifique.</p><p>Par exemple, pour télécharger la version v1.25.0 sur macOS, tapez :</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/darwin/amd64/kubectl
</code></pre></li><li><p>Rendez le binaire kubectl exécutable.</p><pre tabindex=0><code>chmod +x ./kubectl
</code></pre></li><li><p>Déplacez le binaire dans votre PATH.</p><pre tabindex=0><code>sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre></li><li><p>Testez pour vous assurer que la version que vous avez installée est à jour:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><h3 id=installer-avec-homebrew-sur-macos>Installer avec Homebrew sur macOS</h3><p>Si vous êtes sur MacOS et que vous utilisez le gestionnaire de paquets <a href=https://brew.sh/>Homebrew</a>, vous pouvez installer kubectl avec Homebrew.</p><ol><li><p>Exécutez la commande d'installation:</p><pre tabindex=0><code>brew install kubectl 
</code></pre><p>ou</p><pre tabindex=0><code>brew install kubernetes-cli
</code></pre></li><li><p>Testez pour vous assurer que la version que vous avez installée est à jour:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><h3 id=installer-avec-macports-sur-macos>Installer avec Macports sur macOS</h3><p>Si vous êtes sur MacOS et que vous utilisez le gestionnaire de paquets <a href=https://macports.org/>Macports</a>, vous pouvez installer kubectl avec Macports.</p><ol><li><p>Exécuter la commande d'installation:</p><pre tabindex=0><code>sudo port selfupdate
sudo port install kubectl
</code></pre></li><li><p>Testez pour vous assurer que la version que vous avez installée est à jour:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><h2 id=installer-kubectl-sur-windows>Installer kubectl sur Windows</h2><h3 id=installer-le-binaire-kubectl-avec-curl-sur-windows>Installer le binaire kubectl avec curl sur Windows</h3><ol><li><p>Téléchargez la dernière version v1.25.0 depuis <a href=https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/windows/amd64/kubectl.exe>ce lien</a>.</p><p>Ou si vous avez <code>curl</code> installé, utilisez cette commande:</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/windows/amd64/kubectl.exe
</code></pre><p>Pour connaître la dernière version stable (par exemple, en scripting), jetez un coup d'oeil à <a href=https://storage.googleapis.com/kubernetes-release/release/stable.txt>https://storage.googleapis.com/kubernetes-release/release/stable.txt</a>.</p></li><li><p>Ajoutez le binaire dans votre PATH.</p></li><li><p>Testez pour vous assurer que la version que vous avez installée est à jour:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><div class="alert alert-info note callout" role=alert><strong>Note:</strong> <a href=https://docs.docker.com/docker-for-windows/#kubernetes>Docker Desktop pour Windows</a> ajoute sa propre version de <code>kubectl</code> au $PATH.
Si vous avez déjà installé Docker Desktop, vous devrez peut-être placer votre entrée PATH avant celle ajoutée par le programme d'installation de Docker Desktop ou supprimer le <code>kubectl</code> de Docker Desktop.</div><h3 id=installer-avec-powershell-de-psgallery>Installer avec Powershell de PSGallery</h3><p>Si vous êtes sous Windows et que vous utilisez le gestionnaire de paquets <a href=https://www.powershellgallery.com/>Powershell Gallery</a> , vous pouvez installer et mettre à jour kubectl avec Powershell.</p><ol><li><p>Exécutez les commandes d'installation (spécifier le <code>DownloadLocation</code>):</p><pre tabindex=0><code>Install-Script -Name install-kubectl -Scope CurrentUser -Force
install-kubectl.ps1 [-DownloadLocation &lt;path&gt;]
</code></pre><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si vous ne spécifiez pas un <code>DownloadLocation</code>, <code>kubectl</code> sera installé dans le répertoire temp de l'utilisateur.</div><p>Le programme d'installation creé <code>$HOME/.kube</code> qui est suivie par la création d'un fichier de configuration</p></li><li><p>Testez pour vous assurer que la version que vous avez installée est à jour:</p><pre tabindex=0><code>kubectl version --client
</code></pre><div class="alert alert-info note callout" role=alert><strong>Note:</strong> La mise à jour de l'installation s'effectue en réexécutant les deux commandes listées à l'étape 1.</div></li></ol><h3 id=installer-sur-windows-avec-chocolatey-ou-scoop>Installer sur Windows avec Chocolatey ou Scoop</h3><p>Pour installer kubectl sur Windows, vous pouvez utiliser le gestionnaire de paquets <a href=https://chocolatey.org>Chocolatey</a> ou l'installateur en ligne de commande <a href=https://scoop.sh>Scoop</a>.<ul class="nav nav-tabs" id=kubectl-win-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-win-install-0 role=tab aria-controls=kubectl-win-install-0 aria-selected=true>choco</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-win-install-1 role=tab aria-controls=kubectl-win-install-1>scoop</a></li></ul><div class=tab-content id=kubectl-win-install><div id=kubectl-win-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-win-install-0><p><pre><code>choco install kubernetes-cli
</code></pre></div><div id=kubectl-win-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-win-install-1><p><pre><code>scoop install kubectl
</code></pre></div></div>2. Testez pour vous assurer que la version que vous avez installée est à jour:</p><pre><code>```
kubectl version --client
```
</code></pre><ol start=3><li><p>Accédez à votre répertoire personnel:</p><pre tabindex=0><code>cd %USERPROFILE%
</code></pre></li><li><p>Créez le répertoire <code>.kube</code>:</p><pre tabindex=0><code>mkdir .kube
</code></pre></li><li><p>Allez dans le répertoire <code>.kube</code> que vous venez de créer:</p><pre tabindex=0><code>cd .kube
</code></pre></li><li><p>Configurez kubectl pour utiliser un remote cluster Kubernetes:</p><pre tabindex=0><code>New-Item config -type file
</code></pre><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Editez le fichier de configuration avec un éditeur de texte de votre choix, tel que Notepad.</div></li></ol><h2 id=télécharger-en-tant-qu-élément-du-sdk-google-cloud>Télécharger en tant qu'élément du SDK Google Cloud</h2><p>Vous pouvez installer kubectl en tant qu'élément du SDK Google Cloud.</p><ol><li><p>Installer <a href=https://cloud.google.com/sdk/>Google Cloud SDK</a>.</p></li><li><p>Exécutez la commande d'installation <code>kubectl</code>:</p><pre tabindex=0><code>gcloud components install kubectl
</code></pre></li><li><p>Testez pour vous assurer que la version que vous avez installée est à jour:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><h2 id=vérification-de-la-configuration-de-kubectl>Vérification de la configuration de kubectl</h2><p>Pour permettre à kubectl de trouver et d'accéder à un cluster Kubernetes, il lui faut un <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>fichier kubeconfig</a>, qui est créé automatiquement lorsque vous créez un cluster avec <a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a> ou en déployant un cluster Minikube avec succès. Par défaut, la configuration de kubectl est située sous <code>~/.kube/config</code>.</p><p>Vérifiez que kubectl est correctement configuré en obtenant l'état du cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><p>Si vous voyez une réponse avec une URL, kubectl est correctement configuré pour accéder à votre cluster.</p><p>Si vous voyez un message similaire à celui qui suit, kubectl n'est pas configuré correctement ou n'est pas capable de se connecter à un cluster Kubernetes.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
</span></span></code></pre></div><p>Si par exemple, vous avez l'intention d'exécuter un cluster Kubernetes sur votre machine (localement), vous aurez besoin d'un outil comme Minikube pour être installé en premier et exécuter à nouveau les commandes décrites ci-dessus.</p><p>Si kubectl cluster-info retourne la réponse en url mais que vous ne pouvez pas accéder à votre cluster, vous pouvez vérifier s'il est configuré correctement, en utilisant:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info dump
</span></span></code></pre></div><h2 id=configurations-kubectl-optionnelles>Configurations kubectl optionnelles</h2><h3 id=activation-de-l-auto-complétion-de-shell>Activation de l'auto-complétion de shell</h3><p>kubectl fournit un support d'auto-complétion pour Bash et Zsh, ce qui peut vous éviter beaucoup de temps de saisie.</p><p>Vous trouverez ci-dessous les étapes à suivre pour configurer l'auto-complétion pour Bash (y compris la différence entre Linux et MacOS) et Zsh.</p><ul class="nav nav-tabs" id=kubectl-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-autocompletion-0 role=tab aria-controls=kubectl-autocompletion-0 aria-selected=true>Bash sur Linux</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-1 role=tab aria-controls=kubectl-autocompletion-1>Bash sur macOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-2 role=tab aria-controls=kubectl-autocompletion-2>Zsh</a></li></ul><div class=tab-content id=kubectl-autocompletion><div id=kubectl-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-autocompletion-0><p><h3 id=introduction>Introduction</h3><p>Le script de complétion kubectl pour Bash peut être généré avec la commande <code>kubectl completion bash</code>. Sourcer le script de completion dans votre shell permet l'auto-complétion de kubectl.</p><p>En revanche, le script de complétion dépend de <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>, ce qui implique que vous devez d'abord installer ce logiciel (vous pouvez tester si vous avez déjà installé bash-completion en utilisant <code>type _init_completion</code>).</p><h3 id=installer-bash-completion>Installer bash-completion</h3><p>bash-completion est fourni par plusieurs gestionnaires de paquets (voir <a href=https://github.com/scop/bash-completion#installation>ici</a>). Vous pouvez l'installer avec <code>apt-get install bash-completion</code> or <code>yum install bash-completion</code>, etc.</p><p>Les commandes ci-dessus créent <code>/usr/share/bash-completion/bash_completion</code>, qui est le script principal de bash-completion. En fonction de votre gestionnaire de paquets, vous devez manuellement sourcer ce fichier dans votre <code>~/.bashrc</code>.</p><p>Il vous suffit de recharger votre shell et de lancer <code>type _init_completion</code>. Si la commande réussit, vous êtes déjà configuré, sinon ajoutez le suivant à votre fichier `~/.bashrc' :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>source</span> /usr/share/bash-completion/bash_completion
</span></span></code></pre></div><p>Rechargez votre shell et vérifiez que bash-completion est correctement installé en tapant <code>type _init_completion</code>.</p><h3 id=activer-l-auto-complétion-de-kubectl>Activer l'auto-complétion de kubectl</h3><p>Vous devez maintenant vérifier que le script de completion de kubectl est bien sourcé dans toutes vos sessions shell. Il y a deux façons de le faire:</p><ul><li><p>Sourcer le script de completion dans votre fichier <code>~/.bashrc</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div></li><li><p>Ajoutez le script de complétion dans le répertoire <code>/etc/bash_completion.d</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl completion bash &gt;/etc/bash_completion.d/kubectl
</span></span></code></pre></div></li><li><p>Si vous avez un alias pour kubectl, vous pouvez étendre la completion de votre shell pour fonctionner avec cet alias:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bashrc
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -o default -F __start_kubectl k&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div></li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> bash-completion source tous les scripts de completion dans <code>/etc/bash_completion.d</code>.</div><p>Les deux approches sont équivalentes. Après avoir rechargé votre shell, l'auto-complétion de kubectl devrait fonctionner.</p></div><div id=kubectl-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-1><p><h3 id=introduction>Introduction</h3><p>Le script de complétion kubectl pour Bash peut être généré avec la commande <code>kubectl completion bash</code>. Sourcer le script de completion dans votre shell permet l'auto-complétion de kubectl.</p><p>En revanche, le script de complétion dépend de <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>, ce qui implique que vous devez d'abord installer ce logiciel.</p><div class="alert alert-danger warning callout" role=alert><strong>Attention:</strong> macOS inclut Bash 3.2 par défaut. Le script de complétion kubectl nécessite Bash 4.1+ et ne fonctionne pas avec Bash 3.2. Une des solutions possibles est d'installer une version plus récente de Bash sous macOS (voir instructions <a href=https://itnext.io/upgrading-bash-on-macos-7138bd1066ba>ici</a>). Les instructions ci-dessous ne fonctionnent que si vous utilisez Bash 4.1+.</div><h3 id=installer-bash-completion>Installer bash-completion</h3><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Comme mentionné, ces instructions supposent que vous utilisez Bash 4.1+, ce qui signifie que vous installerez bash-completion v2 (contrairement à Bash 3.2 et bash-completion v1, auquel cas la complétion pour kubectl ne fonctionnera pas).</div><p>Vous pouvez tester si vous avez déjà installé bash-completion en utilisant <code>type _init_completion</code>. Si il n'est pas installé, vous pouvez installer bash-completion avec Homebrew:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew install bash-completion@2
</span></span></code></pre></div><p>Comme indiqué dans la sortie de <code>brew install</code> (section "Caveats"), ajoutez les lignes suivantes à votre fichier <code>~/.bashrc</code> ou <code>~/.bash_profile</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>BASH_COMPLETION_COMPAT_DIR</span><span style=color:#666>=</span><span style=color:#b44>&#34;/usr/local/etc/bash_completion.d&#34;</span>
</span></span><span style=display:flex><span><span style=color:#666>[[</span> -r <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span> <span style=color:#666>]]</span> <span style=color:#666>&amp;&amp;</span> . <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span>
</span></span></code></pre></div><p>Rechargez votre shell et vérifiez que bash-completion v2 est correctement installé avec <code>type _init_completion</code>.</p><h3 id=activer-l-auto-complétion-de-kubectl>Activer l'auto-complétion de kubectl</h3><p>Si vous n'avez pas installé via Homebrew, vous devez maintenant vous assurer que le script de complétion kubectl est bien sourcé dans toutes vos sessions shell comme suit:</p><ul><li><p>Sourcer le script de completion dans votre fichier <code>~/.bashrc</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div></li><li><p>Ajoutez le script de complétion dans le répertoire <code>/usr/local/etc/bash_completion.d</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl completion bash &gt;/usr/local/etc/bash_completion.d/kubectl
</span></span></code></pre></div></li><li><p>Si vous avez un alias pour kubectl, vous pouvez étendre la completion de votre shell pour fonctionner avec cet alias:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bashrc
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -o default -F __start_kubectl k&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div></li></ul><p>Si vous avez installé kubectl avec Homebrew (comme expliqué <a href=#installer-avec-homebrew-sur-macos>ici</a>), alors le script de complétion a été automatiquement installé dans <code>/usr/local/etc/bash_completion.d/kubectl</code>. Dans ce cas, vous n'avez rien à faire.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> L'installation Homebrew de bash-complétion v2 source tous les fichiers du répertoire <code>BASH_COMPLETION_COMPAT_DIR</code>, c'est pourquoi les deux dernières méthodes fonctionnent.</div><p>Après avoir rechargé votre shell, l'auto-complétion de kubectl devrait fonctionner.</p></div><div id=kubectl-autocompletion-2 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-2><p><p>Le script de complétion de kubectl pour Zsh peut être généré avec la commande <code>kubectl completion zsh</code>. Sourcer le script de completion dans votre shell permet l'auto-complétion de kubectl.</p><p>Pour faire ainsi dans toutes vos sessions shell, ajoutez ce qui suit à votre fichier <code>~/.zshrc</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>
</span></span></code></pre></div><p>Si vous avez un alias pour kubectl, vous pouvez étendre la completion de votre shell pour fonctionner avec cet alias:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.zshrc
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;compdef __start_kubectl k&#39;</span> &gt;&gt;~/.zshrc
</span></span></code></pre></div><p>Après avoir rechargé votre shell, l'auto-complétion de kubectl devrait fonctionner.</p><p>Si vous rencontrez une erreur comme <code>complete:13: command not found: compdef</code>, alors ajoutez ce qui suit au début de votre fichier <code>~/.zshrc</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>autoload -Uz compinit
</span></span><span style=display:flex><span>compinit
</span></span></code></pre></div></div></div><h2 id=a-suivre>A suivre</h2><ul><li><a href=/docs/tasks/tools/install-minikube/>Installer Minikube</a></li><li>Voir les <a href=/fr/docs/setup/>guides de démarrage</a> pour plus d'informations sur la création de clusters.</li><li><a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Apprenez comment lancer et exposer votre application</a></li><li>Si vous avez besoin d'accéder à un cluster que vous n'avez pas créé, consultez <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Partager l'accès du Cluster</a>.</li><li>Consulter les <a href=/fr/docs/reference/kubectl/kubectl/>documents de référence de kubectl</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2142bfe0834f1bf8f47887f85adba495>1.2 - Installer Minikube</h1><p>Cette page vous montre comment installer <a href=/fr/docs/tutorials/hello-minikube/>Minikube</a>, qui est un outil qui fait tourner un cluster Kubernetes à un noeud unique dans une machine virtuelle sur votre machine.</p><h2 id=pré-requis>Pré-requis</h2><ul class="nav nav-tabs" id=minikube-before-you-begin role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#minikube-before-you-begin-0 role=tab aria-controls=minikube-before-you-begin-0 aria-selected=true>Linux</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#minikube-before-you-begin-1 role=tab aria-controls=minikube-before-you-begin-1>macOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#minikube-before-you-begin-2 role=tab aria-controls=minikube-before-you-begin-2>Windows</a></li></ul><div class=tab-content id=minikube-before-you-begin><div id=minikube-before-you-begin-0 class="tab-pane show active" role=tabpanel aria-labelledby=minikube-before-you-begin-0><p><p>Pour vérifier si la virtualisation est prise en charge sur Linux, exécutez la commande suivante et vérifiez que la sortie n'est pas vide :</p><pre tabindex=0><code>grep -E --color &#39;vmx|svm&#39; /proc/cpuinfo
</code></pre></div><div id=minikube-before-you-begin-1 class=tab-pane role=tabpanel aria-labelledby=minikube-before-you-begin-1><p><p>Pour vérifier si la virtualisation est prise en charge sur macOS, exécutez la commande suivante sur votre terminal.</p><pre tabindex=0><code>sysctl -a | grep -E --color &#39;machdep.cpu.features|VMX&#39;
</code></pre><p>Si vous trouvez <code>VMX</code> dans la sortie, la fonction VT-x est supportée sur votre OS.</p></div><div id=minikube-before-you-begin-2 class=tab-pane role=tabpanel aria-labelledby=minikube-before-you-begin-2><p><p>Pour vérifier si la virtualisation est prise en charge sur Windows 8 et au-delà, exécutez la commande suivante sur votre terminal Windows ou à l'invite de commande.</p><pre tabindex=0><code>systeminfo
</code></pre><p>Si vous obtenez la sortie suivant, la virtualisation est prise en charge sur Windows.</p><pre tabindex=0><code>Hyper-V Requirements:     VM Monitor Mode Extensions: Yes
                          Virtualization Enabled In Firmware: Yes
                          Second Level Address Translation: Yes
                          Data Execution Prevention Available: Yes
</code></pre><p>Si vous voyez la sortie suivante, votre système a déjà un hyperviseur installé et vous pouvez ignorer l'étape suivante.</p><pre tabindex=0><code>Configuration requise pour Hyper-V: un hyperviseur a été détecté. Les fonctionnalités requises pour Hyper-V ne seront pas affichées.
</code></pre></div></div><h2 id=installer-minikube>Installer Minikube</h2><ul class="nav nav-tabs" id=tab-with-md role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-with-md-0 role=tab aria-controls=tab-with-md-0 aria-selected=true>Linux</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-md-1 role=tab aria-controls=tab-with-md-1>macOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-md-2 role=tab aria-controls=tab-with-md-2>Windows</a></li></ul><div class=tab-content id=tab-with-md><div id=tab-with-md-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-with-md-0><p><h3 id=installer-kubectl>Installer kubectl</h3><p>Installez kubectl en suivant les instructions de la section <a href=/fr/docs/tasks/tools/install-kubectl/#install-kubectl-on-linux>Installer et configurer kubectl</a>.</p><h3 id=installer-un-hyperviseur>Installer un hyperviseur</h3><p>Si vous n'avez pas déjà un hyperviseur installé, installez-le maintenant pour votre système d'exploitation :</p><p>• <a href=http://www.linux-kvm.org/>KVM</a>, qui utilise également QEMU</p><p>• <a href=https://www.virtualbox.org/wiki/Downloads>VirtualBox</a></p><p>Minikube supporte également une option <code>--vm-driver=none</code> qui exécute les composants Kubernetes sur la machine hôte et pas dans une VM.
L'utilisation de ce pilote nécessite <a href=https://www.docker.com/products/docker-desktop>Docker</a> et un environnement Linux mais pas un hyperviseur.</p><p>Si vous utilisez le pilote <code>none</code> dans Debian ou un dérivé, utilisez les paquets<code> .deb</code> pour
Docker plutôt que le package snap, qui ne fonctionne pas avec Minikube.
Vous pouvez télécharger les packages <code>.deb</code> depuis <a href=https://www.docker.com/products/docker-desktop>Docker</a>.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Le pilote VM <code>none</code> peut entraîner des problèmes de sécurité et de perte de données.
Avant d'utiliser <code>--driver=none</code>, consultez <a href=https://minikube.sigs.k8s.io/docs/reference/drivers/none/>cette documentation</a> pour plus d'informations.</div><p>Minikube prend également en charge un <code>vm-driver=podman</code> similaire au pilote Docker. Podman est exécuté en tant que superutilisateur (utilisateur root), c'est le meilleur moyen de garantir que vos conteneurs ont un accès complet à toutes les fonctionnalités disponibles sur votre système.</p><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Le pilote <code>podman</code> nécessite l’exécution des conteneurs en tant que root car les comptes d’utilisateurs normaux n’ont pas un accès complet à toutes les fonctionnalités du système d’exploitation que leurs conteneurs pourraient avoir besoin d’exécuter.</div><h3 id=installer-minikube-à-l-aide-d-un-package>Installer Minikube à l'aide d'un package</h3><p>Il existe des packages * expérimentaux * pour Minikube; vous pouvez trouver des packages Linux (AMD64)
depuis la page <a href=https://github.com/kubernetes/minikube/releases>releases</a> de Minikube sur GitHub.</p><p>Utilisez l'outil de package de votre distribution Linux pour installer un package approprié.</p><h3 id=installez-minikube-par-téléchargement-direct>Installez Minikube par téléchargement direct</h3><p>Si vous n'installez pas via un package, vous pouvez télécharger
un binaire autonome et l'utiliser.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> chmod +x minikube
</span></span></code></pre></div><p>Voici un moyen simple d'ajouter l'exécutable Minikube à votre path :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo mkdir -p /usr/local/bin/
</span></span><span style=display:flex><span>sudo install minikube /usr/local/bin/
</span></span></code></pre></div><h3 id=installer-minikube-en-utilisant-homebrew>Installer Minikube en utilisant Homebrew</h3><p>Une autre alternative, vous pouvez installer Minikube en utilisant Linux [Homebrew] (<a href=https://docs.brew.sh/Homebrew-on-Linux>https://docs.brew.sh/Homebrew-on-Linux</a>) :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew install minikube
</span></span></code></pre></div></div><div id=tab-with-md-1 class=tab-pane role=tabpanel aria-labelledby=tab-with-md-1><p><h3 id=installer-kubectl>Installer kubectl</h3><p>Installez kubectl en suivant les instructions de la section <a href=/fr/docs/tasks/tools/install-kubectl/#install-kubectl-on-macos>Installer et configurer kubectl</a>.</p><h3 id=installer-un-hyperviseur>Installer un hyperviseur</h3><p>Si vous n'avez pas encore installé d'hyperviseur, installez-en un maintenant :</p><p>• <a href=https://github.com/moby/hyperkit>HyperKit</a></p><p>• <a href=https://www.virtualbox.org/wiki/Downloads>VirtualBox</a></p><p>• <a href=https://www.vmware.com/products/fusion>VMware Fusion</a></p><h3 id=installer-minikube>Installer Minikube</h3><p>La façon la plus simple d'installer Minikube sur macOS est d'utiliser <a href=https://brew.sh>Homebrew</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew install minikube
</span></span></code></pre></div><p>Vous pouvez aussi l'installer sur macOS en téléchargeant un binaire statique :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> chmod +x minikube
</span></span></code></pre></div><p>Voici une façon simple d'ajouter l'exécutable de Minikube à votre path :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo mv minikube /usr/local/bin
</span></span></code></pre></div></div><div id=tab-with-md-2 class=tab-pane role=tabpanel aria-labelledby=tab-with-md-2><p><h3 id=installer-kubectl>Installer kubectl</h3><p>Installez kubectl en suivant les instructions de la section <a href=/fr/docs/tasks/tools/install-kubectl/#install-kubectl-on-windows>Installer et configurer kubectl</a>.</p><h3 id=installer-un-hyperviseur>Installer un hyperviseur</h3><p>Si vous n'avez pas encore installé d'hyperviseur, installez-en un maintenant :</p><p>• <a href=https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/quick_start/walkthrough_install>Hyper-V</a></p><p>• <a href=https://www.virtualbox.org/wiki/Downloads>VirtualBox</a></p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Hyper-V peut fonctionner sur trois versions de Windows 10: Windows 10 Entreprise, Windows 10 Professionnel et Windows 10 Éducation.</div><h3 id=installer-minikube-en-utilisant-chocolatey>Installer Minikube en utilisant Chocolatey</h3><p>La façon la plus simple d'installer Minikube sur Windows est d'utiliser <a href=https://chocolatey.org/>Chocolatey</a> (exécuté avec les droits administrateur) :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>choco install minikube
</span></span></code></pre></div><p>Une fois l'installation de Minikube terminée, fermez la session CLI en cours et redémarrez. Minikube devrait avoir été ajouté à votre path automatiquement.</p><h3 id=installer-minikube-avec-windows-installer>Installer Minikube avec Windows Installer</h3><p>Pour installer manuellement Minikube sur Windows à l'aide de <a href=https://docs.microsoft.com/en-us/windows/desktop/msi/windows-installer-portal>Windows Installer</a>, téléchargez <a href=https://github.com/kubernetes/minikube/releases/latest><code>minikube-installer.exe</code></a> et exécutez l'Installer.</p><h4 id=installer-minikube-manuellement>Installer Minikube manuellement</h4><p>Pour installer Minikube manuellement sur Windows, téléchargez <a href=https://github.com/kubernetes/minikube/releases/latest><code>minikube-windows-amd64</code></a>, renommez-le en <code>minikube.exe</code>, et ajoutez-le à votre path.</p></div></div><h2 id=confirmer-l-installation>Confirmer l'installation</h2><p>Pour confirmer la réussite de l'installation d'un hyperviseur et d'un mini-cube, vous pouvez exécuter la commande suivante pour démarrer un cluster Kubernetes local :</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Pour définir le <code>--driver</code> avec<code> minikube start</code>, entrez le nom de l'hyperviseur que vous avez installé en minuscules où <code>&lt;driver_name></code> est mentionné ci-dessous. Une liste complète des valeurs <code>--driver</code> est disponible dans <a href=https://kubernetes.io/docs/setup/learning-environment/minikube/#specifying-the-vm-driver>la documentation spécifiant le pilote VM</a>.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start --driver<span style=color:#666>=</span>&lt;driver_name&gt;
</span></span></code></pre></div><p>Une fois <code>minikube start</code> terminé, exécutez la commande ci-dessous pour vérifier l'état du cluster :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube status
</span></span></code></pre></div><p>Si votre cluster est en cours d'exécution, la sortie de <code>minikube status</code> devrait être similaire à :</p><pre tabindex=0><code>host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured
</code></pre><p>Après avoir vérifié si Minikube fonctionne avec l'hyperviseur choisi, vous pouvez continuer à utiliser Minikube ou arrêter votre cluster. Pour arrêter votre cluster, exécutez :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube stop
</span></span></code></pre></div><h2 id=tout-nettoyer-pour-recommencer-à-zéro>Tout nettoyer pour recommencer à zéro</h2><p>Si vous avez déjà installé minikube, exécutez :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start
</span></span></code></pre></div><p>Si cette commande renvoie une erreur :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>machine does not exist
</span></span></code></pre></div><p>Vous devez supprimer les fichiers de configuration :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>rm -rf ~/.minikube
</span></span></code></pre></div><h2 id=a-suivre>A suivre</h2><ul><li><a href=/fr/docs/setup/learning-environment/minikube/>Exécutez Kubernetes localement via Minikube</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-34a810f1516ad9d99b2697e36e9b0d0f>2 - Administration d'un cluster</h1></div><div class=td-content><h1 id=pg-8e16d69617b175d61e2e7a6e1642c9d6>2.1 - Administration avec kubeadm</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-47be5dd51f686017f1766e6ec7aa6f41>2.2 - Gestion de la mémoire du CPU et des ressources d'API</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-8c31aafd38fad5b0de0bd191758d6f93>2.3 - Installation d'un fournisseur de politiques de réseau</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-9585dc0efb0450fd68728e7511754717>2.4 - Développer un Cloud Controller Manager</h1><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div>Dans les prochaines versions, Cloud Controller Manager sera le moyen privilégié d’intégrer Kubernetes à n’importe quel cloud.
Cela garantira que les fournisseurs de cloud peuvent développer leurs fonctionnalités indépendamment des cycles de publication de Kubernetes.</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.8 [alpha]</code></div><p>Avant d’expliquer comment créer votre propre gestionnaire de contrôleur de cloud, il est utile d’avoir quelques informations sur son fonctionnement interne.
Le cloud controller manager est un code de <code>kube-controller-manager</code> utilisant des interfaces Go pour permettre la mise en œuvre d'implémentations depuis n'importe quel cloud.
La plupart des implémentations de contrôleurs génériques seront au cœur du projet, mais elles seront toujours exécutées sur les interfaces de cloud fournies, à condition que l'<a href=https://github.com/kubernetes/cloud-provider/blob/master/cloud.go#L42-L62>interface du fournisseur de cloud</a> soit satisfaite.</p><p>Pour approfondir un peu les détails de la mise en œuvre, tous les gestionnaires de contrôleurs de nuage vont importer des packages à partir de Kubernetes core, la seule différence étant que chaque projet enregistre son propre fournisseur de nuage en appelant <a href=https://github.com/kubernetes/cloud-provider/blob/master/plugins.go#L56-L66>cloudprovider.RegisterCloudProvider</a> où une variable globale des fournisseurs de cloud disponibles est mise à jour.</p><h2 id=développement>Développement</h2><h3 id=out-of-tree>Out of Tree</h3><p>Pour construire un out-of-tree cloud-controller-manager pour votre cloud, suivez ces étapes:</p><ol><li>Créez un package Go avec une implémentation satisfaisant<a href=https://github.com/kubernetes/cloud-provider/blob/master/cloud.go>cloudprovider.Interface</a>.</li><li>Utilisez <a href=https://github.com/kubernetes/kubernetes/blob/master/cmd/cloud-controller-manager/controller-manager.go>main.go dans cloud-controller-manager</a> de Kubernetes core en tant que modèle pour votre main.go. Comme mentionné ci-dessus, la seule différence devrait être le package cloud qui sera importé.</li><li>Importez votre paquet cloud dans <code>main.go</code>, assurez-vous que votre paquet a un bloc <code>init</code> à exécuter <a href=https://github.com/kubernetes/cloud-provider/blob/master/plugins.go>cloudprovider.RegisterCloudProvider</a>.</li></ol><p>Utiliser des exemples de fournisseurs de cloud out-of-tree peut être utile.
Vous pouvez trouver la liste <a href=/docs/tasks/administer-cluster/running-cloud-controller.md#examples>ici</a>.</p><h3 id=in-tree>In Tree</h3><p>Pour les cloud in-tree, vous pouvez exécuter le in-tree cloud controller manager comme un <a href=/examples/admin/cloud/ccm-example.yaml>Daemonset</a> dans votre cluster.
Voir la <a href=/docs/tasks/administer-cluster/running-cloud-controller.md>documentation sur l'exécution d'un cloud controller manager</a> pour plus de détails.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ce4cd28c8feb9faa783e79b48af37961>2.5 - Kubernetes cloud-controller-manager</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [beta]</code></div><p>Kubernetes v1.6 a introduit un nouveau binaire appelé <code>cloud-controller-manager</code>.
<code>cloud-controller-manager</code> est un démon qui intègre des boucles de contrôle spécifiques au cloud.
Ces boucles de contrôle spécifiques au cloud étaient à l’origine dans le binaire <code>kube-controller-manager</code>.
Étant donné que les fournisseurs de cloud développent et publient à un rythme différent de celui du projet Kubernetes, fournir une abstraction du code du <code>cloud-controller-manager</code> permet aux fournisseurs de cloud d’évoluer indépendamment du code Kubernetes principal.</p><p>Le <code>cloud-controller-manager</code> peut être lié à tout fournisseur de cloud satisfaisant l'interface <a href=https://github.com/kubernetes/cloud-provider/blob/master/cloud.go>cloudprovider.Interface</a>.
Pour des raisons de retro-compatibilité, le <a href=https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager>cloud-controller-manager</a> fourni dans le projet de base Kubernetes utilise les mêmes bibliothèques ​​que <code>kube-controller-manager</code>.
Les fournisseurs de cloud déjà pris en charge nativement par Kubernetes devraient utiliser le cloud-controller-manager ​disponible ​dans le code de Kubernetes pour effectuer une transition visant à faire sortir cette prise en charge du code de Kubernetes.
Dans les futures versions de Kubernetes, tous les cloud-controller-manager seront développés en dehors du projet de base de Kubernetes géré par des sig leads ou des fournisseurs de cloud.</p><h2 id=administration>Administration</h2><h3 id=pré-requis>Pré-requis</h3><p>Chaque cloud a ses propres exigences pour l'exécution de sa propre intégration, ces exigences sont similaires à celles requises pour l'exécution de <code>kube-controller-manager</code>.
En règle générale, vous aurez besoin de:</p><ul><li>cloud authentification/autorisation: votre cloud peut nécessiter un jeton ou des règles IAM pour permettre l'accès à leurs API</li><li>kubernetes authentification/autorisation: cloud-controller-manager peut avoir besoin de règles RBAC définies pour parler à l'apiserver kubernetes</li><li>la haute disponibilité: Comme pour kube-controller-manager, vous pouvez souhaiter une configuration hautement disponible pour le cloud controller mananger en utilisant l'élection de leader (activée par défaut).</li></ul><h3 id=lancer-cloud-controller-manager>Lancer cloud-controller-manager</h3><p>L'exécution réussie de cloud-controller-manager nécessite certaines modifications de la configuration de votre cluster.</p><ul><li><code>kube-apiserver</code> et <code>kube-controller-manager</code> NE DOIVENT PAS spécifier l'option <code>--cloud-provider</code>.
Cela garantit qu'il n'exécutera aucune boucle spécifique au cloud qui serait exécutée par le cloud-controller-manager.
À l'avenir, cet indicateur sera rendu obsolète et supprimé.</li><li><code>kubelet</code> doit s'exécuter avec <code>--cloud-provider=external</code>.
C’est pour nous assurer que le kubelet est conscient qu'il doit être initialisé par le cloud-controller-manager avant qu'il ne commence à travailler.</li></ul><p>N'oubliez pas que la configuration de votre cluster pour utiliser le cloud-controller-manager changera le comportement de votre cluster de plusieurs façons:</p><ul><li>Les kubelets lancés avec <code>--cloud-provider=external</code> auront un marquage <code>node.cloudprovider.kubernetes.io/uninitialized</code> avec un effet <code>NoSchedule</code> pendant l'initialisation.
Cela indique que le nœud nécessite une seconde initialisation à partir d'un contrôleur externe avant de pouvoir planifier un travail.
Notez que si le cloud-controller-manager n'est pas disponible, les nouveaux nœuds du cluster ne seront pas valides.
Le marquage est important car le planificateur peut nécessiter des informations spécifiques au cloud à propos des nœuds, telles que leur région ou leur type (CPU performant, gpu, mémoire importante, instance ponctuelle, etc.).</li><li>Les informations relatives aux nœuds s'exécutant dans le cloud ne seront plus récupérées à l'aide de métadonnées locales, mais tous les appels d'API pour récupérer les informations de ces nœuds passeront par le cloud-controller-manager.
Cela peut signifier que vous pouvez restreindre l'accès à votre API de cloud sur les kubelets pour une sécurité accrue.
Pour les clusters de plus grande taille, vous voudrez peut-être déterminer si le cloud-controller-manager atteindra les limites de requêtes sur les API de votre fournisseur de cloud puisqu'il est désormais responsable de la quasi-totalité des appels d'API vers votre cloud depuis le cluster.</li></ul><p>À partir de la version 1.8, le cloud-controller-manager peut implémenter:</p><ul><li>contrôleur de nœud - responsable de la mise à jour des nœud kubernetes à l’aide des API de cloud et de la suppression des nœud kubernetes supprimés sur votre cloud.</li><li>contrôleur de service - responsable des loadbalancers sur votre cloud vers des services de type LoadBalancer.</li><li>contrôleur de route - responsable de la configuration des routes réseau sur votre cloud</li><li>toute autre fonctionnalité que vous voudriez implémenter si vous exécutez en dehors de l'arborescence de Kubernetes.</li></ul><h2 id=exemples>Exemples</h2><p>Si vous utilisez un cloud actuellement pris en charge nativement dans Kubernetes et souhaitez adopter le cloud-controller-manager, reportez-vous à la section <a href=https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager>cloud-controller-manager dans kubernetes core</a>.</p><p>Pour les cloud-controller-manager ne faisant pas partie de Kubernetes, vous pouvez trouver les projets respectifs dans des dépôts maintenus par des fournisseurs de cloud ou des sig leads.</p><ul><li><a href=https://github.com/digitalocean/digitalocean-cloud-controller-manager>DigitalOcean</a></li><li><a href=https://github.com/munnerz/keepalived-cloud-provider>keepalived</a></li><li><a href=https://github.com/oracle/oci-cloud-controller-manager>Oracle Cloud Infrastructure</a></li><li><a href=https://github.com/rancher/rancher-cloud-controller-manager>Rancher</a></li><li><a href=https://github.com/scaleway/scaleway-cloud-controller-manager>Scaleway</a></li></ul><p>Pour les fournisseurs qui se trouvent déjà dans Kubernetes, vous pouvez exécuter le cloud-controller-manager dans l'arborescence en tant que Daemonset dans votre cluster.
Utilisez ce qui suit comme guide:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/admin/cloud/ccm-example.yaml download=admin/cloud/ccm-example.yaml><code>admin/cloud/ccm-example.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-cloud-ccm-example-yaml")' title="Copy admin/cloud/ccm-example.yaml to clipboard"></img></div><div class=includecode id=admin-cloud-ccm-example-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># Voici un exemple de configuration de cloud-controller-manager en tant que Daemonset dans votre cluster.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Il suppose que vos masters peuvent executer des pods et ont le role node-role.kubernetes.io/master</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Notez que ce Daemonset ne fonctionnera pas directement pour votre cloud, c’est juste un exemple.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster-admin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># pour les fournisseurs in-tree, nous utilisons k8s.gcr.io/cloud-controller-manager</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># cela peut être remplacé par n&#39;importe quelle autre image pour les fournisseurs out-of-tree</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/cloud-controller-manager:v1.8.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- /usr/local/bin/cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- --cloud-provider=&lt;YOUR_CLOUD_PROVIDER&gt;  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Ajoutez votre propre fournisseur de cloud ici!</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- --leader-elect=true<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- --use-service-account-credentials<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ces drapeaux varient pour chaque fournisseur de cloud</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- --allocate-node-cidrs=true<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- --configure-cloud-routes=true<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- --cluster-cidr=172.17.0.0/16<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># cela est nécessaire pour que CCM puisse s&#39;initialiser</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node.cloudprovider.kubernetes.io/uninitialized<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># le daemonset doit pouvoir être exécuté sur les nœuds master. Le marquage peut varier en fonction de la configuration de votre cluster.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ceci limite le fonctionnement du CCM sur des nœuds master</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># le sélecteur de nœud peut varier en fonction de la configuration de votre cluster</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>node-role.kubernetes.io/master</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h2 id=limitations>Limitations</h2><p>L'exécution du cloud-controller-manager est soumise à quelques limitations.
Bien que ces limitations soient levées dans les prochaines versions, il est important que vous connaissiez ces limitations pour les charges de travail de production.</p><h3 id=prise-en-charge-des-volumes>Prise en charge des volumes</h3><p>Le cloud-controller-manager n'implémente aucun des contrôleurs de volume trouvés dans <code>kube-controller-manager</code> car les intégrations de volume nécessitent également une coordination avec les kubelets.
Au fur et à mesure de l'évolution de CSI (interface de stockage de conteneur) et de la prise en charge renforcée des plug-ins de volume flexible, le cloud-controller-manager prendra en charge le support nécessaire afin que les clouds puissent pleinement s'intégrer aux volumes.
Pour en savoir plus sur les plug-ins de volume CSI en dehors des sources de Kubernetes consultez <a href=https://github.com/kubernetes/features/issues/178>ceci</a>.</p><h3 id=charge-sur-les-apis-cloud>Charge sur les APIs cloud</h3><p>Dans l'architecture précédente pour les fournisseurs de cloud, nous utilisions des kubelets utilisant un service de métadonnées local pour extraire des informations sur les nœuds.
Avec cette nouvelle architecture, nous comptons désormais entièrement sur les cloud-controller-manager pour extraire les informations de tous les nœuds.
Pour les très grand clusters, vous devez envisager les goulots d'étranglement tels que les besoins en ressources et la limitation de la vitesse des APIs de votre fournisseur cloud.</p><h3 id=problème-de-l-oeuf-et-de-la-poule>Problème de l'oeuf et de la poule</h3><p>L'objectif du projet des cloud-controller-manager est de dissocier le développement des fonctionnalités de cloud computing du projet de base Kubernetes.
Malheureusement, de nombreux aspects du projet Kubernetes supposent que les fonctionnalités de fournisseur de cloud soient étroitement intégrées au projet.
Par conséquent, l'adoption de cette nouvelle architecture peut créer plusieurs situations dans lesquelles une demande d'informations auprès d'un fournisseur de cloud est demandée, mais le cloud-controller-manager peut ne pas être en mesure de renvoyer ces informations sans que la demande d'origine soit complète.</p><p>La fonctionnalité d’amorçage TLS dans Kubelet en est un bon exemple.
Actuellement, l’amorçage TLS suppose que Kubelet aie la possibilité de demander au fournisseur de cloud (ou à un service de métadonnées local) tous ses types d’adresses (privé, public, etc.), mais le cloud-controller-manager ne peut pas définir les types d’adresse d’un nœud sans être initialisé dans le système. Ce qui nécessite que le kubelet possède des certificats TLS pour communiquer avec l’apiserver.</p><p>À mesure que cette initiative évoluera, des modifications seront apportées pour résoudre ces problèmes dans les prochaines versions.</p><h2 id=développer-votre-propre-cloud-controller-manager>Développer votre propre cloud-controller-manager</h2><p>Pour créer et développer votre propre cloud-controller-manager, lisez la documentation <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager.md>Développer un cloud-controller-manager</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f5da33b976758a9183018c421eb83f58>3 - Configuration des Pods et des conteneurs</h1></div><div class=td-content><h1 id=pg-e6dd9300cf3a955f7cdfe77fb5d15292>3.1 - Allouer des ressources mémoire aux conteneurs et aux pods</h1><p>Cette page montre comment assigner une mémoire <em>request</em> et une mémoire <em>limit</em> à un conteneur. Un conteneur est garanti d'avoir autant de mémoire qu'il le demande, mais n'est pas autorisé à consommer plus de mémoire que sa limite.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><p>Chaque nœud de votre cluster doit avoir au moins 300 MiB de mémoire.</p><p>Pour quelques étapes de cette page, vous devez lancer
[metrics-server] (<a href=https://github.com/kubernetes-incubator/metrics-server>https://github.com/kubernetes-incubator/metrics-server</a>)
dans votre cluster. Si vous avez déjà metrics-server vous pouvez sauter ces étapes.</p><p>Si vous utilisez Minikube, exécutez la commande suivante pour activer metrics-server :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> metrics-server
</span></span></code></pre></div><p>Pour voir si le metrics-server fonctionne, ou un autre fournisseur de l'API des métriques de ressources (<code>metrics.k8s.io</code>), exécutez la commande suivante :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get apiservices
</span></span></code></pre></div><p>Si l'API des métriques de ressources est disponible, la sortie inclura une référence à <code>metrics.k8s.io</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME
</span></span><span style=display:flex><span>v1beta1.metrics.k8s.io
</span></span></code></pre></div><h2 id=créer-un-namespace>Créer un namespace</h2><p>Créez un namespace de manière à ce que les ressources que vous créez dans cet exercice soient isolées du reste de votre cluster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace mem-example
</span></span></code></pre></div><h2 id=spécifier-une-demande-de-mémoire-et-une-limite-de-mémoire>Spécifier une demande de mémoire et une limite de mémoire</h2><p>Pour spécifier une demande de mémoire pour un conteneur, incluez le champ <code>resources:requests</code>.
dans le manifeste des ressources du conteneur. Pour spécifier une limite de mémoire, incluez <code>resources:limits</code>.</p><p>Dans cet exercice, vous créez un pod qui possède un seul conteneur. Le conteneur dispose d'une demande de mémoire de 100 MiB et une limite de mémoire de 200 MiB. Voici le fichier de configuration
pour le Pod :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/resource/memory-request-limit.yaml download=pods/resource/memory-request-limit.yaml><code>pods/resource/memory-request-limit.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-yaml")' title="Copy pods/resource/memory-request-limit.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>La section <code>args</code> de votre fichier de configuration fournit des arguments pour le conteneur lorsqu'il démarre.
Les arguments <code>"--vm-bytes", "150M"</code> indiquent au conteneur d'allouer 150 MiB de mémoire.</p><p>Créez le Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Vérifiez que le Pod fonctionne :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Consultez des informations détaillées sur le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>La sortie montre que le conteneur dans le Pod a une demande de mémoire de 100 MiB et une limite de mémoire de 200 MiB.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Exécutez <code>kubectl top</code> pour récupérer les métriques du pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl top pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>La sortie montre que le Pod utilise environ 162.900.000 bytes de mémoire, qui est d'environ 150 MiB. Ce qui est supérieur à la demande de 100 MiB du Pod, mais ne dépassant pas la limite de 200 Mio de Pod.</p><pre tabindex=0><code>NAME                        CPU(cores)   MEMORY(bytes)
memory-demo                 &lt;something&gt;  162856960
</code></pre><p>Supprimez votre Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=dépasser-la-limite-de-mémoire-d-un-conteneur>Dépasser la limite de mémoire d'un conteneur</h2><p>Un conteneur peut dépasser sa demande de mémoire si le nœud dispose de la mémoire disponible. Cependant, un conteneur n'est pas autorisé à utiliser plus que sa limite de mémoire. Si un conteneur alloue plus de mémoire que sa limite, le Conteneur devient un candidat à la terminaison. Si le conteneur continue à consommer de la mémoire au-delà de sa limite, le conteneur est arrêté.
Si un conteneur terminé peut être redémarré, le kubelet le redémarre, comme pour tout autre type d'échec d'exécution.</p><p>Dans cet exercice, vous créez un Pod qui tente d'allouer plus de mémoire que sa limite.
Voici le fichier de configuration d'un Pod qui contient un conteneur avec une demande de mémoire de 50 MiB et une limite de mémoire de 100 MiB :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/resource/memory-request-limit-2.yaml download=pods/resource/memory-request-limit-2.yaml><code>pods/resource/memory-request-limit-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-2-yaml")' title="Copy pods/resource/memory-request-limit-2.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;250M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dans la section <code>args</code> du fichier de configuration, vous pouvez voir que le conteneur
tentera d'allouer 250 MiB de mémoire, ce qui est bien au-dessus de la limite de 100 MiB.</p><p>Créez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-2.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Consultez des informations détaillées sur le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>A ce niveau, le conteneur est soit en train de tourner, soit stoppé. Répétez la commande précédente jusqu'à ce que le conteneur soit terminé :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME            READY     STATUS      RESTARTS   AGE
</span></span><span style=display:flex><span>memory-demo-2   0/1       OOMKilled   <span style=color:#666>1</span>          24s
</span></span></code></pre></div><p>Obtenez une vue plus détaillée de l'état du conteneur :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>La sortie indique que le conteneur a été stoppé suite à un manque de mémoire (OOM) :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>lastState:
</span></span><span style=display:flex><span>   terminated:
</span></span><span style=display:flex><span>     containerID: docker://65183c1877aaec2e8427bc95609cc52677a454b56fcb24340dbd22917c23b10f
</span></span><span style=display:flex><span>     exitCode: <span style=color:#666>137</span>
</span></span><span style=display:flex><span>     finishedAt: 2017-06-20T20:52:19Z
</span></span><span style=display:flex><span>     reason: OOMKilled
</span></span><span style=display:flex><span>     startedAt: null
</span></span></code></pre></div><p>Le conteneur dans cet exercice pourra être redémarré, ainsi le kubelet le redémarre. Répéter
cette commande plusieurs fois pour s'assurer que le conteneur est stoppé et redémarré d'une manière répététive :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>La sortie permet de voir que le conteneur est stoppé, redémarré, stoppé à nouveau, redémarré, et ainsi de suite :</p><pre tabindex=0><code>kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   1          37s
</code></pre><pre tabindex=0><code>
kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-2   1/1       Running   2          40s
</code></pre><p>Affichez des informations détaillées sur l'historique du Pod :</p><pre tabindex=0><code>kubectl describe pod memory-demo-2 --namespace=mem-example
</code></pre><p>La sortie indique que le conteneur se démarre et échoue continuellement :</p><pre tabindex=0><code>... Normal  Created   Created container with id 66a3a20aa7980e61be4922780bf9d24d1a1d8b7395c09861225b0eba1b1f8511
... Warning BackOff   Back-off restarting failed container
</code></pre><p>Affichez des informations détaillées sur les nœuds de votre cluster :</p><pre tabindex=0><code>kubectl describe nodes
</code></pre><p>La sortie inclut un enregistrement de la mise à mort du conteneur suite à une condition hors mémoire :</p><pre tabindex=0><code>Warning OOMKilling Memory cgroup out of memory: Kill process 4481 (stress) score 1994 or sacrifice child
</code></pre><p>Supprimez votre Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=spécifiez-une-demande-de-mémoire-trop-volumineuse-pour-vos-nœuds>Spécifiez une demande de mémoire trop volumineuse pour vos nœuds.</h2><p>Les demandes de mémoire et les limites sont associées aux conteneurs, mais il est utile de réfléchir avant tout à la capacité de demande et limite mémoire des pods.
La demande de mémoire pour le Pod est la somme des demandes de mémoire pour tous ses conteneurs. De même, la mémoire limite pour le Pod est la somme des limites de tous ses Conteneurs.</p><p>L'ordonnancement des modules est basé sur les demandes. Un Pod est schedulé pour se lancer sur un Nœud uniquement si le Nœud dispose de suffisamment de mémoire disponible pour répondre à la demande de mémoire du Pod.</p><p>Dans cet exercice, vous allez créer un Pod dont la demande de mémoire est si importante qu'elle dépasse la capacité de la mémoire de n'importe quel nœud de votre cluster. Voici le fichier de configuration d'un Pod qui possède un seul conteneur avec une demande de 1000 GiB de mémoire, qui dépasse probablement la capacité de tous les nœuds de votre cluster.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/resource/memory-request-limit-3.yaml download=pods/resource/memory-request-limit-3.yaml><code>pods/resource/memory-request-limit-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-3-yaml")' title="Copy pods/resource/memory-request-limit-3.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Créez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-3.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Affichez l'état du Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>La sortie indique que l'état du Pod est PENDING. En d'autres termes, le Pod n'est pas programmé pour tourner sur aucun Nœud, et il restera indéfiniment dans l'état PENDING :</p><pre tabindex=0><code>kubectl get pod memory-demo-3 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-3   0/1       Pending   0          25s
</code></pre><p>Affichez des informations détaillées sur le Pod, y compris les événements :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>La sortie indique que le conteneur ne peut pas être planifié par manque de mémoire sur les nœuds :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  ...  Reason            Message
</span></span><span style=display:flex><span>       ------            -------
</span></span><span style=display:flex><span>  ...  FailedScheduling  No nodes are available that match all of the following predicates:: Insufficient memory <span style=color:#666>(</span>3<span style=color:#666>)</span>.
</span></span></code></pre></div><h2 id=unités-de-mémoire>Unités de mémoire</h2><p>La ressource mémoire est mesurée en bytes. Vous pouvez exprimer la mémoire sous la forme d'un nombre entier simple ou d'un nombre avec l'un de ces suffixes : E, P, T, G, M, K, Ei, Pi, Ti, Gi, Mi, Ki.
Par exemple, les valeurs suivantes représentent approximativement la même valeur :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M , 123Mi
</span></span></code></pre></div><p>Supprimez votre Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=si-vous-ne-spécifiez-pas-de-limite-de-mémoire>Si vous ne spécifiez pas de limite de mémoire</h2><p>Si vous ne spécifiez pas de limite de mémoire pour un conteneur, l'une des situations suivantes s'applique :</p><ul><li><p>Le conteneur n'a pas de limite maximale quant à la quantité de mémoire qu'il utilise. Le conteneur
pourrait utiliser toute la mémoire disponible sur le nœud où il est en cours d'exécution, ce qui pourrait à son tour invoquer le OOM killer. De plus, dans le cas d'un OOM Kill, un conteneur sans limite de ressources aura plus de chance d'être stoppé.</p></li><li><p>Le conteneur s'exécute dans un namespace qui a une limite de mémoire par défaut, d'ou le conteneur est automatiquement affecté cette limite par defaut. Les administrateurs du cluster peuvent utiliser un <a href=/docs/reference/generated/kubernetes-api/v1.25/#limitrange-v1-core>LimitRange</a>
pour spécifier une valeur par défaut pour la limite de mémoire.</p></li></ul><h2 id=motivation-pour-les-demandes-et-les-limites-de-mémoire>Motivation pour les demandes et les limites de mémoire</h2><p>En configurant les demandes de mémoire et les limites pour les conteneurs qui s'exécutent dans votre cluster.
vous pouvez utiliser efficacement les ressources mémoire disponibles sur les noeuds de votre cluster. En gardant la demande de mémoire d'un Pod basse, vous donnez au Pod une bonne chance d'être schedulé. En ayant une limite de mémoire supérieure à la demande de mémoire, vous accomplissez deux choses :</p><ul><li>Le Pod peut avoir des éclats d'activités où il fait usage de la mémoire qui se trouve être disponible.</li><li>La quantité de mémoire qu'un Pod peut utiliser pendant un éclat d'activité est limitée à une quantité raisonnable.</li></ul><h2 id=clean-up>Clean up</h2><p>Supprimez votre namespace. Ceci va supprimer tous les Pods que vous avez créés dans cet exercice :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace mem-example
</span></span></code></pre></div><h2 id=a-suivre>A suivre</h2><h3 id=pour-les-développeurs-d-applications>Pour les développeurs d'applications</h3><ul><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>Allocation des ressources CPU aux conteneurs et pods</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/quality-service-pod/>Configuration de la qualité de service pour les pods</a></p></li></ul><h3 id=pour-les-administrateurs-de-cluster>Pour les administrateurs de cluster</h3><ul><li><p><a href=/docs/tasks/administer-cluster/memory-default-namespace/>Configuration des demandes et des limites de mémoire par défaut pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/cpu-default-namespace/>Configuration des demandes et des limites par défaut de CPU pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/memory-constraint-namespace/>Configuration des contraintes de mémoire minimales et maximales pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/cpu-constraint-namespace/>Configuration des contraintes minimales et maximales du CPU pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-memory-cpu-namespace/>Configuration des quotas de mémoire et de CPU pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-pod-namespace/>Configuration du quota de pods pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>Configuration des quotas pour les objets API</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8555af270ae7122cc0464bab3f5d1609>3.2 - Allouer des ressources CPU aux conteneurs et aux pods</h1><p>Cette page montre comment assigner une <em>demande</em> (request en anglais) de CPU et une <em>limite</em> de CPU à un conteneur.
Un conteneur est garanti d'avoir autant de CPU qu'il le demande, mais n'est pas autorisé à utiliser plus de CPU que sa limite.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><p>Chaque nœud de votre cluster doit avoir au moins 1 CPU.</p><p>Pour certaines des étapes de cette page, vous devez lancer <a href=https://github.com/kubernetes-incubator/metrics-server>metrics-server</a> dans votre cluster. Si le serveur de métriques est déja lancé,
vous pouvez sauter ces étapes.</p><p>Si vous utilisez minikube, exécutez la commande suivante pour activer metrics-server :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> metrics-server
</span></span></code></pre></div><p>Pour voir si metrics-server (ou un autre fournisseur de l'API des métriques de ressources <code>metrics.k8s.io</code>) est lancé, tapez la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get apiservices
</span></span></code></pre></div><p>Si l'API de métriques de ressources est disponible, la sortie inclura une
référence à <code>metrics.k8s.io</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME
</span></span><span style=display:flex><span>v1beta1.metrics.k8s.io
</span></span></code></pre></div><h2 id=créer-un-namespace>Créer un namespace</h2><p>Créez un namespace de manière à ce que les ressources que vous créez dans cet exercice soient isolés du reste de votre cluster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace cpu-example
</span></span></code></pre></div><h2 id=spécifier-une-demande-de-cpu-et-une-limite-de-cpu>Spécifier une demande de CPU et une limite de CPU</h2><p>Pour spécifier une demande de CPU pour un conteneur, incluez le champ <code>resources:requests</code>.
dans le manifeste des ressources du conteneur. Pour spécifier une limite de CPU, incluez <code>resources:limits</code>.</p><p>Dans cet exercice, vous allez créer un Pod qui a un seul conteneur. Le conteneur a une demande de 0.5 CPU et une limite de 1 CPU. Voici le fichier de configuration du Pod :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/resource/cpu-request-limit.yaml download=pods/resource/cpu-request-limit.yaml><code>pods/resource/cpu-request-limit.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-cpu-request-limit-yaml")' title="Copy pods/resource/cpu-request-limit.yaml to clipboard"></img></div><div class=includecode id=pods-resource-cpu-request-limit-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0.5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>La section <code>args</code> du fichier de configuration fournit des arguments pour le conteneur lorsqu'il démarre. L'argument <code>-cpus "2"</code> demande au conteneur d'utiliser 2 CPUs.</p><p>Créez le Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit.yaml --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>Vérifiez que le Pod fonctionne :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>Consultez des informations détaillées sur le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>La sortie indique que le conteneur dans le Pod a une demande CPU de 500 milliCPU.
et une limite de CPU de 1 CPU.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span></code></pre></div><p>Utilisez <code>kubectl top</code> pour récupérer les métriques du pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl top pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>La sortie montre que le Pod utilise 974 milliCPU, ce qui est légèrement inférieur à
la limite de 1 CPU spécifiée dans le fichier de configuration du Pod.</p><pre tabindex=0><code>NAME                        CPU(cores)   MEMORY(bytes)
cpu-demo                    974m         &lt;something&gt;
</code></pre><p>Souvenez-vous qu'en réglant <code>-cpu "2"</code>, vous avez configuré le conteneur pour faire en sorte qu'il utilise 2 CPU, mais que le conteneur ne peut utiliser qu'environ 1 CPU. L'utilisation du CPU du conteneur est entravée, car le conteneur tente d'utiliser plus de ressources CPU que sa limite.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Une autre explication possible de la restriction du CPU est que le Nœud pourrait ne pas avoir
suffisamment de ressources CPU disponibles. Rappelons que les conditions préalables à cet exercice exigent que chacun de vos Nœuds doit avoir au moins 1 CPU.
Si votre conteneur fonctionne sur un nœud qui n'a qu'un seul CPU, le conteneur ne peut pas utiliser plus que 1 CPU, quelle que soit la limite de CPU spécifiée pour le conteneur.</div><h2 id=unités-de-cpu>Unités de CPU</h2><p>La ressource CPU est mesurée en unités <em>CPU</em>. Un CPU, à Kubernetes, est équivalent à:</p><ul><li>1 AWS vCPU</li><li>1 GCP Core</li><li>1 Azure vCore</li><li>1 Hyperthread sur un serveur physique avec un processeur Intel qui a de l'hyperthreading.</li></ul><p>Les valeurs fractionnelles sont autorisées. Un conteneur qui demande 0,5 CPU est garanti deux fois moins CPU par rapport à un conteneur qui demande 1 CPU. Vous pouvez utiliser le suffixe m pour signifier milli. Par exemple 100m CPU, 100 milliCPU, et 0.1 CPU sont tous égaux. Une précision plus fine que 1m n'est pas autorisée.</p><p>Le CPU est toujours demandé en tant que quantité absolue, jamais en tant que quantité relative, 0.1 est la même quantité de CPU sur une machine single-core, dual-core ou 48-core.</p><p>Supprimez votre pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><h2 id=spécifier-une-demande-de-cpu-trop-élevée-pour-vos-nœuds>Spécifier une demande de CPU trop élevée pour vos nœuds.</h2><p>Les demandes et limites de CPU sont associées aux conteneurs, mais il est utile de réfléchir à la demande et à la limite de CPU d'un pod. La demande de CPU pour un Pod est la somme des demandes de CPU pour tous les conteneurs du Pod. De même, la limite de CPU pour les un Pod est la somme des limites de CPU pour tous les conteneurs du Pod.</p><p>L'ordonnancement des pods est basé sur les demandes. Un Pod est prévu pour se lancer sur un Nœud uniquement si le nœud dispose de suffisamment de ressources CPU pour satisfaire la demande de CPU du Pod.</p><p>Dans cet exercice, vous allez créer un Pod qui a une demande de CPU si importante qu'elle dépassera la capacité de n'importe quel nœud de votre cluster. Voici le fichier de configuration d'un Pod
qui a un seul conteneur. Le conteneur nécessite 100 CPU, ce qui est susceptible de dépasser la capacité de tous les nœuds de votre cluster.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/resource/cpu-request-limit-2.yaml download=pods/resource/cpu-request-limit-2.yaml><code>pods/resource/cpu-request-limit-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-cpu-request-limit-2-yaml")' title="Copy pods/resource/cpu-request-limit-2.yaml to clipboard"></img></div><div class=includecode id=pods-resource-cpu-request-limit-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Créez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit-2.yaml --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>Affichez l'état du Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>La sortie montre que l'état du Pod est en attente. En d'autres termes, le Pod n'a pas été
planifié pour tourner sur n'importe quel Nœud, et il restera à l'état PENDING indéfiniment :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</span></span><span style=display:flex><span>NAME         READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>cpu-demo-2   0/1       Pending   <span style=color:#666>0</span>          7m
</span></span></code></pre></div><p>Afficher des informations détaillées sur le Pod, y compris les événements:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>la sortie signale que le conteneur ne peut pas être planifié en raison d'une quantité insuffisante de ressources de CPU sur les Nœuds :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Reason			Message
</span></span><span style=display:flex><span>  ------			-------
</span></span><span style=display:flex><span>  FailedScheduling	No nodes are available that match all of the following predicates:: Insufficient cpu <span style=color:#666>(</span>3<span style=color:#666>)</span>.
</span></span></code></pre></div><p>Supprimez votre Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><h2 id=si-vous-ne-spécifiez-pas-de-limite-cpu>Si vous ne spécifiez pas de limite CPU</h2><p>Si vous ne spécifiez pas de limite CPU pour un conteneur, une de ces situations s'applique :</p><ul><li><p>Le conteneur n'a pas de limite maximale quant aux ressources CPU qu'il peut utiliser. Le conteneur
pourrait utiliser toutes les ressources CPU disponibles sur le nœud où il est lancé.</p></li><li><p>Le conteneur est lancé dans un namespace qui a une limite par défaut de CPU, ainsi le conteneur reçoit automatiquement cette limite par défaut. Les administrateurs du cluster peuvent utiliser un
<a href=/docs/reference/generated/kubernetes-api/v1.25/#limitrange-v1-core/>LimitRange</a>
pour spécifier une valeur par défaut pour la limite de CPU.</p></li></ul><h2 id=motivation-pour-les-demandes-et-les-limites-du-cpu>Motivation pour les demandes et les limites du CPU</h2><p>En configurant les demandes et les limites de CPU des conteneurs qui se lancent sur votre cluster,
vous pouvez utiliser efficacement les ressources CPU disponibles sur les Nœuds de votre cluster.
En gardant une demande faible de CPU de pod, vous donnez au Pod une bonne chance d'être ordonnancé.
En ayant une limite CPU supérieure à la demande de CPU, vous accomplissez deux choses :</p><ul><li>Le Pod peut avoir des pics d'activité où il utilise les ressources CPU qui sont déjà disponibles.</li><li>La quantité de ressources CPU qu'un Pod peut utiliser pendant une pic d'activité est limitée à une quantité raisonnable.</li></ul><h2 id=nettoyage>Nettoyage</h2><p>Supprimez votre namespace :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace cpu-example
</span></span></code></pre></div><h2 id=a-suivre>A suivre</h2><h3 id=pour-les-développeurs-d-applications>Pour les développeurs d'applications</h3><ul><li><p><a href=/fr/docs/tasks/configure-pod-container/assign-memory-resource/>Allocation des ressources mémoire aux conteneurs et aux pods</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/quality-service-pod/>Configuration de la qualité de service pour les pods</a></p></li></ul><h3 id=pour-les-administrateurs-de-cluster>Pour les administrateurs de cluster</h3><ul><li><p><a href=/docs/tasks/administer-cluster/memory-default-namespace/>Configuration des demandes et des limites de mémoire par défaut pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/cpu-default-namespace/>Configuration des demandes et des limites par défaut de CPU pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/memory-constraint-namespace/>Configuration des contraintes de mémoire minimales et maximales pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/cpu-constraint-namespace/>Configuration des contraintes minimales et maximales du CPU pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-memory-cpu-namespace/>Configuration des quotas de mémoire et de CPU pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-pod-namespace/>Configuration du quota de pods pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>Configuration des quotas pour les objets API</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-904cea8c8efd5c0d33adbfe579ec2dd2>3.3 - Configurer la qualité de service pour les pods</h1><p>Cette page montre comment configurer les Pods pour qu'ils soient affectés à des classes particulières de qualité de service (QoS). Kubernetes utilise des classes de QoS pour prendre des décisions concernant l'ordonnancement et les évictions des pods.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><h2 id=les-classes-de-qos>Les Classes de QoS</h2><p>Quand Kubernetes crée un Pod, il affecte une de ces classes QoS au Pod :</p><ul><li>Guaranteed</li><li>Burstable</li><li>BestEffort</li></ul><h2 id=créez-un-namespace>Créez un namespace</h2><p>Créez un namespace de manière à ce que les ressources que vous créez dans cet exercice soient isolées du reste de votre cluster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace qos-example
</span></span></code></pre></div><h2 id=créez-un-pod-qui-se-fait-attribuer-une-classe-qos-de-guaranteed>Créez un Pod qui se fait attribuer une classe QoS de Guaranteed</h2><p>Pour qu'un Pod reçoive une classe de QoS Guaranteed :</p><ul><li>Chaque conteneur du Pod doit avoir une limite de mémoire et une demande de mémoire, et elles doivent être les mêmes.</li><li>Chaque conteneur dans le Pod doit avoir une limite CPU et une demande CPU, et ils doivent être les mêmes.</li></ul><p>Ci-dessous le fichier de configuration d'un Pod qui a un seul conteneur.
Le conteneur dispose d'une limite de mémoire et d'une demande de mémoire, tous deux égaux à 200 MiB. Le conteneur a également une limite CPU et une demande CPU, toutes deux égales à 700 milliCPU :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/qos/qos-pod.yaml download=pods/qos/qos-pod.yaml><code>pods/qos/qos-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-yaml")' title="Copy pods/qos/qos-pod.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Créez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Consultez des informations détaillées sur le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>Le résultat indique que Kubernetes a donné au pod une classe de qualité de service de type Guaranteed. De plus, il affiche que la demande de mémoire du conteneur du pod correspond à sa limite de mémoire, et que la demande de CPU correspond à sa limite de CPU.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Guaranteed<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si un conteneur spécifie sa propre limite de mémoire, mais ne spécifie pas de demande de mémoire, Kubernetes attribue automatiquement une demande de mémoire correspondant à la limite. De même, si un conteneur spécifie sa propre limite CPU, mais ne spécifie pas de demande de CPU, Kubernetes lui attribue automatiquement une demande de CPU qui correspond à cette limite.</div><p>Supprimez votre Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=créez-un-pod-qui-se-fait-attribuer-une-classe-qos-de-type-burstable>Créez un Pod qui se fait attribuer une classe QoS de type Burstable</h2><p>Un Pod reçoit une classe QoS de Burstable si :</p><ul><li>Le Pod ne répond pas aux critères de la classe QoS Guaranteed.</li><li>Au moins un conteneur dans le Pod dispose d'une demande de mémoire ou de CPU.</li></ul><p>Voici le fichier de configuration d'un pod qui a un seul conteneur. Le conteneur a une limite de mémoire de 200 MiB et une demande de mémoire de 100 MiB.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/qos/qos-pod-2.yaml download=pods/qos/qos-pod-2.yaml><code>pods/qos/qos-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-2-yaml")' title="Copy pods/qos/qos-pod-2.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Créez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-2.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Consultez des informations détaillées sur le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>La sortie montre que Kubernetes a accordé au pod une classe QoS de type Burstable.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></span></span></code></pre></div><p>Supprimez votre Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=créez-un-pod-qui-se-fait-attribuer-une-classe-qos-de-type-besteffort>Créez un Pod qui se fait attribuer une classe QoS de type BestEffort</h2><p>Pour qu'un pod puisse avoir la classe QoS de BestEffort, les conteneurs dans le pod ne doivent pas
avoir des limites ou des demandes de mémoire ou de CPU.</p><p>Voici le fichier de configuration d'un Pod qui a un seul conteneur. Le conteneur n'a pas des limites ou des demandes de mémoire ou de CPU :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/qos/qos-pod-3.yaml download=pods/qos/qos-pod-3.yaml><code>pods/qos/qos-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-3-yaml")' title="Copy pods/qos/qos-pod-3.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Créez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-3.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Consultez des informations détaillées sur le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>Le résultat montre que Kubernetes a accordé au pod une classe QoS de BestEffort.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>BestEffort<span style=color:#bbb>
</span></span></span></code></pre></div><p>Supprimez votre Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=créez-un-pod-qui-contient-deux-conteneurs>Créez un pod qui contient deux conteneurs</h2><p>Voici le fichier de configuration d'un Pod qui a deux conteneurs. Un conteneur spécifie une
demande de mémoire de 200 MiB. L'autre conteneur ne spécifie aucune demande ou limite.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/qos/qos-pod-4.yaml download=pods/qos/qos-pod-4.yaml><code>pods/qos/qos-pod-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-4-yaml")' title="Copy pods/qos/qos-pod-4.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Notez que le pod répond aux critères de la classe QoS Burstable. En d'autres termes, il ne répond pas aux exigences de la classe de qualité de service Guaranteed, et l'un de ses conteneurs dispose d'une demande de mémoire.</p><p>Créez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-4.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Consultez des informations détaillées sur le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>Le résultat montre que Kubernetes a accordé au pod une classe QoS de Burstable:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></span></span></code></pre></div><p>Supprimez votre pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=nettoyage>Nettoyage</h2><p>Supprimez votre namespace.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace qos-example
</span></span></code></pre></div><h2 id=a-suivre>A suivre</h2><h3 id=pour-les-développeurs-d-applications>Pour les développeurs d'applications</h3><ul><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>Allocation des ressources CPU aux conteneurs et pods</a></p></li><li><p><a href=/fr/docs/tasks/configure-pod-container/assign-memory-resource/>Allocation des ressources mémoire aux conteneurs et pods</a></p></li></ul><h3 id=pour-les-administrateurs-de-cluster>Pour les administrateurs de cluster</h3><ul><li><p><a href=/docs/tasks/administer-cluster/memory-default-namespace/>Configuration des demandes et des limites de mémoire par défaut pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/cpu-default-namespace/>Configuration des demandes et des limites par défaut de CPU pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/memory-constraint-namespace/>Configuration des contraintes de mémoire minimales et maximales pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/cpu-constraint-namespace/>Configuration des contraintes minimales et maximales du CPU pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-memory-cpu-namespace/>Configuration des quotas de mémoire et de CPU pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-pod-namespace/>Configuration du quota de pods pour un Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>Configuration des quotas pour les objets API</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4219ac6ab56a3b88d20305083d57d03c>3.4 - Affecter des ressources supplémentaires à un conteneur</h1><p>Cette page montre comment affecter des ressources supplémentaires à un conteneur.</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [stable]</code></div><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><p>Avant de commencer cet exercice, procédez à l'exercice en
<a href=/docs/tasks/administer-cluster/extended-resource-node/>Annoncer des ressources supplémentaires pour un nœud</a>.
Cela configurera l'un de vos nœuds pour qu'il annoncera une ressource dongle.</p><h2 id=affecter-une-ressource-supplémentaire-à-un-pod>Affecter une ressource supplémentaire à un Pod</h2><p>Pour demander une ressource supplémentaire, incluez le champ <code>resources:requests</code> dans votre fichier de manifeste du conteneur. Les ressources supplémentaires sont entièrement qualifiées dans n'importe quel domaine à l'extérieur de <code>*.kubernetes.io/</code>.
Les noms de ressources supplémentaires valides ont la forme <code>example.com/foo</code> où <code>example.com</code> est remplacé par le domaine de votre organisation et <code>foo</code> est le nom descriptif de la ressource.</p><p>Voici le fichier de configuration d'un Pod qui a un seul conteneur :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/resource/extended-resource-pod.yaml download=pods/resource/extended-resource-pod.yaml><code>pods/resource/extended-resource-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-extended-resource-pod-yaml")' title="Copy pods/resource/extended-resource-pod.yaml to clipboard"></img></div><div class=includecode id=pods-resource-extended-resource-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dans le fichier de configuration, vous pouvez constater que le conteneur demande 3 dongles.</p><p>Créez un pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod.yaml
</span></span></code></pre></div><p>Vérifiez que le Pod fonctionne :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod extended-resource-demo
</span></span></code></pre></div><p>Décrivez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod extended-resource-demo
</span></span></code></pre></div><p>La sortie affiche les demandes des dongles :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>Requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=tentative-de-création-d-un-deuxième-pod>Tentative de création d'un deuxième Pod</h2><p>Voici le fichier de configuration d'un Pod qui a un seul conteneur. Le conteneur demande
deux dongles.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/resource/extended-resource-pod-2.yaml download=pods/resource/extended-resource-pod-2.yaml><code>pods/resource/extended-resource-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-extended-resource-pod-2-yaml")' title="Copy pods/resource/extended-resource-pod-2.yaml to clipboard"></img></div><div class=includecode id=pods-resource-extended-resource-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Kubernetes ne pourra pas satisfaire la demande de deux dongles, parce que le premier Pod
a utilisé trois des quatre dongles disponibles.</p><p>Essayez de créer un Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod-2.yaml
</span></span></code></pre></div><p>Décrivez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod extended-resource-demo-2
</span></span></code></pre></div><p>La sortie montre que le Pod ne peut pas être planifié, du fait qu'il n'y a pas de Nœud qui a
2 dongles disponibles :</p><pre tabindex=0><code>Conditions:
  Type    Status
  PodScheduled  False
...
Events:
  ...
  ... Warning   FailedScheduling  pod (extended-resource-demo-2) failed to fit in any node
fit failure summary on nodes : Insufficient example.com/dongle (1)
</code></pre><p>Affichez l'état du Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod extended-resource-demo-2
</span></span></code></pre></div><p>La sortie indique que le Pod a été créé, mais pas programmé pour tourner sur un Nœud.
Il a le statut Pending :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>NAME                       READY     STATUS    RESTARTS   AGE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>extended-resource-demo-2   0/1       Pending   0          6m<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=nettoyage>Nettoyage</h2><p>Supprimez les Pods que vous avez créés dans cet exercice :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod extended-resource-demo
</span></span><span style=display:flex><span>kubectl delete pod extended-resource-demo-2
</span></span></code></pre></div><h2 id=a-suivre>A suivre</h2><h3 id=pour-les-développeurs-d-applications>Pour les développeurs d'applications</h3><ul><li><a href=/fr/docs/tasks/configure-pod-container/assign-memory-resource/>Allocation des ressources mémoire aux conteneurs et pods</a></li><li><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>Allocation des ressources CPU aux conteneurs et pods</a></li></ul><h3 id=pour-les-administrateurs-de-cluster>Pour les administrateurs de cluster</h3><ul><li><a href=/docs/tasks/administer-cluster/extended-resource-node/>Annoncer des ressources supplémentaires pour un nœud</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-484833fb880d1e179cc2965d15f84da5>3.5 - Configurer un pod en utilisant un volume pour le stockage</h1><p>Cette page montre comment configurer un Pod pour utiliser un Volume pour le stockage.</p><p>Le système de fichiers d'un conteneur ne vit que tant que le conteneur vit. Ainsi, quand un conteneur se termine et redémarre, les modifications apportées au système de fichiers sont perdues. Pour un stockage plus consistant et indépendant du conteneur, vous pouvez utiliser un
<a href=/fr/docs/concepts/storage/volumes/>Volume</a>.
C'est particulièrement important pour les applications Stateful, telles que les key-value stores (comme par exemple Redis) et les bases de données.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><h2 id=configurer-un-volume-pour-un-pod>Configurer un volume pour un Pod</h2><p>Dans cet exercice, vous créez un pod qui contient un seul conteneur. Ce Pod a un Volume de type
<a href=/fr/docs/concepts/storage/volumes/#emptydir>emptyDir</a> qui dure toute la vie du Pod, même si le conteneur se termine et redémarre.
Voici le fichier de configuration du Pod :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/storage/redis.yaml download=pods/storage/redis.yaml><code>pods/storage/redis.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-redis-yaml")' title="Copy pods/storage/redis.yaml to clipboard"></img></div><div class=includecode id=pods-storage-redis-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Créez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/redis.yaml
</span></span></code></pre></div></li><li><p>Vérifiez que le conteneur du pod est en cours d'exécution, puis surveillez les modifications apportées au pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod redis --watch
</span></span></code></pre></div><p>La sortie ressemble à ceci :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>redis     1/1       Running   <span style=color:#666>0</span>          13s
</span></span></code></pre></div></li><li><p>Dans un autre terminal, accédez à la console shell du conteneur en cours d'exécution :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</span></span></code></pre></div></li><li><p>Dans votre shell, allez dans <code>/data/redis</code>, puis créez un fichier :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data# <span style=color:#a2f>cd</span> /data/redis/
</span></span><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>echo</span> Hello &gt; test-file
</span></span></code></pre></div></li><li><p>Dans votre shell, listez les processus en cours d'exécution :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# apt-get update
</span></span><span style=display:flex><span>root@redis:/data/redis# apt-get install procps
</span></span><span style=display:flex><span>root@redis:/data/redis# ps aux
</span></span></code></pre></div><p>La sortie ressemble à ceci :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
</span></span><span style=display:flex><span>redis        <span style=color:#666>1</span>  0.1  0.1  <span style=color:#666>33308</span>  <span style=color:#666>3828</span> ?        Ssl  00:46   0:00 redis-server *:6379
</span></span><span style=display:flex><span>root        <span style=color:#666>12</span>  0.0  0.0  <span style=color:#666>20228</span>  <span style=color:#666>3020</span> ?        Ss   00:47   0:00 /bin/bash
</span></span><span style=display:flex><span>root        <span style=color:#666>15</span>  0.0  0.0  <span style=color:#666>17500</span>  <span style=color:#666>2072</span> ?        R+   00:48   0:00 ps aux
</span></span></code></pre></div></li><li><p>Dans votre shell, arrêtez le processus Redis :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>kill</span> &lt;pid&gt;
</span></span></code></pre></div><p>où <code>&lt;pid></code> est l'ID de processus Redis (PID).</p></li><li><p>Dans votre terminal initial, surveillez les changements apportés au Pod de Redis. Éventuellement,
vous verrez quelque chose comme ça :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      READY     STATUS     RESTARTS   AGE
</span></span><span style=display:flex><span>redis     1/1       Running    <span style=color:#666>0</span>          13s
</span></span><span style=display:flex><span>redis     0/1       Completed  <span style=color:#666>0</span>         6m
</span></span><span style=display:flex><span>redis     1/1       Running    <span style=color:#666>1</span>         6m
</span></span></code></pre></div></li></ol><p>A ce stade, le conteneur est terminé et redémarré. C'est dû au fait que le Pod de Redis a une
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>restartPolicy</a>
fixé à <code>Always</code>.</p><ol><li><p>Accédez à la console shell du conteneur redémarré :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</span></span></code></pre></div></li><li><p>Dans votre shell, allez dans <code>/data/redis</code>, et vérifiez que <code>test-file</code> est toujours là.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>cd</span> /data/redis/
</span></span><span style=display:flex><span>root@redis:/data/redis# ls
</span></span><span style=display:flex><span>test-file
</span></span></code></pre></div></li><li><p>Supprimez le pod que vous avez créé pour cet exercice :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod redis
</span></span></code></pre></div></li></ol><h2 id=a-suivre>A suivre</h2><ul><li><p>Voir <a href=/docs/reference/generated/kubernetes-api/v1.25/#volume-v1-core>Volume</a>.</p></li><li><p>Voir <a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>Pod</a>.</p></li><li><p>En plus du stockage sur disque local fourni par <code>emptyDir</code>, Kubernetes supporte de nombreuses solutions de stockage connectées au réseau, y compris PD sur GCE et EBS sur EC2, qui sont préférés pour les données critiques et qui s'occuperont des autres détails tels que le montage et le démontage sur les nœuds. Voir <a href=/fr/docs/concepts/storage/volumes/>Volumes</a> pour plus de détails.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2c0d882359718c4c69c67099bed2156c>3.6 - Configurer les comptes de service pour les pods</h1><p>Un ServiceAccount (compte de service) fournit une identité pour les processus qui s'exécutent dans un Pod.</p><p><em>Ceci est une introduction aux comptes de service pour les utilisateurs. Voir aussi
<a href=/docs/reference/access-authn-authz/service-accounts-admin/>Guide de l'administrateur du cluster des comptes de service</a>.</em></p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Ce document décrit le comportement des comptes de service dans un cluster mis en place conformément aux recommandations du projet Kubernetes. L'administrateur de votre cluster a peut-être personnalisé le comportement dans votre cluster, dans ce cas cette documentation pourrait être non applicable.</div><p>Lorsque vous (un humain) accédez au cluster (par exemple, en utilisant <code>kubectl</code>), vous êtes
authentifié par l'apiserver en tant que compte d'utilisateur particulier (actuellement, il s'agit
généralement de l'utilisateur <code>admin</code>, à moins que votre administrateur de cluster n'ait personnalisé votre cluster). Les processus dans les conteneurs dans les Pods peuvent également contacter l'apiserver. Dans ce cas, ils sont authentifiés en tant que compte de service particulier (par exemple, <code>default</code>).</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><h2 id=utiliser-le-compte-de-service-par-défaut-pour-accéder-au-api-server>Utiliser le compte de service par défaut pour accéder au API server.</h2><p>Si vous obtenez le raw json ou yaml pour un Pod que vous avez créé (par exemple, <code>kubectl get pods/&lt;podname> -o yaml</code>), vous pouvez voir que le champ <code>spec.serviceAccountName</code> a été <a href=/docs/user-guide/working-with-resources/#resources-are-automatically-modified>automatiquement assigné</a>.</p><p>Vous pouvez accéder à l'API depuis l'intérieur d'un Pod en utilisant les identifiants de compte de service montés automatiquement, comme décrit dans <a href=/docs/user-guide/accessing-the-cluster/#accessing-the-api-from-a-pod>Accès au cluster</a>.
Les permissions API du compte de service dépendent du <a href=/docs/reference/access-authn-authz/authorization/#authorization-modules>plugin d'autorisation et de la politique</a> en usage.</p><p>Dans la version 1.6+, vous pouvez choisir de ne pas utiliser le montage automatique des identifiants API pour un compte de service en définissant <code>automountServiceAccountToken: false</code> sur le compte de service :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>automountServiceAccountToken</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Dans la version 1.6+, vous pouvez également choisir de ne pas monter automatiquement les identifiants API pour un Pod particulier :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>automountServiceAccountToken</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>La spéc de Pod a prépondérance par rapport au compte de service si les deux spécifient la valeur <code>automountServiceAccountToken</code>.</p><h2 id=utiliser-plusieurs-comptes-de-services>Utiliser plusieurs comptes de services.</h2><p>Chaque Namespace possède une ressource ServiceAccount par défaut appelée <code>default</code>.
Vous pouvez lister cette ressource et toutes les autres ressources de ServiceAccount dans le Namespace avec cette commande :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get serviceAccounts
</span></span></code></pre></div><p>La sortie est comme la suivante :</p><pre tabindex=0><code>NAME      SECRETS    AGE
default   1          1d
</code></pre><p>Vous pouvez créer des objets ServiceAccount supplémentaires comme ceci :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: ServiceAccount
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: build-robot
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Si vous obtenez un dump complet de l'objet compte de service, par exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get serviceaccounts/build-robot -o yaml
</span></span></code></pre></div><p>La sortie est comme la suivante :</p><pre tabindex=0><code>apiVersion: v1
kind: ServiceAccount
metadata:
  creationTimestamp: 2015-06-16T00:12:59Z
  name: build-robot
  namespace: default
  resourceVersion: &#34;272500&#34;
  selfLink: /api/v1/namespaces/default/serviceaccounts/build-robot
  uid: 721ab723-13bc-11e5-aec2-42010af0021e
secrets:
- name: build-robot-token-bvbk5
</code></pre><p>vous verrez alors qu'un token a été automatiquement créé et est référencé par le compte de service.</p><p>Vous pouvez utiliser des plugins d'autorisation pour <a href=/docs/reference/access-authn-authz/rbac/#service-account-permissions>définir les permissions sur les comptes de service</a>.</p><p>Pour utiliser un compte de service autre que par défaut, il suffit de spécifier le <code>spec.serviceAccountName</code> d'un Pod au nom du compte de service que vous souhaitez utiliser.</p><p>Le compte de service doit exister au moment de la création du Pod, sinon il sera rejeté.</p><p>Vous ne pouvez pas mettre à jour le compte de service d'un Pod déjà créé.</p><p>Vous pouvez supprimer le compte de service de cet exemple comme ceci :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete serviceaccount/build-robot
</span></span></code></pre></div><h2 id=créez-manuellement-un-api-token-de-compte-de-service>Créez manuellement un API token de compte de service.</h2><p>Supposons que nous ayons un compte de service existant nommé "build-robot" comme mentionné ci-dessus,et que nous allons créer un nouveau Secret manuellement.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: build-robot-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>  annotations:
</span></span></span><span style=display:flex><span><span style=color:#b44>    kubernetes.io/service-account.name: build-robot
</span></span></span><span style=display:flex><span><span style=color:#b44>type: kubernetes.io/service-account-token
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Vous pouvez maintenant confirmer que le Secret nouvellement construit est rempli d'un API token pour le compte de service "build-robot".</p><p>Tous les tokens pour des comptes de service non-existants seront nettoyés par le contrôleur de token.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe secrets/build-robot-secret
</span></span></code></pre></div><p>La sortie est comme la suivante :</p><pre tabindex=0><code>Name:           build-robot-secret
Namespace:      default
Labels:         &lt;none&gt;
Annotations:    kubernetes.io/service-account: name=build-robot
                kubernetes.io/service-account: uid=da68f9c6-9d26-11e7-b84e-002dc52800da

Type:   kubernetes.io/service-account-token

Data
====
ca.crt:         1338 bytes
namespace:      7 bytes
token:          ...
</code></pre><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le contenu de <code>token</code> est éludé ici.</div><h2 id=ajouter-imagepullsecrets-à-un-compte-de-service>Ajouter ImagePullSecrets à un compte de service</h2><p>Tout d'abord, créez un imagePullSecret, comme décrit <a href=/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>ici</a>.
Puis, vérifiez qu'il a été créé. Par exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets myregistrykey
</span></span></code></pre></div><p>La sortie est comme la suivante :</p><pre tabindex=0><code>NAME             TYPE                              DATA    AGE
myregistrykey    kubernetes.io/.dockerconfigjson   1       1d
</code></pre><p>Ensuite, modifiez le compte de service par défaut du Namespace pour utiliser ce Secret comme un <code>imagePullSecret</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch serviceaccount default -p <span style=color:#b44>&#39;{&#34;imagePullSecrets&#34;: [{&#34;name&#34;: &#34;myregistrykey&#34;}]}&#39;</span>
</span></span></code></pre></div><p>La version interactive nécessite un traitement manuel :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get serviceaccounts default -o yaml &gt; ./sa.yaml
</span></span></code></pre></div><p>La sortie du fichier <code>sa.yaml</code> est similaire à celle-ci :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: ServiceAccount
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  creationTimestamp: 2015-08-07T22:02:39Z
</span></span><span style=display:flex><span>  name: default
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  resourceVersion: <span style=color:#b44>&#34;243024&#34;</span>
</span></span><span style=display:flex><span>  selfLink: /api/v1/namespaces/default/serviceaccounts/default
</span></span><span style=display:flex><span>  uid: 052fb0f4-3d50-11e5-b066-42010af0d7b6
</span></span><span style=display:flex><span>secrets:
</span></span><span style=display:flex><span>- name: default-token-uudge
</span></span></code></pre></div><p>En utilisant l'éditeur de votre choix (par exemple <code>vi</code>), ouvrez le fichier <code>sa.yaml</code>, supprimez la ligne avec la clé <code>resourceVersion</code>, ajoutez les lignes avec <code>imagePullSecrets:</code> et sauvegardez.</p><p>La sortie du fichier <code>sa.yaml</code> est similaire à celle-ci :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: ServiceAccount
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  creationTimestamp: 2015-08-07T22:02:39Z
</span></span><span style=display:flex><span>  name: default
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  selfLink: /api/v1/namespaces/default/serviceaccounts/default
</span></span><span style=display:flex><span>  uid: 052fb0f4-3d50-11e5-b066-42010af0d7b6
</span></span><span style=display:flex><span>secrets:
</span></span><span style=display:flex><span>- name: default-token-uudge
</span></span><span style=display:flex><span>imagePullSecrets:
</span></span><span style=display:flex><span>- name: myregistrykey
</span></span></code></pre></div><p>Enfin, remplacez le compte de service par le nouveau fichier <code>sa.yaml</code> mis à jour.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace serviceaccount default -f ./sa.yaml
</span></span></code></pre></div><p>Maintenant, tous les nouveaux Pods créés dans le Namespace courant auront ceci ajouté à leurs spécifications :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imagePullSecrets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myregistrykey<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=projection-du-volume-des-tokens-de-compte-de-service>Projection du volume des tokens de compte de service</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Ce ServiceAccountTokenVolumeProjection est <strong>beta</strong> en 1.12 et
activé en passant tous les paramètres suivants au serveur API :</p><ul><li><code>--service-account-issuer</code></li><li><code>--service-account-signing-key-file</code></li><li><code>--service-account-api-audiences</code></li></ul></div><p>Kubelet peut également projeter un token de compte de service dans un Pod. Vous pouvez spécifier les propriétés souhaitées du token, telles que l'audience et la durée de validité.
Ces propriétés ne sont pas configurables sur le compte de service par défaut. Le token de compte de service devient également invalide par l'API lorsque le Pod ou le ServiceAccount est supprimé</p><p>Ce comportement est configuré sur un PodSpec utilisant un type de ProjectedVolume appelé
<a href=/docs/concepts/storage/volumes/#projected>ServiceAccountToken</a>. Pour fournir un
Pod avec un token avec une audience de "vault" et une durée de validité de deux heures, vous devriez configurer ce qui suit dans votre PodSpec :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/pod-projected-svc-token.yaml download=pods/pod-projected-svc-token.yaml><code>pods/pod-projected-svc-token.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-projected-svc-token-yaml")' title="Copy pods/pod-projected-svc-token.yaml to clipboard"></img></div><div class=includecode id=pods-pod-projected-svc-token-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/run/secrets/tokens<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>7200</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>vault<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Créez le Pod</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/pod-projected-svc-token.yaml
</span></span></code></pre></div><p>Kubelet demandera et stockera le token a la place du Pod, rendra le token disponible pour le Pod à un chemin d'accès configurable, et rafraîchissez le token à l'approche de son expiration. Kubelet fait tourner le token de manière proactive s'il est plus vieux que 80% de son TTL total, ou si le token est plus vieux que 24 heures.</p><p>L'application est responsable du rechargement du token lorsque celui ci est renouvelé. Un rechargement périodique (par ex. toutes les 5 minutes) est suffisant pour la plupart des cas d'utilisation.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d385b86a7cb496d3b1c3b2a47280ca70>3.7 - Récupération d'une image d'un registre privé</h1><p>Cette page montre comment créer un Pod qui utilise un Secret pour récupérer une image d'un registre privé.</p><h2 id=pré-requis>Pré-requis</h2><ul><li><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p></li><li><p>Pour faire cet exercice, vous avez besoin d'un
<a href=https://docs.docker.com/docker-id/>Docker ID</a> et un mot de passe.</p></li></ul><h2 id=connectez-vous-à-docker>Connectez-vous à Docker</h2><p>Sur votre ordinateur, vous devez vous authentifier à un registre afin de récupérer une image privée :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker login
</span></span></code></pre></div><p>Une fois que c'est fait, entrez votre nom d'utilisateur et votre mot de passe Docker.</p><p>Le processus de connexion crée ou met à jour un fichier <code>config.json</code> qui contient un token d'autorisation.</p><p>Consultez le fichier <code>config.json</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat ~/.docker/config.json
</span></span></code></pre></div><p>La sortie comporte une section similaire à celle-ci :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;https://index.docker.io/v1/&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;c3R...zE2&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si vous utilisez le credentials store de Docker, vous ne verrez pas cette entrée <code>auth</code> mais une entrée <code>credsStore</code> avec le nom du Store comme valeur.</div><h2 id=registry-secret-existing-credentials>Créez un Secret basé sur les identifiants existants du Docker</h2><p>Le cluster Kubernetes utilise le type Secret de <code>docker-registry</code> pour s'authentifier avec
un registre de conteneurs pour y récupérer une image privée.</p><p>Si vous avez déjà lancé <code>docker login</code>, vous pouvez copier ces identifiants dans Kubernetes</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic regcred <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --from-file<span style=color:#666>=</span>.dockerconfigjson<span style=color:#666>=</span>&lt;path/to/.docker/config.json&gt; <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --type<span style=color:#666>=</span>kubernetes.io/dockerconfigjson
</span></span></code></pre></div><p>Si vous avez besoin de plus de contrôle (par exemple, pour définir un Namespace ou un label sur le nouveau secret), vous pouvez alors personnaliser le secret avant de le stocker.
Assurez-vous de :</p><ul><li>Attribuer la valeur <code>.dockerconfigjson</code> dans le nom de l'élément data</li><li>Encoder le fichier docker en base64 et colle cette chaîne, non interrompue, comme valeur du champ <code>data[".dockerconfigjson"]</code>.</li><li>Mettre <code>type</code> à <code>kubernetes.io/dockerconfigjson</code>.</li></ul><p>Exemple:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myregistrykey<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>awesomeapps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockerconfigjson<span style=color:#bbb>
</span></span></span></code></pre></div><p>Si vous obtenez le message d'erreur <code>error: no objects passed to create</code>, cela peut signifier que la chaîne encodée en base64 est invalide.
Si vous obtenez un message d'erreur comme <code>Secret "myregistrykey" is invalid: data[.dockerconfigjson]: invalid value ...</code>, cela signifie que la chaîne encodée en base64 a été décodée avec succès, mais n'a pas pu être interprétée comme un fichier <code>.docker/config.json</code>.</p><h2 id=créez-un-secret-en-fournissant-les-identifiants-sur-la-ligne-de-commande>Créez un Secret en fournissant les identifiants sur la ligne de commande</h2><p>Créez ce secret, en le nommant <code>regcred</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry regcred --docker-server<span style=color:#666>=</span>&lt;your-registry-server&gt; --docker-username<span style=color:#666>=</span>&lt;your-name&gt; --docker-password<span style=color:#666>=</span>&lt;your-pword&gt; --docker-email<span style=color:#666>=</span>&lt;your-email&gt;
</span></span></code></pre></div><p>où :</p><ul><li><code>&lt;your-registry-server></code> est votre FQDN de registre de docker privé. (<a href=https://index.docker.io/v1/>https://index.docker.io/v1/</a> for DockerHub)</li><li><code>&lt;your-name></code> est votre nom d'utilisateur Docker.</li><li><code>&lt;your-pword></code> est votre mot de passe Docker.</li><li><code>&lt;your-email></code> est votre email Docker.</li></ul><p>Vous avez réussi à définir vos identifiants Docker dans le cluster comme un secret appelé <code>regcred</code>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Saisir des secrets sur la ligne de commande peut les conserver dans l'historique de votre shell sans protection, et ces secrets peuvent également être visibles par d'autres utilisateurs sur votre ordinateur pendant l'exécution de <code>kubectl</code>.</div><h2 id=inspection-du-secret-regcred>Inspection du secret <code>regcred</code></h2><p>Pour comprendre le contenu du Secret <code>regcred</code> que vous venez de créer, commencez par visualiser le Secret au format YAML :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret regcred --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>La sortie est similaire à celle-ci :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockerconfigjson<span style=color:#bbb>
</span></span></span></code></pre></div><p>La valeur du champ <code>.dockerconfigjson</code> est une représentation en base64 de vos identifiants Docker.</p><p>Pour comprendre ce que contient le champ <code>.dockerconfigjson</code>, convertissez les données secrètes en un format lisible :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret regcred --output<span style=color:#666>=</span><span style=color:#b44>&#34;jsonpath={.data.\.dockerconfigjson}&#34;</span> | base64 --decode
</span></span></code></pre></div><p>La sortie est similaire à celle-ci :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;auths&#34;</span>:{<span style=color:green;font-weight:700>&#34;your.private.registry.example.com&#34;</span>:{<span style=color:green;font-weight:700>&#34;username&#34;</span>:<span style=color:#b44>&#34;janedoe&#34;</span>,<span style=color:green;font-weight:700>&#34;password&#34;</span>:<span style=color:#b44>&#34;xxxxxxxxxxx&#34;</span>,<span style=color:green;font-weight:700>&#34;email&#34;</span>:<span style=color:#b44>&#34;jdoe@example.com&#34;</span>,<span style=color:green;font-weight:700>&#34;auth&#34;</span>:<span style=color:#b44>&#34;c3R...zE2&#34;</span>}}}
</span></span></code></pre></div><p>Pour comprendre ce qui se cache dans le champ `auth', convertissez les données encodées en base64 dans un format lisible :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;c3R...zE2&#34;</span> | base64 --decode
</span></span></code></pre></div><p>La sortie en tant que nom d'utilisateur et mot de passe concaténés avec un <code>:</code>, est similaire à ceci :</p><pre tabindex=0><code class=language-none data-lang=none>janedoe:xxxxxxxxxxx
</code></pre><p>Remarquez que les données secrètes contiennent le token d'autorisation similaire à votre fichier local <code>~/.docker/config.json</code>.</p><p>Vous avez réussi à définir vos identifiants de Docker comme un Secret appelé <code>regcred</code> dans le cluster.</p><h2 id=créez-un-pod-qui-utilise-votre-secret>Créez un Pod qui utilise votre Secret</h2><p>Voici un fichier de configuration pour un Pod qui a besoin d'accéder à vos identifiants Docker dans <code>regcred</code> :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/private-reg-pod.yaml download=pods/private-reg-pod.yaml><code>pods/private-reg-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-private-reg-pod-yaml")' title="Copy pods/private-reg-pod.yaml to clipboard"></img></div><div class=includecode id=pods-private-reg-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>&lt;your-private-image&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imagePullSecrets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Téléchargez le fichier ci-dessus :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>wget -O my-private-reg-pod.yaml https://k8s.io/examples/pods/private-reg-pod.yaml
</span></span></code></pre></div><p>Dans le fichier <code>my-private-reg-pod.yaml</code>, remplacez <code>&lt;your-private-image></code> par le chemin d'accès à une image dans un registre privé tel que</p><pre tabindex=0><code class=language-none data-lang=none>your.private.registry.example.com/janedoe/jdoe-private:v1
</code></pre><p>Pour récupérer l'image du registre privé, Kubernetes a besoin des identifiants.
Le champ <code>imagePullSecrets</code> dans le fichier de configuration spécifie que Kubernetes doit obtenir les informations d'identification d'un Secret nommé <code>regcred</code>.</p><p>Créez un Pod qui utilise votre secret et vérifiez que le Pod est bien lancé :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f my-private-reg-pod.yaml
</span></span><span style=display:flex><span>kubectl get pod private-reg
</span></span></code></pre></div><h2 id=a-suivre>A suivre</h2><ul><li>Pour en savoir plus sur les <a href=/docs/concepts/configuration/secret/>Secrets</a>.</li><li>Pour en savoir plus sur l'<a href=/docs/concepts/containers/images/#using-a-private-registry>utilisation d'un registre privé</a>.</li><li>Pour en savoir plus sur l'<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>ajout d'un imagePullSecrets à un compte de service</a>.</li><li>Voir <a href=/docs/reference/generated/kubectl/kubectl-commands/#-em-secret-docker-registry-em->kubectl crée un Secret de registre de docker</a>.</li><li>Voir <a href=/docs/reference/generated/kubernetes-api/v1.25/#secret-v1-core>Secret</a>.</li><li>Voir le champ <code>imagePullSecrets</code> de <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-eb54daf87df373096b5e830680194dfc>3.8 - Configurer les Liveness, Readiness et Startup Probes</h1><p>Cette page montre comment configurer les liveness, readiness et startup probes pour les conteneurs.</p><p>Le <a href=/docs/admin/kubelet/>Kubelet</a> utilise les liveness probes pour détecter quand redémarrer un conteneur. Par exemple, les Liveness probes pourraient attraper un deadlock dans le cas où une application est en cours d'exécution, mais qui est incapable de traiter les requêtes. Le redémarrage d'un conteneur dans un tel état rend l'application plus disponible malgré les bugs.</p><p>Le Kubelet utilise readiness probes pour savoir quand un conteneur est prêt à accepter le trafic. Un Pod est considéré comme prêt lorsque tous ses conteneurs sont prêts.
Ce signal sert notamment à contrôler les pods qui sont utilisés comme backends pour les Services. Lorsqu'un Pod n'est pas prêt, il est retiré des équilibreurs de charge des Services.</p><p>Le Kubelet utilise startup probes pour savoir quand une application d'un conteneur a démarré.
Si une telle probe est configurée, elle désactive les contrôles de liveness et readiness jusqu'à cela réussit, en s'assurant que ces probes n'interfèrent pas avec le démarrage de l'application.
Cela peut être utilisé dans le cas des liveness checks sur les conteneurs à démarrage lent, en les évitant de se faire tuer par le Kubelet avant qu'ils ne soient opérationnels.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><h2 id=définir-une-commande-de-liveness>Définir une commande de liveness</h2><p>De nombreuses applications fonctionnant pour des longues périodes finissent par passer à des états de rupture et ne peuvent pas se rétablir, sauf en étant redémarrées. Kubernetes fournit des liveness probes pour détecter et remédier à ces situations.</p><p>Dans cet exercice, vous allez créer un Pod qui exécute un conteneur basé sur l'image <code>k8s.gcr.io/busybox</code>. Voici le fichier de configuration pour le Pod :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/probe/exec-liveness.yaml download=pods/probe/exec-liveness.yaml><code>pods/probe/exec-liveness.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-probe-exec-liveness-yaml")' title="Copy pods/probe/exec-liveness.yaml to clipboard"></img></div><div class=includecode id=pods-probe-exec-liveness-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-exec<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- cat<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- /tmp/healthy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dans le fichier de configuration, vous constatez que le Pod a un seul conteneur.
Le champ <code>periodSeconds</code> spécifie que le Kubelet doit effectuer un check de liveness toutes les 5 secondes. Le champ <code>initialDelaySeconds</code> indique au Kubelet qu'il devrait attendre 5 secondes avant d'effectuer la première probe. Pour effectuer une probe, le Kubelet exécute la commande <code>cat /tmp/healthy</code> dans le conteneur. Si la commande réussit, elle renvoie 0, et le Kubelet considère que le conteneur est vivant et en bonne santé. Si la commande renvoie une valeur non nulle, le Kubelet tue le conteneur et le redémarre.</p><p>Au démarrage, le conteneur exécute cette commande :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/bin/sh -c <span style=color:#b44>&#34;touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600&#34;</span>
</span></span></code></pre></div><p>Pour les 30 premières secondes de la vie du conteneur, il y a un fichier <code>/tmp/healthy</code>.
Donc pendant les 30 premières secondes, la commande <code>cat /tmp/healthy</code> renvoie un code de succès. Après 30 secondes, <code>cat /tmp/healthy</code> renvoie un code d'échec.</p><p>Créez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/probe/exec-liveness.yaml
</span></span></code></pre></div><p>Dans les 30 secondes, visualisez les événements du Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod liveness-exec
</span></span></code></pre></div><p>La sortie indique qu'aucune liveness probe n'a encore échoué :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>FirstSeen    LastSeen    Count   From            SubobjectPath           Type        Reason      Message
</span></span><span style=display:flex><span>--------- --------    -----   ----            -------------           --------    ------      -------
</span></span><span style=display:flex><span>24s       24s     <span style=color:#666>1</span>   <span style=color:#666>{</span>default-scheduler <span style=color:#666>}</span>                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
</span></span><span style=display:flex><span>23s       23s     <span style=color:#666>1</span>   <span style=color:#666>{</span>kubelet worker0<span style=color:#666>}</span>   spec.containers<span style=color:#666>{</span>liveness<span style=color:#666>}</span>   Normal      Pulling     pulling image <span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span>
</span></span><span style=display:flex><span>23s       23s     <span style=color:#666>1</span>   <span style=color:#666>{</span>kubelet worker0<span style=color:#666>}</span>   spec.containers<span style=color:#666>{</span>liveness<span style=color:#666>}</span>   Normal      Pulled      Successfully pulled image <span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span>
</span></span><span style=display:flex><span>23s       23s     <span style=color:#666>1</span>   <span style=color:#666>{</span>kubelet worker0<span style=color:#666>}</span>   spec.containers<span style=color:#666>{</span>liveness<span style=color:#666>}</span>   Normal      Created     Created container with docker id 86849c15382e; Security:<span style=color:#666>[</span><span style=color:#b8860b>seccomp</span><span style=color:#666>=</span>unconfined<span style=color:#666>]</span>
</span></span><span style=display:flex><span>23s       23s     <span style=color:#666>1</span>   <span style=color:#666>{</span>kubelet worker0<span style=color:#666>}</span>   spec.containers<span style=color:#666>{</span>liveness<span style=color:#666>}</span>   Normal      Started     Started container with docker id 86849c15382e
</span></span></code></pre></div><p>Après 35 secondes, visualisez à nouveau les événements du Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod liveness-exec
</span></span></code></pre></div><p>Au bas de la sortie, il y a des messages indiquant que les liveness probes ont échoué, et que les conteneurs ont été tués et recréés.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>FirstSeen LastSeen    Count   From            SubobjectPath           Type        Reason      Message
</span></span><span style=display:flex><span>--------- --------    -----   ----            -------------           --------    ------      -------
</span></span><span style=display:flex><span>37s       37s     <span style=color:#666>1</span>   <span style=color:#666>{</span>default-scheduler <span style=color:#666>}</span>                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
</span></span><span style=display:flex><span>36s       36s     <span style=color:#666>1</span>   <span style=color:#666>{</span>kubelet worker0<span style=color:#666>}</span>   spec.containers<span style=color:#666>{</span>liveness<span style=color:#666>}</span>   Normal      Pulling     pulling image <span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span>
</span></span><span style=display:flex><span>36s       36s     <span style=color:#666>1</span>   <span style=color:#666>{</span>kubelet worker0<span style=color:#666>}</span>   spec.containers<span style=color:#666>{</span>liveness<span style=color:#666>}</span>   Normal      Pulled      Successfully pulled image <span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span>
</span></span><span style=display:flex><span>36s       36s     <span style=color:#666>1</span>   <span style=color:#666>{</span>kubelet worker0<span style=color:#666>}</span>   spec.containers<span style=color:#666>{</span>liveness<span style=color:#666>}</span>   Normal      Created     Created container with docker id 86849c15382e; Security:<span style=color:#666>[</span><span style=color:#b8860b>seccomp</span><span style=color:#666>=</span>unconfined<span style=color:#666>]</span>
</span></span><span style=display:flex><span>36s       36s     <span style=color:#666>1</span>   <span style=color:#666>{</span>kubelet worker0<span style=color:#666>}</span>   spec.containers<span style=color:#666>{</span>liveness<span style=color:#666>}</span>   Normal      Started     Started container with docker id 86849c15382e
</span></span><span style=display:flex><span>2s        2s      <span style=color:#666>1</span>   <span style=color:#666>{</span>kubelet worker0<span style=color:#666>}</span>   spec.containers<span style=color:#666>{</span>liveness<span style=color:#666>}</span>   Warning     Unhealthy   Liveness probe failed: cat: can<span style=color:#b44>&#39;t open &#39;</span>/tmp/healthy<span>&#39;</span>: No such file or directory
</span></span></code></pre></div><p>Attendez encore 30 secondes et vérifiez que le conteneur a été redémarré :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod liveness-exec
</span></span></code></pre></div><p>La sortie montre que <code>RESTARTS</code> a été incrémenté :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME            READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>liveness-exec   1/1       Running   <span style=color:#666>1</span>          1m
</span></span></code></pre></div><h2 id=définir-une-requête-http-de-liveness>Définir une requête HTTP de liveness</h2><p>Un autre type de liveness probe utilise une requête GET HTTP. Voici la configuration
d'un Pod qui fait fonctionner un conteneur basé sur l'image <code>k8s.gcr.io/liveness</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/probe/http-liveness.yaml download=pods/probe/http-liveness.yaml><code>pods/probe/http-liveness.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-probe-http-liveness-yaml")' title="Copy pods/probe/http-liveness.yaml to clipboard"></img></div><div class=includecode id=pods-probe-http-liveness-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Custom-Header<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>Awesome<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dans le fichier de configuration, vous pouvez voir que le Pod a un seul conteneur.
Le champ <code>periodSeconds</code> spécifie que le Kubelet doit effectuer une liveness probe toutes les 3 secondes. Le champ <code>initialDelaySeconds</code> indique au Kubelet qu'il devrait attendre 3 secondes avant d'effectuer la première probe. Pour effectuer une probe, le Kubelet envoie une requête HTTP GET au serveur qui s'exécute dans le conteneur et écoute sur le port 8080. Si le handler du chemin <code>/healthz</code> du serveur renvoie un code de succès, le Kubelet considère que le conteneur est vivant et en bonne santé. Si le handler renvoie un code d'erreur, le Kubelet tue le conteneur et le redémarre.</p><p>Tout code supérieur ou égal à 200 et inférieur à 400 indique un succès. Tout autre code indique un échec.</p><p>Vous pouvez voir le code source du serveur dans
<a href=https://github.com/kubernetes/kubernetes/blob/master/test/images/agnhost/liveness/server.go>server.go</a>.</p><p>Pendant les 10 premières secondes où le conteneur est en vie, le handler <code>/healthz</code> renvoie un statut de 200. Après cela, le handler renvoie un statut de 500.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>http.<span style=color:#00a000>HandleFunc</span>(<span style=color:#b44>&#34;/healthz&#34;</span>, <span style=color:#a2f;font-weight:700>func</span>(w http.ResponseWriter, r <span style=color:#666>*</span>http.Request) {
</span></span><span style=display:flex><span>    duration <span style=color:#666>:=</span> time.<span style=color:#00a000>Now</span>().<span style=color:#00a000>Sub</span>(started)
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> duration.<span style=color:#00a000>Seconds</span>() &gt; <span style=color:#666>10</span> {
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>500</span>)
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;erreur: %v&#34;</span>, duration.<span style=color:#00a000>Seconds</span>())))
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>200</span>)
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(<span style=color:#b44>&#34;ok&#34;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>Le Kubelet commence à effectuer des contrôles de santé 3 secondes après le démarrage du conteneur.
Ainsi, les premiers contrôles de santé seront réussis. Mais après 10 secondes, les contrôles de santé échoueront, et le Kubelet tuera et redémarrera le conteneur.</p><p>Pour essayer le HTTP liveness check, créez un Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/probe/http-liveness.yaml
</span></span></code></pre></div><p>Après 10 secondes, visualisez les événements du Pod pour vérifier que les liveness probes ont échoué et le conteneur a été redémarré :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod liveness-http
</span></span></code></pre></div><p>Dans les versions antérieures à la v1.13 (y compris la v1.13), au cas où la variable d'environnement <code>http_proxy</code> (ou <code>HTTP_PROXY</code>) est définie sur le noeud où tourne un Pod, le HTTP liveness probe utilise ce proxy.
Dans les versions postérieures à la v1.13, les paramètres de la variable d'environnement du HTTP proxy local n'affectent pas le HTTP liveness probe.</p><h2 id=définir-une-tcp-liveness-probe>Définir une TCP liveness probe</h2><p>Un troisième type de liveness probe utilise un TCP Socket. Avec cette configuration, le Kubelet tentera d'ouvrir un socket vers votre conteneur sur le port spécifié.
S'il arrive à établir une connexion, le conteneur est considéré comme étant en bonne santé, s'il n'y arrive pas, c'est un échec.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/probe/tcp-liveness-readiness.yaml download=pods/probe/tcp-liveness-readiness.yaml><code>pods/probe/tcp-liveness-readiness.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-probe-tcp-liveness-readiness-yaml")' title="Copy pods/probe/tcp-liveness-readiness.yaml to clipboard"></img></div><div class=includecode id=pods-probe-tcp-liveness-readiness-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/goproxy:0.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>20</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Comme vous le voyez, la configuration pour un check TCP est assez similaire à un check HTTP.
Cet exemple utilise à la fois des readiness et liveness probes. Le Kubelet transmettra la première readiness probe 5 secondes après le démarrage du conteneur. Il tentera de se connecter au conteneur <code>goproxy</code> sur le port 8080. Si la probe réussit, le conteneur sera marqué comme prêt. Kubelet continuera à effectuer ce check tous les 10 secondes.</p><p>En plus de la readiness probe, cette configuration comprend une liveness probe.
Le Kubelet effectuera la première liveness probe 15 secondes après que le conteneur démarre. Tout comme la readiness probe, celle-ci tentera de se connecter au conteneur de <code>goproxy</code> sur le port 8080. Si la liveness probe échoue, le conteneur sera redémarré.</p><p>Pour essayer la TCP liveness check, créez un Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/probe/tcp-liveness-readiness.yaml
</span></span></code></pre></div><p>Après 15 secondes, visualisez les événements de Pod pour vérifier les liveness probes :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod goproxy
</span></span></code></pre></div><h2 id=utilisation-d-un-port-nommé>Utilisation d'un port nommé</h2><p>Vous pouvez utiliser un <a href=/docs/reference/generated/kubernetes-api/v1.25/#containerport-v1-core>ContainerPort</a> nommé pour les HTTP or TCP liveness probes :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=define-startup-probes>Protéger les conteneurs à démarrage lent avec des startup probes</h2><p>Parfois, vous devez faire face à des applications legacy qui peuvent nécessiter un temps de démarrage supplémentaire lors de leur première initialisation.
Dans de telles situations, il peut être compliqué de régler les paramètres de la liveness probe sans compromettant la réponse rapide aux blocages qui ont motivé une telle probe.
L'astuce est de configurer une startup probe avec la même commande, HTTP ou TCP check avec un <code>failureThreshold * periodSeconds</code> assez long pour couvrir le pire des scénarios des temps de démarrage.</p><p>Ainsi, l'exemple précédent deviendrait :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Grâce à la startup probe, l'application aura un maximum de 5 minutes (30 * 10 = 300s) pour terminer son démarrage.
Une fois que la startup probe a réussi, la liveness probe prend le relais pour fournir une réponse rapide aux blocages de conteneurs.
Si la startup probe ne réussit jamais, le conteneur est tué après 300s puis soumis à la <code>restartPolicy</code> (politique de redémarrage) du Pod.</p><h2 id=définir-les-readiness-probes>Définir les readiness probes</h2><p>Parfois, les applications sont temporairement incapables de servir le trafic.
Par exemple, une application peut avoir besoin de charger des larges données ou des fichiers de configuration pendant le démarrage, ou elle peut dépendre de services externes après le démarrage.
Dans ces cas, vous ne voulez pas tuer l'application, mais vous ne voulez pas non plus lui envoyer de requêtes. Kubernetes fournit des readiness probes pour détecter et atténuer ces situations. Un pod avec des conteneurs qui signale qu'elle n'est pas prête ne reçoit pas de trafic par les services de Kubernetes.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Readiness probes fonctionnent sur le conteneur pendant tout son cycle de vie.</div><p>Readiness probes sont configurées de la même façon que les liveness probes. La seule différence est que vous utilisez le champ <code>readinessProbe</code> au lieu du champ <code>livenessProbe</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /tmp/healthy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>La configuration des readiness probes HTTP et TCP reste également identique à celle des liveness probes.</p><p>Les readiness et liveness probes peuvent être utilisées en parallèle pour le même conteneur.
L'utilisation des deux peut garantir que le trafic n'atteigne pas un conteneur qui n'est pas prêt et que les conteneurs soient redémarrés en cas de défaillance.</p><h2 id=configurer-les-probes>Configurer les Probes</h2><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core>Probes</a> ont un certain nombre de champs qui vous pouvez utiliser pour contrôler plus précisément le comportement de la vivacité et de la disponibilité des probes :</p><ul><li><code>initialDelaySeconds</code>: Nombre de secondes après le démarrage du conteneur avant que les liveness et readiness probes ne soient lancées. La valeur par défaut est de 0 seconde. La valeur minimale est 0.</li><li><code>periodSeconds</code>: La fréquence (en secondes) à laquelle la probe doit être effectuée. La valeur par défaut est de 10 secondes. La valeur minimale est de 1.</li><li><code>timeoutSeconds</code>: Nombre de secondes après lequel la probe time out. Valeur par défaut à 1 seconde. La valeur minimale est de 1.</li><li><code>successThreshold</code>: Le minimum de succès consécutifs pour que la probe soit considérée comme réussie après avoir échoué. La valeur par défaut est 1. Doit être 1 pour la liveness probe. La valeur minimale est de 1.</li><li><code>failureThreshold</code>: Quand un Pod démarre et que la probe échoue, Kubernetes va tenter <code>failureThreshold</code> fois avant d'abandonner. Abandonner en cas de liveness probe signifie le redémarrage du conteneur. En cas de readiness probe, le Pod sera marqué Unready.
La valeur par défaut est 3, la valeur minimum est 1.</li></ul><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#httpgetaction-v1-core>HTTP probes</a>
ont des champs supplémentaires qui peuvent être définis sur <code>httpGet</code> :</p><ul><li><code>host</code>: Nom de l'hôte auquel se connecter, par défaut l'IP du pod. Vous voulez peut être mettre "Host" en httpHeaders à la place.</li><li><code>scheme</code>: Schéma à utiliser pour se connecter à l'hôte (HTTP ou HTTPS). La valeur par défaut est HTTP.</li><li><code>path</code>: Chemin d'accès sur le serveur HTTP.</li><li><code>httpHeaders</code>: En-têtes personnalisés à définir dans la requête. HTTP permet des en-têtes répétés.</li><li><code>port</code>: Nom ou numéro du port à accéder sur le conteneur. Le numéro doit être dans un intervalle de 1 à 65535.</li></ul><p>Pour une probe HTTP, le Kubelet envoie une requête HTTP au chemin et au port spécifiés pour effectuer la vérification. Le Kubelet envoie la probe à l'adresse IP du Pod, à moins que l'adresse ne soit surchargée par le champ optionnel <code>host</code> dans <code>httpGet</code>. Si Le champ <code>scheme</code> est mis à <code>HTTPS</code>, le Kubelet envoie une requête HTTPS en ignorant la vérification du certificat. Dans la plupart des scénarios, vous ne voulez pas définir le champ <code>host</code>.
Voici un scénario où vous le mettriez en place. Supposons que le conteneur écoute sur 127.0.0.1 et que le champ <code>hostNetwork</code> du Pod a la valeur true. Alors <code>host</code>, sous <code>httpGet</code>, devrait être défini à 127.0.0.1. Si votre Pod repose sur des hôtes virtuels, ce qui est probablement plus courant, vous ne devriez pas utiliser <code>host</code>, mais plutôt mettre l'en-tête <code>Host</code> dans <code>httpHeaders</code>.</p><p>Le Kubelet fait la connexion de la probe au noeud, pas dans le Pod, ce qui signifie que vous ne pouvez pas utiliser un nom de service dans le paramètre <code>host</code> puisque le Kubelet est incapable pour le résoudre.</p><h2 id=a-suivre>A suivre</h2><ul><li>Pour en savoir plus sur
<a href=/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Probes des Conteneurs</a>.</li></ul><h3 id=référence>Référence</h3><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>Pod</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Container</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core>Probe</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bbc17480da6d051c696489654c64064a>3.9 - Assigner des pods aux nœuds</h1><p>Cette page montre comment assigner un Pod à un nœud particulier dans un cluster Kubernetes.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><h2 id=ajouter-un-label-à-un-nœud>Ajouter un label à un nœud</h2><ol><li><p>Listez les nœuds de votre cluster :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><p>La sortie est la suivante :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      STATUS    ROLES     AGE     VERSION
</span></span><span style=display:flex><span>worker0   Ready     &lt;none&gt;    1d      v1.13.0
</span></span><span style=display:flex><span>worker1   Ready     &lt;none&gt;    1d      v1.13.0
</span></span><span style=display:flex><span>worker2   Ready     &lt;none&gt;    1d      v1.13.0
</span></span></code></pre></div></li><li><p>Choisissez l'un de vos nœuds et ajoutez-y un label :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</span></span></code></pre></div><p>où <code>&lt;your-node-name></code> est le nom du noeud que vous avez choisi.</p></li><li><p>Vérifiez que le nœud que vous avez choisi a le label <code>disktype=ssd</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>La sortie est la suivante :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      STATUS    ROLES    AGE     VERSION        LABELS
</span></span><span style=display:flex><span>worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype<span style=color:#666>=</span>ssd,kubernetes.io/hostname<span style=color:#666>=</span>worker0
</span></span><span style=display:flex><span>worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
</span></span><span style=display:flex><span>worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</span></span></code></pre></div><p>Dans la sortie précédente, vous constatez que le nœud <code>worker0</code> possède le label <code>disktype=ssd</code>.</p></li></ol><h2 id=créez-un-pod-qui-sera-planifié-sur-un-nœud-sélectionné>Créez un pod qui sera planifié sur un nœud sélectionné.</h2><p>Le fichier de configuration de pod décrit un pod qui possède un selector de nœud de type <code>disktype:ssd</code>. Cela signifie que le pod sera planifié sur un nœud ayant le label <code>disktype=ssd</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-yaml")' title="Copy pods/pod-nginx.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Utilisez le fichier de configuration pour créer un pod qui sera ordonnancé sur votre nœud choisi :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/pod-nginx.yaml
</span></span></code></pre></div></li><li><p>Vérifiez que le pod fonctionne sur le nœud que vous avez choisi :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><p>La sortie est la suivante :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
</span></span><span style=display:flex><span>nginx    1/1       Running   <span style=color:#666>0</span>          13s    10.200.0.4   worker0
</span></span></code></pre></div></li></ol><h2 id=créez-un-pod-qui-va-être-planifié-sur-un-nœud-spécifique>Créez un pod qui va être planifié sur un nœud spécifique</h2><p>Vous pouvez également ordonnancer un pod sur un nœud spécifique via le paramètre <code>nodeName</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/pod-nginx-specific-node.yaml download=pods/pod-nginx-specific-node.yaml><code>pods/pod-nginx-specific-node.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-specific-node-yaml")' title="Copy pods/pod-nginx-specific-node.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-specific-node-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>foo-node<span style=color:#bbb> </span><span style=color:#080;font-style:italic># schedule pod to specific node</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Utilisez le fichier de configuration pour créer un pod qui sera ordonnancé sur <code>foo-node</code> uniquement.</p><h2 id=a-suivre>A suivre</h2><p>Pour en savoir plus sur
<a href=/docs/concepts/overview/working-with-objects/labels/>labels et selectors</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1e7baac1825631a5af5d2aebcf059249>3.10 - Configurer l'initialisation du pod</h1><p>Cette page montre comment utiliser un Init conteneur pour initialiser un Pod avant de lancer un conteneur d'application.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><h2 id=créer-un-pod-qui-a-un-init-container>Créer un Pod qui a un Init Container</h2><p>Dans cet exercice, vous allez créer un Pod qui a un conteneur d'application et Init conteneur. Le conteneur d'initialisation est achevé avant que le conteneur d'application ne démarre.</p><p>Voici le fichier de configuration du Pod :</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/init-containers.yaml download=pods/init-containers.yaml><code>pods/init-containers.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-init-containers-yaml")' title="Copy pods/init-containers.yaml to clipboard"></img></div><div class=includecode id=pods-init-containers-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># These containers are run during pod initialization</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>install<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- wget<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-O&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/work-dir/index.html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- http://kubernetes.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/work-dir&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>Default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dans le fichier de configuration, vous pouvez voir que le Pod a un Volume que le conteneur d'initialisation et le conteneur d'application partagent.</p><p>Le conteneur d'initialisation monte le volume partagé à <code>/work-dir</code>, et le conteneur d'application monte le volume partagé à <code>/usr/share/nginx/html</code>. Le conteneur d'initialisation exécute la commande suivante puis se termine :</p><pre><code>wget -O /work-dir/index.html http://kubernetes.io
</code></pre><p>Remarquez que le conteneur d'initialisation écrit le fichier <code>index.html</code> dans le répertoire racine
du serveur nginx.</p><p>Créez le Pod :</p><pre><code>kubectl apply -f https://k8s.io/examples/pods/init-containers.yaml
</code></pre><p>Vérifiez que le conteneur nginx fonctionne :</p><pre><code>kubectl get pod init-demo
</code></pre><p>La sortie montre que le conteneur nginx est en cours d'exécution :</p><pre><code>NAME        READY     STATUS    RESTARTS   AGE
init-demo   1/1       Running   0          1m
</code></pre><p>Entrez dans la console shell du conteneur nginx du Pod init-demo :</p><pre><code>kubectl exec -it init-demo -- /bin/bash
</code></pre><p>Dans votre shell, envoyez une requête GET au serveur nginx :</p><pre><code>root@nginx:~# apt-get update
root@nginx:~# apt-get install curl
root@nginx:~# curl localhost
</code></pre><p>La sortie montre que nginx sert la page web qui a été écrite par le conteneur d'initialisation :</p><pre><code>&lt;!Doctype html&gt;
&lt;html id=&quot;home&quot;&gt;

&lt;head&gt;
...
&quot;url&quot;: &quot;http://kubernetes.io/&quot;}&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  ...
  &lt;p&gt;Kubernetes is open source giving you the freedom to take advantage ...&lt;/p&gt;
  ...
</code></pre><h2 id=a-suivre>A suivre</h2><ul><li>Pour en savoir plus sur
<a href=/docs/tasks/access-application-cluster/communicate-containers-same-pod-shared-volume/>communiquer entre conteneurs fonctionnant dans le même Pod</a>.</li><li>Pour en savoir plus sur <a href=/docs/concepts/workloads/pods/init-containers/>Init Conteneurs</a>.</li><li>Pour en savoir plus sur <a href=/docs/concepts/storage/volumes/>Volumes</a>.</li><li>Pour en savoir plus sur <a href=/docs/tasks/debug/debug-application/debug-init-containers/>Débogage des Init Conteneurs</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ed34e761c3dbd00fa79577fa78e30020>3.11 - Configurer un pod pour utiliser une ConfigMap</h1><p>Les ConfigMaps vous permettent de découpler les artefacts de configuration du contenu de l'image pour garder les applications conteneurisées portables.
Cette page fournit une série d'exemples d'utilisation montrant comment créer des ConfigMaps et configurer des pods à l'aide des données stockées dans des ConfigMaps.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><h2 id=créer-un-configmap>Créer un ConfigMap</h2><p>Vous pouvez utiliser soit <code>kubectl create configmap</code> ou un générateur ConfigMap dans <code>kustomization.yaml</code> pour créer un ConfigMap.
Notez que <code>kubectl</code> prends en charge <code>kustomization.yaml</code> à partir de la version 1.14.</p><h3 id=créer-un-configmap-à-l-aide-de-kubectl-create-configmap>Créer un ConfigMap à l'aide de kubectl create configmap</h3><p>Utilisez la commande <code>kubectl create configmap</code> pour créer des Configmaps depuis des <a href=#create-configmaps-from-directories>dossiers</a>, <a href=#create-configmaps-from-files>fichiers</a>, ou des <a href=#create-configmaps-from-literal-values>valeurs littérales</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap &lt;map-name&gt; &lt;data-source&gt;
</span></span></code></pre></div><p>où &lt;map-name> est le nom que vous souhaitez attribuer à ConfigMap et &lt;data-source> est le répertoire, le fichier ou la valeur littérale à partir de laquelle récupérer les données.</p><p>La source de données correspond à une paire clé-valeur dans ConfigMap, où</p><ul><li>clé = le nom du fichier ou la clé que vous avez fournie sur la ligne de commande, et</li><li>valeur = le contenu du fichier ou la valeur littérale que vous avez fournie sur la ligne de commande.</li></ul><p>Vous pouvez utiliser <a href=/docs/reference/generated/kubectl/kubectl-commands/#describe><code>kubectl describe</code></a> ou <a href=/docs/reference/generated/kubectl/kubectl-commands/#get><code>kubectl get</code></a> pour récupérer des informations sur un ConfigMap.</p><h4 id=créer-des-configmaps-à-partir-de-répertoires>Créer des ConfigMaps à partir de répertoires</h4><p>Vous pouvez utiliser <code>kubectl create configmap</code> pour créer un ConfigMap à partir de plusieurs fichiers dans le même répertoire.</p><p>Par exemple:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Créez le répertoire local</span>
</span></span><span style=display:flex><span>mkdir -p configure-pod-container/configmap/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Téléchargez les exemples de fichiers dans le répertoire `configure-pod-container/configmap/`</span>
</span></span><span style=display:flex><span>wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties
</span></span><span style=display:flex><span>wget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Créer la configmap</span>
</span></span><span style=display:flex><span>kubectl create configmap game-config --from-file<span style=color:#666>=</span>configure-pod-container/configmap/
</span></span></code></pre></div><p>combine le contenu du répertoire <code>configure-pod-container/configmap/</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>game.properties
</span></span><span style=display:flex><span>ui.properties
</span></span></code></pre></div><p>dans le ConfigMap suivant:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe configmaps game-config
</span></span></code></pre></div><p>où la sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:           game-config
</span></span><span style=display:flex><span>Namespace:      default
</span></span><span style=display:flex><span>Labels:         &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:    &lt;none&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data
</span></span><span style=display:flex><span>====
</span></span><span style=display:flex><span>game.properties:        158 bytes
</span></span><span style=display:flex><span>ui.properties:          83 bytes
</span></span></code></pre></div><p>Les fichiers <code>game.properties</code> et <code>ui.properties</code> dans le répertoire <code>configure-pod-container/configmap/</code> sont représentés dans la section <code>data</code> de la ConfigMap.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmaps game-config -o yaml
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:52:05Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;516&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>b4952dc3-d670-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies=aliens
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    lives=3
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.good=purple
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    allow.textmode=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    how.nice.to.look=fairlyNice</span><span style=color:#bbb>    
</span></span></span></code></pre></div><h4 id=créer-des-configmaps-à-partir-de-fichiers>Créer des ConfigMaps à partir de fichiers</h4><p>Vous pouvez utiliser <code>kubectl create configmap</code> pour créer un ConfigMap à partir d'un fichier individuel ou de plusieurs fichiers.</p><p>Par exemple,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</span></span></code></pre></div><p>produirait le ConfigMap suivant:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe configmaps game-config-2
</span></span></code></pre></div><p>où la sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:           game-config-2
</span></span><span style=display:flex><span>Namespace:      default
</span></span><span style=display:flex><span>Labels:         &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:    &lt;none&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data
</span></span><span style=display:flex><span>====
</span></span><span style=display:flex><span>game.properties:        158 bytes
</span></span></code></pre></div><p>Vous pouvez passer l'argument <code>--from-file</code> plusieurs fois pour créer un ConfigMap à partir de plusieurs sources de données.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties --from-file<span style=color:#666>=</span>configure-pod-container/configmap/ui.properties
</span></span></code></pre></div><p>Décrivez la ConfigMap crée <code>game-config-2</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe configmaps game-config-2
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:           game-config-2
</span></span><span style=display:flex><span>Namespace:      default
</span></span><span style=display:flex><span>Labels:         &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:    &lt;none&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data
</span></span><span style=display:flex><span>====
</span></span><span style=display:flex><span>game.properties:        158 bytes
</span></span><span style=display:flex><span>ui.properties:          83 bytes
</span></span></code></pre></div><p>Utilisez l'option <code>--from-env-file</code> pour créer un ConfigMap à partir d'un fichier env, par exemple:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Les fichiers env contiennent une liste de variables d&#39;environnement.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Ces règles de syntaxe s&#39;appliquent:</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#   Chaque ligne d&#39;un fichier env doit être au format VAR=VAL.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#   Les lignes commençant par # (c&#39;est-à-dire les commentaires) sont ignorées.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#   Les lignes vides sont ignorées.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#   Il n&#39;y a pas de traitement spécial des guillemets (c&#39;est-à-dire qu&#39;ils feront partie de la valeur ConfigMap)).</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Téléchargez les exemples de fichiers dans le dossier `configure-pod-container/configmap/`</span>
</span></span><span style=display:flex><span>wget https://kubernetes.io/examples/configmap/game-env-file.properties -O configure-pod-container/configmap/game-env-file.properties
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Le fichier env `game-env-file.properties` ressemble à ceci</span>
</span></span><span style=display:flex><span>cat configure-pod-container/configmap/game-env-file.properties
</span></span><span style=display:flex><span><span style=color:#b8860b>enemies</span><span style=color:#666>=</span>aliens
</span></span><span style=display:flex><span><span style=color:#b8860b>lives</span><span style=color:#666>=</span><span style=color:#666>3</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>allowed</span><span style=color:#666>=</span><span style=color:#b44>&#34;true&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Ce commentaire et la ligne vide au-dessus sont ignorés</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-env-file <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>       --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties
</span></span></code></pre></div><p>produirait le ConfigMap suivant:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmap game-config-env-file -o yaml
</span></span></code></pre></div><p>où la sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:36:28Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-env-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;809965&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d9d1ca5b-eb34-11e7-887b-42010a8002b8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;&#34;true&#34;&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>enemies</span>:<span style=color:#bbb> </span>aliens<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Lorsque vous passez plusieurs fois <code>--from-env-file</code> pour créer un ConfigMap à partir de plusieurs sources de données, seul le dernier fichier env est utilisé.</div><p>Le comportement consistant à passer plusieurs fois <code>--from-env-file</code> est démontré par:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Téléchargez les exemples de fichiers dans le répertoire `configure-pod-container/configmap/`</span>
</span></span><span style=display:flex><span>wget https://k8s.io/examples/configmap/ui-env-file.properties -O configure-pod-container/configmap/ui-env-file.properties
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Créez le configmap</span>
</span></span><span style=display:flex><span>kubectl create configmap config-multi-env-files <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/ui-env-file.properties
</span></span></code></pre></div><p>produirait le ConfigMap suivant:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmap config-multi-env-files -o yaml
</span></span></code></pre></div><p>où la sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:38:34Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-multi-env-files<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;810136&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>252c4572-eb35-11e7-887b-42010a8002b8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>color</span>:<span style=color:#bbb> </span>purple<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>how</span>:<span style=color:#bbb> </span>fairlyNice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>textmode</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=définissez-la-clé-à-utiliser-lors-de-la-création-d-un-configmap-à-partir-d-un-fichier>Définissez la clé à utiliser lors de la création d'un ConfigMap à partir d'un fichier</h4><p>Vous pouvez définir une clé autre que le nom de fichier à utiliser dans la section <code>data</code> de votre ConfigMap lorsque vous utilisez l'argument <code>--from-file</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>&lt;my-key-name&gt;<span style=color:#666>=</span>&lt;path-to-file&gt;
</span></span></code></pre></div><p>où <code>&lt;my-key-name></code> est la clé que vous souhaitez utiliser dans la ConfigMap et <code>&lt;path-to-file></code> est l'emplacement du fichier de source de données que vous souhaitez que la clé représente.</p><p>Par exemple:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>game-special-key<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</span></span></code></pre></div><p>produirait la ConfigMap suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmaps game-config-3 -o yaml
</span></span></code></pre></div><p>où la sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:54:22Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;530&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>05f8da22-d671-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game-special-key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies=aliens
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    lives=3
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span></span></span></code></pre></div><h4 id=créer-des-configmaps-à-partir-de-valeurs-littérales>Créer des ConfigMaps à partir de valeurs littérales</h4><p>Vous pouvez utiliser <code>kubectl create configmap</code> avec l'argument <code>--from-literal</code> définir une valeur littérale à partir de la ligne de commande:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very --from-literal<span style=color:#666>=</span>special.type<span style=color:#666>=</span>charm
</span></span></code></pre></div><p>Vous pouvez transmettre plusieurs paires clé-valeur.
Chaque paire fournie sur la ligne de commande est représentée comme une entrée distincte dans la section <code>data</code> de la ConfigMap.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmaps special-config -o yaml
</span></span></code></pre></div><p>La sortie est similaire à ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;651&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>dadce046-d673-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.type</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=créer-un-configmap-à-partir-du-générateur>Créer un ConfigMap à partir du générateur</h3><p><code>kubectl</code> supporte <code>kustomization.yaml</code> depuis 1.14.
Vous pouvez également créer un ConfigMap à partir de générateurs, puis l'appliquer pour créer l'objet sur l'Apiserver.
Les générateurs doivent être spécifiés dans un <code>kustomization.yaml</code> à l'intérieur d'un répertoire.</p><h4 id=générer-des-configmaps-à-partir-de-fichiers>Générer des ConfigMaps à partir de fichiers</h4><p>Par exemple, pour générer un ConfigMap à partir de fichiers <code>configure-pod-container/configmap/game.properties</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Create a kustomization.yaml file with ConfigMapGenerator</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: game-config-4
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - configure-pod-container/configmap/game.properties
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Appliquer le dossier kustomization pour créer l'objet ConfigMap.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span><span style=display:flex><span>configmap/game-config-4-m9dm2f92bt created
</span></span></code></pre></div><p>Vous pouvez vérifier que le ConfigMap a été créé comme ceci:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl get configmap
</span></span><span style=display:flex><span>NAME                       DATA   AGE
</span></span><span style=display:flex><span>game-config-4-m9dm2f92bt   1      37s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl describe configmaps/game-config-4-m9dm2f92bt
</span></span><span style=display:flex><span>Name:         game-config-4-m9dm2f92bt
</span></span><span style=display:flex><span>Namespace:    default
</span></span><span style=display:flex><span>Labels:       &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:  kubectl.kubernetes.io/last-applied-configuration:
</span></span><span style=display:flex><span>                {&#34;apiVersion&#34;:&#34;v1&#34;,&#34;data&#34;:{&#34;game.properties&#34;:&#34;enemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.p...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data
</span></span><span style=display:flex><span>====
</span></span><span style=display:flex><span>game.properties:
</span></span><span style=display:flex><span>----
</span></span><span style=display:flex><span>enemies=aliens
</span></span><span style=display:flex><span>lives=3
</span></span><span style=display:flex><span>enemies.cheat=true
</span></span><span style=display:flex><span>enemies.cheat.level=noGoodRotten
</span></span><span style=display:flex><span>secret.code.passphrase=UUDDLRLRBABAS
</span></span><span style=display:flex><span>secret.code.allowed=true
</span></span><span style=display:flex><span>secret.code.lives=30
</span></span><span style=display:flex><span>Events:  &lt;none&gt;
</span></span></code></pre></div><p>Notez que le nom ConfigMap généré a un suffixe obtenu par hachage de son contenu.
Cela garantit qu'un nouveau ConfigMap est généré chaque fois que le contenu est modifié.</p><h4 id=définissez-la-clé-à-utiliser-lors-de-la-génération-d-un-configmap-à-partir-d-un-fichier>Définissez la clé à utiliser lors de la génération d'un ConfigMap à partir d'un fichier</h4><p>Vous pouvez définir une clé autre que le nom de fichier à utiliser dans le générateur ConfigMap.
Par exemple, pour générer un ConfigMap à partir du fichier <code>configure-pod-container/configmap/game.properties</code>
avec la clé <code>game-special-key</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Créer un fichier kustomization.yaml avec ConfigMapGenerator</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: game-config-5
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - game-special-key=configure-pod-container/configmap/game.properties
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Appliquer le dossier kustomization pour créer l'objet ConfigMap.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl apply -k .
</span></span><span style=display:flex><span>configmap/game-config-5-m67dt67794 created
</span></span></code></pre></div><h4 id=générer-des-configmaps-à-partir-de-littéraux>Générer des ConfigMaps à partir de littéraux</h4><p>Pour générer un ConfigMap à partir de littéraux <code>special.type=charm</code> et <code>special.how=very</code>, vous pouvez spécifier le générateur ConfigMap dans <code>kustomization.yaml</code> comme</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Create a kustomization.yaml file with ConfigMapGenerator</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: special-config-2
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - special.how=very
</span></span></span><span style=display:flex><span><span style=color:#b44>  - special.type=charm
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Appliquez le dossier kustomization pour créer l'objet ConfigMap.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl apply -k .
</span></span><span style=display:flex><span>configmap/special-config-2-c92b5mmcf2 created
</span></span></code></pre></div><h2 id=définir-des-variables-d-environnement-de-conteneur-à-l-aide-des-données-configmap>Définir des variables d'environnement de conteneur à l'aide des données ConfigMap</h2><h3 id=définissez-une-variable-d-environnement-de-conteneur-avec-les-données-d-une-seule-configmap>Définissez une variable d'environnement de conteneur avec les données d'une seule ConfigMap</h3><ol><li><p>Définissez une variable d'environnement comme paire clé-valeur dans un ConfigMap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very
</span></span></code></pre></div></li><li><p>Attribuez la valeur <code>special.how</code> défini dans ConfigMap à la variable d'environnement <code>SPECIAL_LEVEL_KEY</code> dans la spécification du Pod.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/pod-single-configmap-env-variable.yaml download=pods/pod-single-configmap-env-variable.yaml><code>pods/pod-single-configmap-env-variable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-single-configmap-env-variable-yaml")' title="Copy pods/pod-single-configmap-env-variable.yaml to clipboard"></img></div><div class=includecode id=pods-pod-single-configmap-env-variable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Définie la variable d&#39;environnement</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># La ConfigMap contenant la valeur que vous voulez attribuer à SPECIAL_LEVEL_KEY</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># Spécifier la clé associée à la valeur</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
   </span></span></span></code></pre></div></div></div><p>Créez le pod:</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-single-configmap-env-variable.yaml
</span></span></code></pre></div><p>Maintenant, la sortie du Pod comprend une variable d'environnement <code>SPECIAL_LEVEL_KEY=very</code>.</p><h3 id=définir-des-variables-d-environnement-de-conteneur-avec-des-données-de-plusieurs-configmaps>Définir des variables d'environnement de conteneur avec des données de plusieurs ConfigMaps</h3><ul><li><p>Comme avec l'exemple précédent, créez d'abord les ConfigMaps.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/configmap/configmaps.yaml download=configmap/configmaps.yaml><code>configmap/configmaps.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("configmap-configmaps-yaml")' title="Copy configmap/configmaps.yaml to clipboard"></img></div><div class=includecode id=configmap-configmaps-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>log_level</span>:<span style=color:#bbb> </span>INFO<span style=color:#bbb>
   </span></span></span></code></pre></div></div></div><p>Créez le ConfigMap:</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/configmap/configmaps.yaml
</span></span></code></pre></div><ul><li><p>Définissez les variables d'environnement dans la spécification Pod.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/pod-multiple-configmap-env-variable.yaml download=pods/pod-multiple-configmap-env-variable.yaml><code>pods/pod-multiple-configmap-env-variable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-multiple-configmap-env-variable-yaml")' title="Copy pods/pod-multiple-configmap-env-variable.yaml to clipboard"></img></div><div class=includecode id=pods-pod-multiple-configmap-env-variable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>LOG_LEVEL<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
  </span></span></span></code></pre></div></div></div><p>Créez le pod:</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-multiple-configmap-env-variable.yaml
</span></span></code></pre></div><p>Maintenant, la sortie du Pod comprend des variables d'environnement <code>SPECIAL_LEVEL_KEY=very</code> et <code>LOG_LEVEL=INFO</code>.</p><h2 id=configurer-toutes-les-paires-clé-valeur-dans-un-configmap-en-tant-que-variables-d-environnement-de-conteneur>Configurer toutes les paires clé-valeur dans un ConfigMap en tant que variables d'environnement de conteneur</h2><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Cette fonctionnalité est disponible dans Kubernetes v1.6 et versions ultérieures.</div><ul><li><p>Créez un ConfigMap contenant plusieurs paires clé-valeur.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("configmap-configmap-multikeys-yaml")' title="Copy configmap/configmap-multikeys.yaml to clipboard"></img></div><div class=includecode id=configmap-configmap-multikeys-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
  </span></span></span></code></pre></div></div></div><p>Créez le ConfigMap:</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</span></span></code></pre></div><ul><li>Utilisez <code>envFrom</code> pour définir toutes les données du ConfigMap en tant que variables d'environnement du conteneur.
La clé de ConfigMap devient le nom de la variable d'environnement dans le pod.</li></ul><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/pod-configmap-envFrom.yaml download=pods/pod-configmap-envFrom.yaml><code>pods/pod-configmap-envFrom.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-envfrom-yaml")' title="Copy pods/pod-configmap-envFrom.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-envfrom-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMapRef</span>:<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
 </span></span></span></code></pre></div></div></div><p>Créez le pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml
</span></span></code></pre></div><p>Maintenant, la sortie du Pod comprend les variables d'environnement <code>SPECIAL_LEVEL=very</code> et <code>SPECIAL_TYPE=charm</code>.</p><h2 id=utiliser-des-variables-d-environnement-définies-par-configmap-dans-les-commandes-du-pod>Utiliser des variables d'environnement définies par ConfigMap dans les commandes du Pod</h2><p>Vous pouvez utiliser des variables d'environnement définies par ConfigMap dans la section <code>command</code> de la spécification du Pod en utilisant la syntaxe de substitution Kubernetes <code>$(VAR_NAME)</code>.</p><p>Par exemple, la spécification de pod suivante</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/pod-configmap-env-var-valueFrom.yaml download=pods/pod-configmap-env-var-valueFrom.yaml><code>pods/pod-configmap-env-var-valueFrom.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-env-var-valuefrom-yaml")' title="Copy pods/pod-configmap-env-var-valueFrom.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-env-var-valuefrom-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/echo&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;$(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_TYPE_KEY<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_TYPE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>créé en exécutant</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml
</span></span></code></pre></div><p>produit la sortie suivante dans le conteneur <code>test-container</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>very charm
</span></span></code></pre></div><h2 id=ajouter-des-données-configmap-à-un-volume>Ajouter des données ConfigMap à un volume</h2><p>Comme expliqué dans <a href=#create-configmaps-from-files>Créer des ConfigMaps à partir de fichiers</a>, lorsque vous créez un ConfigMap à l'aide <code>--from-file</code>, le nom de fichier devient une clé stockée dans la section <code>data</code> du ConfigMap.
Le contenu du fichier devient la valeur de la clé.</p><p>Les exemples de cette section se réfèrent à un ConfigMap nommé special-config, illustré ci-dessous.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("configmap-configmap-multikeys-yaml")' title="Copy configmap/configmap-multikeys.yaml to clipboard"></img></div><div class=includecode id=configmap-configmap-multikeys-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Créez le ConfigMap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</span></span></code></pre></div><h3 id=remplissez-un-volume-avec-des-données-stockées-dans-un-configmap>Remplissez un volume avec des données stockées dans un ConfigMap</h3><p>Ajoutez le nom ConfigMap sous la section <code>volumes</code> de la spécification Pod.
Ceci ajoute les données ConfigMap au répertoire spécifié comme <code>volumeMounts.mountPath</code> (dans ce cas, <code>/etc/config</code>).
La section <code>command</code> répertorie les fichiers de répertoire dont les noms correspondent aux clés de ConfigMap.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/pod-configmap-volume.yaml download=pods/pod-configmap-volume.yaml><code>pods/pod-configmap-volume.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-volume-yaml")' title="Copy pods/pod-configmap-volume.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-volume-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ls /etc/config/&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Indiquez le nom de la ConfigMap contenant les fichiers que vous souhaitez ajouter au conteneur</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Créez le pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume.yaml
</span></span></code></pre></div><p>Lorsque le pod s'exécute, la commande <code>ls /etc/config/</code> produit la sortie ci-dessous:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>SPECIAL_LEVEL
</span></span><span style=display:flex><span>SPECIAL_TYPE
</span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> S'il y a des fichiers dans le dossier <code>/etc/config/</code>, ils seront supprimés.</div><h3 id=ajouter-un-configmap-à-un-chemin-spécifique-dans-un-volume>Ajouter un configmap à un chemin spécifique dans un volume</h3><p>Utilisez le champ <code>path</code> pour spécifier le chemin de fichier souhaité pour les éléments de configmap spécifiques.
Dans ce cas, le <code>SPECIAL_LEVEL</code> sera monté dans le volume <code>config-volume</code> au chemin <code>/etc/config/keys</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/pod-configmap-volume-specific-key.yaml download=pods/pod-configmap-volume-specific-key.yaml><code>pods/pod-configmap-volume-specific-key.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-volume-specific-key-yaml")' title="Copy pods/pod-configmap-volume-specific-key.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-volume-specific-key-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#b44>&#34;cat /etc/config/keys&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>keys<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Créez le Pod :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml
</span></span></code></pre></div><p>Lorsque le pod fonctionne, la commande <code>cat /etc/config/keys</code> produit la sortie ci-dessous :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>very
</span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>Avertissement:</strong> Comme avant, tous les fichiers précédents dans le répertoire <code>/etc/config/</code> seront supprimés.</div><h3 id=projections-de-clés-pour-des-chemins-et-des-autorisations-de-fichiers-spécifiques>Projections de clés pour des chemins et des autorisations de fichiers spécifiques</h3><p>Vous pouvez projeter des clés vers des chemins spécifiques avec des autorisations spécifiques fichiers par fichiers.
Le guide de l'utilisateur <a href=/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod>Secrets</a> explique la syntaxe.</p><h3 id=les-configmaps-montées-sont-mises-à-jour-automatiquement>Les ConfigMaps montées sont mises à jour automatiquement</h3><p>Lorsqu'une ConfigMap déjà consommée dans un volume est mise à jour, les clés projetées sont éventuellement mises à jour elles aussi.
Kubelet vérifie si la ConfigMap montée est fraîche à chaque synchronisation périodique.
Cependant, il utilise son cache local basé sur le ttl pour obtenir la valeur actuelle de la ConfigMap.
Par conséquent, le délai total entre le moment où la ConfigMap est mise à jour et le moment où les nouvelles clés sont projetées vers le pod peut être aussi long que la période de synchronisation de kubelet (1 minute par défaut) + le ttl du cache ConfigMaps (1 minute par défaut) dans kubelet.
Vous pouvez déclencher un rafraîchissement immédiat en mettant à jour l'une des annotations du pod.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Un conteneur utilisant un ConfigMap comme volume <a href=/docs/concepts/storage/volumes/#using-subpath>subPath</a> ne recevra pas les mises à jour de ConfigMap.</div><h2 id=comprendre-le-lien-entre-les-configmaps-et-les-pods>Comprendre le lien entre les ConfigMaps et les Pods</h2><p>La ressource API ConfigMap stocke les données de configuration sous forme de paires clé-valeur.
Les données peuvent être consommées dans des pods ou fournir les configurations des composants du système tels que les contrôleurs.
ConfigMap est similaire à <a href=/docs/concepts/configuration/secret/>Secrets</a>, mais fournit un moyen de travailler avec des chaînes de caractères qui ne contiennent pas d'informations sensibles.
Les utilisateurs comme les composants du système peuvent stocker des données de configuration dans un ConfigMap.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Les ConfigMaps doivent faire référence aux fichiers de propriétés, et non les remplacer.
Pensez à la ConfigMap comme représentant quelque chose de similaire au répertoire <code>/etc</code> de Linux et à son contenu.
Par exemple, si vous créez un <a href=/docs/concepts/storage/volumes/>volume Kubernetes</a> à partir d'une ConfigMap, chaque élément de données de la ConfigMap est représenté par un fichier individuel dans le volume.</div><p>Le champ <code>data</code> de la ConfigMap contient les données de configuration.
Comme le montre l'exemple ci-dessous, cela peut être simple -- comme des propriétés individuelles définies à l'aide de <code>--from-literal</code> -- ou complexe -- comme des fichiers de configuration ou des blobs JSON définis à l'aide de <code>--from-file</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># example of a simple property defined using --from-literal</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.1</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.2</span>:<span style=color:#bbb> </span>world<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># example of a complex property defined using --from-file</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.file</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    property.1=value-1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    property.2=value-2
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    property.3=value-3</span><span style=color:#bbb>    
</span></span></span></code></pre></div><h3 id=restrictions>Restrictions</h3><ul><li><p>Vous devez créer un ConfigMap avant de le référencer dans une spécification de Pod (sauf si vous marquez le ConfigMap comme "facultatif").
Si vous faites référence à un ConfigMap qui n'existe pas, le Pod ne démarrera pas.
De même, les références à des clés qui n'existent pas dans la ConfigMap empêcheront le pod de démarrer.</p></li><li><p>Si vous utilisez <code>envFrom</code> pour définir des variables d'environnement à partir de ConfigMaps, les clés considérées comme invalides seront ignorées.
Le pod sera autorisé à démarrer, mais les noms invalides seront enregistrés dans le journal des événements (<code>InvalidVariableNames</code>).
Le message du journal énumère chaque clé sautée.
Par exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>Le résultat est similaire à celui-ci :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>LASTSEEN FIRSTSEEN COUNT NAME          KIND  SUBOBJECT  TYPE      REASON                            SOURCE                MESSAGE
</span></span><span style=display:flex><span>0s       0s        1     dapi-test-pod Pod              Warning   InvalidEnvironmentVariableNames   {kubelet, 127.0.0.1}  Keys [1badkey, 2alsobad] from the EnvFrom configMap default/myconfig were skipped since they are considered invalid environment variable names.
</span></span></code></pre></div></li><li><p>Les ConfigMaps résident dans un <a class=glossary-tooltip title='An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a>.
Un ConfigMap ne peut être référencé que par des pods résidant dans le même namespace.</p></li><li><p>Vous ne pouvez pas utiliser des ConfigMaps pour <a class=glossary-tooltip title='A pod managed directly by the kubelet daemon on a specific node.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='static pods'>static pods</a>, car le Kubelet ne le supporte pas.</p></li></ul><p>A suivre</p><ul><li>Suivez un exemple concret de <a href=/docs/tutorials/configuration/configure-redis-using-configmap/>Configurer Redis en utilisant un ConfigMap</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3d7b9cb24a647c36ba63f7a02ec49010>3.12 - Partager l'espace de nommage des processus entre les conteneurs d'un Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code></div><p>Cette page montre comment configurer le partage de l'espace de noms d'un processus pour un pod. Lorsque le partage de l'espace de noms des processus est activé, les processus d'un conteneur sont visibles pour tous les autres conteneurs de ce pod.</p><p>Vous pouvez utiliser cette fonctionnalité pour configurer les conteneurs coopérants, comme un conteneur de sidecar de gestionnaire de journaux, ou pour dépanner les images de conteneurs qui n'incluent pas d'utilitaires de débogage comme un shell.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Votre serveur Kubernetes doit être au moins à la version v1.10.
Pour consulter la version, entrez <code>kubectl version</code>.</p><h2 id=configurer-un-pod>Configurer un Pod</h2><p>Le partage de l'espace de nommage du processus est activé en utilisant le champ <code>shareProcessNamespace</code> de <code>v1.PodSpec</code>. Par exemple:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/pods/share-process-namespace.yaml download=pods/share-process-namespace.yaml><code>pods/share-process-namespace.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-share-process-namespace-yaml")' title="Copy pods/share-process-namespace.yaml to clipboard"></img></div><div class=includecode id=pods-share-process-namespace-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>shareProcessNamespace</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- SYS_PTRACE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stdin</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tty</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Créez le pod <code>nginx</code> sur votre cluster :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/share-process-namespace.yaml
</span></span></code></pre></div></li><li><p>Attachez-le au conteneur <code>shell</code> et lancez <code>ps</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it nginx -c shell
</span></span></code></pre></div><p>Si vous ne verrez pas d'invite de commande, appuyez sur la touche Entrée.</p><pre tabindex=0><code>/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   14 101       0:00 nginx: worker process
   15 root      0:00 sh
   21 root      0:00 ps ax
</code></pre></li></ol><p>Vous pouvez signaler les processus dans d'autres conteneurs. Par exemple, envoyez <code>SIGHUP</code> à
nginx pour relancer le processus de worker. Cela nécessite la fonctionnalité <code>SYS_PTRACE</code>.</p><pre tabindex=0><code>/ # kill -HUP 8
/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   15 root      0:00 sh
   22 101       0:00 nginx: worker process
   23 root      0:00 ps ax
</code></pre><p>Il est même possible d'accéder aux autres conteneurs en utilisant le lien <code>/proc/$pid/root</code>.</p><pre tabindex=0><code>/ # head /proc/8/root/etc/nginx/nginx.conf

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
</code></pre><h2 id=comprendre-le-processus-de-partage-de-l-espace-de-nommage>Comprendre le processus de partage de l'espace de nommage</h2><p>Les pods partagent de nombreuses ressources, il est donc logique qu'elles partagent également un espace de noms des processus. Pour certaines images de conteneur, on peut envisager de les isoler les uns des autres. Il est donc important de comprendre ces différences :</p><ol><li><p><strong>Le processus de conteneur n'a plus de PID 1.</strong> Certaines images de conteneurs refusent de démarrer sans PID 1 (par exemple, les conteneurs utilisant <code>systemd</code>) ou exécuter des commandes comme <code>kill -HUP 1</code> pour signaler le processus du conteneur. Dans les pods avec un espace de noms partagé du processus, <code>kill -HUP 1</code> signalera la sandbox du pod. (<code>/pause</code> dans l'exemple ci-dessus.)</p></li><li><p><strong>Les processus sont visibles par les autres conteneurs du pod.</strong> Cela inclut tout les informations visibles dans <code>/proc</code>, comme les mots de passe passés en argument ou les variables d'environnement. Celles-ci ne sont protégées que par des permissions Unix régulières.</p></li><li><p><strong>Les systèmes de fichiers des conteneurs sont visibles par les autres conteneurs du pod à travers le lien <code>/proc/$pid/root</code>.</strong> Cela rend le débogage plus facile, mais cela signifie aussi que les secrets du système de fichiers ne sont protégés que par les permissions du système de fichiers.</p></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-1bb997c61a85de753d9994e7a312a291>3.13 - Convertir un fichier Docker Compose en ressources Kubernetes</h1><p>C'est quoi Kompose ? C'est un outil de conversion de tout ce qui compose (notamment Docker Compose) en orchestrateurs de conteneurs (Kubernetes ou OpenShift).
Vous trouverez plus d'informations sur le site web de Kompose à <a href=http:/kompose.io>http://kompose.io</a>.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><h2 id=installer-kompose>Installer Kompose</h2><p>Nous disposons de plusieurs façons d'installer Kompose. Notre méthode préférée est de télécharger le binaire de la dernière version de GitHub.</p><ul class="nav nav-tabs" id=install-ways role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#install-ways-0 role=tab aria-controls=install-ways-0 aria-selected=true>GitHub download</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-1 role=tab aria-controls=install-ways-1>Build from source</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-2 role=tab aria-controls=install-ways-2>CentOS package</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-3 role=tab aria-controls=install-ways-3>Fedora package</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-4 role=tab aria-controls=install-ways-4>Homebrew (macOS)</a></li></ul><div class=tab-content id=install-ways><div id=install-ways-0 class="tab-pane show active" role=tabpanel aria-labelledby=install-ways-0><p><p>Kompose est publié via GitHub sur un cycle de trois semaines, vous pouvez voir toutes les versions actuelles sur <a href=https://github.com/kubernetes/kompose/releases>la page des releases de Github</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#080;font-style:italic># Linux</span>
</span></span><span style=display:flex><span>curl -L https://github.com/kubernetes/kompose/releases/download/v1.16.0/kompose-linux-amd64 -o kompose
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># macOS</span>
</span></span><span style=display:flex><span>curl -L https://github.com/kubernetes/kompose/releases/download/v1.16.0/kompose-darwin-amd64 -o kompose
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Windows</span>
</span></span><span style=display:flex><span>curl -L https://github.com/kubernetes/kompose/releases/download/v1.16.0/kompose-windows-amd64.exe -o kompose.exe
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>chmod +x kompose
</span></span><span style=display:flex><span>sudo mv ./kompose /usr/local/bin/kompose
</span></span></code></pre></div><p>Alternativement, vous pouvez télécharger le <a href=https://github.com/kubernetes/kompose/releases>tarball</a>.</p></div><div id=install-ways-1 class=tab-pane role=tabpanel aria-labelledby=install-ways-1><p><p>L'installation en utilisant <code>go get</code> extrait de la branche master avec les derniers changements de développement.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>go get -u github.com/kubernetes/kompose
</span></span></code></pre></div></div><div id=install-ways-2 class=tab-pane role=tabpanel aria-labelledby=install-ways-2><p><p>Kompose est dans le dépôt CentOS <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a>.
Si vous n'avez pas le dépôt <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a> déjà installé et activé, vous pouvez le faire en lançant <code>sudo yum install epel-release</code></p><p>Si vous avez <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a> activé dans votre système, vous pouvez installer Kompose comme n'importe quel autre logiciel.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo yum -y install kompose
</span></span></code></pre></div></div><div id=install-ways-3 class=tab-pane role=tabpanel aria-labelledby=install-ways-3><p><p>Kompose est dans les dépôts Fedora 24, 25 et 26. Vous pouvez l'installer comme n'importe quel autre paquetage.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo dnf -y install kompose
</span></span></code></pre></div></div><div id=install-ways-4 class=tab-pane role=tabpanel aria-labelledby=install-ways-4><p><p>Sur macOS, vous pouvez installer la dernière version via <a href=https://brew.sh>Homebrew</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>brew install kompose
</span></span></code></pre></div></div></div><h2 id=utiliser-kompose>Utiliser Kompose</h2><p>En quelques étapes, nous vous emmenons de Docker Compose à Kubernetes. Tous dont vous avez besoin est un fichier <code>docker-compose.yml</code>.</p><ol><li><p>Allez dans le répertoire contenant votre fichier <code>docker-compose.yml</code>. Si vous n'en avez pas, faites un test en utilisant celui-ci.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis-master</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/redis:e2e<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis-slave</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-redisslave:v3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- GET_HOSTS_FROM=dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>frontend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/gb-frontend:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;80:80&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- GET_HOSTS_FROM=dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p>Pour convertir le fichier <code>docker-compose.yml</code> en fichiers que vous pouvez utiliser avec <code>kubectl</code>, lancez <code>kompose convert</code> et ensuite <code>kubectl apply -f &lt;output file></code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kompose convert                           
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;frontend-service.yaml&#34;</span> created         
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-master-service.yaml&#34;</span> created     
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-slave-service.yaml&#34;</span> created      
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;frontend-deployment.yaml&#34;</span> created      
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-master-deployment.yaml&#34;</span> created  
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-slave-deployment.yaml&#34;</span> created   
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f frontend-service.yaml,redis-master-service.yaml,redis-slave-service.yaml,frontend-deployment.yaml,redis-master-deployment.yaml,redis-slave-deployment.yaml
</span></span><span style=display:flex><span>service/frontend created
</span></span><span style=display:flex><span>service/redis-master created
</span></span><span style=display:flex><span>service/redis-slave created
</span></span><span style=display:flex><span>deployment.apps/frontend created
</span></span><span style=display:flex><span>deployment.apps/redis-master created
</span></span><span style=display:flex><span>deployment.apps/redis-slave created
</span></span></code></pre></div><p>Vos déploiements fonctionnent sur Kubernetes.</p></li><li><p>Accédez à votre application.</p><p>Si vous utilisez déjà <code>minikube</code> pour votre processus de développement :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ minikube service frontend
</span></span></code></pre></div><p>Sinon, regardons quelle IP votre service utilise !</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ kubectl describe svc frontend
</span></span><span style=display:flex><span>Name:                   frontend
</span></span><span style=display:flex><span>Namespace:              default
</span></span><span style=display:flex><span>Labels:                 <span style=color:#b8860b>service</span><span style=color:#666>=</span>frontend
</span></span><span style=display:flex><span>Selector:               <span style=color:#b8860b>service</span><span style=color:#666>=</span>frontend
</span></span><span style=display:flex><span>Type:                   LoadBalancer
</span></span><span style=display:flex><span>IP:                     10.0.0.183
</span></span><span style=display:flex><span>LoadBalancer Ingress:   192.0.2.89
</span></span><span style=display:flex><span>Port:                   <span style=color:#666>80</span>      80/TCP
</span></span><span style=display:flex><span>NodePort:               <span style=color:#666>80</span>      31144/TCP
</span></span><span style=display:flex><span>Endpoints:              172.17.0.4:80
</span></span><span style=display:flex><span>Session Affinity:       None
</span></span><span style=display:flex><span>No events.
</span></span></code></pre></div><p>Si vous utilisez un fournisseur de cloud computing, votre IP sera listée à côté de <code>LoadBalancer Ingress</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ curl http://192.0.2.89
</span></span></code></pre></div></li></ol><h2 id=guide-de-l-utilisateur>Guide de l'utilisateur</h2><ul><li>CLI<ul><li><a href=#kompose-convert><code>kompose convert</code></a></li></ul></li><li>Documentation<ul><li><a href=#alternative-conversions>Conversions alternatives</a></li><li><a href=#labels>Etiquettes</a></li><li><a href=#restart>Redémarrage</a></li><li><a href=#docker-compose-versions>Les Versions de Docker Compose</a></li></ul></li></ul><p>Kompose supporte deux fournisseurs : OpenShift et Kubernetes.
Vous pouvez choisir un fournisseur ciblé en utilisant l'option globale <code>--provider</code>. Si aucun fournisseur n'est spécifié, Kubernetes est défini par défaut.</p><h2 id=kompose-convert><code>kompose convert</code></h2><p>Kompose prend en charge la conversion des fichiers Docker Compose V1, V2 et V3 en objets Kubernetes et OpenShift.</p><h3 id=kubernetes>Kubernetes</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ kompose --file docker-voting.yml convert
</span></span><span style=display:flex><span>WARN Unsupported key networks - ignoring
</span></span><span style=display:flex><span>WARN Unsupported key build - ignoring
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;worker-svc.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;db-svc.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-svc.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;result-svc.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;vote-svc.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-deployment.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;result-deployment.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;vote-deployment.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;worker-deployment.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;db-deployment.yaml&#34;</span> created
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ls
</span></span><span style=display:flex><span>db-deployment.yaml  docker-compose.yml         docker-gitlab.yml  redis-deployment.yaml  result-deployment.yaml  vote-deployment.yaml  worker-deployment.yaml
</span></span><span style=display:flex><span>db-svc.yaml         docker-voting.yml          redis-svc.yaml     result-svc.yaml        vote-svc.yaml           worker-svc.yaml
</span></span></code></pre></div><p>Vous pouvez également fournir plusieurs fichiers de composition du Docker en même temps :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ kompose -f docker-compose.yml -f docker-guestbook.yml convert
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;frontend-service.yaml&#34;</span> created         
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;mlbparks-service.yaml&#34;</span> created         
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;mongodb-service.yaml&#34;</span> created          
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-master-service.yaml&#34;</span> created     
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-slave-service.yaml&#34;</span> created      
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;frontend-deployment.yaml&#34;</span> created      
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;mlbparks-deployment.yaml&#34;</span> created      
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;mongodb-deployment.yaml&#34;</span> created       
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;mongodb-claim0-persistentvolumeclaim.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-master-deployment.yaml&#34;</span> created  
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-slave-deployment.yaml&#34;</span> created   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ls
</span></span><span style=display:flex><span>mlbparks-deployment.yaml  mongodb-service.yaml                       redis-slave-service.jsonmlbparks-service.yaml  
</span></span><span style=display:flex><span>frontend-deployment.yaml  mongodb-claim0-persistentvolumeclaim.yaml  redis-master-service.yaml
</span></span><span style=display:flex><span>frontend-service.yaml     mongodb-deployment.yaml                    redis-slave-deployment.yaml
</span></span><span style=display:flex><span>redis-master-deployment.yaml
</span></span></code></pre></div><p>Lorsque plusieurs fichiers de docker-compose sont fournis, la configuration est fusionnée. Toute configuration qui est commune sera surchargée par le fichier suivant.</p><h3 id=openshift>OpenShift</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ kompose --provider openshift --file docker-voting.yml convert
</span></span><span style=display:flex><span>WARN <span style=color:#666>[</span>worker<span style=color:#666>]</span> Service cannot be created because of missing port.
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;vote-service.yaml&#34;</span> created             
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;db-service.yaml&#34;</span> created               
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;redis-service.yaml&#34;</span> created            
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;result-service.yaml&#34;</span> created           
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;vote-deploymentconfig.yaml&#34;</span> created    
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;vote-imagestream.yaml&#34;</span> created         
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;worker-deploymentconfig.yaml&#34;</span> created  
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;worker-imagestream.yaml&#34;</span> created       
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;db-deploymentconfig.yaml&#34;</span> created      
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;db-imagestream.yaml&#34;</span> created           
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;redis-deploymentconfig.yaml&#34;</span> created   
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;redis-imagestream.yaml&#34;</span> created        
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;result-deploymentconfig.yaml&#34;</span> created  
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;result-imagestream.yaml&#34;</span> created  
</span></span></code></pre></div><p>Il supporte également la création de buildconfig pour la directive de build dans un service. Par défaut, il utilise le répertoire distant de la branche git courante comme répertoire source, et la branche courante comme branche source pour le build. Vous pouvez spécifier un repo source et une branche différents en utilisant respectivement les options <code>--build-repo</code> et <code>--build-branch</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ kompose --provider openshift --file buildconfig/docker-compose.yml convert
</span></span><span style=display:flex><span>WARN <span style=color:#666>[</span>foo<span style=color:#666>]</span> Service cannot be created because of missing port.
</span></span><span style=display:flex><span>INFO OpenShift Buildconfig using git@github.com:rtnpro/kompose.git::master as source.
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;foo-deploymentconfig.yaml&#34;</span> created     
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;foo-imagestream.yaml&#34;</span> created          
</span></span><span style=display:flex><span>INFO OpenShift file <span style=color:#b44>&#34;foo-buildconfig.yaml&#34;</span> created
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Si vous poussez manuellement les artefacts OpenShift en utilisant <code>oc create -f</code>, vous devez vous assurer que vous poussez l'artefact imagestream avant l'artefact buildconfig, pour contourner ce problème OpenShift : <a href=https://github.com/openshift/origin/issues/4518>https://github.com/openshift/origin/issues/4518</a> .</div><h2 id=autres-conversions>Autres conversions</h2><p>La transformation par défaut <code>komposer</code> va générer des <a href=/docs/concepts/workloads/controllers/deployment/>Déploiements</a> et <a href=/docs/concepts/services-networking/service/>Services</a> de Kubernetes, au format yaml. Vous avez une autre option pour générer json avec <code>-j</code>. Vous pouvez aussi générer des objets de <a href=/docs/concepts/workloads/controllers/replicationcontroller/>Replication Controllers</a>, <a href=/docs/concepts/workloads/controllers/daemonset/>Daemon Sets</a>, ou <a href=https://github.com/helm/helm>Helm</a> charts.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ kompose convert -j
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-svc.json&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;web-svc.json&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-deployment.json&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;web-deployment.json&#34;</span> created
</span></span></code></pre></div><p>Les fichiers <code>*-deployment.json</code> contiennent les objets Déploiements.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ kompose convert --replication-controller
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-svc.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;web-svc.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-replicationcontroller.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;web-replicationcontroller.yaml&#34;</span> created
</span></span></code></pre></div><p>Les fichiers <code>*-replicationcontroller.yaml</code> contiennent les objets du Contrôleur de Réplication. Si vous voulez spécifier des répliques (la valeur par défaut est 1), utilisez l'option <code>--replicas</code> : <code>$ kompose convert --replication-controller --replicas 3</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ kompose convert --daemon-set
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-svc.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;web-svc.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-daemonset.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;web-daemonset.yaml&#34;</span> created
</span></span></code></pre></div><p>Les fichiers <code>*-daemonset.yaml</code> contiennent les objets du Daemon Set</p><p>Si vous voulez générer un Chart à utiliser avec <a href=https://github.com/kubernetes/helm>Helm</a>, faites-le simplement :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ kompose convert -c
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;web-svc.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-svc.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;web-deployment.yaml&#34;</span> created
</span></span><span style=display:flex><span>INFO Kubernetes file <span style=color:#b44>&#34;redis-deployment.yaml&#34;</span> created
</span></span><span style=display:flex><span>chart created in <span style=color:#b44>&#34;./docker-compose/&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ tree docker-compose/
</span></span><span style=display:flex><span>docker-compose
</span></span><span style=display:flex><span>├── Chart.yaml
</span></span><span style=display:flex><span>├── README.md
</span></span><span style=display:flex><span>└── templates
</span></span><span style=display:flex><span>    ├── redis-deployment.yaml
</span></span><span style=display:flex><span>    ├── redis-svc.yaml
</span></span><span style=display:flex><span>    ├── web-deployment.yaml
</span></span><span style=display:flex><span>    └── web-svc.yaml
</span></span></code></pre></div><p>La structure du Chart est destinée à fournir un modèle pour la construction de vos chartes de Helm.</p><h2 id=étiquettes>Étiquettes</h2><p><code>kompose</code> supporte les étiquettes spécifiques à Kompose dans le fichier <code>docker-compose.yml</code> afin de définir explicitement le comportement d'un service lors de la conversion.</p><ul><li>Le fichier <code>kompose.service.type</code> définit le type de service à créer.</li></ul><p>Par exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>dockerfile</span>:<span style=color:#bbb> </span>foobar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>build</span>:<span style=color:#bbb> </span>./foobar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cap_add</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- ALL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>container_name</span>:<span style=color:#bbb> </span>foobar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.type</span>:<span style=color:#bbb> </span>nodeport<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>kompose.service.expose</code> définit si le service doit être accessible depuis l'extérieur du cluster ou non. Si la valeur est fixée à "true", le fournisseur définit automatiquement l'extrémité, et pour toute autre valeur, la valeur est définie comme le nom d'hôte. Si plusieurs ports sont définis dans un service, le premier est choisi pour être l'exposé.<ul><li>Pour le fournisseur Kubernetes, une ressource ingress est créée et il est supposé qu'un contrôleur ingress a déjà été configuré.</li><li>Pour le fournisseur OpenShift, une route est créée.</li></ul></li></ul><p>Par exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>web</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>tuna/docker-counter23<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;5000:5000&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>links</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>- redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.expose</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;counter.example.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis:3.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Les options actuellement supportées sont :</p><table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody><tr><td>kompose.service.type</td><td>nodeport / clusterip / loadbalancer</td></tr><tr><td>kompose.service.expose</td><td>true / hostname</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le label <code>kompose.service.type</code> doit être défini avec <code>ports</code> uniquement, sinon <code>kompose</code> échouera.</div><h2 id=redémarrer>Redémarrer</h2><p>Si vous voulez créer des pods normaux sans contrôleurs, vous pouvez utiliser la construction
<code>restart</code> de docker-compose pour définir cela. Suivez le tableau ci-dessous pour voir ce qui se passe avec la valeur de <code>restart</code>.</p><table><thead><tr><th><code>docker-compose</code> <code>restart</code></th><th>object created</th><th>Pod <code>restartPolicy</code></th></tr></thead><tbody><tr><td><code>""</code></td><td>controller object</td><td><code>Always</code></td></tr><tr><td><code>always</code></td><td>controller object</td><td><code>Always</code></td></tr><tr><td><code>on-failure</code></td><td>Pod</td><td><code>OnFailure</code></td></tr><tr><td><code>no</code></td><td>Pod</td><td><code>Never</code></td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Note:</strong> L'objet contrôleur peut être <code>déploiement</code> ou <code>replicationcontroller</code>, etc.</div><p>Par exemple, le service <code>pival</code> deviendra un Pod. Ce conteneur a calculé la valeur de <code>pi</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;2&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pival</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>restart</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;on-failure&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=avertissement-concernant-les-configurations-de-déploiement>Avertissement concernant les configurations de déploiement</h3><p>Si le fichier Docker Compose a un volume spécifié pour un service, la stratégie Deployment (Kubernetes) ou DeploymentConfig (OpenShift) est changée en "Recreate" au lieu de "RollingUpdate" (par défaut). Ceci est fait pour éviter que plusieurs instances d'un service n'accèdent à un volume en même temps.</p><p>Si le fichier Docker Compose a un nom de service avec <code>_</code> dedans (par exemple <code>web_service</code>), alors il sera remplacé par <code>-</code> et le nom du service sera renommé en conséquence (par exemple <code>web-service</code>). Kompose fait cela parce que "Kubernetes" n'autorise pas <code>_</code> dans le nom de l'objet.</p><p>Veuillez noter que changer le nom du service peut casser certains fichiers <code>docker-compose</code>.</p><h2 id=versions-du-docker-compose>Versions du Docker Compose</h2><p>Kompose supporte les versions Docker Compose : 1, 2 et 3. Nous avons un support limité sur les versions 2.1 et 3.2 en raison de leur nature expérimentale.</p><p>Une liste complète sur la compatibilité entre les trois versions est donnée dans notre <a href=https://github.com/kubernetes/kompose/blob/master/docs/conversion.md>document de conversion</a> incluant une liste de toutes les clés Docker Compose incompatibles.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>4 - Gérez vos objets Kubernetes</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-866924fa095f897ede8dfdcab9e97942>5 - Injection des données dans les applications</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-a78a5e7e765fd8c49c8f7c0d72499f72>6 - Exécution des applications</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-ca3bc4e31dfe46d5044a3b93eb804ee9>7 - Exécution des jobs</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-b74b959f5a531003dd0653dfbfc2e88b>8 - Accès aux applications dans un cluster</h1></div><div class=td-content><h1 id=pg-777447042cd4e81df3fa5beb3357a485>8.1 - Tableau de bord (Dashboard)</h1><p>Le tableau de bord (Dashboard) est une interface web pour Kubernetes.
Vous pouvez utiliser ce tableau de bord pour déployer des applications conteneurisées dans un cluster Kubernetes, dépanner votre application conteneurisée et gérer les ressources du cluster.
Vous pouvez utiliser le tableau de bord pour obtenir une vue d'ensemble des applications en cours d'exécution dans votre cluster, ainsi que pour créer ou modifier des ressources Kubernetes individuelles. (comme des Deployments, Jobs, DaemonSets, etc).
Par exemple, vous pouvez redimensionner un Deployment, lancer une mise à jour progressive, recréer un pod ou déployez de nouvelles applications à l'aide d'un assistant de déploiement.</p><p>Le tableau de bord fournit également des informations sur l'état des ressources Kubernetes de votre cluster et sur les erreurs éventuelles.</p><p><img src=/images/docs/ui-dashboard.png alt="Tableau de bord Kubernetes"></p><h2 id=déploiement-du-tableau-de-bord>Déploiement du tableau de bord</h2><p>L'interface utilisateur du tableau de bord n'est pas déployée par défaut.
Pour le déployer, exécutez la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/aio/deploy/recommended.yaml
</span></span></code></pre></div><h2 id=accès-à-l-interface-utilisateur-du-tableau-de-bord>Accès à l'interface utilisateur du tableau de bord</h2><p>Pour protéger vos données dans le cluster, le tableau de bord se déploie avec une configuration RBAC minimale par défaut.
Actuellement, le tableau de bord prend uniquement en charge la connexion avec un jeton de support.
Pour créer un jeton pour cette démo, vous pouvez suivre notre guide sur <a href=https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md>créer un exemple d'utilisateur</a>.</p><div class="alert alert-danger warning callout" role=alert><strong>Attention:</strong> L’exemple d’utilisateur créé dans le didacticiel disposera de privilèges d’administrateur et servira uniquement à des fins pédagogiques.</div><h3 id=proxy-en-ligne-de-commande>Proxy en ligne de commande</h3><p>Vous pouvez accéder au tableau de bord à l'aide de l'outil en ligne de commande kubectl en exécutant la commande suivante:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>kubectl proxy
</span></span></code></pre></div><p>Kubectl mettra le tableau de bord à disposition à l'adresse suivante: <a href=http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a>.</p><p>Vous ne pouvez accéder à l'interface utilisateur <em>que</em> depuis la machine sur laquelle la commande est exécutée.
Voir <code>kubectl proxy --help</code> pour plus d'options.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> La méthode d'authentification Kubeconfig ne prend pas en charge les fournisseurs d'identité externes ni l'authentification basée sur un certificat x509.</div><h2 id=page-de-bienvenue>Page de bienvenue</h2><p>Lorsque vous accédez au tableau de bord sur un cluster vide, la page d'accueil s'affiche.
Cette page contient un lien vers ce document ainsi qu'un bouton pour déployer votre première application.
De plus, vous pouvez voir quelles applications système sont exécutées par défaut dans le <a href=/docs/tasks/administer-cluster/namespaces/>namespace</a> <code>kubernetes-dashboard</code> de votre cluster, par exemple le tableau de bord lui-même.</p><p><img src=/images/docs/ui-dashboard-zerostate.png alt="Page d'accueil du tableau de bord Kubernetes"></p><h2 id=déploiement-d-applications-conteneurisées>Déploiement d'applications conteneurisées</h2><p>Le tableau de bord vous permet de créer et de déployer une application conteneurisée en tant que Deployment et optionnellement un Service avec un simple assistant.
Vous pouvez spécifier manuellement les détails de l'application ou charger un fichier YAML ou JSON contenant la configuration de l'application.</p><p>Cliquez sur le bouton <strong>CREATE</strong> dans le coin supérieur droit de n’importe quelle page pour commencer.</p><h3 id=spécifier-les-détails-de-l-application>Spécifier les détails de l'application</h3><p>L'assistant de déploiement s'attend à ce que vous fournissiez les informations suivantes:</p><ul><li><p><strong>App name</strong> (obligatoire): Nom de votre application.
Un <a href=/docs/concepts/overview/working-with-objects/labels/>label</a> avec le nom sera ajouté au Deployment et Service, le cas échéant, qui sera déployé.</p><p>Le nom de l'application doit être unique dans son <a href=/docs/tasks/administer-cluster/namespaces/>namespace</a> Kubernetes.
Il doit commencer par une lettre minuscule et se terminer par une lettre minuscule ou un chiffre et ne contenir que des lettres minuscules, des chiffres et des tirets (-).
Il est limité à 24 caractères.
Les espaces de début et de fin sont ignorés.</p></li><li><p><strong>Container image</strong> (obligatoire): L'URL d'une <a href=/docs/concepts/containers/images/>image de conteneur</a> sur n'importe quel registre, ou une image privée (généralement hébergée sur le registre de conteneurs Google ou le hub Docker).
La spécification d'image de conteneur doit se terminer par un deux-points.</p></li><li><p><strong>Number of pods</strong> (obligatoire): Nombre cible de pods dans lesquels vous souhaitez déployer votre application.
La valeur doit être un entier positif.</p><p>Un objet <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a> sera créé pour maintenir le nombre souhaité de pods dans votre cluster.</p></li><li><p><strong>Service</strong> (optionnel): Pour certaines parties de votre application (par exemple les serveurs frontaux), vous souhaiterez peut-être exposer un <a href=/docs/concepts/services-networking/service/>Service</a> sur une adresse IP externe, peut-être publique, en dehors de votre cluster (Service externe).
Pour les Services externes, vous devrez peut-être ouvrir un ou plusieurs ports pour le faire.
Trouvez plus de détails <a href=/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/>ici</a>.</p><p>Les autres services visibles uniquement de l'intérieur du cluster sont appelés Services internes.</p><p>Quel que soit le type de service, si vous choisissez de créer un service et que votre conteneur écoute sur un port (entrant), vous devez spécifier deux ports.
Le Service sera créé en mappant le port (entrant) sur le port cible vu par le conteneur.
Ce Service acheminera le trafic vers vos pods déployés.
Les protocoles pris en charge sont TCP et UDP.
Le nom DNS interne de ce service sera la valeur que vous avez spécifiée comme nom d'application ci-dessus.</p></li></ul><p>Si nécessaire, vous pouvez développer la section <strong>Options avancées</strong> dans laquelle vous pouvez spécifier davantage de paramètres:</p><ul><li><p><strong>Description</strong>: Le texte que vous entrez ici sera ajouté en tant qu'<a href=/docs/concepts/overview/working-with-objects/annotations/>annotation</a> au Deployment et affiché dans les détails de l'application.</p></li><li><p><strong>Labels</strong>: Les <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> par défaut à utiliser pour votre application sont le nom et la version de l’application.
Vous pouvez spécifier des labels supplémentaires à appliquer au Deployment, Service (le cas échéant), et Pods, tels que la release, l'environnement, le niveau, la partition et la piste d'édition.</p><p>Exemple:</p><pre tabindex=0><code class=language-conf data-lang=conf>release=1.0
tier=frontend
environment=pod
track=stable
</code></pre></li><li><p><strong>Namespace</strong>: Kubernetes prend en charge plusieurs clusters virtuels s'exécutant sur le même cluster physique.
Ces clusters virtuels sont appelés <a href=/docs/tasks/administer-cluster/namespaces/>namespaces</a>.
Ils vous permettent de partitionner les ressources en groupes nommés de manière logique.</p><p>Le tableau de bord propose tous les namespaces disponibles dans une liste déroulante et vous permet de créer un nouveau namespace.
Le nom du namespace peut contenir au maximum 63 caractères alphanumériques et des tirets (-), mais ne peut pas contenir de lettres majuscules.
Les noms de Namespace ne devraient pas être composés uniquement de chiffres.
Si le nom est défini sous la forme d’un nombre, tel que 10, le pod sera placé dans le namespace par défaut.</p><p>Si la création du namespace réussit, celle-ci est sélectionnée par défaut.
Si la création échoue, le premier namespace est sélectionné.</p></li><li><p><strong>Image Pull Secret</strong>: Si l'image de conteneur spécifiée est privée, il peut être nécessaire de configurer des identifiants de <a href=/docs/concepts/configuration/secret/>pull secret</a>.</p><p>Le tableau de bord propose tous les secrets disponibles dans une liste déroulante et vous permet de créer un nouveau secret.
Le nom de secret doit respecter la syntaxe du nom de domaine DNS, par exemple. <code>new.image-pull.secret</code>.
Le contenu d'un secret doit être codé en base64 et spécifié dans un fichier <a href=/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod><code>.dockercfg</code></a>.
Le nom du secret peut contenir 253 caractères maximum.</p><p>Si la création du secret d’extraction d’image est réussie, celle-ci est sélectionnée par défaut.
Si la création échoue, aucun secret n'est appliqué.</p></li><li><p><strong>CPU requirement (cores)</strong> et <strong>Memory requirement (MiB)</strong>: Vous pouvez spécifier les <a href=/docs/tasks/configure-pod-container/limit-range/>limites de ressource</a> minimales pour le conteneur.
Par défaut, les pods fonctionnent avec des limites de CPU et de mémoire illimitées.</p></li><li><p><strong>Run command</strong> et <strong>Run command arguments</strong>: Par défaut, vos conteneurs exécutent les valeurs par défaut de la <a href=/docs/user-guide/containers/#containers-and-commands>commande d'entrée</a> de l'image spécifiée.
Vous pouvez utiliser les options de commande et les arguments pour remplacer la valeur par défaut.</p></li><li><p><strong>Run as privileged</strong>: Ce paramètre détermine si les processus dans <a href=/docs/user-guide/pods/#privileged-mode-for-pod-containers>conteneurs privilégiés</a> sont équivalents aux processus s'exécutant en tant que root sur l'hôte.
Les conteneurs privilégiés peuvent utiliser des fonctionnalités telles que la manipulation de la pile réseau et l'accès aux périphériques.</p></li><li><p><strong>Environment variables</strong>: Kubernetes expose ses Services via des <a href=/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>variables d'environnement</a>.
Vous pouvez composer une variable d'environnement ou transmettre des arguments à vos commandes en utilisant les valeurs des variables d'environnement.<br>Ils peuvent être utilisés dans les applications pour trouver un Service.
Les valeurs peuvent référencer d'autres variables à l'aide de la syntaxe <code>$(VAR_NAME)</code>.</p></li></ul><h3 id=téléchargement-d-un-fichier-yaml-ou-json>Téléchargement d'un fichier YAML ou JSON</h3><p>Kubernetes supporte la configuration déclarative.
Dans ce style, toute la configuration est stockée dans des fichiers de configuration YAML ou JSON à l'aide des schémas de ressources de l'<a href=/docs/concepts/overview/kubernetes-api/>API</a> de Kubernetes.</p><p>Au lieu de spécifier les détails de l'application dans l'assistant de déploiement, vous pouvez définir votre application dans des fichiers YAML ou JSON et télécharger les fichiers à l'aide du tableau de bord.</p><h2 id=utilisation-du-tableau-de-bord>Utilisation du tableau de bord</h2><p>Les sections suivantes décrivent des vues du tableau de bord de Kubernetes; ce qu'elles fournissent et comment peuvent-elles être utilisées.</p><h3 id=navigation>Navigation</h3><p>Lorsque des objets Kubernetes sont définis dans le cluster, le tableau de bord les affiche dans la vue initiale.
Par défaut, seuls les objets du namespace <em>default</em> sont affichés, ce qui peut être modifié à l'aide du sélecteur d'espace de nom situé dans le menu de navigation.</p><p>Le tableau de bord montre la plupart des types d'objets Kubernetes et les regroupe dans quelques catégories de menus.</p><h4 id=vue-d-ensemble-de-l-administrateur>Vue d'ensemble de l'administrateur</h4><p>Pour les administrateurs de cluster et de namespace, le tableau de bord répertorie les noeuds, les namespaces et les volumes persistants et propose des vues de détail pour ceux-ci.
La vue Liste de nœuds contient les mesures d'utilisation de CPU et de la mémoire agrégées sur tous les nœuds.
La vue détaillée affiche les métriques d'un nœud, ses spécifications, son statut, les ressources allouées, les événements et les pods s'exécutant sur le nœud.</p><h4 id=charges-de-travail>Charges de travail</h4><p>Affiche toutes les applications en cours d'exécution dans le namespace selectionné.
La vue répertorie les applications par type de charge de travail. (e.g., Deployments, Replica Sets, Stateful Sets, etc.) et chaque type de charge de travail peut être visualisé séparément.
Les listes récapitulent les informations exploitables sur les charges de travail, telles que le nombre de Pods prêts pour un Replica Set ou l'utilisation actuelle de la mémoire pour un Pod.</p><p>Les vues détaillées des charges de travail affichent des informations sur l'état et les spécifications, ainsi que les relations de surface entre les objets.
Par exemple, les Pods qu'un Replica Set controle ou bien les nouveaux Replica Sets et Horizontal Pod Autoscalers pour les Deployments.</p><h4 id=services>Services</h4><p>Affiche les ressources Kubernetes permettant d’exposer les services au monde externe et de les découvrir au sein d’un cluster.
Pour cette raison, les vues Service et Ingress montrent les Pods ciblés par eux, les points de terminaison internes pour les connexions au cluster et les points de terminaison externes pour les utilisateurs externes.</p><h4 id=stockage>Stockage</h4><p>La vue de stockage montre les ressources Persistent Volume Claim qui sont utilisées par les applications pour stocker des données.</p><h4 id=config-maps-et-secrets>Config Maps et Secrets</h4><p>Affiche toutes les ressources Kubernetes utilisées pour la configuration en temps réel d'applications s'exécutant dans des clusters.
La vue permet d’éditer et de gérer des objets de configuration et d’afficher les secrets cachés par défaut.</p><h4 id=visualisation-de-journaux>Visualisation de journaux</h4><p>Les listes de Pod et les pages de détail renvoient à une visionneuse de journaux intégrée au tableau de bord.
Le visualiseur permet d’exploiter les logs des conteneurs appartenant à un seul Pod.</p><p><img src=/images/docs/ui-dashboard-logs-view.png alt="Visualisation de journaux"></p><h2 id=a-suivre>A suivre</h2><p>Pour plus d'informations, voir la page du projet <a href=https://github.com/kubernetes/dashboard>Kubernetes Dashboard</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5a233e14205d77fe1294917d2da6f876>8.2 - Configurer l'accès à plusieurs clusters</h1><p>Cette page montre comment configurer l'accès à plusieurs clusters à l'aide de fichiers de configuration.
Une fois vos clusters, utilisateurs et contextes définis dans un ou plusieurs fichiers de configuration, vous pouvez basculer rapidement entre les clusters en utilisant la commande <code>kubectl config use-context</code>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Un fichier utilisé pour configurer l'accès à un cluster est parfois appelé <em>fichier kubeconfig</em>.
C'est une manière générique de se référer aux fichiers de configuration.
Cela ne signifie pas qu'il existe un fichier nommé <code>kubeconfig</code>.</div><h2 id=pré-requis>Pré-requis</h2><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>Pour vérifier que <a class=glossary-tooltip title='A command line tool for communicating with a Kubernetes cluster.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a> est installé, executez <code>kubectl version --client</code>.
La version kubectl doit être <a href=/docs/setup/release/version-skew-policy/#kubectl>dans une version mineure</a> de votre
serveur API du cluster.</p><h2 id=définir-des-clusters-des-utilisateurs-et-des-contextes>Définir des clusters, des utilisateurs et des contextes</h2><p>Supposons que vous ayez deux clusters, un pour le développement et un pour le travail <code>scratch</code>.
Dans le cluster <code>development</code>, vos développeurs frontend travaillent dans un espace de noms appelé <code>frontend</code>, et vos développeurs de stockage travaillent dans un espace de noms appelé <code>storage</code>.
Dans votre cluster <code>scratch</code>, les développeurs travaillent dans le namespace par défaut ou créent des namespaces auxiliaires comme bon leur semble.
L'accès au cluster <code>development</code> nécessite une authentification par certificat.
L'accès au cluster <code>scratch</code> nécessite une authentification par nom d'utilisateur et mot de passe.</p><p>Créez un répertoire nommé <code>config-exercice</code>.
Dans votre répertoire <code>config-exercice</code>, créez un fichier nommé <code>config-demo</code> avec ce contenu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Config
</span></span><span style=display:flex><span>preferences: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>clusters:
</span></span><span style=display:flex><span>- cluster:
</span></span><span style=display:flex><span>  name: development
</span></span><span style=display:flex><span>- cluster:
</span></span><span style=display:flex><span>  name: scratch
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>users:
</span></span><span style=display:flex><span>- name: developer
</span></span><span style=display:flex><span>- name: experimenter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>contexts:
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>  name: dev-frontend
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>  name: dev-storage
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>  name: exp-scratch
</span></span></code></pre></div><p>Un fichier de configuration décrit les clusters, les utilisateurs et les contextes.
Votre fichier <code>config-demo</code> a le cadre pour décrire deux clusters, deux utilisateurs et trois contextes.</p><p>Allez dans votre répertoire <code>config-exercice</code>.
Entrez ces commandes pour ajouter les détails du cluster à votre fichier de configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster development --server<span style=color:#666>=</span>https://1.2.3.4 --certificate-authority<span style=color:#666>=</span>fake-ca-file
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster scratch --server<span style=color:#666>=</span>https://5.6.7.8 --insecure-skip-tls-verify
</span></span></code></pre></div><p>Ajoutez les détails de l'utilisateur à votre fichier de configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials developer --client-certificate<span style=color:#666>=</span>fake-cert-file --client-key<span style=color:#666>=</span>fake-key-seefile
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials experimenter --username<span style=color:#666>=</span>exp --password<span style=color:#666>=</span>some-password
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong><ul><li>Pour supprimer un utilisateur, vous pouvez exécuter <code>kubectl --kubeconfig=config-demo config unset users.&lt;name></code></li><li>Pour supprimer un cluster, vous pouvez exécuter <code>kubectl --kubeconfig=config-demo config unset clusters.&lt;name></code></li><li>Pour supprimer un contexte, vous pouvez exécuter <code>kubectl --kubeconfig=config-demo config unset contexts.&lt;name></code></li></ul></div><p>Ajoutez des détails de contexte à votre fichier de configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-frontend --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>frontend --user<span style=color:#666>=</span>developer
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-storage --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>storage --user<span style=color:#666>=</span>developer
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context exp-scratch --cluster<span style=color:#666>=</span>scratch --namespace<span style=color:#666>=</span>default --user<span style=color:#666>=</span>experimenter
</span></span></code></pre></div><p>Ouvrez votre fichier <code>config-demo</code> pour voir les détails ajoutés.
Au lieu d'ouvrir le fichier <code>config-demo</code>, vous pouvez utiliser la commande <code>kubectl config view</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view
</span></span></code></pre></div><p>La sortie montre les deux clusters, deux utilisateurs et trois contextes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>clusters:
</span></span><span style=display:flex><span>- cluster:
</span></span><span style=display:flex><span>    certificate-authority: fake-ca-file
</span></span><span style=display:flex><span>    server: https://1.2.3.4
</span></span><span style=display:flex><span>  name: development
</span></span><span style=display:flex><span>- cluster:
</span></span><span style=display:flex><span>    insecure-skip-tls-verify: <span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>    server: https://5.6.7.8
</span></span><span style=display:flex><span>  name: scratch
</span></span><span style=display:flex><span>contexts:
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: frontend
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-frontend
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: storage
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-storage
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: scratch
</span></span><span style=display:flex><span>    namespace: default
</span></span><span style=display:flex><span>    user: experimenter
</span></span><span style=display:flex><span>  name: exp-scratch
</span></span><span style=display:flex><span>current-context: <span style=color:#b44>&#34;&#34;</span>
</span></span><span style=display:flex><span>kind: Config
</span></span><span style=display:flex><span>preferences: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>users:
</span></span><span style=display:flex><span>- name: developer
</span></span><span style=display:flex><span>  user:
</span></span><span style=display:flex><span>    client-certificate: fake-cert-file
</span></span><span style=display:flex><span>    client-key: fake-key-file
</span></span><span style=display:flex><span>- name: experimenter
</span></span><span style=display:flex><span>  user:
</span></span><span style=display:flex><span>    password: some-password
</span></span><span style=display:flex><span>    username: exp
</span></span></code></pre></div><p>Le <code>fake-ca-file</code>, <code>fake-cert-file</code> et <code>fake-key-file</code> ci-dessus sont les espaces réservés pour les noms de chemin des fichiers de certificat.
Vous devez les remplacer par les noms de chemin réels des fichiers de certificat dans votre environnement.</p><p>Parfois, vous souhaiterez peut-être utiliser des données encodées en Base64 incorporées ici au lieu de fichiers de certificat séparés; dans ce cas, vous devez ajouter le suffixe <code>-data</code> aux clés, par exemple, <code>certificate-Authority-data</code>, <code>client-certificate-data</code>, <code>client-key-data</code>.</p><p>Chaque contexte est un triplet (cluster, utilisateur, namespace).
Par exemple, le contexte <code>dev-frontend</code> dit, "Utilisez les informations d'identification de l'utilisateur <code>developer</code> pour accéder au namespace <code>frontend</code> du cluster <code>development</code>".</p><p>Définissez le contexte actuel:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-frontend
</span></span></code></pre></div><p>Maintenant, chaque fois que vous entrez une commande <code>kubectl</code>, l'action s'appliquera au cluster et au namespace répertorié dans le contexte <code>dev-frontend</code>.
Et la commande utilisera les informations d'identification de l'utilisateur répertoriées dans le contexte <code>dev-frontend</code>.</p><p>Pour voir uniquement les informations de configuration associées au contexte actuel, utilisez l'indicateur <code>--minify</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><p>La sortie affiche les informations de configuration associées au contexte <code>dev-frontend</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>clusters:
</span></span><span style=display:flex><span>- cluster:
</span></span><span style=display:flex><span>    certificate-authority: fake-ca-file
</span></span><span style=display:flex><span>    server: https://1.2.3.4
</span></span><span style=display:flex><span>  name: development
</span></span><span style=display:flex><span>contexts:
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: frontend
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-frontend
</span></span><span style=display:flex><span>current-context: dev-frontend
</span></span><span style=display:flex><span>kind: Config
</span></span><span style=display:flex><span>preferences: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>users:
</span></span><span style=display:flex><span>- name: developer
</span></span><span style=display:flex><span>  user:
</span></span><span style=display:flex><span>    client-certificate: fake-cert-file
</span></span><span style=display:flex><span>    client-key: fake-key-file
</span></span></code></pre></div><p>Supposons maintenant que vous souhaitiez travailler pendant un certain temps dans le cluster scratch.</p><p>Changez le contexte actuel en <code>exp-scratch</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context exp-scratch
</span></span></code></pre></div><p>Maintenant, toute commande <code>kubectl</code> que vous donnez s'appliquera au namespace par défaut du cluster <code>scratch</code>.
Et la commande utilisera les informations d'identification de l'utilisateur répertoriées dans le contexte <code>exp-scratch</code>.</p><p>Afficher la configuration associée au nouveau contexte actuel, <code>exp-scratch</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><p>Enfin, supposons que vous vouliez travailler pendant un certain temps dans le namespace <code>storage</code> du cluster <code>development</code>.</p><p>Changez le contexte actuel en <code>dev-storage</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-storage
</span></span></code></pre></div><p>Afficher la configuration associée au nouveau contexte actuel, <code>dev-storage</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><h2 id=créer-un-deuxième-fichier-de-configuration>Créer un deuxième fichier de configuration</h2><p>Dans votre répertoire <code>config-exercice</code>, créez un fichier nommé <code>config-demo-2</code> avec ce contenu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Config
</span></span><span style=display:flex><span>preferences: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>contexts:
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: ramp
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-ramp-up
</span></span></code></pre></div><p>Le fichier de configuration précédent définit un nouveau contexte nommé <code>dev-ramp-up</code>.</p><h2 id=définissez-la-variable-d-environnement-kubeconfig>Définissez la variable d'environnement KUBECONFIG</h2><p>Vérifiez si vous avez une variable d'environnement nommée <code>KUBECONFIG</code>.
Si tel est le cas, enregistrez la valeur actuelle de votre variable d'environnement <code>KUBECONFIG</code>, afin de pouvoir la restaurer ultérieurement.
Par exemple:</p><h3 id=linux>Linux</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG_SAVED</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>
</span></span></code></pre></div><h3 id=windows-powershell>Windows PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>$Env</span>:KUBECONFIG_SAVED<span style=color:#666>=</span><span style=color:#b8860b>$ENV</span>:KUBECONFIG
</span></span></code></pre></div><p>La variable d'environnement <code>KUBECONFIG</code> est une liste de chemins vers les fichiers de configuration.
La liste est délimitée par deux-points pour Linux et Mac et par des points-virgules pour Windows.
Si vous avez une variable d'environnement <code>KUBECONFIG</code>, familiarisez-vous avec les fichiers de configuration de la liste.</p><p>Ajoutez temporairement deux chemins à votre variable d'environnement <code>KUBECONFIG</code>.
Par exemple:</p><h3 id=linux-1>Linux</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>:config-demo:config-demo-2
</span></span></code></pre></div><h3 id=windows-powershell-1>Windows PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=(</span><span style=color:#b44>&#34;config-demo;config-demo-2&#34;</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>Dans votre répertoire <code>config-exercice</code>, entrez cette commande:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>La sortie affiche les informations fusionnées de tous les fichiers répertoriés dans votre variable d'environnement <code>KUBECONFIG</code>.
En particulier, notez que les informations fusionnées ont le contexte <code>dev-ramp-up</code> du fichier <code>config-demo-2</code> et les trois contextes du fichier <code>config-demo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>contexts:
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: frontend
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-frontend
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: ramp
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-ramp-up
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: storage
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-storage
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: scratch
</span></span><span style=display:flex><span>    namespace: default
</span></span><span style=display:flex><span>    user: experimenter
</span></span><span style=display:flex><span>  name: exp-scratch
</span></span></code></pre></div><p>Pour plus d'informations sur la manière dont les fichiers kubeconfig sont fusionnés, consultez <a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>Organisation de l'accès au cluster à l'aide des fichiers kubeconfig</a></p><h2 id=explorez-le-répertoire-home-kube>Explorez le répertoire $HOME/.kube</h2><p>Si vous avez déjà un cluster, et vous pouvez utiliser <code>kubectl</code> pour interagir avec le cluster, alors vous avez probablement un fichier nommé <code>config</code> dans le repertoire <code>$HOME/.kube</code>.</p><p>Allez dans <code>$ HOME/.kube</code>, et voyez quels fichiers sont là.
En règle générale, il existe un fichier nommé <code>config</code>.
Il peut également y avoir d'autres fichiers de configuration dans ce répertoire.
Familiarisez-vous brièvement avec le contenu de ces fichiers.</p><h2 id=ajoutez-home-kube-config-à-votre-variable-d-environnement-kubeconfig>Ajoutez $HOME/.kube/config à votre variable d'environnement KUBECONFIG</h2><p>Si vous avez un fichier <code>$ HOME/.kube/config</code>, et qu'il n'est pas déjà répertorié dans votre variable d'environnement <code>KUBECONFIG</code>, ajoutez-le maintenant à votre variable d'environnement <code>KUBECONFIG</code>.
Par exemple:</p><h3 id=linux-2>Linux</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>:<span style=color:#b8860b>$HOME</span>/.kube/config
</span></span></code></pre></div><h3 id=windows-powershell-2>Windows Powershell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$Env</span><span style=color:#b44>:KUBECONFIG;</span><span style=color:#b8860b>$HOME</span><span style=color:#b44>\.kube\config&#34;</span>
</span></span></code></pre></div><p>Affichez les informations de configuration fusionnées à partir de tous les fichiers qui sont maintenant répertoriés dans votre variable d'environnement <code>KUBECONFIG</code>.
Dans votre répertoire config-exercice, entrez:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><h2 id=nettoyage>Nettoyage</h2><p>Remettez votre variable d'environnement <code>KUBECONFIG</code> à sa valeur d'origine.</p><p>Par exemple:</p><h3 id=linux-3>Linux</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG_SAVED</span>
</span></span></code></pre></div><h3 id=windows-powershell-3>Windows PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=</span><span style=color:#b8860b>$ENV</span>:KUBECONFIG_SAVED
</span></span></code></pre></div><h2 id=a-suivre>A suivre</h2><ul><li><a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>Organisation de l'accès au cluster à l'aide des fichiers kubeconfig</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-48e8f306f919c5b81265e265a2b76ab4>8.3 - Lister toutes les images de conteneur exécutées dans un cluster</h1><p>Cette page montre comment utiliser kubectl pour répertorier toutes les images de conteneur pour les pods s'exécutant dans un cluster.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><p>Dans cet exercice, vous allez utiliser kubectl pour récupérer tous les pods exécutés dans un cluster et formater la sortie pour extraire la liste des conteneurs pour chacun.</p><h2 id=répertorier-toutes-les-images-de-conteneurs-dans-tous-les-namespaces>Répertorier toutes les images de conteneurs dans tous les namespaces</h2><ul><li>Récupérez tous les pods dans tous les namespace à l'aide de <code>kubectl get pods --all-namespaces</code></li><li>Formatez la sortie pour inclure uniquement la liste des noms d'image de conteneur à l'aide de <code>-o jsonpath={.items[*].spec.containers[*].image}</code>.
Cela analysera récursivement le champ <code>image</code> du json retourné.<ul><li>Voir la <a href=/docs/reference/kubectl/jsonpath/>reference jsonpath</a> pour plus d'informations sur l'utilisation de jsonpath.</li></ul></li><li>Formatez la sortie à l'aide des outils standard: <code>tr</code>, <code>sort</code>, <code>uniq</code><ul><li>Utilisez <code>tr</code> pour remplacer les espaces par des nouvelles lignes</li><li>Utilisez <code>sort</code> pour trier les résultats</li><li>Utilisez <code>uniq</code> pour agréger le nombre d'images</li></ul></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>tr -s <span style=color:#b44>&#39;[[:space:]]&#39;</span> <span style=color:#b44>&#39;\n&#39;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>sort |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>uniq -c
</span></span></code></pre></div><p>La commande ci-dessus renverra récursivement tous les champs nommés <code>image</code> pour tous les éléments retournés.</p><p>Comme alternative, il est possible d'utiliser le chemin absolu vers le champ d'image dans le Pod.
Cela garantit que le champ correct est récupéré même lorsque le nom du champ est répété, par ex. de nombreux champs sont appelés <code>name</code> dans un élément donné:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</span></span></code></pre></div><p>Le jsonpath est interprété comme suit:</p><ul><li><code>.items[*]</code>: pour chaque valeur renvoyée</li><li><code>.spec</code>: obtenir les spécifications</li><li><code>.containers[*]</code>: pour chaque conteneur</li><li><code>.image</code>: obtenir l'image</li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Lors de la récupération d'un seul pod par son nom, par exemple <code>kubectl get pod nginx</code>, la portion <code>.items[*]</code> du chemin doit être omis car un seul pod est renvoyé au lieu d'une liste d'éléments.</div><h2 id=liste-des-images-de-conteneurs-par-pod>Liste des images de conteneurs par pod</h2><p>Le formatage peut être contrôlé davantage en utilisant l'opération <code>range</code> pour parcourir les éléments individuellement.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{&#34;\n&#34;}{.metadata.name}{&#34;:\t&#34;}{range .spec.containers[*]}{.image}{&#34;, &#34;}{end}{end}&#39;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>sort
</span></span></code></pre></div><h2 id=filtrage-des-images-de-conteneur-de-liste-par-label-de-pod>Filtrage des images de conteneur de liste par label de pod</h2><p>Pour cibler uniquement les pods correspondant à un label spécifique, utilisez l'indicateur -l.
Les éléments suivants correspondent uniquement aux pods avec les labels <code>app=nginx</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span> -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><h2 id=filtrage-des-images-de-conteneur-de-liste-par-namespace-de-pod>Filtrage des images de conteneur de liste par namespace de pod</h2><p>Pour cibler uniquement les pods dans un namespace spécifique, utilisez l'indicateur de namespace.
Ce qui suit correspond uniquement aux pods du namespace <code>kube-system</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --namespace kube-system -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</span></span></code></pre></div><h2 id=répertorier-les-images-de-conteneurs-en-utilisant-un-go-template-au-lieu-de-jsonpath>Répertorier les images de conteneurs en utilisant un go-template au lieu de jsonpath</h2><p>Comme alternative à jsonpath, Kubectl peut aussi utiliser les <a href=https://golang.org/pkg/text/template/>go-templates</a> pour formater la sortie:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --all-namespaces -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#34;{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}&#34;</span>
</span></span></code></pre></div><h2 id=a-suivre>A suivre</h2><h3 id=reference>Reference</h3><ul><li>Guide de référence pour <a href=/docs/reference/kubectl/jsonpath/>Jsonpath</a></li><li>Guide de référence pour les <a href=https://golang.org/pkg/text/template/>Go template</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f6a755efe831d24956501e4bcd49ff96>9 - Monitoring, Logging et Debugging</h1></div><div class=td-content><h1 id=pg-9713ac27b6d9e3034033200d968221f2>9.1 - Obtenez un shell dans un conteneur en cours d'exécution</h1><p>Cette page montre comment utiliser <code>kubectl exec</code> pour obtenir un shell dans un conteneur en cours d'exécution.</p><h2 id=pré-requis>Pré-requis</h2><p><p>Vous devez disposer d'un cluster Kubernetes et l'outil de ligne de commande kubectl doit être configuré pour communiquer avec votre cluster.
Si vous ne possédez pas déjà de cluster, vous pouvez en créer un en utilisant <a href=/docs/setup/minikube>Minikube</a>, ou vous pouvez utiliser l'un de ces environnements Kubernetes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Pour consulter la version, entrez <code>kubectl version</code>.</p><h2 id=obtenir-un-shell-dans-un-conteneur>Obtenir un shell dans un conteneur</h2><p>Dans cet exercice, vous allez créer un pod contenant un conteneur.
Le conteneur exécute une image nginx.
Voici le fichier de configuration du Pod:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/fr/examples/application/shell-demo.yaml download=application/shell-demo.yaml><code>application/shell-demo.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-shell-demo-yaml")' title="Copy application/shell-demo.yaml to clipboard"></img></div><div class=includecode id=application-shell-demo-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>Default<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Créez le Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/shell-demo.yaml
</span></span></code></pre></div><p>Vérifiez que le conteneur est en cours d'exécution:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod shell-demo
</span></span></code></pre></div><p>Obtenez un shell pour le conteneur en cours d'exécution:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it shell-demo -- /bin/bash
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Le double tiret "-" est utilisé pour séparer les arguments que vous souhaitez passer à la commande des arguments kubectl.</div><p>Dans votre shell, listez le répertoire racine:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@shell-demo:/# ls /
</span></span></code></pre></div><p>Dans votre shell, testez d'autres commandes.
Voici quelques exemples:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@shell-demo:/# ls /
</span></span><span style=display:flex><span>root@shell-demo:/# cat /proc/mounts
</span></span><span style=display:flex><span>root@shell-demo:/# cat /proc/1/maps
</span></span><span style=display:flex><span>root@shell-demo:/# apt-get update
</span></span><span style=display:flex><span>root@shell-demo:/# apt-get install -y tcpdump
</span></span><span style=display:flex><span>root@shell-demo:/# tcpdump
</span></span><span style=display:flex><span>root@shell-demo:/# apt-get install -y lsof
</span></span><span style=display:flex><span>root@shell-demo:/# lsof
</span></span><span style=display:flex><span>root@shell-demo:/# apt-get install -y procps
</span></span><span style=display:flex><span>root@shell-demo:/# ps aux
</span></span><span style=display:flex><span>root@shell-demo:/# ps aux | grep nginx
</span></span></code></pre></div><h2 id=écriture-de-la-page-racine-de-nginx>Écriture de la page racine de nginx</h2><p>Regardez à nouveau le fichier de configuration de votre Pod.
Le pod a un volume <code>emptyDir</code> et le conteneur monte le volume dans <code>/usr/share/nginx/html</code>.</p><p>Dans votre shell, créez un fichier <code>index.html</code> dans le répertoire <code>/usr/share/nginx/html</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@shell-demo:/# <span style=color:#a2f>echo</span> Hello shell demo &gt; /usr/share/nginx/html/index.html
</span></span></code></pre></div><p>Dans votre shell, envoyez une requête GET au serveur nginx:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@shell-demo:/# apt-get update
</span></span><span style=display:flex><span>root@shell-demo:/# apt-get install curl
</span></span><span style=display:flex><span>root@shell-demo:/# curl localhost
</span></span></code></pre></div><p>La sortie affiche le texte que vous avez écrit dans le fichier <code>index.html</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Hello shell demo
</span></span></code></pre></div><p>Lorsque vous avez terminé avec votre shell, entrez <code>exit</code>.</p><h2 id=exécution-de-commandes-individuelles-dans-un-conteneur>Exécution de commandes individuelles dans un conteneur</h2><p>Dans une fenêtre de commande ordinaire, pas votre shell, répertoriez les variables d'environnement dans le conteneur en cours d'exécution:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo env
</span></span></code></pre></div><p>Essayez d'exécuter d'autres commandes.
Voici quelques exemples:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo ps aux
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo ls /
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo cat /proc/1/mounts
</span></span></code></pre></div><h2 id=ouverture-d-un-shell-lorsqu-un-pod-possède-plusieurs-conteneurs>Ouverture d'un shell lorsqu'un pod possède plusieurs conteneurs</h2><p>Si un pod a plusieurs conteneurs, utilisez <code>--container</code> ou <code>-c</code> pour spécifier un conteneur dans la commande <code>kubectl exec</code>.
Par exemple, supposons que vous ayez un pod nommé my-pod et que le pod ait deux conteneurs nommés main-app et helper-app.
La commande suivante ouvrirait un shell sur le conteneur de l'application principale.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it my-pod --container main-app -- /bin/bash
</span></span></code></pre></div><h2 id=a-suivre>A suivre</h2><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fd78dc15c135dedc24438431769d4d5b>10 - Extensions de Kubernetes</h1></div><div class=td-content><h1 id=pg-5b9d7df11699e8cb1a5a4414ff770efe>10.1 - Utilisation des ressources personnalisées</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-d3c88a8663f58e9ec0bed73faff5b670>11 - TLS</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-40e9293a348cfa50147082afc09ff77f>12 - Fédération</h1></div><div class=td-content><h1 id=pg-b61e5206fb2a30cabe2857ed4aaf7944>12.1 - Administration du Control Plane de la fédération</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-ba58efa15c6d46f10e34d799be220965>13 - Gestion des démons du cluster</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-5266308e17490aeee8b018316bf47e03>14 - Installation du catalogue de services</h1></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/fr/docs/home/>Accueil</a>
<a class=text-white href=/fr/blog/>Blog</a>
<a class=text-white href=/fr/partners/>Partenaires</a>
<a class=text-white href=/fr/community/>Communauté</a>
<a class=text-white href=/fr/case-studies/>Études de cas</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>