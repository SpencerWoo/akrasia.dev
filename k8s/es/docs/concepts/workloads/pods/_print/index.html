<!doctype html><html lang=es class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/workloads/pods/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/workloads/pods/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/workloads/pods/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/workloads/pods/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/workloads/pods/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/workloads/pods/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/es/docs/concepts/workloads/pods/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Pods | Kubernetes</title><meta property="og:title" content="Pods"><meta property="og:description" content="Orquestación de contenedores para producción"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/es/docs/concepts/workloads/pods/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Pods"><meta itemprop=description content="Orquestación de contenedores para producción"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pods"><meta name=twitter:description content="Orquestación de contenedores para producción"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/es/docs/concepts/workloads/pods/"><meta property="og:title" content="Pods"><meta name=twitter:title content="Pods"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/es/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/es/docs/>Documentación</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/es/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/es/partners/>Partners</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/es/community/>Comunidad</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/es/case-studies/>Casos de éxito</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/es/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/es/docs/concepts/workloads/pods/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/es/docs/concepts/workloads/pods/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/es/docs/concepts/workloads/pods/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/es/docs/concepts/workloads/pods/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/es/docs/concepts/workloads/pods/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Español (Spanish)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/workloads/pods/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/workloads/pods/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/workloads/pods/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/workloads/pods/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/workloads/pods/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/workloads/pods/>Deutsch (German)</a>
<a class=dropdown-item href=/id/docs/concepts/workloads/pods/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Versión imprimible multipagina.
<a href=# onclick="return print(),!1">Haga click aquí para imprimir</a>.</p><p><a href=/es/docs/concepts/workloads/pods/>Volver a la vista normal de esta página</a>.</p></div><h1 class=title>Pods</h1><ul><li>1: <a href=#pg-99cce294fe789317ee684a6e1f07f20f>Pods</a></li><li>2: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>Contenedores de Inicialización</a></li><li>3: <a href=#pg-4e9b9cbc9776b12e7335c53da377c9c8>Pod Preset</a></li><li>4: <a href=#pg-4aaf43c715cd764bc8ed4436f3537e68>Interrupciones</a></li><li>5: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>Containers Efímeros</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-99cce294fe789317ee684a6e1f07f20f>1 - Pods</h1><p>Los <em>Pods</em> son las unidades de computación desplegables más pequeñas que se pueden crear y gestionar en Kubernetes.</p><h2 id=qué-és-un-pod>¿Qué és un Pod?</h2><p>Un <em>Pod</em> (como en una vaina de ballenas o vaina de guisantes) es un grupo de uno o más contenedores (como contenedores Docker), con almacenamiento/red compartidos, y unas especificaciones de cómo ejecutar los contenedores. Los contenidos de un Pod son siempre coubicados, coprogramados y ejecutados en un contexto compartido. Un Pod modela un "host lógico" específico de la aplicación: contiene uno o más contenedores de aplicaciones relativamente entrelazados. Antes de la llegada de los contenedores, ejecutarse en la misma máquina física o virtual significaba ser ejecutado en el mismo host lógico.</p><p>Mientras que Kubernetes soporta más <a class=glossary-tooltip title='El Container Runtime, entorno de ejecución de un contenedor, es el software responsable de ejecutar contenedores.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='runtimes de contenedores'>runtimes de contenedores</a> a parte de Docker, este último es el más conocido y ayuda a describir Pods en términos de Docker.</p><p>El contexto compartido de un Pod es un conjunto de namespaces de Linux, cgroups y, potencialmente, otras facetas de aislamiento, las mismas cosas que aíslan un contenedor Docker. Dentro del contexto de un Pod, las aplicaciones individuales pueden tener más subaislamientos aplicados.</p><p>Los contenedores dentro de un Pod comparten dirección IP y puerto, y pueden encontrarse a través de <code>localhost</code>. También pueden comunicarse entre sí mediante comunicaciones estándar entre procesos, como semáforos de SystemV o la memoria compartida POSIX. Los contenedores en diferentes Pods tienen direcciones IP distintas y no pueden comunicarse por IPC sin <a href=/docs/concepts/policy/pod-security-policy/>configuración especial</a>.
Estos contenedores normalmente se comunican entre sí a través de las direcciones IP del Pod.</p><p>Las aplicaciones dentro de un Pod también tienen acceso a <a class=glossary-tooltip title='Un directorio que contiene datos y que es accesible desde los contenedores corriendo en un pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volúmenes>volúmenes</a> compartidos, que se definen como parte de un Pod y están disponibles para ser montados en el sistema de archivos de cada aplicación.</p><p>En términos de <a href=https://www.docker.com/>Docker</a>, un Pod se modela como un grupo de contenedores de Docker con namespaces y volúmenes de sistemas de archivos compartidos.</p><p>Al igual que los contenedores de aplicaciones individuales, los Pods se consideran entidades relativamente efímeras (en lugar de duraderas). Como se explica en <a href=/docs/concepts/workloads/pods/pod-lifecycle/>ciclo de vida del pod</a>, los Pods se crean, se les asigna un identificador único (UID) y se planifican en nodos donde permanecen hasta su finalización (según la política de reinicio) o supresión. Si un <a class=glossary-tooltip title='Un Node, nodo en castellano, es una de las máquinas del clúster de Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nodo>nodo</a> muere, los Pods programados para ese nodo se programan para su eliminación después de un período de tiempo de espera. Un Pod dado (definido por su UID) no se "replanifica" a un nuevo nodo; en su lugar, puede reemplazarse por un Pod idéntico, con incluso el mismo nombre si lo desea, pero con un nuevo UID (consulte <a href=/es/docs/concepts/workloads/controllers/replicationcontroller/>controlador de replicación</a> para obtener más detalles).</p><p>Cuando se dice que algo tiene la misma vida útil que un Pod, como un volumen, significa que existe mientras exista ese Pod (con ese UID). Si ese Pod se elimina por cualquier motivo, incluso si se crea un reemplazo idéntico, el recurso relacionado (por ejemplo, el volumen) también se destruye y se crea de nuevo.<figure><img src=/images/docs/pod.svg width=50%><figcaption><h4>diagrama de Pod</h4></figcaption></figure></p><p><em>Un Pod de múltiples contenedores que contiene un extractor de archivos y un servidor web que utiliza un volumen persistente para el almacenamiento compartido entre los contenedores.</em></p><h2 id=motivación-para-los-pods>Motivación para los Pods</h2><h3 id=gestión>Gestión</h3><p>Los Pods son un modelo del patrón de múltiples procesos de cooperación que forman una unidad de servicio cohesiva. Simplifican la implementación y la administración de las aplicaciones proporcionando una abstracción de mayor nivel que el conjunto de las aplicaciones que lo constituyen. Los Pods sirven como unidad de despliegue, escalado horizontal y replicación. La colocación (coprogramación), el destino compartido (por ejemplo, la finalización), la replicación coordinada, el uso compartido de recursos y la gestión de dependencias se controlan automáticamente para los contenedores en un Pod.</p><h3 id=recursos-compartidos-y-comunicación>Recursos compartidos y comunicación</h3><p>Los Pods permiten el intercambio de datos y la comunicación entre los contenedores que lo constituyen.</p><p>Todas las aplicaciones en un Pod utilizan el mismo namespace de red (la misma IP y puerto) y, por lo tanto, pueden "encontrarse" entre sí y comunicarse utilizando <code>localhost</code>.
Debido a esto, las aplicaciones en un Pod deben coordinar su uso de puertos. Cada Pod tiene una dirección IP en un espacio de red compartido que tiene comunicación completa con otros servidores físicos y Pods a través de la red.</p><p>Los contenedores dentro del Pod ven que el hostname del sistema es el mismo que el <code>nombre</code> configurado para el Pod. Hay más información sobre esto en la sección <a href=/docs/concepts/cluster-administration/networking/>networking</a>.</p><p>Además de definir los contenedores de aplicaciones que se ejecutan en el Pod, el Pod especifica un conjunto de volúmenes de almacenamiento compartido. Los volúmenes permiten que los datos sobrevivan a reinicios de contenedores y se compartan entre las aplicaciones dentro del Pod.</p><h2 id=usos-de-pods>Usos de Pods</h2><p>Los Pods pueden ser usados para alojar pilas de aplicaciones integradas (por ejemplo, LAMP), pero su objetivo principal es apoyar los programas de ayuda coubicados y coadministrados, como:</p><ul><li>sistemas de gestión de contenido, loaders de datos y archivos, gestores de caché locales, etc.</li><li>copia de seguridad de registro y punto de control, compresión, rotación, captura de imágenes, etc.</li><li>observadores de cambio de datos, adaptadores de registro y monitoreo, publicadores de eventos, etc.</li><li>proxies, bridges y adaptadores.</li><li>controladores, configuradores y actualizadores.</li></ul><p>Los Pods individuales no están diseñados para ejecutar varias instancias de la misma aplicación, en general.</p><p>Para una explicación más detallada, ver <a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>El sistema distribuido ToolKit: Patrones para Contenedores multiaplicación</a>.</p><h2 id=alternativas>Alternativas</h2><p><em>¿Por qué simplemente no ejecutar múltiples programas en un solo contenedor de Docker?</em></p><ol><li>Transparencia. Hacer visibles los contenedores dentro del Pod
a la infraestructura permite que esta brinde servicios, como gestión de procesos
y monitoreo de recursos, a los contenedores, facilitando una
serie de comodidades a los usuarios.</li><li>Desacople de dependencias de software. Los contenedores individuales pueden ser
versionados, reconstruidos y redistribuidos independientemente. Kubernetes podría incluso apoyar
actualizaciones en vivo de contenedores individuales en un futuro.</li><li>Facilidad de uso. Los usuarios no necesitan ejecutar sus propios administradores de procesos,
para propagación de señales, códigos de salida, etc.</li><li>Eficiencia. Debido a que la infraestructura asume más responsabilidad,
los contenedores pueden ser más livianos.</li></ol><p><em>¿Por qué no admitir la planificación conjunta de contenedores por afinidad?</em></p><p>Ese enfoque proporcionaría la ubicación conjunta, pero no la mayor parte de
beneficios de los Pods, como compartir recursos, IPC, compartir el destino garantizado y
gestión simplificada.</p><h2 id=durabilidad-de-pods-o-su-ausencia>Durabilidad de pods (o su ausencia)</h2><p>Los Pods no están destinados a ser tratados como entidades duraderas. No sobrevivirán a errores de planificación, caídas de nodo u otros desalojos, ya sea por falta de recursos o en el caso de mantenimiento de nodos.</p><p>En general, los usuarios no deberían necesitar crear Pods directamente, deberían
usar siempre controladores incluso para Pods individuales, como por ejemplo, los
<a href=/es/docs/concepts/workloads/controllers/deployment/>Deployments</a>.
Los controladores proporcionan autorecuperación con un alcance de clúster, así como replicación
y gestión de despliegue.
Otros controladores como los <a href=/es/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>
pueden tambien proporcionar soporte para Pods que necesiten persistir el estado.</p><p>El uso de API colectivas como la principal primitiva de cara al usuario es relativamente común entre los sistemas de planificación de clúster, incluyendo <a href=https://research.google.com/pubs/pub43438.html>Borg</a>, <a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a>, <a href=http://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a>, y <a href=http://www.slideshare.net/Docker/aravindnarayanan-facebook140613153626phpapp02-37588997>Tupperware</a>.</p><p>El Pod se expone como primitiva para facilitar:</p><ul><li>planificación y capacidad de conexión del controlador</li><li>soporte para operaciones a nivel de Pod sin la necesidad de "proxy" a través de las API del controlador</li><li>desacople de la vida útil del Pod de la vida útil del controlador, como para el arranque</li><li>desacople de controladores y servicios, el endpoint del controlador solo mira Pods</li><li>composición limpia de funcionalidad a nivel de Kubelet con funcionalidad a nivel de clúster, Kubelet es efectivamente el "controlador de Pod"</li><li>aplicaciones en alta disponibilidad, que esperan que los Pods sean reemplazados antes de su finalización y ciertamente antes de su eliminación, como en el caso de desalojos planificados o descarga previa de imágenes.</li></ul><h2 id=finalización-de-pods>Finalización de Pods</h2><p>Debido a que los Pods representan procesos en ejecución en los nodos del clúster, es importante permitir que esos procesos finalicen de forma correcta cuando ya no se necesiten (en lugar de ser detenidos bruscamente con una señal de KILL). Los usuarios deben poder solicitar la eliminación y saber cuándo finalizan los procesos, pero también deben poder asegurarse de que las eliminaciones finalmente se completen. Cuando un usuario solicita la eliminación de un Pod, el sistema registra el período de gracia previsto antes de que el Pod pueda ser eliminado de forma forzada, y se envía una señal TERM al proceso principal en cada contenedor. Una vez que el período de gracia ha expirado, la señal KILL se envía a esos procesos y el Pod se elimina del servidor API. Si se reinicia Kubelet o el administrador de contenedores mientras se espera que finalicen los procesos, la terminación se volverá a intentar con el período de gracia completo.</p><p>Un ejemplo del ciclo de terminación de un Pod:</p><ol><li>El usuario envía un comando para eliminar Pod, con un período de gracia predeterminado (30s)</li><li>El Pod en el servidor API se actualiza con el tiempo a partir del cual el Pod se considera "muerto" junto con el período de gracia.</li><li>El Pod aparece como "Terminando" cuando aparece en los comandos del cliente</li><li>(simultáneo con 3) Cuando el Kubelet ve que un Pod se ha marcado como terminado porque se ha configurado el tiempo en 2, comienza el proceso de apagado del Pod.<ol><li>Si uno de los contenedores del Pod ha definido un <a href=/es/docs/concepts/containers/container-lifecycle-hooks/#hook-details>preStop hook</a>, se invoca dentro del contenedor. Si el hook <code>preStop</code> todavía se está ejecutando después de que expire el período de gracia, el paso 2 se invoca con un pequeño período de gracia extendido (2s).</li><li>El contenedor recibe la señal TERM. Tenga en cuenta que no todos los contenedores en el Pod recibirán la señal TERM al mismo tiempo y cada uno puede requerir un hook <code>preStop</code> si el orden en el que se cierra es importante.</li></ol></li><li>(simultáneo con 3) Pod se elimina de la lista de endponts del servicio, y ya no se considera parte del conjunto de Pods en ejecución para controladores de replicación. Los Pods que se apagan lentamente no pueden continuar sirviendo el tráfico ya que los balanceadores de carga (como el proxy de servicio) los eliminan de sus rotaciones.</li><li>Cuando expira el período de gracia, todos los procesos que todavía se ejecutan en el Pod se eliminan con SIGKILL.</li><li>El Kubelet terminará de eliminar el Pod en el servidor API configurando el período de gracia 0 (eliminación inmediata). El Pod desaparece de la API y ya no es visible desde el cliente.</li></ol><p>Por defecto, todas las eliminaciones se realizan correctamente en 30 segundos. El comando <code>kubectl delete</code> admite la opción<code>--grace-period = &lt;seconds></code>que permite al usuario anular el valor predeterminado y especificar su propio valor. El valor <code>0</code> <a href=/es/docs/concepts/workloads/pods/pod/#forzar-destrucci%C3%B3n-de-pods>forzar eliminación</a> del Pod.
Debe especificar un indicador adicional <code>--force</code> junto con <code>--grace-period = 0</code> para realizar eliminaciones forzadas.</p><h3 id=forzar-destrucción-de-pods>Forzar destrucción de Pods</h3><p>La eliminación forzada de un Pod se define como la eliminación de un Pod del estado del clúster y etcd inmediatamente. Cuando se realiza una eliminación forzada, el apiserver no espera la confirmación del kubelet de que el Pod ha finalizado en el nodo en el que se estaba ejecutando. Elimina el Pod en la API inmediatamente para que se pueda crear un nuevo Pod con el mismo nombre. En el nodo, los Pods que están configurados para terminar de inmediato recibirán un pequeño período de gracia antes de ser forzadas a matar.</p><p>Estas eliminaciones pueden ser potencialmente peligrosas para algunos Pods y deben realizarse con precaución. En el caso de Pods de StatefulSets, consulte la documentación de la tarea para <a href=/docs/tasks/run-application/force-delete-stateful-set-pod/>eliminando Pods de un StatefulSet</a>.</p><h2 id=modo-privilegiado-para-pods>Modo privilegiado para Pods</h2><p>Cualquier contenedor en un Pod puede habilitar el modo privilegiado, utilizando el indicador <code>privilegiado</code> en el <a href=/docs/tasks/configure-pod-container/security-context/>contexto de seguridad</a> de la especificación del contenedor. Esto es útil para contenedores que desean usar capacidades de Linux como manipular la pila de red y acceder a dispositivos. Los procesos dentro del contenedor obtienen casi los mismos privilegios que están disponibles para los procesos fuera de un contenedor. Con el modo privilegiado, debería ser más fácil escribir complementos de red y volumen como Pods separados que no necesitan compilarse en el kubelet.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> El <a class=glossary-tooltip title='El Container Runtime, entorno de ejecución de un contenedor, es el software responsable de ejecutar contenedores.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='runtime de contenedores'>runtime de contenedores</a> debe admitir el concepto de un contenedor privilegiado para que esta configuración sea relevante.</div><h2 id=api>API</h2><p>Pod es un recurso de nivel superior en la API REST de Kubernetes.
La definición de <a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>objeto de API Pod</a>
describe el objeto en detalle.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>2 - Contenedores de Inicialización</h1><p>Esta página proporciona una descripción general de los contenedores de inicialización (init containers): contenedores especializados que se ejecutan
antes de los contenedores de aplicación en un <a class=glossary-tooltip title='El objeto más pequeño y simple de Kubernetes. Un Pod es la unidad mínima de computación en Kubernetes y representa uno o más contenedores ejecutándose en el clúster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>.
Los contenedores de inicialización pueden contener utilidades o scripts de instalación no presentes en una imagen de aplicación.</p><p>Tú puedes especificar contenedores de inicialización en la especificación del Pod junto con el arreglo de <code>containers</code>
(el cual describe los contenedores de aplicación).</p><h2 id=entendiendo-los-contenedores-de-inicialización>Entendiendo los contenedores de inicialización</h2><p>Un <a class=glossary-tooltip title='El objeto más pequeño y simple de Kubernetes. Un Pod es la unidad mínima de computación en Kubernetes y representa uno o más contenedores ejecutándose en el clúster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> puede tener múltiples contenedores
ejecutando aplicaciones dentro de él, pero también puede tener uno o más contenedores de inicialización
que se ejecutan antes de que se inicien los contenedores de aplicación.</p><p>Los contenedores de inicialización son exactamente iguales a los contenedores regulares excepto por:</p><ul><li>Los contenedores de inicialización siempre se ejecutan hasta su finalización.</li><li>Cada contenedor de inicialiación debe completarse correctamente antes de que comience el siguiente.</li></ul><p>Si el contenedor de inicialización de un Pod falla, kubelet reinicia repetidamente ese contenedor de inicialización hasta que tenga éxito.
Sin embargo, si el Pod tiene una <code>restartPolicy</code> de <code>Never</code> y un contenedor de inicialización falla durante el inicio de ese Pod, Kubernetes trata al Pod en general como fallido.</p><p>Para especificar un contenedor de inicialización para un Pod, agrega el campo <code>initContainers</code> en
la <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>especificación del Pod</a>,
como un arreglo de elementos <code>container</code> (similar al campo <code>containers</code> de aplicación y su contenido).
Consulta <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>Container</a> en la
referencia de API para más detalles.</p><p>El estado de los contenedores de inicialización se devuelve en el campo <code>.status.initContainerStatuses</code>
como un arreglo de los estados del contenedor (similar al campo <code>.status.containerStatuses</code>).</p><h3 id=diferencias-con-los-contenedores-regulares>Diferencias con los contenedores regulares</h3><p>Los contenedores de inicialización admiten todos los campos y características de los contenedores de aplicaciones,
incluidos los límites de recursos, los volúmenes y la configuración de seguridad. Sin embargo, las
solicitudes de recursos y los límites para un contenedor de inicialización se manejan de manera diferente,
como se documenta en <a href=#resources>Recursos</a>.</p><p>Además, los contenedores de inicialización no admiten <code>lifecycle</code>, <code>livenessProbe</code>, <code>readinessProbe</code> o
<code>startupProbe</code> porque deben de ejecutarse hasta su finalización antes de que el Pod pueda estar listo.</p><p>Si especificas varios contenedores de inicialización para un Pod, kubelet ejecuta cada contenedor
de inicialización secuencialmente. Cada contenedor de inicialización debe tener éxito antes de que se pueda ejecutar el siguiente.
Cuando todos los contenedores de inicialización se hayan ejecutado hasta su finalización, kubelet inicializa
los contenedores de aplicación para el Pod y los ejecuta como de costumbre.</p><h3 id=usando-contenedores-de-inicialización>Usando contenedores de inicialización</h3><p>Dado que los contenedores de inicialización tienen imágenes separadas de los contenedores de aplicaciones, estos
tienen algunas ventajas sobre el código relacionado de inicio:</p><ul><li>Los contenedores de inicialización pueden contener utilidades o código personalizado para la configuración que no están presentes en una
imagen de aplicación. Por ejemplo, no hay necesidad de hacer una imagen <code>FROM</code> de otra imagen solo para usar una herramienta como
<code>sed</code>, <code>awk</code>, <code>python</code> o <code>dig</code> durante la instalación.</li><li>Los roles de constructor e implementador de imágenes de aplicación pueden funcionar de forma independiente sin
la necesidad de construir conjuntamente una sola imagen de aplicación.</li><li>Los contenedores de inicialización pueden ejecutarse con una vista diferente al sistema de archivos que los contenedores de aplicaciones en
el mismo Pod. En consecuencia, se les puede dar acceso a
<a class=glossary-tooltip title='Almacena información sensible, como contraseñas, tokens OAuth o claves ssh.' data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/secret/ target=_blank aria-label=Secrets>Secrets</a> a los que los contenedores de aplicaciones no pueden acceder.</li><li>Debido a que los contenedores de inicialización se ejecutan hasta su finalización antes de que se inicien los contenedores de aplicaciones, los contenedores de inicialización ofrecen
un mecanismo para bloquear o retrasar el inicio del contenedor de aplicación hasta que se cumplan una serie de condiciones previas. Una vez
que las condiciones previas se cumplen, todos los contenedores de aplicaciones de un Pod pueden iniciarse en paralelo.</li><li>Los contenedores de inicialización pueden ejecutar de forma segura utilidades o código personalizado que de otro modo harían a una imagen de aplicación
de contenedor menos segura. Si mantiene separadas herramientas innecesarias, puede limitar la superficie de ataque
a la imagen del contenedor de aplicación.</li></ul><h3 id=ejemplos>Ejemplos</h3><p>A continuación, se muestran algunas ideas sobre cómo utilizar los contenedores de inicialización:</p><ul><li><p>Esperar a que se cree un <a class=glossary-tooltip title='Un Service, servicio en castellano, es el objeto de la API de Kubernetes que describe cómo se accede a las aplicaciones, tal como un conjunto de Pods, y que puede describir puertos y balanceadores de carga.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>
usando una sola linea de comando de shell:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>{</span>1..100<span style=color:#666>}</span>; <span style=color:#a2f;font-weight:700>do</span> sleep 1; <span style=color:#a2f;font-weight:700>if</span> dig myservice; <span style=color:#a2f;font-weight:700>then</span> <span style=color:#a2f>exit</span> 0; <span style=color:#a2f;font-weight:700>fi</span>; <span style=color:#a2f;font-weight:700>done</span>; <span style=color:#a2f>exit</span> <span style=color:#666>1</span>
</span></span></code></pre></div></li><li><p>Registrar este Pod con un servidor remoto desde la downward API con un comando como:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X POST http://<span style=color:#b8860b>$MANAGEMENT_SERVICE_HOST</span>:<span style=color:#b8860b>$MANAGEMENT_SERVICE_PORT</span>/register -d <span style=color:#b44>&#39;instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)&#39;</span>
</span></span></code></pre></div></li><li><p>Esperar algo de tiempo antes de iniciar el contenedor de aplicación con un comando como:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sleep <span style=color:#666>60</span>
</span></span></code></pre></div></li><li><p>Clonar un repositorio de Git en un <a class=glossary-tooltip title='Un directorio que contiene datos y que es accesible desde los contenedores corriendo en un pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a></p></li><li><p>Colocar valores en un archivo de configuración y ejecutar una herramienta de plantilla para generar
dinámicamente un archivo de configuración para el contenedor de aplicación principal. Por ejemplo,
colocar el valor <code>POD_IP</code> en una configuración y generar el archivo de configuración
de la aplicación principal usando Jinja.</p></li></ul><h4 id=contenedores-de-inicialización-en-uso>Contenedores de inicialización en uso</h4><p>Este ejemplo define un simple Pod que tiene dos contenedores de inicialización.
El primero espera por <code>myservice</code> y el segundo espera por <code>mydb</code>. Una vez que ambos
contenedores de inicialización se completen, el Pod ejecuta el contenedor de aplicación desde su sección <code>spec</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo ¡La aplicación se está ejecutando! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo esperando a myservice; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo esperando a mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Puedes iniciar este Pod ejecutando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f myapp.yaml
</span></span></code></pre></div><p>El resultado es similar a esto:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pod/myapp-pod created
</span></span></code></pre></div><p>Y verificar su estado con:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>El resultado es similar a esto:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME        READY     STATUS     RESTARTS   AGE
</span></span><span style=display:flex><span>myapp-pod   0/1       Init:0/2   <span style=color:#666>0</span>          6m
</span></span></code></pre></div><p>o para más detalles:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe -f myapp.yaml
</span></span></code></pre></div><p>El resultado es similar a esto:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:          myapp-pod
</span></span><span style=display:flex><span>Namespace:     default
</span></span><span style=display:flex><span><span style=color:#666>[</span>...<span style=color:#666>]</span>
</span></span><span style=display:flex><span>Labels:        app.kubernetes.io/name<span style=color:#666>=</span>MyApp
</span></span><span style=display:flex><span>Status:        Pending
</span></span><span style=display:flex><span><span style=color:#666>[</span>...<span style=color:#666>]</span>
</span></span><span style=display:flex><span>Init Containers:
</span></span><span style=display:flex><span>  init-myservice:
</span></span><span style=display:flex><span><span style=color:#666>[</span>...<span style=color:#666>]</span>
</span></span><span style=display:flex><span>    State:         Running
</span></span><span style=display:flex><span><span style=color:#666>[</span>...<span style=color:#666>]</span>
</span></span><span style=display:flex><span>  init-mydb:
</span></span><span style=display:flex><span><span style=color:#666>[</span>...<span style=color:#666>]</span>
</span></span><span style=display:flex><span>    State:         Waiting
</span></span><span style=display:flex><span>      Reason:      PodInitializing
</span></span><span style=display:flex><span>    Ready:         False
</span></span><span style=display:flex><span><span style=color:#666>[</span>...<span style=color:#666>]</span>
</span></span><span style=display:flex><span>Containers:
</span></span><span style=display:flex><span>  myapp-container:
</span></span><span style=display:flex><span><span style=color:#666>[</span>...<span style=color:#666>]</span>
</span></span><span style=display:flex><span>    State:         Waiting
</span></span><span style=display:flex><span>      Reason:      PodInitializing
</span></span><span style=display:flex><span>    Ready:         False
</span></span><span style=display:flex><span><span style=color:#666>[</span>...<span style=color:#666>]</span>
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
</span></span><span style=display:flex><span>  ---------    --------    -----    ----                      -------------                           --------      ------        -------
</span></span><span style=display:flex><span>  16s          16s         <span style=color:#666>1</span>        <span style=color:#666>{</span>default-scheduler <span style=color:#666>}</span>                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
</span></span><span style=display:flex><span>  16s          16s         <span style=color:#666>1</span>        <span style=color:#666>{</span>kubelet 172.17.4.201<span style=color:#666>}</span>    spec.initContainers<span style=color:#666>{</span>init-myservice<span style=color:#666>}</span>     Normal        Pulling       pulling image <span style=color:#b44>&#34;busybox&#34;</span>
</span></span><span style=display:flex><span>  13s          13s         <span style=color:#666>1</span>        <span style=color:#666>{</span>kubelet 172.17.4.201<span style=color:#666>}</span>    spec.initContainers<span style=color:#666>{</span>init-myservice<span style=color:#666>}</span>     Normal        Pulled        Successfully pulled image <span style=color:#b44>&#34;busybox&#34;</span>
</span></span><span style=display:flex><span>  13s          13s         <span style=color:#666>1</span>        <span style=color:#666>{</span>kubelet 172.17.4.201<span style=color:#666>}</span>    spec.initContainers<span style=color:#666>{</span>init-myservice<span style=color:#666>}</span>     Normal        Created       Created container with docker id 5ced34a04634; Security:<span style=color:#666>[</span><span style=color:#b8860b>seccomp</span><span style=color:#666>=</span>unconfined<span style=color:#666>]</span>
</span></span><span style=display:flex><span>  13s          13s         <span style=color:#666>1</span>        <span style=color:#666>{</span>kubelet 172.17.4.201<span style=color:#666>}</span>    spec.initContainers<span style=color:#666>{</span>init-myservice<span style=color:#666>}</span>     Normal        Started       Started container with docker id 5ced34a04634
</span></span></code></pre></div><p>Para ver los logs de los contenedores de inicialización en este Pod ejecuta:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># Inspecciona el primer contenedor de inicialización</span>
</span></span><span style=display:flex><span>kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># Inspecciona el segundo contenedor de inicialización</span>
</span></span></code></pre></div><p>En este punto, estos contenedores de inicialización estarán esperando para descubrir los Servicios denominados
<code>mydb</code> y <code>myservice</code>.</p><p>Aquí hay una configuración que puedes usar para que aparezcan esos Servicios:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Para crear los servicios de <code>mydb</code> y <code>myservice</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f services.yaml
</span></span></code></pre></div><p>El resultado es similar a esto:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>service/myservice created
</span></span><span style=display:flex><span>service/mydb created
</span></span></code></pre></div><p>Luego verás que esos contenedores de inicialización se completan y que el Pod <code>myapp-pod</code>
pasa al estado <code>Running</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>El resultado es similar a esto:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME        READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>myapp-pod   1/1       Running   <span style=color:#666>0</span>          9m
</span></span></code></pre></div><p>Este sencillo ejemplo debería servirte de inspiración para crear tus propios
contenedores de inicialización. <a href=#what-s-next>¿Qué es lo que sigue?</a> contiene un enlace a un ejemplo más detallado.</p><h2 id=comportamiento-detallado>Comportamiento detallado</h2><p>Durante el inicio del Pod, kubelet retrasa la ejecución de contenedores de inicialización hasta que la red
y el almacenamiento estén listos. Después, kubelet ejecuta los contenedores de inicialización del Pod en el orden que
aparecen en la especificación del Pod.</p><p>Cada contenedor de inicialización debe salir correctamente antes de que
comience el siguiente contenedor. Si un contenedor falla en iniciar debido al tiempo de ejecución o
sale con una falla, se vuelve a intentar de acuerdo con el <code>restartPolicy</code> del Pod. Sin embargo,
si el <code>restartPolicy</code> del Pod se establece en <code>Always</code>, los contenedores de inicialización usan
el <code>restartPolicy</code> como <code>OnFailure</code>.</p><p>Un Pod no puede estar <code>Ready</code> sino hasta que todos los contenedores de inicialización hayan tenido éxito. Los puertos en un
contenedor de inicialización no se agregan a un Servicio. Un Pod que se está inicializando,
está en el estado de <code>Pending</code>, pero debe tener una condición <code>Initialized</code> configurada como falsa.</p><p>Si el Pod <a href=#pod-restart-reasons>se reinicia</a> o es reiniciado, todos los contenedores de inicialización
deben ejecutarse de nuevo.</p><p>Los cambios en la especificación del contenedor de inicialización se limitan al campo de la imagen del contenedor.
Alterar un campo de la imagen del contenedor de inicialización equivale a reiniciar el Pod.</p><p>Debido a que los contenedores de inicialización se pueden reiniciar, reintentar o volverse a ejecutar, el código del contenedor de inicialización
debe ser idempotente. En particular, el código que escribe en archivos en <code>EmptyDirs</code>
debe estar preparado para la posibilidad de que ya exista un archivo de salida.</p><p>Los contenedores de inicialización tienen todos los campos de un contenedor de aplicaciones. Sin embargo, Kubernetes
prohíbe el uso de <code>readinessProbe</code> porque los contenedores de inicialización no pueden
definir el <code>readiness</code> distinto de la finalización. Esto se aplica durante la validación.</p><p>Usa <code>activeDeadlineSeconds</code> en el Pod para prevenir que los contenedores de inicialización fallen por siempre.
La fecha límite incluye contenedores de inicialización.
Sin embargo, se recomienda utilizar <code>activeDeadlineSeconds</code> si el usuario implementa su aplicación
como un <code>Job</code> porque <code>activeDeadlineSeconds</code> tiene un efecto incluso después de que <code>initContainer</code> finaliza.
El Pod que ya se está ejecutando correctamente sería eliminado por <code>activeDeadlineSeconds</code> si lo estableces.</p><p>El nombre de cada aplicación y contenedor de inicialización en un Pod debe ser único; un
error de validación es arrojado para cualquier contenedor que comparta un nombre con otro.</p><h3 id=recursos>Recursos</h3><p>Dado el orden y la ejecución de los contenedores de inicialización, las siguientes reglas
para el uso de recursos se aplican:</p><ul><li>La solicitud más alta de cualquier recurso o límite particular definido en todos los contenedores
de inicialización es la <em>solicitud/límite de inicialización efectiva</em>. Si algún recurso no tiene un
límite de recursos especificado éste se considera como el límite más alto.</li><li>La <em>solicitud/límite efectiva</em> para un recurso es la más alta entre:<ul><li>la suma de todas las solicitudes/límites de los contenedores de aplicación, y</li><li>la solicitud/límite de inicialización efectiva para un recurso</li></ul></li><li>La planificación es hecha con base en las solicitudes/límites efectivos, lo que significa
que los contenedores de inicialización pueden reservar recursos para la inicialización que no se utilizan
durante la vida del Pod.</li><li>El nivel de <code>QoS</code> (calidad de servicio) del <em>nivel de <code>QoS</code> efectivo</em> del Pod es el
nivel de <code>QoS</code> tanto para los contenedores de inicialización como para los contenedores de aplicación.</li></ul><p>La cuota y los límites son aplicados con base en la solicitud y límite efectivos de Pod.</p><p>Los grupos de control de nivel de Pod (cgroups) se basan en la solicitud y el límite de Pod efectivos, al igual que el planificador de Kubernetes (<a class=glossary-tooltip title='Componente del plano de control que está pendiente de los pods que no tienen ningún nodo asignado y seleciona uno dónde ejecutarlo.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>).</p><h3 id=razones-de-reinicio-del-pod>Razones de reinicio del Pod</h3><p>Un Pod puede reiniciarse, provocando la re-ejecución de los contenedores de inicialización por las siguientes razones:</p><ul><li>Se reinicia el contenedor de infraestructura del Pod. Esto es poco común y debería hacerlo alguien con acceso de root a los nodos.</li><li>Todos los contenedores en un Pod son terminados mientras <code>restartPolicy</code> esté configurado en <code>Always</code>,
forzando un reinicio y el registro de finalización del contenedor de inicialización se ha perdido debido a
la recolección de basura.</li></ul><p>El Pod no se reiniciará cuando se cambie la imagen del contenedor de inicialización o cuando
se pierda el registro de finalización del contenedor de inicialización debido a la recolección de basura. Esto
se aplica a Kubernetes v1.20 y posteriores. Si estás utilizando una versión anterior de
Kubernetes, consulta la documentación de la versión que estás utilizando.</p><h2 id=siguientes-pasos>Siguientes pasos</h2><ul><li>Lee acerca de <a href=/docs/tasks/configure-pod-container/configure-pod-initialization/#create-a-pod-that-has-an-init-container>creando un Pod que tiene un contenedor de inicialización</a></li><li>Aprende cómo <a href=/docs/tasks/debug/debug-application/debug-init-containers/>depurar contenedores de inicialización</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4e9b9cbc9776b12e7335c53da377c9c8>3 - Pod Preset</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.6 [alpha]</code></div><p>Esta página provee una descripción general de los PodPresets, los cuales son
los objetos que se utilizan para inyectar cierta información en los Pods en
el momento de la creación. Esta información puede incluir secretos, volúmenes,
montajes de volúmenes y variables de entorno.</p><h2 id=entendiendo-los-pod-presets>Entendiendo los Pod Presets</h2><p>Un PodPreset es un recurso de la API utilizado para poder inyectar requerimientos
adicionales de tiempo de ejecución en un Pod en el momento de la creación.
Se utilizan los <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>selectores de etiquetas</a>
para especificar los Pods a los que se aplica un PodPreset determinado.</p><p>El uso de un PodPreset permite a los autores de plantillas de Pods no tener que proporcionar
explícitamente toda la información de cada Pod. De esta manera, los autores de plantillas de
Pods que consuman un determinado servicio no tendrán que conocer todos los detalles de ese servicio.</p><h2 id=habilitando-un-podpreset-en-su-clúster>Habilitando un PodPreset en su clúster</h2><p>Con el fin de utilizar los Pod Presets en un clúster debe asegurarse de lo siguiente:</p><ol><li><p>Que se ha configurado el tipo de API <code>settings.k8s.io/v1alpha1/podpreset</code>. Esto se puede hacer,
por ejemplo, incluyendo <code>settings.k8s.io/v1alpha1=true</code> como valor de la opción <code>--runtime-config</code>
en el servidor API. En minikube se debe añadir el flag
<code>--extra-config=apiserver.runtime-config=settings.k8s.io/v1alpha1=true</code> cuando el clúster
se está iniciando.</p></li><li><p>Que se ha habilitado el controlador de admisión <code>PodPreset</code>. Una forma de hacer esto es incluir
<code>PodPreset</code> como valor de la opción <code>--enable-admission-plugins</code> especificada
para el servidor API. En minikube se debe añadir el flag</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--extra-config<span style=color:#666>=</span>apiserver.enable-admission-plugins<span style=color:#666>=</span>NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset
</span></span></code></pre></div><p>cuando el clúster se está iniciando.</p></li></ol><h2 id=cómo-funciona>Cómo funciona</h2><p>Kubernetes provee un controlador de admisión (<code>PodPreset</code>) que, cuando está habilitado,
aplica los Pod Presets a las peticiones de creación de Pods entrantes.
Cuando se realiza una solicitud de creación de Pods, el sistema hace lo siguiente:</p><ol><li>Obtiene todos los <code>PodPresets</code> disponibles para usar.</li><li>Verifica si los selectores de etiquetas de cualquier <code>PodPreset</code> correspondan
con las etiquetas del Pod que se está creando.</li><li>Intenta fusionar los diversos recursos definidos por el <code>PodPreset</code> dentro del Pod
que se está creando.</li><li>Si se llegase a producir un error al intentar fusionar los recursos dentro del Pod,
lanza un evento que documente este error, luego crea el Pod <em>sin</em> ningún recurso que se
inyecte desde el <code>PodPreset</code>.</li><li>Escribe una nota descriptiva de la especificación de Pod modificada resultante para
indicar que ha sido modificada por un <code>PodPreset</code>. La nota descriptiva presenta la forma
<code>podpreset.admission.kubernetes.io/podpreset-&lt;pod-preset name>: "&lt;resource version>"</code>.</li></ol><p>Cada Pod puede ser correspondido por cero o más Pod Presets; y cada <code>PodPreset</code> puede ser
aplicado a cero o más Pods. Cuando se aplica un <code>PodPreset</code> a una o más Pods, Kubernetes
modifica la especificación del Pod. Para los cambios a <code>env</code>, <code>envFrom</code>, y <code>volumeMounts</code>,
Kubernetes modifica la especificación del Container para todos los Containers en el Pod;
para los cambios a <code>volumes</code>, Kubernetes modifica la especificación del Pod.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Un Pod Preset es capaz de modificar los siguientes campos en las especificaciones de un Pod
en caso de ser necesario:</p><ul><li>El campo <code>.spec.containers</code>.</li><li>El campo <code>.spec.initContainers</code></li></ul></div><h3 id=deshabilitar-un-pod-preset-para-un-pod-específico>Deshabilitar un Pod Preset para un Pod específico</h3><p>Puede haber casos en los que se desee que un Pod no se vea alterado por ninguna posible
modificación del Pod Preset. En estos casos, se puede añadir una observación en el Pod
<code>.spec</code> de la siguiente forma: <code>podpreset.admission.kubernetes.io/exclude: "true"</code>.</p><h2 id=siguientes-pasos>Siguientes pasos</h2><p>Ver <a href=/docs/tasks/inject-data-application/podpreset/>Inyectando datos en un Pod usando PodPreset</a></p><p>Para más información sobre los detalles de los trasfondos, consulte la <a href=https://git.k8s.io/design-proposals-archive/service-catalog/pod-preset.md>propuesta de diseño de PodPreset</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4aaf43c715cd764bc8ed4436f3537e68>4 - Interrupciones</h1><p>Esta guía es para los dueños de aplicaciones que quieren crear
aplicaciones con alta disponibilidad y que necesitan entender
que tipos de interrupciones pueden suceder en los Pods.</p><p>También es para los administradores de clústers que quieren aplicar acciones
automatizadas en sus clústers, cómo actualizar o autoescalar los clústers.</p><h2 id=interrupciones-voluntarias-e-involuntarias>Interrupciones voluntarias e involuntarias</h2><p>Los Pods no desaparecen hasta que algo (una persona o un controlador) los destruye
ó hay problemas de hardware ó software que son inevitables.</p><p>Nosotros llamamos a esos casos inevitables <em>interrupciones involuntarias</em> de
una aplicación. Algunos ejemplos:</p><ul><li>Una falla en hardware de la máquina física del nodo</li><li>Un administrador del clúster borra una VM (instancia) por error</li><li>El proveedor de la nube o el hipervisor falla y hace desaparecer la VM</li><li>Un kernel panic</li><li>El nodo desaparece del clúster por un problema de red que lo separa del clúster</li><li>Una remoción del Pod porque el nodo <a href=/docs/concepts/scheduling-eviction/node-pressure-eviction/>no tiene recursos suficientes</a>.</li></ul><p>A excepción de la condición sin recursos suficientes, todas estas condiciones
deben ser familiares para la mayoría de los usuarios, no son específicas
de Kubernetes</p><p>Nosotros llamamos a los otros casos <em>interrupciones voluntarias</em>. Estas incluyen
las acciones iniciadas por el dueño de la aplicación y aquellas iniciadas por el Administrador
del Clúster. Las acciones típicas de los dueños de la aplicación incluye:</p><ul><li>borrar el Deployment u otro controlador que maneja el Pod</li><li>actualizar el Deployment del Pod que causa un reinicio</li><li>borrar un Pod (por ejemplo, por accidente)</li></ul><p>Las acciones del administrador del clúster incluyen:</p><ul><li><a href=/docs/tasks/administer-cluster/safely-drain-node/>Drenar un nodo</a> para reparar o actualizar.</li><li>Drenar un nodo del clúster para reducir el clúster (aprenda acerca de <a href=https://github.com/kubernetes/autoscaler/#readme>Autoescalamiento de Clúster</a>
).</li><li>Remover un Pod de un nodo para permitir que otra cosa pueda ingresar a ese nodo.</li></ul><p>Estas acciones pueden ser realizadas directamente por el administrador del clúster, por
tareas automatizadas del administrador del clúster ó por el proveedor del clúster.</p><p>Consulte al administrador de su clúster, a su proveedor de la nube ó a la documentación de su distribución
para determinar si alguna de estas interrupciones voluntarias están habilitadas en su clúster.
Si ninguna se encuentra habilitada, puede omitir la creación del presupuesto de Interrupción de Pods.</p><div class="alert alert-warning caution callout" role=alert><strong>Precaución:</strong> No todas las interrupciones voluntarias son consideradas por el presupuesto de interrupción de Pods. Por ejemplo,
borrar un Deployment o Pods que evitan el uso del presupuesto.</div><h2 id=tratando-con-las-interrupciones>Tratando con las interrupciones</h2><p>Estas son algunas de las maneras para mitigar las interrupciones involuntarias:</p><ul><li>Asegurarse que el Pod <a href=/docs/tasks/configure-pod-container/assign-memory-resource>solicite los recursos</a> que necesita.</li><li>Replique su aplicación si usted necesita alta disponibilidad. (Aprenda sobre correr aplicaciones replicadas
<a href=/docs/tasks/run-application/run-stateless-application-deployment/>stateless</a>
y <a href=/docs/tasks/run-application/run-replicated-stateful-application/>stateful</a></li><li>Incluso, para una alta disponibilidad mayor cuando se corren aplicaciones replicadas,
propague las aplicaciones por varios racks (usando
<a href=/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>anti-affinity</a>)
o usando zonas (si usa un <a href=/docs/setup/multiple-zones>clúster multi-zona</a>.)</li></ul><p>La frecuencia de las interrupciones voluntarias varía. En un clúster basico de Kubernetes, no hay
interrupciones voluntarias automáticas (solo el usuario las genera). Sin embargo, su administrador del clúster o proveedor de alojamiento
puede correr algun servicio adicional que pueda causar estas interrupciones voluntarias. Por ejemplo,
desplegando una actualización de software en los nodos puede causar interrupciones. También, algunas implementaciones
de clústers con autoescalamiento de nodos puede causar interrupciones para defragmentar o compactar los nodos.
Su administrador de clúster o proveedor de alojamiento debe tener documentado cuál es el nivel de interrupciones
voluntarias esperadas, sí es que las hay. Ciertas opciones de configuración, como ser
<a href=/docs/concepts/scheduling-eviction/pod-priority-preemption/>usar PriorityClasses</a>
en las especificaciones de su Pod pueden también causar interrupciones voluntarias (o involuntarias).</p><h2 id=presupuesto-de-interrupción-de-pods>Presupuesto de Interrupción de Pods</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code></div><p>Kubernetes ofrece carácteristicas para ayudar a ejecutar aplicaciones con alta disponibliidad, incluso cuando usted
introduce interrupciones voluntarias frecuentes.</p><p>Como dueño de la aplicación, usted puede crear un presupuesto de interrupción de Pods (PDB por sus siglas en inglés) para cada aplicación.
Un PDB limita el numero de Pods de una aplicación replicada, que estan caídos de manera simultánea por
interrupciones voluntarias. Por ejemplo, una aplicación basada en quórum puede
asegurarse que el número de réplicas corriendo nunca es menor al
número necesitado para obtener el quórum. Una web de tipo front end puede querer
asegurarse que el número de réplicas atendiendo al tráfico nunca puede caer bajo un cierto
porcentaje del total.</p><p>Los administradores del clúster y proveedores de hosting pueden usar herramientas que
respeten el presupuesto de interrupción de Pods utilizando la <a href=/docs/tasks/administer-cl%C3%BAster/safely-drain-node/#eviction-api>API de Desalojo</a>
en vez de directamente borrar Pods o Deployments.</p><p>Por ejemplo, el subcomando <code>kubectl drain</code> le permite marcar un nodo a un modo fuera de
servicio. Cuando se ejecuta <code>kubectl drain</code>, la herramienta trata de quitar a todos los Pods en
el nodo que se esta dejando fuera de servicio. La petición de desalojo que <code>kubectl</code> solicita en
su nombre puede ser temporalmente denegado, entonces la herramienta periodicamente reintenta todas las
peticiones fallidas hasta que todos los Pods en el nodo afectado son terminados ó hasta que el tiempo de espera,
que puede ser configurado, es alcanzado.</p><p>Un PDB especifica el número de réplicas que una aplicación puede tolerar, relativo a cuantas
se pretende tener. Por ejemplo, un Deployment que tiene un <code>.spec.replicas: 5</code> se
supone que tiene 5 Pods en cualquier momento. Si su PDB permite tener 4 a la vez,
entonces la API de Desalojo va a permitir interrupciones voluntarias de un (pero no a dos) Pod a la vez.</p><p>El grupo de Pods que comprende a la aplicación esta especificada usando una etiqueta selectora, la misma
que es usada por el controlador de aplicación (deployment, stateful-set, etc).</p><p>El numero de Pods "deseado" es calculado a partir de <code>.spec.replicas</code> de el recurso de Workload
que es manejado para esos Pods. El plano de control descubre el recurso Workload perteneciente a el
examinando las <code>.metadata.ownerReferences</code> del Pod.</p><p>Las <a href=#voluntary-and-involuntary-disruptions>Interrupciones Involuntarias</a> no pueden ser prevenidas por los PDB; pero si
son contabilizadas a partir este presupuesto.</p><p>Los Pods que son borrados o no estan disponibles debido a una actualización continua de una aplicación forman parte del presupuesto de interrupciones, pero los recursos Workload (como los Deployments y StatefulSet)
no están limitados por los PDBs cuando se hacen actualizaciones continuas. En cambio, la administración de fallas
durante la actualización de la aplicación es configurada en la especificación para este recurso Workload específico.</p><p>Cuando un Pod es quitado usando la API de desalojo, este es
<a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>terminado</a> correctamente, haciendo honor al
<code>terminationGracePeriodSeconds</code> configurado en su <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>.</p><h2 id=pdb-example>Ejemplo de Presupuesto de Interrupción de POD</h2><p>Considere un clúster con 3 nodos, <code>nodo-1</code> hasta <code>nodo-3</code>.
El clúster esta corriendo varias aplicaciones. Uno de ellos tiene 3 replicas, que llamaremos
<code>pod-a</code>, <code>pod-b</code>, y <code>pod-c</code>. Otro Pod no relacionado y sin PDB, llamado <code>pod-x</code>, también se muestra.</p><p>Inicialmente los pods estan distribuidos de esta manera:</p><table><thead><tr><th style=text-align:center>nodo-1</th><th style=text-align:center>nodo-2</th><th style=text-align:center>nodo-3</th></tr></thead><tbody><tr><td style=text-align:center>pod-a <em>available</em></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center>pod-x <em>available</em></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>Los 3 Pods son parte de un Deployment, ellos colectivamente tienen un PDB que requiere
que por lo menos 2 de los 3 Pods esten disponibles todo el tiempo.</p><p>Por ejemplo, supongamos que el administrador del clúster quiere reiniciar para actualizar el kernel y arreglar un bug.
El administrador del clúster primero intenta desocupar el <code>nodo-1</code> usando el comando <code>kubectl drain</code>.
La herramienta intenta desalojar a los pods <code>pod-a</code> y <code>pod-x</code>. Esto tiene éxito inmediatamente.
Ambos Pods van al estado <code>terminating</code> al mismo tiempo.
Pone al clúster en el siguiente estado:</p><table><thead><tr><th style=text-align:center>nodo-1 <em>draining</em></th><th style=text-align:center>nodo-2</th><th style=text-align:center>nodo-3</th></tr></thead><tbody><tr><td style=text-align:center>pod-a <em>terminating</em></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center>pod-x <em>terminating</em></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>El Deployment detecta que uno de los Pods esta terminando, entonces crea un reemplazo
llamado <code>pod-d</code>. Como el <code>nodo-1</code> esta bloqueado, el pod termina en otro nodo. Algo más, adicionalmente
a creado el pod <code>pod-y</code> como un reemplazo del <code>pod-x</code> .</p><p>(Nota: para un StatefulSet, <code>pod-a</code>, el cual debería ser llamado algo como <code>pod-0</code>, necesitaría ser terminado completamente antes de su remplazo, el cual también es llamado <code>pod-0</code> pero tiene un UID diferente, podría ser creado. De lo contrario, el ejemplo también aplica a un StatefulSet.)</p><p>Ahora el clúster esta en este estado:</p><table><thead><tr><th style=text-align:center>nodo-1 <em>draining</em></th><th style=text-align:center>nodo-2</th><th style=text-align:center>nodo-3</th></tr></thead><tbody><tr><td style=text-align:center>pod-a <em>terminating</em></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center>pod-x <em>terminating</em></td><td style=text-align:center>pod-d <em>starting</em></td><td style=text-align:center>pod-y</td></tr></tbody></table><p>En algún punto, los Pods finalizan y el clúster se ve de esta forma:</p><table><thead><tr><th style=text-align:center>nodo-1 <em>drained</em></th><th style=text-align:center>nodo-2</th><th style=text-align:center>nodo-3</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>pod-d <em>starting</em></td><td style=text-align:center>pod-y</td></tr></tbody></table><p>En este estado, si un administrador del clúster impaciente intenta desalojar el <code>nodo-2</code> ó el
<code>nodo-3</code>, el comando drain va a ser bloqueado, porque hay solamente 2 Pods disponibles para
el Deployment y el PDB requiere por lo menos 2. Después de pasado un tiempo el <code>pod-d</code> esta disponible.</p><p>El estado del clúster ahora se ve así:</p><table><thead><tr><th style=text-align:center>nodo-1 <em>drained</em></th><th style=text-align:center>nodo-2</th><th style=text-align:center>nodo-3</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>pod-d <em>available</em></td><td style=text-align:center>pod-y</td></tr></tbody></table><p>Ahora, el administrador del clúster desaloja el <code>nodo-2</code>.
El comando drain tratará de desalojar a los 2 Pods con algún orden, digamos
primero el <code>pod-b</code> y después el <code>pod-d</code>. Va a tener éxito en quitar el <code>pod-b</code>.
Pero cuando intente desalojar al <code>pod-d</code>, va a ser rechazado porque esto va a dejar
un Pod solamente disponible para el Deployment.</p><p>El Deployment crea un reemplazo para el <code>pod-b</code> llamado <code>pod-e</code>.
Porque no hay recursos suficientes disponibles en el clúster para programar
el <code>pod-e</code> el desalojo será bloqueado nuevamente. El clúster va a terminar en este
estado:</p><table><thead><tr><th style=text-align:center>nodo-1 <em>drained</em></th><th style=text-align:center>nodo-2</th><th style=text-align:center>nodo-3</th><th style=text-align:center><em>no node</em></th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>pod-b <em>terminating</em></td><td style=text-align:center>pod-c <em>available</em></td><td style=text-align:center>pod-e <em>pending</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>pod-d <em>available</em></td><td style=text-align:center>pod-y</td><td style=text-align:center></td></tr></tbody></table><p>Ahora, el administrador del clúster necesita
agregar un nuevo nodo en el clúster para continuar con la actualización.</p><p>Usted puede ver como Kubernetes varia la tasa a la que las interrupciones
pueden suceder, en función de:</p><ul><li>cuantas réplicas una aplicación necesita</li><li>cuanto toma apagar una instancia de manera correcta</li><li>cuanto tiempo toma que una nueva instancia inicie</li><li>el tipo de controlador</li><li>la capacidad de recursos del clúster</li></ul><h2 id=separando-al-dueño-del-clúster-y-los-roles-de-dueños-de-la-aplicación>Separando al dueño del Clúster y los roles de dueños de la Aplicación</h2><p>Muchas veces es útil pensar en el Administrador del Clúster
y al dueño de la aplicación como roles separados con conocimiento limitado
el uno del otro. Esta separación de responsabilidades
puede tener sentido en estos escenarios:</p><ul><li>Cuando hay muchas equipos con aplicaciones compartiendo un clúster de Kubernetes y
hay una especialización natural de roles</li><li>Cuando una herramienta de terceros o servicio es usado para automatizar el control del clúster</li></ul><p>El presupuesto de interrupción de Pods soporta esta separación de roles, ofreciendo
una interfaz entre los roles.</p><p>Si no se tiene tal separación de responsabilidades en la organización,
posiblemente no se necesite el Presupuesto de Interrupción de Pods.</p><h2 id=como-realizar-acciones-disruptivas-en-el-clúster>Como realizar Acciones Disruptivas en el Clúster</h2><p>Si usted es el Administrador del Clúster y necesita realizar una acción disruptiva en todos
los nodos en el clúster, como ser una actualización de nodo o de software, estas son algunas de las opciones:</p><ul><li>Aceptar el tiempo sin funcionar mientras dura la actualización.</li><li>Conmutar a otra replica completa del clúster.<ul><li>No hay tiempo sin funcionar, pero puede ser costoso tener duplicados los nodos
y tambien un esfuerzo humano para orquestar dicho cambio.</li></ul></li><li>Escribir la toleracia a la falla de la aplicación y usar PDBs.<ul><li>No hay tiempo sin funcionar.</li><li>Duplicación de recursos mínimo.</li><li>Permite mucha más automatización de la administración del clúster.</li><li>Escribir aplicaciones que tengan tolerancia a fallas es complicado, pero el trabajo para tolerar interrupciones
involuntarias, largamente se sobrepone con el trabajo que es dar soporte a autoescalamientos y tolerar
interrupciones involuntarias.</li></ul></li></ul><h2 id=siguientes-pasos>Siguientes pasos</h2><ul><li><p>Siga los pasos para proteger su aplicación con <a href=/docs/tasks/run-application/configure-pdb/>configurar el Presupuesto de Interrupciones de Pods</a>.</p></li><li><p>Aprenda más sobre <a href=/docs/tasks/administer-cl%C3%BAster/safely-drain-node/>desalojar nodos</a></p></li><li><p>Aprenda sobre <a href=/docs/concepts/workloads/controllers/deployment/#updating-a-deployment>actualizar un Deployment</a>
incluyendo los pasos para mantener su disponibilidad mientras dura la actualización.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>5 - Containers Efímeros</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [alpha]</code></div><p>Esta página proporciona una descripción general de los Containers efímeros: un tipo especial de Container
que se ejecuta temporalmente en un <a class=glossary-tooltip title='El objeto más pequeño y simple de Kubernetes. Un Pod es la unidad mínima de computación en Kubernetes y representa uno o más contenedores ejecutándose en el clúster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> ya existente para cumplir las
acciones iniciadas por el usuario, como por ejemplo, la solución de problemas. En vez de ser utilizadas para
crear aplicaciones, los Containers efímeros se utilizan para examinar los servicios.</p><div class="alert alert-danger warning callout" role=alert><strong>Advertencia:</strong> Los Containers efímeros se encuentran en una fase alfa inicial y no son aptos para clústers
de producción. Es de esperar que esta característica no funcione en algunas situaciones, por
ejemplo, al seleccionar los Namespaces de un Container. De acuerdo con la <a href=/docs/reference/using-api/deprecation-policy/>Política de
Deprecación de Kubernetes</a>, esta característica
alfa puede variar significativamente en el futuro o ser eliminada por completo.</div><h2 id=entendiendo-los-containers-efímeros>Entendiendo los Containers efímeros</h2><p><a class=glossary-tooltip title='El objeto más pequeño y simple de Kubernetes. Un Pod es la unidad mínima de computación en Kubernetes y representa uno o más contenedores ejecutándose en el clúster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a> son el componente fundamental de las
aplicaciones de Kubernetes. Puesto que los Pods están previstos para ser desechables
y reemplazables, no se puede añadir un Container a un Pod una vez creado. Sin embargo, por lo
general se eliminan y se reemplazan los Pods de manera controlada utilizando
<a class=glossary-tooltip title='Un objeto API que gestiona una aplicación replicada.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployments>Deployments</a>.</p><p>En ocasiones es necesario examinar el estado de un Pod existente, como por ejemplo,
para poder solucionar un error difícil de reproducir. Puede ejecutar en estos casos
un Container efímero en un Pod ya existente para examinar su estado y para ejecutar
comandos de manera arbitraria.</p><h3 id=qué-es-un-container-efímero>Qué es un Container efímero?</h3><p>Los Containers efímeros se diferencian de otros Containers en que no garantizan ni los
recursos ni la ejecución, y en que nunca se reiniciarán automáticamente, de modo que no
son aptos para la construcción de aplicaciones. Los Containers efímeros se describen
usando la misma <a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>ContainerSpec</a> que los Containers regulares, aunque muchos campos son
incompatibles y no están habilitados para los Containers efímeros.</p><ul><li>Los Containers efímeros no pueden tener puertos, por lo que campos como <code>ports</code>,
<code>livenessProbe</code>, <code>readinessProbe</code> no están habilitados.</li><li>Las asignaciones de recursos del Pod son inmutables, por lo que no esta habilitado
configurar "resources".</li><li>Para obtener una lista completa de los campos habilitados, consulte la documentación
de referencia [EphemeralContainer] (/docs/reference/generated/kubernetes-api/v1.25/#ephemeralcontainer-v1-core).</li></ul><p>En vez de añadirlos de forma directa al <code>pod.spec</code>, los Containers efímeros se crean usando un
controlador especial de la API, <code>ephemeralcontainers</code>, por lo tanto no es posible añadir un
Container efímero utilizando <code>kubectl edit</code>.</p><p>Al igual en el caso de los Containers regulares, no se puede modificar o remover un Container
efímero después de haberlo agregado a un Pod.</p><h2 id=casos-de-uso-para-los-containers-efímeros>Casos de uso para los Containers efímeros</h2><p>Los Containers efímeros resultan útiles para la solución interactiva de incidencias cuando
<code>kubectl exec</code> es insuficiente tanto porque un container se ha caído, como porque la imagen de un
Container no incluye las utilidades de depuración.</p><p>En particular, las <a href=https://github.com/GoogleContainerTools/distroless>imágenes distroless</a>
le permiten desplegar imágenes de Containers mínimos que disminuyen la superficie de ataque
y la exposición a errores y vulnerabilidades. Ya que las imágenes distroless no contienen un
shell ni ninguna utilidad de depuración, resulta difícil solucionar los problemas de las imágenes
distroless usando solamente <code>kubectl exec</code>.</p><p>Cuando utilice Containers efímeros, es conveniente habilitar el <a href=/docs/tasks/configure-pod-container/share-process-namespace/>proceso Namespace de uso
compartido</a> para poder ver los
procesos en otros containers.</p><h3 id=ejemplos>Ejemplos</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Los ejemplos de esta sección requieren que los <code>EphemeralContainers</code> <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature
gate</a> estén habilitados
y que tanto el cliente como el servidor de Kubernetes tengan la version v1.16 o posterior.</div><p>En los ejemplos de esta sección muestran la forma en que los Containers efímeros se
presentan en la API. Los usuarios normalmente usarían un plugin <code>kubectl</code> para la solución
de problemas que automatizaría estos pasos.</p><p>Los Containers efímeros son creados utilizando el subrecurso <code>ephemeralcontainers</code> del Pod,
que puede ser visto utilizando <code>kubectl --raw</code>. En primer lugar describa el Container
efímero a añadir como una lista de <code>EphemeralContainers</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example-pod&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>: [{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>: <span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;stdin&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;tty&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>: <span style=color:#b44>&#34;File&#34;</span>
</span></span><span style=display:flex><span>    }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Para actualizar los Containers efímeros de los <code>example-pod</code> en ejecución:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace --raw /api/v1/namespaces/default/pods/example-pod/ephemeralcontainers  -f ec.json
</span></span></code></pre></div><p>Esto devolverá una nueva lista de Containers efímeros:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;example-pod&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>:<span style=color:#b44>&#34;/api/v1/namespaces/default/pods/example-pod/ephemeralcontainers&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;uid&#34;</span>:<span style=color:#b44>&#34;a14a6d9b-62f2-4119-9d8e-e2ed6bc3a47c&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>:<span style=color:#b44>&#34;15886&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>:<span style=color:#b44>&#34;2019-08-29T06:41:42Z&#34;</span>
</span></span><span style=display:flex><span>   },
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>:[
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;command&#34;</span>:[
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>         ],
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;resources&#34;</span>:{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         },
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>:<span style=color:#b44>&#34;File&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>:<span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;stdin&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;tty&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Se puede ver el estado del Container efímero creado usando <code>kubectl describe</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod example-pod
</span></span></code></pre></div><pre tabindex=0><code>...
Ephemeral Containers:
  debugger:
    Container ID:  docker://cf81908f149e7e9213d3c3644eda55c72efaff67652a2685c1146f0ce151e80f
    Image:         busybox
    Image ID:      docker-pullable://busybox@sha256:9f1003c480699be56815db0f8146ad2e22efea85129b5b5983d0e0fb52d9ab70
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Command:
      sh
    State:          Running
      Started:      Thu, 29 Aug 2019 06:42:21 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre><p>Se puede conectar al nuevo Container efímero usando <code>kubectl attach</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it example-pod -c debugger
</span></span></code></pre></div><p>Si el proceso Namespace de uso compartido está habilitado, se pueden visualizar los procesos de todos los Containers de ese Pod.
Por ejemplo, después de haber conectado, ejecute <code>ps</code> en el debugger del container:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps auxww
</span></span></code></pre></div><p>La respuesta es semejante a:</p><pre tabindex=0><code>PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    6 root      0:00 nginx: master process nginx -g daemon off;
   11 101       0:00 nginx: worker process
   12 101       0:00 nginx: worker process
   13 101       0:00 nginx: worker process
   14 101       0:00 nginx: worker process
   15 101       0:00 nginx: worker process
   16 101       0:00 nginx: worker process
   17 101       0:00 nginx: worker process
   18 101       0:00 nginx: worker process
   19 root      0:00 /pause
   24 root      0:00 sh
   29 root      0:00 ps auxww
</code></pre></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/es/docs/home/>Home</a>
<a class=text-white href=/es/blog/>Blog</a>
<a class=text-white href=/es/partners/>Partners</a>
<a class=text-white href=/es/community/>Comunidad</a>
<a class=text-white href=/es/case-studies/>Casos de éxito</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Los autores de Kubernetes | Documentación distribuida bajo <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Todos los derechos reservados. The Linux Foundation tiene marcas registradas y utiliza marcas registradas. Para obtener una lista de marcas registradas por The Linux Foundation, visita <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>