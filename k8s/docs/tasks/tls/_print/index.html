<!doctype html><html lang=en class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/tasks/tls/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/tls/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/tls/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/tls/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/tls/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/tls/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/tls/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/docs/tasks/tls/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>TLS | Kubernetes</title><meta property="og:title" content="TLS"><meta property="og:description" content="Understand how to protect traffic within your cluster using Transport Layer Security (TLS)."><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/docs/tasks/tls/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="TLS"><meta itemprop=description content="Understand how to protect traffic within your cluster using Transport Layer Security (TLS)."><meta name=twitter:card content="summary"><meta name=twitter:title content="TLS"><meta name=twitter:description content="Understand how to protect traffic within your cluster using Transport Layer Security (TLS)."><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Understand how to protect traffic within your cluster using Transport Layer Security (TLS)."><meta property="og:description" content="Understand how to protect traffic within your cluster using Transport Layer Security (TLS)."><meta name=twitter:description content="Understand how to protect traffic within your cluster using Transport Layer Security (TLS)."><meta property="og:url" content="https://kubernetes.io/docs/tasks/tls/"><meta property="og:title" content="TLS"><meta name=twitter:title content="TLS"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/docs/>Documentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/training/>Training</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/partners/>Partners</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/case-studies/>Case Studies</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/docs/tasks/tls/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/docs/tasks/tls/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/docs/tasks/tls/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/docs/tasks/tls/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/docs/tasks/tls/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>English</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/docs/tasks/tls/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/tasks/tls/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/tasks/tls/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/tasks/tls/>Français (French)</a>
<a class=dropdown-item href=/de/docs/tasks/tls/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/tasks/tls/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/tasks/tls/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/tasks/tls/>Return to the regular view of this page</a>.</p></div><h1 class=title>TLS</h1><div class=lead>Understand how to protect traffic within your cluster using Transport Layer Security (TLS).</div><ul><li>1: <a href=#pg-1272b18ac0c008f6ffc2c62a29fa929f>Configure Certificate Rotation for the Kubelet</a></li><li>2: <a href=#pg-9a87de8ee8332cb487f34a05debb1125>Manage TLS Certificates in a Cluster</a></li><li>3: <a href=#pg-43d5e2b1fc2a7e104e66d481d08578dc>Manual Rotation of CA Certificates</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-1272b18ac0c008f6ffc2c62a29fa929f>1 - Configure Certificate Rotation for the Kubelet</h1><p>This page shows how to enable and configure certificate rotation for the kubelet.</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code></div><h2 id=before-you-begin>Before you begin</h2><ul><li>Kubernetes version 1.8.0 or later is required</li></ul><h2 id=overview>Overview</h2><p>The kubelet uses certificates for authenticating to the Kubernetes API. By
default, these certificates are issued with one year expiration so that they do
not need to be renewed too frequently.</p><p>Kubernetes contains <a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>kubelet certificate
rotation</a>,
that will automatically generate a new key and request a new certificate from
the Kubernetes API as the current certificate approaches expiration. Once the
new certificate is available, it will be used for authenticating connections to
the Kubernetes API.</p><h2 id=enabling-client-certificate-rotation>Enabling client certificate rotation</h2><p>The <code>kubelet</code> process accepts an argument <code>--rotate-certificates</code> that controls
if the kubelet will automatically request a new certificate as the expiration of
the certificate currently in use approaches.</p><p>The <code>kube-controller-manager</code> process accepts an argument
<code>--cluster-signing-duration</code> (<code>--experimental-cluster-signing-duration</code> prior to 1.19)
that controls how long certificates will be issued for.</p><h2 id=understanding-the-certificate-rotation-configuration>Understanding the certificate rotation configuration</h2><p>When a kubelet starts up, if it is configured to bootstrap (using the
<code>--bootstrap-kubeconfig</code> flag), it will use its initial certificate to connect
to the Kubernetes API and issue a certificate signing request. You can view the
status of certificate signing requests using:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><p>Initially a certificate signing request from the kubelet on a node will have a
status of <code>Pending</code>. If the certificate signing requests meets specific
criteria, it will be auto approved by the controller manager, then it will have
a status of <code>Approved</code>. Next, the controller manager will sign a certificate,
issued for the duration specified by the
<code>--cluster-signing-duration</code> parameter, and the signed certificate
will be attached to the certificate signing request.</p><p>The kubelet will retrieve the signed certificate from the Kubernetes API and
write that to disk, in the location specified by <code>--cert-dir</code>. Then the kubelet
will use the new certificate to connect to the Kubernetes API.</p><p>As the expiration of the signed certificate approaches, the kubelet will
automatically issue a new certificate signing request, using the Kubernetes API.
This can happen at any point between 30% and 10% of the time remaining on the
certificate. Again, the controller manager will automatically approve the certificate
request and attach a signed certificate to the certificate signing request. The
kubelet will retrieve the new signed certificate from the Kubernetes API and
write that to disk. Then it will update the connections it has to the
Kubernetes API to reconnect using the new certificate.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9a87de8ee8332cb487f34a05debb1125>2 - Manage TLS Certificates in a Cluster</h1><p>Kubernetes provides a <code>certificates.k8s.io</code> API, which lets you provision TLS
certificates signed by a Certificate Authority (CA) that you control. These CA
and certificates can be used by your workloads to establish trust.</p><p><code>certificates.k8s.io</code> API uses a protocol that is similar to the <a href=https://github.com/ietf-wg-acme/acme/>ACME
draft</a>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Certificates created using the <code>certificates.k8s.io</code> API are signed by a
<a href=#configuring-your-cluster-to-provide-signing>dedicated CA</a>. It is possible to configure your cluster to use the cluster root
CA for this purpose, but you should never rely on this. Do not assume that
these certificates will validate against the cluster root CA.</div><h2 id=before-you-begin>Before you begin</h2><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>You need the <code>cfssl</code> tool. You can download <code>cfssl</code> from
<a href=https://github.com/cloudflare/cfssl/releases>https://github.com/cloudflare/cfssl/releases</a>.</p><p>Some steps in this page use the <code>jq</code> tool. If you don't have <code>jq</code>, you can
install it via your operating system's software sources, or fetch it from
<a href=https://stedolan.github.io/jq/>https://stedolan.github.io/jq/</a>.</p><h2 id=trusting-tls-in-a-cluster>Trusting TLS in a cluster</h2><p>Trusting the <a href=#configuring-your-cluster-to-provide-signing>custom CA</a> from an application running as a pod usually requires
some extra application configuration. You will need to add the CA certificate
bundle to the list of CA certificates that the TLS client or server trusts. For
example, you would do this with a golang TLS config by parsing the certificate
chain and adding the parsed certificates to the <code>RootCAs</code> field in the
<a href=https://pkg.go.dev/crypto/tls#Config><code>tls.Config</code></a> struct.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Even though the custom CA certificate may be included in the filesystem (in the
ConfigMap <code>kube-root-ca.crt</code>),
you should not use that certificate authority for any purpose other than to verify internal
Kubernetes endpoints. An example of an internal Kubernetes endpoint is the
Service named <code>kubernetes</code> in the default namespace.</p><p>If you want to use a custom certificate authority for your workloads, you should generate
that CA separately, and distribute its CA certificate using a
<a href=/docs/tasks/configure-pod-container/configure-pod-configmap>ConfigMap</a> that your pods
have access to read.</p></div><h2 id=requesting-a-certificate>Requesting a certificate</h2><p>The following section demonstrates how to create a TLS certificate for a
Kubernetes service accessed through DNS.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> This tutorial uses CFSSL: Cloudflare's PKI and TLS toolkit <a href=https://blog.cloudflare.com/introducing-cfssl/>click here</a> to know more.</div><h2 id=create-a-certificate-signing-request>Create a certificate signing request</h2><p>Generate a private key and certificate signing request (or CSR) by running
the following command:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | cfssl genkey - | cfssljson -bare server
</span></span></span><span style=display:flex><span><span style=color:#b44>{
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;hosts&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;my-svc.my-namespace.svc.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;192.0.2.24&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;10.0.34.2&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>  ],
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;CN&#34;: &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;key&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;algo&#34;: &#34;ecdsa&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;size&#34;: 256
</span></span></span><span style=display:flex><span><span style=color:#b44>  }
</span></span></span><span style=display:flex><span><span style=color:#b44>}
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Where <code>192.0.2.24</code> is the service's cluster IP,
<code>my-svc.my-namespace.svc.cluster.local</code> is the service's DNS name,
<code>10.0.34.2</code> is the pod's IP and <code>my-pod.my-namespace.pod.cluster.local</code>
is the pod's DNS name. You should see the output similar to:</p><pre tabindex=0><code>2022/02/01 11:45:32 [INFO] generate received request
2022/02/01 11:45:32 [INFO] received CSR
2022/02/01 11:45:32 [INFO] generating key: ecdsa-256
2022/02/01 11:45:32 [INFO] encoded CSR
</code></pre><p>This command generates two files; it generates <code>server.csr</code> containing the PEM
encoded <a href=https://tools.ietf.org/html/rfc2986>PKCS#10</a> certification request,
and <code>server-key.pem</code> containing the PEM encoded key to the certificate that
is still to be created.</p><h2 id=create-a-certificatesigningrequest-object-to-send-to-the-kubernetes-api>Create a CertificateSigningRequest object to send to the Kubernetes API</h2><p>Generate a CSR manifest (in YAML), and send it to the API server. You can do that by
running the following command:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: certificates.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: CertificateSigningRequest
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-svc.my-namespace
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  request: $(cat server.csr | base64 | tr -d &#39;\n&#39;)
</span></span></span><span style=display:flex><span><span style=color:#b44>  signerName: example.com/serving
</span></span></span><span style=display:flex><span><span style=color:#b44>  usages:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - digital signature
</span></span></span><span style=display:flex><span><span style=color:#b44>  - key encipherment
</span></span></span><span style=display:flex><span><span style=color:#b44>  - server auth
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Notice that the <code>server.csr</code> file created in step 1 is base64 encoded
and stashed in the <code>.spec.request</code> field. You are also requesting a
certificate with the "digital signature", "key encipherment", and "server
auth" key usages, signed by an example <code>example.com/serving</code> signer.
A specific <code>signerName</code> must be requested.
View documentation for <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#signers>supported signer names</a>
for more information.</p><p>The CSR should now be visible from the API in a Pending state. You can see
it by running:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe csr my-svc.my-namespace
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Name:                   my-svc.my-namespace
Labels:                 &lt;none&gt;
Annotations:            &lt;none&gt;
CreationTimestamp:      Tue, 01 Feb 2022 11:49:15 -0500
Requesting User:        yourname@example.com
Signer:                 example.com/serving
Status:                 Pending
Subject:
        Common Name:    my-pod.my-namespace.pod.cluster.local
        Serial Number:
Subject Alternative Names:
        DNS Names:      my-pod.my-namespace.pod.cluster.local
                        my-svc.my-namespace.svc.cluster.local
        IP Addresses:   192.0.2.24
                        10.0.34.2
Events: &lt;none&gt;
</code></pre><h2 id=get-the-certificate-signing-request-approved>Get the CertificateSigningRequest approved</h2><p>Approving the <a href=/docs/reference/access-authn-authz/certificate-signing-requests/>certificate signing request</a>
is either done by an automated approval process or on a one off basis by a cluster
administrator. If you're authorized to approve a certificate request, you can do that
manually using <code>kubectl</code>; for example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl certificate approve my-svc.my-namespace
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>certificatesigningrequest.certificates.k8s.io/my-svc.my-namespace approved
</code></pre><p>You should now see the following:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   10m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved
</code></pre><p>This means the certificate request has been approved and is waiting for the
requested signer to sign it.</p><h2 id=sign-the-certificate-signing-request>Sign the CertificateSigningRequest</h2><p>Next, you'll play the part of a certificate signer, issue the certificate, and upload it to the API.</p><p>A signer would typically watch the CertificateSigningRequest API for objects with its <code>signerName</code>,
check that they have been approved, sign certificates for those requests,
and update the API object status with the issued certificate.</p><h3 id=create-a-certificate-authority>Create a Certificate Authority</h3><p>You need an authority to provide the digital signature on the new certificate.</p><p>First, create a signing certificate by running the following:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | cfssl gencert -initca - | cfssljson -bare ca
</span></span></span><span style=display:flex><span><span style=color:#b44>{
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;CN&#34;: &#34;My Example Signer&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;key&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;algo&#34;: &#34;rsa&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;size&#34;: 2048
</span></span></span><span style=display:flex><span><span style=color:#b44>  }
</span></span></span><span style=display:flex><span><span style=color:#b44>}
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>You should see output similar to:</p><pre tabindex=0><code class=language-none data-lang=none>2022/02/01 11:50:39 [INFO] generating a new CA key and certificate from CSR
2022/02/01 11:50:39 [INFO] generate received request
2022/02/01 11:50:39 [INFO] received CSR
2022/02/01 11:50:39 [INFO] generating key: rsa-2048
2022/02/01 11:50:39 [INFO] encoded CSR
2022/02/01 11:50:39 [INFO] signed certificate with serial number 263983151013686720899716354349605500797834580472
</code></pre><p>This produces a certificate authority key file (<code>ca-key.pem</code>) and certificate (<code>ca.pem</code>).</p><h3 id=issue-a-certificate>Issue a certificate</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/tls/server-signing-config.json download=tls/server-signing-config.json><code>tls/server-signing-config.json</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("tls-server-signing-config-json")' title="Copy tls/server-signing-config.json to clipboard"></img></div><div class=includecode id=tls-server-signing-config-json><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;signing&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;default&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;usages&#34;</span>: [
</span></span><span style=display:flex><span>                <span style=color:#b44>&#34;digital signature&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#b44>&#34;key encipherment&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#b44>&#34;server auth&#34;</span>
</span></span><span style=display:flex><span>            ],
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;expiry&#34;</span>: <span style=color:#b44>&#34;876000h&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;ca_constraint&#34;</span>: {
</span></span><span style=display:flex><span>                <span style=color:green;font-weight:700>&#34;is_ca&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><p>Use a <code>server-signing-config.json</code> signing configuration and the certificate authority key file
and certificate to sign the certificate request:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr my-svc.my-namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.request}&#39;</span> | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  base64 --decode | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  cfssl sign -ca ca.pem -ca-key ca-key.pem -config server-signing-config.json - | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  cfssljson -bare ca-signed-server
</span></span></code></pre></div><p>You should see the output similar to:</p><pre tabindex=0><code>2022/02/01 11:52:26 [INFO] signed certificate with serial number 576048928624926584381415936700914530534472870337
</code></pre><p>This produces a signed serving certificate file, <code>ca-signed-server.pem</code>.</p><h3 id=upload-the-signed-certificate>Upload the signed certificate</h3><p>Finally, populate the signed certificate in the API object's status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr my-svc.my-namespace -o json | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  jq <span style=color:#b44>&#39;.status.certificate = &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>base64 ca-signed-server.pem | tr -d <span style=color:#b44>&#39;\n&#39;</span><span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34;&#39;</span> | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  kubectl replace --raw /apis/certificates.k8s.io/v1/certificatesigningrequests/my-svc.my-namespace/status -f -
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> This uses the command line tool <a href=https://stedolan.github.io/jq/><code>jq</code></a> to populate the base64-encoded
content in the <code>.status.certificate</code> field.
If you do not have <code>jq</code>, you can also save the JSON output to a file, populate this field manually, and
upload the resulting file.</div><p>Once the CSR is approved and the signed certificate is uploaded, run:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><p>The output is similar to:</p><pre tabindex=0><code class=language-none data-lang=none>NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   20m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved,Issued
</code></pre><h2 id=download-the-certificate-and-use-it>Download the certificate and use it</h2><p>Now, as the requesting user, you can download the issued certificate
and save it to a <code>server.crt</code> file by running the following:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr my-svc.my-namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.status.certificate}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    | base64 --decode &gt; server.crt
</span></span></code></pre></div><p>Now you can populate <code>server.crt</code> and <code>server-key.pem</code> in a
<a class=glossary-tooltip title='Stores sensitive information, such as passwords, OAuth tokens, and ssh keys.' data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>
that you could later mount into a Pod (for example, to use with a webserver
that serves HTTPS).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls server --cert server.crt --key server-key.pem
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>secret/server created
</code></pre><p>Finally, you can populate <code>ca.pem</code> into a <a class=glossary-tooltip title='An API object used to store non-confidential data in key-value pairs. Can be consumed as environment variables, command-line arguments, or configuration files in a volume.' data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>
and use it as the trust root to verify the serving certificate:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap example-serving-ca --from-file ca.crt<span style=color:#666>=</span>ca.pem
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>configmap/example-serving-ca created
</code></pre><h2 id=approving-certificate-signing-requests>Approving CertificateSigningRequests</h2><p>A Kubernetes administrator (with appropriate permissions) can manually approve
(or deny) CertificateSigningRequests by using the <code>kubectl certificate approve</code> and <code>kubectl certificate deny</code> commands. However if you intend
to make heavy usage of this API, you might consider writing an automated
certificates controller.</p><div class="alert alert-warning caution callout" role=alert><strong>Caution:</strong><p>The ability to approve CSRs decides who trusts whom within your environment. The
ability to approve CSRs should not be granted broadly or lightly.</p><p>You should make sure that you confidently understand both the verification requirements
that fall on the approver <strong>and</strong> the repercussions of issuing a specific certificate
before you grant the <code>approve</code> permission.</p></div><p>Whether a machine or a human using kubectl as above, the role of the <em>approver</em> is
to verify that the CSR satisfies two requirements:</p><ol><li>The subject of the CSR controls the private key used to sign the CSR. This
addresses the threat of a third party masquerading as an authorized subject.
In the above example, this step would be to verify that the pod controls the
private key used to generate the CSR.</li><li>The subject of the CSR is authorized to act in the requested context. This
addresses the threat of an undesired subject joining the cluster. In the
above example, this step would be to verify that the pod is allowed to
participate in the requested service.</li></ol><p>If and only if these two requirements are met, the approver should approve
the CSR and otherwise should deny the CSR.</p><p>For more information on certificate approval and access control, read
the <a href=/docs/reference/access-authn-authz/certificate-signing-requests/>Certificate Signing Requests</a>
reference page.</p><h2 id=configuring-your-cluster-to-provide-signing>Configuring your cluster to provide signing</h2><p>This page assumes that a signer is set up to serve the certificates API. The
Kubernetes controller manager provides a default implementation of a signer. To
enable it, pass the <code>--cluster-signing-cert-file</code> and
<code>--cluster-signing-key-file</code> parameters to the controller manager with paths to
your Certificate Authority's keypair.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-43d5e2b1fc2a7e104e66d481d08578dc>3 - Manual Rotation of CA Certificates</h1><p>This page shows how to manually rotate the certificate authority (CA) certificates.</p><h2 id=before-you-begin>Before you begin</h2><p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>
or you can use one of these Kubernetes playgrounds:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><ul><li>For more information about authentication in Kubernetes, see
<a href=/docs/reference/access-authn-authz/authentication>Authenticating</a>.</li><li>For more information about best practices for CA certificates, see
<a href=/docs/setup/best-practices/certificates/#single-root-ca>Single root CA</a>.</li></ul><h2 id=rotate-the-ca-certificates-manually>Rotate the CA certificates manually</h2><div class="alert alert-warning caution callout" role=alert><strong>Caution:</strong><p>Make sure to back up your certificate directory along with configuration files and any other necessary files.</p><p>This approach assumes operation of the Kubernetes control plane in a HA configuration with multiple API servers.
Graceful termination of the API server is also assumed so clients can cleanly disconnect from one API server and
reconnect to another.</p><p>Configurations with a single API server will experience unavailability while the API server is being restarted.</p></div><ol><li><p>Distribute the new CA certificates and private keys (for example: <code>ca.crt</code>, <code>ca.key</code>, <code>front-proxy-ca.crt</code>,
and <code>front-proxy-ca.key</code>) to all your control plane nodes in the Kubernetes certificates directory.</p></li><li><p>Update the <code>--root-ca-file</code> flag for the <a class=glossary-tooltip title='Control Plane component that runs controller processes.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> to include
both old and new CA, then restart the kube-controller-manager.</p><p>Any <a class=glossary-tooltip title='Provides an identity for processes that run in a Pod.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=ServiceAccount>ServiceAccount</a> created after this point will get
Secrets that include both old and new CAs.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>The files specified by the kube-controller-manager flags <code>--client-ca-file</code> and <code>--cluster-signing-cert-file</code>
cannot be CA bundles. If these flags and <code>--root-ca-file</code> point to the same <code>ca.crt</code> file which is now a
bundle (includes both old and new CA) you will face an error. To workaround this problem you can copy the new CA
to a separate file and make the flags <code>--client-ca-file</code> and <code>--cluster-signing-cert-file</code> point to the copy.
Once <code>ca.crt</code> is no longer a bundle you can restore the problem flags to point to <code>ca.crt</code> and delete the copy.</p><p><a href=https://github.com/kubernetes/kubeadm/issues/1350>Issue 1350</a> for kubeadm tracks an bug with the
kube-controller-manager being unable to accept a CA bundle.</p></div></li><li><p>Wait for the controller manager to update <code>ca.crt</code> in the service account Secrets to include both old and new CA certificates.</p><p>If any Pods are started before new CA is used by API servers, the new Pods get this update and will trust both
old and new CAs.</p></li><li><p>Restart all pods using in-cluster configurations (for example: kube-proxy, CoreDNS, etc) so they can use the
updated certificate authority data from Secrets that link to ServiceAccounts.</p><ul><li>Make sure CoreDNS, kube-proxy and other Pods using in-cluster configurations are working as expected.</li></ul></li><li><p>Append the both old and new CA to the file against <code>--client-ca-file</code> and <code>--kubelet-certificate-authority</code>
flag in the <code>kube-apiserver</code> configuration.</p></li><li><p>Append the both old and new CA to the file against <code>--client-ca-file</code> flag in the <code>kube-scheduler</code> configuration.</p></li><li><p>Update certificates for user accounts by replacing the content of <code>client-certificate-data</code> and <code>client-key-data</code>
respectively.</p><p>For information about creating certificates for individual user accounts, see
<a href=/docs/setup/best-practices/certificates/#configure-certificates-for-user-accounts>Configure certificates for user accounts</a>.</p><p>Additionally, update the <code>certificate-authority-data</code> section in the kubeconfig files,
respectively with Base64-encoded old and new certificate authority data</p></li><li><p>Update the <code>--root-ca-file</code> flag for the <a class=glossary-tooltip title='Control plane component that integrates Kubernetes with third-party cloud providers.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/cloud-controller/ target=_blank aria-label='Cloud Controller Manager'>Cloud Controller Manager</a> to include
both old and new CA, then restart the cloud-controller-manager.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> If your cluster does not have a cloud-controller-manager, you can skip this step.</div></li><li><p>Follow the steps below in a rolling fashion.</p><ol><li><p>Restart any other
<a href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>aggregated API servers</a> or
webhook handlers to trust the new CA certificates.</p></li><li><p>Restart the kubelet by update the file against <code>clientCAFile</code> in kubelet configuration and
<code>certificate-authority-data</code> in <code>kubelet.conf</code> to use both the old and new CA on all nodes.</p><p>If your kubelet is not using client certificate rotation, update <code>client-certificate-data</code> and
<code>client-key-data</code> in <code>kubelet.conf</code> on all nodes along with the kubelet client certificate file
usually found in <code>/var/lib/kubelet/pki</code>.</p></li><li><p>Restart API servers with the certificates (<code>apiserver.crt</code>, <code>apiserver-kubelet-client.crt</code> and
<code>front-proxy-client.crt</code>) signed by new CA.
You can use the existing private keys or new private keys.
If you changed the private keys then update these in the Kubernetes certificates directory as well.</p><p>Since the Pods in your cluster trust both old and new CAs, there will be a momentarily disconnection
after which pods' Kubernetes clients reconnect to the new API server.
The new API server uses a certificate signed by the new CA.</p><ul><li>Restart the <a class=glossary-tooltip title='Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a> to use and
trust the new CAs.</li><li>Make sure control plane components logs no TLS errors.</li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> To generate certificates and private keys for your cluster using the <code>openssl</code> command line tool,
see <a href=/docs/tasks/administer-cluster/certificates/#openssl>Certificates (<code>openssl</code>)</a>.
You can also use <a href=/docs/tasks/administer-cluster/certificates/#cfssl><code>cfssl</code></a>.</div></li><li><p>Annotate any DaemonSets and Deployments to trigger pod replacement in a safer rolling fashion.</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> namespace in <span style=color:#a2f;font-weight:700>$(</span>kubectl get namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> name in <span style=color:#a2f;font-weight:700>$(</span>kubectl get deployments -n <span style=color:#b8860b>$namespace</span> -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>        kubectl patch deployment -n <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>namespace</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>name</span><span style=color:#b68;font-weight:700>}</span> -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>done</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> name in <span style=color:#a2f;font-weight:700>$(</span>kubectl get daemonset -n <span style=color:#b8860b>$namespace</span> -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>        kubectl patch daemonset -n <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>namespace</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>name</span><span style=color:#b68;font-weight:700>}</span> -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>done</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> To limit the number of concurrent disruptions that your application experiences,
see <a href=/docs/tasks/run-application/configure-pdb/>configure pod disruption budget</a>.</div><pre><code> Depending on how you use StatefulSets you may also need to perform similar rolling replacement.
</code></pre></li><li><p>If your cluster is using bootstrap tokens to join nodes, update the ConfigMap <code>cluster-info</code> in the <code>kube-public</code>
namespace with new CA.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>base64 -w0 /etc/kubernetes/pki/ca.crt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl get cm/cluster-info --namespace kube-public -o yaml | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    /bin/sed <span style=color:#b44>&#34;s/\(certificate-authority-data:\).*/\1 </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/&#34;</span> | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    kubectl apply -f -
</span></span></code></pre></div></li><li><p>Verify the cluster functionality.</p><ol><li><p>Check the logs from control plane components, along with the kubelet and the kube-proxy.
Ensure those components are not reporting any TLS errors; see
<a href=/docs/tasks/debug/debug-cluster/#looking-at-logs>looking at the logs</a> for more details.</p></li><li><p>Validate logs from any aggregated api servers and pods using in-cluster config.</p></li></ol></li><li><p>Once the cluster functionality is successfully verified:</p><ol><li><p>Update all service account tokens to include new CA certificate only.</p><ul><li>All pods using an in-cluster kubeconfig will eventually need to be restarted to pick up the new Secret,
so that no Pods are relying on the old cluster CA.</li></ul></li><li><p>Restart the control plane components by removing the old CA from the kubeconfig files and the files against
<code>--client-ca-file</code>, <code>--root-ca-file</code> flags resp.</p></li><li><p>On each node, restart the kubelet by removing the old CA from file against the <code>clientCAFile</code> flag
and from the kubelet kubeconfig file. You should carry this out as a rolling update.</p><p>If your cluster lets you make this change, you can also roll it out by replacing nodes rather than
reconfiguring them.</p></li></ol></li></ol></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/docs/home/>Home</a>
<a class=text-white href=/blog/>Blog</a>
<a class=text-white href=/training/>Training</a>
<a class=text-white href=/partners/>Partners</a>
<a class=text-white href=/community/>Community</a>
<a class=text-white href=/case-studies/>Case Studies</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>