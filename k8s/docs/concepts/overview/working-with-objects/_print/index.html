<!doctype html><html lang=en class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/overview/working-with-objects/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/docs/concepts/overview/working-with-objects/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Working with Kubernetes Objects | Kubernetes</title><meta property="og:title" content="Working with Kubernetes Objects"><meta property="og:description" content="Kubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Learn about the Kubernetes object model and how to work with these objects.
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/docs/concepts/overview/working-with-objects/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Working with Kubernetes Objects"><meta itemprop=description content="Kubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Learn about the Kubernetes object model and how to work with these objects.
"><meta name=twitter:card content="summary"><meta name=twitter:title content="Working with Kubernetes Objects"><meta name=twitter:description content="Kubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Learn about the Kubernetes object model and how to work with these objects.
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Kubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Learn about the Kubernetes object model and how to work with these objects.
"><meta property="og:description" content="Kubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Learn about the Kubernetes object model and how to work with these objects.
"><meta name=twitter:description content="Kubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Learn about the Kubernetes object model and how to work with these objects.
"><meta property="og:url" content="https://kubernetes.io/docs/concepts/overview/working-with-objects/"><meta property="og:title" content="Working with Kubernetes Objects"><meta name=twitter:title content="Working with Kubernetes Objects"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/docs/>Documentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/training/>Training</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/partners/>Partners</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/case-studies/>Case Studies</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/docs/concepts/overview/working-with-objects/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/docs/concepts/overview/working-with-objects/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/docs/concepts/overview/working-with-objects/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/docs/concepts/overview/working-with-objects/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/docs/concepts/overview/working-with-objects/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>English</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/docs/concepts/overview/working-with-objects/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/overview/working-with-objects/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/overview/working-with-objects/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/overview/working-with-objects/>Français (French)</a>
<a class=dropdown-item href=/es/docs/concepts/overview/working-with-objects/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/overview/working-with-objects/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/overview/working-with-objects/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/concepts/overview/working-with-objects/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/concepts/overview/working-with-objects/>Return to the regular view of this page</a>.</p></div><h1 class=title>Working with Kubernetes Objects</h1><div class=lead>Kubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Learn about the Kubernetes object model and how to work with these objects.</div><ul><li>1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Understanding Kubernetes Objects</a></li><li>2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>Kubernetes Object Management</a></li><li>3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>Object Names and IDs</a></li><li>4: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>Labels and Selectors</a></li><li>5: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Namespaces</a></li><li>6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>Annotations</a></li><li>7: <a href=#pg-046c03090d47bc4b89b818dc645c3865>Field Selectors</a></li><li>8: <a href=#pg-13ce5627ef1dc8cbb4530ed231cb7d38>Finalizers</a></li><li>9: <a href=#pg-efaa7a58910b58892dafd50e3b43c93c>Owners and Dependents</a></li><li>10: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>Recommended Labels</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>1 - Understanding Kubernetes Objects</h1><p>This page explains how Kubernetes objects are represented in the Kubernetes API, and how you can
express them in <code>.yaml</code> format.</p><h2 id=kubernetes-objects>Understanding Kubernetes objects</h2><p><em>Kubernetes objects</em> are persistent entities in the Kubernetes system. Kubernetes uses these
entities to represent the state of your cluster. Specifically, they can describe:</p><ul><li>What containerized applications are running (and on which nodes)</li><li>The resources available to those applications</li><li>The policies around how those applications behave, such as restart policies, upgrades, and fault-tolerance</li></ul><p>A Kubernetes object is a "record of intent"--once you create the object, the Kubernetes system
will constantly work to ensure that object exists. By creating an object, you're effectively
telling the Kubernetes system what you want your cluster's workload to look like; this is your
cluster's <em>desired state</em>.</p><p>To work with Kubernetes objects--whether to create, modify, or delete them--you'll need to use the
<a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>. When you use the <code>kubectl</code> command-line
interface, for example, the CLI makes the necessary Kubernetes API calls for you. You can also use
the Kubernetes API directly in your own programs using one of the
<a href=/docs/reference/using-api/client-libraries/>Client Libraries</a>.</p><h3 id=object-spec-and-status>Object spec and status</h3><p>Almost every Kubernetes object includes two nested object fields that govern
the object's configuration: the object <em><code>spec</code></em> and the object <em><code>status</code></em>.
For objects that have a <code>spec</code>, you have to set this when you create the object,
providing a description of the characteristics you want the resource to have:
its <em>desired state</em>.</p><p>The <code>status</code> describes the <em>current state</em> of the object, supplied and updated
by the Kubernetes system and its components. The Kubernetes
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> continually
and actively manages every object's actual state to match the desired state you
supplied.</p><p>For example: in Kubernetes, a Deployment is an object that can represent an
application running on your cluster. When you create the Deployment, you
might set the Deployment <code>spec</code> to specify that you want three replicas of
the application to be running. The Kubernetes system reads the Deployment
spec and starts three instances of your desired application--updating
the status to match your spec. If any of those instances should fail
(a status change), the Kubernetes system responds to the difference
between spec and status by making a correction--in this case, starting
a replacement instance.</p><p>For more information on the object spec, status, and metadata, see the
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Kubernetes API Conventions</a>.</p><h3 id=describing-a-kubernetes-object>Describing a Kubernetes object</h3><p>When you create an object in Kubernetes, you must provide the object spec that describes its
desired state, as well as some basic information about the object (such as a name). When you use
the Kubernetes API to create the object (either directly or via <code>kubectl</code>), that API request must
include that information as JSON in the request body. <strong>Most often, you provide the information to
<code>kubectl</code> in a .yaml file.</strong> <code>kubectl</code> converts the information to JSON when making the API
request.</p><p>Here's an example <code>.yaml</code> file that shows the required fields and object spec for a Kubernetes Deployment:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>One way to create a Deployment using a <code>.yaml</code> file like the one above is to use the
<a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a> command
in the <code>kubectl</code> command-line interface, passing the <code>.yaml</code> file as an argument. Here's an example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex=0><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=required-fields>Required fields</h3><p>In the <code>.yaml</code> file for the Kubernetes object you want to create, you'll need to set values for the following fields:</p><ul><li><code>apiVersion</code> - Which version of the Kubernetes API you're using to create this object</li><li><code>kind</code> - What kind of object you want to create</li><li><code>metadata</code> - Data that helps uniquely identify the object, including a <code>name</code> string, <code>UID</code>, and optional <code>namespace</code></li><li><code>spec</code> - What state you desire for the object</li></ul><p>The precise format of the object <code>spec</code> is different for every Kubernetes object, and contains
nested fields specific to that object. The <a href=/docs/reference/kubernetes-api/>Kubernetes API Reference</a>
can help you find the spec format for all of the objects you can create using Kubernetes.</p><p>For example, see the <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec><code>spec</code> field</a>
for the Pod API reference.
For each Pod, the <code>.spec</code> field specifies the pod and its desired state (such as the container image name for
each container within that pod).
Another example of an object specification is the
<a href=/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec><code>spec</code> field</a>
for the StatefulSet API. For StatefulSet, the <code>.spec</code> field specifies the StatefulSet and
its desired state.
Within the <code>.spec</code> of a StatefulSet is a <a href=/docs/concepts/workloads/pods/#pod-templates>template</a>
for Pod objects. That template describes Pods that the StatefulSet controller will create in order to
satisfy the StatefulSet specification.
Different kinds of object can also have different <code>.status</code>; again, the API reference pages
detail the structure of that <code>.status</code> field, and its content for each different type of object.</p><h2 id=what-s-next>What's next</h2><p>Learn more about the following:</p><ul><li><a href=/docs/concepts/workloads/pods/>Pods</a> which are the most important basic Kubernetes objects.</li><li><a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a> objects.</li><li><a href=/docs/concepts/architecture/controller/>Controllers</a> in Kubernetes.</li><li><a href=/docs/reference/using-api/>Kubernetes API overview</a> which explains some more API concepts.</li><li><a href=/docs/reference/kubectl/>kubectl</a> and <a href=/docs/reference/generated/kubectl/kubectl-commands>kubectl commands</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6751db8ff5409476de8225d17d6c42dd>2 - Kubernetes Object Management</h1><p>The <code>kubectl</code> command-line tool supports several different ways to create and manage
Kubernetes objects. This document provides an overview of the different
approaches. Read the <a href=https://kubectl.docs.kubernetes.io>Kubectl book</a> for
details of managing objects by Kubectl.</p><h2 id=management-techniques>Management techniques</h2><div class="alert alert-danger warning callout" role=alert><strong>Warning:</strong> A Kubernetes object should be managed using only one technique. Mixing
and matching techniques for the same object results in undefined behavior.</div><table><thead><tr><th>Management technique</th><th>Operates on</th><th>Recommended environment</th><th>Supported writers</th><th>Learning curve</th></tr></thead><tbody><tr><td>Imperative commands</td><td>Live objects</td><td>Development projects</td><td>1+</td><td>Lowest</td></tr><tr><td>Imperative object configuration</td><td>Individual files</td><td>Production projects</td><td>1</td><td>Moderate</td></tr><tr><td>Declarative object configuration</td><td>Directories of files</td><td>Production projects</td><td>1+</td><td>Highest</td></tr></tbody></table><h2 id=imperative-commands>Imperative commands</h2><p>When using imperative commands, a user operates directly on live objects
in a cluster. The user provides operations to
the <code>kubectl</code> command as arguments or flags.</p><p>This is the recommended way to get started or to run a one-off task in
a cluster. Because this technique operates directly on live
objects, it provides no history of previous configurations.</p><h3 id=examples>Examples</h3><p>Run an instance of the nginx container by creating a Deployment object:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id=trade-offs>Trade-offs</h3><p>Advantages compared to object configuration:</p><ul><li>Commands are expressed as a single action word.</li><li>Commands require only a single step to make changes to the cluster.</li></ul><p>Disadvantages compared to object configuration:</p><ul><li>Commands do not integrate with change review processes.</li><li>Commands do not provide an audit trail associated with changes.</li><li>Commands do not provide a source of records except for what is live.</li><li>Commands do not provide a template for creating new objects.</li></ul><h2 id=imperative-object-configuration>Imperative object configuration</h2><p>In imperative object configuration, the kubectl command specifies the
operation (create, replace, etc.), optional flags and at least one file
name. The file specified must contain a full definition of the object
in YAML or JSON format.</p><p>See the <a href=/docs/reference/generated/kubernetes-api/v1.25/>API reference</a>
for more details on object definitions.</p><div class="alert alert-danger warning callout" role=alert><strong>Warning:</strong> The imperative <code>replace</code> command replaces the existing
spec with the newly provided one, dropping all changes to the object missing from
the configuration file. This approach should not be used with resource
types whose specs are updated independently of the configuration file.
Services of type <code>LoadBalancer</code>, for example, have their <code>externalIPs</code> field updated
independently from the configuration by the cluster.</div><h3 id=examples-1>Examples</h3><p>Create the objects defined in a configuration file:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>Delete the objects defined in two configuration files:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>Update the objects defined in a configuration file by overwriting
the live configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id=trade-offs-1>Trade-offs</h3><p>Advantages compared to imperative commands:</p><ul><li>Object configuration can be stored in a source control system such as Git.</li><li>Object configuration can integrate with processes such as reviewing changes before push and audit trails.</li><li>Object configuration provides a template for creating new objects.</li></ul><p>Disadvantages compared to imperative commands:</p><ul><li>Object configuration requires basic understanding of the object schema.</li><li>Object configuration requires the additional step of writing a YAML file.</li></ul><p>Advantages compared to declarative object configuration:</p><ul><li>Imperative object configuration behavior is simpler and easier to understand.</li><li>As of Kubernetes version 1.5, imperative object configuration is more mature.</li></ul><p>Disadvantages compared to declarative object configuration:</p><ul><li>Imperative object configuration works best on files, not directories.</li><li>Updates to live objects must be reflected in configuration files, or they will be lost during the next replacement.</li></ul><h2 id=declarative-object-configuration>Declarative object configuration</h2><p>When using declarative object configuration, a user operates on object
configuration files stored locally, however the user does not define the
operations to be taken on the files. Create, update, and delete operations
are automatically detected per-object by <code>kubectl</code>. This enables working on
directories, where different operations might be needed for different objects.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Declarative object configuration retains changes made by other
writers, even if the changes are not merged back to the object configuration file.
This is possible by using the <code>patch</code> API operation to write only
observed differences, instead of using the <code>replace</code>
API operation to replace the entire object configuration.</div><h3 id=examples-2>Examples</h3><p>Process all object configuration files in the <code>configs</code> directory, and create or
patch the live objects. You can first <code>diff</code> to see what changes are going to be
made, and then apply:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -f configs/
</span></span><span style=display:flex><span>kubectl apply -f configs/
</span></span></code></pre></div><p>Recursively process directories:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -R -f configs/
</span></span><span style=display:flex><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id=trade-offs-2>Trade-offs</h3><p>Advantages compared to imperative object configuration:</p><ul><li>Changes made directly to live objects are retained, even if they are not merged back into the configuration files.</li><li>Declarative object configuration has better support for operating on directories and automatically detecting operation types (create, patch, delete) per-object.</li></ul><p>Disadvantages compared to imperative object configuration:</p><ul><li>Declarative object configuration is harder to debug and understand results when they are unexpected.</li><li>Partial updates using diffs create complex merge and patch operations.</li></ul><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-command/>Managing Kubernetes Objects Using Imperative Commands</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-config/>Imperative Management of Kubernetes Objects Using Configuration Files</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/declarative-config/>Declarative Management of Kubernetes Objects Using Configuration Files</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Declarative Management of Kubernetes Objects Using Kustomize</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl Command Reference</a></li><li><a href=https://kubectl.docs.kubernetes.io>Kubectl Book</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Kubernetes API Reference</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>3 - Object Names and IDs</h1><p>Each object in your cluster has a <a href=#names><em>Name</em></a> that is unique for that type of resource.
Every Kubernetes object also has a <a href=#uids><em>UID</em></a> that is unique across your whole cluster.</p><p>For example, you can only have one Pod named <code>myapp-1234</code> within the same <a href=/docs/concepts/overview/working-with-objects/namespaces/>namespace</a>, but you can have one Pod and one Deployment that are each named <code>myapp-1234</code>.</p><p>For non-unique user-provided attributes, Kubernetes provides <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> and <a href=/docs/concepts/overview/working-with-objects/annotations/>annotations</a>.</p><h2 id=names>Names</h2><p>A client-provided string that refers to an object in a resource URL, such as <code>/api/v1/pods/some-name</code>.</p><p>Only one object of a given kind can have a given name at a time. However, if you delete the object, you can make a new object with the same name.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> In cases when objects represent a physical entity, like a Node representing a physical host, when the host is re-created under the same name without deleting and re-creating the Node, Kubernetes treats the new host as the old one, which may lead to inconsistencies.</div><p>Below are four types of commonly used name constraints for resources.</p><h3 id=dns-subdomain-names>DNS Subdomain Names</h3><p>Most resource types require a name that can be used as a DNS subdomain name
as defined in <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>.
This means the name must:</p><ul><li>contain no more than 253 characters</li><li>contain only lowercase alphanumeric characters, '-' or '.'</li><li>start with an alphanumeric character</li><li>end with an alphanumeric character</li></ul><h3 id=dns-label-names>RFC 1123 Label Names</h3><p>Some resource types require their names to follow the DNS
label standard as defined in <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>.
This means the name must:</p><ul><li>contain at most 63 characters</li><li>contain only lowercase alphanumeric characters or '-'</li><li>start with an alphanumeric character</li><li>end with an alphanumeric character</li></ul><h3 id=rfc-1035-label-names>RFC 1035 Label Names</h3><p>Some resource types require their names to follow the DNS
label standard as defined in <a href=https://tools.ietf.org/html/rfc1035>RFC 1035</a>.
This means the name must:</p><ul><li>contain at most 63 characters</li><li>contain only lowercase alphanumeric characters or '-'</li><li>start with an alphabetic character</li><li>end with an alphanumeric character</li></ul><h3 id=path-segment-names>Path Segment Names</h3><p>Some resource types require their names to be able to be safely encoded as a
path segment. In other words, the name may not be "." or ".." and the name may
not contain "/" or "%".</p><p>Here's an example manifest for a Pod named <code>nginx-demo</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Some resource types have additional restrictions on their names.</div><h2 id=uids>UIDs</h2><p>A Kubernetes systems-generated string to uniquely identify objects.</p><p>Every object created over the whole lifetime of a Kubernetes cluster has a distinct UID. It is intended to distinguish between historical occurrences of similar entities.</p><p>Kubernetes UIDs are universally unique identifiers (also known as UUIDs).
UUIDs are standardized as ISO/IEC 9834-8 and as ITU-T X.667.</p><h2 id=what-s-next>What's next</h2><ul><li>Read about <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> and <a href=/docs/concepts/overview/working-with-objects/annotations/>annotations</a> in Kubernetes.</li><li>See the <a href=https://git.k8s.io/design-proposals-archive/architecture/identifiers.md>Identifiers and Names in Kubernetes</a> design document.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>4 - Labels and Selectors</h1><p><em>Labels</em> are key/value pairs that are attached to objects, such as pods.
Labels are intended to be used to specify identifying attributes of objects that are meaningful and relevant to users, but do not directly imply semantics to the core system.
Labels can be used to organize and to select subsets of objects. Labels can be attached to objects at creation time and subsequently added and modified at any time.
Each object can have a set of key/value labels defined. Each Key must be unique for a given object.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Labels allow for efficient queries and watches and are ideal for use in UIs
and CLIs. Non-identifying information should be recorded using
<a href=/docs/concepts/overview/working-with-objects/annotations/>annotations</a>.</p><h2 id=motivation>Motivation</h2><p>Labels enable users to map their own organizational structures onto system objects in a loosely coupled fashion, without requiring clients to store these mappings.</p><p>Service deployments and batch processing pipelines are often multi-dimensional entities (e.g., multiple partitions or deployments, multiple release tracks, multiple tiers, multiple micro-services per tier). Management often requires cross-cutting operations, which breaks encapsulation of strictly hierarchical representations, especially rigid hierarchies determined by the infrastructure rather than by users.</p><p>Example labels:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>These are examples of <a href=/docs/concepts/overview/working-with-objects/common-labels/>commonly used labels</a>; you are free to develop your own conventions. Keep in mind that label Key must be unique for a given object.</p><h2 id=syntax-and-character-set>Syntax and character set</h2><p><em>Labels</em> are key/value pairs. Valid label keys have two segments: an optional prefix and name, separated by a slash (<code>/</code>). The name segment is required and must be 63 characters or less, beginning and ending with an alphanumeric character (<code>[a-z0-9A-Z]</code>) with dashes (<code>-</code>), underscores (<code>_</code>), dots (<code>.</code>), and alphanumerics between. The prefix is optional. If specified, the prefix must be a DNS subdomain: a series of DNS labels separated by dots (<code>.</code>), not longer than 253 characters in total, followed by a slash (<code>/</code>).</p><p>If the prefix is omitted, the label Key is presumed to be private to the user. Automated system components (e.g. <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, or other third-party automation) which add labels to end-user objects must specify a prefix.</p><p>The <code>kubernetes.io/</code> and <code>k8s.io/</code> prefixes are <a href=/docs/reference/labels-annotations-taints/>reserved</a> for Kubernetes core components.</p><p>Valid label value:</p><ul><li>must be 63 characters or less (can be empty),</li><li>unless empty, must begin and end with an alphanumeric character (<code>[a-z0-9A-Z]</code>),</li><li>could contain dashes (<code>-</code>), underscores (<code>_</code>), dots (<code>.</code>), and alphanumerics between.</li></ul><p>For example, here's the configuration file for a Pod that has two labels <code>environment: production</code> and <code>app: nginx</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=label-selectors>Label selectors</h2><p>Unlike <a href=/docs/concepts/overview/working-with-objects/names/>names and UIDs</a>, labels do not provide uniqueness. In general, we expect many objects to carry the same label(s).</p><p>Via a <em>label selector</em>, the client/user can identify a set of objects. The label selector is the core grouping primitive in Kubernetes.</p><p>The API currently supports two types of selectors: <em>equality-based</em> and <em>set-based</em>.
A label selector can be made of multiple <em>requirements</em> which are comma-separated. In the case of multiple requirements, all must be satisfied so the comma separator acts as a logical <em>AND</em> (<code>&&</code>) operator.</p><p>The semantics of empty or non-specified selectors are dependent on the context,
and API types that use selectors should document the validity and meaning of
them.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> For some API types, such as ReplicaSets, the label selectors of two instances must not overlap within a namespace, or the controller can see that as conflicting instructions and fail to determine how many replicas should be present.</div><div class="alert alert-warning caution callout" role=alert><strong>Caution:</strong> For both equality-based and set-based conditions there is no logical <em>OR</em> (<code>||</code>) operator. Ensure your filter statements are structured accordingly.</div><h3 id=equality-based-requirement><em>Equality-based</em> requirement</h3><p><em>Equality-</em> or <em>inequality-based</em> requirements allow filtering by label keys and values. Matching objects must satisfy all of the specified label constraints, though they may have additional labels as well.
Three kinds of operators are admitted <code>=</code>,<code>==</code>,<code>!=</code>. The first two represent <em>equality</em> (and are synonyms), while the latter represents <em>inequality</em>. For example:</p><pre tabindex=0><code>environment = production
tier != frontend
</code></pre><p>The former selects all resources with key equal to <code>environment</code> and value equal to <code>production</code>.
The latter selects all resources with key equal to <code>tier</code> and value distinct from <code>frontend</code>, and all resources with no labels with the <code>tier</code> key.
One could filter for resources in <code>production</code> excluding <code>frontend</code> using the comma operator: <code>environment=production,tier!=frontend</code></p><p>One usage scenario for equality-based label requirement is for Pods to specify
node selection criteria. For example, the sample Pod below selects nodes with
the label "<code>accelerator=nvidia-tesla-p100</code>".</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;registry.k8s.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=set-based-requirement><em>Set-based</em> requirement</h3><p><em>Set-based</em> label requirements allow filtering keys according to a set of values. Three kinds of operators are supported: <code>in</code>,<code>notin</code> and <code>exists</code> (only the key identifier). For example:</p><pre tabindex=0><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><ul><li>The first example selects all resources with key equal to <code>environment</code> and value equal to <code>production</code> or <code>qa</code>.</li><li>The second example selects all resources with key equal to <code>tier</code> and values other than <code>frontend</code> and <code>backend</code>, and all resources with no labels with the <code>tier</code> key.</li><li>The third example selects all resources including a label with key <code>partition</code>; no values are checked.</li><li>The fourth example selects all resources without a label with key <code>partition</code>; no values are checked.</li></ul><p>Similarly the comma separator acts as an <em>AND</em> operator. So filtering resources with a <code>partition</code> key (no matter the value) and with <code>environment</code> different than  <code>qa</code> can be achieved using <code>partition,environment notin (qa)</code>.
The <em>set-based</em> label selector is a general form of equality since <code>environment=production</code> is equivalent to <code>environment in (production)</code>; similarly for <code>!=</code> and <code>notin</code>.</p><p><em>Set-based</em> requirements can be mixed with <em>equality-based</em> requirements. For example: <code>partition in (customerA, customerB),environment!=qa</code>.</p><h2 id=api>API</h2><h3 id=list-and-watch-filtering>LIST and WATCH filtering</h3><p>LIST and WATCH operations may specify label selectors to filter the sets of objects returned using a query parameter. Both requirements are permitted (presented here as they would appear in a URL query string):</p><ul><li><em>equality-based</em> requirements: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li><em>set-based</em> requirements: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>Both label selector styles can be used to list or watch resources via a REST client. For example, targeting <code>apiserver</code> with <code>kubectl</code> and using <em>equality-based</em> one may write:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>or using <em>set-based</em> requirements:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</span></span></code></pre></div><p>As already mentioned <em>set-based</em> requirements are more expressive.  For instance, they can implement the <em>OR</em> operator on values:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</span></span></code></pre></div><p>or restricting negative matching via <em>exists</em> operator:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</span></span></code></pre></div><h3 id=set-references-in-api-objects>Set references in API objects</h3><p>Some Kubernetes objects, such as <a href=/docs/concepts/services-networking/service/><code>services</code></a>
and <a href=/docs/concepts/workloads/controllers/replicationcontroller/><code>replicationcontrollers</code></a>,
also use label selectors to specify sets of other resources, such as
<a href=/docs/concepts/workloads/pods/>pods</a>.</p><h4 id=service-and-replicationcontroller>Service and ReplicationController</h4><p>The set of pods that a <code>service</code> targets is defined with a label selector. Similarly, the population of pods that a <code>replicationcontroller</code> should manage is also defined with a label selector.</p><p>Labels selectors for both objects are defined in <code>json</code> or <code>yaml</code> files using maps, and only <em>equality-based</em> requirement selectors are supported:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>or</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div><p>this selector (respectively in <code>json</code> or <code>yaml</code> format) is equivalent to <code>component=redis</code> or <code>component in (redis)</code>.</p><h4 id=resources-that-support-set-based-requirements>Resources that support set-based requirements</h4><p>Newer resources, such as <a href=/docs/concepts/workloads/controllers/job/><code>Job</code></a>,
<a href=/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>,
<a href=/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>, and
<a href=/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>,
support <em>set-based</em> requirements as well.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>matchLabels</code> is a map of <code>{key,value}</code> pairs. A single <code>{key,value}</code> in the <code>matchLabels</code> map is equivalent to an element of <code>matchExpressions</code>, whose <code>key</code> field is "key", the <code>operator</code> is "In", and the <code>values</code> array contains only "value". <code>matchExpressions</code> is a list of pod selector requirements. Valid operators include In, NotIn, Exists, and DoesNotExist. The values set must be non-empty in the case of In and NotIn. All of the requirements, from both <code>matchLabels</code> and <code>matchExpressions</code> are ANDed together -- they must all be satisfied in order to match.</p><h4 id=selecting-sets-of-nodes>Selecting sets of nodes</h4><p>One use case for selecting over labels is to constrain the set of nodes onto which a pod can schedule.
See the documentation on <a href=/docs/concepts/scheduling-eviction/assign-pod-node/>node selection</a> for more information.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>5 - Namespaces</h1><p>In Kubernetes, <em>namespaces</em> provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects <em>(e.g. Deployments, Services, etc)</em> and not for cluster-wide objects <em>(e.g. StorageClass, Nodes, PersistentVolumes, etc)</em>.</p><h2 id=when-to-use-multiple-namespaces>When to Use Multiple Namespaces</h2><p>Namespaces are intended for use in environments with many users spread across multiple
teams, or projects. For clusters with a few to tens of users, you should not
need to create or think about namespaces at all. Start using namespaces when you
need the features they provide.</p><p>Namespaces provide a scope for names. Names of resources need to be unique within a namespace,
but not across namespaces. Namespaces cannot be nested inside one another and each Kubernetes
resource can only be in one namespace.</p><p>Namespaces are a way to divide cluster resources between multiple users (via <a href=/docs/concepts/policy/resource-quotas/>resource quota</a>).</p><p>It is not necessary to use multiple namespaces to separate slightly different
resources, such as different versions of the same software: use
<a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a> to distinguish
resources within the same namespace.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> For a production cluster, consider <em>not</em> using the <code>default</code> namespace. Instead, make other namespaces and use those.</div><h2 id=initial-namespaces>Initial namespaces</h2><p>Kubernetes starts with four initial namespaces:</p><dl><dt><code>default</code></dt><dd>Kubernetes includes this namespace so that you can start using your new cluster without first creating a namespace.</dd><dt><code>kube-node-lease</code></dt><dd>This namespace holds <a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>Lease</a> objects associated with each node. Node leases allow the kubelet to send <a href=/docs/concepts/architecture/nodes/#heartbeats>heartbeats</a> so that the control plane can detect node failure.</dd><dt><code>kube-public</code></dt><dd>This namespace is readable by <em>all</em> clients (including those not authenticated). This namespace is mostly reserved for cluster usage, in case that some resources should be visible and readable publicly throughout the whole cluster. The public aspect of this namespace is only a convention, not a requirement.</dd><dt><code>kube-system</code></dt><dd>The namespace for objects created by the Kubernetes system.</dd></dl><h2 id=working-with-namespaces>Working with Namespaces</h2><p>Creation and deletion of namespaces are described in the
<a href=/docs/tasks/administer-cluster/namespaces>Admin Guide documentation for namespaces</a>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Avoid creating namespaces with the prefix <code>kube-</code>, since it is reserved for Kubernetes system namespaces.</div><h3 id=viewing-namespaces>Viewing namespaces</h3><p>You can list the current namespaces in a cluster using:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
</code></pre><h3 id=setting-the-namespace-for-a-request>Setting the namespace for a request</h3><p>To set the namespace for a current request, use the <code>--namespace</code> flag.</p><p>For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id=setting-the-namespace-preference>Setting the namespace preference</h3><p>You can permanently save the namespace for all subsequent kubectl commands in that
context.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Validate it</span>
</span></span><span style=display:flex><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id=namespaces-and-dns>Namespaces and DNS</h2><p>When you create a <a href=/docs/concepts/services-networking/service/>Service</a>,
it creates a corresponding <a href=/docs/concepts/services-networking/dns-pod-service/>DNS entry</a>.
This entry is of the form <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code>, which means
that if a container only uses <code>&lt;service-name></code>, it will resolve to the service which
is local to a namespace. This is useful for using the same configuration across
multiple namespaces such as Development, Staging and Production. If you want to reach
across namespaces, you need to use the fully qualified domain name (FQDN).</p><p>As a result, all namespace names must be valid
<a href=/docs/concepts/overview/working-with-objects/names/#dns-label-names>RFC 1123 DNS labels</a>.</p><div class="alert alert-danger warning callout" role=alert><strong>Warning:</strong><p>By creating namespaces with the same name as <a href=https://data.iana.org/TLD/tlds-alpha-by-domain.txt>public top-level
domains</a>, Services in these
namespaces can have short DNS names that overlap with public DNS records.
Workloads from any namespace performing a DNS lookup without a <a href=https://datatracker.ietf.org/doc/html/rfc1034#page-8>trailing dot</a> will
be redirected to those services, taking precedence over public DNS.</p><p>To mitigate this, limit privileges for creating namespaces to trusted users. If
required, you could additionally configure third-party security controls, such
as <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>admission
webhooks</a>,
to block creating any namespace with the name of <a href=https://data.iana.org/TLD/tlds-alpha-by-domain.txt>public
TLDs</a>.</p></div><h2 id=not-all-objects-are-in-a-namespace>Not all objects are in a namespace</h2><p>Most Kubernetes resources (e.g. pods, services, replication controllers, and others) are
in some namespaces. However namespace resources are not themselves in a namespace.
And low-level resources, such as
<a href=/docs/concepts/architecture/nodes/>nodes</a> and
<a href=/docs/concepts/storage/persistent-volumes/>persistentVolumes</a>, are not in any namespace.</p><p>To see which Kubernetes resources are and aren't in a namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># In a namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Not in a namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h2 id=automatic-labelling>Automatic labelling</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.21 [beta]</code></div><p>The Kubernetes control plane sets an immutable <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=label>label</a>
<code>kubernetes.io/metadata.name</code> on all namespaces, provided that the <code>NamespaceDefaultLabelName</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> is enabled.
The value of the label is the namespace name.</p><h2 id=what-s-next>What's next</h2><ul><li>Learn more about <a href=/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace>creating a new namespace</a>.</li><li>Learn more about <a href=/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace>deleting a namespace</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>6 - Annotations</h1><p>You can use Kubernetes annotations to attach arbitrary non-identifying metadata
to objects. Clients such as tools and libraries can retrieve this metadata.</p><h2 id=attaching-metadata-to-objects>Attaching metadata to objects</h2><p>You can use either labels or annotations to attach metadata to Kubernetes
objects. Labels can be used to select objects and to find
collections of objects that satisfy certain conditions. In contrast, annotations
are not used to identify and select objects. The metadata
in an annotation can be small or large, structured or unstructured, and can
include characters not permitted by labels.</p><p>Annotations, like labels, are key/value maps:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> The keys and the values in the map must be strings. In other words, you cannot use
numeric, boolean, list or other types for either the keys or the values.</div><p>Here are some examples of information that could be recorded in annotations:</p><ul><li><p>Fields managed by a declarative configuration layer. Attaching these fields
as annotations distinguishes them from default values set by clients or
servers, and from auto-generated fields and fields set by
auto-sizing or auto-scaling systems.</p></li><li><p>Build, release, or image information like timestamps, release IDs, git branch,
PR numbers, image hashes, and registry address.</p></li><li><p>Pointers to logging, monitoring, analytics, or audit repositories.</p></li><li><p>Client library or tool information that can be used for debugging purposes:
for example, name, version, and build information.</p></li><li><p>User or tool/system provenance information, such as URLs of related objects
from other ecosystem components.</p></li><li><p>Lightweight rollout tool metadata: for example, config or checkpoints.</p></li><li><p>Phone or pager numbers of persons responsible, or directory entries that
specify where that information can be found, such as a team web site.</p></li><li><p>Directives from the end-user to the implementations to modify behavior or
engage non-standard features.</p></li></ul><p>Instead of using annotations, you could store this type of information in an
external database or directory, but that would make it much harder to produce
shared client libraries and tools for deployment, management, introspection,
and the like.</p><h2 id=syntax-and-character-set>Syntax and character set</h2><p><em>Annotations</em> are key/value pairs. Valid annotation keys have two segments: an optional prefix and name, separated by a slash (<code>/</code>). The name segment is required and must be 63 characters or less, beginning and ending with an alphanumeric character (<code>[a-z0-9A-Z]</code>) with dashes (<code>-</code>), underscores (<code>_</code>), dots (<code>.</code>), and alphanumerics between. The prefix is optional. If specified, the prefix must be a DNS subdomain: a series of DNS labels separated by dots (<code>.</code>), not longer than 253 characters in total, followed by a slash (<code>/</code>).</p><p>If the prefix is omitted, the annotation Key is presumed to be private to the user. Automated system components (e.g. <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, or other third-party automation) which add annotations to end-user objects must specify a prefix.</p><p>The <code>kubernetes.io/</code> and <code>k8s.io/</code> prefixes are reserved for Kubernetes core components.</p><p>For example, here's the configuration file for a Pod that has the annotation <code>imageregistry: https://hub.docker.com/</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotations-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageregistry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://hub.docker.com/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=what-s-next>What's next</h2><p>Learn more about <a href=/docs/concepts/overview/working-with-objects/labels/>Labels and Selectors</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>7 - Field Selectors</h1><p><em>Field selectors</em> let you <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects>select Kubernetes resources</a> based on the value of one or more resource fields. Here are some examples of field selector queries:</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>This <code>kubectl</code> command selects all Pods for which the value of the <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a> field is <code>Running</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Field selectors are essentially resource <em>filters</em>. By default, no selectors/filters are applied, meaning that all resources of the specified type are selected. This makes the <code>kubectl</code> queries <code>kubectl get pods</code> and <code>kubectl get pods --field-selector ""</code> equivalent.</div><h2 id=supported-fields>Supported fields</h2><p>Supported field selectors vary by Kubernetes resource type. All resource types support the <code>metadata.name</code> and <code>metadata.namespace</code> fields. Using unsupported field selectors produces an error. For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=supported-operators>Supported operators</h2><p>You can use the <code>=</code>, <code>==</code>, and <code>!=</code> operators with field selectors (<code>=</code> and <code>==</code> mean the same thing). This <code>kubectl</code> command, for example, selects all Kubernetes Services that aren't in the <code>default</code> namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=chained-selectors>Chained selectors</h2><p>As with <a href=/docs/concepts/overview/working-with-objects/labels>label</a> and other selectors, field selectors can be chained together as a comma-separated list. This <code>kubectl</code> command selects all Pods for which the <code>status.phase</code> does not equal <code>Running</code> and the <code>spec.restartPolicy</code> field equals <code>Always</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=multiple-resource-types>Multiple resource types</h2><p>You can use field selectors across multiple resource types. This <code>kubectl</code> command selects all Statefulsets and Services that are not in the <code>default</code> namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-13ce5627ef1dc8cbb4530ed231cb7d38>8 - Finalizers</h1><p>Finalizers are namespaced keys that tell Kubernetes to wait until specific
conditions are met before it fully deletes resources marked for deletion.
Finalizers alert <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a>
to clean up resources the deleted object owned.</p><p>When you tell Kubernetes to delete an object that has finalizers specified for
it, the Kubernetes API marks the object for deletion by populating <code>.metadata.deletionTimestamp</code>,
and returns a <code>202</code> status code (HTTP "Accepted"). The target object remains in a terminating state while the
control plane, or other components, take the actions defined by the finalizers.
After these actions are complete, the controller removes the relevant finalizers
from the target object. When the <code>metadata.finalizers</code> field is empty,
Kubernetes considers the deletion complete and deletes the object.</p><p>You can use finalizers to control <a class=glossary-tooltip title='A collective term for the various mechanisms Kubernetes uses to clean up cluster resources.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/garbage-collection/ target=_blank aria-label='garbage collection'>garbage collection</a>
of resources. For example, you can define a finalizer to clean up related resources or
infrastructure before the controller deletes the target resource.</p><p>You can use finalizers to control <a class=glossary-tooltip title='A collective term for the various mechanisms Kubernetes uses to clean up cluster resources.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/garbage-collection/ target=_blank aria-label='garbage collection'>garbage collection</a>
of resources by alerting <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a> to perform specific cleanup tasks before
deleting the target resource.</p><p>Finalizers don't usually specify the code to execute. Instead, they are
typically lists of keys on a specific resource similar to annotations.
Kubernetes specifies some finalizers automatically, but you can also specify
your own.</p><h2 id=how-finalizers-work>How finalizers work</h2><p>When you create a resource using a manifest file, you can specify finalizers in
the <code>metadata.finalizers</code> field. When you attempt to delete the resource, the
API server handling the delete request notices the values in the <code>finalizers</code> field
and does the following:</p><ul><li>Modifies the object to add a <code>metadata.deletionTimestamp</code> field with the
time you started the deletion.</li><li>Prevents the object from being removed until its <code>metadata.finalizers</code> field is empty.</li><li>Returns a <code>202</code> status code (HTTP "Accepted")</li></ul><p>The controller managing that finalizer notices the update to the object setting the
<code>metadata.deletionTimestamp</code>, indicating deletion of the object has been requested.
The controller then attempts to satisfy the requirements of the finalizers
specified for that resource. Each time a finalizer condition is satisfied, the
controller removes that key from the resource's <code>finalizers</code> field. When the
<code>finalizers</code> field is emptied, an object with a <code>deletionTimestamp</code> field set
is automatically deleted. You can also use finalizers to prevent deletion of unmanaged resources.</p><p>A common example of a finalizer is <code>kubernetes.io/pv-protection</code>, which prevents
accidental deletion of <code>PersistentVolume</code> objects. When a <code>PersistentVolume</code>
object is in use by a Pod, Kubernetes adds the <code>pv-protection</code> finalizer. If you
try to delete the <code>PersistentVolume</code>, it enters a <code>Terminating</code> status, but the
controller can't delete it because the finalizer exists. When the Pod stops
using the <code>PersistentVolume</code>, Kubernetes clears the <code>pv-protection</code> finalizer,
and the controller deletes the volume.</p><h2 id=owners-labels-finalizers>Owner references, labels, and finalizers</h2><p>Like <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a>,
<a href=/docs/concepts/overview/working-with-objects/owners-dependents/>owner references</a>
describe the relationships between objects in Kubernetes, but are used for a
different purpose. When a
<a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> manages objects
like Pods, it uses labels to track changes to groups of related objects. For
example, when a <a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> creates one or
more Pods, the Job controller applies labels to those pods and tracks changes to
any Pods in the cluster with the same label.</p><p>The Job controller also adds <em>owner references</em> to those Pods, pointing at the
Job that created the Pods. If you delete the Job while these Pods are running,
Kubernetes uses the owner references (not labels) to determine which Pods in the
cluster need cleanup.</p><p>Kubernetes also processes finalizers when it identifies owner references on a
resource targeted for deletion.</p><p>In some situations, finalizers can block the deletion of dependent objects,
which can cause the targeted owner object to remain for
longer than expected without being fully deleted. In these situations, you
should check finalizers and owner references on the target owner and dependent
objects to troubleshoot the cause.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> In cases where objects are stuck in a deleting state, avoid manually
removing finalizers to allow deletion to continue. Finalizers are usually added
to resources for a reason, so forcefully removing them can lead to issues in
your cluster. This should only be done when the purpose of the finalizer is
understood and is accomplished in another way (for example, manually cleaning
up some dependent object).</div><h2 id=what-s-next>What's next</h2><ul><li>Read <a href=/blog/2021/05/14/using-finalizers-to-control-deletion/>Using Finalizers to Control Deletion</a>
on the Kubernetes blog.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-efaa7a58910b58892dafd50e3b43c93c>9 - Owners and Dependents</h1><p>In Kubernetes, some objects are <em>owners</em> of other objects. For example, a
<a class=glossary-tooltip title='ReplicaSet ensures that a specified number of Pod replicas are running at one time' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a> is the owner of a set of Pods. These owned objects are <em>dependents</em>
of their owner.</p><p>Ownership is different from the <a href=/docs/concepts/overview/working-with-objects/labels/>labels and selectors</a>
mechanism that some resources also use. For example, consider a Service that
creates <code>EndpointSlice</code> objects. The Service uses labels to allow the control plane to
determine which <code>EndpointSlice</code> objects are used for that Service. In addition
to the labels, each <code>EndpointSlice</code> that is managed on behalf of a Service has
an owner reference. Owner references help different parts of Kubernetes avoid
interfering with objects they don’t control.</p><h2 id=owner-references-in-object-specifications>Owner references in object specifications</h2><p>Dependent objects have a <code>metadata.ownerReferences</code> field that references their
owner object. A valid owner reference consists of the object name and a UID
within the same namespace as the dependent object. Kubernetes sets the value of
this field automatically for objects that are dependents of other objects like
ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers.
You can also configure these relationships manually by changing the value of
this field. However, you usually don't need to and can allow Kubernetes to
automatically manage the relationships.</p><p>Dependent objects also have an <code>ownerReferences.blockOwnerDeletion</code> field that
takes a boolean value and controls whether specific dependents can block garbage
collection from deleting their owner object. Kubernetes automatically sets this
field to <code>true</code> if a <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>
(for example, the Deployment controller) sets the value of the
<code>metadata.ownerReferences</code> field. You can also set the value of the
<code>blockOwnerDeletion</code> field manually to control which dependents block garbage
collection.</p><p>A Kubernetes admission controller controls user access to change this field for
dependent resources, based on the delete permissions of the owner. This control
prevents unauthorized users from delaying owner object deletion.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Cross-namespace owner references are disallowed by design.
Namespaced dependents can specify cluster-scoped or namespaced owners.
A namespaced owner <strong>must</strong> exist in the same namespace as the dependent.
If it does not, the owner reference is treated as absent, and the dependent
is subject to deletion once all owners are verified absent.</p><p>Cluster-scoped dependents can only specify cluster-scoped owners.
In v1.20+, if a cluster-scoped dependent specifies a namespaced kind as an owner,
it is treated as having an unresolvable owner reference, and is not able to be garbage collected.</p><p>In v1.20+, if the garbage collector detects an invalid cross-namespace <code>ownerReference</code>,
or a cluster-scoped dependent with an <code>ownerReference</code> referencing a namespaced kind, a warning Event
with a reason of <code>OwnerRefInvalidNamespace</code> and an <code>involvedObject</code> of the invalid dependent is reported.
You can check for that kind of Event by running
<code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code>.</p></div><h2 id=ownership-and-finalizers>Ownership and finalizers</h2><p>When you tell Kubernetes to delete a resource, the API server allows the
managing controller to process any <a href=/docs/concepts/overview/working-with-objects/finalizers/>finalizer rules</a>
for the resource. <a class=glossary-tooltip title='A namespaced key that tells Kubernetes to wait until specific conditions are met before it fully deletes an object marked for deletion.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=Finalizers>Finalizers</a>
prevent accidental deletion of resources your cluster may still need to function
correctly. For example, if you try to delete a <code>PersistentVolume</code> that is still
in use by a Pod, the deletion does not happen immediately because the
<code>PersistentVolume</code> has the <code>kubernetes.io/pv-protection</code> finalizer on it.
Instead, the volume remains in the <code>Terminating</code> status until Kubernetes clears
the finalizer, which only happens after the <code>PersistentVolume</code> is no longer
bound to a Pod.</p><p>Kubernetes also adds finalizers to an owner resource when you use either
<a href=/docs/concepts/architecture/garbage-collection/#cascading-deletion>foreground or orphan cascading deletion</a>.
In foreground deletion, it adds the <code>foreground</code> finalizer so that the
controller must delete dependent resources that also have
<code>ownerReferences.blockOwnerDeletion=true</code> before it deletes the owner. If you
specify an orphan deletion policy, Kubernetes adds the <code>orphan</code> finalizer so
that the controller ignores dependent resources after it deletes the owner
object.</p><h2 id=what-s-next>What's next</h2><ul><li>Learn more about <a href=/docs/concepts/overview/working-with-objects/finalizers/>Kubernetes finalizers</a>.</li><li>Learn about <a href=/docs/concepts/architecture/garbage-collection>garbage collection</a>.</li><li>Read the API reference for <a href=/docs/reference/kubernetes-api/common-definitions/object-meta/#System>object metadata</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>10 - Recommended Labels</h1><p>You can visualize and manage Kubernetes objects with more tools than kubectl and
the dashboard. A common set of labels allows tools to work interoperably, describing
objects in a common manner that all tools can understand.</p><p>In addition to supporting tooling, the recommended labels describe applications
in a way that can be queried.</p><p>The metadata is organized around the concept of an <em>application</em>. Kubernetes is not
a platform as a service (PaaS) and doesn't have or enforce a formal notion of an application.
Instead, applications are informal and described with metadata. The definition of
what an application contains is loose.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> These are recommended labels. They make it easier to manage applications
but aren't required for any core tooling.</div><p>Shared labels and annotations share a common prefix: <code>app.kubernetes.io</code>. Labels
without a prefix are private to users. The shared prefix ensures that shared labels
do not interfere with custom user labels.</p><h2 id=labels>Labels</h2><p>In order to take full advantage of using these labels, they should be applied
on every resource object.</p><table><thead><tr><th>Key</th><th>Description</th><th>Example</th><th>Type</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>The name of the application</td><td><code>mysql</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>A unique name identifying the instance of an application</td><td><code>mysql-abcxzy</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>The current version of the application (e.g., a semantic version, revision hash, etc.)</td><td><code>5.7.21</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>The component within the architecture</td><td><code>database</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>The name of a higher level application this one is part of</td><td><code>wordpress</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>The tool being used to manage the operation of an application</td><td><code>helm</code></td><td>string</td></tr></tbody></table><p>To illustrate these labels in action, consider the following <a class=glossary-tooltip title='Manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a> object:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># This is an excerpt</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=applications-and-instances-of-applications>Applications And Instances Of Applications</h2><p>An application can be installed one or more times into a Kubernetes cluster and,
in some cases, the same namespace. For example, WordPress can be installed more
than once where different websites are different installations of WordPress.</p><p>The name of an application and the instance name are recorded separately. For
example, WordPress has a <code>app.kubernetes.io/name</code> of <code>wordpress</code> while it has
an instance name, represented as <code>app.kubernetes.io/instance</code> with a value of
<code>wordpress-abcxzy</code>. This enables the application and instance of the application
to be identifiable. Every instance of an application must have a unique name.</p><h2 id=examples>Examples</h2><p>To illustrate different ways to use these labels the following examples have varying complexity.</p><h3 id=a-simple-stateless-service>A Simple Stateless Service</h3><p>Consider the case for a simple stateless service deployed using <code>Deployment</code> and <code>Service</code> objects. The following two snippets represent how the labels could be used in their simplest form.</p><p>The <code>Deployment</code> is used to oversee the pods running the application itself.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>The <code>Service</code> is used to expose the application.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=web-application-with-a-database>Web Application With A Database</h3><p>Consider a slightly more complicated application: a web application (WordPress)
using a database (MySQL), installed using Helm. The following snippets illustrate
the start of objects used to deploy this application.</p><p>The start to the following <code>Deployment</code> is used for WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>The <code>Service</code> is used to expose WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL is exposed as a <code>StatefulSet</code> with metadata for both it and the larger application it belongs to:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>The <code>Service</code> is used to expose MySQL as part of WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>With the MySQL <code>StatefulSet</code> and <code>Service</code> you'll notice information about both MySQL and WordPress, the broader application, are included.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/docs/home/>Home</a>
<a class=text-white href=/blog/>Blog</a>
<a class=text-white href=/training/>Training</a>
<a class=text-white href=/partners/>Partners</a>
<a class=text-white href=/community/>Community</a>
<a class=text-white href=/case-studies/>Case Studies</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>