<!doctype html><html lang=en class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/api-extension/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Extending the Kubernetes API | Kubernetes</title><meta property="og:title" content="Extending the Kubernetes API"><meta property="og:description" content="Production-Grade Container Orchestration"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Extending the Kubernetes API"><meta itemprop=description content="Production-Grade Container Orchestration"><meta name=twitter:card content="summary"><meta name=twitter:title content="Extending the Kubernetes API"><meta name=twitter:description content="Production-Grade Container Orchestration"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/"><meta property="og:title" content="Extending the Kubernetes API"><meta name=twitter:title content="Extending the Kubernetes API"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/docs/>Documentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/training/>Training</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/partners/>Partners</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/case-studies/>Case Studies</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/docs/concepts/extend-kubernetes/api-extension/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/docs/concepts/extend-kubernetes/api-extension/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/docs/concepts/extend-kubernetes/api-extension/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/docs/concepts/extend-kubernetes/api-extension/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>English</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/extend-kubernetes/api-extension/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/extend-kubernetes/api-extension/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/extend-kubernetes/api-extension/>Français (French)</a>
<a class=dropdown-item href=/es/docs/concepts/extend-kubernetes/api-extension/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/extend-kubernetes/api-extension/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/extend-kubernetes/api-extension/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/concepts/extend-kubernetes/api-extension/>Return to the regular view of this page</a>.</p></div><h1 class=title>Extending the Kubernetes API</h1><ul><li>1: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>Custom Resources</a></li><li>2: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>Kubernetes API Aggregation Layer</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-342388440304e19ce30c0f8ada1c77ce>1 - Custom Resources</h1><p><em>Custom resources</em> are extensions of the Kubernetes API. This page discusses when to add a custom
resource to your Kubernetes cluster and when to use a standalone service. It describes the two
methods for adding custom resources and how to choose between them.</p><h2 id=custom-resources>Custom resources</h2><p>A <em>resource</em> is an endpoint in the <a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a> that
stores a collection of <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>API objects</a>
of a certain kind; for example, the built-in <em>pods</em> resource contains a collection of Pod objects.</p><p>A <em>custom resource</em> is an extension of the Kubernetes API that is not necessarily available in a default
Kubernetes installation. It represents a customization of a particular Kubernetes installation. However,
many core Kubernetes functions are now built using custom resources, making Kubernetes more modular.</p><p>Custom resources can appear and disappear in a running cluster through dynamic registration,
and cluster admins can update custom resources independently of the cluster itself.
Once a custom resource is installed, users can create and access its objects using
<a class=glossary-tooltip title='A command line tool for communicating with a Kubernetes cluster.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>, just as they do for built-in resources
like <em>Pods</em>.</p><h2 id=custom-controllers>Custom controllers</h2><p>On their own, custom resources let you store and retrieve structured data.
When you combine a custom resource with a <em>custom controller</em>, custom resources
provide a true <em>declarative API</em>.</p><p>The Kubernetes <a href=/docs/concepts/overview/kubernetes-api/>declarative API</a>
enforces a separation of responsibilities. You declare the desired state of
your resource. The Kubernetes controller keeps the current state of Kubernetes
objects in sync with your declared desired state. This is in contrast to an
imperative API, where you <em>instruct</em> a server what to do.</p><p>You can deploy and update a custom controller on a running cluster, independently
of the cluster's lifecycle. Custom controllers can work with any kind of resource,
but they are especially effective when combined with custom resources. The
<a href=/docs/concepts/extend-kubernetes/operator/>Operator pattern</a> combines custom
resources and custom controllers. You can use custom controllers to encode domain knowledge
for specific applications into an extension of the Kubernetes API.</p><h2 id=should-i-add-a-custom-resource-to-my-kubernetes-cluster>Should I add a custom resource to my Kubernetes cluster?</h2><p>When creating a new API, consider whether to
<a href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>aggregate your API with the Kubernetes cluster APIs</a>
or let your API stand alone.</p><table><thead><tr><th>Consider API aggregation if:</th><th>Prefer a stand-alone API if:</th></tr></thead><tbody><tr><td>Your API is <a href=#declarative-apis>Declarative</a>.</td><td>Your API does not fit the <a href=#declarative-apis>Declarative</a> model.</td></tr><tr><td>You want your new types to be readable and writable using <code>kubectl</code>.</td><td><code>kubectl</code> support is not required</td></tr><tr><td>You want to view your new types in a Kubernetes UI, such as dashboard, alongside built-in types.</td><td>Kubernetes UI support is not required.</td></tr><tr><td>You are developing a new API.</td><td>You already have a program that serves your API and works well.</td></tr><tr><td>You are willing to accept the format restriction that Kubernetes puts on REST resource paths, such as API Groups and Namespaces. (See the <a href=/docs/concepts/overview/kubernetes-api/>API Overview</a>.)</td><td>You need to have specific REST paths to be compatible with an already defined REST API.</td></tr><tr><td>Your resources are naturally scoped to a cluster or namespaces of a cluster.</td><td>Cluster or namespace scoped resources are a poor fit; you need control over the specifics of resource paths.</td></tr><tr><td>You want to reuse <a href=#common-features>Kubernetes API support features</a>.</td><td>You don't need those features.</td></tr></tbody></table><h3 id=declarative-apis>Declarative APIs</h3><p>In a Declarative API, typically:</p><ul><li>Your API consists of a relatively small number of relatively small objects (resources).</li><li>The objects define configuration of applications or infrastructure.</li><li>The objects are updated relatively infrequently.</li><li>Humans often need to read and write the objects.</li><li>The main operations on the objects are CRUD-y (creating, reading, updating and deleting).</li><li>Transactions across objects are not required: the API represents a desired state, not an exact state.</li></ul><p>Imperative APIs are not declarative.
Signs that your API might not be declarative include:</p><ul><li>The client says "do this", and then gets a synchronous response back when it is done.</li><li>The client says "do this", and then gets an operation ID back, and has to check a separate
Operation object to determine completion of the request.</li><li>You talk about Remote Procedure Calls (RPCs).</li><li>Directly storing large amounts of data; for example, > a few kB per object, or > 1000s of objects.</li><li>High bandwidth access (10s of requests per second sustained) needed.</li><li>Store end-user data (such as images, PII, etc.) or other large-scale data processed by applications.</li><li>The natural operations on the objects are not CRUD-y.</li><li>The API is not easily modeled as objects.</li><li>You chose to represent pending operations with an operation ID or an operation object.</li></ul><h2 id=should-i-use-a-configmap-or-a-custom-resource>Should I use a ConfigMap or a custom resource?</h2><p>Use a ConfigMap if any of the following apply:</p><ul><li>There is an existing, well-documented configuration file format, such as a <code>mysql.cnf</code> or
<code>pom.xml</code>.</li><li>You want to put the entire configuration into one key of a ConfigMap.</li><li>The main use of the configuration file is for a program running in a Pod on your cluster to
consume the file to configure itself.</li><li>Consumers of the file prefer to consume via file in a Pod or environment variable in a pod,
rather than the Kubernetes API.</li><li>You want to perform rolling updates via Deployment, etc., when the file is updated.</li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Use a <a class=glossary-tooltip title='Stores sensitive information, such as passwords, OAuth tokens, and ssh keys.' data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> for sensitive data, which is similar
to a ConfigMap but more secure.</div><p>Use a custom resource (CRD or Aggregated API) if most of the following apply:</p><ul><li>You want to use Kubernetes client libraries and CLIs to create and update the new resource.</li><li>You want top-level support from <code>kubectl</code>; for example, <code>kubectl get my-object object-name</code>.</li><li>You want to build new automation that watches for updates on the new object, and then CRUD other
objects, or vice versa.</li><li>You want to write automation that handles updates to the object.</li><li>You want to use Kubernetes API conventions like <code>.spec</code>, <code>.status</code>, and <code>.metadata</code>.</li><li>You want the object to be an abstraction over a collection of controlled resources, or a
summarization of other resources.</li></ul><h2 id=adding-custom-resources>Adding custom resources</h2><p>Kubernetes provides two ways to add custom resources to your cluster:</p><ul><li>CRDs are simple and can be created without any programming.</li><li><a href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API Aggregation</a>
requires programming, but allows more control over API behaviors like how data is stored and
conversion between API versions.</li></ul><p>Kubernetes provides these two options to meet the needs of different users, so that neither ease
of use nor flexibility is compromised.</p><p>Aggregated APIs are subordinate API servers that sit behind the primary API server, which acts as
a proxy. This arrangement is called <a href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API Aggregation</a>(AA).
To users, the Kubernetes API appears extended.</p><p>CRDs allow users to create new types of resources without adding another API server. You do not
need to understand API Aggregation to use CRDs.</p><p>Regardless of how they are installed, the new resources are referred to as Custom Resources to
distinguish them from built-in Kubernetes resources (like pods).</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Avoid using a Custom Resource as data storage for application, end user, or monitoring data:
architecture designs that store application data within the Kubernetes API typically represent
a design that is too closely coupled.</p><p>Architecturally, <a href=https://www.cncf.io/about/faq/#what-is-cloud-native>cloud native</a> application architectures
favor loose coupling between components. If part of your workload requires a backing service for
its routine operation, run that backing service as a component or consume it as an external service.
This way, your workload does not rely on the Kubernetes API for its normal operation.</p></div><h2 id=customresourcedefinitions>CustomResourceDefinitions</h2><p>The <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>
API resource allows you to define custom resources.
Defining a CRD object creates a new custom resource with a name and schema that you specify.
The Kubernetes API serves and handles the storage of your custom resource.
The name of a CRD object must be a valid
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS subdomain name</a>.</p><p>This frees you from writing your own API server to handle the custom resource,
but the generic nature of the implementation means you have less flexibility than with
<a href=#api-server-aggregation>API server aggregation</a>.</p><p>Refer to the <a href=https://github.com/kubernetes/sample-controller>custom controller example</a>
for an example of how to register a new custom resource, work with instances of your new resource type,
and use a controller to handle events.</p><h2 id=api-server-aggregation>API server aggregation</h2><p>Usually, each resource in the Kubernetes API requires code that handles REST requests and manages
persistent storage of objects. The main Kubernetes API server handles built-in resources like
<em>pods</em> and <em>services</em>, and can also generically handle custom resources through
<a href=#customresourcedefinitions>CRDs</a>.</p><p>The <a href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>aggregation layer</a>
allows you to provide specialized implementations for your custom resources by writing and
deploying your own API server.
The main API server delegates requests to your API server for the custom resources that you handle,
making them available to all of its clients.</p><h2 id=choosing-a-method-for-adding-custom-resources>Choosing a method for adding custom resources</h2><p>CRDs are easier to use. Aggregated APIs are more flexible. Choose the method that best meets your needs.</p><p>Typically, CRDs are a good fit if:</p><ul><li>You have a handful of fields</li><li>You are using the resource within your company, or as part of a small open-source project (as
opposed to a commercial product)</li></ul><h3 id=comparing-ease-of-use>Comparing ease of use</h3><p>CRDs are easier to create than Aggregated APIs.</p><table><thead><tr><th>CRDs</th><th>Aggregated API</th></tr></thead><tbody><tr><td>Do not require programming. Users can choose any language for a CRD controller.</td><td>Requires programming and building binary and image.</td></tr><tr><td>No additional service to run; CRDs are handled by API server.</td><td>An additional service to create and that could fail.</td></tr><tr><td>No ongoing support once the CRD is created. Any bug fixes are picked up as part of normal Kubernetes Master upgrades.</td><td>May need to periodically pickup bug fixes from upstream and rebuild and update the Aggregated API server.</td></tr><tr><td>No need to handle multiple versions of your API; for example, when you control the client for this resource, you can upgrade it in sync with the API.</td><td>You need to handle multiple versions of your API; for example, when developing an extension to share with the world.</td></tr></tbody></table><h3 id=advanced-features-and-flexibility>Advanced features and flexibility</h3><p>Aggregated APIs offer more advanced API features and customization of other features; for example, the storage layer.</p><table><thead><tr><th>Feature</th><th>Description</th><th>CRDs</th><th>Aggregated API</th></tr></thead><tbody><tr><td>Validation</td><td>Help users prevent errors and allow you to evolve your API independently of your clients. These features are most useful when there are many clients who can't all update at the same time.</td><td>Yes. Most validation can be specified in the CRD using <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 validation</a>. Any other validations supported by addition of a <a href=/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9>Validating Webhook</a>.</td><td>Yes, arbitrary validation checks</td></tr><tr><td>Defaulting</td><td>See above</td><td>Yes, either via <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#defaulting>OpenAPI v3.0 validation</a> <code>default</code> keyword (GA in 1.17), or via a <a href=/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>Mutating Webhook</a> (though this will not be run when reading from etcd for old objects).</td><td>Yes</td></tr><tr><td>Multi-versioning</td><td>Allows serving the same object through two API versions. Can help ease API changes like renaming fields. Less important if you control your client versions.</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning>Yes</a></td><td>Yes</td></tr><tr><td>Custom Storage</td><td>If you need storage with a different performance mode (for example, a time-series database instead of key-value store) or isolation for security (for example, encryption of sensitive information, etc.)</td><td>No</td><td>Yes</td></tr><tr><td>Custom Business Logic</td><td>Perform arbitrary checks or actions when creating, reading, updating or deleting an object</td><td>Yes, using <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Webhooks</a>.</td><td>Yes</td></tr><tr><td>Scale Subresource</td><td>Allows systems like HorizontalPodAutoscaler and PodDisruptionBudget interact with your new resource</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource>Yes</a></td><td>Yes</td></tr><tr><td>Status Subresource</td><td>Allows fine-grained access control where user writes the spec section and the controller writes the status section. Allows incrementing object Generation on custom resource data mutation (requires separate spec and status sections in the resource)</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource>Yes</a></td><td>Yes</td></tr><tr><td>Other Subresources</td><td>Add operations other than CRUD, such as "logs" or "exec".</td><td>No</td><td>Yes</td></tr><tr><td>strategic-merge-patch</td><td>The new endpoints support PATCH with <code>Content-Type: application/strategic-merge-patch+json</code>. Useful for updating objects that may be modified both locally, and by the server. For more information, see <a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>"Update API Objects in Place Using kubectl patch"</a></td><td>No</td><td>Yes</td></tr><tr><td>Protocol Buffers</td><td>The new resource supports clients that want to use Protocol Buffers</td><td>No</td><td>Yes</td></tr><tr><td>OpenAPI Schema</td><td>Is there an OpenAPI (swagger) schema for the types that can be dynamically fetched from the server? Is the user protected from misspelling field names by ensuring only allowed fields are set? Are types enforced (in other words, don't put an <code>int</code> in a <code>string</code> field?)</td><td>Yes, based on the <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 validation</a> schema (GA in 1.16).</td><td>Yes</td></tr></tbody></table><h3 id=common-features>Common Features</h3><p>When you create a custom resource, either via a CRD or an AA, you get many features for your API,
compared to implementing it outside the Kubernetes platform:</p><table><thead><tr><th>Feature</th><th>What it does</th></tr></thead><tbody><tr><td>CRUD</td><td>The new endpoints support CRUD basic operations via HTTP and <code>kubectl</code></td></tr><tr><td>Watch</td><td>The new endpoints support Kubernetes Watch operations via HTTP</td></tr><tr><td>Discovery</td><td>Clients like <code>kubectl</code> and dashboard automatically offer list, display, and field edit operations on your resources</td></tr><tr><td>json-patch</td><td>The new endpoints support PATCH with <code>Content-Type: application/json-patch+json</code></td></tr><tr><td>merge-patch</td><td>The new endpoints support PATCH with <code>Content-Type: application/merge-patch+json</code></td></tr><tr><td>HTTPS</td><td>The new endpoints uses HTTPS</td></tr><tr><td>Built-in Authentication</td><td>Access to the extension uses the core API server (aggregation layer) for authentication</td></tr><tr><td>Built-in Authorization</td><td>Access to the extension can reuse the authorization used by the core API server; for example, RBAC.</td></tr><tr><td>Finalizers</td><td>Block deletion of extension resources until external cleanup happens.</td></tr><tr><td>Admission Webhooks</td><td>Set default values and validate extension resources during any create/update/delete operation.</td></tr><tr><td>UI/CLI Display</td><td>Kubectl, dashboard can display extension resources.</td></tr><tr><td>Unset versus Empty</td><td>Clients can distinguish unset fields from zero-valued fields.</td></tr><tr><td>Client Libraries Generation</td><td>Kubernetes provides generic client libraries, as well as tools to generate type-specific client libraries.</td></tr><tr><td>Labels and annotations</td><td>Common metadata across objects that tools know how to edit for core and custom resources.</td></tr></tbody></table><h2 id=preparing-to-install-a-custom-resource>Preparing to install a custom resource</h2><p>There are several points to be aware of before adding a custom resource to your cluster.</p><h3 id=third-party-code-and-new-points-of-failure>Third party code and new points of failure</h3><p>While creating a CRD does not automatically add any new points of failure (for example, by causing
third party code to run on your API server), packages (for example, Charts) or other installation
bundles often include CRDs as well as a Deployment of third-party code that implements the
business logic for a new custom resource.</p><p>Installing an Aggregated API server always involves running a new Deployment.</p><h3 id=storage>Storage</h3><p>Custom resources consume storage space in the same way that ConfigMaps do. Creating too many
custom resources may overload your API server's storage space.</p><p>Aggregated API servers may use the same storage as the main API server, in which case the same
warning applies.</p><h3 id=authentication-authorization-and-auditing>Authentication, authorization, and auditing</h3><p>CRDs always use the same authentication, authorization, and audit logging as the built-in
resources of your API server.</p><p>If you use RBAC for authorization, most RBAC roles will not grant access to the new resources
(except the cluster-admin role or any role created with wildcard rules). You'll need to explicitly
grant access to the new resources. CRDs and Aggregated APIs often come bundled with new role
definitions for the types they add.</p><p>Aggregated API servers may or may not use the same authentication, authorization, and auditing as
the primary API server.</p><h2 id=accessing-a-custom-resource>Accessing a custom resource</h2><p>Kubernetes <a href=/docs/reference/using-api/client-libraries/>client libraries</a> can be used to access
custom resources. Not all client libraries support custom resources. The <em>Go</em> and <em>Python</em> client
libraries do.</p><p>When you add a custom resource, you can access it using:</p><ul><li><code>kubectl</code></li><li>The Kubernetes dynamic client.</li><li>A REST client that you write.</li><li>A client generated using <a href=https://github.com/kubernetes/code-generator>Kubernetes client generation tools</a>
(generating one is an advanced undertaking, but some projects may provide a client along with
the CRD or AA).</li></ul><h2 id=what-s-next>What's next</h2><ul><li>Learn how to <a href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Extend the Kubernetes API with the aggregation layer</a>.</li><li>Learn how to <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>Extend the Kubernetes API with CustomResourceDefinition</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>2 - Kubernetes API Aggregation Layer</h1><p>The aggregation layer allows Kubernetes to be extended with additional APIs, beyond what is
offered by the core Kubernetes APIs.
The additional APIs can either be ready-made solutions such as a
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics server</a>, or APIs that you develop yourself.</p><p>The aggregation layer is different from
<a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Custom Resources</a>,
which are a way to make the <a class=glossary-tooltip title='Control plane component that serves the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>
recognise new kinds of object.</p><h2 id=aggregation-layer>Aggregation layer</h2><p>The aggregation layer runs in-process with the kube-apiserver. Until an extension resource is
registered, the aggregation layer will do nothing. To register an API, you add an <em>APIService</em>
object, which "claims" the URL path in the Kubernetes API. At that point, the aggregation layer
will proxy anything sent to that API path (e.g. <code>/apis/myextension.mycompany.io/v1/…</code>) to the
registered APIService.</p><p>The most common way to implement the APIService is to run an <em>extension API server</em> in Pod(s) that
run in your cluster. If you're using the extension API server to manage resources in your cluster,
the extension API server (also written as "extension-apiserver") is typically paired with one or
more <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a>. The apiserver-builder
library provides a skeleton for both extension API servers and the associated controller(s).</p><h3 id=response-latency>Response latency</h3><p>Extension API servers should have low latency networking to and from the kube-apiserver.
Discovery requests are required to round-trip from the kube-apiserver in five seconds or less.</p><p>If your extension API server cannot achieve that latency requirement, consider making changes that
let you meet it.</p><h2 id=what-s-next>What's next</h2><ul><li>To get the aggregator working in your environment, <a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>configure the aggregation layer</a>.</li><li>Then, <a href=/docs/tasks/extend-kubernetes/setup-extension-api-server/>setup an extension api-server</a> to work with the aggregation layer.</li><li>Read about <a href=/docs/reference/kubernetes-api/cluster-resources/api-service-v1/>APIService</a> in the API reference</li></ul><p>Alternatively: learn how to
<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>extend the Kubernetes API using Custom Resource Definitions</a>.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/docs/home/>Home</a>
<a class=text-white href=/blog/>Blog</a>
<a class=text-white href=/training/>Training</a>
<a class=text-white href=/partners/>Partners</a>
<a class=text-white href=/community/>Community</a>
<a class=text-white href=/case-studies/>Case Studies</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>