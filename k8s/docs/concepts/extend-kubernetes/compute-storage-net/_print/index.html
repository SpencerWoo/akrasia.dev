<!doctype html><html lang=en class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/extend-kubernetes/compute-storage-net/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/extend-kubernetes/compute-storage-net/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/extend-kubernetes/compute-storage-net/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/extend-kubernetes/compute-storage-net/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/compute-storage-net/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Compute, Storage, and Networking Extensions | Kubernetes</title><meta property="og:title" content="Compute, Storage, and Networking Extensions"><meta property="og:description" content="Production-Grade Container Orchestration"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Compute, Storage, and Networking Extensions"><meta itemprop=description content="Production-Grade Container Orchestration"><meta name=twitter:card content="summary"><meta name=twitter:title content="Compute, Storage, and Networking Extensions"><meta name=twitter:description content="Production-Grade Container Orchestration"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="This section covers extensions to your cluster that do not come as part as Kubernetes itself. You can use these extensions to enhance the nodes in your cluster, or to provide the network fabric that links Pods together.
CSI and FlexVolume storage plugins
Container Storage Interface (CSI) plugins provide a way to extend Kubernetes with supports for new kinds of volumes. The volumes can be backed by durable external storage, or provide ephemeral storage, or they might offer a read-only interface to information using a filesystem paradigm."><meta property="og:description" content="This section covers extensions to your cluster that do not come as part as Kubernetes itself. You can use these extensions to enhance the nodes in your cluster, or to provide the network fabric that links Pods together.
CSI and FlexVolume storage plugins
Container Storage Interface (CSI) plugins provide a way to extend Kubernetes with supports for new kinds of volumes. The volumes can be backed by durable external storage, or provide ephemeral storage, or they might offer a read-only interface to information using a filesystem paradigm."><meta name=twitter:description content="This section covers extensions to your cluster that do not come as part as Kubernetes itself. You can use these extensions to enhance the nodes in your cluster, or to provide the network fabric that links Pods together.
CSI and FlexVolume storage plugins
Container Storage Interface (CSI) plugins provide a way to extend Kubernetes with supports for new kinds of volumes. The volumes can be backed by durable external storage, or provide ephemeral storage, or they might offer a read-only interface to information using a filesystem paradigm."><meta property="og:url" content="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/"><meta property="og:title" content="Compute, Storage, and Networking Extensions"><meta name=twitter:title content="Compute, Storage, and Networking Extensions"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/docs/>Documentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/training/>Training</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/partners/>Partners</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/case-studies/>Case Studies</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>English</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/extend-kubernetes/compute-storage-net/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/concepts/extend-kubernetes/compute-storage-net/>Français (French)</a>
<a class=dropdown-item href=/es/docs/concepts/extend-kubernetes/compute-storage-net/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/extend-kubernetes/compute-storage-net/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/extend-kubernetes/compute-storage-net/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/concepts/extend-kubernetes/compute-storage-net/>Return to the regular view of this page</a>.</p></div><h1 class=title>Compute, Storage, and Networking Extensions</h1><ul><li>1: <a href=#pg-1ac2260db9ecccbf0303a899bc27ce6d>Network Plugins</a></li><li>2: <a href=#pg-53e1ea8892ceca307ba19e8d6a7b8d32>Device Plugins</a></li></ul><div class=content><p>This section covers extensions to your cluster that do not come as part as Kubernetes itself.
You can use these extensions to enhance the nodes in your cluster, or to provide the network
fabric that links Pods together.</p><ul><li><p><a href=/docs/concepts/storage/volumes/#csi>CSI</a> and <a href=/docs/concepts/storage/volumes/#flexvolume>FlexVolume</a> storage plugins</p><p><a class=glossary-tooltip title='The Container Storage Interface (CSI) defines a standard interface to expose storage systems to containers.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label='Container Storage Interface'>Container Storage Interface</a> (CSI) plugins
provide a way to extend Kubernetes with supports for new kinds of volumes. The volumes can
be backed by durable external storage, or provide ephemeral storage, or they might offer a
read-only interface to information using a filesystem paradigm.</p><p>Kubernetes also includes support for <a href=/docs/concepts/storage/volumes/#flexvolume>FlexVolume</a>
plugins, which are deprecated since Kubernetes v1.23 (in favour of CSI).</p><p>FlexVolume plugins allow users to mount volume types that aren't natively
supported by Kubernetes. When you run a Pod that relies on FlexVolume
storage, the kubelet calls a binary plugin to mount the volume. The archived
<a href=https://git.k8s.io/design-proposals-archive/storage/flexvolume-deployment.md>FlexVolume</a>
design proposal has more detail on this approach.</p><p>The <a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md#kubernetes-volume-plugin-faq-for-storage-vendors>Kubernetes Volume Plugin FAQ for Storage Vendors</a>
includes general information on storage plugins.</p></li><li><p><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>Device plugins</a></p><p>Device plugins allow a node to discover new Node facilities (in addition to the
built-in node resources such as <code>cpu</code> and <code>memory</code>), and provide these custom node-local
facilities to Pods that request them.</p></li><li><p><a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>Network plugins</a></p><p>A network plugin allow Kubernetes to work with different networking topologies and technologies.
Your Kubernetes cluster needs a <em>network plugin</em> in order to have a working Pod network
and to support other aspects of the Kubernetes network model.</p><p>Kubernetes 1.25 is compatible with <a class=glossary-tooltip title='Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification.' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/ target=_blank aria-label=CNI>CNI</a>
network plugins.</p></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-1ac2260db9ecccbf0303a899bc27ce6d>1 - Network Plugins</h1><p>Kubernetes 1.25 supports <a href=https://github.com/containernetworking/cni>Container Network Interface</a>
(CNI) plugins for cluster networking. You must use a CNI plugin that is compatible with your
cluster and that suits your needs. Different plugins are available (both open- and closed- source)
in the wider Kubernetes ecosystem.</p><p>A CNI plugin is required to implement the
<a href=/docs/concepts/services-networking/#the-kubernetes-network-model>Kubernetes network model</a>.</p><p>You must use a CNI plugin that is compatible with the
<a href=https://github.com/containernetworking/cni/blob/spec-v0.4.0/SPEC.md>v0.4.0</a> or later
releases of the CNI specification. The Kubernetes project recommends using a plugin that is
compatible with the <a href=https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md>v1.0.0</a>
CNI specification (plugins can be compatible with multiple spec versions).</p><h2 id=installation>Installation</h2><p>A Container Runtime, in the networking context, is a daemon on a node configured to provide CRI
Services for kubelet. In particular, the Container Runtime must be configured to load the CNI
plugins required to implement the Kubernetes network model.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Prior to Kubernetes 1.24, the CNI plugins could also be managed by the kubelet using the
<code>cni-bin-dir</code> and <code>network-plugin</code> command-line parameters.
These command-line parameters were removed in Kubernetes 1.24, with management of the CNI no
longer in scope for kubelet.</p><p>See <a href=/docs/tasks/administer-cluster/migrating-from-dockershim/troubleshooting-cni-plugin-related-errors/>Troubleshooting CNI plugin-related errors</a>
if you are facing issues following the removal of dockershim.</p></div><p>For specific information about how a Container Runtime manages the CNI plugins, see the
documentation for that Container Runtime, for example:</p><ul><li><a href=https://github.com/containerd/containerd/blob/main/script/setup/install-cni>containerd</a></li><li><a href=https://github.com/cri-o/cri-o/blob/main/contrib/cni/README.md>CRI-O</a></li></ul><p>For specific information about how to install and manage a CNI plugin, see the documentation for
that plugin or <a href=/docs/concepts/cluster-administration/networking/#how-to-implement-the-kubernetes-networking-model>networking provider</a>.</p><h2 id=network-plugin-requirements>Network Plugin Requirements</h2><p>For plugin developers and users who regularly build or deploy Kubernetes, the plugin may also need
specific configuration to support kube-proxy. The iptables proxy depends on iptables, and the
plugin may need to ensure that container traffic is made available to iptables. For example, if
the plugin connects containers to a Linux bridge, the plugin must set the
<code>net/bridge/bridge-nf-call-iptables</code> sysctl to <code>1</code> to ensure that the iptables proxy functions
correctly. If the plugin does not use a Linux bridge, but uses something like Open vSwitch or
some other mechanism instead, it should ensure container traffic is appropriately routed for the
proxy.</p><p>By default, if no kubelet network plugin is specified, the <code>noop</code> plugin is used, which sets
<code>net/bridge/bridge-nf-call-iptables=1</code> to ensure simple configurations (like Docker with a bridge)
work correctly with the iptables proxy.</p><h3 id=loopback-cni>Loopback CNI</h3><p>In addition to the CNI plugin installed on the nodes for implementing the Kubernetes network
model, Kubernetes also requires the container runtimes to provide a loopback interface <code>lo</code>, which
is used for each sandbox (pod sandboxes, vm sandboxes, ...).
Implementing the loopback interface can be accomplished by re-using the
<a href=https://github.com/containernetworking/plugins/blob/master/plugins/main/loopback/loopback.go>CNI loopback plugin.</a>
or by developing your own code to achieve this (see
<a href=https://github.com/cri-o/ocicni/blob/release-1.24/pkg/ocicni/util_linux.go#L91>this example from CRI-O</a>).</p><h3 id=support-hostport>Support hostPort</h3><p>The CNI networking plugin supports <code>hostPort</code>. You can use the official
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/portmap>portmap</a>
plugin offered by the CNI plugin team or use your own plugin with portMapping functionality.</p><p>If you want to enable <code>hostPort</code> support, you must specify <code>portMappings capability</code> in your
<code>cni-conf-dir</code>. For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;portmap&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;portMappings&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=support-traffic-shaping>Support traffic shaping</h3><p><strong>Experimental Feature</strong></p><p>The CNI networking plugin also supports pod ingress and egress traffic shaping. You can use the
official <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/bandwidth>bandwidth</a>
plugin offered by the CNI plugin team or use your own plugin with bandwidth control functionality.</p><p>If you want to enable traffic shaping support, you must add the <code>bandwidth</code> plugin to your CNI
configuration file (default <code>/etc/cni/net.d</code>) and ensure that the binary is included in your CNI
bin dir (default <code>/opt/cni/bin</code>).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;bandwidth&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;bandwidth&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now you can add the <code>kubernetes.io/ingress-bandwidth</code> and <code>kubernetes.io/egress-bandwidth</code>
annotations to your Pod. For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/ingress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/egress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=what-s-next>What's next</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-53e1ea8892ceca307ba19e8d6a7b8d32>2 - Device Plugins</h1><div class=lead>Device plugins let you configure your cluster with support for devices or resources that require vendor-specific setup, such as GPUs, NICs, FPGAs, or non-volatile main memory.</div><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code></div><p>Kubernetes provides a <a href=https://git.k8s.io/design-proposals-archive/resource-management/device-plugin.md>device plugin framework</a>
that you can use to advertise system hardware resources to the
<a class=glossary-tooltip title='An agent that runs on each node in the cluster. It makes sure that containers are running in a pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>.</p><p>Instead of customizing the code for Kubernetes itself, vendors can implement a
device plugin that you deploy either manually or as a <a class=glossary-tooltip title='Ensures a copy of a Pod is running across a set of nodes in a cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>.
The targeted devices include GPUs, high-performance NICs, FPGAs, InfiniBand adapters,
and other similar computing resources that may require vendor specific initialization
and setup.</p><h2 id=device-plugin-registration>Device plugin registration</h2><p>The kubelet exports a <code>Registration</code> gRPC service:</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>service Registration {
	rpc Register(RegisterRequest) returns (Empty) {}
}
</code></pre><p>A device plugin can register itself with the kubelet through this gRPC service.
During the registration, the device plugin needs to send:</p><ul><li>The name of its Unix socket.</li><li>The Device Plugin API version against which it was built.</li><li>The <code>ResourceName</code> it wants to advertise. Here <code>ResourceName</code> needs to follow the
<a href=/docs/concepts/configuration/manage-resources-containers/#extended-resources>extended resource naming scheme</a>
as <code>vendor-domain/resourcetype</code>.
(For example, an NVIDIA GPU is advertised as <code>nvidia.com/gpu</code>.)</li></ul><p>Following a successful registration, the device plugin sends the kubelet the
list of devices it manages, and the kubelet is then in charge of advertising those
resources to the API server as part of the kubelet node status update.
For example, after a device plugin registers <code>hardware-vendor.example/foo</code> with the kubelet
and reports two healthy devices on a node, the node status is updated
to advertise that the node has 2 "Foo" devices installed and available.</p><p>Then, users can request devices as part of a Pod specification
(see <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container><code>container</code></a>).
Requesting extended resources is similar to how you manage requests and limits for
other resources, with the following differences:</p><ul><li>Extended resources are only supported as integer resources and cannot be overcommitted.</li><li>Devices cannot be shared between containers.</li></ul><h3 id=example-pod>Example</h3><p>Suppose a Kubernetes cluster is running a device plugin that advertises resource <code>hardware-vendor.example/foo</code>
on certain nodes. Here is an example of a pod requesting this resource to run a demo workload:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-container-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/pause:2.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>hardware-vendor.example/foo</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># This Pod needs 2 of the hardware-vendor.example/foo devices</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># and can only schedule onto a Node that&#39;s able to satisfy</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># that need.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># If the Node has more than 2 of those devices available, the</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># remainder would be available for other Pods to use.</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=device-plugin-implementation>Device plugin implementation</h2><p>The general workflow of a device plugin includes the following steps:</p><ul><li><p>Initialization. During this phase, the device plugin performs vendor specific
initialization and setup to make sure the devices are in a ready state.</p></li><li><p>The plugin starts a gRPC service, with a Unix socket under host path
<code>/var/lib/kubelet/device-plugins/</code>, that implements the following interfaces:</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>service DevicePlugin {
      // GetDevicePluginOptions returns options to be communicated with Device Manager.
      rpc GetDevicePluginOptions(Empty) returns (DevicePluginOptions) {}

      // ListAndWatch returns a stream of List of Devices
      // Whenever a Device state change or a Device disappears, ListAndWatch
      // returns the new list
      rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) {}

      // Allocate is called during container creation so that the Device
      // Plugin can run device specific operations and instruct Kubelet
      // of the steps to make the Device available in the container
      rpc Allocate(AllocateRequest) returns (AllocateResponse) {}

      // GetPreferredAllocation returns a preferred set of devices to allocate
      // from a list of available ones. The resulting preferred allocation is not
      // guaranteed to be the allocation ultimately performed by the
      // devicemanager. It is only designed to help the devicemanager make a more
      // informed allocation decision when possible.
      rpc GetPreferredAllocation(PreferredAllocationRequest) returns (PreferredAllocationResponse) {}

      // PreStartContainer is called, if indicated by Device Plugin during registeration phase,
      // before each container start. Device plugin can run device specific operations
      // such as resetting the device before making devices available to the container.
      rpc PreStartContainer(PreStartContainerRequest) returns (PreStartContainerResponse) {}
}
</code></pre><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Plugins are not required to provide useful implementations for
<code>GetPreferredAllocation()</code> or <code>PreStartContainer()</code>. Flags indicating which
(if any) of these calls are available should be set in the <code>DevicePluginOptions</code>
message sent back by a call to <code>GetDevicePluginOptions()</code>. The <code>kubelet</code> will
always call <code>GetDevicePluginOptions()</code> to see which optional functions are
available, before calling any of them directly.</div></li><li><p>The plugin registers itself with the kubelet through the Unix socket at host
path <code>/var/lib/kubelet/device-plugins/kubelet.sock</code>.</p></li><li><p>After successfully registering itself, the device plugin runs in serving mode, during which it keeps
monitoring device health and reports back to the kubelet upon any device state changes.
It is also responsible for serving <code>Allocate</code> gRPC requests. During <code>Allocate</code>, the device plugin may
do device-specific preparation; for example, GPU cleanup or QRNG initialization.
If the operations succeed, the device plugin returns an <code>AllocateResponse</code> that contains container
runtime configurations for accessing the allocated devices. The kubelet passes this information
to the container runtime.</p></li></ul><h3 id=handling-kubelet-restarts>Handling kubelet restarts</h3><p>A device plugin is expected to detect kubelet restarts and re-register itself with the new
kubelet instance. In the current implementation, a new kubelet instance deletes all the existing Unix sockets
under <code>/var/lib/kubelet/device-plugins</code> when it starts. A device plugin can monitor the deletion
of its Unix socket and re-register itself upon such an event.</p><h2 id=device-plugin-deployment>Device plugin deployment</h2><p>You can deploy a device plugin as a DaemonSet, as a package for your node's operating system,
or manually.</p><p>The canonical directory <code>/var/lib/kubelet/device-plugins</code> requires privileged access,
so a device plugin must run in a privileged security context.
If you're deploying a device plugin as a DaemonSet, <code>/var/lib/kubelet/device-plugins</code>
must be mounted as a <a class=glossary-tooltip title='A directory containing data, accessible to the containers in a pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a>
in the plugin's <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>.</p><p>If you choose the DaemonSet approach you can rely on Kubernetes to: place the device plugin's
Pod onto Nodes, to restart the daemon Pod after failure, and to help automate upgrades.</p><h2 id=api-compatibility>API compatibility</h2><p>Kubernetes device plugin support is in beta. The API may change before stabilization,
in incompatible ways. As a project, Kubernetes recommends that device plugin developers:</p><ul><li>Watch for changes in future releases.</li><li>Support multiple versions of the device plugin API for backward/forward compatibility.</li></ul><p>If you enable the DevicePlugins feature and run device plugins on nodes that need to be upgraded to
a Kubernetes release with a newer device plugin API version, upgrade your device plugins
to support both versions before upgrading these nodes. Taking that approach will
ensure the continuous functioning of the device allocations during the upgrade.</p><h2 id=monitoring-device-plugin-resources>Monitoring device plugin resources</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code></div><p>In order to monitor resources provided by device plugins, monitoring agents need to be able to
discover the set of devices that are in-use on the node and obtain metadata to describe which
container the metric should be associated with. <a href=https://prometheus.io/>Prometheus</a> metrics
exposed by device monitoring agents should follow the
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/instrumentation.md>Kubernetes Instrumentation Guidelines</a>,
identifying containers using <code>pod</code>, <code>namespace</code>, and <code>container</code> prometheus labels.</p><p>The kubelet provides a gRPC service to enable discovery of in-use devices, and to provide metadata
for these devices:</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>// PodResourcesLister is a service provided by the kubelet that provides information about the
// node resources consumed by pods and containers on the node
service PodResourcesLister {
    rpc List(ListPodResourcesRequest) returns (ListPodResourcesResponse) {}
    rpc GetAllocatableResources(AllocatableResourcesRequest) returns (AllocatableResourcesResponse) {}
}
</code></pre><h3 id=grpc-endpoint-list><code>List</code> gRPC endpoint</h3><p>The <code>List</code> endpoint provides information on resources of running pods, with details such as the
id of exclusively allocated CPUs, device id as it was reported by device plugins and id of
the NUMA node where these devices are allocated. Also, for NUMA-based machines, it contains the
information about memory and hugepages reserved for a container.</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>// ListPodResourcesResponse is the response returned by List function
message ListPodResourcesResponse {
    repeated PodResources pod_resources = 1;
}

// PodResources contains information about the node resources assigned to a pod
message PodResources {
    string name = 1;
    string namespace = 2;
    repeated ContainerResources containers = 3;
}

// ContainerResources contains information about the resources assigned to a container
message ContainerResources {
    string name = 1;
    repeated ContainerDevices devices = 2;
    repeated int64 cpu_ids = 3;
    repeated ContainerMemory memory = 4;
}

// ContainerMemory contains information about memory and hugepages assigned to a container
message ContainerMemory {
    string memory_type = 1;
    uint64 size = 2;
    TopologyInfo topology = 3;
}

// Topology describes hardware topology of the resource
message TopologyInfo {
        repeated NUMANode nodes = 1;
}

// NUMA representation of NUMA node
message NUMANode {
        int64 ID = 1;
}

// ContainerDevices contains information about the devices assigned to a container
message ContainerDevices {
    string resource_name = 1;
    repeated string device_ids = 2;
    TopologyInfo topology = 3;
}
</code></pre><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>cpu_ids in the <code>ContainerResources</code> in the <code>List</code> endpoint correspond to exclusive CPUs allocated
to a partilar container. If the goal is to evaluate CPUs that belong to the shared pool, the <code>List</code>
endpoint needs to be used in conjunction with the <code>GetAllocatableResources</code> endpoint as explained
below:</p><ol><li>Call <code>GetAllocatableResources</code> to get a list of all the allocatable CPUs</li><li>Call <code>GetCpuIds</code> on all <code>ContainerResources</code> in the system</li><li>Subtract out all of the CPUs from the <code>GetCpuIds</code> calls from the <code>GetAllocatableResources</code> call</li></ol></div><h3 id=grpc-endpoint-getallocatableresources><code>GetAllocatableResources</code> gRPC endpoint</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code></div><p>GetAllocatableResources provides information on resources initially available on the worker node.
It provides more information than kubelet exports to APIServer.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p><code>GetAllocatableResources</code> should only be used to evaluate <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>allocatable</a>
resources on a node. If the goal is to evaluate free/unallocated resources it should be used in
conjunction with the List() endpoint. The result obtained by <code>GetAllocatableResources</code> would remain
the same unless the underlying resources exposed to kubelet change. This happens rarely but when
it does (for example: hotplug/hotunplug, device health changes), client is expected to call
<code>GetAlloctableResources</code> endpoint.</p><p>However, calling <code>GetAllocatableResources</code> endpoint is not sufficient in case of cpu and/or memory
update and Kubelet needs to be restarted to reflect the correct resource capacity and allocatable.</p></div><pre tabindex=0><code class=language-gRPC data-lang=gRPC>// AllocatableResourcesResponses contains informations about all the devices known by the kubelet
message AllocatableResourcesResponse {
    repeated ContainerDevices devices = 1;
    repeated int64 cpu_ids = 2;
    repeated ContainerMemory memory = 3;
}
</code></pre><p>Starting from Kubernetes v1.23, the <code>GetAllocatableResources</code> is enabled by default.
You can disable it by turning off the <code>KubeletPodResourcesGetAllocatable</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>.</p><p>Preceding Kubernetes v1.23, to enable this feature <code>kubelet</code> must be started with the following flag:</p><pre tabindex=0><code>--feature-gates=KubeletPodResourcesGetAllocatable=true
</code></pre><p><code>ContainerDevices</code> do expose the topology information declaring to which NUMA cells the device is
affine. The NUMA cells are identified using a opaque integer ID, which value is consistent to
what device plugins report
<a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-integration-with-the-topology-manager>when they register themselves to the kubelet</a>.</p><p>The gRPC service is served over a unix socket at <code>/var/lib/kubelet/pod-resources/kubelet.sock</code>.
Monitoring agents for device plugin resources can be deployed as a daemon, or as a DaemonSet.
The canonical directory <code>/var/lib/kubelet/pod-resources</code> requires privileged access, so monitoring
agents must run in a privileged security context. If a device monitoring agent is running as a
DaemonSet, <code>/var/lib/kubelet/pod-resources</code> must be mounted as a
<a class=glossary-tooltip title='A directory containing data, accessible to the containers in a pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a> in the device monitoring agent's
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>.</p><p>Support for the <code>PodResourcesLister service</code> requires <code>KubeletPodResources</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> to be enabled.
It is enabled by default starting with Kubernetes 1.15 and is v1 since Kubernetes 1.20.</p><h2 id=device-plugin-integration-with-the-topology-manager>Device plugin integration with the Topology Manager</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>The Topology Manager is a Kubelet component that allows resources to be co-ordinated in a Topology
aligned manner. In order to do this, the Device Plugin API was extended to include a
<code>TopologyInfo</code> struct.</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>message TopologyInfo {
    repeated NUMANode nodes = 1;
}

message NUMANode {
    int64 ID = 1;
}
</code></pre><p>Device Plugins that wish to leverage the Topology Manager can send back a populated TopologyInfo
struct as part of the device registration, along with the device IDs and the health of the device.
The device manager will then use this information to consult with the Topology Manager and make
resource assignment decisions.</p><p><code>TopologyInfo</code> supports setting a <code>nodes</code> field to either <code>nil</code> or a list of NUMA nodes. This
allows the Device Plugin to advertise a device that spans multiple NUMA nodes.</p><p>Setting <code>TopologyInfo</code> to <code>nil</code> or providing an empty list of NUMA nodes for a given device
indicates that the Device Plugin does not have a NUMA affinity preference for that device.</p><p>An example <code>TopologyInfo</code> struct populated for a device by a Device Plugin:</p><pre tabindex=0><code>pluginapi.Device{ID: &#34;25102017&#34;, Health: pluginapi.Healthy, Topology:&amp;pluginapi.TopologyInfo{Nodes: []*pluginapi.NUMANode{&amp;pluginapi.NUMANode{ID: 0,},}}}
</code></pre><h2 id=examples>Device plugin examples</h2><div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div><p>Here are some examples of device plugin implementations:</p><ul><li>The <a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>AMD GPU device plugin</a></li><li>The <a href=https://github.com/intel/intel-device-plugins-for-kubernetes>Intel device plugins</a> for
Intel GPU, FPGA, QAT, VPU, SGX, DSA, DLB and IAA devices</li><li>The <a href=https://github.com/kubevirt/kubernetes-device-plugins>KubeVirt device plugins</a> for
hardware-assisted virtualization</li><li>The <a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu>NVIDIA GPU device plugin for Container-Optimized OS</a></li><li>The <a href=https://github.com/hustcat/k8s-rdma-device-plugin>RDMA device plugin</a></li><li>The <a href=https://github.com/collabora/k8s-socketcan>SocketCAN device plugin</a></li><li>The <a href=https://github.com/vikaschoudhary16/sfc-device-plugin>Solarflare device plugin</a></li><li>The <a href=https://github.com/intel/sriov-network-device-plugin>SR-IOV Network device plugin</a></li><li>The <a href=https://github.com/Xilinx/FPGA_as_a_Service/tree/master/k8s-device-plugin>Xilinx FPGA device plugins</a> for Xilinx FPGA devices</li></ul><h2 id=what-s-next>What's next</h2><ul><li>Learn about <a href=/docs/tasks/manage-gpus/scheduling-gpus/>scheduling GPU resources</a> using device
plugins</li><li>Learn about <a href=/docs/tasks/administer-cluster/extended-resource-node/>advertising extended resources</a>
on a node</li><li>Learn about the <a href=/docs/tasks/administer-cluster/topology-manager/>Topology Manager</a></li><li>Read about using <a href=/blog/2019/04/24/hardware-accelerated-ssl/tls-termination-in-ingress-controllers-using-kubernetes-device-plugins-and-runtimeclass/>hardware acceleration for TLS ingress</a>
with Kubernetes</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/docs/home/>Home</a>
<a class=text-white href=/blog/>Blog</a>
<a class=text-white href=/training/>Training</a>
<a class=text-white href=/partners/>Partners</a>
<a class=text-white href=/community/>Community</a>
<a class=text-white href=/case-studies/>Case Studies</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>