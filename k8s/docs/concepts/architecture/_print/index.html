<!doctype html><html lang=en class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/architecture/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/architecture/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/architecture/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/architecture/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/architecture/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/architecture/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/architecture/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/architecture/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/architecture/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/architecture/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/architecture/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/docs/concepts/architecture/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Cluster Architecture | Kubernetes</title><meta property="og:title" content="Cluster Architecture"><meta property="og:description" content="The architectural concepts behind Kubernetes.
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/docs/concepts/architecture/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Cluster Architecture"><meta itemprop=description content="The architectural concepts behind Kubernetes.
"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cluster Architecture"><meta name=twitter:description content="The architectural concepts behind Kubernetes.
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="The architectural concepts behind Kubernetes.
"><meta property="og:description" content="The architectural concepts behind Kubernetes.
"><meta name=twitter:description content="The architectural concepts behind Kubernetes.
"><meta property="og:url" content="https://kubernetes.io/docs/concepts/architecture/"><meta property="og:title" content="Cluster Architecture"><meta name=twitter:title content="Cluster Architecture"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/docs/>Documentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/training/>Training</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/partners/>Partners</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/case-studies/>Case Studies</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/docs/concepts/architecture/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/docs/concepts/architecture/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/docs/concepts/architecture/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/docs/concepts/architecture/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/docs/concepts/architecture/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>English</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/docs/concepts/architecture/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/architecture/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/architecture/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/architecture/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/architecture/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/architecture/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/architecture/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/architecture/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/architecture/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/architecture/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/concepts/architecture/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/concepts/architecture/>Return to the regular view of this page</a>.</p></div><h1 class=title>Cluster Architecture</h1><div class=lead>The architectural concepts behind Kubernetes.</div><ul><li>1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Nodes</a></li><li>2: <a href=#pg-c0251def6da29b30afebfb04549f1703>Communication between Nodes and the Control Plane</a></li><li>3: <a href=#pg-ca8819042a505291540e831283da66df>Controllers</a></li><li>4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Cloud Controller Manager</a></li><li>5: <a href=#pg-c20ec7d296cc2c8668bb204c2af31180>About cgroup v2</a></li><li>6: <a href=#pg-c0ea5310f52e22c5de34dc84d9ab5e0d>Container Runtime Interface (CRI)</a></li><li>7: <a href=#pg-44a2e2e592af0846101e970aff9243e5>Garbage Collection</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>1 - Nodes</h1><p>Kubernetes runs your workload by placing containers into Pods to run on <em>Nodes</em>.
A node may be a virtual or physical machine, depending on the cluster. Each node
is managed by the
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>
and contains the services necessary to run
<a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a>.</p><p>Typically you have several nodes in a cluster; in a learning or resource-limited
environment, you might have only one node.</p><p>The <a href=/docs/concepts/overview/components/#node-components>components</a> on a node include the
<a class=glossary-tooltip title='An agent that runs on each node in the cluster. It makes sure that containers are running in a pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>, a
<a class=glossary-tooltip title='The container runtime is the software that is responsible for running containers.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a>, and the
<a class=glossary-tooltip title='kube-proxy is a network proxy that runs on each node in the cluster.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>.</p><h2 id=management>Management</h2><p>There are two main ways to have Nodes added to the <a class=glossary-tooltip title='Control plane component that serves the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a>:</p><ol><li>The kubelet on a node self-registers to the control plane</li><li>You (or another human user) manually add a Node object</li></ol><p>After you create a Node <a class=glossary-tooltip title='A entity in the Kubernetes system, representing part of the state of your cluster.' data-toggle=tooltip data-placement=top href=https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects target=_blank aria-label=object>object</a>,
or the kubelet on a node self-registers, the control plane checks whether the new Node object is
valid. For example, if you try to create a Node from the following JSON manifest:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kubernetes creates a Node object internally (the representation). Kubernetes checks
that a kubelet has registered to the API server that matches the <code>metadata.name</code>
field of the Node. If the node is healthy (i.e. all necessary services are running),
then it is eligible to run a Pod. Otherwise, that node is ignored for any cluster activity
until it becomes healthy.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Kubernetes keeps the object for the invalid Node and continues checking to see whether
it becomes healthy.</p><p>You, or a <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>, must explicitly
delete the Node object to stop that health checking.</p></div><p>The name of a Node object must be a valid
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS subdomain name</a>.</p><h3 id=node-name-uniqueness>Node name uniqueness</h3><p>The <a href=/docs/concepts/overview/working-with-objects/names#names>name</a> identifies a Node. Two Nodes
cannot have the same name at the same time. Kubernetes also assumes that a resource with the same
name is the same object. In case of a Node, it is implicitly assumed that an instance using the
same name will have the same state (e.g. network settings, root disk contents)
and attributes like node labels. This may lead to
inconsistencies if an instance was modified without changing its name. If the Node needs to be
replaced or updated significantly, the existing Node object needs to be removed from API server
first and re-added after the update.</p><h3 id=self-registration-of-nodes>Self-registration of Nodes</h3><p>When the kubelet flag <code>--register-node</code> is true (the default), the kubelet will attempt to
register itself with the API server. This is the preferred pattern, used by most distros.</p><p>For self-registration, the kubelet is started with the following options:</p><ul><li><p><code>--kubeconfig</code> - Path to credentials to authenticate itself to the API server.</p></li><li><p><code>--cloud-provider</code> - How to talk to a <a class=glossary-tooltip title='An organization that offers a cloud computing platform.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-cloud-provider' target=_blank aria-label='cloud provider'>cloud provider</a>
to read metadata about itself.</p></li><li><p><code>--register-node</code> - Automatically register with the API server.</p></li><li><p><code>--register-with-taints</code> - Register the node with the given list of
<a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taints>taints</a> (comma separated <code>&lt;key>=&lt;value>:&lt;effect></code>).</p><p>No-op if <code>register-node</code> is false.</p></li><li><p><code>--node-ip</code> - IP address of the node.</p></li><li><p><code>--node-labels</code> - <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Labels>Labels</a> to add when registering the node
in the cluster (see label restrictions enforced by the
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>).</p></li><li><p><code>--node-status-update-frequency</code> - Specifies how often kubelet posts its node status to the API server.</p></li></ul><p>When the <a href=/docs/reference/access-authn-authz/node/>Node authorization mode</a> and
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>
are enabled, kubelets are only authorized to create/modify their own Node resource.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>As mentioned in the <a href=#node-name-uniqueness>Node name uniqueness</a> section,
when Node configuration needs to be updated, it is a good practice to re-register
the node with the API server. For example, if the kubelet being restarted with
the new set of <code>--node-labels</code>, but the same Node name is used, the change will
not take an effect, as labels are being set on the Node registration.</p><p>Pods already scheduled on the Node may misbehave or cause issues if the Node
configuration will be changed on kubelet restart. For example, already running
Pod may be tainted against the new labels assigned to the Node, while other
Pods, that are incompatible with that Pod will be scheduled based on this new
label. Node re-registration ensures all Pods will be drained and properly
re-scheduled.</p></div><h3 id=manual-node-administration>Manual Node administration</h3><p>You can create and modify Node objects using
<a class=glossary-tooltip title='A command line tool for communicating with a Kubernetes cluster.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>.</p><p>When you want to create Node objects manually, set the kubelet flag <code>--register-node=false</code>.</p><p>You can modify Node objects regardless of the setting of <code>--register-node</code>.
For example, you can set labels on an existing Node or mark it unschedulable.</p><p>You can use labels on Nodes in conjunction with node selectors on Pods to control
scheduling. For example, you can constrain a Pod to only be eligible to run on
a subset of the available nodes.</p><p>Marking a node as unschedulable prevents the scheduler from placing new pods onto
that Node but does not affect existing Pods on the Node. This is useful as a
preparatory step before a node reboot or other maintenance.</p><p>To mark a Node unschedulable, run:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</span></span></code></pre></div><p>See <a href=/docs/tasks/administer-cluster/safely-drain-node/>Safely Drain a Node</a>
for more details.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Pods that are part of a <a class=glossary-tooltip title='Ensures a copy of a Pod is running across a set of nodes in a cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a> tolerate
being run on an unschedulable Node. DaemonSets typically provide node-local services
that should run on the Node even if it is being drained of workload applications.</div><h2 id=node-status>Node status</h2><p>A Node's status contains the following information:</p><ul><li><a href=#addresses>Addresses</a></li><li><a href=#condition>Conditions</a></li><li><a href=#capacity>Capacity and Allocatable</a></li><li><a href=#info>Info</a></li></ul><p>You can use <code>kubectl</code> to view a Node's status and other details:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node &lt;insert-node-name-here&gt;
</span></span></code></pre></div><p>Each section of the output is described below.</p><h3 id=addresses>Addresses</h3><p>The usage of these fields varies depending on your cloud provider or bare metal configuration.</p><ul><li>HostName: The hostname as reported by the node's kernel. Can be overridden via the kubelet
<code>--hostname-override</code> parameter.</li><li>ExternalIP: Typically the IP address of the node that is externally routable (available from
outside the cluster).</li><li>InternalIP: Typically the IP address of the node that is routable only within the cluster.</li></ul><h3 id=condition>Conditions</h3><p>The <code>conditions</code> field describes the status of all <code>Running</code> nodes. Examples of conditions include:</p><table><caption style=display:none>Node conditions, and a description of when each condition applies.</caption><thead><tr><th>Node Condition</th><th>Description</th></tr></thead><tbody><tr><td><code>Ready</code></td><td><code>True</code> if the node is healthy and ready to accept pods, <code>False</code> if the node is not healthy and is not accepting pods, and <code>Unknown</code> if the node controller has not heard from the node in the last <code>node-monitor-grace-period</code> (default is 40 seconds)</td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> if pressure exists on the disk size—that is, if the disk capacity is low; otherwise <code>False</code></td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> if pressure exists on the node memory—that is, if the node memory is low; otherwise <code>False</code></td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> if pressure exists on the processes—that is, if there are too many processes on the node; otherwise <code>False</code></td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> if the network for the node is not correctly configured, otherwise <code>False</code></td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Note:</strong> If you use command-line tools to print details of a cordoned Node, the Condition includes
<code>SchedulingDisabled</code>. <code>SchedulingDisabled</code> is not a Condition in the Kubernetes API; instead,
cordoned nodes are marked Unschedulable in their spec.</div><p>In the Kubernetes API, a node's condition is represented as part of the <code>.status</code>
of the Node resource. For example, the following JSON structure describes a healthy node:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>If the <code>status</code> of the Ready condition remains <code>Unknown</code> or <code>False</code> for longer
than the <code>pod-eviction-timeout</code> (an argument passed to the
<a class=glossary-tooltip title='Control Plane component that runs controller processes.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>), then the <a href=#node-controller>node controller</a> triggers
<a class=glossary-tooltip title='API-initiated eviction is the process by which you use the Eviction API to create an Eviction object that triggers graceful pod termination.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/api-eviction/ target=_blank aria-label='API-initiated eviction'>API-initiated eviction</a>
for all Pods assigned to that node. The default eviction timeout duration is
<strong>five minutes</strong>.
In some cases when the node is unreachable, the API server is unable to communicate
with the kubelet on the node. The decision to delete the pods cannot be communicated to
the kubelet until communication with the API server is re-established. In the meantime,
the pods that are scheduled for deletion may continue to run on the partitioned node.</p><p>The node controller does not force delete pods until it is confirmed that they have stopped
running in the cluster. You can see the pods that might be running on an unreachable node as
being in the <code>Terminating</code> or <code>Unknown</code> state. In cases where Kubernetes cannot deduce from the
underlying infrastructure if a node has permanently left a cluster, the cluster administrator
may need to delete the node object by hand. Deleting the node object from Kubernetes causes
all the Pod objects running on the node to be deleted from the API server and frees up their
names.</p><p>When problems occur on nodes, the Kubernetes control plane automatically creates
<a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>taints</a> that match the conditions
affecting the node.
The scheduler takes the Node's taints into consideration when assigning a Pod to a Node.
Pods can also have <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Tolerations enable the scheduling of pods on nodes or node groups that have a matching taint.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=tolerations>tolerations</a> that let
them run on a Node even though it has a specific taint.</p><p>See <a href=/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-nodes-by-condition>Taint Nodes by Condition</a>
for more details.</p><h3 id=capacity>Capacity and Allocatable</h3><p>Describes the resources available on the node: CPU, memory, and the maximum
number of pods that can be scheduled onto the node.</p><p>The fields in the capacity block indicate the total amount of resources that a
Node has. The allocatable block indicates the amount of resources on a
Node that is available to be consumed by normal Pods.</p><p>You may read more about capacity and allocatable resources while learning how
to <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>reserve compute resources</a>
on a Node.</p><h3 id=info>Info</h3><p>Describes general information about the node, such as kernel version, Kubernetes
version (kubelet and kube-proxy version), container runtime details, and which
operating system the node uses.
The kubelet gathers this information from the node and publishes it into
the Kubernetes API.</p><h2 id=heartbeats>Heartbeats</h2><p>Heartbeats, sent by Kubernetes nodes, help your cluster determine the
availability of each node, and to take action when failures are detected.</p><p>For nodes there are two forms of heartbeats:</p><ul><li>updates to the <code>.status</code> of a Node</li><li><a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>Lease</a> objects
within the <code>kube-node-lease</code>
<a class=glossary-tooltip title='An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Each Node has an associated Lease object.</li></ul><p>Compared to updates to <code>.status</code> of a Node, a Lease is a lightweight resource.
Using Leases for heartbeats reduces the performance impact of these updates
for large clusters.</p><p>The kubelet is responsible for creating and updating the <code>.status</code> of Nodes,
and for updating their related Leases.</p><ul><li>The kubelet updates the node's <code>.status</code> either when there is change in status
or if there has been no update for a configured interval. The default interval
for <code>.status</code> updates to Nodes is 5 minutes, which is much longer than the 40
second default timeout for unreachable nodes.</li><li>The kubelet creates and then updates its Lease object every 10 seconds
(the default update interval). Lease updates occur independently from
updates to the Node's <code>.status</code>. If the Lease update fails, the kubelet retries,
using exponential backoff that starts at 200 milliseconds and capped at 7 seconds.</li></ul><h2 id=node-controller>Node controller</h2><p>The node <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> is a
Kubernetes control plane component that manages various aspects of nodes.</p><p>The node controller has multiple roles in a node's life. The first is assigning a
CIDR block to the node when it is registered (if CIDR assignment is turned on).</p><p>The second is keeping the node controller's internal list of nodes up to date with
the cloud provider's list of available machines. When running in a cloud
environment and whenever a node is unhealthy, the node controller asks the cloud
provider if the VM for that node is still available. If not, the node
controller deletes the node from its list of nodes.</p><p>The third is monitoring the nodes' health. The node controller is
responsible for:</p><ul><li>In the case that a node becomes unreachable, updating the <code>Ready</code> condition
in the Node's <code>.status</code> field. In this case the node controller sets the
<code>Ready</code> condition to <code>Unknown</code>.</li><li>If a node remains unreachable: triggering
<a href=/docs/concepts/scheduling-eviction/api-eviction/>API-initiated eviction</a>
for all of the Pods on the unreachable node. By default, the node controller
waits 5 minutes between marking the node as <code>Unknown</code> and submitting
the first eviction request.</li></ul><p>By default, the node controller checks the state of each node every 5 seconds.
This period can be configured using the <code>--node-monitor-period</code> flag on the
<code>kube-controller-manager</code> component.</p><h3 id=rate-limits-on-eviction>Rate limits on eviction</h3><p>In most cases, the node controller limits the eviction rate to
<code>--node-eviction-rate</code> (default 0.1) per second, meaning it won't evict pods
from more than 1 node per 10 seconds.</p><p>The node eviction behavior changes when a node in a given availability zone
becomes unhealthy. The node controller checks what percentage of nodes in the zone
are unhealthy (the <code>Ready</code> condition is <code>Unknown</code> or <code>False</code>) at
the same time:</p><ul><li>If the fraction of unhealthy nodes is at least <code>--unhealthy-zone-threshold</code>
(default 0.55), then the eviction rate is reduced.</li><li>If the cluster is small (i.e. has less than or equal to
<code>--large-cluster-size-threshold</code> nodes - default 50), then evictions are stopped.</li><li>Otherwise, the eviction rate is reduced to <code>--secondary-node-eviction-rate</code>
(default 0.01) per second.</li></ul><p>The reason these policies are implemented per availability zone is because one
availability zone might become partitioned from the control plane while the others remain
connected. If your cluster does not span multiple cloud provider availability zones,
then the eviction mechanism does not take per-zone unavailability into account.</p><p>A key reason for spreading your nodes across availability zones is so that the
workload can be shifted to healthy zones when one entire zone goes down.
Therefore, if all nodes in a zone are unhealthy, then the node controller evicts at
the normal rate of <code>--node-eviction-rate</code>. The corner case is when all zones are
completely unhealthy (none of the nodes in the cluster are healthy). In such a
case, the node controller assumes that there is some problem with connectivity
between the control plane and the nodes, and doesn't perform any evictions.
(If there has been an outage and some nodes reappear, the node controller does
evict pods from the remaining nodes that are unhealthy or unreachable).</p><p>The node controller is also responsible for evicting pods running on nodes with
<code>NoExecute</code> taints, unless those pods tolerate that taint.
The node controller also adds <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taints>taints</a>
corresponding to node problems like node unreachable or not ready. This means
that the scheduler won't place Pods onto unhealthy nodes.</p><h2 id=node-capacity>Resource capacity tracking</h2><p>Node objects track information about the Node's resource capacity: for example, the amount
of memory available and the number of CPUs.
Nodes that <a href=#self-registration-of-nodes>self register</a> report their capacity during
registration. If you <a href=#manual-node-administration>manually</a> add a Node, then
you need to set the node's capacity information when you add it.</p><p>The Kubernetes <a class=glossary-tooltip title='Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a> ensures that
there are enough resources for all the Pods on a Node. The scheduler checks that the sum
of the requests of containers on the node is no greater than the node's capacity.
That sum of requests includes all containers managed by the kubelet, but excludes any
containers started directly by the container runtime, and also excludes any
processes running outside of the kubelet's control.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> If you want to explicitly reserve resources for non-Pod processes, see
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>reserve resources for system daemons</a>.</div><h2 id=node-topology>Node topology</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>If you have enabled the <code>TopologyManager</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>, then
the kubelet can use topology hints when making resource assignment decisions.
See <a href=/docs/tasks/administer-cluster/topology-manager/>Control Topology Management Policies on a Node</a>
for more information.</p><h2 id=graceful-node-shutdown>Graceful node shutdown</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p>The kubelet attempts to detect node system shutdown and terminates pods running on the node.</p><p>Kubelet ensures that pods follow the normal
<a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>pod termination process</a>
during the node shutdown.</p><p>The Graceful node shutdown feature depends on systemd since it takes advantage of
<a href=https://www.freedesktop.org/wiki/Software/systemd/inhibit/>systemd inhibitor locks</a> to
delay the node shutdown with a given duration.</p><p>Graceful node shutdown is controlled with the <code>GracefulNodeShutdown</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> which is
enabled by default in 1.21.</p><p>Note that by default, both configuration options described below,
<code>shutdownGracePeriod</code> and <code>shutdownGracePeriodCriticalPods</code> are set to zero,
thus not activating the graceful node shutdown functionality.
To activate the feature, the two kubelet config settings should be configured appropriately and
set to non-zero values.</p><p>During a graceful shutdown, kubelet terminates pods in two phases:</p><ol><li>Terminate regular pods running on the node.</li><li>Terminate <a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>
running on the node.</li></ol><p>Graceful node shutdown feature is configured with two
<a href=/docs/tasks/administer-cluster/kubelet-config-file/><code>KubeletConfiguration</code></a> options:</p><ul><li><code>shutdownGracePeriod</code>:<ul><li>Specifies the total duration that the node should delay the shutdown by. This is the total
grace period for pod termination for both regular and
<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>.</li></ul></li><li><code>shutdownGracePeriodCriticalPods</code>:<ul><li>Specifies the duration used to terminate
<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>
during a node shutdown. This value should be less than <code>shutdownGracePeriod</code>.</li></ul></li></ul><p>For example, if <code>shutdownGracePeriod=30s</code>, and
<code>shutdownGracePeriodCriticalPods=10s</code>, kubelet will delay the node shutdown by
30 seconds. During the shutdown, the first 20 (30-10) seconds would be reserved
for gracefully terminating normal pods, and the last 10 seconds would be
reserved for terminating <a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>When pods were evicted during the graceful node shutdown, they are marked as shutdown.
Running <code>kubectl get pods</code> shows the status of the evicted pods as <code>Terminated</code>.
And <code>kubectl describe pod</code> indicates that the pod was evicted because of node shutdown:</p><pre tabindex=0><code>Reason:         Terminated
Message:        Pod was terminated in response to imminent node shutdown.
</code></pre></div><h2 id=non-graceful-node-shutdown>Non Graceful node shutdown</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [alpha]</code></div><p>A node shutdown action may not be detected by kubelet's Node Shutdown Manager,
either because the command does not trigger the inhibitor locks mechanism used by
kubelet or because of a user error, i.e., the ShutdownGracePeriod and
ShutdownGracePeriodCriticalPods are not configured properly. Please refer to above
section <a href=#graceful-node-shutdown>Graceful Node Shutdown</a> for more details.</p><p>When a node is shutdown but not detected by kubelet's Node Shutdown Manager, the pods
that are part of a StatefulSet will be stuck in terminating status on
the shutdown node and cannot move to a new running node. This is because kubelet on
the shutdown node is not available to delete the pods so the StatefulSet cannot
create a new pod with the same name. If there are volumes used by the pods, the
VolumeAttachments will not be deleted from the original shutdown node so the volumes
used by these pods cannot be attached to a new running node. As a result, the
application running on the StatefulSet cannot function properly. If the original
shutdown node comes up, the pods will be deleted by kubelet and new pods will be
created on a different running node. If the original shutdown node does not come up,<br>these pods will be stuck in terminating status on the shutdown node forever.</p><p>To mitigate the above situation, a user can manually add the taint <code>node.kubernetes.io/out-of-service</code> with either <code>NoExecute</code>
or <code>NoSchedule</code> effect to a Node marking it out-of-service.
If the <code>NodeOutOfServiceVolumeDetach</code><a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
is enabled on <code>kube-controller-manager</code>, and a Node is marked out-of-service with this taint, the
pods on the node will be forcefully deleted if there are no matching tolerations on it and volume
detach operations for the pods terminating on the node will happen immediately. This allows the
Pods on the out-of-service node to recover quickly on a different node.</p><p>During a non-graceful shutdown, Pods are terminated in the two phases:</p><ol><li>Force delete the Pods that do not have matching <code>out-of-service</code> tolerations.</li><li>Immediately perform detach volume operation for such pods.</li></ol><div class="alert alert-info note callout" role=alert><strong>Note:</strong><ul><li>Before adding the taint <code>node.kubernetes.io/out-of-service</code> , it should be verified
that the node is already in shutdown or power off state (not in the middle of
restarting).</li><li>The user is required to manually remove the out-of-service taint after the pods are
moved to a new node and the user has checked that the shutdown node has been
recovered since the user was the one who originally added the taint.</li></ul></div><h3 id=pod-priority-graceful-node-shutdown>Pod Priority based graceful node shutdown</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code></div><p>To provide more flexibility during graceful node shutdown around the ordering
of pods during shutdown, graceful node shutdown honors the PriorityClass for
Pods, provided that you enabled this feature in your cluster. The feature
allows cluster administers to explicitly define the ordering of pods
during graceful node shutdown based on
<a href=/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass>priority classes</a>.</p><p>The <a href=#graceful-node-shutdown>Graceful Node Shutdown</a> feature, as described
above, shuts down pods in two phases, non-critical pods, followed by critical
pods. If additional flexibility is needed to explicitly define the ordering of
pods during shutdown in a more granular way, pod priority based graceful
shutdown can be used.</p><p>When graceful node shutdown honors pod priorities, this makes it possible to do
graceful node shutdown in multiple phases, each phase shutting down a
particular priority class of pods. The kubelet can be configured with the exact
phases and shutdown time per phase.</p><p>Assuming the following custom pod
<a href=/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass>priority classes</a>
in a cluster,</p><table><thead><tr><th>Pod priority class name</th><th>Pod priority class value</th></tr></thead><tbody><tr><td><code>custom-class-a</code></td><td>100000</td></tr><tr><td><code>custom-class-b</code></td><td>10000</td></tr><tr><td><code>custom-class-c</code></td><td>1000</td></tr><tr><td><code>regular/unset</code></td><td>0</td></tr></tbody></table><p>Within the <a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>kubelet configuration</a>
the settings for <code>shutdownGracePeriodByPodPriority</code> could look like:</p><table><thead><tr><th>Pod priority class value</th><th>Shutdown period</th></tr></thead><tbody><tr><td>100000</td><td>10 seconds</td></tr><tr><td>10000</td><td>180 seconds</td></tr><tr><td>1000</td><td>120 seconds</td></tr><tr><td>0</td><td>60 seconds</td></tr></tbody></table><p>The corresponding kubelet config YAML configuration would be:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>shutdownGracePeriodByPodPriority</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>100000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>10000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>180</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>120</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>The above table implies that any pod with <code>priority</code> value >= 100000 will get
just 10 seconds to stop, any pod with value >= 10000 and &lt; 100000 will get 180
seconds to stop, any pod with value >= 1000 and &lt; 10000 will get 120 seconds to stop.
Finally, all other pods will get 60 seconds to stop.</p><p>One doesn't have to specify values corresponding to all of the classes. For
example, you could instead use these settings:</p><table><thead><tr><th>Pod priority class value</th><th>Shutdown period</th></tr></thead><tbody><tr><td>100000</td><td>300 seconds</td></tr><tr><td>1000</td><td>120 seconds</td></tr><tr><td>0</td><td>60 seconds</td></tr></tbody></table><p>In the above case, the pods with <code>custom-class-b</code> will go into the same bucket
as <code>custom-class-c</code> for shutdown.</p><p>If there are no pods in a particular range, then the kubelet does not wait
for pods in that priority range. Instead, the kubelet immediately skips to the
next priority class value range.</p><p>If this feature is enabled and no configuration is provided, then no ordering
action will be taken.</p><p>Using this feature requires enabling the <code>GracefulNodeShutdownBasedOnPodPriority</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
, and setting <code>ShutdownGracePeriodByPodPriority</code> in the
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>kubelet config</a>
to the desired configuration containing the pod priority class values and
their respective shutdown periods.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> The ability to take Pod priority into account during graceful node shutdown was introduced
as an Alpha feature in Kubernetes v1.23. In Kubernetes 1.25
the feature is Beta and is enabled by default.</div><p>Metrics <code>graceful_shutdown_start_time_seconds</code> and <code>graceful_shutdown_end_time_seconds</code>
are emitted under the kubelet subsystem to monitor node shutdowns.</p><h2 id=swap-memory>Swap memory management</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code></div><p>Prior to Kubernetes 1.22, nodes did not support the use of swap memory, and a
kubelet would by default fail to start if swap was detected on a node. In 1.22
onwards, swap memory support can be enabled on a per-node basis.</p><p>To enable swap on a node, the <code>NodeSwap</code> feature gate must be enabled on
the kubelet, and the <code>--fail-swap-on</code> command line flag or <code>failSwapOn</code>
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>configuration setting</a>
must be set to false.</p><div class="alert alert-danger warning callout" role=alert><strong>Warning:</strong> When the memory swap feature is turned on, Kubernetes data such as the content
of Secret objects that were written to tmpfs now could be swapped to disk.</div><p>A user can also optionally configure <code>memorySwap.swapBehavior</code> in order to
specify how a node will use swap memory. For example,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>memorySwap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>swapBehavior</span>:<span style=color:#bbb> </span>LimitedSwap<span style=color:#bbb>
</span></span></span></code></pre></div><p>The available configuration options for <code>swapBehavior</code> are:</p><ul><li><code>LimitedSwap</code>: Kubernetes workloads are limited in how much swap they can
use. Workloads on the node not managed by Kubernetes can still swap.</li><li><code>UnlimitedSwap</code>: Kubernetes workloads can use as much swap memory as they
request, up to the system limit.</li></ul><p>If configuration for <code>memorySwap</code> is not specified and the feature gate is
enabled, by default the kubelet will apply the same behaviour as the
<code>LimitedSwap</code> setting.</p><p>The behaviour of the <code>LimitedSwap</code> setting depends if the node is running with
v1 or v2 of control groups (also known as "cgroups"):</p><ul><li><strong>cgroupsv1:</strong> Kubernetes workloads can use any combination of memory and
swap, up to the pod's memory limit, if set.</li><li><strong>cgroupsv2:</strong> Kubernetes workloads cannot use swap memory.</li></ul><p>For more information, and to assist with testing and provide feedback, please
see <a href=https://github.com/kubernetes/enhancements/issues/2400>KEP-2400</a> and its
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md>design proposal</a>.</p><h2 id=what-s-next>What's next</h2><ul><li>Learn about the <a href=/docs/concepts/overview/components/#node-components>components</a> that make up a node.</li><li>Read the <a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>API definition for Node</a>.</li><li>Read the <a href=https://git.k8s.io/design-proposals-archive/architecture/architecture.md#the-kubernetes-node>Node</a>
section of the architecture design document.</li><li>Read about <a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>taints and tolerations</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>2 - Communication between Nodes and the Control Plane</h1><p>This document catalogs the communication paths between the API server and the Kubernetes cluster.
The intent is to allow users to customize their installation to harden the network configuration
such that the cluster can be run on an untrusted network (or on fully public IPs on a cloud
provider).</p><h2 id=node-to-control-plane>Node to Control Plane</h2><p>Kubernetes has a "hub-and-spoke" API pattern. All API usage from nodes (or the pods they run)
terminates at the API server. None of the other control plane components are designed to expose
remote services. The API server is configured to listen for remote connections on a secure HTTPS
port (typically 443) with one or more forms of client
<a href=/docs/reference/access-authn-authz/authentication/>authentication</a> enabled.
One or more forms of <a href=/docs/reference/access-authn-authz/authorization/>authorization</a> should be
enabled, especially if <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>anonymous requests</a>
or <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>service account tokens</a>
are allowed.</p><p>Nodes should be provisioned with the public root certificate for the cluster such that they can
connect securely to the API server along with valid client credentials. A good approach is that the
client credentials provided to the kubelet are in the form of a client certificate. See
<a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>kubelet TLS bootstrapping</a>
for automated provisioning of kubelet client certificates.</p><p>Pods that wish to connect to the API server can do so securely by leveraging a service account so
that Kubernetes will automatically inject the public root certificate and a valid bearer token
into the pod when it is instantiated.
The <code>kubernetes</code> service (in <code>default</code> namespace) is configured with a virtual IP address that is
redirected (via <code>kube-proxy</code>) to the HTTPS endpoint on the API server.</p><p>The control plane components also communicate with the API server over the secure port.</p><p>As a result, the default operating mode for connections from the nodes and pods running on the
nodes to the control plane is secured by default and can run over untrusted and/or public
networks.</p><h2 id=control-plane-to-node>Control plane to node</h2><p>There are two primary communication paths from the control plane (the API server) to the nodes.
The first is from the API server to the kubelet process which runs on each node in the cluster.
The second is from the API server to any node, pod, or service through the API server's <em>proxy</em>
functionality.</p><h3 id=api-server-to-kubelet>API server to kubelet</h3><p>The connections from the API server to the kubelet are used for:</p><ul><li>Fetching logs for pods.</li><li>Attaching (usually through <code>kubectl</code>) to running pods.</li><li>Providing the kubelet's port-forwarding functionality.</li></ul><p>These connections terminate at the kubelet's HTTPS endpoint. By default, the API server does not
verify the kubelet's serving certificate, which makes the connection subject to man-in-the-middle
attacks and <strong>unsafe</strong> to run over untrusted and/or public networks.</p><p>To verify this connection, use the <code>--kubelet-certificate-authority</code> flag to provide the API
server with a root certificate bundle to use to verify the kubelet's serving certificate.</p><p>If that is not possible, use <a href=#ssh-tunnels>SSH tunneling</a> between the API server and kubelet if
required to avoid connecting over an
untrusted or public network.</p><p>Finally, <a href=/docs/reference/access-authn-authz/kubelet-authn-authz/>Kubelet authentication and/or authorization</a>
should be enabled to secure the kubelet API.</p><h3 id=api-server-to-nodes-pods-and-services>API server to nodes, pods, and services</h3><p>The connections from the API server to a node, pod, or service default to plain HTTP connections
and are therefore neither authenticated nor encrypted. They can be run over a secure HTTPS
connection by prefixing <code>https:</code> to the node, pod, or service name in the API URL, but they will
not validate the certificate provided by the HTTPS endpoint nor provide client credentials. So
while the connection will be encrypted, it will not provide any guarantees of integrity. These
connections <strong>are not currently safe</strong> to run over untrusted or public networks.</p><h3 id=ssh-tunnels>SSH tunnels</h3><p>Kubernetes supports SSH tunnels to protect the control plane to nodes communication paths. In this
configuration, the API server initiates an SSH tunnel to each node in the cluster (connecting to
the SSH server listening on port 22) and passes all traffic destined for a kubelet, node, pod, or
service through the tunnel.
This tunnel ensures that the traffic is not exposed outside of the network in which the nodes are
running.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> SSH tunnels are currently deprecated, so you shouldn't opt to use them unless you know what you
are doing. The <a href=#konnectivity-service>Konnectivity service</a> is a replacement for this
communication channel.</div><h3 id=konnectivity-service>Konnectivity service</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>As a replacement to the SSH tunnels, the Konnectivity service provides TCP level proxy for the
control plane to cluster communication. The Konnectivity service consists of two parts: the
Konnectivity server in the control plane network and the Konnectivity agents in the nodes network.
The Konnectivity agents initiate connections to the Konnectivity server and maintain the network
connections.
After enabling the Konnectivity service, all control plane to nodes traffic goes through these
connections.</p><p>Follow the <a href=/docs/tasks/extend-kubernetes/setup-konnectivity/>Konnectivity service task</a> to set
up the Konnectivity service in your cluster.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>3 - Controllers</h1><p>In robotics and automation, a <em>control loop</em> is
a non-terminating loop that regulates the state of a system.</p><p>Here is one example of a control loop: a thermostat in a room.</p><p>When you set the temperature, that's telling the thermostat
about your <em>desired state</em>. The actual room temperature is the
<em>current state</em>. The thermostat acts to bring the current state
closer to the desired state, by turning equipment on or off.</p>In Kubernetes, controllers are control loops that watch the state of your
<a class=glossary-tooltip title='A set of worker machines, called nodes, that run containerized applications. Every cluster has at least one worker node.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=cluster>cluster</a>, then make or request
changes where needed.
Each controller tries to move the current cluster state closer to the desired
state.<h2 id=controller-pattern>Controller pattern</h2><p>A controller tracks at least one Kubernetes resource type.
These <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>objects</a>
have a spec field that represents the desired state. The
controller(s) for that resource are responsible for making the current
state come closer to that desired state.</p><p>The controller might carry the action out itself; more commonly, in Kubernetes,
a controller will send messages to the
<a class=glossary-tooltip title='Control plane component that serves the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a> that have
useful side effects. You'll see examples of this below.</p><h3 id=control-via-api-server>Control via API server</h3><p>The <a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> controller is an example of a
Kubernetes built-in controller. Built-in controllers manage state by
interacting with the cluster API server.</p><p>Job is a Kubernetes resource that runs a
<a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>, or perhaps several Pods, to carry out
a task and then stop.</p><p>(Once <a href=/docs/concepts/scheduling-eviction/>scheduled</a>, Pod objects become part of the
desired state for a kubelet).</p><p>When the Job controller sees a new task it makes sure that, somewhere
in your cluster, the kubelets on a set of Nodes are running the right
number of Pods to get the work done.
The Job controller does not run any Pods or containers
itself. Instead, the Job controller tells the API server to create or remove
Pods.
Other components in the
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>
act on the new information (there are new Pods to schedule and run),
and eventually the work is done.</p><p>After you create a new Job, the desired state is for that Job to be completed.
The Job controller makes the current state for that Job be nearer to your
desired state: creating Pods that do the work you wanted for that Job, so that
the Job is closer to completion.</p><p>Controllers also update the objects that configure them.
For example: once the work is done for a Job, the Job controller
updates that Job object to mark it <code>Finished</code>.</p><p>(This is a bit like how some thermostats turn a light off to
indicate that your room is now at the temperature you set).</p><h3 id=direct-control>Direct control</h3><p>In contrast with Job, some controllers need to make changes to
things outside of your cluster.</p><p>For example, if you use a control loop to make sure there
are enough <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodes>Nodes</a>
in your cluster, then that controller needs something outside the
current cluster to set up new Nodes when needed.</p><p>Controllers that interact with external state find their desired state from
the API server, then communicate directly with an external system to bring
the current state closer in line.</p><p>(There actually is a <a href=https://github.com/kubernetes/autoscaler/>controller</a>
that horizontally scales the nodes in your cluster.)</p><p>The important point here is that the controller makes some changes to bring about
your desired state, and then reports the current state back to your cluster's API server.
Other control loops can observe that reported data and take their own actions.</p><p>In the thermostat example, if the room is very cold then a different controller
might also turn on a frost protection heater. With Kubernetes clusters, the control
plane indirectly works with IP address management tools, storage services,
cloud provider APIs, and other services by
<a href=/docs/concepts/extend-kubernetes/>extending Kubernetes</a> to implement that.</p><h2 id=desired-vs-current>Desired versus current state</h2><p>Kubernetes takes a cloud-native view of systems, and is able to handle
constant change.</p><p>Your cluster could be changing at any point as work happens and
control loops automatically fix failures. This means that,
potentially, your cluster never reaches a stable state.</p><p>As long as the controllers for your cluster are running and able to make
useful changes, it doesn't matter if the overall state is stable or not.</p><h2 id=design>Design</h2><p>As a tenet of its design, Kubernetes uses lots of controllers that each manage
a particular aspect of cluster state. Most commonly, a particular control loop
(controller) uses one kind of resource as its desired state, and has a different
kind of resource that it manages to make that desired state happen. For example,
a controller for Jobs tracks Job objects (to discover new work) and Pod objects
(to run the Jobs, and then to see when the work is finished). In this case
something else creates the Jobs, whereas the Job controller creates Pods.</p><p>It's useful to have simple controllers rather than one, monolithic set of control
loops that are interlinked. Controllers can fail, so Kubernetes is designed to
allow for that.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>There can be several controllers that create or update the same kind of object.
Behind the scenes, Kubernetes controllers make sure that they only pay attention
to the resources linked to their controlling resource.</p><p>For example, you can have Deployments and Jobs; these both create Pods.
The Job controller does not delete the Pods that your Deployment created,
because there is information (<a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a>)
the controllers can use to tell those Pods apart.</p></div><h2 id=running-controllers>Ways of running controllers</h2><p>Kubernetes comes with a set of built-in controllers that run inside
the <a class=glossary-tooltip title='Control Plane component that runs controller processes.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>. These
built-in controllers provide important core behaviors.</p><p>The Deployment controller and Job controller are examples of controllers that
come as part of Kubernetes itself ("built-in" controllers).
Kubernetes lets you run a resilient control plane, so that if any of the built-in
controllers were to fail, another part of the control plane will take over the work.</p><p>You can find controllers that run outside the control plane, to extend Kubernetes.
Or, if you want, you can write a new controller yourself.
You can run your own controller as a set of Pods,
or externally to Kubernetes. What fits best will depend on what that particular
controller does.</p><h2 id=what-s-next>What's next</h2><ul><li>Read about the <a href=/docs/concepts/overview/components/#control-plane-components>Kubernetes control plane</a></li><li>Discover some of the basic <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>Kubernetes objects</a></li><li>Learn more about the <a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a></li><li>If you want to write your own controller, see
<a href=/docs/concepts/extend-kubernetes/#extension-patterns>Extension Patterns</a>
in Extending Kubernetes.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>4 - Cloud Controller Manager</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>Cloud infrastructure technologies let you run Kubernetes on public, private, and hybrid clouds.
Kubernetes believes in automated, API-driven infrastructure without tight coupling between
components.</p><p><p>The cloud-controller-manager is a Kubernetes <a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> component
that embeds cloud-specific control logic. The cloud controller manager lets you link your
cluster into your cloud provider's API, and separates out the components that interact
with that cloud platform from components that only interact with your cluster.</p></p><p>By decoupling the interoperability logic between Kubernetes and the underlying cloud
infrastructure, the cloud-controller-manager component enables cloud providers to release
features at a different pace compared to the main Kubernetes project.</p><p>The cloud-controller-manager is structured using a plugin
mechanism that allows different cloud providers to integrate their platforms with Kubernetes.</p><h2 id=design>Design</h2><p><img src=/images/docs/components-of-kubernetes.svg alt="Kubernetes components"></p><p>The cloud controller manager runs in the control plane as a replicated set of processes
(usually, these are containers in Pods). Each cloud-controller-manager implements
multiple <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a> in a single
process.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> You can also run the cloud controller manager as a Kubernetes
<a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=addon>addon</a> rather than as part
of the control plane.</div><h2 id=functions-of-the-ccm>Cloud controller manager functions</h2><p>The controllers inside the cloud controller manager include:</p><h3 id=node-controller>Node controller</h3><p>The node controller is responsible for updating <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a> objects
when new servers are created in your cloud infrastructure. The node controller obtains information about the
hosts running inside your tenancy with the cloud provider. The node controller performs the following functions:</p><ol><li>Update a Node object with the corresponding server's unique identifier obtained from the cloud provider API.</li><li>Annotating and labelling the Node object with cloud-specific information, such as the region the node
is deployed into and the resources (CPU, memory, etc) that it has available.</li><li>Obtain the node's hostname and network addresses.</li><li>Verifying the node's health. In case a node becomes unresponsive, this controller checks with
your cloud provider's API to see if the server has been deactivated / deleted / terminated.
If the node has been deleted from the cloud, the controller deletes the Node object from your Kubernetes
cluster.</li></ol><p>Some cloud provider implementations split this into a node controller and a separate node
lifecycle controller.</p><h3 id=route-controller>Route controller</h3><p>The route controller is responsible for configuring routes in the cloud
appropriately so that containers on different nodes in your Kubernetes
cluster can communicate with each other.</p><p>Depending on the cloud provider, the route controller might also allocate blocks
of IP addresses for the Pod network.</p><h3 id=service-controller>Service controller</h3><p><a class=glossary-tooltip title='A way to expose an application running on a set of Pods as a network service.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a> integrate with cloud
infrastructure components such as managed load balancers, IP addresses, network
packet filtering, and target health checking. The service controller interacts with your
cloud provider's APIs to set up load balancers and other infrastructure components
when you declare a Service resource that requires them.</p><h2 id=authorization>Authorization</h2><p>This section breaks down the access that the cloud controller manager requires
on various API objects, in order to perform its operations.</p><h3 id=authorization-node-controller>Node controller</h3><p>The Node controller only works with Node objects. It requires full access
to read and modify Node objects.</p><p><code>v1/Node</code>:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=authorization-route-controller>Route controller</h3><p>The route controller listens to Node object creation and configures
routes appropriately. It requires Get access to Node objects.</p><p><code>v1/Node</code>:</p><ul><li>Get</li></ul><h3 id=authorization-service-controller>Service controller</h3><p>The service controller listens to Service object Create, Update and Delete events and then configures Endpoints for those Services appropriately (for EndpointSlices, the kube-controller-manager manages these on demand).</p><p>To access Services, it requires List, and Watch access. To update Services, it requires Patch and Update access.</p><p>To set up Endpoints resources for the Services, it requires access to Create, List, Get, Watch, and Update.</p><p><code>v1/Service</code>:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=authorization-miscellaneous>Others</h3><p>The implementation of the core of the cloud controller manager requires access to create Event objects, and to ensure secure operation, it requires access to create ServiceAccounts.</p><p><code>v1/Event</code>:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p><code>v1/ServiceAccount</code>:</p><ul><li>Create</li></ul><p>The <a class=glossary-tooltip title='Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> ClusterRole for the cloud
controller manager looks like:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=what-s-next>What's next</h2><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>Cloud Controller Manager Administration</a>
has instructions on running and managing the cloud controller manager.</p><p>To upgrade a HA control plane to use the cloud controller manager, see <a href=/docs/tasks/administer-cluster/controller-manager-leader-migration/>Migrate Replicated Control Plane To Use Cloud Controller Manager</a>.</p><p>Want to know how to implement your own cloud controller manager, or extend an existing project?</p><p>The cloud controller manager uses Go interfaces to allow implementations from any cloud to be plugged in. Specifically, it uses the <code>CloudProvider</code> interface defined in <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a> from <a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>.</p><p>The implementation of the shared controllers highlighted in this document (Node, Route, and Service), and some scaffolding along with the shared cloudprovider interface, is part of the Kubernetes core. Implementations specific to cloud providers are outside the core of Kubernetes and implement the <code>CloudProvider</code> interface.</p><p>For more information about developing plugins, see <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Developing Cloud Controller Manager</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c20ec7d296cc2c8668bb204c2af31180>5 - About cgroup v2</h1><p>On Linux, <a class=glossary-tooltip title='A group of Linux processes with optional resource isolation, accounting and limits.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-cgroup' target=_blank aria-label='control groups'>control groups</a>
constrain resources that are allocated to processes.</p><p>The <a class=glossary-tooltip title='An agent that runs on each node in the cluster. It makes sure that containers are running in a pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> and the
underlying container runtime need to interface with cgroups to enforce
<a href=/docs/concepts/configuration/manage-resources-containers/>resource management for pods and containers</a> which
includes cpu/memory requests and limits for containerized workloads.</p><p>There are two versions of cgroups in Linux: cgroup v1 and cgroup v2. cgroup v2 is
the new generation of the <code>cgroup</code> API.</p><h2 id=cgroup-v2>What is cgroup v2?</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [stable]</code></div><p>cgroup v2 is the next version of the Linux <code>cgroup</code> API. cgroup v2 provides a
unified control system with enhanced resource management
capabilities.</p><p>cgroup v2 offers several improvements over cgroup v1, such as the following:</p><ul><li>Single unified hierarchy design in API</li><li>Safer sub-tree delegation to containers</li><li>Newer features like <a href=https://www.kernel.org/doc/html/latest/accounting/psi.html>Pressure Stall Information</a></li><li>Enhanced resource allocation management and isolation across multiple resources<ul><li>Unified accounting for different types of memory allocations (network memory, kernel memory, etc)</li><li>Accounting for non-immediate resource changes such as page cache write backs</li></ul></li></ul><p>Some Kubernetes features exclusively use cgroup v2 for enhanced resource
management and isolation. For example, the
<a href=/blog/2021/11/26/qos-memory-resources/>MemoryQoS</a> feature improves memory QoS
and relies on cgroup v2 primitives.</p><h2 id=using-cgroupv2>Using cgroup v2</h2><p>The recommended way to use cgroup v2 is to use a Linux distribution that
enables and uses cgroup v2 by default.</p><p>To check if your distribution uses cgroup v2, refer to <a href=#check-cgroup-version>Identify cgroup version on Linux nodes</a>.</p><h3 id=requirements>Requirements</h3><p>cgroup v2 has the following requirements:</p><ul><li>OS distribution enables cgroup v2</li><li>Linux Kernel version is 5.8 or later</li><li>Container runtime supports cgroup v2. For example:<ul><li><a href=https://containerd.io/>containerd</a> v1.4 and later</li><li><a href=https://cri-o.io/>cri-o</a> v1.20 and later</li></ul></li><li>The kubelet and the container runtime are configured to use the <a href=/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver>systemd cgroup driver</a></li></ul><h3 id=linux-distribution-cgroup-v2-support>Linux Distribution cgroup v2 support</h3><p>For a list of Linux distributions that use cgroup v2, refer to the <a href=https://github.com/opencontainers/runc/blob/main/docs/cgroup-v2.md>cgroup v2 documentation</a></p><ul><li>Container Optimized OS (since M97)</li><li>Ubuntu (since 21.10, 22.04+ recommended)</li><li>Debian GNU/Linux (since Debian 11 bullseye)</li><li>Fedora (since 31)</li><li>Arch Linux (since April 2021)</li><li>RHEL and RHEL-like distributions (since 9)</li></ul><p>To check if your distribution is using cgroup v2, refer to your distribution's
documentation or follow the instructions in <a href=#check-cgroup-version>Identify the cgroup version on Linux nodes</a>.</p><p>You can also enable cgroup v2 manually on your Linux distribution by modifying
the kernel cmdline boot arguments. If your distribution uses GRUB,
<code>systemd.unified_cgroup_hierarchy=1</code> should be added in <code>GRUB_CMDLINE_LINUX</code>
under <code>/etc/default/grub</code>, followed by <code>sudo update-grub</code>. However, the
recommended approach is to use a distribution that already enables cgroup v2 by
default.</p><h3 id=migrating-cgroupv2>Migrating to cgroup v2</h3><p>To migrate to cgroup v2, ensure that you meet the <a href=#requirements>requirements</a>, then upgrade
to a kernel version that enables cgroup v2 by default.</p><p>The kubelet automatically detects that the OS is running on cgroup v2 and
performs accordingly with no additional configuration required.</p><p>There should not be any noticeable difference in the user experience when
switching to cgroup v2, unless users are accessing the cgroup file system
directly, either on the node or from within the containers.</p><p>cgroup v2 uses a different API than cgroup v1, so if there are any
applications that directly access the cgroup file system, they need to be
updated to newer versions that support cgroup v2. For example:</p><ul><li>Some third-party monitoring and security agents may depend on the cgroup filesystem.
Update these agents to versions that support cgroup v2.</li><li>If you run <a href=https://github.com/google/cadvisor>cAdvisor</a> as a stand-alone
DaemonSet for monitoring pods and containers, update it to v0.43.0 or later.</li><li>If you use JDK, prefer to use JDK 11.0.16 and later or JDK 15 and later, which <a href=https://bugs.openjdk.org/browse/JDK-8230305>fully support cgroup v2</a>.</li></ul><h2 id=check-cgroup-version>Identify the cgroup version on Linux Nodes</h2><p>The cgroup version depends on the Linux distribution being used and the
default cgroup version configured on the OS. To check which cgroup version your
distribution uses, run the <code>stat -fc %T /sys/fs/cgroup/</code> command on
the node:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>stat -fc %T /sys/fs/cgroup/
</span></span></code></pre></div><p>For cgroup v2, the output is <code>cgroup2fs</code>.</p><p>For cgroup v1, the output is <code>tmpfs.</code></p><h2 id=what-s-next>What's next</h2><ul><li>Learn more about <a href=https://man7.org/linux/man-pages/man7/cgroups.7.html>cgroups</a></li><li>Learn more about <a href=/docs/concepts/architecture/cri>container runtime</a></li><li>Learn more about <a href=/docs/setup/production-environment/container-runtimes#cgroup-drivers>cgroup drivers</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0ea5310f52e22c5de34dc84d9ab5e0d>6 - Container Runtime Interface (CRI)</h1><p>The CRI is a plugin interface which enables the kubelet to use a wide variety of
container runtimes, without having a need to recompile the cluster components.</p><p>You need a working
<a class=glossary-tooltip title='The container runtime is the software that is responsible for running containers.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a> on
each Node in your cluster, so that the
<a class=glossary-tooltip title='An agent that runs on each node in the cluster. It makes sure that containers are running in a pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> can launch
<a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> and their containers.</p><p><p>The Container Runtime Interface (CRI) is the main protocol for the communication between the kubelet and Container Runtime.</p></p><p>The Kubernetes Container Runtime Interface (CRI) defines the main
<a href=https://grpc.io>gRPC</a> protocol for the communication between the
<a href=/docs/concepts/overview/components/#node-components>cluster components</a>
<a class=glossary-tooltip title='An agent that runs on each node in the cluster. It makes sure that containers are running in a pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> and
<a class=glossary-tooltip title='The container runtime is the software that is responsible for running containers.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a>.</p><h2 id=api>The API</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code></div><p>The kubelet acts as a client when connecting to the container runtime via gRPC.
The runtime and image service endpoints have to be available in the container
runtime, which can be configured separately within the kubelet by using the
<code>--image-service-endpoint</code> and <code>--container-runtime-endpoint</code> <a href=/docs/reference/command-line-tools-reference/kubelet>command line
flags</a></p><p>For Kubernetes v1.25, the kubelet prefers to use CRI <code>v1</code>.
If a container runtime does not support <code>v1</code> of the CRI, then the kubelet tries to
negotiate any older supported version.
The v1.25 kubelet can also negotiate CRI <code>v1alpha2</code>, but
this version is considered as deprecated.
If the kubelet cannot negotiate a supported CRI version, the kubelet gives up
and doesn't register as a node.</p><h2 id=upgrading>Upgrading</h2><p>When upgrading Kubernetes, the kubelet tries to automatically select the
latest CRI version on restart of the component. If that fails, then the fallback
will take place as mentioned above. If a gRPC re-dial was required because the
container runtime has been upgraded, then the container runtime must also
support the initially selected version or the redial is expected to fail. This
requires a restart of the kubelet.</p><h2 id=what-s-next>What's next</h2><ul><li>Learn more about the CRI <a href=https://github.com/kubernetes/cri-api/blob/c75ef5b/pkg/apis/runtime/v1/api.proto>protocol definition</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-44a2e2e592af0846101e970aff9243e5>7 - Garbage Collection</h1><p>Garbage collection is a collective term for the various mechanisms Kubernetes uses to clean up
cluster resources. This
allows the clean up of resources like the following:</p><ul><li><a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>Terminated pods</a></li><li><a href=/docs/concepts/workloads/controllers/ttlafterfinished/>Completed Jobs</a></li><li><a href=#owners-dependents>Objects without owner references</a></li><li><a href=#containers-images>Unused containers and container images</a></li><li><a href=/docs/concepts/storage/persistent-volumes/#delete>Dynamically provisioned PersistentVolumes with a StorageClass reclaim policy of Delete</a></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process>Stale or expired CertificateSigningRequests (CSRs)</a></li><li><a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodes>Nodes</a> deleted in the following scenarios:<ul><li>On a cloud when the cluster uses a <a href=/docs/concepts/architecture/cloud-controller/>cloud controller manager</a></li><li>On-premises when the cluster uses an addon similar to a cloud controller
manager</li></ul></li><li><a href=/docs/concepts/architecture/nodes/#heartbeats>Node Lease objects</a></li></ul><h2 id=owners-dependents>Owners and dependents</h2><p>Many objects in Kubernetes link to each other through <a href=/docs/concepts/overview/working-with-objects/owners-dependents/><em>owner references</em></a>.
Owner references tell the control plane which objects are dependent on others.
Kubernetes uses owner references to give the control plane, and other API
clients, the opportunity to clean up related resources before deleting an
object. In most cases, Kubernetes manages owner references automatically.</p><p>Ownership is different from the <a href=/docs/concepts/overview/working-with-objects/labels/>labels and selectors</a>
mechanism that some resources also use. For example, consider a
<a class=glossary-tooltip title='A way to expose an application running on a set of Pods as a network service.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a> that creates
<code>EndpointSlice</code> objects. The Service uses <em>labels</em> to allow the control plane to
determine which <code>EndpointSlice</code> objects are used for that Service. In addition
to the labels, each <code>EndpointSlice</code> that is managed on behalf of a Service has
an owner reference. Owner references help different parts of Kubernetes avoid
interfering with objects they don’t control.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Cross-namespace owner references are disallowed by design.
Namespaced dependents can specify cluster-scoped or namespaced owners.
A namespaced owner <strong>must</strong> exist in the same namespace as the dependent.
If it does not, the owner reference is treated as absent, and the dependent
is subject to deletion once all owners are verified absent.</p><p>Cluster-scoped dependents can only specify cluster-scoped owners.
In v1.20+, if a cluster-scoped dependent specifies a namespaced kind as an owner,
it is treated as having an unresolvable owner reference, and is not able to be garbage collected.</p><p>In v1.20+, if the garbage collector detects an invalid cross-namespace <code>ownerReference</code>,
or a cluster-scoped dependent with an <code>ownerReference</code> referencing a namespaced kind, a warning Event
with a reason of <code>OwnerRefInvalidNamespace</code> and an <code>involvedObject</code> of the invalid dependent is reported.
You can check for that kind of Event by running
<code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code>.</p></div><h2 id=cascading-deletion>Cascading deletion</h2><p>Kubernetes checks for and deletes objects that no longer have owner
references, like the pods left behind when you delete a ReplicaSet. When you
delete an object, you can control whether Kubernetes deletes the object's
dependents automatically, in a process called <em>cascading deletion</em>. There are
two types of cascading deletion, as follows:</p><ul><li>Foreground cascading deletion</li><li>Background cascading deletion</li></ul><p>You can also control how and when garbage collection deletes resources that have
owner references using Kubernetes <a class=glossary-tooltip title='A namespaced key that tells Kubernetes to wait until specific conditions are met before it fully deletes an object marked for deletion.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=finalizers>finalizers</a>.</p><h3 id=foreground-deletion>Foreground cascading deletion</h3><p>In foreground cascading deletion, the owner object you're deleting first enters
a <em>deletion in progress</em> state. In this state, the following happens to the
owner object:</p><ul><li>The Kubernetes API server sets the object's <code>metadata.deletionTimestamp</code>
field to the time the object was marked for deletion.</li><li>The Kubernetes API server also sets the <code>metadata.finalizers</code> field to
<code>foregroundDeletion</code>.</li><li>The object remains visible through the Kubernetes API until the deletion
process is complete.</li></ul><p>After the owner object enters the deletion in progress state, the controller
deletes the dependents. After deleting all the dependent objects, the controller
deletes the owner object. At this point, the object is no longer visible in the
Kubernetes API.</p><p>During foreground cascading deletion, the only dependents that block owner
deletion are those that have the <code>ownerReference.blockOwnerDeletion=true</code> field.
See <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion>Use foreground cascading deletion</a>
to learn more.</p><h3 id=background-deletion>Background cascading deletion</h3><p>In background cascading deletion, the Kubernetes API server deletes the owner
object immediately and the controller cleans up the dependent objects in
the background. By default, Kubernetes uses background cascading deletion unless
you manually use foreground deletion or choose to orphan the dependent objects.</p><p>See <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion>Use background cascading deletion</a>
to learn more.</p><h3 id=orphaned-dependents>Orphaned dependents</h3><p>When Kubernetes deletes an owner object, the dependents left behind are called
<em>orphan</em> objects. By default, Kubernetes deletes dependent objects. To learn how
to override this behaviour, see <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy>Delete owner objects and orphan dependents</a>.</p><h2 id=containers-images>Garbage collection of unused containers and images</h2><p>The <a class=glossary-tooltip title='An agent that runs on each node in the cluster. It makes sure that containers are running in a pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> performs garbage
collection on unused images every five minutes and on unused containers every
minute. You should avoid using external garbage collection tools, as these can
break the kubelet behavior and remove containers that should exist.</p><p>To configure options for unused container and image garbage collection, tune the
kubelet using a <a href=/docs/tasks/administer-cluster/kubelet-config-file/>configuration file</a>
and change the parameters related to garbage collection using the
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>KubeletConfiguration</code></a>
resource type.</p><h3 id=container-image-lifecycle>Container image lifecycle</h3><p>Kubernetes manages the lifecycle of all images through its <em>image manager</em>,
which is part of the kubelet, with the cooperation of
<a class=glossary-tooltip title='Tool that provides understanding of the resource usage and performance characteristics for containers' data-toggle=tooltip data-placement=top href=https://github.com/google/cadvisor/ target=_blank aria-label=cadvisor>cadvisor</a>. The kubelet
considers the following disk usage limits when making garbage collection
decisions:</p><ul><li><code>HighThresholdPercent</code></li><li><code>LowThresholdPercent</code></li></ul><p>Disk usage above the configured <code>HighThresholdPercent</code> value triggers garbage
collection, which deletes images in order based on the last time they were used,
starting with the oldest first. The kubelet deletes images
until disk usage reaches the <code>LowThresholdPercent</code> value.</p><h3 id=container-image-garbage-collection>Container garbage collection</h3><p>The kubelet garbage collects unused containers based on the following variables,
which you can define:</p><ul><li><code>MinAge</code>: the minimum age at which the kubelet can garbage collect a
container. Disable by setting to <code>0</code>.</li><li><code>MaxPerPodContainer</code>: the maximum number of dead containers each Pod pair
can have. Disable by setting to less than <code>0</code>.</li><li><code>MaxContainers</code>: the maximum number of dead containers the cluster can have.
Disable by setting to less than <code>0</code>.</li></ul><p>In addition to these variables, the kubelet garbage collects unidentified and
deleted containers, typically starting with the oldest first.</p><p><code>MaxPerPodContainer</code> and <code>MaxContainers</code> may potentially conflict with each other
in situations where retaining the maximum number of containers per Pod
(<code>MaxPerPodContainer</code>) would go outside the allowable total of global dead
containers (<code>MaxContainers</code>). In this situation, the kubelet adjusts
<code>MaxPerPodContainer</code> to address the conflict. A worst-case scenario would be to
downgrade <code>MaxPerPodContainer</code> to <code>1</code> and evict the oldest containers.
Additionally, containers owned by pods that have been deleted are removed once
they are older than <code>MinAge</code>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> The kubelet only garbage collects the containers it manages.</div><h2 id=configuring-gc>Configuring garbage collection</h2><p>You can tune garbage collection of resources by configuring options specific to
the controllers managing those resources. The following pages show you how to
configure garbage collection:</p><ul><li><a href=/docs/tasks/administer-cluster/use-cascading-deletion/>Configuring cascading deletion of Kubernetes objects</a></li><li><a href=/docs/concepts/workloads/controllers/ttlafterfinished/>Configuring cleanup of finished Jobs</a></li></ul><h2 id=what-s-next>What's next</h2><ul><li>Learn more about <a href=/docs/concepts/overview/working-with-objects/owners-dependents/>ownership of Kubernetes objects</a>.</li><li>Learn more about Kubernetes <a href=/docs/concepts/overview/working-with-objects/finalizers/>finalizers</a>.</li><li>Learn about the <a href=/docs/concepts/workloads/controllers/ttlafterfinished/>TTL controller</a> (beta) that cleans up finished Jobs.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/docs/home/>Home</a>
<a class=text-white href=/blog/>Blog</a>
<a class=text-white href=/training/>Training</a>
<a class=text-white href=/partners/>Partners</a>
<a class=text-white href=/community/>Community</a>
<a class=text-white href=/case-studies/>Case Studies</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>