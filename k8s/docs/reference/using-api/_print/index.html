<!doctype html><html lang=en class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/reference/using-api/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/reference/using-api/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/reference/using-api/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/using-api/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/using-api/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/using-api/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/docs/reference/using-api/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>API Overview | Kubernetes</title><meta property="og:title" content="API Overview"><meta property="og:description" content="Production-Grade Container Orchestration"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/docs/reference/using-api/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="API Overview"><meta itemprop=description content="Production-Grade Container Orchestration"><meta name=twitter:card content="summary"><meta name=twitter:title content="API Overview"><meta name=twitter:description content="Production-Grade Container Orchestration"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="This section provides reference information for the Kubernetes API.
The REST API is the fundamental fabric of Kubernetes. All operations and communications between components, and external user commands are REST API calls that the API Server handles. Consequently, everything in the Kubernetes platform is treated as an API object and has a corresponding entry in the API.
The Kubernetes API reference lists the API for Kubernetes version v1.25.
For general background information, read The Kubernetes API."><meta property="og:description" content="This section provides reference information for the Kubernetes API.
The REST API is the fundamental fabric of Kubernetes. All operations and communications between components, and external user commands are REST API calls that the API Server handles. Consequently, everything in the Kubernetes platform is treated as an API object and has a corresponding entry in the API.
The Kubernetes API reference lists the API for Kubernetes version v1.25.
For general background information, read The Kubernetes API."><meta name=twitter:description content="This section provides reference information for the Kubernetes API.
The REST API is the fundamental fabric of Kubernetes. All operations and communications between components, and external user commands are REST API calls that the API Server handles. Consequently, everything in the Kubernetes platform is treated as an API object and has a corresponding entry in the API.
The Kubernetes API reference lists the API for Kubernetes version v1.25.
For general background information, read The Kubernetes API."><meta property="og:url" content="https://kubernetes.io/docs/reference/using-api/"><meta property="og:title" content="API Overview"><meta name=twitter:title content="API Overview"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/docs/>Documentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/training/>Training</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/partners/>Partners</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/case-studies/>Case Studies</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/docs/reference/using-api/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/docs/reference/using-api/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/docs/reference/using-api/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/docs/reference/using-api/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/docs/reference/using-api/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>English</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/docs/reference/using-api/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/reference/using-api/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/reference/using-api/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/reference/using-api/>Français (French)</a>
<a class=dropdown-item href=/de/docs/reference/using-api/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/reference/using-api/>Español (Spanish)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/reference/using-api/>Return to the regular view of this page</a>.</p></div><h1 class=title>API Overview</h1><ul><li>1: <a href=#pg-2b5428a2ff6f4831fd972ef50e12b3eb>Kubernetes API Concepts</a></li><li>2: <a href=#pg-040d9484db673074f1b8ba3465be9d91>Server-Side Apply</a></li><li>3: <a href=#pg-79880efc25dc8cb3b6962ad78a964319>Client Libraries</a></li><li>4: <a href=#pg-8d2ce3e7b2223cda0ccd428f4d5ea24b>Kubernetes Deprecation Policy</a></li><li>5: <a href=#pg-2479c39af50fd55b898a3bcfb5988077>Deprecated API Migration Guide</a></li><li>6: <a href=#pg-e4dbb59f8f23854d7b7d574e169923c4>Kubernetes API health endpoints</a></li></ul><div class=content><p>This section provides reference information for the Kubernetes API.</p><p>The REST API is the fundamental fabric of Kubernetes. All operations and
communications between components, and external user commands are REST API
calls that the API Server handles. Consequently, everything in the Kubernetes
platform is treated as an API object and has a corresponding entry in the
<a href=/docs/reference/generated/kubernetes-api/v1.25/>API</a>.</p><p>The <a href=/docs/reference/generated/kubernetes-api/v1.25/>Kubernetes API reference</a>
lists the API for Kubernetes version v1.25.</p><p>For general background information, read
<a href=/docs/concepts/overview/kubernetes-api/>The Kubernetes API</a>.
<a href=/docs/concepts/security/controlling-access/>Controlling Access to the Kubernetes API</a>
describes how clients can authenticate to the Kubernetes API server, and how their
requests are authorized.</p><h2 id=api-versioning>API versioning</h2><p>The JSON and Protobuf serialization schemas follow the same guidelines for
schema changes. The following descriptions cover both formats.</p><p>The API versioning and software versioning are indirectly related.
The <a href=https://git.k8s.io/sig-release/release-engineering/versioning.md>API and release versioning proposal</a>
describes the relationship between API versioning and software versioning.</p><p>Different API versions indicate different levels of stability and support. You
can find more information about the criteria for each level in the
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>API Changes documentation</a>.</p><p>Here's a summary of each level:</p><ul><li><p>Alpha:</p><ul><li>The version names contain <code>alpha</code> (for example, <code>v1alpha1</code>).</li><li>Built-in alpha API versions are disabled by default and must be explicitly enabled in the <code>kube-apiserver</code> configuration to be used.</li><li>The software may contain bugs. Enabling a feature may expose bugs.</li><li>Support for an alpha API may be dropped at any time without notice.</li><li>The API may change in incompatible ways in a later software release without notice.</li><li>The software is recommended for use only in short-lived testing clusters,
due to increased risk of bugs and lack of long-term support.</li></ul></li><li><p>Beta:</p><ul><li><p>The version names contain <code>beta</code> (for example, <code>v2beta3</code>).</p></li><li><p>Built-in beta API versions are disabled by default and must be explicitly enabled in the <code>kube-apiserver</code> configuration to be used
(<strong>except</strong> for beta versions of APIs introduced prior to Kubernetes 1.22, which were enabled by default).</p></li><li><p>Built-in beta API versions have a maximum lifetime of 9 months or 3 minor releases (whichever is longer) from introduction
to deprecation, and 9 months or 3 minor releases (whichever is longer) from deprecation to removal.</p></li><li><p>The software is well tested. Enabling a feature is considered safe.</p></li><li><p>The support for a feature will not be dropped, though the details may change.</p></li><li><p>The schema and/or semantics of objects may change in incompatible ways in
a subsequent beta or stable API version. When this happens, migration
instructions are provided. Adapting to a subsequent beta or stable API version
may require editing or re-creating API objects, and may not be straightforward.
The migration may require downtime for applications that rely on the feature.</p></li><li><p>The software is not recommended for production uses. Subsequent releases
may introduce incompatible changes. Use of beta API versions is
required to transition to subsequent beta or stable API versions
once the beta API version is deprecated and no longer served.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Please try beta features and provide feedback. After the features exit beta, it
may not be practical to make more changes.</div></li><li><p>Stable:</p><ul><li>The version name is <code>vX</code> where <code>X</code> is an integer.</li><li>Stable API versions remain available for all future releases within a Kubernetes major version,
and there are no current plans for a major version revision of Kubernetes that removes stable APIs.</li></ul></li></ul><h2 id=api-groups>API groups</h2><p><a href=https://git.k8s.io/design-proposals-archive/api-machinery/api-group.md>API groups</a>
make it easier to extend the Kubernetes API.
The API group is specified in a REST path and in the <code>apiVersion</code> field of a
serialized object.</p><p>There are several API groups in Kubernetes:</p><ul><li>The <em>core</em> (also called <em>legacy</em>) group is found at REST path <code>/api/v1</code>.
The core group is not specified as part of the <code>apiVersion</code> field, for
example, <code>apiVersion: v1</code>.</li><li>The named groups are at REST path <code>/apis/$GROUP_NAME/$VERSION</code> and use
<code>apiVersion: $GROUP_NAME/$VERSION</code> (for example, <code>apiVersion: batch/v1</code>).
You can find the full list of supported API groups in
<a href=/docs/reference/generated/kubernetes-api/v1.25/#-strong-api-groups-strong->Kubernetes API reference</a>.</li></ul><h2 id=enabling-or-disabling>Enabling or disabling API groups</h2><p>Certain resources and API groups are enabled by default. You can enable or
disable them by setting <code>--runtime-config</code> on the API server. The
<code>--runtime-config</code> flag accepts comma separated <code>&lt;key>[=&lt;value>]</code> pairs
describing the runtime configuration of the API server. If the <code>=&lt;value></code>
part is omitted, it is treated as if <code>=true</code> is specified. For example:</p><ul><li>to disable <code>batch/v1</code>, set <code>--runtime-config=batch/v1=false</code></li><li>to enable <code>batch/v2alpha1</code>, set <code>--runtime-config=batch/v2alpha1</code></li><li>to enable a specific version of an API, such as <code>storage.k8s.io/v1beta1/csistoragecapacities</code>, set <code>--runtime-config=storage.k8s.io/v1beta1/csistoragecapacities</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Note:</strong> When you enable or disable groups or resources, you need to restart the API
server and controller manager to pick up the <code>--runtime-config</code> changes.</div><h2 id=persistence>Persistence</h2><p>Kubernetes stores its serialized state in terms of the API resources by writing them into
<a class=glossary-tooltip title='Consistent and highly-available key value store used as backing store of Kubernetes for all cluster data.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>.</p><h2 id=what-s-next>What's next</h2><ul><li>Learn more about <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#api-conventions>API conventions</a></li><li>Read the design documentation for
<a href=https://git.k8s.io/design-proposals-archive/api-machinery/aggregated-api-servers.md>aggregator</a></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-2b5428a2ff6f4831fd972ef50e12b3eb>1 - Kubernetes API Concepts</h1><p>The Kubernetes API is a resource-based (RESTful) programmatic interface
provided via HTTP. It supports retrieving, creating, updating, and deleting
primary resources via the standard HTTP verbs (POST, PUT, PATCH, DELETE,
GET).</p><p>For some resources, the API includes additional subresources that allow
fine grained authorization (such as separate views for Pod details and
log retrievals), and can accept and serve those resources in different
representations for convenience or efficiency.</p><p>Kubernetes supports efficient change notifications on resources via <em>watches</em>.
Kubernetes also provides consistent list operations so that API clients can
effectively cache, track, and synchronize the state of resources.</p><p>You can view the <a href=/docs/reference/kubernetes-api/>API reference</a> online,
or read on to learn about the API in general.</p><h2 id=standard-api-terminology>Kubernetes API terminology</h2><p>Kubernetes generally leverages common RESTful terminology to describe the
API concepts:</p><ul><li>A <em>resource type</em> is the name used in the URL (<code>pods</code>, <code>namespaces</code>, <code>services</code>)</li><li>All resource types have a concrete representation (their object schema) which is called a <em>kind</em></li><li>A list of instances of a resource is known as a <em>collection</em></li><li>A single instance of a resource type is called a <em>resource</em>, and also usually represents an <em>object</em></li><li>For some resource types, the API includes one or more <em>sub-resources</em>, which are represented as URI paths below the resource</li></ul><p>Most Kubernetes API resource types are
<a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>objects</a>:
they represent a concrete instance of a concept on the cluster, like a
pod or namespace. A smaller number of API resource types are <em>virtual</em> in
that they often represent operations on objects, rather than objects, such
as a permission check
(use a POST with a JSON-encoded body of <code>SubjectAccessReview</code> to the
<code>subjectaccessreviews</code> resource), or the <code>eviction</code> sub-resource of a Pod
(used to trigger
<a href=/docs/concepts/scheduling-eviction/api-eviction/>API-initiated eviction</a>).</p><h3 id=object-names>Object names</h3><p>All objects you can create via the API have a unique object
<a class=glossary-tooltip title='A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/names target=_blank aria-label=name>name</a> to allow idempotent creation and
retrieval, except that virtual resource types may not have unique names if they are
not retrievable, or do not rely on idempotency.
Within a <a class=glossary-tooltip title='An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>, only one object
of a given kind can have a given name at a time. However, if you delete the object,
you can make a new object with the same name. Some objects are not namespaced (for
example: Nodes), and so their names must be unique across the whole cluster.</p><h3 id=api-verbs>API verbs</h3><p>Almost all object resource types support the standard HTTP verbs - GET, POST, PUT, PATCH,
and DELETE. Kubernetes also uses its own verbs, which are often written lowercase to distinguish
them from HTTP verbs.</p><p>Kubernetes uses the term <strong>list</strong> to describe returning a <a href=#collections>collection</a> of
resources to distinguish from retrieving a single resource which is usually called
a <strong>get</strong>. If you sent an HTTP GET request with the <code>?watch</code> query parameter,
Kubernetes calls this a <strong>watch</strong> and not a <strong>get</strong> (see
<a href=#efficient-detection-of-changes>Efficient detection of changes</a> for more details).</p><p>For PUT requests, Kubernetes internally classifies these as either <strong>create</strong> or <strong>update</strong>
based on the state of the existing object. An <strong>update</strong> is different from a <strong>patch</strong>; the
HTTP verb for a <strong>patch</strong> is PATCH.</p><h2 id=resource-uris>Resource URIs</h2><p>All resource types are either scoped by the cluster (<code>/apis/GROUP/VERSION/*</code>) or to a
namespace (<code>/apis/GROUP/VERSION/namespaces/NAMESPACE/*</code>). A namespace-scoped resource
type will be deleted when its namespace is deleted and access to that resource type
is controlled by authorization checks on the namespace scope.</p><p>You can also access collections of resources (for example: listing all Nodes).
The following paths are used to retrieve collections and resources:</p><ul><li><p>Cluster-scoped resources:</p><ul><li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - return the collection of resources of the resource type</li><li><code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME</code> - return the resource with NAME under the resource type</li></ul></li><li><p>Namespace-scoped resources:</p><ul><li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - return the collection of all instances of the resource type across all namespaces</li><li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE</code> - return collection of all instances of the resource type in NAMESPACE</li><li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME</code> - return the instance of the resource type with NAME in NAMESPACE</li></ul></li></ul><p>Since a namespace is a cluster-scoped resource type, you can retrieve the list
(“collection”) of all namespaces with <code>GET /api/v1/namespaces</code> and details about
a particular namespace with <code>GET /api/v1/namespaces/NAME</code>.</p><ul><li>Cluster-scoped subresource: <code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE</code></li><li>Namespace-scoped subresource: <code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE</code></li></ul><p>The verbs supported for each subresource will differ depending on the object -
see the <a href=/docs/reference/kubernetes-api/>API reference</a> for more information. It
is not possible to access sub-resources across multiple resources - generally a new
virtual resource type would be used if that becomes necessary.</p><h2 id=efficient-detection-of-changes>Efficient detection of changes</h2><p>The Kubernetes API allows clients to make an initial request for an object or a
collection, and then to track changes since that initial request: a <strong>watch</strong>. Clients
can send a <strong>list</strong> or a <strong>get</strong> and then make a follow-up <strong>watch</strong> request.</p><p>To make this change tracking possible, every Kubernetes object has a <code>resourceVersion</code>
field representing the version of that resource as stored in the underlying persistence
layer. When retrieving a collection of resources (either namespace or cluster scoped),
the response from the API server contains a <code>resourceVersion</code> value. The client can
use that <code>resourceVersion</code> to initiate a <strong>watch</strong> against the API server.</p><p>When you send a <strong>watch</strong> request, the API server responds with a stream of
changes. These changes itemize the outcome of operations (such as <strong>create</strong>, <strong>delete</strong>,
and <strong>update</strong>) that occurred after the <code>resourceVersion</code> you specified as a parameter
to the <strong>watch</strong> request. The overall <strong>watch</strong> mechanism allows a client to fetch
the current state and then subscribe to subsequent changes, without missing any events.</p><p>If a client <strong>watch</strong> is disconnected then that client can start a new <strong>watch</strong> from
the last returned <code>resourceVersion</code>; the client could also perform a fresh <strong>get</strong> /
<strong>list</strong> request and begin again. See <a href=#resource-versions>Resource Version Semantics</a>
for more detail.</p><p>For example:</p><ol><li><p>List all of the pods in a given namespace.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/namespaces/test/pods
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;kind&#34;: &#34;PodList&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;metadata&#34;: {&#34;resourceVersion&#34;:&#34;10245&#34;},
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;items&#34;: [...]
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div></li><li><p>Starting from resource version 10245, receive notifications of any API operations
(such as <strong>create</strong>, <strong>delete</strong>, <strong>apply</strong> or <strong>update</strong>) that affect Pods in the
<em>test</em> namespace. Each change notification is a JSON document. The HTTP response body
(served as <code>application/json</code>) consists a series of JSON documents.</p><pre tabindex=0><code>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &#34;type&#34;: &#34;ADDED&#34;,
  &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;10596&#34;, ...}, ...}
}
{
  &#34;type&#34;: &#34;MODIFIED&#34;,
  &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;11020&#34;, ...}, ...}
}
...
</code></pre></li></ol><p>A given Kubernetes server will only preserve a historical record of changes for a
limited time. Clusters using etcd 3 preserve changes in the last 5 minutes by default.
When the requested <strong>watch</strong> operations fail because the historical version of that
resource is not available, clients must handle the case by recognizing the status code
<code>410 Gone</code>, clearing their local cache, performing a new <strong>get</strong> or <strong>list</strong> operation,
and starting the <strong>watch</strong> from the <code>resourceVersion</code> that was returned.</p><p>For subscribing to collections, Kubernetes client libraries typically offer some form
of standard tool for this <strong>list</strong>-then-<strong>watch</strong> logic. (In the Go client library,
this is called a <code>Reflector</code> and is located in the <code>k8s.io/client-go/tools/cache</code> package.)</p><h3 id=watch-bookmarks>Watch bookmarks</h3><p>To mitigate the impact of short history window, the Kubernetes API provides a watch
event named <code>BOOKMARK</code>. It is a special kind of event to mark that all changes up
to a given <code>resourceVersion</code> the client is requesting have already been sent. The
document representing the <code>BOOKMARK</code> event is of the type requested by the request,
but only includes a <code>.metadata.resourceVersion</code> field. For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245&amp;allowWatchBookmarks=true
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Transfer-Encoding: chunked
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;type&#34;: &#34;ADDED&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;10596&#34;, ...}, ...}
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span><span style=display:flex><span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;type&#34;: &#34;BOOKMARK&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;12746&#34;} }
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div><p>As a client, you can request <code>BOOKMARK</code> events by setting the
<code>allowWatchBookmarks=true</code> query parameter to a <strong>watch</strong> request, but you shouldn't
assume bookmarks are returned at any specific interval, nor can clients assume that
the API server will send any <code>BOOKMARK</code> event even when requested.</p><h2 id=retrieving-large-results-sets-in-chunks>Retrieving large results sets in chunks</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.9 [beta]</code></div><p>On large clusters, retrieving the collection of some resource types may result in
very large responses that can impact the server and client. For instance, a cluster
may have tens of thousands of Pods, each of which is equivalent to roughly 2 KiB of
encoded JSON. Retrieving all pods across all namespaces may result in a very large
response (10-20MB) and consume a large amount of server resources.</p><p>Provided that you don't explicitly disable the <code>APIListChunking</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>, the
Kubernetes API server supports the ability to break a single large collection request
into many smaller chunks while preserving the consistency of the total request. Each
chunk can be returned sequentially which reduces both the total size of the request and
allows user-oriented clients to display results incrementally to improve responsiveness.</p><p>You can request that the API server handles a <strong>list</strong> by serving single collection
using pages (which Kubernetes calls <em>chunks</em>). To retrieve a single collection in
chunks, two query parameters <code>limit</code> and <code>continue</code> are supported on requests against
collections, and a response field <code>continue</code> is returned from all <strong>list</strong> operations
in the collection's <code>metadata</code> field. A client should specify the maximum results they
wish to receive in each chunk with <code>limit</code> and the server will return up to <code>limit</code>
resources in the result and include a <code>continue</code> value if there are more resources
in the collection.</p><p>As an API client, you can then pass this <code>continue</code> value to the API server on the
next request, to instruct the server to return the next page (<em>chunk</em>) of results. By
continuing until the server returns an empty <code>continue</code> value, you can retrieve the
entire collection.</p><p>Like a <strong>watch</strong> operation, a <code>continue</code> token will expire after a short amount
of time (by default 5 minutes) and return a <code>410 Gone</code> if more results cannot be
returned. In this case, the client will need to start from the beginning or omit the
<code>limit</code> parameter.</p><p>For example, if there are 1,253 pods on the cluster and you wants to receive chunks
of 500 pods at a time, request those chunks as follows:</p><ol><li><p>List all of the pods on a cluster, retrieving up to 500 pods each time.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/pods?limit=500
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;kind&#34;: &#34;PodList&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;metadata&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;resourceVersion&#34;:&#34;10245&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;continue&#34;: &#34;ENCODED_CONTINUE_TOKEN&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;remainingItemCount&#34;: 753,
</span></span></span><span style=display:flex><span><span style=color:#888>    ...
</span></span></span><span style=display:flex><span><span style=color:#888>  },
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;items&#34;: [...] // returns pods 1-500
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div></li><li><p>Continue the previous call, retrieving the next set of 500 pods.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;kind&#34;: &#34;PodList&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;metadata&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;resourceVersion&#34;:&#34;10245&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;continue&#34;: &#34;ENCODED_CONTINUE_TOKEN_2&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;remainingItemCount&#34;: 253,
</span></span></span><span style=display:flex><span><span style=color:#888>    ...
</span></span></span><span style=display:flex><span><span style=color:#888>  },
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;items&#34;: [...] // returns pods 501-1000
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div></li><li><p>Continue the previous call, retrieving the last 253 pods.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN_2
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;kind&#34;: &#34;PodList&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;metadata&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;resourceVersion&#34;:&#34;10245&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;continue&#34;: &#34;&#34;, // continue token is empty because we have reached the end of the list
</span></span></span><span style=display:flex><span><span style=color:#888>    ...
</span></span></span><span style=display:flex><span><span style=color:#888>  },
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;items&#34;: [...] // returns pods 1001-1253
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div></li></ol><p>Notice that the <code>resourceVersion</code> of the collection remains constant across each request,
indicating the server is showing you a consistent snapshot of the pods. Pods that
are created, updated, or deleted after version <code>10245</code> would not be shown unless
you make a separate <strong>list</strong> request without the <code>continue</code> token. This allows you
to break large requests into smaller chunks and then perform a <strong>watch</strong> operation
on the full set without missing any updates.</p><p><code>remainingItemCount</code> is the number of subsequent items in the collection that are not
included in this response. If the <strong>list</strong> request contained label or field
<a class=glossary-tooltip title='Allows users to filter a list of resources based on labels.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selectors>selectors</a> then the number of
remaining items is unknown and the API server does not include a <code>remainingItemCount</code>
field in its response.
If the <strong>list</strong> is complete (either because it is not chunking, or because this is the
last chunk), then there are no more remaining items and the API server does not include a
<code>remainingItemCount</code> field in its response. The intended use of the <code>remainingItemCount</code>
is estimating the size of a collection.</p><h2 id=collections>Collections</h2><p>In Kubernetes terminology, the response you get from a <strong>list</strong> is
a <em>collection</em>. However, Kubernetes defines concrete kinds for
collections of different types of resource. Collections have a kind
named for the resource kind, with <code>List</code> appended.</p><p>When you query the API for a particular type, all items returned by that query are
of that type.
For example, when you <strong>list</strong> Services, the collection response
has <code>kind</code> set to
<a href=/docs/reference/kubernetes-api/service-resources/service-v1/#ServiceList><code>ServiceList</code></a>; each item in that collection represents a single Service. For example:</p><pre tabindex=0><code>GET /api/v1/services
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;ServiceList&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;metadata&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;resourceVersion&#34;: </span><span style=color:#b44>&#34;2947301&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;items&#34;: </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;metadata&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;name&#34;: </span><span style=color:#b44>&#34;kubernetes&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;namespace&#34;: </span><span style=color:#b44>&#34;default&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;metadata&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;name&#34;: </span><span style=color:#b44>&#34;kube-dns&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;namespace&#34;: </span><span style=color:#b44>&#34;kube-system&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>There are dozens of collection types (such as <code>PodList</code>, <code>ServiceList</code>,
and <code>NodeList</code>) defined in the Kubernetes API.
You can get more information about each collection type from the
<a href=/docs/reference/kubernetes-api/>Kubernetes API</a> documentation.</p><p>Some tools, such as <code>kubectl</code>, represent the Kubernetes collection
mechanism slightly differently from the Kubernetes API itself.
Because the output of <code>kubectl</code> might include the response from
multiple <strong>list</strong> operations at the API level, <code>kubectl</code> represents
a list of items using <code>kind: List</code>. For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services -A -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-06-03T14:54:12Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>apiserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>provider</span>:<span style=color:#bbb> </span>kubernetes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubernetes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>prometheus.io/port</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;9153&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>prometheus.io/scrape</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-06-03T14:54:14Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>kube-dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/name</span>:<span style=color:#bbb> </span>CoreDNS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Keep in mind that the Kubernetes API does not have a <code>kind</code> named <code>List</code>.</p><p><code>kind: List</code> is a client-side, internal implementation detail for processing
collections that might be of different kinds of object. Avoid depending on
<code>kind: List</code> in automation or other code.</p></div><h2 id=receiving-resources-as-tables>Receiving resources as Tables</h2><p>When you run <code>kubectl get</code>, the default output format is a simple tabular
representation of one or more instances of a particular resource type. In the past,
clients were required to reproduce the tabular and describe output implemented in
<code>kubectl</code> to perform simple lists of objects.
A few limitations of that approach include non-trivial logic when dealing with
certain objects. Additionally, types provided by API aggregation or third party
resources are not known at compile time. This means that generic implementations
had to be in place for types unrecognized by a client.</p><p>In order to avoid potential limitations as described above, clients may request
the Table representation of objects, delegating specific details of printing to the
server. The Kubernetes API implements standard HTTP content type negotiation: passing
an <code>Accept</code> header containing a value of <code>application/json;as=Table;g=meta.k8s.io;v=v1</code>
with a <code>GET</code> call will request that the server return objects in the Table content
type.</p><p>For example, list all of the pods on a cluster in the Table format.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/pods
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/json;as=Table;g=meta.k8s.io;v=v1
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;kind&#34;: &#34;Table&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;apiVersion&#34;: &#34;meta.k8s.io/v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    ...
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;columnDefinitions&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#888>        ...
</span></span></span><span style=display:flex><span><span style=color:#888>    ]
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div><p>For API resource types that do not have a custom Table definition known to the control
plane, the API server returns a default Table response that consists of the resource's
<code>name</code> and <code>creationTimestamp</code> fields.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /apis/crd.example.com/v1alpha1/namespaces/default/resources
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;kind&#34;: &#34;Table&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;apiVersion&#34;: &#34;meta.k8s.io/v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    ...
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;columnDefinitions&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#888>        {
</span></span></span><span style=display:flex><span><span style=color:#888>            &#34;name&#34;: &#34;Name&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>            &#34;type&#34;: &#34;string&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>            ...
</span></span></span><span style=display:flex><span><span style=color:#888>        },
</span></span></span><span style=display:flex><span><span style=color:#888>        {
</span></span></span><span style=display:flex><span><span style=color:#888>            &#34;name&#34;: &#34;Created At&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>            &#34;type&#34;: &#34;date&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>            ...
</span></span></span><span style=display:flex><span><span style=color:#888>        }
</span></span></span><span style=display:flex><span><span style=color:#888>    ]
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div><p>Not all API resource types support a Table response; for example, a
<a class=glossary-tooltip title='Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server.' data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CustomResourceDefinitions>CustomResourceDefinitions</a>
might not define field-to-table mappings, and an APIService that
<a href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>extends the core Kubernetes API</a>
might not serve Table responses at all. If you are implementing a client that
uses the Table information and must work against all resource types, including
extensions, you should make requests that specify multiple content types in the
<code>Accept</code> header. For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>Accept: application/json;as=Table;g=meta.k8s.io;v=v1, application/json
</span></span></span></code></pre></div><h2 id=alternate-representations-of-resources>Alternate representations of resources</h2><p>By default, Kubernetes returns objects serialized to JSON with content type
<code>application/json</code>. This is the default serialization format for the API. However,
clients may request the more efficient
<a href=#protobuf-encoding>Protobuf representation</a> of these objects for better performance at scale.
The Kubernetes API implements standard HTTP content type negotiation: passing an
<code>Accept</code> header with a <code>GET</code> call will request that the server tries to return
a response in your preferred media type, while sending an object in Protobuf to
the server for a <code>PUT</code> or <code>POST</code> call means that you must set the <code>Content-Type</code>
header appropriately.</p><p>The server will return a response with a <code>Content-Type</code> header if the requested
format is supported, or the <code>406 Not acceptable</code> error if none of the media types you
requested are supported. All built-in resource types support the <code>application/json</code>
media type.</p><p>See the Kubernetes <a href=/docs/reference/kubernetes-api/>API reference</a> for a list of
supported content types for each API.</p><p>For example:</p><ol><li><p>List all of the pods on a cluster in Protobuf format.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/pods
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/vnd.kubernetes.protobuf
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/vnd.kubernetes.protobuf
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>... binary encoded PodList object
</span></span></span></code></pre></div></li><li><p>Create a pod by sending Protobuf encoded data to the server, but request a response
in JSON.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>POST /api/v1/namespaces/test/pods
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/vnd.kubernetes.protobuf
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/json
</span></span></span><span style=display:flex><span><span style=color:#888>... binary encoded Pod object
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;kind&#34;: &#34;Pod&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  ...
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div></li></ol><p>Not all API resource types support Protobuf; specifically, Protobuf isn't available for
resources that are defined as
<a class=glossary-tooltip title='Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server.' data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CustomResourceDefinitions>CustomResourceDefinitions</a>
or are served via the
<a class=glossary-tooltip title='The aggregation layer lets you install additional Kubernetes-style APIs in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/ target=_blank aria-label='aggregation layer'>aggregation layer</a>.
As a client, if you might need to work with extension types you should specify multiple
content types in the request <code>Accept</code> header to support fallback to JSON.
For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>Accept: application/vnd.kubernetes.protobuf, application/json
</span></span></span></code></pre></div><h3 id=protobuf-encoding>Kubernetes Protobuf encoding</h3><p>Kubernetes uses an envelope wrapper to encode Protobuf responses. That wrapper starts
with a 4 byte magic number to help identify content in disk or in etcd as Protobuf
(as opposed to JSON), and then is followed by a Protobuf encoded wrapper message, which
describes the encoding and type of the underlying object and then contains the object.</p><p>The wrapper format is:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>A four byte magic number prefix:
</span></span></span><span style=display:flex><span><span style=color:#888>  Bytes 0-3: &#34;k8s\x00&#34; [0x6b, 0x38, 0x73, 0x00]
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>An encoded Protobuf message with the following IDL:
</span></span></span><span style=display:flex><span><span style=color:#888>  message Unknown {
</span></span></span><span style=display:flex><span><span style=color:#888>    // typeMeta should have the string values for &#34;kind&#34; and &#34;apiVersion&#34; as set on the JSON object
</span></span></span><span style=display:flex><span><span style=color:#888>    optional TypeMeta typeMeta = 1;
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>    // raw will hold the complete serialized object in protobuf. See the protobuf definitions in the client libraries for a given kind.
</span></span></span><span style=display:flex><span><span style=color:#888>    optional bytes raw = 2;
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>    // contentEncoding is encoding used for the raw data. Unspecified means no encoding.
</span></span></span><span style=display:flex><span><span style=color:#888>    optional string contentEncoding = 3;
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>    // contentType is the serialization method used to serialize &#39;raw&#39;. Unspecified means application/vnd.kubernetes.protobuf and is usually
</span></span></span><span style=display:flex><span><span style=color:#888>    // omitted.
</span></span></span><span style=display:flex><span><span style=color:#888>    optional string contentType = 4;
</span></span></span><span style=display:flex><span><span style=color:#888>  }
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>  message TypeMeta {
</span></span></span><span style=display:flex><span><span style=color:#888>    // apiVersion is the group/version for this type
</span></span></span><span style=display:flex><span><span style=color:#888>    optional string apiVersion = 1;
</span></span></span><span style=display:flex><span><span style=color:#888>    // kind is the name of the object schema. A protobuf definition should exist for this object.
</span></span></span><span style=display:flex><span><span style=color:#888>    optional string kind = 2;
</span></span></span><span style=display:flex><span><span style=color:#888>  }
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Clients that receive a response in <code>application/vnd.kubernetes.protobuf</code> that does
not match the expected prefix should reject the response, as future versions may need
to alter the serialization format in an incompatible way and will do so by changing
the prefix.</div><h2 id=resource-deletion>Resource deletion</h2><p>When you <strong>delete</strong> a resource this takes place in two phases.</p><ol><li><em>finalization</em></li><li>removal</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;ConfigMap&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;metadata&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;finalizers&#34;: </span>{<span style=color:#b44>&#34;url.io/neat-finalization&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;other-url.io/my-finalizer&#34;</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;deletionTimestamp&#34;: </span>nil,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>When a client first sends a <strong>delete</strong> to request removal of a resource, the <code>.metadata.deletionTimestamp</code> is set to the current time.
Once the <code>.metadata.deletionTimestamp</code> is set, external controllers that act on finalizers
may start performing their cleanup work at any time, in any order.</p><p>Order is <strong>not</strong> enforced between finalizers because it would introduce significant
risk of stuck <code>.metadata.finalizers</code>.</p><p>The <code>.metadata.finalizers</code> field is shared: any actor with permission can reorder it.
If the finalizer list were processed in order, then this might lead to a situation
in which the component responsible for the first finalizer in the list is
waiting for some signal (field value, external system, or other) produced by a
component responsible for a finalizer later in the list, resulting in a deadlock.</p><p>Without enforced ordering, finalizers are free to order amongst themselves and are
not vulnerable to ordering changes in the list.</p><p>Once the last finalizer is removed, the resource is actually removed from etcd.</p><h2 id=single-resource-api>Single resource API</h2><p>The Kubernetes API verbs <strong>get</strong>, <strong>create</strong>, <strong>apply</strong>, <strong>update</strong>, <strong>patch</strong>,
<strong>delete</strong> and <strong>proxy</strong> support single resources only.
These verbs with single resource support have no support for submitting multiple
resources together in an ordered or unordered list or transaction.</p><p>When clients (including kubectl) act on a set of resources, the client makes a series
of single-resource API requests, then aggregates the responses if needed.</p><p>By contrast, the Kubernetes API verbs <strong>list</strong> and <strong>watch</strong> allow getting multiple
resources, and <strong>deletecollection</strong> allows deleting multiple resources.</p><h2 id=field-validation>Field validation</h2><p>Kubernetes always validates the type of fields. For example, if a field in the
API is defined as a number, you cannot set the field to a text value. If a field
is defined as an array of strings, you can only provide an array. Some fields
allow you to omit them, other fields are required. Omitting a required field
from an API request is an error.</p><p>If you make a request with an extra field, one that the cluster's control plane
does not recognize, then the behavior of the API server is more complicated.</p><p>By default, the API server drops fields that it does not recognize
from an input that it receives (for example, the JSON body of a <code>PUT</code> request).</p><p>There are two situations where the API server drops fields that you supplied in
an HTTP request.</p><p>These situations are:</p><ol><li>The field is unrecognized because it is not in the resource's OpenAPI schema. (One
exception to this is for <a class=glossary-tooltip title='Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server.' data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CRDs>CRDs</a> that explicitly choose not to prune unknown
fields via <code>x-kubernetes-preserve-unknown-fields</code>).</li><li>The field is duplicated in the object.</li></ol><h3 id=setting-the-field-validation-level>Setting the field validation level</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [beta]</code></div><p>Provided that the <code>ServerSideFieldValidation</code> <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> is enabled (disabled
by default in 1.23 and 1.24, enabled by default starting in 1.25), you can take
advantage of server side field validation to catch these unrecognized fields.</p><p>When you use HTTP verbs that can submit data (<code>POST</code>, <code>PUT</code>, and <code>PATCH</code>), field
validation gives you the option to choose how you would like to be notified of
these fields that are being dropped by the API server. Possible levels of
validation are <code>Ignore</code>, <code>Warn</code>, and <code>Strict</code>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>If you submit a request that specifies an unrecognized field, and that is also invalid for
a different reason (for example, the request provides a string value where the API expects
an integer), then the API server responds with a 400 Bad Request error response.</p><p>You always receive an error response in this case, no matter what field validation level you requested.</p></div><p>Field validation is set by the <code>fieldValidation</code> query parameter. The three
values that you can provide for this parameter are:</p><dl><dt><code>Ignore</code></dt><dd>The API server succeeds in handling the request as it would without the erroneous fields
being set, dropping all unknown and duplicate fields and giving no indication it
has done so.</dd><dt><code>Warn</code></dt><dd>(Default) The API server succeeds in handling the request, and reports a
warning to the client. The warning is sent using the <code>Warning:</code> response header,
adding one warning item for each unknown or duplicate field. For more
information about warnings and the Kubernetes API, see the blog article
<a href=/blog/2020/09/03/warnings/>Warning: Helpful Warnings Ahead</a>.</dd><dt><code>Strict</code></dt><dd>The API server rejects the request with a 400 Bad Request error when it
detects any unknown or duplicate fields. The response message from the API
server specifies all the unknown or duplicate fields that the API server has
detected.</dd></dl><p>Tools that submit requests to the server (such as <code>kubectl</code>), might set their own
defaults that are different from the <code>Warn</code> validation level that the API server uses
by default.</p><p>The <code>kubectl</code> tool uses the <code>--validate</code> flag to set the level of field validation.
Historically <code>--validate</code> was used to toggle client-side validation on or off as
a boolean flag. Since Kubernetes 1.25, kubectl uses
server-side field validation when sending requests to a serer with this feature
enabled. Validation will fall back to client-side only when it cannot connect
to an API server with field validation enabled.
It accepts the values <code>ignore</code>, <code>warn</code>,
and <code>strict</code> while also accepting the values <code>true</code> (equivalent to <code>strict</code>) and <code>false</code>
(equivalent to <code>ignore</code>). The default validation setting for kubectl is <code>--validate=true</code>,
which means strict server-side field validation.</p><h2 id=dry-run>Dry-run</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>When you use HTTP verbs that can modify resources (<code>POST</code>, <code>PUT</code>, <code>PATCH</code>, and
<code>DELETE</code>), you can submit your request in a <em>dry run</em> mode. Dry run mode helps to
evaluate a request through the typical request stages (admission chain, validation,
merge conflicts) up until persisting objects to storage. The response body for the
request is as close as possible to a non-dry-run response. Kubernetes guarantees that
dry-run requests will not be persisted in storage or have any other side effects.</p><h3 id=make-a-dry-run-request>Make a dry-run request</h3><p>Dry-run is triggered by setting the <code>dryRun</code> query parameter. This parameter is a
string, working as an enum, and the only accepted values are:</p><dl><dt>[no value set]</dt><dd>Allow side effects. You request this with a query string such as <code>?dryRun</code>
or <code>?dryRun&pretty=true</code>. The response is the final object that would have been
persisted, or an error if the request could not be fulfilled.</dd><dt><code>All</code></dt><dd>Every stage runs as normal, except for the final storage stage where side effects
are prevented.</dd></dl><p>When you set <code>?dryRun=All</code>, any relevant
<a class=glossary-tooltip title='A piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/admission-controllers/ target=_blank aria-label='admission controllers'>admission controllers</a>
are run, validating admission controllers check the request post-mutation, merge is
performed on <code>PATCH</code>, fields are defaulted, and schema validation occurs. The changes
are not persisted to the underlying storage, but the final object which would have
been persisted is still returned to the user, along with the normal status code.</p><p>If the non-dry-run version of a request would trigger an admission controller that has
side effects, the request will be failed rather than risk an unwanted side effect. All
built in admission control plugins support dry-run. Additionally, admission webhooks can
declare in their
<a href=/docs/reference/generated/kubernetes-api/v1.25/#validatingwebhook-v1-admissionregistration-k8s-io>configuration object</a>
that they do not have side effects, by setting their <code>sideEffects</code> field to <code>None</code>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> If a webhook actually does have side effects, then the <code>sideEffects</code> field should be
set to "NoneOnDryRun". That change is appropriate provided that the webhook is also
be modified to understand the <code>DryRun</code> field in AdmissionReview, and to prevent side
effects on any request marked as dry runs.</div><p>Here is an example dry-run request that uses <code>?dryRun=All</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>POST /api/v1/namespaces/test/pods?dryRun=All
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/json
</span></span></span></code></pre></div><p>The response would look the same as for non-dry-run request, but the values of some
generated fields may differ.</p><h3 id=generated-values>Generated values</h3><p>Some values of an object are typically generated before the object is persisted. It
is important not to rely upon the values of these fields set by a dry-run request,
since these values will likely be different in dry-run mode from when the real
request is made. Some of these fields are:</p><ul><li><code>name</code>: if <code>generateName</code> is set, <code>name</code> will have a unique random name</li><li><code>creationTimestamp</code> / <code>deletionTimestamp</code>: records the time of creation/deletion</li><li><code>UID</code>: <a href=/docs/concepts/overview/working-with-objects/names/#uids>uniquely identifies</a> the object and is randomly generated (non-deterministic)</li><li><code>resourceVersion</code>: tracks the persisted version of the object</li><li>Any field set by a mutating admission controller</li><li>For the <code>Service</code> resource: Ports or IP addresses that the kube-apiserver assigns to Service objects</li></ul><h3 id=dry-run-authorization>Dry-run authorization</h3><p>Authorization for dry-run and non-dry-run requests is identical. Thus, to make
a dry-run request, you must be authorized to make the non-dry-run request.</p><p>For example, to run a dry-run <strong>patch</strong> for a Deployment, you must be authorized
to perform that <strong>patch</strong>. Here is an example of a rule for Kubernetes
<a class=glossary-tooltip title='Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> that allows patching
Deployments:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;patch&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>See <a href=/docs/reference/access-authn-authz/authorization/>Authorization Overview</a>.</p><h2 id=server-side-apply>Server Side Apply</h2><p>Kubernetes' <a href=/docs/reference/using-api/server-side-apply/>Server Side Apply</a>
feature allows the control plane to track managed fields for newly created objects.
Server Side Apply provides a clear pattern for managing field conflicts,
offers server-side <code>Apply</code> and <code>Update</code> operations, and replaces the
client-side functionality of <code>kubectl apply</code>.</p><p>The API verb for Server-Side Apply is <strong>apply</strong>.
See <a href=/docs/reference/using-api/server-side-apply/>Server Side Apply</a> for more details.</p><h2 id=resource-versions>Resource versions</h2><p>Resource versions are strings that identify the server's internal version of an
object. Resource versions can be used by clients to determine when objects have
changed, or to express data consistency requirements when getting, listing and
watching resources. Resource versions must be treated as opaque by clients and passed
unmodified back to the server.</p><p>You must not assume resource versions are numeric or collatable. API clients may
only compare two resource versions for equality (this means that you must not compare
resource versions for greater-than or less-than relationships).</p><h3 id=resourceversion-in-metadata><code>resourceVersion</code> fields in metadata</h3><p>Clients find resource versions in resources, including the resources from the response
stream for a <strong>watch</strong>, or when using <strong>list</strong> to enumerate resources.</p><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#objectmeta-v1-meta>v1.meta/ObjectMeta</a> - The <code>metadata.resourceVersion</code> of a resource instance identifies the resource version the instance was last modified at.</p><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#listmeta-v1-meta>v1.meta/ListMeta</a> - The <code>metadata.resourceVersion</code> of a resource collection (the response to a <strong>list</strong>) identifies the resource version at which the collection was constructed.</p><h3 id=the-resourceversion-parameter><code>resourceVersion</code> parameters in query strings</h3><p>The <strong>get</strong>, <strong>list</strong>, and <strong>watch</strong> operations support the <code>resourceVersion</code> parameter.
From version v1.19, Kubernetes API servers also support the <code>resourceVersionMatch</code>
parameter on <em>list</em> requests.</p><p>The API server interprets the <code>resourceVersion</code> parameter differently depending
on the operation you request, and on the value of <code>resourceVersion</code>. If you set
<code>resourceVersionMatch</code> then this also affects the way matching happens.</p><h3 id=semantics-for-get-and-list>Semantics for <strong>get</strong> and <strong>list</strong></h3><p>For <strong>get</strong> and <strong>list</strong>, the semantics of <code>resourceVersion</code> are:</p><p><strong>get:</strong></p><table><thead><tr><th>resourceVersion unset</th><th>resourceVersion="0"</th><th>resourceVersion="{value other than 0}"</th></tr></thead><tbody><tr><td>Most Recent</td><td>Any</td><td>Not older than</td></tr></tbody></table><p><strong>list:</strong></p><p>From version v1.19, Kubernetes API servers support the <code>resourceVersionMatch</code> parameter
on <em>list</em> requests. If you set both <code>resourceVersion</code> and <code>resourceVersionMatch</code>, the
<code>resourceVersionMatch</code> parameter determines how the API server interprets
<code>resourceVersion</code>.</p><p>You should always set the <code>resourceVersionMatch</code> parameter when setting
<code>resourceVersion</code> on a <strong>list</strong> request. However, be prepared to handle the case
where the API server that responds is unaware of <code>resourceVersionMatch</code>
and ignores it.</p><p>Unless you have strong consistency requirements, using <code>resourceVersionMatch=NotOlderThan</code> and
a known <code>resourceVersion</code> is preferable since it can achieve better performance and scalability
of your cluster than leaving <code>resourceVersion</code> and <code>resourceVersionMatch</code> unset, which requires
quorum read to be served.</p><p>Setting the <code>resourceVersionMatch</code> parameter without setting <code>resourceVersion</code> is not valid.</p><p>This table explains the behavior of <strong>list</strong> requests with various combinations of
<code>resourceVersion</code> and <code>resourceVersionMatch</code>:</p><table><caption style=display:none>resourceVersionMatch and paging parameters for list</caption><thead><tr><th>resourceVersionMatch param</th><th>paging params</th><th>resourceVersion not set</th><th>resourceVersion="0"</th><th>resourceVersion="{value other than 0}"</th></tr></thead><tbody><tr><td><em>unset</em></td><td><em>limit unset</em></td><td>Most Recent</td><td>Any</td><td>Not older than</td></tr><tr><td><em>unset</em></td><td>limit=&lt;n>, <em>continue unset</em></td><td>Most Recent</td><td>Any</td><td>Exact</td></tr><tr><td><em>unset</em></td><td>limit=&lt;n>, continue=&lt;token></td><td>Continue Token, Exact</td><td>Invalid, treated as Continue Token, Exact</td><td>Invalid, HTTP <code>400 Bad Request</code></td></tr><tr><td><code>resourceVersionMatch=Exact</code></td><td><em>limit unset</em></td><td>Invalid</td><td>Invalid</td><td>Exact</td></tr><tr><td><code>resourceVersionMatch=Exact</code></td><td>limit=&lt;n>, <em>continue unset</em></td><td>Invalid</td><td>Invalid</td><td>Exact</td></tr><tr><td><code>resourceVersionMatch=NotOlderThan</code></td><td><em>limit unset</em></td><td>Invalid</td><td>Any</td><td>Not older than</td></tr><tr><td><code>resourceVersionMatch=NotOlderThan</code></td><td>limit=&lt;n>, <em>continue unset</em></td><td>Invalid</td><td>Any</td><td>Not older than</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Note:</strong> If your cluster's API server does not honor the <code>resourceVersionMatch</code> parameter,
the behavior is the same as if you did not set it.</div><p>The meaning of the <strong>get</strong> and <strong>list</strong> semantics are:</p><dl><dt>Any</dt><dd>Return data at any resource version. The newest available resource version is preferred,
but strong consistency is not required; data at any resource version may be served. It is possible
for the request to return data at a much older resource version that the client has previously
observed, particularly in high availability configurations, due to partitions or stale
caches. Clients that cannot tolerate this should not use this semantic.</dd><dt>Most recent</dt><dd>Return data at the most recent resource version. The returned data must be
consistent (in detail: served from etcd via a quorum read).</dd><dt>Not older than</dt><dd>Return data at least as new as the provided <code>resourceVersion</code>. The newest
available data is preferred, but any data not older than the provided <code>resourceVersion</code> may be
served. For <strong>list</strong> requests to servers that honor the <code>resourceVersionMatch</code> parameter, this
guarantees that the collection's <code>.metadata.resourceVersion</code> is not older than the requested
<code>resourceVersion</code>, but does not make any guarantee about the <code>.metadata.resourceVersion</code> of any
of the items in that collection.</dd><dt>Exact</dt><dd>Return data at the exact resource version provided. If the provided <code>resourceVersion</code> is
unavailable, the server responds with HTTP 410 "Gone". For <strong>list</strong> requests to servers that honor the
<code>resourceVersionMatch</code> parameter, this guarantees that the collection's <code>.metadata.resourceVersion</code>
is the same as the <code>resourceVersion</code> you requested in the query string. That guarantee does
not apply to the <code>.metadata.resourceVersion</code> of any items within that collection.</dd><dt>Continue Token, Exact</dt><dd>Return data at the resource version of the initial paginated <strong>list</strong> call. The returned <em>continue
tokens</em> are responsible for keeping track of the initially provided resource version for all paginated
<strong>list</strong> calls after the initial paginated <strong>list</strong>.</dd></dl><div class="alert alert-info note callout" role=alert><strong>Note:</strong> When you <strong>list</strong> resources and receive a collection response, the response includes the
<a href=/docs/reference/generated/kubernetes-api/v1.21/#listmeta-v1-meta>metadata</a> of the collection as
well as <a href=/docs/reference/generated/kubernetes-api/v1.21/#listmeta-v1-meta>object metadata</a>
for each item in that collection. For individual objects found within a collection response,
<code>.metadata.resourceVersion</code> tracks when that object was last updated, and not how up-to-date
the object is when served.</div><p>When using <code>resourceVersionMatch=NotOlderThan</code> and limit is set, clients must
handle HTTP 410 "Gone" responses. For example, the client might retry with a
newer <code>resourceVersion</code> or fall back to <code>resourceVersion=""</code>.</p><p>When using <code>resourceVersionMatch=Exact</code> and <code>limit</code> is unset, clients must
verify that the collection's <code>.metadata.resourceVersion</code> matches
the requested <code>resourceVersion</code>, and handle the case where it does not. For
example, the client might fall back to a request with <code>limit</code> set.</p><h3 id=semantics-for-watch>Semantics for <strong>watch</strong></h3><p>For <strong>watch</strong>, the semantics of resource version are:</p><p><strong>watch:</strong></p><table><caption style=display:none>resourceVersion for watch</caption><thead><tr><th>resourceVersion unset</th><th>resourceVersion="0"</th><th>resourceVersion="{value other than 0}"</th></tr></thead><tbody><tr><td>Get State and Start at Most Recent</td><td>Get State and Start at Any</td><td>Start at Exact</td></tr></tbody></table><p>The meaning of those <strong>watch</strong> semantics are:</p><dl><dt>Get State and Start at Any</dt><dd><div class="alert alert-warning caution callout" role=alert><strong>Caution:</strong> Watches initialized this way may return arbitrarily stale
data. Please review this semantic before using it, and favor the other semantics
where possible.</div>Start a <strong>watch</strong> at any resource version; the most recent resource version
available is preferred, but not required. Any starting resource version is
allowed. It is possible for the <strong>watch</strong> to start at a much older resource
version that the client has previously observed, particularly in high availability
configurations, due to partitions or stale caches. Clients that cannot tolerate
this apparent rewinding should not start a <strong>watch</strong> with this semantic. To
establish initial state, the <strong>watch</strong> begins with synthetic "Added" events for
all resource instances that exist at the starting resource version. All following
watch events are for all changes that occurred after the resource version the
<strong>watch</strong> started at.</dd><dt>Get State and Start at Most Recent</dt><dd>Start a <strong>watch</strong> at the most recent resource version, which must be consistent
(in detail: served from etcd via a quorum read). To establish initial state,
the <strong>watch</strong> begins with synthetic "Added" events of all resources instances
that exist at the starting resource version. All following watch events are for
all changes that occurred after the resource version the <strong>watch</strong> started at.</dd><dt>Start at Exact</dt><dd>Start a <strong>watch</strong> at an exact resource version. The watch events are for all changes
after the provided resource version. Unlike "Get State and Start at Most Recent"
and "Get State and Start at Any", the <strong>watch</strong> is not started with synthetic
"Added" events for the provided resource version. The client is assumed to already
have the initial state at the starting resource version since the client provided
the resource version.</dd></dl><h3 id=410-gone-responses>"410 Gone" responses</h3><p>Servers are not required to serve all older resource versions and may return a HTTP
<code>410 (Gone)</code> status code if a client requests a <code>resourceVersion</code> older than the
server has retained. Clients must be able to tolerate <code>410 (Gone)</code> responses. See
<a href=#efficient-detection-of-changes>Efficient detection of changes</a> for details on
how to handle <code>410 (Gone)</code> responses when watching resources.</p><p>If you request a <code>resourceVersion</code> outside the applicable limit then, depending
on whether a request is served from cache or not, the API server may reply with a
<code>410 Gone</code> HTTP response.</p><h3 id=unavailable-resource-versions>Unavailable resource versions</h3><p>Servers are not required to serve unrecognized resource versions. If you request
<strong>list</strong> or <strong>get</strong> for a resource version that the API server does not recognize,
then the API server may either:</p><ul><li>wait briefly for the resource version to become available, then timeout with a
<code>504 (Gateway Timeout)</code> if the provided resource versions does not become available
in a reasonable amount of time;</li><li>respond with a <code>Retry-After</code> response header indicating how many seconds a client
should wait before retrying the request.</li></ul><p>If you request a resource version that an API server does not recognize, the
kube-apiserver additionally identifies its error responses with a "Too large resource
version" message.</p><p>If you make a <strong>watch</strong> request for an unrecognized resource version, the API server
may wait indefinitely (until the request timeout) for the resource version to become
available.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-040d9484db673074f1b8ba3465be9d91>2 - Server-Side Apply</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code></div><h2 id=introduction>Introduction</h2><p>Server-Side Apply helps users and controllers manage their resources through
declarative configurations. Clients can create and modify their
<a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>objects</a>
declaratively by sending their fully specified intent.</p><p>A fully specified intent is a partial object that only includes the fields and
values for which the user has an opinion. That intent either creates a new
object or is <a href=#merge-strategy>combined</a>, by the server, with the existing object.</p><p>The system supports multiple appliers collaborating on a single object.</p><p>Changes to an object's fields are tracked through a "<a href=#field-management>field management</a>"
mechanism. When a field's value changes, ownership moves from its current
manager to the manager making the change. When trying to apply an object,
fields that have a different value and are owned by another manager will
result in a <a href=#conflicts>conflict</a>. This is done in order to signal that the
operation might undo another collaborator's changes. Conflicts can be forced,
in which case the value will be overridden, and the ownership will be
transferred.</p><p>If you remove a field from a configuration and apply the configuration,
Server-Side Apply checks if there are any other field managers that also
own the field. If the field is not owned by any other field managers, it
is either deleted from the live object or reset to its default value, if
it has one. The same rule applies to associative list or map items.</p><p>Server-Side Apply is meant both as a replacement for the original <code>kubectl apply</code> and as a simpler mechanism for controllers to enact their changes.</p><p>If you have Server-Side Apply enabled, the control plane tracks managed fields
for all newly created objects.</p><h2 id=field-management>Field Management</h2><p>Compared to the <code>last-applied</code> annotation managed by <code>kubectl</code>, Server-Side
Apply uses a more declarative approach, which tracks a user's field management,
rather than a user's last applied state. This means that as a side effect of
using Server-Side Apply, information about which field manager manages each
field in an object also becomes available.</p><p>For a user to manage a field, in the Server-Side Apply sense, means that the
user relies on and expects the value of the field not to change. The user who
last made an assertion about the value of a field will be recorded as the
current field manager. This can be done either by changing the value with
<code>POST</code>, <code>PUT</code>, or non-apply <code>PATCH</code>, or by including the field in a config sent
to the Server-Side Apply endpoint. When using Server-Side Apply, trying to
change a field which is managed by someone else will result in a rejected
request (if not forced, see <a href=#conflicts>Conflicts</a>).</p><p>When two or more appliers set a field to the same value, they share ownership of
that field. Any subsequent attempt to change the value of the shared field, by any of
the appliers, results in a conflict. Shared field owners may give up ownership
of a field by removing it from their configuration.</p><p>Field management is stored in a<code>managedFields</code> field that is part of an object's
<a href=/docs/reference/generated/kubernetes-api/v1.25/#objectmeta-v1-meta><code>metadata</code></a>.</p><p>A simple example of an object created by Server-Side Apply could look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test-label</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kubectl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>time</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2010-10-10T0:00:00Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fieldsType</span>:<span style=color:#bbb> </span>FieldsV1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fieldsV1</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>f:test-label</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:key</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>some value<span style=color:#bbb>
</span></span></span></code></pre></div><p>The above object contains a single manager in <code>metadata.managedFields</code>. The
manager consists of basic information about the managing entity itself, like
operation type, API version, and the fields managed by it.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> This field is managed by the API server and should not be changed by
the user.</div><p>Nevertheless it is possible to change <code>metadata.managedFields</code> through an
<code>Update</code> operation. Doing so is highly discouraged, but might be a reasonable
option to try if, for example, the <code>managedFields</code> get into an inconsistent
state (which clearly should not happen).</p><p>The format of the <code>managedFields</code> is described in the
<a href=/docs/reference/generated/kubernetes-api/v1.25/#fieldsv1-v1-meta>API</a>.</p><h2 id=conflicts>Conflicts</h2><p>A conflict is a special status error that occurs when an <code>Apply</code> operation tries
to change a field, which another user also claims to manage. This prevents an
applier from unintentionally overwriting the value set by another user. When
this occurs, the applier has 3 options to resolve the conflicts:</p><ul><li><p><strong>Overwrite value, become sole manager:</strong> If overwriting the value was
intentional (or if the applier is an automated process like a controller) the
applier should set the <code>force</code> query parameter to true (in kubectl, it can be done by
using the <code>--force-conflicts</code> flag with the apply command) and make the request
again. This forces the operation to succeed, changes the value of the field,
and removes the field from all other managers' entries in managedFields.</p></li><li><p><strong>Don't overwrite value, give up management claim:</strong> If the applier doesn't
care about the value of the field anymore, they can remove it from their
config and make the request again. This leaves the value unchanged, and causes
the field to be removed from the applier's entry in managedFields.</p></li><li><p><strong>Don't overwrite value, become shared manager:</strong> If the applier still cares
about the value of the field, but doesn't want to overwrite it, they can
change the value of the field in their config to match the value of the object
on the server, and make the request again. This leaves the value unchanged,
and causes the field's management to be shared by the applier and all other
field managers that already claimed to manage it.</p></li></ul><h2 id=managers>Managers</h2><p>Managers identify distinct workflows that are modifying the object (especially
useful on conflicts!), and can be specified through the <code>fieldManager</code> query
parameter as part of a modifying request. It is required for the apply endpoint,
though kubectl will default it to <code>kubectl</code>. For other updates, its default is
computed from the user-agent.</p><h2 id=apply-and-update>Apply and Update</h2><p>The two operation types considered by this feature are <code>Apply</code> (<code>PATCH</code> with
content type <code>application/apply-patch+yaml</code>) and <code>Update</code> (all other operations
which modify the object). Both operations update the <code>managedFields</code>, but behave
a little differently.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Whether you are submitting JSON data or YAML data, use
<code>application/apply-patch+yaml</code> as the <code>Content-Type</code> header value.</p><p>All JSON documents are valid YAML.</p></div><p>For instance, only the apply operation fails on conflicts while update does
not. Also, apply operations are required to identify themselves by providing a
<code>fieldManager</code> query parameter, while the query parameter is optional for update
operations. Finally, when using the apply operation you cannot have
<code>managedFields</code> in the object that is being applied.</p><p>An example object with multiple managers could look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test-label</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kubectl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>f:test-label</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kube-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>time</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;2019-03-30T16:00:00.000Z&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:key</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>new value<span style=color:#bbb>
</span></span></span></code></pre></div><p>In this example, a second operation was run as an <code>Update</code> by the manager called
<code>kube-controller-manager</code>. The update changed a value in the data field which
caused the field's management to change to the <code>kube-controller-manager</code>.</p><p>If this update would have been an <code>Apply</code> operation, the operation
would have failed due to conflicting ownership.</p><h2 id=merge-strategy>Merge strategy</h2><p>The merging strategy, implemented with Server-Side Apply, provides a generally
more stable object lifecycle. Server-Side Apply tries to merge fields based on
the actor who manages them instead of overruling based on values. This way
multiple actors can update the same object without causing unexpected interference.</p><p>When a user sends a "fully-specified intent" object to the Server-Side Apply
endpoint, the server merges it with the live object favoring the value in the
applied config if it is specified in both places. If the set of items present in
the applied config is not a superset of the items applied by the same user last
time, each missing item not managed by any other appliers is removed. For
more information about how an object's schema is used to make decisions when
merging, see
<a href=https://sigs.k8s.io/structured-merge-diff>sigs.k8s.io/structured-merge-diff</a>.</p><p>A number of markers were added in Kubernetes 1.16 and 1.17, to allow API
developers to describe the merge strategy supported by lists, maps, and
structs. These markers can be applied to objects of the respective type,
in Go files or in the OpenAPI schema definition of the
<a href=/docs/reference/generated/kubernetes-api/v1.25#jsonschemaprops-v1-apiextensions-k8s-io>CRD</a>:</p><table><thead><tr><th>Golang marker</th><th>OpenAPI extension</th><th>Accepted values</th><th>Description</th><th>Introduced in</th></tr></thead><tbody><tr><td><code>//+listType</code></td><td><code>x-kubernetes-list-type</code></td><td><code>atomic</code>/<code>set</code>/<code>map</code></td><td>Applicable to lists. <code>set</code> applies to lists that include only scalar elements. These elements must be unique. <code>map</code> applies to lists of nested types only. The key values (see <code>listMapKey</code>) must be unique in the list. <code>atomic</code> can apply to any list. If configured as <code>atomic</code>, the entire list is replaced during merge. At any point in time, a single manager owns the list. If <code>set</code> or <code>map</code>, different managers can manage entries separately.</td><td>1.16</td></tr><tr><td><code>//+listMapKey</code></td><td><code>x-kubernetes-list-map-keys</code></td><td>List of field names, e.g. <code>["port", "protocol"]</code></td><td>Only applicable when <code>+listType=map</code>. A list of field names whose values uniquely identify entries in the list. While there can be multiple keys, <code>listMapKey</code> is singular because keys need to be specified individually in the Go type. The key fields must be scalars.</td><td>1.16</td></tr><tr><td><code>//+mapType</code></td><td><code>x-kubernetes-map-type</code></td><td><code>atomic</code>/<code>granular</code></td><td>Applicable to maps. <code>atomic</code> means that the map can only be entirely replaced by a single manager. <code>granular</code> means that the map supports separate managers updating individual fields.</td><td>1.17</td></tr><tr><td><code>//+structType</code></td><td><code>x-kubernetes-map-type</code></td><td><code>atomic</code>/<code>granular</code></td><td>Applicable to structs; otherwise same usage and OpenAPI annotation as <code>//+mapType</code>.</td><td>1.17</td></tr></tbody></table><p>If <code>listType</code> is missing, the API server interprets a
<code>patchMergeStrategy=merge</code> marker as a <code>listType=map</code> and the
corresponding <code>patchMergeKey</code> marker as a <code>listMapKey</code>.</p><p>The <code>atomic</code> list type is recursive.</p><p>These markers are specified as comments and don't have to be repeated as
field tags.</p><h3 id=compatibility-across-topology-changes>Compatibility across topology changes</h3><p>On rare occurrences, a CRD or built-in type author may want to change the
specific topology of a field in their resource without incrementing its
version. Changing the topology of types, by upgrading the cluster or
updating the CRD, has different consequences when updating existing
objects. There are two categories of changes: when a field goes from
<code>map</code>/<code>set</code>/<code>granular</code> to <code>atomic</code> and the other way around.</p><p>When the <code>listType</code>, <code>mapType</code>, or <code>structType</code> changes from
<code>map</code>/<code>set</code>/<code>granular</code> to <code>atomic</code>, the whole list, map, or struct of
existing objects will end-up being owned by actors who owned an element
of these types. This means that any further change to these objects
would cause a conflict.</p><p>When a list, map, or struct changes from <code>atomic</code> to
<code>map</code>/<code>set</code>/<code>granular</code>, the API server won't be able to infer the new
ownership of these fields. Because of that, no conflict will be produced
when objects have these fields updated. For that reason, it is not
recommended to change a type from <code>atomic</code> to <code>map</code>/<code>set</code>/<code>granular</code>.</p><p>Take for example, the custom resource:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-sample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>manager-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key1</span>:<span style=color:#bbb> </span>val1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key2</span>:<span style=color:#bbb> </span>val2<span style=color:#bbb>
</span></span></span></code></pre></div><p>Before <code>spec.data</code> gets changed from <code>atomic</code> to <code>granular</code>,
<code>manager-one</code> owns the field <code>spec.data</code>, and all the fields within it
(<code>key1</code> and <code>key2</code>). When the CRD gets changed to make <code>spec.data</code>
<code>granular</code>, <code>manager-one</code> continues to own the top-level field
<code>spec.data</code> (meaning no other managers can delete the map called <code>data</code>
without a conflict), but it no longer owns <code>key1</code> and <code>key2</code>, so another
manager can then modify or delete those fields without conflict.</p><h2 id=custom-resources>Custom Resources</h2><p>By default, Server-Side Apply treats custom resources as unstructured data. All
keys are treated the same as struct fields, and all lists are considered atomic.</p><p>If the Custom Resource Definition defines a
<a href=/docs/reference/generated/kubernetes-api/v1.25#jsonschemaprops-v1-apiextensions-k8s-io>schema</a>
that contains annotations as defined in the previous "Merge Strategy"
section, these annotations will be used when merging objects of this
type.</p><h2 id=using-server-side-apply-in-a-controller>Using Server-Side Apply in a controller</h2><p>As a developer of a controller, you can use server-side apply as a way to
simplify the update logic of your controller. The main differences with a
read-modify-write and/or patch are the following:</p><ul><li>the applied object must contain all the fields that the controller cares about.</li><li>there is no way to remove fields that haven't been applied by the controller
before (controller can still send a PATCH/UPDATE for these use-cases).</li><li>the object doesn't have to be read beforehand, <code>resourceVersion</code> doesn't have
to be specified.</li></ul><p>It is strongly recommended for controllers to always "force" conflicts, since they
might not be able to resolve or act on these conflicts.</p><h2 id=transferring-ownership>Transferring Ownership</h2><p>In addition to the concurrency controls provided by <a href=#conflicts>conflict resolution</a>,
Server-Side Apply provides ways to perform coordinated
field ownership transfers from users to controllers.</p><p>This is best explained by example. Let's look at how to safely transfer
ownership of the <code>replicas</code> field from a user to a controller while enabling
automatic horizontal scaling for a Deployment, using the HorizontalPodAutoscaler
resource and its accompanying controller.</p><p>Say a user has defined deployment with <code>replicas</code> set to the desired value:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/ssa/nginx-deployment.yaml download=application/ssa/nginx-deployment.yaml><code>application/ssa/nginx-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-ssa-nginx-deployment-yaml")' title="Copy application/ssa/nginx-deployment.yaml to clipboard"></img></div><div class=includecode id=application-ssa-nginx-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>And the user has created the deployment using Server-Side Apply like so:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment.yaml --server-side
</span></span></code></pre></div><p>Then later, HPA is enabled for the deployment, e.g.:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment nginx-deployment --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span> --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><p>Now, the user would like to remove <code>replicas</code> from their configuration, so they
don't accidentally fight with the HPA controller. However, there is a race: it
might take some time before HPA feels the need to adjust <code>replicas</code>, and if
the user removes <code>replicas</code> before the HPA writes to the field and becomes
its owner, then apiserver will set <code>replicas</code> to 1, its default value. This
is not what the user wants to happen, even temporarily.</p><p>There are two solutions:</p><ul><li><p>(basic) Leave <code>replicas</code> in the configuration; when HPA eventually writes to that
field, the system gives the user a conflict over it. At that point, it is safe
to remove from the configuration.</p></li><li><p>(more advanced) If, however, the user doesn't want to wait, for example
because they want to keep the cluster legible to coworkers, then they can take
the following steps to make it safe to remove <code>replicas</code> from their
configuration:</p></li></ul><p>First, the user defines a new configuration containing only the <code>replicas</code> field:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/ssa/nginx-deployment-replicas-only.yaml download=application/ssa/nginx-deployment-replicas-only.yaml><code>application/ssa/nginx-deployment-replicas-only.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-ssa-nginx-deployment-replicas-only-yaml")' title="Copy application/ssa/nginx-deployment-replicas-only.yaml to clipboard"></img></div><div class=includecode id=application-ssa-nginx-deployment-replicas-only-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>The user applies that configuration using the field manager name <code>handover-to-hpa</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment-replicas-only.yaml <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --server-side --field-manager<span style=color:#666>=</span>handover-to-hpa <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --validate<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><p>If the apply results in a conflict with the HPA controller, then do nothing. The
conflict indicates the controller has claimed the field earlier in the
process than it sometimes does.</p><p>At this point the user may remove the <code>replicas</code> field from their configuration.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/ssa/nginx-deployment-no-replicas.yaml download=application/ssa/nginx-deployment-no-replicas.yaml><code>application/ssa/nginx-deployment-no-replicas.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-ssa-nginx-deployment-no-replicas-yaml")' title="Copy application/ssa/nginx-deployment-no-replicas.yaml to clipboard"></img></div><div class=includecode id=application-ssa-nginx-deployment-no-replicas-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Note that whenever the HPA controller sets the <code>replicas</code> field to a new value,
the temporary field manager will no longer own any fields and will be
automatically deleted. No clean up is required.</p><h3 id=transferring-ownership-between-users>Transferring Ownership Between Users</h3><p>Users can transfer ownership of a field between each other by setting the field
to the same value in both of their applied configs, causing them to share
ownership of the field. Once the users share ownership of the field, one of them
can remove the field from their applied configuration to give up ownership and
complete the transfer to the other user.</p><h2 id=comparison-with-client-side-apply>Comparison with Client Side Apply</h2><p>A consequence of the conflict detection and resolution implemented by Server-Side
Apply is that an applier always has up to date field values in their local
state. If they don't, they get a conflict the next time they apply. Any of the
three options to resolve conflicts results in the applied configuration being an
up to date subset of the object on the server's fields.</p><p>This is different from Client Side Apply, where outdated values which have been
overwritten by other users are left in an applier's local config. These values
only become accurate when the user updates that specific field, if ever, and an
applier has no way of knowing whether their next apply will overwrite other
users' changes.</p><p>Another difference is that an applier using Client Side Apply is unable to
change the API version they are using, but Server-Side Apply supports this use
case.</p><h2 id=upgrading-from-client-side-apply-to-server-side-apply>Upgrading from client-side apply to server-side apply</h2><p>Client-side apply users who manage a resource with <code>kubectl apply</code> can start
using server-side apply with the following flag.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply --server-side <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</span></span></code></pre></div><p>By default, field management of the object transfers from client-side apply to
kubectl server-side apply without encountering conflicts.</p><div class="alert alert-warning caution callout" role=alert><strong>Caution:</strong><p>Keep the <code>last-applied-configuration</code> annotation up to date.
The annotation infers client-side apply's managed fields.
Any fields not managed by client-side apply raise conflicts.</p><p>For example, if you used <code>kubectl scale</code> to update the replicas field after
client-side apply, then this field is not owned by client-side apply and
creates conflicts on <code>kubectl apply --server-side</code>.</p></div><p>This behavior applies to server-side apply with the <code>kubectl</code> field manager.
As an exception, you can opt-out of this behavior by specifying a different,
non-default field manager, as seen in the following example. The default field
manager for kubectl server-side apply is <code>kubectl</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply --server-side --field-manager<span style=color:#666>=</span>my-manager <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</span></span></code></pre></div><h2 id=downgrading-from-server-side-apply-to-client-side-apply>Downgrading from server-side apply to client-side apply</h2><p>If you manage a resource with <code>kubectl apply --server-side</code>,
you can downgrade to client-side apply directly with <code>kubectl apply</code>.</p><p>Downgrading works because kubectl server-side apply keeps the
<code>last-applied-configuration</code> annotation up-to-date if you use
<code>kubectl apply</code>.</p><p>This behavior applies to server-side apply with the <code>kubectl</code> field manager.
As an exception, you can opt-out of this behavior by specifying a different,
non-default field manager, as seen in the following example. The default field
manager for kubectl server-side apply is <code>kubectl</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply --server-side --field-manager<span style=color:#666>=</span>my-manager <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</span></span></code></pre></div><h2 id=api-endpoint>API Endpoint</h2><p>With the Server-Side Apply feature enabled, the <code>PATCH</code> endpoint accepts the
additional <code>application/apply-patch+yaml</code> content type. Users of Server-Side
Apply can send partially specified objects as YAML to this endpoint. When
applying a configuration, one should always include all the fields that they
have an opinion about.</p><h3 id=rbac-and-permissions>RBAC and permissions</h3><p>Since Server-Side Apply is a type of <code>PATCH</code>, a role will require the
<code>PATCH</code> permission to edit resources, but will also need the <code>CREATE</code>
verb permission in order to create resources with Server-Side Apply.</p><h2 id=clearing-managedfields>Clearing ManagedFields</h2><p>It is possible to strip all managedFields from an object by overwriting them
using <code>MergePatch</code>, <code>StrategicMergePatch</code>, <code>JSONPatch</code>, or <code>Update</code>, so every
non-apply operation. This can be done by overwriting the managedFields field
with an empty entry. Two examples are:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>PATCH /api/v1/namespaces/default/configmaps/example-cm
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/merge-patch+json
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/json
</span></span></span><span style=display:flex><span><span style=color:#888>Data: {&#34;metadata&#34;:{&#34;managedFields&#34;: [{}]}}
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>PATCH /api/v1/namespaces/default/configmaps/example-cm
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json-patch+json
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/json
</span></span></span><span style=display:flex><span><span style=color:#888>Data: [{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/metadata/managedFields&#34;, &#34;value&#34;: [{}]}]
</span></span></span></code></pre></div><p>This will overwrite the managedFields with a list containing a single empty
entry that then results in the managedFields being stripped entirely from the
object. Note that setting the managedFields to an empty list will not
reset the field. This is on purpose, so managedFields never get stripped by
clients not aware of the field.</p><p>In cases where the reset operation is combined with changes to other fields
than the managedFields, this will result in the managedFields being reset
first and the other changes being processed afterwards. As a result the
applier takes ownership of any fields updated in the same request.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-79880efc25dc8cb3b6962ad78a964319>3 - Client Libraries</h1><p>This page contains an overview of the client libraries for using the Kubernetes
API from various programming languages.</p><p>To write applications using the <a href=/docs/reference/using-api/>Kubernetes REST API</a>,
you do not need to implement the API calls and request/response types yourself.
You can use a client library for the programming language you are using.</p><p>Client libraries often handle common tasks such as authentication for you.
Most client libraries can discover and use the Kubernetes Service Account to
authenticate if the API client is running inside the Kubernetes cluster, or can
understand the <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig file</a>
format to read the credentials and the API Server address.</p><h2 id=officially-supported-kubernetes-client-libraries>Officially-supported Kubernetes client libraries</h2><p>The following client libraries are officially maintained by
<a href=https://github.com/kubernetes/community/tree/master/sig-api-machinery>Kubernetes SIG API Machinery</a>.</p><table><thead><tr><th>Language</th><th>Client Library</th><th>Sample Programs</th></tr></thead><tbody><tr><td>C</td><td><a href=https://github.com/kubernetes-client/c/>github.com/kubernetes-client/c</a></td><td><a href=https://github.com/kubernetes-client/c/tree/master/examples>browse</a></td></tr><tr><td>dotnet</td><td><a href=https://github.com/kubernetes-client/csharp>github.com/kubernetes-client/csharp</a></td><td><a href=https://github.com/kubernetes-client/csharp/tree/master/examples/simple>browse</a></td></tr><tr><td>Go</td><td><a href=https://github.com/kubernetes/client-go/>github.com/kubernetes/client-go/</a></td><td><a href=https://github.com/kubernetes/client-go/tree/master/examples>browse</a></td></tr><tr><td>Haskell</td><td><a href=https://github.com/kubernetes-client/haskell>github.com/kubernetes-client/haskell</a></td><td><a href=https://github.com/kubernetes-client/haskell/tree/master/kubernetes-client/example>browse</a></td></tr><tr><td>Java</td><td><a href=https://github.com/kubernetes-client/java/>github.com/kubernetes-client/java</a></td><td><a href=https://github.com/kubernetes-client/java/tree/master/examples>browse</a></td></tr><tr><td>JavaScript</td><td><a href=https://github.com/kubernetes-client/javascript>github.com/kubernetes-client/javascript</a></td><td><a href=https://github.com/kubernetes-client/javascript/tree/master/examples>browse</a></td></tr><tr><td>Perl</td><td><a href=https://github.com/kubernetes-client/perl/>github.com/kubernetes-client/perl/</a></td><td><a href=https://github.com/kubernetes-client/perl/tree/master/examples>browse</a></td></tr><tr><td>Python</td><td><a href=https://github.com/kubernetes-client/python/>github.com/kubernetes-client/python/</a></td><td><a href=https://github.com/kubernetes-client/python/tree/master/examples>browse</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/kubernetes-client/ruby/>github.com/kubernetes-client/ruby/</a></td><td><a href=https://github.com/kubernetes-client/ruby/tree/master/examples>browse</a></td></tr></tbody></table><h2 id=community-maintained-client-libraries>Community-maintained client libraries</h2><div class="alert alert-secondary callout third-party-content" role=alert><strong>Note:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div><p>The following Kubernetes API client libraries are provided and maintained by
their authors, not the Kubernetes team.</p><table><thead><tr><th>Language</th><th>Client Library</th></tr></thead><tbody><tr><td>Clojure</td><td><a href=https://github.com/yanatan16/clj-kubernetes-api>github.com/yanatan16/clj-kubernetes-api</a></td></tr><tr><td>DotNet</td><td><a href=https://github.com/tonnyeremin/kubernetes_gen>github.com/tonnyeremin/kubernetes_gen</a></td></tr><tr><td>DotNet (RestSharp)</td><td><a href=https://github.com/masroorhasan/Kubernetes.DotNet>github.com/masroorhasan/Kubernetes.DotNet</a></td></tr><tr><td>Elixir</td><td><a href=https://github.com/obmarg/kazan/>github.com/obmarg/kazan</a></td></tr><tr><td>Elixir</td><td><a href=https://github.com/coryodaniel/k8s>github.com/coryodaniel/k8s</a></td></tr><tr><td>Go</td><td><a href=https://github.com/ericchiang/k8s>github.com/ericchiang/k8s</a></td></tr><tr><td>Java (OSGi)</td><td><a href=https://bitbucket.org/amdatulabs/amdatu-kubernetes>bitbucket.org/amdatulabs/amdatu-kubernetes</a></td></tr><tr><td>Java (Fabric8, OSGi)</td><td><a href=https://github.com/fabric8io/kubernetes-client>github.com/fabric8io/kubernetes-client</a></td></tr><tr><td>Java</td><td><a href=https://github.com/manusa/yakc>github.com/manusa/yakc</a></td></tr><tr><td>Lisp</td><td><a href=https://github.com/brendandburns/cl-k8s>github.com/brendandburns/cl-k8s</a></td></tr><tr><td>Lisp</td><td><a href=https://github.com/xh4/cube>github.com/xh4/cube</a></td></tr><tr><td>Node.js (TypeScript)</td><td><a href=https://github.com/Goyoo/node-k8s-client>github.com/Goyoo/node-k8s-client</a></td></tr><tr><td>Node.js</td><td><a href=https://github.com/ajpauwels/easy-k8s>github.com/ajpauwels/easy-k8s</a></td></tr><tr><td>Node.js</td><td><a href=https://github.com/godaddy/kubernetes-client>github.com/godaddy/kubernetes-client</a></td></tr><tr><td>Node.js</td><td><a href=https://github.com/tenxcloud/node-kubernetes-client>github.com/tenxcloud/node-kubernetes-client</a></td></tr><tr><td>Perl</td><td><a href=https://metacpan.org/pod/Net::Kubernetes>metacpan.org/pod/Net::Kubernetes</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/allansun/kubernetes-php-client>github.com/allansun/kubernetes-php-client</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/maclof/kubernetes-client>github.com/maclof/kubernetes-client</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/travisghansen/kubernetes-client-php>github.com/travisghansen/kubernetes-client-php</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/renoki-co/php-k8s>github.com/renoki-co/php-k8s</a></td></tr><tr><td>Python</td><td><a href=https://github.com/fiaas/k8s>github.com/fiaas/k8s</a></td></tr><tr><td>Python</td><td><a href=https://github.com/gtsystem/lightkube>github.com/gtsystem/lightkube</a></td></tr><tr><td>Python</td><td><a href=https://github.com/mnubo/kubernetes-py>github.com/mnubo/kubernetes-py</a></td></tr><tr><td>Python</td><td><a href=https://github.com/tomplus/kubernetes_asyncio>github.com/tomplus/kubernetes_asyncio</a></td></tr><tr><td>Python</td><td><a href=https://github.com/Frankkkkk/pykorm>github.com/Frankkkkk/pykorm</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/abonas/kubeclient>github.com/abonas/kubeclient</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/k8s-ruby/k8s-ruby>github.com/k8s-ruby/k8s-ruby</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/kontena/k8s-client>github.com/kontena/k8s-client</a></td></tr><tr><td>Rust</td><td><a href=https://github.com/clux/kube-rs>github.com/clux/kube-rs</a></td></tr><tr><td>Rust</td><td><a href=https://github.com/ynqa/kubernetes-rust>github.com/ynqa/kubernetes-rust</a></td></tr><tr><td>Scala</td><td><a href=https://github.com/hagay3/skuber>github.com/hagay3/skuber</a></td></tr><tr><td>Scala</td><td><a href=https://github.com/hnaderi/scala-k8s>github.com/hnaderi/scala-k8s</a></td></tr><tr><td>Scala</td><td><a href=https://github.com/joan38/kubernetes-client>github.com/joan38/kubernetes-client</a></td></tr><tr><td>Swift</td><td><a href=https://github.com/swiftkube/client>github.com/swiftkube/client</a></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-8d2ce3e7b2223cda0ccd428f4d5ea24b>4 - Kubernetes Deprecation Policy</h1><p>This document details the deprecation policy for various facets of the system.</p><p>Kubernetes is a large system with many components and many contributors. As
with any such software, the feature set naturally evolves over time, and
sometimes a feature may need to be removed. This could include an API, a flag,
or even an entire feature. To avoid breaking existing users, Kubernetes follows
a deprecation policy for aspects of the system that are slated to be removed.</p><h2 id=deprecating-parts-of-the-api>Deprecating parts of the API</h2><p>Since Kubernetes is an API-driven system, the API has evolved over time to
reflect the evolving understanding of the problem space. The Kubernetes API is
actually a set of APIs, called "API groups", and each API group is
independently versioned. <a href=/docs/reference/using-api/#api-versioning>API versions</a> fall
into 3 main tracks, each of which has different policies for deprecation:</p><table><thead><tr><th>Example</th><th>Track</th></tr></thead><tbody><tr><td>v1</td><td>GA (generally available, stable)</td></tr><tr><td>v1beta1</td><td>Beta (pre-release)</td></tr><tr><td>v1alpha1</td><td>Alpha (experimental)</td></tr></tbody></table><p>A given release of Kubernetes can support any number of API groups and any
number of versions of each.</p><p>The following rules govern the deprecation of elements of the API. This
includes:</p><ul><li>REST resources (aka API objects)</li><li>Fields of REST resources</li><li>Annotations on REST resources, including "beta" annotations but not
including "alpha" annotations.</li><li>Enumerated or constant values</li><li>Component config structures</li></ul><p>These rules are enforced between official releases, not between
arbitrary commits to master or release branches.</p><p><strong>Rule #1: API elements may only be removed by incrementing the version of the
API group.</strong></p><p>Once an API element has been added to an API group at a particular version, it
can not be removed from that version or have its behavior significantly
changed, regardless of track.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> For historical reasons, there are 2 "monolithic" API groups - "core" (no
group name) and "extensions". Resources will incrementally be moved from these
legacy API groups into more domain-specific API groups.</div><p><strong>Rule #2: API objects must be able to round-trip between API versions in a given
release without information loss, with the exception of whole REST resources
that do not exist in some versions.</strong></p><p>For example, an object can be written as v1 and then read back as v2 and
converted to v1, and the resulting v1 resource will be identical to the
original. The representation in v2 might be different from v1, but the system
knows how to convert between them in both directions. Additionally, any new
field added in v2 must be able to round-trip to v1 and back, which means v1
might have to add an equivalent field or represent it as an annotation.</p><p><strong>Rule #3: An API version in a given track may not be deprecated in favor of a less stable API version.</strong></p><ul><li>GA API versions can replace beta and alpha API versions.</li><li>Beta API versions can replace earlier beta and alpha API versions, but <em>may not</em> replace GA API versions.</li><li>Alpha API versions can replace earlier alpha API versions, but <em>may not</em> replace GA or beta API versions.</li></ul><p><strong>Rule #4a: API lifetime is determined by the API stability level</strong></p><ul><li>GA API versions may be marked as deprecated, but must not be removed within a major version of Kubernetes</li><li>Beta API versions are deprecated no more than 9 months or 3 minor releases after introduction (whichever is longer),
and are no longer served 9 months or 3 minor releases after deprecation (whichever is longer)</li><li>Alpha API versions may be removed in any release without prior deprecation notice</li></ul><p>This ensures beta API support covers the <a href=/releases/version-skew-policy/>maximum supported version skew of 2 releases</a>,
and that APIs don't stagnate on unstable beta versions, accumulating production usage that will be disrupted when support for the beta API ends.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> There are no current plans for a major version revision of Kubernetes that removes GA APIs.</div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Until <a href=https://github.com/kubernetes/kubernetes/issues/52185>#52185</a> is
resolved, no API versions that have been persisted to storage may be removed.
Serving REST endpoints for those versions may be disabled (subject to the
deprecation timelines in this document), but the API server must remain capable
of decoding/converting previously persisted data from storage.</div><p><strong>Rule #4b: The "preferred" API version and the "storage version" for a given
group may not advance until after a release has been made that supports both the
new version and the previous version</strong></p><p>Users must be able to upgrade to a new release of Kubernetes and then roll back
to a previous release, without converting anything to the new API version or
suffering breakages (unless they explicitly used features only available in the
newer version). This is particularly evident in the stored representation of
objects.</p><p>All of this is best illustrated by examples. Imagine a Kubernetes release,
version X, which introduces a new API group. A new Kubernetes release is made
every approximately 4 months (3 per year). The following table describes which
API versions are supported in a series of subsequent releases.</p><table><thead><tr><th>Release</th><th>API Versions</th><th>Preferred/Storage Version</th><th>Notes</th></tr></thead><tbody><tr><td>X</td><td>v1alpha1</td><td>v1alpha1</td><td></td></tr><tr><td>X+1</td><td>v1alpha2</td><td>v1alpha2</td><td><ul><li>v1alpha1 is removed, "action required" relnote</li></ul></td></tr><tr><td>X+2</td><td>v1beta1</td><td>v1beta1</td><td><ul><li>v1alpha2 is removed, "action required" relnote</li></ul></td></tr><tr><td>X+3</td><td>v1beta2, v1beta1 (deprecated)</td><td>v1beta1</td><td><ul><li>v1beta1 is deprecated, "action required" relnote</li></ul></td></tr><tr><td>X+4</td><td>v1beta2, v1beta1 (deprecated)</td><td>v1beta2</td><td></td></tr><tr><td>X+5</td><td>v1, v1beta1 (deprecated), v1beta2 (deprecated)</td><td>v1beta2</td><td><ul><li>v1beta2 is deprecated, "action required" relnote</li></ul></td></tr><tr><td>X+6</td><td>v1, v1beta2 (deprecated)</td><td>v1</td><td><ul><li>v1beta1 is removed, "action required" relnote</li></ul></td></tr><tr><td>X+7</td><td>v1, v1beta2 (deprecated)</td><td>v1</td><td></td></tr><tr><td>X+8</td><td>v2alpha1, v1</td><td>v1</td><td><ul><li>v1beta2 is removed, "action required" relnote</li></ul></td></tr><tr><td>X+9</td><td>v2alpha2, v1</td><td>v1</td><td><ul><li>v2alpha1 is removed, "action required" relnote</li></ul></td></tr><tr><td>X+10</td><td>v2beta1, v1</td><td>v1</td><td><ul><li>v2alpha2 is removed, "action required" relnote</li></ul></td></tr><tr><td>X+11</td><td>v2beta2, v2beta1 (deprecated), v1</td><td>v1</td><td><ul><li>v2beta1 is deprecated, "action required" relnote</li></ul></td></tr><tr><td>X+12</td><td>v2, v2beta2 (deprecated), v2beta1 (deprecated), v1 (deprecated)</td><td>v1</td><td><ul><li>v2beta2 is deprecated, "action required" relnote</li><li>v1 is deprecated in favor of v2, but will not be removed</li></ul></td></tr><tr><td>X+13</td><td>v2, v2beta1 (deprecated), v2beta2 (deprecated), v1 (deprecated)</td><td>v2</td><td></td></tr><tr><td>X+14</td><td>v2, v2beta2 (deprecated), v1 (deprecated)</td><td>v2</td><td><ul><li>v2beta1 is removed, "action required" relnote</li></ul></td></tr><tr><td>X+15</td><td>v2, v1 (deprecated)</td><td>v2</td><td><ul><li>v2beta2 is removed, "action required" relnote</li></ul></td></tr></tbody></table><h3 id=rest-resources-aka-api-objects>REST resources (aka API objects)</h3><p>Consider a hypothetical REST resource named Widget, which was present in API v1
in the above timeline, and which needs to be deprecated. We document and
<a href=https://groups.google.com/forum/#!forum/kubernetes-announce>announce</a> the
deprecation in sync with release X+1. The Widget resource still exists in API
version v1 (deprecated) but not in v2alpha1. The Widget resource continues to
exist and function in releases up to and including X+8. Only in release X+9,
when API v1 has aged out, does the Widget resource cease to exist, and the
behavior get removed.</p><p>Starting in Kubernetes v1.19, making an API request to a deprecated REST API endpoint:</p><ol><li><p>Returns a <code>Warning</code> header (as defined in <a href=https://tools.ietf.org/html/rfc7234#section-5.5>RFC7234, Section 5.5</a>) in the API response.</p></li><li><p>Adds a <code>"k8s.io/deprecated":"true"</code> annotation to the <a href=/docs/tasks/debug/debug-cluster/audit/>audit event</a> recorded for the request.</p></li><li><p>Sets an <code>apiserver_requested_deprecated_apis</code> gauge metric to <code>1</code> in the <code>kube-apiserver</code>
process. The metric has labels for <code>group</code>, <code>version</code>, <code>resource</code>, <code>subresource</code> that can be joined
to the <code>apiserver_request_total</code> metric, and a <code>removed_release</code> label that indicates the
Kubernetes release in which the API will no longer be served. The following Prometheus query
returns information about requests made to deprecated APIs which will be removed in v1.22:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-promql data-lang=promql><span style=display:flex><span><span style=color:#b8860b>apiserver_requested_deprecated_apis</span>{<span style=color:#a0a000>removed_release</span><span style=color:#666>=</span>&#34;<span style=color:#b44>1.22</span>&#34;}<span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>on</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>group</span>,<span style=color:#b8860b>version</span>,<span style=color:#b8860b>resource</span>,<span style=color:#b8860b>subresource</span><span style=color:#666>)</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>group_right</span><span style=color:#666>()</span><span style=color:#bbb> </span><span style=color:#b8860b>apiserver_request_total</span><span style=color:#bbb>
</span></span></span></code></pre></div></li></ol><h3 id=fields-of-rest-resources>Fields of REST resources</h3><p>As with whole REST resources, an individual field which was present in API v1
must exist and function until API v1 is removed. Unlike whole resources, the
v2 APIs may choose a different representation for the field, as long as it can
be round-tripped. For example a v1 field named "magnitude" which was
deprecated might be named "deprecatedMagnitude" in API v2. When v1 is
eventually removed, the deprecated field can be removed from v2.</p><h3 id=enumerated-or-constant-values>Enumerated or constant values</h3><p>As with whole REST resources and fields thereof, a constant value which was
supported in API v1 must exist and function until API v1 is removed.</p><h3 id=component-config-structures>Component config structures</h3><p>Component configs are versioned and managed similar to REST resources.</p><h3 id=future-work>Future work</h3><p>Over time, Kubernetes will introduce more fine-grained API versions, at which
point these rules will be adjusted as needed.</p><h2 id=deprecating-a-flag-or-cli>Deprecating a flag or CLI</h2><p>The Kubernetes system is comprised of several different programs cooperating.
Sometimes, a Kubernetes release might remove flags or CLI commands
(collectively "CLI elements") in these programs. The individual programs
naturally sort into two main groups - user-facing and admin-facing programs,
which vary slightly in their deprecation policies. Unless a flag is explicitly
prefixed or documented as "alpha" or "beta", it is considered GA.</p><p>CLI elements are effectively part of the API to the system, but since they are
not versioned in the same way as the REST API, the rules for deprecation are as
follows:</p><p><strong>Rule #5a: CLI elements of user-facing components (e.g. kubectl) must function
after their announced deprecation for no less than:</strong></p><ul><li><strong>GA: 12 months or 2 releases (whichever is longer)</strong></li><li><strong>Beta: 3 months or 1 release (whichever is longer)</strong></li><li><strong>Alpha: 0 releases</strong></li></ul><p><strong>Rule #5b: CLI elements of admin-facing components (e.g. kubelet) must function
after their announced deprecation for no less than:</strong></p><ul><li><strong>GA: 6 months or 1 release (whichever is longer)</strong></li><li><strong>Beta: 3 months or 1 release (whichever is longer)</strong></li><li><strong>Alpha: 0 releases</strong></li></ul><p><strong>Rule #6: Deprecated CLI elements must emit warnings (optionally disable)
when used.</strong></p><h2 id=deprecating-a-feature-or-behavior>Deprecating a feature or behavior</h2><p>Occasionally a Kubernetes release needs to deprecate some feature or behavior
of the system that is not controlled by the API or CLI. In this case, the
rules for deprecation are as follows:</p><p><strong>Rule #7: Deprecated behaviors must function for no less than 1 year after their
announced deprecation.</strong></p><p>This does not imply that all changes to the system are governed by this policy.
This applies only to significant, user-visible behaviors which impact the
correctness of applications running on Kubernetes or that impact the
administration of Kubernetes clusters, and which are being removed entirely.</p><p>An exception to the above rule is <em>feature gates</em>. Feature gates are key=value
pairs that allow for users to enable/disable experimental features.</p><p>Feature gates are intended to cover the development life cycle of a feature - they
are not intended to be long-term APIs. As such, they are expected to be deprecated
and removed after a feature becomes GA or is dropped.</p><p>As a feature moves through the stages, the associated feature gate evolves.
The feature life cycle matched to its corresponding feature gate is:</p><ul><li>Alpha: the feature gate is disabled by default and can be enabled by the user.</li><li>Beta: the feature gate is enabled by default and can be disabled by the user.</li><li>GA: the feature gate is deprecated (see <a href=#deprecation>"Deprecation"</a>) and becomes
non-operational.</li><li>GA, deprecation window complete: the feature gate is removed and calls to it are
no longer accepted.</li></ul><h3 id=deprecation>Deprecation</h3><p>Features can be removed at any point in the life cycle prior to GA. When features are
removed prior to GA, their associated feature gates are also deprecated.</p><p>When an invocation tries to disable a non-operational feature gate, the call fails in order
to avoid unsupported scenarios that might otherwise run silently.</p><p>In some cases, removing pre-GA features requires considerable time. Feature gates can remain
operational until their associated feature is fully removed, at which point the feature gate
itself can be deprecated.</p><p>When removing a feature gate for a GA feature also requires considerable time, calls to
feature gates may remain operational if the feature gate has no effect on the feature,
and if the feature gate causes no errors.</p><p>Features intended to be disabled by users should include a mechanism for disabling the
feature in the associated feature gate.</p><p>Versioning for feature gates is different from the previously discussed components,
therefore the rules for deprecation are as follows:</p><p><strong>Rule #8: Feature gates must be deprecated when the corresponding feature they control
transitions a lifecycle stage as follows. Feature gates must function for no less than:</strong></p><ul><li><strong>Beta feature to GA: 6 months or 2 releases (whichever is longer)</strong></li><li><strong>Beta feature to EOL: 3 months or 1 release (whichever is longer)</strong></li><li><strong>Alpha feature to EOL: 0 releases</strong></li></ul><p><strong>Rule #9: Deprecated feature gates must respond with a warning when used. When a feature gate
is deprecated it must be documented in both in the release notes and the corresponding CLI help.
Both warnings and documentation must indicate whether a feature gate is non-operational.</strong></p><h2 id=deprecating-a-metric>Deprecating a metric</h2><p>Each component of the Kubernetes control-plane exposes metrics (usually the
<code>/metrics</code> endpoint), which are typically ingested by cluster administrators.
Not all metrics are the same: some metrics are commonly used as SLIs or used
to determine SLOs, these tend to have greater import. Other metrics are more
experimental in nature or are used primarily in the Kubernetes development
process.</p><p>Accordingly, metrics fall under two stability classes (<code>ALPHA</code> and <code>STABLE</code>);
this impacts removal of a metric during a Kubernetes release. These classes
are determined by the perceived importance of the metric. The rules for
deprecating and removing a metric are as follows:</p><p><strong>Rule #9a: Metrics, for the corresponding stability class, must function for no less than:</strong></p><ul><li><strong>STABLE: 4 releases or 12 months (whichever is longer)</strong></li><li><strong>ALPHA: 0 releases</strong></li></ul><p><strong>Rule #9b: Metrics, after their <em>announced deprecation</em>, must function for no less than:</strong></p><ul><li><strong>STABLE: 3 releases or 9 months (whichever is longer)</strong></li><li><strong>ALPHA: 0 releases</strong></li></ul><p>Deprecated metrics will have their description text prefixed with a deprecation notice
string '(Deprecated from x.y)' and a warning log will be emitted during metric
registration. Like their stable undeprecated counterparts, deprecated metrics will
be automatically registered to the metrics endpoint and therefore visible.</p><p>On a subsequent release (when the metric's <code>deprecatedVersion</code> is equal to
<em>current_kubernetes_version - 3</em>)), a deprecated metric will become a <em>hidden</em> metric.
<strong><em>Unlike</em></strong> their deprecated counterparts, hidden metrics will <em>no longer</em> be
automatically registered to the metrics endpoint (hence hidden). However, they
can be explicitly enabled through a command line flag on the binary
(<code>--show-hidden-metrics-for-version=</code>). This provides cluster admins an
escape hatch to properly migrate off of a deprecated metric, if they were not
able to react to the earlier deprecation warnings. Hidden metrics should be
deleted after one release.</p><h2 id=exceptions>Exceptions</h2><p>No policy can cover every possible situation. This policy is a living
document, and will evolve over time. In practice, there will be situations
that do not fit neatly into this policy, or for which this policy becomes a
serious impediment. Such situations should be discussed with SIGs and project
leaders to find the best solutions for those specific cases, always bearing in
mind that Kubernetes is committed to being a stable system that, as much as
possible, never breaks users. Exceptions will always be announced in all
relevant release notes.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2479c39af50fd55b898a3bcfb5988077>5 - Deprecated API Migration Guide</h1><p>As the Kubernetes API evolves, APIs are periodically reorganized or upgraded.
When APIs evolve, the old API is deprecated and eventually removed.
This page contains information you need to know when migrating from
deprecated API versions to newer and more stable API versions.</p><h2 id=removed-apis-by-release>Removed APIs by release</h2><h3 id=v1-27>v1.27</h3><p>The <strong>v1.27</strong> release will stop serving the following deprecated API versions:</p><h4 id=csistoragecapacity-v127>CSIStorageCapacity</h4><p>The <strong>storage.k8s.io/v1beta1</strong> API version of CSIStorageCapacity will no longer be served in v1.27.</p><ul><li>Migrate manifests and API clients to use the <strong>storage.k8s.io/v1</strong> API version, available since v1.24.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h3 id=v1-26>v1.26</h3><p>The <strong>v1.26</strong> release will stop serving the following deprecated API versions:</p><h4 id=flowcontrol-resources-v126>Flow control resources</h4><p>The <strong>flowcontrol.apiserver.k8s.io/v1beta1</strong> API version of FlowSchema and PriorityLevelConfiguration will no longer be served in v1.26.</p><ul><li>Migrate manifests and API clients to use the <strong>flowcontrol.apiserver.k8s.io/v1beta2</strong> API version, available since v1.23.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id=horizontalpodautoscaler-v126>HorizontalPodAutoscaler</h4><p>The <strong>autoscaling/v2beta2</strong> API version of HorizontalPodAutoscaler will no longer be served in v1.26.</p><ul><li>Migrate manifests and API clients to use the <strong>autoscaling/v2</strong> API version, available since v1.23.</li><li>All existing persisted objects are accessible via the new API</li></ul><h3 id=v1-25>v1.25</h3><p>The <strong>v1.25</strong> release will stop serving the following deprecated API versions:</p><h4 id=cronjob-v125>CronJob</h4><p>The <strong>batch/v1beta1</strong> API version of CronJob will no longer be served in v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>batch/v1</strong> API version, available since v1.21.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id=endpointslice-v125>EndpointSlice</h4><p>The <strong>discovery.k8s.io/v1beta1</strong> API version of EndpointSlice will no longer be served in v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>discovery.k8s.io/v1</strong> API version, available since v1.21.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes in <strong>discovery.k8s.io/v1</strong>:<ul><li>use per Endpoint <code>nodeName</code> field instead of deprecated <code>topology["kubernetes.io/hostname"]</code> field</li><li>use per Endpoint <code>zone</code> field instead of deprecated <code>topology["topology.kubernetes.io/zone"]</code> field</li><li><code>topology</code> is replaced with the <code>deprecatedTopology</code> field which is not writable in v1</li></ul></li></ul><h4 id=event-v125>Event</h4><p>The <strong>events.k8s.io/v1beta1</strong> API version of Event will no longer be served in v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>events.k8s.io/v1</strong> API version, available since v1.19.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes in <strong>events.k8s.io/v1</strong>:<ul><li><code>type</code> is limited to <code>Normal</code> and <code>Warning</code></li><li><code>involvedObject</code> is renamed to <code>regarding</code></li><li><code>action</code>, <code>reason</code>, <code>reportingController</code>, and <code>reportingInstance</code> are required when creating new <strong>events.k8s.io/v1</strong> Events</li><li>use <code>eventTime</code> instead of the deprecated <code>firstTimestamp</code> field (which is renamed to <code>deprecatedFirstTimestamp</code> and not permitted in new <strong>events.k8s.io/v1</strong> Events)</li><li>use <code>series.lastObservedTime</code> instead of the deprecated <code>lastTimestamp</code> field (which is renamed to <code>deprecatedLastTimestamp</code> and not permitted in new <strong>events.k8s.io/v1</strong> Events)</li><li>use <code>series.count</code> instead of the deprecated <code>count</code> field (which is renamed to <code>deprecatedCount</code> and not permitted in new <strong>events.k8s.io/v1</strong> Events)</li><li>use <code>reportingController</code> instead of the deprecated <code>source.component</code> field (which is renamed to <code>deprecatedSource.component</code> and not permitted in new <strong>events.k8s.io/v1</strong> Events)</li><li>use <code>reportingInstance</code> instead of the deprecated <code>source.host</code> field (which is renamed to <code>deprecatedSource.host</code> and not permitted in new <strong>events.k8s.io/v1</strong> Events)</li></ul></li></ul><h4 id=horizontalpodautoscaler-v125>HorizontalPodAutoscaler</h4><p>The <strong>autoscaling/v2beta1</strong> API version of HorizontalPodAutoscaler will no longer be served in v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>autoscaling/v2</strong> API version, available since v1.23.</li><li>All existing persisted objects are accessible via the new API</li></ul><h4 id=poddisruptionbudget-v125>PodDisruptionBudget</h4><p>The <strong>policy/v1beta1</strong> API version of PodDisruptionBudget will no longer be served in v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>policy/v1</strong> API version, available since v1.21.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes in <strong>policy/v1</strong>:<ul><li>an empty <code>spec.selector</code> (<code>{}</code>) written to a <code>policy/v1</code> PodDisruptionBudget selects all pods in the namespace (in <code>policy/v1beta1</code> an empty <code>spec.selector</code> selected no pods). An unset <code>spec.selector</code> selects no pods in either API version.</li></ul></li></ul><h4 id=psp-v125>PodSecurityPolicy</h4><p>PodSecurityPolicy in the <strong>policy/v1beta1</strong> API version will no longer be served in v1.25, and the PodSecurityPolicy admission controller will be removed.</p><p>Migrate to <a href=/docs/concepts/security/pod-security-admission/>Pod Security Admission</a>
or a <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>3rd party admission webhook</a>.
For a migration guide, see <a href=/docs/tasks/configure-pod-container/migrate-from-psp/>Migrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller</a>.
For more information on the deprecation, see <a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>PodSecurityPolicy Deprecation: Past, Present, and Future</a>.</p><h4 id=runtimeclass-v125>RuntimeClass</h4><p>RuntimeClass in the <strong>node.k8s.io/v1beta1</strong> API version will no longer be served in v1.25.</p><ul><li>Migrate manifests and API clients to use the <strong>node.k8s.io/v1</strong> API version, available since v1.20.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h3 id=v1-22>v1.22</h3><p>The <strong>v1.22</strong> release stopped serving the following deprecated API versions:</p><h4 id=webhook-resources-v122>Webhook resources</h4><p>The <strong>admissionregistration.k8s.io/v1beta1</strong> API version of MutatingWebhookConfiguration and ValidatingWebhookConfiguration is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>admissionregistration.k8s.io/v1</strong> API version, available since v1.16.</li><li>All existing persisted objects are accessible via the new APIs</li><li>Notable changes:<ul><li><code>webhooks[*].failurePolicy</code> default changed from <code>Ignore</code> to <code>Fail</code> for v1</li><li><code>webhooks[*].matchPolicy</code> default changed from <code>Exact</code> to <code>Equivalent</code> for v1</li><li><code>webhooks[*].timeoutSeconds</code> default changed from <code>30s</code> to <code>10s</code> for v1</li><li><code>webhooks[*].sideEffects</code> default value is removed, and the field made required, and only <code>None</code> and <code>NoneOnDryRun</code> are permitted for v1</li><li><code>webhooks[*].admissionReviewVersions</code> default value is removed and the field made required for v1 (supported versions for AdmissionReview are <code>v1</code> and <code>v1beta1</code>)</li><li><code>webhooks[*].name</code> must be unique in the list for objects created via <code>admissionregistration.k8s.io/v1</code></li></ul></li></ul><h4 id=customresourcedefinition-v122>CustomResourceDefinition</h4><p>The <strong>apiextensions.k8s.io/v1beta1</strong> API version of CustomResourceDefinition is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>apiextensions.k8s.io/v1</strong> API version, available since v1.16.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.scope</code> is no longer defaulted to <code>Namespaced</code> and must be explicitly specified</li><li><code>spec.version</code> is removed in v1; use <code>spec.versions</code> instead</li><li><code>spec.validation</code> is removed in v1; use <code>spec.versions[*].schema</code> instead</li><li><code>spec.subresources</code> is removed in v1; use <code>spec.versions[*].subresources</code> instead</li><li><code>spec.additionalPrinterColumns</code> is removed in v1; use <code>spec.versions[*].additionalPrinterColumns</code> instead</li><li><code>spec.conversion.webhookClientConfig</code> is moved to <code>spec.conversion.webhook.clientConfig</code> in v1</li><li><code>spec.conversion.conversionReviewVersions</code> is moved to <code>spec.conversion.webhook.conversionReviewVersions</code> in v1</li><li><code>spec.versions[*].schema.openAPIV3Schema</code> is now required when creating v1 CustomResourceDefinition objects, and must be a <a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#specifying-a-structural-schema>structural schema</a></li><li><code>spec.preserveUnknownFields: true</code> is disallowed when creating v1 CustomResourceDefinition objects; it must be specified within schema definitions as <code>x-kubernetes-preserve-unknown-fields: true</code></li><li>In <code>additionalPrinterColumns</code> items, the <code>JSONPath</code> field was renamed to <code>jsonPath</code> in v1 (fixes <a href=https://github.com/kubernetes/kubernetes/issues/66531>#66531</a>)</li></ul></li></ul><h4 id=apiservice-v122>APIService</h4><p>The <strong>apiregistration.k8s.io/v1beta1</strong> API version of APIService is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>apiregistration.k8s.io/v1</strong> API version, available since v1.10.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id=tokenreview-v122>TokenReview</h4><p>The <strong>authentication.k8s.io/v1beta1</strong> API version of TokenReview is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>authentication.k8s.io/v1</strong> API version, available since v1.6.</li><li>No notable changes</li></ul><h4 id=subjectaccessreview-resources-v122>SubjectAccessReview resources</h4><p>The <strong>authorization.k8s.io/v1beta1</strong> API version of LocalSubjectAccessReview, SelfSubjectAccessReview, SubjectAccessReview, and SelfSubjectRulesReview is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>authorization.k8s.io/v1</strong> API version, available since v1.6.</li><li>Notable changes:<ul><li><code>spec.group</code> was renamed to <code>spec.groups</code> in v1 (fixes <a href=https://github.com/kubernetes/kubernetes/issues/32709>#32709</a>)</li></ul></li></ul><h4 id=certificatesigningrequest-v122>CertificateSigningRequest</h4><p>The <strong>certificates.k8s.io/v1beta1</strong> API version of CertificateSigningRequest is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>certificates.k8s.io/v1</strong> API version, available since v1.19.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes in <code>certificates.k8s.io/v1</code>:<ul><li>For API clients requesting certificates:<ul><li><code>spec.signerName</code> is now required (see <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers>known Kubernetes signers</a>), and requests for <code>kubernetes.io/legacy-unknown</code> are not allowed to be created via the <code>certificates.k8s.io/v1</code> API</li><li><code>spec.usages</code> is now required, may not contain duplicate values, and must only contain known usages</li></ul></li><li>For API clients approving or signing certificates:<ul><li><code>status.conditions</code> may not contain duplicate types</li><li><code>status.conditions[*].status</code> is now required</li><li><code>status.certificate</code> must be PEM-encoded, and contain only <code>CERTIFICATE</code> blocks</li></ul></li></ul></li></ul><h4 id=lease-v122>Lease</h4><p>The <strong>coordination.k8s.io/v1beta1</strong> API version of Lease is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>coordination.k8s.io/v1</strong> API version, available since v1.14.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id=ingress-v122>Ingress</h4><p>The <strong>extensions/v1beta1</strong> and <strong>networking.k8s.io/v1beta1</strong> API versions of Ingress is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>networking.k8s.io/v1</strong> API version, available since v1.19.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.backend</code> is renamed to <code>spec.defaultBackend</code></li><li>The backend <code>serviceName</code> field is renamed to <code>service.name</code></li><li>Numeric backend <code>servicePort</code> fields are renamed to <code>service.port.number</code></li><li>String backend <code>servicePort</code> fields are renamed to <code>service.port.name</code></li><li><code>pathType</code> is now required for each specified path. Options are <code>Prefix</code>, <code>Exact</code>, and <code>ImplementationSpecific</code>. To match the undefined <code>v1beta1</code> behavior, use <code>ImplementationSpecific</code>.</li></ul></li></ul><h4 id=ingressclass-v122>IngressClass</h4><p>The <strong>networking.k8s.io/v1beta1</strong> API version of IngressClass is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>networking.k8s.io/v1</strong> API version, available since v1.19.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id=rbac-resources-v122>RBAC resources</h4><p>The <strong>rbac.authorization.k8s.io/v1beta1</strong> API version of ClusterRole, ClusterRoleBinding, Role, and RoleBinding is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>rbac.authorization.k8s.io/v1</strong> API version, available since v1.8.</li><li>All existing persisted objects are accessible via the new APIs</li><li>No notable changes</li></ul><h4 id=priorityclass-v122>PriorityClass</h4><p>The <strong>scheduling.k8s.io/v1beta1</strong> API version of PriorityClass is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>scheduling.k8s.io/v1</strong> API version, available since v1.14.</li><li>All existing persisted objects are accessible via the new API</li><li>No notable changes</li></ul><h4 id=storage-resources-v122>Storage resources</h4><p>The <strong>storage.k8s.io/v1beta1</strong> API version of CSIDriver, CSINode, StorageClass, and VolumeAttachment is no longer served as of v1.22.</p><ul><li>Migrate manifests and API clients to use the <strong>storage.k8s.io/v1</strong> API version<ul><li>CSIDriver is available in <strong>storage.k8s.io/v1</strong> since v1.19.</li><li>CSINode is available in <strong>storage.k8s.io/v1</strong> since v1.17</li><li>StorageClass is available in <strong>storage.k8s.io/v1</strong> since v1.6</li><li>VolumeAttachment is available in <strong>storage.k8s.io/v1</strong> v1.13</li></ul></li><li>All existing persisted objects are accessible via the new APIs</li><li>No notable changes</li></ul><h3 id=v1-16>v1.16</h3><p>The <strong>v1.16</strong> release stopped serving the following deprecated API versions:</p><h4 id=networkpolicy-v116>NetworkPolicy</h4><p>The <strong>extensions/v1beta1</strong> API version of NetworkPolicy is no longer served as of v1.16.</p><ul><li>Migrate manifests and API clients to use the <strong>networking.k8s.io/v1</strong> API version, available since v1.8.</li><li>All existing persisted objects are accessible via the new API</li></ul><h4 id=daemonset-v116>DaemonSet</h4><p>The <strong>extensions/v1beta1</strong> and <strong>apps/v1beta2</strong> API versions of DaemonSet are no longer served as of v1.16.</p><ul><li>Migrate manifests and API clients to use the <strong>apps/v1</strong> API version, available since v1.9.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.templateGeneration</code> is removed</li><li><code>spec.selector</code> is now required and immutable after creation; use the existing template labels as the selector for seamless upgrades</li><li><code>spec.updateStrategy.type</code> now defaults to <code>RollingUpdate</code> (the default in <code>extensions/v1beta1</code> was <code>OnDelete</code>)</li></ul></li></ul><h4 id=deployment-v116>Deployment</h4><p>The <strong>extensions/v1beta1</strong>, <strong>apps/v1beta1</strong>, and <strong>apps/v1beta2</strong> API versions of Deployment are no longer served as of v1.16.</p><ul><li>Migrate manifests and API clients to use the <strong>apps/v1</strong> API version, available since v1.9.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.rollbackTo</code> is removed</li><li><code>spec.selector</code> is now required and immutable after creation; use the existing template labels as the selector for seamless upgrades</li><li><code>spec.progressDeadlineSeconds</code> now defaults to <code>600</code> seconds (the default in <code>extensions/v1beta1</code> was no deadline)</li><li><code>spec.revisionHistoryLimit</code> now defaults to <code>10</code> (the default in <code>apps/v1beta1</code> was <code>2</code>, the default in <code>extensions/v1beta1</code> was to retain all)</li><li><code>maxSurge</code> and <code>maxUnavailable</code> now default to <code>25%</code> (the default in <code>extensions/v1beta1</code> was <code>1</code>)</li></ul></li></ul><h4 id=statefulset-v116>StatefulSet</h4><p>The <strong>apps/v1beta1</strong> and <strong>apps/v1beta2</strong> API versions of StatefulSet are no longer served as of v1.16.</p><ul><li>Migrate manifests and API clients to use the <strong>apps/v1</strong> API version, available since v1.9.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.selector</code> is now required and immutable after creation; use the existing template labels as the selector for seamless upgrades</li><li><code>spec.updateStrategy.type</code> now defaults to <code>RollingUpdate</code> (the default in <code>apps/v1beta1</code> was <code>OnDelete</code>)</li></ul></li></ul><h4 id=replicaset-v116>ReplicaSet</h4><p>The <strong>extensions/v1beta1</strong>, <strong>apps/v1beta1</strong>, and <strong>apps/v1beta2</strong> API versions of ReplicaSet are no longer served as of v1.16.</p><ul><li>Migrate manifests and API clients to use the <strong>apps/v1</strong> API version, available since v1.9.</li><li>All existing persisted objects are accessible via the new API</li><li>Notable changes:<ul><li><code>spec.selector</code> is now required and immutable after creation; use the existing template labels as the selector for seamless upgrades</li></ul></li></ul><h4 id=psp-v116>PodSecurityPolicy</h4><p>The <strong>extensions/v1beta1</strong> API version of PodSecurityPolicy is no longer served as of v1.16.</p><ul><li>Migrate manifests and API client to use the <strong>policy/v1beta1</strong> API version, available since v1.10.</li><li>Note that the <strong>policy/v1beta1</strong> API version of PodSecurityPolicy will be removed in v1.25.</li></ul><h2 id=what-to-do>What to do</h2><h3 id=test-with-deprecated-apis-disabled>Test with deprecated APIs disabled</h3><p>You can test your clusters by starting an API server with specific API versions disabled
to simulate upcoming removals. Add the following flag to the API server startup arguments:</p><p><code>--runtime-config=&lt;group>/&lt;version>=false</code></p><p>For example:</p><p><code>--runtime-config=admissionregistration.k8s.io/v1beta1=false,apiextensions.k8s.io/v1beta1,...</code></p><h3 id=locate-use-of-deprecated-apis>Locate use of deprecated APIs</h3><p>Use <a href=/blog/2020/09/03/warnings/#deprecation-warnings>client warnings, metrics, and audit information available in 1.19+</a>
to locate use of deprecated APIs.</p><h3 id=migrate-to-non-deprecated-apis>Migrate to non-deprecated APIs</h3><ul><li><p>Update custom integrations and controllers to call the non-deprecated APIs</p></li><li><p>Change YAML files to reference the non-deprecated APIs</p><p>You can use the <code>kubectl-convert</code> command (<code>kubectl convert</code> prior to v1.20)
to automatically convert an existing object:</p><p><code>kubectl-convert -f &lt;file> --output-version &lt;group>/&lt;version></code>.</p><p>For example, to convert an older Deployment to <code>apps/v1</code>, you can run:</p><p><code>kubectl-convert -f ./my-deployment.yaml --output-version apps/v1</code></p><p>Note that this may use non-ideal default values. To learn more about a specific
resource, check the Kubernetes <a href=/docs/reference/kubernetes-api/>API reference</a>.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e4dbb59f8f23854d7b7d574e169923c4>6 - Kubernetes API health endpoints</h1><p>The Kubernetes <a class=glossary-tooltip title='Control plane component that serves the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a> provides API endpoints to indicate the current status of the API server.
This page describes these API endpoints and explains how you can use them.</p><h2 id=api-endpoints-for-health>API endpoints for health</h2><p>The Kubernetes API server provides 3 API endpoints (<code>healthz</code>, <code>livez</code> and <code>readyz</code>) to indicate the current status of the API server.
The <code>healthz</code> endpoint is deprecated (since Kubernetes v1.16), and you should use the more specific <code>livez</code> and <code>readyz</code> endpoints instead.
The <code>livez</code> endpoint can be used with the <code>--livez-grace-period</code> <a href=/docs/reference/command-line-tools-reference/kube-apiserver>flag</a> to specify the startup duration.
For a graceful shutdown you can specify the <code>--shutdown-delay-duration</code> <a href=/docs/reference/command-line-tools-reference/kube-apiserver>flag</a> with the <code>/readyz</code> endpoint.
Machines that check the <code>healthz</code>/<code>livez</code>/<code>readyz</code> of the API server should rely on the HTTP status code.
A status code <code>200</code> indicates the API server is <code>healthy</code>/<code>live</code>/<code>ready</code>, depending on the called endpoint.
The more verbose options shown below are intended to be used by human operators to debug their cluster or understand the state of the API server.</p><p>The following examples will show how you can interact with the health API endpoints.</p><p>For all endpoints, you can use the <code>verbose</code> parameter to print out the checks and their status.
This can be useful for a human operator to debug the current status of the API server, it is not intended to be consumed by a machine:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -k https://localhost:6443/livez?verbose
</span></span></code></pre></div><p>or from a remote host with authentication:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --raw<span style=color:#666>=</span><span style=color:#b44>&#39;/readyz?verbose&#39;</span>
</span></span></code></pre></div><p>The output will look like this:</p><pre><code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
</code></pre><p>The Kubernetes API server also supports to exclude specific checks.
The query parameters can also be combined like in this example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -k <span style=color:#b44>&#39;https://localhost:6443/readyz?verbose&amp;exclude=etcd&#39;</span>
</span></span></code></pre></div><p>The output show that the <code>etcd</code> check is excluded:</p><pre><code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
</code></pre><h2 id=individual-health-checks>Individual health checks</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [alpha]</code></div><p>Each individual health check exposes an HTTP endpoint and can be checked individually.
The schema for the individual health checks is <code>/livez/&lt;healthcheck-name></code> where <code>livez</code> and <code>readyz</code> and be used to indicate if you want to check the liveness or the readiness of the API server.
The <code>&lt;healthcheck-name></code> path can be discovered using the <code>verbose</code> flag from above and take the path between <code>[+]</code> and <code>ok</code>.
These individual health checks should not be consumed by machines but can be helpful for a human operator to debug a system:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -k https://localhost:6443/livez/etcd
</span></span></code></pre></div></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/docs/home/>Home</a>
<a class=text-white href=/blog/>Blog</a>
<a class=text-white href=/training/>Training</a>
<a class=text-white href=/partners/>Partners</a>
<a class=text-white href=/community/>Community</a>
<a class=text-white href=/case-studies/>Case Studies</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>