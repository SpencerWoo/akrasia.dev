<!doctype html><html lang=en class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/reference/setup-tools/kubeadm/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/reference/setup-tools/kubeadm/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/setup-tools/kubeadm/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/setup-tools/kubeadm/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/reference/setup-tools/kubeadm/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/docs/reference/setup-tools/kubeadm/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Kubeadm | Kubernetes</title><meta property="og:title" content="Kubeadm"><meta property="og:description" content="Production-Grade Container Orchestration"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/docs/reference/setup-tools/kubeadm/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Kubeadm"><meta itemprop=description content="Production-Grade Container Orchestration"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubeadm"><meta name=twitter:description content="Production-Grade Container Orchestration"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Kubeadm is a tool built to provide kubeadm init and kubeadm join as best-practice &#34;fast paths&#34; for creating Kubernetes clusters.
kubeadm performs the actions necessary to get a minimum viable cluster up and running. By design, it cares only about bootstrapping, not about provisioning machines. Likewise, installing various nice-to-have addons, like the Kubernetes Dashboard, monitoring solutions, and cloud-specific addons, is not in scope.
Instead, we expect higher-level and more tailored tooling to be built on top of kubeadm, and ideally, using kubeadm as the basis of all deployments will make it easier to create conformant clusters."><meta property="og:description" content="Kubeadm is a tool built to provide kubeadm init and kubeadm join as best-practice &#34;fast paths&#34; for creating Kubernetes clusters.
kubeadm performs the actions necessary to get a minimum viable cluster up and running. By design, it cares only about bootstrapping, not about provisioning machines. Likewise, installing various nice-to-have addons, like the Kubernetes Dashboard, monitoring solutions, and cloud-specific addons, is not in scope.
Instead, we expect higher-level and more tailored tooling to be built on top of kubeadm, and ideally, using kubeadm as the basis of all deployments will make it easier to create conformant clusters."><meta name=twitter:description content="Kubeadm is a tool built to provide kubeadm init and kubeadm join as best-practice &#34;fast paths&#34; for creating Kubernetes clusters.
kubeadm performs the actions necessary to get a minimum viable cluster up and running. By design, it cares only about bootstrapping, not about provisioning machines. Likewise, installing various nice-to-have addons, like the Kubernetes Dashboard, monitoring solutions, and cloud-specific addons, is not in scope.
Instead, we expect higher-level and more tailored tooling to be built on top of kubeadm, and ideally, using kubeadm as the basis of all deployments will make it easier to create conformant clusters."><meta property="og:url" content="https://kubernetes.io/docs/reference/setup-tools/kubeadm/"><meta property="og:title" content="Kubeadm"><meta name=twitter:title content="Kubeadm"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/docs/>Documentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/training/>Training</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/partners/>Partners</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/case-studies/>Case Studies</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/docs/reference/setup-tools/kubeadm/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/docs/reference/setup-tools/kubeadm/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/docs/reference/setup-tools/kubeadm/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/docs/reference/setup-tools/kubeadm/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/docs/reference/setup-tools/kubeadm/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>English</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/docs/reference/setup-tools/kubeadm/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/reference/setup-tools/kubeadm/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/reference/setup-tools/kubeadm/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/reference/setup-tools/kubeadm/>Français (French)</a>
<a class=dropdown-item href=/es/docs/reference/setup-tools/kubeadm/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/reference/setup-tools/kubeadm/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/reference/setup-tools/kubeadm/>Return to the regular view of this page</a>.</p></div><h1 class=title>Kubeadm</h1><ul><li>1: <a href=#pg-36c22b52e8447eb3d2452d4f56fbea9b>Kubeadm Generated</a></li><ul><li>1.1: <a href=#pg-fd3ad295c1f10bfa333f841bbdffba81></a></li><li>1.2: <a href=#pg-8df9aba508b2736a6712ef46227eea7d></a></li><li>1.3: <a href=#pg-018648dfc6f28bc9b969f45af0563cae></a></li><li>1.4: <a href=#pg-4a1ff27cdf01c1c47d034278048e776b></a></li><li>1.5: <a href=#pg-5d6b2999153cd86f56329534249fc4ec></a></li><li>1.6: <a href=#pg-adb5eecdc351074cc2e0cc2b1b4f04a8></a></li><li>1.7: <a href=#pg-df4c2dc6cba0be90d8d7de2fca9b87f7></a></li><li>1.8: <a href=#pg-6d6746e8ac1f1602f7dab1056b27e5c2></a></li><li>1.9: <a href=#pg-7449c7fa06f25b967cf531e937b0f4b2></a></li><li>1.10: <a href=#pg-b5c6ae77d3be9bd358c68667006cfc18></a></li><li>1.11: <a href=#pg-4f804e59ec1739e733807d2b591d771f></a></li><li>1.12: <a href=#pg-f5cf8caa95834803b133d53c321ab4a9></a></li><li>1.13: <a href=#pg-ee770858e2bb767b79d572b4882af656></a></li><li>1.14: <a href=#pg-7484bf11b6183f4c329b1f66734cc886></a></li><li>1.15: <a href=#pg-bf444d915ab856dba693c36294c5427b></a></li><li>1.16: <a href=#pg-f5c087e087714c5290b4967dd7924b3b></a></li><li>1.17: <a href=#pg-20703ce1c236264ad78cb1ad7244723e></a></li><li>1.18: <a href=#pg-49aaa494ef75de67609987a43e5ee520></a></li><li>1.19: <a href=#pg-d63311c16e6468f5a5940aadd902faa7></a></li><li>1.20: <a href=#pg-6678a79b85306310066616185153377d></a></li><li>1.21: <a href=#pg-8f73e208cc67d221165f6294393881a7></a></li><li>1.22: <a href=#pg-9aec3477159c105a46f4479de1c21418></a></li><li>1.23: <a href=#pg-045e41c28798930e21f77a90c3a90263></a></li><li>1.24: <a href=#pg-e7d83478123771ad14f475ee44440303></a></li><li>1.25: <a href=#pg-57a6b20d9571220989a7a445d4459468></a></li><li>1.26: <a href=#pg-92a2c11eef37937af846b55d9b87a544></a></li><li>1.27: <a href=#pg-dcfffcaafb438cd650475945ddc129ee></a></li><li>1.28: <a href=#pg-6eaa2624c512051ff2a9cdbc6ee54949></a></li><li>1.29: <a href=#pg-4b7ada30e3923594b2907dcb8b431080></a></li><li>1.30: <a href=#pg-6d1154da2e554de858cf4e7b37c054fa></a></li><li>1.31: <a href=#pg-d3a16914ddc849435ed864163978ddbf></a></li><li>1.32: <a href=#pg-8a257337ea78e5d9a0c54aa971eaf991></a></li><li>1.33: <a href=#pg-77759011117e7974cbfee9694b6f8801></a></li><li>1.34: <a href=#pg-8e1920b2caaa8de839cd3997edca80e9></a></li><li>1.35: <a href=#pg-00aa8c2e4b3b2fd3a4b7986976b7bfda></a></li><li>1.36: <a href=#pg-316aa97ee5719be5a723ac1b77c44f5a></a></li><li>1.37: <a href=#pg-759e85e62b32c0697ab37c214e99a864></a></li><li>1.38: <a href=#pg-2e7091074560abc2a8e7b897cdd8a7b6></a></li><li>1.39: <a href=#pg-eedb8f5a6ed4cff1dfb1a5d14176b5b3></a></li><li>1.40: <a href=#pg-c55f2fa6bdaa124b37da090a3ef90902></a></li><li>1.41: <a href=#pg-10f416336efdcee22d691869e7585b9f></a></li><li>1.42: <a href=#pg-c4b6d149cda7cac896f4374c821b7fc6></a></li><li>1.43: <a href=#pg-1db087626f4f368e932df6f12993a5ab></a></li><li>1.44: <a href=#pg-e85da83e18a50e472eb56320af55768a></a></li><li>1.45: <a href=#pg-eb911bdcb8bb53ceb8b253089ab0d814></a></li><li>1.46: <a href=#pg-62c5dc89c39f3ecd6aee57545d12891a></a></li><li>1.47: <a href=#pg-2a79e12b9455f0ca1a6d5b00a9841249></a></li><li>1.48: <a href=#pg-a2c8efac328fcf416e558bf167ef417d></a></li><li>1.49: <a href=#pg-d93bd37094201bdefdb3908c9a6c86b3></a></li><li>1.50: <a href=#pg-efa9ae4c92ed1c26dc04bb049db38cec></a></li><li>1.51: <a href=#pg-576c00359074987304b3b418cec9a5b1></a></li><li>1.52: <a href=#pg-e6097fe5dd013abd9f356c2566ef7b63></a></li><li>1.53: <a href=#pg-5ab65eab2498cc1893af5b3bf8fe08fc></a></li><li>1.54: <a href=#pg-fcb78718510a9d3027d1bb9d379c0c17></a></li><li>1.55: <a href=#pg-a0e1457f667eb757f82f8c42901aa6c5></a></li><li>1.56: <a href=#pg-59e362bf565041872395d165e99eafc1></a></li><li>1.57: <a href=#pg-2a5040747a02ae2b2326c9901f1725d3></a></li><li>1.58: <a href=#pg-043bd19497eefb77a6ed30a4d704fe7c></a></li><li>1.59: <a href=#pg-bffb0d67824e75ade7232d09754b9718></a></li><li>1.60: <a href=#pg-a37b5872c572c71775e389df50fca215></a></li><li>1.61: <a href=#pg-3f49598c499c3356d89d98fdc8c8ad79></a></li><li>1.62: <a href=#pg-7d68ac74e5301f789ddd2e25dd36218e></a></li><li>1.63: <a href=#pg-e7c1ae3d905d9b6854216e26651955cd></a></li><li>1.64: <a href=#pg-967a98823c19c8338bfc0e1338a20fb1></a></li><li>1.65: <a href=#pg-b5838cc93a3fdb37b61afd201a71edd9></a></li><li>1.66: <a href=#pg-f54c84a0fdada369a87b2ced6ccfc38f></a></li><li>1.67: <a href=#pg-0d96e214c09a8f014e984a6b980522b3></a></li><li>1.68: <a href=#pg-48afa88840a20edf1ad613c18480d4fc></a></li><li>1.69: <a href=#pg-14da359f76a0f36af507d289dd4a5050></a></li><li>1.70: <a href=#pg-3fda282409b804a14879b9c65c035797></a></li><li>1.71: <a href=#pg-e044e6c69c2b1512c8d89430e0400771></a></li><li>1.72: <a href=#pg-9f968809f867b76728697577492429e8></a></li><li>1.73: <a href=#pg-c3c506c1683aed34398a34ab66d609da></a></li><li>1.74: <a href=#pg-2c1a5a4405dca745ef50b4e86f5977c7></a></li><li>1.75: <a href=#pg-003aaef561d065ecdaeb2c325b6b9253></a></li><li>1.76: <a href=#pg-535f050663a6d8db3a61df2b19a0714b></a></li><li>1.77: <a href=#pg-2f0a684baffe3cdf830c16693412f8e0></a></li><li>1.78: <a href=#pg-aba528e06c437710b269f4e41f854fdd></a></li><li>1.79: <a href=#pg-1d7987a759cd1519def4d433710cdff1></a></li><li>1.80: <a href=#pg-33216a69b333c330cb8b305a119abc7c></a></li><li>1.81: <a href=#pg-53abd743076fc859067264f3e8e676e0></a></li><li>1.82: <a href=#pg-3a08eb202d572e417768a942ad24c59f></a></li><li>1.83: <a href=#pg-11ed4820a6c3b411d9c4b87163cf0ae7></a></li><li>1.84: <a href=#pg-e81c9d9320242b5ed4b063beea6696f8></a></li><li>1.85: <a href=#pg-47f2d404188d6eb1fbf6fffd7fba4e48></a></li><li>1.86: <a href=#pg-257824537b4c6c6b33249aa786461156></a></li><li>1.87: <a href=#pg-e10faf6f940de61052258af59e036518></a></li><li>1.88: <a href=#pg-a46a193f2322aa88cb3b2de2447b0461></a></li><li>1.89: <a href=#pg-f5b27d7bd0eeed918f8635c68d220dc5></a></li><li>1.90: <a href=#pg-370e9ffda66b4c48dfa54ea37c3aad21></a></li><li>1.91: <a href=#pg-6bd27042c883aa5c498647d37762392c></a></li><li>1.92: <a href=#pg-3a000435e1cca0be398b44b487f530c8></a></li><li>1.93: <a href=#pg-bee6749065a369c2ab5b311eb43c40ba></a></li><li>1.94: <a href=#pg-bdd9680ec894593d17f782d5e5665fd4></a></li><li>1.95: <a href=#pg-1d005baad1a1e217d7ae0210fec96c3f></a></li><li>1.96: <a href=#pg-c79d11d27bed54caac743c93e0b2fb24></a></li><li>1.97: <a href=#pg-ba78e64c325e4131dd741235e2a1b2c0></a></li><li>1.98: <a href=#pg-872d33f1fbc83cb2f0bf89b4bd545174></a></li><li>1.99: <a href=#pg-7d8c1710684742ca940f580674225d9d></a></li><li>1.100: <a href=#pg-28dcf20d89c7bb1c8e7a3873d7703d5d></a></li><li>1.101: <a href=#pg-f869b6331e40c6f9eb01314f96d3113e></a></li><li>1.102: <a href=#pg-19a94d2f7649959b218952cef00729f4></a></li><li>1.103: <a href=#pg-b22d3ed181fb7f926ae2081f8fc8c14d></a></li><li>1.104: <a href=#pg-ae1ea74c2c21b25a3c1eacdaf549274b></a></li><li>1.105: <a href=#pg-633020ef232bc34f60c82153578a6c9b></a></li><li>1.106: <a href=#pg-e938edeb3d824f9b364de617a1f10a93></a></li><li>1.107: <a href=#pg-aa9f718186487df2ab6885cae45f5d37></a></li><li>1.108: <a href=#pg-60d816e74ec8e0301cc484b19d7694e6></a></li></ul><li>2: <a href=#pg-82b2fcf985bae77dcb754387a9fcc64f>kubeadm init</a></li><li>3: <a href=#pg-2a2b5f34806b4b1bd2c12682ac170d68>kubeadm join</a></li><li>4: <a href=#pg-2c20539d9fabf5982e2dd931742714bd>kubeadm upgrade</a></li><li>5: <a href=#pg-5042dc49c5348b3674d3878f37f7670b>kubeadm config</a></li><li>6: <a href=#pg-6eb5bc1e7114609930a76c683cc27c2b>kubeadm reset</a></li><li>7: <a href=#pg-516f4705fb2f5f62c76c7742772726a3>kubeadm token</a></li><li>8: <a href=#pg-34c4af6f36d969ed08ba840e7fb64c6d>kubeadm version</a></li><li>9: <a href=#pg-92a39c69c3689119dd5fa12886cb73a3>kubeadm alpha</a></li><li>10: <a href=#pg-6a1fed09235bbf3644c804339928f10e>kubeadm certs</a></li><li>11: <a href=#pg-fbe8dcd222ce5795a5c325670a26b067>kubeadm init phase</a></li><li>12: <a href=#pg-62a742c564b0b5b7ac12a95e67cc425a>kubeadm join phase</a></li><li>13: <a href=#pg-1ab2d643d770ca684548de4ddbc7d8c4>kubeadm kubeconfig</a></li><li>14: <a href=#pg-b969d0033ce5d9036463521fb1f150b3>kubeadm reset phase</a></li><li>15: <a href=#pg-dfd085b5ab706bd84dda15847dd27f1b>kubeadm upgrade phase</a></li><li>16: <a href=#pg-455b6412a275b743ee8ad90f35808393>Implementation details</a></li></ul><div class=content><p><img src=/images/kubeadm-stacked-color.png align=right width=150px>Kubeadm is a tool built to provide <code>kubeadm init</code> and <code>kubeadm join</code> as best-practice "fast paths" for creating Kubernetes clusters.</p><p>kubeadm performs the actions necessary to get a minimum viable cluster up and running. By design, it cares only about bootstrapping, not about provisioning machines. Likewise, installing various nice-to-have addons, like the Kubernetes Dashboard, monitoring solutions, and cloud-specific addons, is not in scope.</p><p>Instead, we expect higher-level and more tailored tooling to be built on top of kubeadm, and ideally, using kubeadm as the basis of all deployments will make it easier to create conformant clusters.</p><h2 id=how-to-install>How to install</h2><p>To install kubeadm, see the <a href=/docs/setup/production-environment/tools/kubeadm/install-kubeadm>installation guide</a>.</p><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init>kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join>kubeadm join</a> to bootstrap a Kubernetes worker node and join it to the cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-upgrade>kubeadm upgrade</a> to upgrade a Kubernetes cluster to a newer version</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-config>kubeadm config</a> if you initialized your cluster using kubeadm v1.7.x or lower, to configure your cluster for <code>kubeadm upgrade</code></li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-token>kubeadm token</a> to manage tokens for <code>kubeadm join</code></li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset>kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-certs>kubeadm certs</a> to manage Kubernetes certificates</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig>kubeadm kubeconfig</a> to manage kubeconfig files</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-version>kubeadm version</a> to print the kubeadm version</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-alpha>kubeadm alpha</a> to preview a set of features made available for gathering feedback from the community</li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-36c22b52e8447eb3d2452d4f56fbea9b>1 - Kubeadm Generated</h1></div><div class=td-content><h1 id=pg-fd3ad295c1f10bfa333f841bbdffba81>1.1 -</h1><p>kubeadm: easily bootstrap a secure Kubernetes cluster</p><h3 id=synopsis>Synopsis</h3><pre><code>┌──────────────────────────────────────────────────────────┐
│ KUBEADM                                                  │
│ Easily bootstrap a secure Kubernetes cluster             │
│                                                          │
│ Please give us feedback at:                              │
│ https://github.com/kubernetes/kubeadm/issues             │
└──────────────────────────────────────────────────────────┘
</code></pre><p>Example usage:</p><pre><code>Create a two-machine cluster with one control-plane node
(which controls the cluster), and one worker node
(where your workloads, like Pods and Deployments run).

┌──────────────────────────────────────────────────────────┐
│ On the first machine:                                    │
├──────────────────────────────────────────────────────────┤
│ control-plane# kubeadm init                              │
└──────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────┐
│ On the second machine:                                   │
├──────────────────────────────────────────────────────────┤
│ worker# kubeadm join &amp;lt;arguments-returned-from-init&amp;gt;      │
└──────────────────────────────────────────────────────────┘

You can then repeat the second step on as many other machines as you like.
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubeadm</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-8df9aba508b2736a6712ef46227eea7d>1.2 -</h1><p>Commands related to handling kubernetes certificates</p><h3 id=synopsis>Synopsis</h3><p>Commands related to handling kubernetes certificates</p><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for certs</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-018648dfc6f28bc9b969f45af0563cae>1.3 -</h1><p>Generate certificate keys</p><h3 id=synopsis>Synopsis</h3><p>This command will print out a secure randomly-generated certificate key that can be used with
the "init" command.</p><p>You can also use "kubeadm init --upload-certs" without specifying a certificate key and it will
generate and print one for you.</p><pre tabindex=0><code>kubeadm certs certificate-key [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for certificate-key</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-4a1ff27cdf01c1c47d034278048e776b>1.4 -</h1><p>Check certificates expiration for a Kubernetes cluster</p><h3 id=synopsis>Synopsis</h3><p>Checks expiration for the certificates in the local PKI managed by kubeadm.</p><pre tabindex=0><code>kubeadm certs check-expiration [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for check-expiration</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-5d6b2999153cd86f56329534249fc4ec>1.5 -</h1><p>Generate keys and certificate signing requests</p><h3 id=synopsis>Synopsis</h3><p>Generates keys and certificate signing requests (CSRs) for all the certificates required to run the control plane. This command also generates partial kubeconfig files with private key data in the "users > user > client-key-data" field, and for each kubeconfig file an accompanying ".csr" file is created.</p><p>This command is designed for use in <a href=https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode>Kubeadm External CA Mode</a>. It generates CSRs which you can then submit to your external certificate authority for signing.</p><p>The PEM encoded signed certificates should then be saved alongside the key files, using ".crt" as the file extension, or in the case of kubeconfig files, the PEM encoded signed certificate should be base64 encoded and added to the kubeconfig file in the "users > user > client-certificate-data" field.</p><pre tabindex=0><code>kubeadm certs generate-csr [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # The following command will generate keys and CSRs for all control-plane certificates and kubeconfig files:
  kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for generate-csr</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-adb5eecdc351074cc2e0cc2b1b4f04a8>1.6 -</h1><p>Renew certificates for a Kubernetes cluster</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm certs renew [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for renew</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-df4c2dc6cba0be90d8d7de2fca9b87f7>1.7 -</h1><p>Renew the certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew admin.conf [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for admin.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-6d6746e8ac1f1602f7dab1056b27e5c2>1.8 -</h1><p>Renew all available certificates</p><h3 id=synopsis>Synopsis</h3><p>Renew all known certificates necessary to run the control plane. Renewals are run unconditionally, regardless of expiration date. Renewals can also be run individually for more control.</p><pre tabindex=0><code>kubeadm certs renew all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-7449c7fa06f25b967cf531e937b0f4b2>1.9 -</h1><p>Renew the certificate the apiserver uses to access etcd</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate the apiserver uses to access etcd.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver-etcd-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-b5c6ae77d3be9bd358c68667006cfc18>1.10 -</h1><p>Renew the certificate for the API server to connect to kubelet</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for the API server to connect to kubelet.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver-kubelet-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-4f804e59ec1739e733807d2b591d771f>1.11 -</h1><p>Renew the certificate for serving the Kubernetes API</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for serving the Kubernetes API.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew apiserver [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-f5cf8caa95834803b133d53c321ab4a9>1.12 -</h1><p>Renew the certificate embedded in the kubeconfig file for the controller manager to use</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate embedded in the kubeconfig file for the controller manager to use.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew controller-manager.conf [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for controller-manager.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-ee770858e2bb767b79d572b4882af656>1.13 -</h1><p>Renew the certificate for liveness probes to healthcheck etcd</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for liveness probes to healthcheck etcd.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-healthcheck-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-7484bf11b6183f4c329b1f66734cc886>1.14 -</h1><p>Renew the certificate for etcd nodes to communicate with each other</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for etcd nodes to communicate with each other.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew etcd-peer [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-peer</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-bf444d915ab856dba693c36294c5427b>1.15 -</h1><p>Renew the certificate for serving etcd</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for serving etcd.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew etcd-server [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-server</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-f5c087e087714c5290b4967dd7924b3b>1.16 -</h1><p>Renew the certificate for the front proxy client</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for the front proxy client.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew front-proxy-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for front-proxy-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-20703ce1c236264ad78cb1ad7244723e>1.17 -</h1><p>Renew the certificate embedded in the kubeconfig file for the scheduler manager to use</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate embedded in the kubeconfig file for the scheduler manager to use.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew scheduler.conf [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for scheduler.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-49aaa494ef75de67609987a43e5ee520>1.18 -</h1><p>Output shell completion code for the specified shell (bash or zsh)</p><h3 id=synopsis>Synopsis</h3><p>Output shell completion code for the specified shell (bash or zsh).
The shell code must be evaluated to provide interactive
completion of kubeadm commands. This can be done by sourcing it from
the .bash_profile.</p><p>Note: this requires the bash-completion framework.</p><p>To install it on Mac use homebrew:
$ brew install bash-completion
Once installed, bash_completion must be evaluated. This can be done by adding the
following line to the .bash_profile
$ source $(brew --prefix)/etc/bash_completion</p><p>If bash-completion is not installed on Linux, please install the 'bash-completion' package
via your distribution's package manager.</p><p>Note for zsh users: [1] zsh completions are only supported in versions of zsh >= 5.2</p><pre tabindex=0><code>kubeadm completion SHELL [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>
# Install bash completion on a Mac using homebrew
brew install bash-completion
printf &#34;\n# Bash completion support\nsource $(brew --prefix)/etc/bash_completion\n&#34; &gt;&gt; $HOME/.bash_profile
source $HOME/.bash_profile

# Load the kubeadm completion code for bash into the current shell
source &lt;(kubeadm completion bash)

# Write bash completion code to a file and source it from .bash_profile
kubeadm completion bash &gt; ~/.kube/kubeadm_completion.bash.inc
printf &#34;\n# Kubeadm shell completion\nsource &#39;$HOME/.kube/kubeadm_completion.bash.inc&#39;\n&#34; &gt;&gt; $HOME/.bash_profile
source $HOME/.bash_profile

# Load the kubeadm completion code for zsh[1] into the current shell
source &lt;(kubeadm completion zsh)
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for completion</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-d63311c16e6468f5a5940aadd902faa7>1.19 -</h1><p>Manage configuration for a kubeadm cluster persisted in a ConfigMap in the cluster</p><h3 id=synopsis>Synopsis</h3><p>There is a ConfigMap in the kube-system namespace called "kubeadm-config" that kubeadm uses to store internal configuration about the
cluster. kubeadm CLI v1.8.0+ automatically creates this ConfigMap with the config used with 'kubeadm init', but if you
initialized your cluster using kubeadm v1.7.x or lower, you must use the 'config upload' command to create this
ConfigMap. This is required so that 'kubeadm upgrade' can configure your upgraded cluster correctly.</p><pre tabindex=0><code>kubeadm config [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for config</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-6678a79b85306310066616185153377d>1.20 -</h1><p>Interact with container images used by kubeadm</p><h3 id=synopsis>Synopsis</h3><p>Interact with container images used by kubeadm</p><pre tabindex=0><code>kubeadm config images [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for images</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-8f73e208cc67d221165f6294393881a7>1.21 -</h1><p>Print a list of images kubeadm will use. The configuration file is used in case any images or image repositories are customized</p><h3 id=synopsis>Synopsis</h3><p>Print a list of images kubeadm will use. The configuration file is used in case any images or image repositories are customized</p><pre tabindex=0><code>kubeadm config images list [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for list</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--show-managed-fields</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If true, keep the managedFields when printing objects in JSON or YAML format.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-9aec3477159c105a46f4479de1c21418>1.22 -</h1><p>Pull images used by kubeadm</p><h3 id=synopsis>Synopsis</h3><p>Pull images used by kubeadm</p><pre tabindex=0><code>kubeadm config images pull [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for pull</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-045e41c28798930e21f77a90c3a90263>1.23 -</h1><p>Read an older version of the kubeadm configuration API types from a file, and output the similar config object for the newer version</p><h3 id=synopsis>Synopsis</h3><p>This command lets you convert configuration objects of older versions to the latest supported version,
locally in the CLI tool without ever touching anything in the cluster.
In this version of kubeadm, the following API versions are supported:</p><ul><li>kubeadm.k8s.io/v1beta3</li></ul><p>Further, kubeadm can only write out config of version "kubeadm.k8s.io/v1beta3", but read both types.
So regardless of what version you pass to the --old-config parameter here, the API object will be
read, deserialized, defaulted, converted, validated, and re-serialized when written to stdout or
--new-config if specified.</p><p>In other words, the output of this command is what kubeadm actually would read internally if you
submitted this file to "kubeadm init"</p><pre tabindex=0><code>kubeadm config migrate [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for migrate</p></td></tr><tr><td colspan=2>--new-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the resulting equivalent kubeadm config file using the new API version. Optional, if not specified output will be sent to STDOUT.</p></td></tr><tr><td colspan=2>--old-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the kubeadm config file that is using an old API version and should be converted. This flag is mandatory.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e7d83478123771ad14f475ee44440303>1.24 -</h1><p>Print configuration</p><h3 id=synopsis>Synopsis</h3><p>This command prints configurations for subcommands provided.
For details, see: <a href=https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories>https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories</a></p><pre tabindex=0><code>kubeadm config print [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for print</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-57a6b20d9571220989a7a445d4459468>1.25 -</h1><p>Print default init configuration, that can be used for 'kubeadm init'</p><h3 id=synopsis>Synopsis</h3><p>This command prints objects such as the default init configuration that is used for 'kubeadm init'.</p><p>Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like "abcdef.0123456789abcdef" in order to pass validation but
not perform the real computation for creating a token.</p><pre tabindex=0><code>kubeadm config print init-defaults [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--component-configs strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for init-defaults</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-92a2c11eef37937af846b55d9b87a544>1.26 -</h1><p>Print default join configuration, that can be used for 'kubeadm join'</p><h3 id=synopsis>Synopsis</h3><p>This command prints objects such as the default join configuration that is used for 'kubeadm join'.</p><p>Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like "abcdef.0123456789abcdef" in order to pass validation but
not perform the real computation for creating a token.</p><pre tabindex=0><code>kubeadm config print join-defaults [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--component-configs strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for join-defaults</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-dcfffcaafb438cd650475945ddc129ee>1.27 -</h1><p>Run this command in order to set up the Kubernetes control plane</p><h3 id=synopsis>Synopsis</h3><p>Run this command in order to set up the Kubernetes control plane</p><p>The "init" command executes the following phases:</p><pre tabindex=0><code>preflight                    Run pre-flight checks
certs                        Certificate generation
  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components
  /apiserver                   Generate the certificate for serving the Kubernetes API
  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet
  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy
  /front-proxy-client          Generate the certificate for the front proxy client
  /etcd-ca                     Generate the self-signed CA to provision identities for etcd
  /etcd-server                 Generate the certificate for serving etcd
  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other
  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd
  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd
  /sa                          Generate a private key for signing service account tokens along with its public key
kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file
  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself
  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes
  /controller-manager          Generate a kubeconfig file for the controller manager to use
  /scheduler                   Generate a kubeconfig file for the scheduler to use
kubelet-start                Write kubelet settings and (re)start the kubelet
control-plane                Generate all static Pod manifest files necessary to establish the control plane
  /apiserver                   Generates the kube-apiserver static Pod manifest
  /controller-manager          Generates the kube-controller-manager static Pod manifest
  /scheduler                   Generates the kube-scheduler static Pod manifest
etcd                         Generate static Pod manifest file for local etcd
  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance
upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap
  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet                     Upload the kubelet component config to a ConfigMap
upload-certs                 Upload certificates to kubeadm-certs
mark-control-plane           Mark a node as a control-plane
bootstrap-token              Generates bootstrap tokens used to join a node to a cluster
kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap
  /experimental-cert-rotation  Enable kubelet client certificate rotation
addon                        Install required addons for passing conformance tests
  /coredns                     Install the CoreDNS addon to a Kubernetes cluster
  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster
</code></pre><pre tabindex=0><code>kubeadm init [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--apiserver-cert-extra-sans strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for init</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr><tr><td colspan=2>--skip-certificate-key-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't print the key used to encrypt the control-plane certificates.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>List of phases to be skipped</p></td></tr><tr><td colspan=2>--skip-token-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Skip printing of the default bootstrap token generated by 'kubeadm init'.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The token to use for establishing bidirectional trust between nodes and control-plane nodes. The format is [a-z0-9]{6}.[a-z0-9]{16} - e.g. abcdef.0123456789abcdef</p></td></tr><tr><td colspan=2>--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire</p></td></tr><tr><td colspan=2>--upload-certs</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Upload control-plane certificates to the kubeadm-certs Secret.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-6eaa2624c512051ff2a9cdbc6ee54949>1.28 -</h1><p>Use this command to invoke single phase of the init workflow</p><h3 id=synopsis>Synopsis</h3><p>Use this command to invoke single phase of the init workflow</p><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for phase</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-4b7ada30e3923594b2907dcb8b431080>1.29 -</h1><p>Install required addons for passing conformance tests</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase addon [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for addon</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-6d1154da2e554de858cf4e7b37c054fa>1.30 -</h1><p>Install all the addons</p><h3 id=synopsis>Synopsis</h3><p>Install all the addons</p><pre tabindex=0><code>kubeadm init phase addon all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-d3a16914ddc849435ed864163978ddbf>1.31 -</h1><p>Install the CoreDNS addon to a Kubernetes cluster</p><h3 id=synopsis>Synopsis</h3><p>Install the CoreDNS addon components via the API server. Please note that although the DNS server is deployed, it will not be scheduled until CNI is installed.</p><pre tabindex=0><code>kubeadm init phase addon coredns [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for coredns</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--print-manifest</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Print the addon manifests to STDOUT instead of installing them</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-8a257337ea78e5d9a0c54aa971eaf991>1.32 -</h1><p>Install the kube-proxy addon to a Kubernetes cluster</p><h3 id=synopsis>Synopsis</h3><p>Install the kube-proxy addon components via the API server.</p><pre tabindex=0><code>kubeadm init phase addon kube-proxy [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kube-proxy</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan=2>--print-manifest</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Print the addon manifests to STDOUT instead of installing them</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-77759011117e7974cbfee9694b6f8801>1.33 -</h1><p>Generates bootstrap tokens used to join a node to a cluster</p><h3 id=synopsis>Synopsis</h3><p>Bootstrap tokens are used for establishing bidirectional trust between a node joining the cluster and a control-plane node.</p><p>This command makes all the configurations required to make bootstrap tokens works and then creates an initial token.</p><pre tabindex=0><code>kubeadm init phase bootstrap-token [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Make all the bootstrap token configurations and create an initial token, functionally
  # equivalent to what generated by kubeadm init.
  kubeadm init phase bootstrap-token
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for bootstrap-token</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--skip-token-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Skip printing of the default bootstrap token generated by 'kubeadm init'.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-8e1920b2caaa8de839cd3997edca80e9>1.34 -</h1><p>Certificate generation</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase certs [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for certs</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-00aa8c2e4b3b2fd3a4b7986976b7bfda>1.35 -</h1><p>Generate all certificates</p><h3 id=synopsis>Synopsis</h3><p>Generate all certificates</p><pre tabindex=0><code>kubeadm init phase certs all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-cert-extra-sans strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-316aa97ee5719be5a723ac1b77c44f5a>1.36 -</h1><p>Generate the certificate the apiserver uses to access etcd</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate the apiserver uses to access etcd, and save them into apiserver-etcd-client.crt and apiserver-etcd-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs apiserver-etcd-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver-etcd-client</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-759e85e62b32c0697ab37c214e99a864>1.37 -</h1><p>Generate the certificate for the API server to connect to kubelet</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for the API server to connect to kubelet, and save them into apiserver-kubelet-client.crt and apiserver-kubelet-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs apiserver-kubelet-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver-kubelet-client</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-2e7091074560abc2a8e7b897cdd8a7b6>1.38 -</h1><p>Generate the certificate for serving the Kubernetes API</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for serving the Kubernetes API, and save them into apiserver.crt and apiserver.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs apiserver [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-cert-extra-sans strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-eedb8f5a6ed4cff1dfb1a5d14176b5b3>1.39 -</h1><p>Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components</p><h3 id=synopsis>Synopsis</h3><p>Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components, and save them into ca.crt and ca.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs ca [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for ca</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-c55f2fa6bdaa124b37da090a3ef90902>1.40 -</h1><p>Generate the self-signed CA to provision identities for etcd</p><h3 id=synopsis>Synopsis</h3><p>Generate the self-signed CA to provision identities for etcd, and save them into etcd/ca.crt and etcd/ca.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs etcd-ca [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-ca</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-10f416336efdcee22d691869e7585b9f>1.41 -</h1><p>Generate the certificate for liveness probes to healthcheck etcd</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for liveness probes to healthcheck etcd, and save them into etcd/healthcheck-client.crt and etcd/healthcheck-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs etcd-healthcheck-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-healthcheck-client</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-c4b6d149cda7cac896f4374c821b7fc6>1.42 -</h1><p>Generate the certificate for etcd nodes to communicate with each other</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for etcd nodes to communicate with each other, and save them into etcd/peer.crt and etcd/peer.key files.</p><p>Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs etcd-peer [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-peer</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-1db087626f4f368e932df6f12993a5ab>1.43 -</h1><p>Generate the certificate for serving etcd</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for serving etcd, and save them into etcd/server.crt and etcd/server.key files.</p><p>Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs etcd-server [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-server</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e85da83e18a50e472eb56320af55768a>1.44 -</h1><p>Generate the self-signed CA to provision identities for front proxy</p><h3 id=synopsis>Synopsis</h3><p>Generate the self-signed CA to provision identities for front proxy, and save them into front-proxy-ca.crt and front-proxy-ca.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs front-proxy-ca [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for front-proxy-ca</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-eb911bdcb8bb53ceb8b253089ab0d814>1.45 -</h1><p>Generate the certificate for the front proxy client</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for the front proxy client, and save them into front-proxy-client.crt and front-proxy-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs front-proxy-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for front-proxy-client</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-62c5dc89c39f3ecd6aee57545d12891a>1.46 -</h1><p>Generate a private key for signing service account tokens along with its public key</p><h3 id=synopsis>Synopsis</h3><p>Generate the private key for signing service account tokens along with its public key, and save them into sa.key and sa.pub files. If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs sa [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for sa</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-2a79e12b9455f0ca1a6d5b00a9841249>1.47 -</h1><p>Generate all static Pod manifest files necessary to establish the control plane</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase control-plane [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for control-plane</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-a2c8efac328fcf416e558bf167ef417d>1.48 -</h1><p>Generate all static Pod manifest files</p><h3 id=synopsis>Synopsis</h3><p>Generate all static Pod manifest files</p><pre tabindex=0><code>kubeadm init phase control-plane all [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Generates all static Pod manifest files for control plane components,
  # functionally equivalent to what is generated by kubeadm init.
  kubeadm init phase control-plane all
  
  # Generates all static Pod manifest files using options read from a configuration file.
  kubeadm init phase control-plane all --config config.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--apiserver-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname>=&lt;value></p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>--controller-manager-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname>=&lt;value></p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan=2>--scheduler-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname>=&lt;value></p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-d93bd37094201bdefdb3908c9a6c86b3>1.49 -</h1><p>Generates the kube-apiserver static Pod manifest</p><h3 id=synopsis>Synopsis</h3><p>Generates the kube-apiserver static Pod manifest</p><pre tabindex=0><code>kubeadm init phase control-plane apiserver [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--apiserver-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname>=&lt;value></p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-efa9ae4c92ed1c26dc04bb049db38cec>1.50 -</h1><p>Generates the kube-controller-manager static Pod manifest</p><h3 id=synopsis>Synopsis</h3><p>Generates the kube-controller-manager static Pod manifest</p><pre tabindex=0><code>kubeadm init phase control-plane controller-manager [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--controller-manager-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname>=&lt;value></p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for controller-manager</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-576c00359074987304b3b418cec9a5b1>1.51 -</h1><p>Generates the kube-scheduler static Pod manifest</p><h3 id=synopsis>Synopsis</h3><p>Generates the kube-scheduler static Pod manifest</p><pre tabindex=0><code>kubeadm init phase control-plane scheduler [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for scheduler</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--scheduler-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname>=&lt;value></p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e6097fe5dd013abd9f356c2566ef7b63>1.52 -</h1><p>Generate static Pod manifest file for local etcd</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase etcd [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-5ab65eab2498cc1893af5b3bf8fe08fc>1.53 -</h1><p>Generate the static Pod manifest file for a local, single-node local etcd instance</p><h3 id=synopsis>Synopsis</h3><p>Generate the static Pod manifest file for a local, single-node local etcd instance</p><pre tabindex=0><code>kubeadm init phase etcd local [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Generates the static Pod manifest file for etcd, functionally
  # equivalent to what is generated by kubeadm init.
  kubeadm init phase etcd local
  
  # Generates the static Pod manifest file for etcd using options
  # read from a configuration file.
  kubeadm init phase etcd local --config config.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for local</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-fcb78718510a9d3027d1bb9d379c0c17>1.54 -</h1><p>Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase kubeconfig [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubeconfig</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-a0e1457f667eb757f82f8c42901aa6c5>1.55 -</h1><p>Generate a kubeconfig file for the admin to use and for kubeadm itself</p><h3 id=synopsis>Synopsis</h3><p>Generate the kubeconfig file for the admin and for kubeadm itself, and save it to admin.conf file.</p><pre tabindex=0><code>kubeadm init phase kubeconfig admin [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for admin</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-59e362bf565041872395d165e99eafc1>1.56 -</h1><p>Generate all kubeconfig files</p><h3 id=synopsis>Synopsis</h3><p>Generate all kubeconfig files</p><pre tabindex=0><code>kubeadm init phase kubeconfig all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-2a5040747a02ae2b2326c9901f1725d3>1.57 -</h1><p>Generate a kubeconfig file for the controller manager to use</p><h3 id=synopsis>Synopsis</h3><p>Generate the kubeconfig file for the controller manager to use and save it to controller-manager.conf file</p><pre tabindex=0><code>kubeadm init phase kubeconfig controller-manager [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for controller-manager</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-043bd19497eefb77a6ed30a4d704fe7c>1.58 -</h1><p>Generate a kubeconfig file for the kubelet to use <em>only</em> for cluster bootstrapping purposes</p><h3 id=synopsis>Synopsis</h3><p>Generate the kubeconfig file for the kubelet to use and save it to kubelet.conf file.</p><p>Please note that this should <em>only</em> be used for cluster bootstrapping purposes. After your control plane is up, you should request all kubelet credentials from the CSR API.</p><pre tabindex=0><code>kubeadm init phase kubeconfig kubelet [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-bffb0d67824e75ade7232d09754b9718>1.59 -</h1><p>Generate a kubeconfig file for the scheduler to use</p><h3 id=synopsis>Synopsis</h3><p>Generate the kubeconfig file for the scheduler to use and save it to scheduler.conf file.</p><pre tabindex=0><code>kubeadm init phase kubeconfig scheduler [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for scheduler</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-a37b5872c572c71775e389df50fca215>1.60 -</h1><p>Updates settings relevant to the kubelet after TLS bootstrap</p><h3 id=synopsis>Synopsis</h3><p>Updates settings relevant to the kubelet after TLS bootstrap</p><pre tabindex=0><code>kubeadm init phase kubelet-finalize [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Updates settings relevant to the kubelet after TLS bootstrap&#34;
  kubeadm init phase kubelet-finalize all --config
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet-finalize</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-3f49598c499c3356d89d98fdc8c8ad79>1.61 -</h1><p>Run all kubelet-finalize phases</p><h3 id=synopsis>Synopsis</h3><p>Run all kubelet-finalize phases</p><pre tabindex=0><code>kubeadm init phase kubelet-finalize all [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Updates settings relevant to the kubelet after TLS bootstrap&#34;
  kubeadm init phase kubelet-finalize all --config
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-7d68ac74e5301f789ddd2e25dd36218e>1.62 -</h1><p>Enable kubelet client certificate rotation</p><h3 id=synopsis>Synopsis</h3><p>Enable kubelet client certificate rotation</p><pre tabindex=0><code>kubeadm init phase kubelet-finalize experimental-cert-rotation [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for experimental-cert-rotation</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e7c1ae3d905d9b6854216e26651955cd>1.63 -</h1><p>Write kubelet settings and (re)start the kubelet</p><h3 id=synopsis>Synopsis</h3><p>Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.</p><pre tabindex=0><code>kubeadm init phase kubelet-start [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Writes a dynamic environment file with kubelet flags from a InitConfiguration file.
  kubeadm init phase kubelet-start --config config.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet-start</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-967a98823c19c8338bfc0e1338a20fb1>1.64 -</h1><p>Mark a node as a control-plane</p><h3 id=synopsis>Synopsis</h3><p>Mark a node as a control-plane</p><pre tabindex=0><code>kubeadm init phase mark-control-plane [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Applies control-plane label and taint to the current node, functionally equivalent to what executed by kubeadm init.
  kubeadm init phase mark-control-plane --config config.yaml
  
  # Applies control-plane label and taint to a specific node
  kubeadm init phase mark-control-plane --node-name myNode
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for mark-control-plane</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-b5838cc93a3fdb37b61afd201a71edd9>1.65 -</h1><p>Run pre-flight checks</p><h3 id=synopsis>Synopsis</h3><p>Run pre-flight checks for kubeadm init.</p><pre tabindex=0><code>kubeadm init phase preflight [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Run pre-flight checks for kubeadm init using a config file.
  kubeadm init phase preflight --config kubeadm-config.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for preflight</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-f54c84a0fdada369a87b2ced6ccfc38f>1.66 -</h1><p>Upload certificates to kubeadm-certs</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase upload-certs [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for upload-certs</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--skip-certificate-key-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't print the key used to encrypt the control-plane certificates.</p></td></tr><tr><td colspan=2>--upload-certs</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Upload control-plane certificates to the kubeadm-certs Secret.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-0d96e214c09a8f014e984a6b980522b3>1.67 -</h1><p>Upload the kubeadm and kubelet configuration to a ConfigMap</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase upload-config [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for upload-config</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-48afa88840a20edf1ad613c18480d4fc>1.68 -</h1><p>Upload all configuration to a config map</p><h3 id=synopsis>Synopsis</h3><p>Upload all configuration to a config map</p><pre tabindex=0><code>kubeadm init phase upload-config all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-14da359f76a0f36af507d289dd4a5050>1.69 -</h1><p>Upload the kubeadm ClusterConfiguration to a ConfigMap</p><h3 id=synopsis>Synopsis</h3><p>Upload the kubeadm ClusterConfiguration to a ConfigMap called kubeadm-config in the kube-system namespace. This enables correct configuration of system components and a seamless user experience when upgrading.</p><p>Alternatively, you can use kubeadm config.</p><pre tabindex=0><code>kubeadm init phase upload-config kubeadm [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # upload the configuration of your cluster
  kubeadm init phase upload-config --config=myConfig.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubeadm</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-3fda282409b804a14879b9c65c035797>1.70 -</h1><p>Upload the kubelet component config to a ConfigMap</p><h3 id=synopsis>Synopsis</h3><p>Upload the kubelet configuration extracted from the kubeadm InitConfiguration object to a kubelet-config ConfigMap in the cluster</p><pre tabindex=0><code>kubeadm init phase upload-config kubelet [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Upload the kubelet configuration from the kubeadm Config file to a ConfigMap in the cluster.
  kubeadm init phase upload-config kubelet --config kubeadm.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e044e6c69c2b1512c8d89430e0400771>1.71 -</h1><p>Run this on any machine you wish to join an existing cluster</p><h3 id=synopsis>Synopsis</h3><p>When joining a kubeadm initialized cluster, we need to establish
bidirectional trust. This is split into discovery (having the Node
trust the Kubernetes Control Plane) and TLS bootstrap (having the
Kubernetes Control Plane trust the Node).</p><p>There are 2 main schemes for discovery. The first is to use a shared
token along with the IP address of the API server. The second is to
provide a file - a subset of the standard kubeconfig file. The
discovery/kubeconfig file supports token, client-go authentication
plugins ("exec"), "tokenFile", and "authProvider". This file can be a
local file or downloaded via an HTTPS URL. The forms are
kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443,
kubeadm join --discovery-file path/to/file.conf, or kubeadm join
--discovery-file https://url/file.conf. Only one form can be used. If
the discovery information is loaded from a URL, HTTPS must be used.
Also, in that case the host installed CA bundle is used to verify
the connection.</p><p>If you use a shared token for discovery, you should also pass the
--discovery-token-ca-cert-hash flag to validate the public key of the
root certificate authority (CA) presented by the Kubernetes Control Plane.
The value of this flag is specified as "&lt;hash-type>:&lt;hex-encoded-value>",
where the supported hash type is "sha256". The hash is calculated over
the bytes of the Subject Public Key Info (SPKI) object (as in RFC7469).
This value is available in the output of "kubeadm init" or can be
calculated using standard tools. The --discovery-token-ca-cert-hash flag
may be repeated multiple times to allow more than one public key.</p><p>If you cannot know the CA public key hash ahead of time, you can pass
the --discovery-token-unsafe-skip-ca-verification flag to disable this
verification. This weakens the kubeadm security model since other nodes
can potentially impersonate the Kubernetes Control Plane.</p><p>The TLS bootstrap mechanism is also driven via a shared token. This is
used to temporarily authenticate with the Kubernetes Control Plane to submit a
certificate signing request (CSR) for a locally created key pair. By
default, kubeadm will set up the Kubernetes Control Plane to automatically
approve these signing requests. This token is passed in with the
--tls-bootstrap-token abcdef.1234567890abcdef flag.</p><p>Often times the same token is used for both parts. In this case, the
--token flag can be used instead of specifying each token individually.</p><p>The "join [api-server-endpoint]" command executes the following phases:</p><pre tabindex=0><code>preflight              Run join pre-flight checks
control-plane-prepare  Prepare the machine for serving a control plane
  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
  /certs                 Generate the certificates for the new control plane components
  /kubeconfig            Generate the kubeconfig for the new control plane components
  /control-plane         Generate the manifests for the new control plane components
kubelet-start          Write kubelet settings, certificates and (re)start the kubelet
control-plane-join     Join a machine as a control plane instance
  /etcd                  Add a new local etcd member
  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap (DEPRECATED)
  /mark-control-plane    Mark a node as a control-plane
</code></pre><pre tabindex=0><code>kubeadm join [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this key to decrypt the certificate secrets uploaded by init.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for join</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>List of phases to be skipped</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-9f968809f867b76728697577492429e8>1.72 -</h1><p>Use this command to invoke single phase of the join workflow</p><h3 id=synopsis>Synopsis</h3><p>Use this command to invoke single phase of the join workflow</p><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for phase</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-c3c506c1683aed34398a34ab66d609da>1.73 -</h1><p>Join a machine as a control plane instance</p><h3 id=synopsis>Synopsis</h3><p>Join a machine as a control plane instance</p><pre tabindex=0><code>kubeadm join phase control-plane-join [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Joins a machine as a control plane instance
  kubeadm join phase control-plane-join all
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for control-plane-join</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-2c1a5a4405dca745ef50b4e86f5977c7>1.74 -</h1><p>Join a machine as a control plane instance</p><h3 id=synopsis>Synopsis</h3><p>Join a machine as a control plane instance</p><pre tabindex=0><code>kubeadm join phase control-plane-join all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-003aaef561d065ecdaeb2c325b6b9253>1.75 -</h1><p>Add a new local etcd member</p><h3 id=synopsis>Synopsis</h3><p>Add a new local etcd member</p><pre tabindex=0><code>kubeadm join phase control-plane-join etcd [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-535f050663a6d8db3a61df2b19a0714b>1.76 -</h1><p>Mark a node as a control-plane</p><h3 id=synopsis>Synopsis</h3><p>Mark a node as a control-plane</p><pre tabindex=0><code>kubeadm join phase control-plane-join mark-control-plane [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for mark-control-plane</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-2f0a684baffe3cdf830c16693412f8e0>1.77 -</h1><p>Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap (DEPRECATED)</p><h3 id=synopsis>Synopsis</h3><p>Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap (DEPRECATED)</p><pre tabindex=0><code>kubeadm join phase control-plane-join update-status [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for update-status</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-aba528e06c437710b269f4e41f854fdd>1.78 -</h1><p>Prepare the machine for serving a control plane</p><h3 id=synopsis>Synopsis</h3><p>Prepare the machine for serving a control plane</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Prepares the machine for serving a control plane
  kubeadm join phase control-plane-prepare all
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for control-plane-prepare</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-1d7987a759cd1519def4d433710cdff1>1.79 -</h1><p>Prepare the machine for serving a control plane</p><h3 id=synopsis>Synopsis</h3><p>Prepare the machine for serving a control plane</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare all [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this key to decrypt the certificate secrets uploaded by init.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-33216a69b333c330cb8b305a119abc7c>1.80 -</h1><p>Generate the certificates for the new control plane components</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificates for the new control plane components</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare certs [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for certs</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-53abd743076fc859067264f3e8e676e0>1.81 -</h1><p>Generate the manifests for the new control plane components</p><h3 id=synopsis>Synopsis</h3><p>Generate the manifests for the new control plane components</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare control-plane [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for control-plane</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-3a08eb202d572e417768a942ad24c59f>1.82 -</h1><p>[EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret</p><h3 id=synopsis>Synopsis</h3><p>[EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare download-certs [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this key to decrypt the certificate secrets uploaded by init.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for download-certs</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-11ed4820a6c3b411d9c4b87163cf0ae7>1.83 -</h1><p>Generate the kubeconfig for the new control plane components</p><h3 id=synopsis>Synopsis</h3><p>Generate the kubeconfig for the new control plane components</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare kubeconfig [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this key to decrypt the certificate secrets uploaded by init.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubeconfig</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e81c9d9320242b5ed4b063beea6696f8>1.84 -</h1><p>Write kubelet settings, certificates and (re)start the kubelet</p><h3 id=synopsis>Synopsis</h3><p>Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.</p><pre tabindex=0><code>kubeadm join phase kubelet-start [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet-start</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-47f2d404188d6eb1fbf6fffd7fba4e48>1.85 -</h1><p>Run join pre-flight checks</p><h3 id=synopsis>Synopsis</h3><p>Run pre-flight checks for kubeadm join.</p><pre tabindex=0><code>kubeadm join phase preflight [api-server-endpoint] [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Run join pre-flight checks using a config file.
  kubeadm join phase preflight --config kubeadm-config.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this key to decrypt the certificate secrets uploaded by init.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for preflight</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-257824537b4c6c6b33249aa786461156>1.86 -</h1><p>Kubeconfig file utilities</p><h3 id=synopsis>Synopsis</h3><p>Kubeconfig file utilities.</p><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubeconfig</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e10faf6f940de61052258af59e036518>1.87 -</h1><p>Output a kubeconfig file for an additional user</p><h3 id=synopsis>Synopsis</h3><p>Output a kubeconfig file for an additional user.</p><pre tabindex=0><code>kubeadm kubeconfig user [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Output a kubeconfig file for an additional user named foo using a kubeadm config file bar
  kubeadm kubeconfig user --client-name=foo --config=bar
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--client-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The name of user. It will be used as the CN if client certificates are created</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for user</p></td></tr><tr><td colspan=2>--org strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The organizations of the client certificate. It will be used as the O if client certificates are created</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The token that should be used as the authentication mechanism for this kubeconfig, instead of client certificates</p></td></tr><tr><td colspan=2>--validity-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 8760h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The validity period of the client certificate. It is an offset from the current time.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-a46a193f2322aa88cb3b2de2447b0461>1.88 -</h1><p>Performs a best effort revert of changes made to this host by 'kubeadm init' or 'kubeadm join'</p><h3 id=synopsis>Synopsis</h3><p>Performs a best effort revert of changes made to this host by 'kubeadm init' or 'kubeadm join'</p><p>The "reset" command executes the following phases:</p><pre tabindex=0><code>preflight           Run reset pre-flight checks
remove-etcd-member  Remove a local etcd member.
cleanup-node        Run cleanup node.
</code></pre><pre tabindex=0><code>kubeadm reset [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path to the directory where the certificates are stored. If specified, clean this directory.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>-f, --force</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Reset the node without prompting for confirmation.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for reset</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>List of phases to be skipped</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-f5b27d7bd0eeed918f8635c68d220dc5>1.89 -</h1><p>Use this command to invoke single phase of the reset workflow</p><h3 id=synopsis>Synopsis</h3><p>Use this command to invoke single phase of the reset workflow</p><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for phase</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-370e9ffda66b4c48dfa54ea37c3aad21>1.90 -</h1><p>Run cleanup node.</p><h3 id=synopsis>Synopsis</h3><p>Run cleanup node.</p><pre tabindex=0><code>kubeadm reset phase cleanup-node [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path to the directory where the certificates are stored. If specified, clean this directory.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for cleanup-node</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-6bd27042c883aa5c498647d37762392c>1.91 -</h1><p>Run reset pre-flight checks</p><h3 id=synopsis>Synopsis</h3><p>Run pre-flight checks for kubeadm reset.</p><pre tabindex=0><code>kubeadm reset phase preflight [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-f, --force</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Reset the node without prompting for confirmation.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for preflight</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-3a000435e1cca0be398b44b487f530c8>1.92 -</h1><p>Remove a local etcd member.</p><h3 id=synopsis>Synopsis</h3><p>Remove a local etcd member for a control plane node.</p><pre tabindex=0><code>kubeadm reset phase remove-etcd-member [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for remove-etcd-member</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-bee6749065a369c2ab5b311eb43c40ba>1.93 -</h1><p>Manage bootstrap tokens</p><h3 id=synopsis>Synopsis</h3><p>This command manages bootstrap tokens. It is optional and needed only for advanced use cases.</p><p>In short, bootstrap tokens are used for establishing bidirectional trust between a client and a server.
A bootstrap token can be used when a client (for example a node that is about to join the cluster) needs
to trust the server it is talking to. Then a bootstrap token with the "signing" usage can be used.
bootstrap tokens can also function as a way to allow short-lived authentication to the API Server
(the token serves as a way for the API Server to trust the client), for example for doing the TLS Bootstrap.</p><p>What is a bootstrap token more exactly?</p><ul><li>It is a Secret in the kube-system namespace of type "bootstrap.kubernetes.io/token".</li><li>A bootstrap token must be of the form "[a-z0-9]{6}.[a-z0-9]{16}". The former part is the public token ID,
while the latter is the Token Secret and it must be kept private at all circumstances!</li><li>The name of the Secret must be named "bootstrap-token-(token-id)".</li></ul><p>You can read more about bootstrap tokens here:
<a href=https://kubernetes.io/docs/admin/bootstrap-tokens/>https://kubernetes.io/docs/admin/bootstrap-tokens/</a></p><pre tabindex=0><code>kubeadm token [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for token</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-bdd9680ec894593d17f782d5e5665fd4>1.94 -</h1><p>Create bootstrap tokens on the server</p><h3 id=synopsis>Synopsis</h3><p>This command will create a bootstrap token for you.
You can specify the usages for this token, the "time to live" and an optional human friendly description.</p><p>The [token] is the actual token to write.
This should be a securely generated random token of the form "[a-z0-9]{6}.[a-z0-9]{16}".
If no [token] is given, kubeadm will generate a random token instead.</p><pre tabindex=0><code>kubeadm token create [token]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>When used together with '--print-join-command', print the full 'kubeadm join' flag needed to join the cluster as a control-plane. To create a new certificate key you must use 'kubeadm init phase upload-certs --upload-certs'.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--description string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A human friendly description of how this token is used.</p></td></tr><tr><td colspan=2>--groups strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "system:bootstrappers:kubeadm:default-node-token"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Extra groups that this token will authenticate as when used for authentication. Must match "\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\z"</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for create</p></td></tr><tr><td colspan=2>--print-join-command</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Instead of printing only the token, print the full 'kubeadm join' flag needed to join the cluster using the token.</p></td></tr><tr><td colspan=2>--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire</p></td></tr><tr><td colspan=2>--usages strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "signing,authentication"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Describes the ways in which this token can be used. You can pass --usages multiple times or provide a comma separated list of options. Valid options: [signing,authentication]</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-1d005baad1a1e217d7ae0210fec96c3f>1.95 -</h1><p>Delete bootstrap tokens on the server</p><h3 id=synopsis>Synopsis</h3><p>This command will delete a list of bootstrap tokens for you.</p><p>The [token-value] is the full Token of the form "[a-z0-9]{6}.[a-z0-9]{16}" or the
Token ID of the form "[a-z0-9]{6}" to delete.</p><pre tabindex=0><code>kubeadm token delete [token-value] ...
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for delete</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-c79d11d27bed54caac743c93e0b2fb24>1.96 -</h1><p>Generate and print a bootstrap token, but do not create it on the server</p><h3 id=synopsis>Synopsis</h3><p>This command will print out a randomly-generated bootstrap token that can be used with
the "init" and "join" commands.</p><p>You don't have to use this command in order to generate a token. You can do so
yourself as long as it is in the format "[a-z0-9]{6}.[a-z0-9]{16}". This
command is provided for convenience to generate tokens in the given format.</p><p>You can also use "kubeadm init" without specifying a token and it will
generate and print one for you.</p><pre tabindex=0><code>kubeadm token generate [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for generate</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-ba78e64c325e4131dd741235e2a1b2c0>1.97 -</h1><p>List bootstrap tokens on the server</p><h3 id=synopsis>Synopsis</h3><p>This command will list all bootstrap tokens for you.</p><pre tabindex=0><code>kubeadm token list [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.</p></td></tr><tr><td colspan=2>-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for list</p></td></tr><tr><td colspan=2>--show-managed-fields</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If true, keep the managedFields when printing objects in JSON or YAML format.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-872d33f1fbc83cb2f0bf89b4bd545174>1.98 -</h1><p>Upgrade your cluster smoothly to a newer version with this command</p><h3 id=synopsis>Synopsis</h3><p>Upgrade your cluster smoothly to a newer version with this command</p><pre tabindex=0><code>kubeadm upgrade [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for upgrade</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-7d8c1710684742ca940f580674225d9d>1.99 -</h1><p>Upgrade your Kubernetes cluster to the specified version</p><h3 id=synopsis>Synopsis</h3><p>Upgrade your Kubernetes cluster to the specified version</p><pre tabindex=0><code>kubeadm upgrade apply [version]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-experimental-upgrades</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Show unstable versions of Kubernetes as an upgrade alternative and allow upgrading to an alpha/beta/release candidate versions of Kubernetes.</p></td></tr><tr><td colspan=2>--allow-release-candidate-upgrades</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Show release candidate versions of Kubernetes as an upgrade alternative and allow upgrading to a release candidate versions of Kubernetes.</p></td></tr><tr><td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the renewal of certificates used by component changed during upgrades.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Do not change any state, just output what actions would be performed.</p></td></tr><tr><td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the upgrade of etcd.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-f, --force</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Force upgrading although some requirements might not be met. This also implies non-interactive mode.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apply</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--print-config</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specifies whether the configuration file that will be used in the upgrade should be printed or not.</p></td></tr><tr><td colspan=2>-y, --yes</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the upgrade and do not prompt for confirmation (non-interactive mode).</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-28dcf20d89c7bb1c8e7a3873d7703d5d>1.100 -</h1><p>Show what differences would be applied to existing static pod manifests. See also: kubeadm upgrade apply --dry-run</p><h3 id=synopsis>Synopsis</h3><p>Show what differences would be applied to existing static pod manifests. See also: kubeadm upgrade apply --dry-run</p><pre tabindex=0><code>kubeadm upgrade diff [version] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-apiserver.yaml"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>path to API server manifest</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 3</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>How many lines of context in the diff</p></td></tr><tr><td colspan=2>--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>path to controller manifest</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for diff</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-scheduler.yaml"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>path to scheduler manifest</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-f869b6331e40c6f9eb01314f96d3113e>1.101 -</h1><p>Upgrade commands for a node in the cluster</p><h3 id=synopsis>Synopsis</h3><p>Upgrade commands for a node in the cluster</p><p>The "node" command executes the following phases:</p><pre tabindex=0><code>preflight       Run upgrade node pre-flight checks
control-plane   Upgrade the control plane instance deployed on this node, if any
kubelet-config  Upgrade the kubelet configuration for this node
</code></pre><pre tabindex=0><code>kubeadm upgrade node [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the renewal of certificates used by component changed during upgrades.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Do not change any state, just output the actions that would be performed.</p></td></tr><tr><td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the upgrade of etcd.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for node</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>List of phases to be skipped</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-19a94d2f7649959b218952cef00729f4>1.102 -</h1><p>Use this command to invoke single phase of the node workflow</p><h3 id=synopsis>Synopsis</h3><p>Use this command to invoke single phase of the node workflow</p><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for phase</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-b22d3ed181fb7f926ae2081f8fc8c14d>1.103 -</h1><p>Upgrade the control plane instance deployed on this node, if any</p><h3 id=synopsis>Synopsis</h3><p>Upgrade the control plane instance deployed on this node, if any</p><pre tabindex=0><code>kubeadm upgrade node phase control-plane [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the renewal of certificates used by component changed during upgrades.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Do not change any state, just output the actions that would be performed.</p></td></tr><tr><td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the upgrade of etcd.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for control-plane</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-ae1ea74c2c21b25a3c1eacdaf549274b>1.104 -</h1><p>Upgrade the kubelet configuration for this node</p><h3 id=synopsis>Synopsis</h3><p>Download the kubelet configuration from the kubelet-config ConfigMap stored in the cluster</p><pre tabindex=0><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Do not change any state, just output the actions that would be performed.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet-config</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-633020ef232bc34f60c82153578a6c9b>1.105 -</h1><p>Run upgrade node pre-flight checks</p><h3 id=synopsis>Synopsis</h3><p>Run pre-flight checks for kubeadm upgrade node.</p><pre tabindex=0><code>kubeadm upgrade node phase preflight [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for preflight</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e938edeb3d824f9b364de617a1f10a93>1.106 -</h1><p>Check which versions are available to upgrade to and validate whether your current cluster is upgradeable. To skip the internet check, pass in the optional [version] parameter</p><h3 id=synopsis>Synopsis</h3><p>Check which versions are available to upgrade to and validate whether your current cluster is upgradeable. To skip the internet check, pass in the optional [version] parameter</p><pre tabindex=0><code>kubeadm upgrade plan [version] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-experimental-upgrades</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Show unstable versions of Kubernetes as an upgrade alternative and allow upgrading to an alpha/beta/release candidate versions of Kubernetes.</p></td></tr><tr><td colspan=2>--allow-release-candidate-upgrades</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Show release candidate versions of Kubernetes as an upgrade alternative and allow upgrading to a release candidate versions of Kubernetes.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for plan</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>-o, --output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>EXPERIMENTAL: Output format. One of: text|json|yaml.</p></td></tr><tr><td colspan=2>--print-config</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specifies whether the configuration file that will be used in the upgrade should be printed or not.</p></td></tr><tr><td colspan=2>--show-managed-fields</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If true, keep the managedFields when printing objects in JSON or YAML format.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-aa9f718186487df2ab6885cae45f5d37>1.107 -</h1><p>Print the version of kubeadm</p><h3 id=synopsis>Synopsis</h3><p>Print the version of kubeadm</p><pre tabindex=0><code>kubeadm version [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for version</p></td></tr><tr><td colspan=2>-o, --output string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Output format; available options are 'yaml', 'json' and 'short'</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-60d816e74ec8e0301cc484b19d7694e6>1.108 -</h1><p>All files in this directory are auto-generated from other repos. <strong>Do not edit them manually. You must edit them in their upstream repo.</strong></p></div><div class=td-content style=page-break-before:always><h1 id=pg-82b2fcf985bae77dcb754387a9fcc64f>2 - kubeadm init</h1><p>This command initializes a Kubernetes control-plane node.</p><p>Run this command in order to set up the Kubernetes control plane</p><h3 id=synopsis>Synopsis</h3><p>Run this command in order to set up the Kubernetes control plane</p><p>The "init" command executes the following phases:</p><pre tabindex=0><code>preflight                    Run pre-flight checks
certs                        Certificate generation
  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components
  /apiserver                   Generate the certificate for serving the Kubernetes API
  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet
  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy
  /front-proxy-client          Generate the certificate for the front proxy client
  /etcd-ca                     Generate the self-signed CA to provision identities for etcd
  /etcd-server                 Generate the certificate for serving etcd
  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other
  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd
  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd
  /sa                          Generate a private key for signing service account tokens along with its public key
kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file
  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself
  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes
  /controller-manager          Generate a kubeconfig file for the controller manager to use
  /scheduler                   Generate a kubeconfig file for the scheduler to use
kubelet-start                Write kubelet settings and (re)start the kubelet
control-plane                Generate all static Pod manifest files necessary to establish the control plane
  /apiserver                   Generates the kube-apiserver static Pod manifest
  /controller-manager          Generates the kube-controller-manager static Pod manifest
  /scheduler                   Generates the kube-scheduler static Pod manifest
etcd                         Generate static Pod manifest file for local etcd
  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance
upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap
  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet                     Upload the kubelet component config to a ConfigMap
upload-certs                 Upload certificates to kubeadm-certs
mark-control-plane           Mark a node as a control-plane
bootstrap-token              Generates bootstrap tokens used to join a node to a cluster
kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap
  /experimental-cert-rotation  Enable kubelet client certificate rotation
addon                        Install required addons for passing conformance tests
  /coredns                     Install the CoreDNS addon to a Kubernetes cluster
  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster
</code></pre><pre tabindex=0><code>kubeadm init [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--apiserver-cert-extra-sans strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for init</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr><tr><td colspan=2>--skip-certificate-key-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't print the key used to encrypt the control-plane certificates.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>List of phases to be skipped</p></td></tr><tr><td colspan=2>--skip-token-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Skip printing of the default bootstrap token generated by 'kubeadm init'.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The token to use for establishing bidirectional trust between nodes and control-plane nodes. The format is [a-z0-9]{6}.[a-z0-9]{16} - e.g. abcdef.0123456789abcdef</p></td></tr><tr><td colspan=2>--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire</p></td></tr><tr><td colspan=2>--upload-certs</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Upload control-plane certificates to the kubeadm-certs Secret.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h3 id=init-workflow>Init workflow</h3><p><code>kubeadm init</code> bootstraps a Kubernetes control-plane node by executing the
following steps:</p><ol><li><p>Runs a series of pre-flight checks to validate the system state
before making changes. Some checks only trigger warnings, others are
considered errors and will exit kubeadm until the problem is corrected or the
user specifies <code>--ignore-preflight-errors=&lt;list-of-errors></code>.</p></li><li><p>Generates a self-signed CA to set up identities for each component in the cluster. The user can provide their
own CA cert and/or key by dropping it in the cert directory configured via <code>--cert-dir</code>
(<code>/etc/kubernetes/pki</code> by default).
The APIServer certs will have additional SAN entries for any <code>--apiserver-cert-extra-sans</code>
arguments, lowercased if necessary.</p></li><li><p>Writes kubeconfig files in <code>/etc/kubernetes/</code> for the kubelet, the controller-manager and the
scheduler to use to connect to the API server, each with its own identity, as well as an
additional kubeconfig file for administration named <code>admin.conf</code>.</p></li><li><p>Generates static Pod manifests for the API server,
controller-manager and scheduler. In case an external etcd is not provided,
an additional static Pod manifest is generated for etcd.</p><p>Static Pod manifests are written to <code>/etc/kubernetes/manifests</code>; the kubelet
watches this directory for Pods to create on startup.</p><p>Once control plane Pods are up and running, the <code>kubeadm init</code> sequence can continue.</p></li><li><p>Apply labels and taints to the control-plane node so that no additional workloads will
run there.</p></li><li><p>Generates the token that additional nodes can use to register
themselves with a control-plane in the future. Optionally, the user can provide a
token via <code>--token</code>, as described in the
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token</a> docs.</p></li><li><p>Makes all the necessary configurations for allowing node joining with the
<a href=/docs/reference/access-authn-authz/bootstrap-tokens/>Bootstrap Tokens</a> and
<a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>TLS Bootstrap</a>
mechanism:</p><ul><li><p>Write a ConfigMap for making available all the information required
for joining, and set up related RBAC access rules.</p></li><li><p>Let Bootstrap Tokens access the CSR signing API.</p></li><li><p>Configure auto-approval for new CSR requests.</p></li></ul><p>See <a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> for additional info.</p></li><li><p>Installs a DNS server (CoreDNS) and the kube-proxy addon components via the API server.
In Kubernetes version 1.11 and later CoreDNS is the default DNS server.
Please note that although the DNS server is deployed, it will not be scheduled until CNI is installed.</p><div class="alert alert-danger warning callout" role=alert><strong>Warning:</strong> kube-dns usage with kubeadm is deprecated as of v1.18 and is removed in v1.21.</div></li></ol><h3 id=init-phases>Using init phases with kubeadm</h3><p>Kubeadm allows you to create a control-plane node in phases using the <code>kubeadm init phase</code> command.</p><p>To view the ordered list of phases and sub-phases you can call <code>kubeadm init --help</code>. The list
will be located at the top of the help screen and each phase will have a description next to it.
Note that by calling <code>kubeadm init</code> all of the phases and sub-phases will be executed in this exact order.</p><p>Some phases have unique flags, so if you want to have a look at the list of available options add
<code>--help</code>, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm init phase control-plane controller-manager --help
</span></span></code></pre></div><p>You can also use <code>--help</code> to see the list of sub-phases for a certain parent phase:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm init phase control-plane --help
</span></span></code></pre></div><p><code>kubeadm init</code> also exposes a flag called <code>--skip-phases</code> that can be used to skip certain phases.
The flag accepts a list of phase names and the names can be taken from the above ordered list.</p><p>An example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm init phase control-plane all --config<span style=color:#666>=</span>configfile.yaml
</span></span><span style=display:flex><span>sudo kubeadm init phase etcd <span style=color:#a2f>local</span> --config<span style=color:#666>=</span>configfile.yaml
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># you can now modify the control plane and etcd manifest files</span>
</span></span><span style=display:flex><span>sudo kubeadm init --skip-phases<span style=color:#666>=</span>control-plane,etcd --config<span style=color:#666>=</span>configfile.yaml
</span></span></code></pre></div><p>What this example would do is write the manifest files for the control plane and etcd in
<code>/etc/kubernetes/manifests</code> based on the configuration in <code>configfile.yaml</code>. This allows you to
modify the files and then skip these phases using <code>--skip-phases</code>. By calling the last command you
will create a control plane node with the custom manifest files.</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code></div><p>Alternatively, you can use the <code>skipPhases</code> field under <code>InitConfiguration</code>.</p><h3 id=config-file>Using kubeadm init with a configuration file</h3><div class="alert alert-warning caution callout" role=alert><strong>Caution:</strong> The config file is still considered beta and may change in future versions.</div><p>It's possible to configure <code>kubeadm init</code> with a configuration file instead of command
line flags, and some more advanced features may only be available as
configuration file options. This file is passed using the <code>--config</code> flag and it must
contain a <code>ClusterConfiguration</code> structure and optionally more structures separated by <code>---\n</code>
Mixing <code>--config</code> with others flags may not be allowed in some cases.</p><p>The default configuration can be printed out using the
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config print</a> command.</p><p>If your configuration is not using the latest version it is <strong>recommended</strong> that you migrate using
the <a href=/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config migrate</a> command.</p><p>For more information on the fields and usage of the configuration you can navigate to our
<a href=/docs/reference/config-api/kubeadm-config.v1beta3/>API reference page</a>.</p><h3 id=feature-gates>Using kubeadm init with feature gates</h3><p>Kubeadm supports a set of feature gates that are unique to kubeadm and can only be applied
during cluster creation with <code>kubeadm init</code>. These features can control the behavior
of the cluster. Feature gates are removed after a feature graduates to GA.</p><p>To pass a feature gate you can either use the <code>--feature-gates</code> flag for
<code>kubeadm init</code>, or you can add items into the <code>featureGates</code> field when you pass
a <a href=/docs/reference/config-api/kubeadm-config.v1beta3/#kubeadm-k8s-io-v1beta3-ClusterConfiguration>configuration file</a>
using <code>--config</code>.</p><p>Passing <a href=/docs/reference/command-line-tools-reference/feature-gates>feature gates for core Kubernetes components</a>
directly to kubeadm is not supported. Instead, it is possible to pass them by
<a href=/docs/setup/production-environment/tools/kubeadm/control-plane-flags/>Customizing components with the kubeadm API</a>.</p><p>List of feature gates:</p><table><caption style=display:none>kubeadm feature gates</caption><thead><tr><th style=text-align:left>Feature</th><th style=text-align:left>Default</th><th style=text-align:left>Alpha</th><th style=text-align:left>Beta</th><th style=text-align:left>GA</th></tr></thead><tbody><tr><td style=text-align:left><code>PublicKeysECDSA</code></td><td style=text-align:left><code>false</code></td><td style=text-align:left>1.19</td><td style=text-align:left>-</td><td style=text-align:left>-</td></tr><tr><td style=text-align:left><code>RootlessControlPlane</code></td><td style=text-align:left><code>false</code></td><td style=text-align:left>1.22</td><td style=text-align:left>-</td><td style=text-align:left>-</td></tr><tr><td style=text-align:left><code>UnversionedKubeletConfigMap</code></td><td style=text-align:left><code>true</code></td><td style=text-align:left>1.22</td><td style=text-align:left>1.23</td><td style=text-align:left>1.25</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Once a feature gate goes GA its value becomes locked to <code>true</code> by default.</div><p>Feature gate descriptions:</p><dl><dt><code>PublicKeysECDSA</code></dt><dd>Can be used to create a cluster that uses ECDSA certificates instead of the default RSA algorithm.
Renewal of existing ECDSA certificates is also supported using <code>kubeadm certs renew</code>, but you cannot
switch between the RSA and ECDSA algorithms on the fly or during upgrades.</dd><dt><code>RootlessControlPlane</code></dt><dd>Setting this flag configures the kubeadm deployed control plane component static Pod containers
for <code>kube-apiserver</code>, <code>kube-controller-manager</code>, <code>kube-scheduler</code> and <code>etcd</code> to run as non-root users.
If the flag is not set, those components run as root. You can change the value of this feature gate before
you upgrade to a newer version of Kubernetes.</dd><dt><code>UnversionedKubeletConfigMap</code></dt><dd>This flag controls the name of the <a class=glossary-tooltip title='An API object used to store non-confidential data in key-value pairs. Can be consumed as environment variables, command-line arguments, or configuration files in a volume.' data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a> where kubeadm stores
kubelet configuration data. With this flag not specified or set to <code>true</code>, the ConfigMap is named <code>kubelet-config</code>.
If you set this flag to <code>false</code>, the name of the ConfigMap includes the major and minor version for Kubernetes
(for example: <code>kubelet-config-1.25</code>). Kubeadm ensures that RBAC rules for reading and writing
that ConfigMap are appropriate for the value you set. When kubeadm writes this ConfigMap (during <code>kubeadm init</code>
or <code>kubeadm upgrade apply</code>), kubeadm respects the value of <code>UnversionedKubeletConfigMap</code>. When reading that ConfigMap
(during <code>kubeadm join</code>, <code>kubeadm reset</code>, <code>kubeadm upgrade ...</code>), kubeadm attempts to use unversioned ConfigMap name first;
if that does not succeed, kubeadm falls back to using the legacy (versioned) name for that ConfigMap.</dd></dl><h3 id=kube-proxy>Adding kube-proxy parameters</h3><p>For information about kube-proxy parameters in the kubeadm configuration see:</p><ul><li><a href=/docs/reference/config-api/kube-proxy-config.v1alpha1/>kube-proxy reference</a></li></ul><p>For information about enabling IPVS mode with kubeadm see:</p><ul><li><a href=https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/ipvs/README.md>IPVS</a></li></ul><h3 id=control-plane-flags>Passing custom flags to control plane components</h3><p>For information about passing flags to control plane components see:</p><ul><li><a href=/docs/setup/production-environment/tools/kubeadm/control-plane-flags/>control-plane-flags</a></li></ul><h3 id=without-internet-connection>Running kubeadm without an Internet connection</h3><p>For running kubeadm without an Internet connection you have to pre-pull the required control-plane images.</p><p>You can list and pull the images using the <code>kubeadm config images</code> sub-command:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm config images list
</span></span><span style=display:flex><span>kubeadm config images pull
</span></span></code></pre></div><p>You can pass <code>--config</code> to the above commands with a <a href=#config-file>kubeadm configuration file</a>
to control the <code>kubernetesVersion</code> and <code>imageRepository</code> fields.</p><p>All default <code>registry.k8s.io</code> images that kubeadm requires support multiple architectures.</p><h3 id=custom-images>Using custom images</h3><p>By default, kubeadm pulls images from <code>registry.k8s.io</code>. If the
requested Kubernetes version is a CI label (such as <code>ci/latest</code>)
<code>gcr.io/k8s-staging-ci-images</code> is used.</p><p>You can override this behavior by using <a href=#config-file>kubeadm with a configuration file</a>.
Allowed customization are:</p><ul><li>To provide <code>kubernetesVersion</code> which affects the version of the images.</li><li>To provide an alternative <code>imageRepository</code> to be used instead of
<code>registry.k8s.io</code>.</li><li>To provide a specific <code>imageRepository</code> and <code>imageTag</code> for etcd or CoreDNS.</li></ul><p>Image paths between the default <code>registry.k8s.io</code> and a custom repository specified using
<code>imageRepository</code> may differ for backwards compatibility reasons. For example,
one image might have a subpath at <code>registry.k8s.io/subpath/image</code>, but be defaulted
to <code>my.customrepository.io/image</code> when using a custom repository.</p><p>To ensure you push the images to your custom repository in paths that kubeadm
can consume, you must:</p><ul><li>Pull images from the defaults paths at <code>registry.k8s.io</code> using <code>kubeadm config images {list|pull}</code>.</li><li>Push images to the paths from <code>kubeadm config images list --config=config.yaml</code>,
where <code>config.yaml</code> contains the custom <code>imageRepository</code>, and/or <code>imageTag</code>
for etcd and CoreDNS.</li><li>Pass the same <code>config.yaml</code> to <code>kubeadm init</code>.</li></ul><h4 id=custom-pause-image>Custom sandbox (pause) images</h4><p>To set a custom image for these you need to configure this in your
<a class=glossary-tooltip title='The container runtime is the software that is responsible for running containers.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a>
to use the image.
Consult the documentation for your container runtime to find out how to change this setting;
for selected container runtimes, you can also find advice within the
<a href=/docs/setup/production-environment/container-runtimes/>Container Runtimes</a> topic.</p><h3 id=uploading-control-plane-certificates-to-the-cluster>Uploading control-plane certificates to the cluster</h3><p>By adding the flag <code>--upload-certs</code> to <code>kubeadm init</code> you can temporary upload
the control-plane certificates to a Secret in the cluster. Please note that this Secret
will expire automatically after 2 hours. The certificates are encrypted using
a 32byte key that can be specified using <code>--certificate-key</code>. The same key can be used
to download the certificates when additional control-plane nodes are joining, by passing
<code>--control-plane</code> and <code>--certificate-key</code> to <code>kubeadm join</code>.</p><p>The following phase command can be used to re-upload the certificates after expiration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm init phase upload-certs --upload-certs --certificate-key<span style=color:#666>=</span>SOME_VALUE --config<span style=color:#666>=</span>SOME_YAML_FILE
</span></span></code></pre></div><p>If the flag <code>--certificate-key</code> is not passed to <code>kubeadm init</code> and
<code>kubeadm init phase upload-certs</code> a new key will be generated automatically.</p><p>The following command can be used to generate a new key on demand:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm certs certificate-key
</span></span></code></pre></div><h3 id=certificate-management-with-kubeadm>Certificate management with kubeadm</h3><p>For detailed information on certificate management with kubeadm see
<a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/>Certificate Management with kubeadm</a>.
The document includes information about using external CA, custom certificates
and certificate renewal.</p><h3 id=kubelet-drop-in>Managing the kubeadm drop-in file for the kubelet</h3><p>The <code>kubeadm</code> package ships with a configuration file for running the <code>kubelet</code> by <code>systemd</code>.
Note that the kubeadm CLI never touches this drop-in file. This drop-in file is part of the kubeadm
DEB/RPM package.</p><p>For further information, see
<a href=/docs/setup/production-environment/tools/kubeadm/kubelet-integration/#the-kubelet-drop-in-file-for-systemd>Managing the kubeadm drop-in file for systemd</a>.</p><h3 id=use-kubeadm-with-cri-runtimes>Use kubeadm with CRI runtimes</h3><p>By default kubeadm attempts to detect your container runtime. For more details on this detection,
see the <a href=/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-runtime>kubeadm CRI installation guide</a>.</p><h3 id=setting-the-node-name>Setting the node name</h3><p>By default, <code>kubeadm</code> assigns a node name based on a machine's host address.
You can override this setting with the <code>--node-name</code> flag.
The flag passes the appropriate <a href=/docs/reference/command-line-tools-reference/kubelet/#options><code>--hostname-override</code></a>
value to the kubelet.</p><p>Be aware that overriding the hostname can
<a href=https://github.com/kubernetes/website/pull/8873>interfere with cloud providers</a>.</p><h3 id=automating-kubeadm>Automating kubeadm</h3><p>Rather than copying the token you obtained from <code>kubeadm init</code> to each node, as
in the <a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>basic kubeadm tutorial</a>,
you can parallelize the token distribution for easier automation. To implement this automation,
you must know the IP address that the control-plane node will have after it is started, or use a
DNS name or an address of a load balancer.</p><ol><li><p>Generate a token. This token must have the form <code>&lt;6 character string>.&lt;16 character string></code>. More formally, it must match the regex:
<code>[a-z0-9]{6}\.[a-z0-9]{16}</code>.</p><p>kubeadm can generate a token for you:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> kubeadm token generate
</span></span></code></pre></div></li><li><p>Start both the control-plane node and the worker nodes concurrently with this token.
As they come up they should find each other and form the cluster. The same
<code>--token</code> argument can be used on both <code>kubeadm init</code> and <code>kubeadm join</code>.</p></li><li><p>Similar can be done for <code>--certificate-key</code> when joining additional control-plane
nodes. The key can be generated using:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm certs certificate-key
</span></span></code></pre></div></li></ol><p>Once the cluster is up, you can grab the admin credentials from the control-plane node
at <code>/etc/kubernetes/admin.conf</code> and use that to talk to the cluster.</p><p>Note that this style of bootstrap has some relaxed security guarantees because
it does not allow the root CA hash to be validated with
<code>--discovery-token-ca-cert-hash</code> (since it's not generated when the nodes are
provisioned). For details, see the <a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>.</p><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/>kubeadm init phase</a> to understand more about
<code>kubeadm init</code> phases</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> to bootstrap a Kubernetes
worker node and join it to the cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/>kubeadm upgrade</a> to upgrade a Kubernetes
cluster to a newer version</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a> to revert any changes made
to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2a2b5f34806b4b1bd2c12682ac170d68>3 - kubeadm join</h1><p>This command initializes a Kubernetes worker node and joins it to the cluster.</p><p>Run this on any machine you wish to join an existing cluster</p><h3 id=synopsis>Synopsis</h3><p>When joining a kubeadm initialized cluster, we need to establish
bidirectional trust. This is split into discovery (having the Node
trust the Kubernetes Control Plane) and TLS bootstrap (having the
Kubernetes Control Plane trust the Node).</p><p>There are 2 main schemes for discovery. The first is to use a shared
token along with the IP address of the API server. The second is to
provide a file - a subset of the standard kubeconfig file. The
discovery/kubeconfig file supports token, client-go authentication
plugins ("exec"), "tokenFile", and "authProvider". This file can be a
local file or downloaded via an HTTPS URL. The forms are
kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443,
kubeadm join --discovery-file path/to/file.conf, or kubeadm join
--discovery-file https://url/file.conf. Only one form can be used. If
the discovery information is loaded from a URL, HTTPS must be used.
Also, in that case the host installed CA bundle is used to verify
the connection.</p><p>If you use a shared token for discovery, you should also pass the
--discovery-token-ca-cert-hash flag to validate the public key of the
root certificate authority (CA) presented by the Kubernetes Control Plane.
The value of this flag is specified as "&lt;hash-type>:&lt;hex-encoded-value>",
where the supported hash type is "sha256". The hash is calculated over
the bytes of the Subject Public Key Info (SPKI) object (as in RFC7469).
This value is available in the output of "kubeadm init" or can be
calculated using standard tools. The --discovery-token-ca-cert-hash flag
may be repeated multiple times to allow more than one public key.</p><p>If you cannot know the CA public key hash ahead of time, you can pass
the --discovery-token-unsafe-skip-ca-verification flag to disable this
verification. This weakens the kubeadm security model since other nodes
can potentially impersonate the Kubernetes Control Plane.</p><p>The TLS bootstrap mechanism is also driven via a shared token. This is
used to temporarily authenticate with the Kubernetes Control Plane to submit a
certificate signing request (CSR) for a locally created key pair. By
default, kubeadm will set up the Kubernetes Control Plane to automatically
approve these signing requests. This token is passed in with the
--tls-bootstrap-token abcdef.1234567890abcdef flag.</p><p>Often times the same token is used for both parts. In this case, the
--token flag can be used instead of specifying each token individually.</p><p>The "join [api-server-endpoint]" command executes the following phases:</p><pre tabindex=0><code>preflight              Run join pre-flight checks
control-plane-prepare  Prepare the machine for serving a control plane
  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
  /certs                 Generate the certificates for the new control plane components
  /kubeconfig            Generate the kubeconfig for the new control plane components
  /control-plane         Generate the manifests for the new control plane components
kubelet-start          Write kubelet settings, certificates and (re)start the kubelet
control-plane-join     Join a machine as a control plane instance
  /etcd                  Add a new local etcd member
  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap (DEPRECATED)
  /mark-control-plane    Mark a node as a control-plane
</code></pre><pre tabindex=0><code>kubeadm join [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this key to decrypt the certificate secrets uploaded by init.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for join</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>List of phases to be skipped</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h3 id=join-workflow>The join workflow</h3><p><code>kubeadm join</code> bootstraps a Kubernetes worker node or a control-plane node and adds it to the cluster.
This action consists of the following steps for worker nodes:</p><ol><li><p>kubeadm downloads necessary cluster information from the API server.
By default, it uses the bootstrap token and the CA key hash to verify the
authenticity of that data. The root CA can also be discovered directly via a
file or URL.</p></li><li><p>Once the cluster information is known, kubelet can start the TLS bootstrapping
process.</p><p>The TLS bootstrap uses the shared token to temporarily authenticate
with the Kubernetes API server to submit a certificate signing request (CSR); by
default the control plane signs this CSR request automatically.</p></li><li><p>Finally, kubeadm configures the local kubelet to connect to the API
server with the definitive identity assigned to the node.</p></li></ol><p>For control-plane nodes additional steps are performed:</p><ol><li><p>Downloading certificates shared among control-plane nodes from the cluster
(if explicitly requested by the user).</p></li><li><p>Generating control-plane component manifests, certificates and kubeconfig.</p></li><li><p>Adding new local etcd member.</p></li></ol><h3 id=join-phases>Using join phases with kubeadm</h3><p>Kubeadm allows you join a node to the cluster in phases using <code>kubeadm join phase</code>.</p><p>To view the ordered list of phases and sub-phases you can call <code>kubeadm join --help</code>. The list will be located
at the top of the help screen and each phase will have a description next to it.
Note that by calling <code>kubeadm join</code> all of the phases and sub-phases will be executed in this exact order.</p><p>Some phases have unique flags, so if you want to have a look at the list of available options add <code>--help</code>, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm join phase kubelet-start --help
</span></span></code></pre></div><p>Similar to the <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-phases>kubeadm init phase</a>
command, <code>kubeadm join phase</code> allows you to skip a list of phases using the <code>--skip-phases</code> flag.</p><p>For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm join --skip-phases<span style=color:#666>=</span>preflight --config<span style=color:#666>=</span>config.yaml
</span></span></code></pre></div><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code></div><p>Alternatively, you can use the <code>skipPhases</code> field in <code>JoinConfiguration</code>.</p><h3 id=discovering-what-cluster-ca-to-trust>Discovering what cluster CA to trust</h3><p>The kubeadm discovery has several options, each with security tradeoffs.
The right method for your environment depends on how you provision nodes and the
security expectations you have about your network and node lifecycles.</p><h4 id=token-based-discovery-with-ca-pinning>Token-based discovery with CA pinning</h4><p>This is the default mode in kubeadm. In this mode, kubeadm downloads
the cluster configuration (including root CA) and validates it using the token
as well as validating that the root CA public key matches the provided hash and
that the API server certificate is valid under the root CA.</p><p>The CA key hash has the format <code>sha256:&lt;hex_encoded_hash></code>. By default, the hash value is returned in the <code>kubeadm join</code> command printed at the end of <code>kubeadm init</code> or in the output of <code>kubeadm token create --print-join-command</code>. It is in a standard format (see <a href=https://tools.ietf.org/html/rfc7469#section-2.4>RFC7469</a>) and can also be calculated by 3rd party tools or provisioning systems. For example, using the OpenSSL CLI:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span style=color:#b44>&#39;s/^.* //&#39;</span>
</span></span></code></pre></div><p><strong>Example <code>kubeadm join</code> commands:</strong></p><p>For worker nodes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef 1.2.3.4:6443
</span></span></code></pre></div><p>For control-plane nodes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef --control-plane 1.2.3.4:6443
</span></span></code></pre></div><p>You can also call <code>join</code> for a control-plane node with <code>--certificate-key</code> to copy certificates to this node,
if the <code>kubeadm init</code> command was called with <code>--upload-certs</code>.</p><p><strong>Advantages:</strong></p><ul><li><p>Allows bootstrapping nodes to securely discover a root of trust for the
control-plane node even if other worker nodes or the network are compromised.</p></li><li><p>Convenient to execute manually since all of the information required fits
into a single <code>kubeadm join</code> command.</p></li></ul><p><strong>Disadvantages:</strong></p><ul><li>The CA hash is not normally known until the control-plane node has been provisioned,
which can make it more difficult to build automated provisioning tools that
use kubeadm. By generating your CA in beforehand, you may workaround this
limitation.</li></ul><h4 id=token-based-discovery-without-ca-pinning>Token-based discovery without CA pinning</h4><p>This mode relies only on the symmetric token to sign
(HMAC-SHA256) the discovery information that establishes the root of trust for
the control-plane. To use the mode the joining nodes must skip the hash validation of the
CA public key, using <code>--discovery-token-unsafe-skip-ca-verification</code>. You should consider
using one of the other modes if possible.</p><p><strong>Example <code>kubeadm join</code> command:</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm join --token abcdef.1234567890abcdef --discovery-token-unsafe-skip-ca-verification 1.2.3.4:6443
</span></span></code></pre></div><p><strong>Advantages:</strong></p><ul><li><p>Still protects against many network-level attacks.</p></li><li><p>The token can be generated ahead of time and shared with the control-plane node and
worker nodes, which can then bootstrap in parallel without coordination. This
allows it to be used in many provisioning scenarios.</p></li></ul><p><strong>Disadvantages:</strong></p><ul><li>If an attacker is able to steal a bootstrap token via some vulnerability,
they can use that token (along with network-level access) to impersonate the
control-plane node to other bootstrapping nodes. This may or may not be an appropriate
tradeoff in your environment.</li></ul><h4 id=file-or-https-based-discovery>File or HTTPS-based discovery</h4><p>This provides an out-of-band way to establish a root of trust between the control-plane node
and bootstrapping nodes. Consider using this mode if you are building automated provisioning
using kubeadm. The format of the discovery file is a regular Kubernetes
<a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a> file.</p><p>In case the discovery file does not contain credentials, the TLS discovery token will be used.</p><p><strong>Example <code>kubeadm join</code> commands:</strong></p><ul><li><p><code>kubeadm join --discovery-file path/to/file.conf</code> (local file)</p></li><li><p><code>kubeadm join --discovery-file https://url/file.conf</code> (remote HTTPS URL)</p></li></ul><p><strong>Advantages:</strong></p><ul><li>Allows bootstrapping nodes to securely discover a root of trust for the
control-plane node even if the network or other worker nodes are compromised.</li></ul><p><strong>Disadvantages:</strong></p><ul><li>Requires that you have some way to carry the discovery information from
the control-plane node to the bootstrapping nodes. If the discovery file contains credentials
you must keep it secret and transfer it over a secure channel. This might be possible with your
cloud provider or provisioning tool.</li></ul><h3 id=securing-more>Securing your installation even more</h3><p>The defaults for kubeadm may not work for everyone. This section documents how to tighten up a kubeadm installation
at the cost of some usability.</p><h4 id=turning-off-auto-approval-of-node-client-certificates>Turning off auto-approval of node client certificates</h4><p>By default, there is a CSR auto-approver enabled that basically approves any client certificate request
for a kubelet when a Bootstrap Token was used when authenticating. If you don't want the cluster to
automatically approve kubelet client certs, you can turn it off by executing this command:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete clusterrolebinding kubeadm:node-autoapprove-bootstrap
</span></span></code></pre></div><p>After that, <code>kubeadm join</code> will block until the admin has manually approved the CSR in flight:</p><ol><li><p>Using <code>kubectl get csr</code>, you can see that the original CSR is in the Pending state.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex=0><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   18s       system:bootstrap:878f07   Pending
</code></pre></li><li><p><code>kubectl certificate approve</code> allows the admin to approve CSR.This action tells a certificate signing
controller to issue a certificate to the requestor with the attributes requested in the CSR.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl certificate approve node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex=0><code>certificatesigningrequest &#34;node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ&#34; approved
</code></pre></li><li><p>This would change the CRS resource to Active state.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex=0><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   1m        system:bootstrap:878f07   Approved,Issued
</code></pre></li></ol><p>This forces the workflow that <code>kubeadm join</code> will only succeed if <code>kubectl certificate approve</code> has been run.</p><h4 id=turning-off-public-access-to-the-cluster-info-configmap>Turning off public access to the <code>cluster-info</code> ConfigMap</h4><p>In order to achieve the joining flow using the token as the only piece of validation information, a
ConfigMap with some data needed for validation of the control-plane node's identity is exposed publicly by
default. While there is no private data in this ConfigMap, some users might wish to turn
it off regardless. Doing so will disable the ability to use the <code>--discovery-token</code> flag of the
<code>kubeadm join</code> flow. Here are the steps to do so:</p><ul><li>Fetch the <code>cluster-info</code> file from the API Server:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n kube-public get cm cluster-info -o yaml | grep <span style=color:#b44>&#34;kubeconfig:&#34;</span> -A11 | grep <span style=color:#b44>&#34;apiVersion&#34;</span> -A10 | sed <span style=color:#b44>&#34;s/    //&#34;</span> | tee cluster-info.yaml
</span></span></code></pre></div><p>The output is similar to this:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority-data</span>:<span style=color:#bbb> </span>&lt;ca-cert&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://&lt;ip&gt;:&lt;port&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><p>Use the <code>cluster-info.yaml</code> file as an argument to <code>kubeadm join --discovery-file</code>.</p></li><li><p>Turn off public access to the <code>cluster-info</code> ConfigMap:</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n kube-public delete rolebinding kubeadm:bootstrap-signer-clusterinfo
</span></span></code></pre></div><p>These commands should be run after <code>kubeadm init</code> but before <code>kubeadm join</code>.</p><h3 id=config-file>Using kubeadm join with a configuration file</h3><div class="alert alert-warning caution callout" role=alert><strong>Caution:</strong> The config file is still considered beta and may change in future versions.</div><p>It's possible to configure <code>kubeadm join</code> with a configuration file instead of command
line flags, and some more advanced features may only be available as
configuration file options. This file is passed using the <code>--config</code> flag and it must
contain a <code>JoinConfiguration</code> structure. Mixing <code>--config</code> with others flags may not be
allowed in some cases.</p><p>The default configuration can be printed out using the
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-config/#cmd-config-print>kubeadm config print</a> command.</p><p>If your configuration is not using the latest version it is <strong>recommended</strong> that you migrate using
the <a href=/docs/reference/setup-tools/kubeadm/kubeadm-config/#cmd-config-migrate>kubeadm config migrate</a> command.</p><p>For more information on the fields and usage of the configuration you can navigate to our
<a href=/docs/reference/config-api/kubeadm-config.v1beta3/>API reference</a>.</p><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> to bootstrap a Kubernetes control-plane node.</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token</a> to manage tokens for <code>kubeadm join</code>.</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2c20539d9fabf5982e2dd931742714bd>4 - kubeadm upgrade</h1><p><code>kubeadm upgrade</code> is a user-friendly command that wraps complex upgrading logic
behind one command, with support for both planning an upgrade and actually performing it.</p><h2 id=kubeadm-upgrade-guidance>kubeadm upgrade guidance</h2><p>The steps for performing an upgrade using kubeadm are outlined in <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>this document</a>.
For older versions of kubeadm, please refer to older documentation sets of the Kubernetes website.</p><p>You can use <code>kubeadm upgrade diff</code> to see the changes that would be applied to static pod manifests.</p><p>In Kubernetes v1.15.0 and later, <code>kubeadm upgrade apply</code> and <code>kubeadm upgrade node</code> will also
automatically renew the kubeadm managed certificates on this node, including those stored in kubeconfig files.
To opt-out, it is possible to pass the flag <code>--certificate-renewal=false</code>. For more details about certificate
renewal see the <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs>certificate management documentation</a>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> The commands <code>kubeadm upgrade apply</code> and <code>kubeadm upgrade plan</code> have a legacy <code>--config</code>
flag which makes it possible to reconfigure the cluster, while performing planning or upgrade of that particular
control-plane node. Please be aware that the upgrade workflow was not designed for this scenario and there are
reports of unexpected results.</div><h2 id=cmd-upgrade-plan>kubeadm upgrade plan</h2><p>Check which versions are available to upgrade to and validate whether your current cluster is upgradeable. To skip the internet check, pass in the optional [version] parameter</p><h3 id=synopsis>Synopsis</h3><p>Check which versions are available to upgrade to and validate whether your current cluster is upgradeable. To skip the internet check, pass in the optional [version] parameter</p><pre tabindex=0><code>kubeadm upgrade plan [version] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-experimental-upgrades</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Show unstable versions of Kubernetes as an upgrade alternative and allow upgrading to an alpha/beta/release candidate versions of Kubernetes.</p></td></tr><tr><td colspan=2>--allow-release-candidate-upgrades</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Show release candidate versions of Kubernetes as an upgrade alternative and allow upgrading to a release candidate versions of Kubernetes.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for plan</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>-o, --output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>EXPERIMENTAL: Output format. One of: text|json|yaml.</p></td></tr><tr><td colspan=2>--print-config</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specifies whether the configuration file that will be used in the upgrade should be printed or not.</p></td></tr><tr><td colspan=2>--show-managed-fields</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If true, keep the managedFields when printing objects in JSON or YAML format.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=cmd-upgrade-apply>kubeadm upgrade apply</h2><p>Upgrade your Kubernetes cluster to the specified version</p><h3 id=synopsis>Synopsis</h3><p>Upgrade your Kubernetes cluster to the specified version</p><pre tabindex=0><code>kubeadm upgrade apply [version]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-experimental-upgrades</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Show unstable versions of Kubernetes as an upgrade alternative and allow upgrading to an alpha/beta/release candidate versions of Kubernetes.</p></td></tr><tr><td colspan=2>--allow-release-candidate-upgrades</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Show release candidate versions of Kubernetes as an upgrade alternative and allow upgrading to a release candidate versions of Kubernetes.</p></td></tr><tr><td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the renewal of certificates used by component changed during upgrades.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Do not change any state, just output what actions would be performed.</p></td></tr><tr><td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the upgrade of etcd.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-f, --force</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Force upgrading although some requirements might not be met. This also implies non-interactive mode.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apply</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--print-config</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specifies whether the configuration file that will be used in the upgrade should be printed or not.</p></td></tr><tr><td colspan=2>-y, --yes</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the upgrade and do not prompt for confirmation (non-interactive mode).</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=cmd-upgrade-diff>kubeadm upgrade diff</h2><p>Show what differences would be applied to existing static pod manifests. See also: kubeadm upgrade apply --dry-run</p><h3 id=synopsis>Synopsis</h3><p>Show what differences would be applied to existing static pod manifests. See also: kubeadm upgrade apply --dry-run</p><pre tabindex=0><code>kubeadm upgrade diff [version] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-apiserver.yaml"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>path to API server manifest</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 3</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>How many lines of context in the diff</p></td></tr><tr><td colspan=2>--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>path to controller manifest</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for diff</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-scheduler.yaml"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>path to scheduler manifest</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=cmd-upgrade-node>kubeadm upgrade node</h2><p>Upgrade commands for a node in the cluster</p><h3 id=synopsis>Synopsis</h3><p>Upgrade commands for a node in the cluster</p><p>The "node" command executes the following phases:</p><pre tabindex=0><code>preflight       Run upgrade node pre-flight checks
control-plane   Upgrade the control plane instance deployed on this node, if any
kubelet-config  Upgrade the kubelet configuration for this node
</code></pre><pre tabindex=0><code>kubeadm upgrade node [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the renewal of certificates used by component changed during upgrades.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Do not change any state, just output the actions that would be performed.</p></td></tr><tr><td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the upgrade of etcd.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for node</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>List of phases to be skipped</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config</a> if you initialized your cluster using kubeadm v1.7.x or lower, to configure your cluster for <code>kubeadm upgrade</code></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5042dc49c5348b3674d3878f37f7670b>5 - kubeadm config</h1><p>During <code>kubeadm init</code>, kubeadm uploads the <code>ClusterConfiguration</code> object to your cluster
in a ConfigMap called <code>kubeadm-config</code> in the <code>kube-system</code> namespace. This configuration is then read during
<code>kubeadm join</code>, <code>kubeadm reset</code> and <code>kubeadm upgrade</code>.</p><p>You can use <code>kubeadm config print</code> to print the default static configuration that kubeadm
uses for <code>kubeadm init</code> and <code>kubeadm join</code>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> The output of the command is meant to serve as an example. You must manually edit the output
of this command to adapt to your setup. Remove the fields that you are not certain about and kubeadm
will try to default them on runtime by examining the host.</div><p>For more information on <code>init</code> and <code>join</code> navigate to
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file>Using kubeadm init with a configuration file</a>
or <a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/#config-file>Using kubeadm join with a configuration file</a>.</p><p>For more information on using the kubeadm configuration API navigate to
<a href=/docs/setup/production-environment/tools/kubeadm/control-plane-flags>Customizing components with the kubeadm API</a>.</p><p>You can use <code>kubeadm config migrate</code> to convert your old configuration files that contain a deprecated
API version to a newer, supported API version.</p><p><code>kubeadm config images list</code> and <code>kubeadm config images pull</code> can be used to list and pull the images
that kubeadm requires.</p><h2 id=cmd-config-print>kubeadm config print</h2><p>Print configuration</p><h3 id=synopsis>Synopsis</h3><p>This command prints configurations for subcommands provided.
For details, see: <a href=https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories>https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories</a></p><pre tabindex=0><code>kubeadm config print [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for print</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=cmd-config-print-init-defaults>kubeadm config print init-defaults</h2><p>Print default init configuration, that can be used for 'kubeadm init'</p><h3 id=synopsis>Synopsis</h3><p>This command prints objects such as the default init configuration that is used for 'kubeadm init'.</p><p>Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like "abcdef.0123456789abcdef" in order to pass validation but
not perform the real computation for creating a token.</p><pre tabindex=0><code>kubeadm config print init-defaults [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--component-configs strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for init-defaults</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=cmd-config-print-join-defaults>kubeadm config print join-defaults</h2><p>Print default join configuration, that can be used for 'kubeadm join'</p><h3 id=synopsis>Synopsis</h3><p>This command prints objects such as the default join configuration that is used for 'kubeadm join'.</p><p>Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like "abcdef.0123456789abcdef" in order to pass validation but
not perform the real computation for creating a token.</p><pre tabindex=0><code>kubeadm config print join-defaults [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--component-configs strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for join-defaults</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=cmd-config-migrate>kubeadm config migrate</h2><p>Read an older version of the kubeadm configuration API types from a file, and output the similar config object for the newer version</p><h3 id=synopsis>Synopsis</h3><p>This command lets you convert configuration objects of older versions to the latest supported version,
locally in the CLI tool without ever touching anything in the cluster.
In this version of kubeadm, the following API versions are supported:</p><ul><li>kubeadm.k8s.io/v1beta3</li></ul><p>Further, kubeadm can only write out config of version "kubeadm.k8s.io/v1beta3", but read both types.
So regardless of what version you pass to the --old-config parameter here, the API object will be
read, deserialized, defaulted, converted, validated, and re-serialized when written to stdout or
--new-config if specified.</p><p>In other words, the output of this command is what kubeadm actually would read internally if you
submitted this file to "kubeadm init"</p><pre tabindex=0><code>kubeadm config migrate [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for migrate</p></td></tr><tr><td colspan=2>--new-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the resulting equivalent kubeadm config file using the new API version. Optional, if not specified output will be sent to STDOUT.</p></td></tr><tr><td colspan=2>--old-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the kubeadm config file that is using an old API version and should be converted. This flag is mandatory.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=cmd-config-images-list>kubeadm config images list</h2><p>Print a list of images kubeadm will use. The configuration file is used in case any images or image repositories are customized</p><h3 id=synopsis>Synopsis</h3><p>Print a list of images kubeadm will use. The configuration file is used in case any images or image repositories are customized</p><pre tabindex=0><code>kubeadm config images list [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for list</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--show-managed-fields</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If true, keep the managedFields when printing objects in JSON or YAML format.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=cmd-config-images-pull>kubeadm config images pull</h2><p>Pull images used by kubeadm</p><h3 id=synopsis>Synopsis</h3><p>Pull images used by kubeadm</p><pre tabindex=0><code>kubeadm config images pull [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for pull</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/>kubeadm upgrade</a> to upgrade a Kubernetes cluster to a newer version</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6eb5bc1e7114609930a76c683cc27c2b>6 - kubeadm reset</h1><p>Performs a best effort revert of changes made by <code>kubeadm init</code> or <code>kubeadm join</code>.</p><p>Performs a best effort revert of changes made to this host by 'kubeadm init' or 'kubeadm join'</p><h3 id=synopsis>Synopsis</h3><p>Performs a best effort revert of changes made to this host by 'kubeadm init' or 'kubeadm join'</p><p>The "reset" command executes the following phases:</p><pre tabindex=0><code>preflight           Run reset pre-flight checks
remove-etcd-member  Remove a local etcd member.
cleanup-node        Run cleanup node.
</code></pre><pre tabindex=0><code>kubeadm reset [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path to the directory where the certificates are stored. If specified, clean this directory.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>-f, --force</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Reset the node without prompting for confirmation.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for reset</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>List of phases to be skipped</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h3 id=reset-workflow>Reset workflow</h3><p><code>kubeadm reset</code> is responsible for cleaning up a node local file system from files that were created using
the <code>kubeadm init</code> or <code>kubeadm join</code> commands. For control-plane nodes <code>reset</code> also removes the local stacked
etcd member of this node from the etcd cluster.</p><p><code>kubeadm reset phase</code> can be used to execute the separate phases of the above workflow.
To skip a list of phases you can use the <code>--skip-phases</code> flag, which works in a similar way to
the <code>kubeadm join</code> and <code>kubeadm init</code> phase runners.</p><h3 id=external-etcd-clean-up>External etcd clean up</h3><p><code>kubeadm reset</code> will not delete any etcd data if external etcd is used. This means that if you run <code>kubeadm init</code> again using the same etcd endpoints, you will see state from previous clusters.</p><p>To wipe etcd data it is recommended you use a client like etcdctl, such as:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>etcdctl del <span style=color:#b44>&#34;&#34;</span> --prefix
</span></span></code></pre></div><p>See the <a href=https://github.com/coreos/etcd/tree/master/etcdctl>etcd documentation</a> for more information.</p><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> to bootstrap a Kubernetes worker node and join it to the cluster</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-516f4705fb2f5f62c76c7742772726a3>7 - kubeadm token</h1><p>Bootstrap tokens are used for establishing bidirectional trust between a node joining
the cluster and a control-plane node, as described in <a href=/docs/reference/access-authn-authz/bootstrap-tokens/>authenticating with bootstrap tokens</a>.</p><p><code>kubeadm init</code> creates an initial token with a 24-hour TTL. The following commands allow you to manage
such a token and also to create and manage new ones.</p><h2 id=cmd-token-create>kubeadm token create</h2><p>Create bootstrap tokens on the server</p><h3 id=synopsis>Synopsis</h3><p>This command will create a bootstrap token for you.
You can specify the usages for this token, the "time to live" and an optional human friendly description.</p><p>The [token] is the actual token to write.
This should be a securely generated random token of the form "[a-z0-9]{6}.[a-z0-9]{16}".
If no [token] is given, kubeadm will generate a random token instead.</p><pre tabindex=0><code>kubeadm token create [token]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>When used together with '--print-join-command', print the full 'kubeadm join' flag needed to join the cluster as a control-plane. To create a new certificate key you must use 'kubeadm init phase upload-certs --upload-certs'.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--description string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A human friendly description of how this token is used.</p></td></tr><tr><td colspan=2>--groups strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "system:bootstrappers:kubeadm:default-node-token"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Extra groups that this token will authenticate as when used for authentication. Must match "\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\z"</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for create</p></td></tr><tr><td colspan=2>--print-join-command</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Instead of printing only the token, print the full 'kubeadm join' flag needed to join the cluster using the token.</p></td></tr><tr><td colspan=2>--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire</p></td></tr><tr><td colspan=2>--usages strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "signing,authentication"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Describes the ways in which this token can be used. You can pass --usages multiple times or provide a comma separated list of options. Valid options: [signing,authentication]</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=cmd-token-delete>kubeadm token delete</h2><p>Delete bootstrap tokens on the server</p><h3 id=synopsis>Synopsis</h3><p>This command will delete a list of bootstrap tokens for you.</p><p>The [token-value] is the full Token of the form "[a-z0-9]{6}.[a-z0-9]{16}" or the
Token ID of the form "[a-z0-9]{6}" to delete.</p><pre tabindex=0><code>kubeadm token delete [token-value] ...
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for delete</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=cmd-token-generate>kubeadm token generate</h2><p>Generate and print a bootstrap token, but do not create it on the server</p><h3 id=synopsis>Synopsis</h3><p>This command will print out a randomly-generated bootstrap token that can be used with
the "init" and "join" commands.</p><p>You don't have to use this command in order to generate a token. You can do so
yourself as long as it is in the format "[a-z0-9]{6}.[a-z0-9]{16}". This
command is provided for convenience to generate tokens in the given format.</p><p>You can also use "kubeadm init" without specifying a token and it will
generate and print one for you.</p><pre tabindex=0><code>kubeadm token generate [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for generate</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=cmd-token-list>kubeadm token list</h2><p>List bootstrap tokens on the server</p><h3 id=synopsis>Synopsis</h3><p>This command will list all bootstrap tokens for you.</p><pre tabindex=0><code>kubeadm token list [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.</p></td></tr><tr><td colspan=2>-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for list</p></td></tr><tr><td colspan=2>--show-managed-fields</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If true, keep the managedFields when printing objects in JSON or YAML format.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Whether to enable dry-run mode or not</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> to bootstrap a Kubernetes worker node and join it to the cluster</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-34c4af6f36d969ed08ba840e7fb64c6d>8 - kubeadm version</h1><p>This command prints the version of kubeadm.</p><p>Print the version of kubeadm</p><h3 id=synopsis>Synopsis</h3><p>Print the version of kubeadm</p><pre tabindex=0><code>kubeadm version [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for version</p></td></tr><tr><td colspan=2>-o, --output string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Output format; available options are 'yaml', 'json' and 'short'</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-92a39c69c3689119dd5fa12886cb73a3>9 - kubeadm alpha</h1><div class="alert alert-warning caution callout" role=alert><strong>Caution:</strong> <code>kubeadm alpha</code> provides a preview of a set of features made available for gathering feedback
from the community. Please try it out and give us feedback!</div><p>Currently there are no experimental commands under <code>kubeadm alpha</code>.</p><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> to connect a node to the cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6a1fed09235bbf3644c804339928f10e>10 - kubeadm certs</h1><p><code>kubeadm certs</code> provides utilities for managing certificates.
For more details on how these commands can be used, see
<a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/>Certificate Management with kubeadm</a>.</p><h2 id=cmd-certs>kubeadm certs</h2><p>A collection of operations for operating Kubernetes certificates.</p><ul class="nav nav-tabs" id=tab-certs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-0 role=tab aria-controls=tab-certs-0 aria-selected=true>overview</a></li></ul><div class=tab-content id=tab-certs><div id=tab-certs-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-0><p><p>Commands related to handling kubernetes certificates</p><h3 id=synopsis>Synopsis</h3><p>Commands related to handling kubernetes certificates</p><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for certs</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-certs-renew>kubeadm certs renew</h2><p>You can renew all Kubernetes certificates using the <code>all</code> subcommand or renew them selectively.
For more details see <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#manual-certificate-renewal>Manual certificate renewal</a>.</p><ul class="nav nav-tabs" id=tab-certs-renew role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-renew-0 role=tab aria-controls=tab-certs-renew-0 aria-selected=true>renew</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-1 role=tab aria-controls=tab-certs-renew-1>all</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-2 role=tab aria-controls=tab-certs-renew-2>admin.conf</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-3 role=tab aria-controls=tab-certs-renew-3>apiserver-etcd-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-4 role=tab aria-controls=tab-certs-renew-4>apiserver-kubelet-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-5 role=tab aria-controls=tab-certs-renew-5>apiserver</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-6 role=tab aria-controls=tab-certs-renew-6>controller-manager.conf</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-7 role=tab aria-controls=tab-certs-renew-7>etcd-healthcheck-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-8 role=tab aria-controls=tab-certs-renew-8>etcd-peer</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-9 role=tab aria-controls=tab-certs-renew-9>etcd-server</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-10 role=tab aria-controls=tab-certs-renew-10>front-proxy-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-11 role=tab aria-controls=tab-certs-renew-11>scheduler.conf</a></li></ul><div class=tab-content id=tab-certs-renew><div id=tab-certs-renew-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-renew-0><p><p>Renew certificates for a Kubernetes cluster</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm certs renew [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for renew</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-renew-1 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-1><p><p>Renew all available certificates</p><h3 id=synopsis>Synopsis</h3><p>Renew all known certificates necessary to run the control plane. Renewals are run unconditionally, regardless of expiration date. Renewals can also be run individually for more control.</p><pre tabindex=0><code>kubeadm certs renew all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-renew-2 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-2><p><p>Renew the certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew admin.conf [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for admin.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-renew-3 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-3><p><p>Renew the certificate the apiserver uses to access etcd</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate the apiserver uses to access etcd.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver-etcd-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-renew-4 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-4><p><p>Renew the certificate for the API server to connect to kubelet</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for the API server to connect to kubelet.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver-kubelet-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-renew-5 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-5><p><p>Renew the certificate for serving the Kubernetes API</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for serving the Kubernetes API.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew apiserver [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-renew-6 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-6><p><p>Renew the certificate embedded in the kubeconfig file for the controller manager to use</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate embedded in the kubeconfig file for the controller manager to use.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew controller-manager.conf [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for controller-manager.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-renew-7 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-7><p><p>Renew the certificate for liveness probes to healthcheck etcd</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for liveness probes to healthcheck etcd.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-healthcheck-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-renew-8 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-8><p><p>Renew the certificate for etcd nodes to communicate with each other</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for etcd nodes to communicate with each other.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew etcd-peer [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-peer</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-renew-9 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-9><p><p>Renew the certificate for serving etcd</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for serving etcd.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew etcd-server [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-server</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-renew-10 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-10><p><p>Renew the certificate for the front proxy client</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate for the front proxy client.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew front-proxy-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for front-proxy-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-renew-11 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-11><p><p>Renew the certificate embedded in the kubeconfig file for the scheduler manager to use</p><h3 id=synopsis>Synopsis</h3><p>Renew the certificate embedded in the kubeconfig file for the scheduler manager to use.</p><p>Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.</p><p>Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.</p><p>After renewal, in order to make changes effective, is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.</p><pre tabindex=0><code>kubeadm certs renew scheduler.conf [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for scheduler.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-certs-certificate-key>kubeadm certs certificate-key</h2><p>This command can be used to generate a new control-plane certificate key.
The key can be passed as <code>--certificate-key</code> to <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init><code>kubeadm init</code></a>
and <a href=/docs/reference/setup-tools/kubeadm/kubeadm-join><code>kubeadm join</code></a>
to enable the automatic copy of certificates when joining additional control-plane nodes.</p><ul class="nav nav-tabs" id=tab-certs-certificate-key role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-certificate-key-0 role=tab aria-controls=tab-certs-certificate-key-0 aria-selected=true>certificate-key</a></li></ul><div class=tab-content id=tab-certs-certificate-key><div id=tab-certs-certificate-key-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-certificate-key-0><p><p>Generate certificate keys</p><h3 id=synopsis>Synopsis</h3><p>This command will print out a secure randomly-generated certificate key that can be used with
the "init" command.</p><p>You can also use "kubeadm init --upload-certs" without specifying a certificate key and it will
generate and print one for you.</p><pre tabindex=0><code>kubeadm certs certificate-key [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for certificate-key</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-certs-check-expiration>kubeadm certs check-expiration</h2><p>This command checks expiration for the certificates in the local PKI managed by kubeadm.
For more details see
<a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#check-certificate-expiration>Check certificate expiration</a>.</p><ul class="nav nav-tabs" id=tab-certs-check-expiration role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-check-expiration-0 role=tab aria-controls=tab-certs-check-expiration-0 aria-selected=true>check-expiration</a></li></ul><div class=tab-content id=tab-certs-check-expiration><div id=tab-certs-check-expiration-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-check-expiration-0><p><p>Check certificates expiration for a Kubernetes cluster</p><h3 id=synopsis>Synopsis</h3><p>Checks expiration for the certificates in the local PKI managed by kubeadm.</p><pre tabindex=0><code>kubeadm certs check-expiration [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for check-expiration</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-certs-generate-csr>kubeadm certs generate-csr</h2><p>This command can be used to generate keys and CSRs for all control-plane certificates and kubeconfig files.
The user can then sign the CSRs with a CA of their choice.</p><ul class="nav nav-tabs" id=tab-certs-generate-csr role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-generate-csr-0 role=tab aria-controls=tab-certs-generate-csr-0 aria-selected=true>generate-csr</a></li></ul><div class=tab-content id=tab-certs-generate-csr><div id=tab-certs-generate-csr-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-generate-csr-0><p><p>Generate keys and certificate signing requests</p><h3 id=synopsis>Synopsis</h3><p>Generates keys and certificate signing requests (CSRs) for all the certificates required to run the control plane. This command also generates partial kubeconfig files with private key data in the "users > user > client-key-data" field, and for each kubeconfig file an accompanying ".csr" file is created.</p><p>This command is designed for use in <a href=https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode>Kubeadm External CA Mode</a>. It generates CSRs which you can then submit to your external certificate authority for signing.</p><p>The PEM encoded signed certificates should then be saved alongside the key files, using ".crt" as the file extension, or in the case of kubeconfig files, the PEM encoded signed certificate should be base64 encoded and added to the kubeconfig file in the "users > user > client-certificate-data" field.</p><pre tabindex=0><code>kubeadm certs generate-csr [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # The following command will generate keys and CSRs for all control-plane certificates and kubeconfig files:
  kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the certificates</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for generate-csr</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> to connect a node to the cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fbe8dcd222ce5795a5c325670a26b067>11 - kubeadm init phase</h1><p><code>kubeadm init phase</code> enables you to invoke atomic steps of the bootstrap process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.</p><p><code>kubeadm init phase</code> is consistent with the <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow>kubeadm init workflow</a>,
and behind the scene both use the same code.</p><h2 id=cmd-phase-preflight>kubeadm init phase preflight</h2><p>Using this command you can execute preflight checks on a control-plane node.</p><ul class="nav nav-tabs" id=tab-preflight role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-preflight-0 role=tab aria-controls=tab-preflight-0 aria-selected=true>preflight</a></li></ul><div class=tab-content id=tab-preflight><div id=tab-preflight-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-preflight-0><p><p>Run pre-flight checks</p><h3 id=synopsis>Synopsis</h3><p>Run pre-flight checks for kubeadm init.</p><pre tabindex=0><code>kubeadm init phase preflight [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Run pre-flight checks for kubeadm init using a config file.
  kubeadm init phase preflight --config kubeadm-config.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for preflight</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-phase-kubelet-start>kubeadm init phase kubelet-start</h2><p>This phase will write the kubelet configuration file and environment file and then start the kubelet.</p><ul class="nav nav-tabs" id=tab-kubelet-start role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubelet-start-0 role=tab aria-controls=tab-kubelet-start-0 aria-selected=true>kubelet-start</a></li></ul><div class=tab-content id=tab-kubelet-start><div id=tab-kubelet-start-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubelet-start-0><p><p>Write kubelet settings and (re)start the kubelet</p><h3 id=synopsis>Synopsis</h3><p>Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.</p><pre tabindex=0><code>kubeadm init phase kubelet-start [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Writes a dynamic environment file with kubelet flags from a InitConfiguration file.
  kubeadm init phase kubelet-start --config config.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet-start</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-phase-certs>kubeadm init phase certs</h2><p>Can be used to create all required certificates by kubeadm.</p><ul class="nav nav-tabs" id=tab-certs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-0 role=tab aria-controls=tab-certs-0 aria-selected=true>certs</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-1 role=tab aria-controls=tab-certs-1>all</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-2 role=tab aria-controls=tab-certs-2>ca</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-3 role=tab aria-controls=tab-certs-3>apiserver</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-4 role=tab aria-controls=tab-certs-4>apiserver-kubelet-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-5 role=tab aria-controls=tab-certs-5>front-proxy-ca</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-6 role=tab aria-controls=tab-certs-6>front-proxy-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-7 role=tab aria-controls=tab-certs-7>etcd-ca</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-8 role=tab aria-controls=tab-certs-8>etcd-server</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-9 role=tab aria-controls=tab-certs-9>etcd-peer</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-10 role=tab aria-controls=tab-certs-10>healthcheck-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-11 role=tab aria-controls=tab-certs-11>apiserver-etcd-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-12 role=tab aria-controls=tab-certs-12>sa</a></li></ul><div class=tab-content id=tab-certs><div id=tab-certs-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-0><p><p>Certificate generation</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase certs [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for certs</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-1 class=tab-pane role=tabpanel aria-labelledby=tab-certs-1><p><p>Generate all certificates</p><h3 id=synopsis>Synopsis</h3><p>Generate all certificates</p><pre tabindex=0><code>kubeadm init phase certs all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-cert-extra-sans strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-2 class=tab-pane role=tabpanel aria-labelledby=tab-certs-2><p><p>Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components</p><h3 id=synopsis>Synopsis</h3><p>Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components, and save them into ca.crt and ca.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs ca [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for ca</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-3 class=tab-pane role=tabpanel aria-labelledby=tab-certs-3><p><p>Generate the certificate for serving the Kubernetes API</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for serving the Kubernetes API, and save them into apiserver.crt and apiserver.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs apiserver [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-cert-extra-sans strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-4 class=tab-pane role=tabpanel aria-labelledby=tab-certs-4><p><p>Generate the certificate for the API server to connect to kubelet</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for the API server to connect to kubelet, and save them into apiserver-kubelet-client.crt and apiserver-kubelet-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs apiserver-kubelet-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver-kubelet-client</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-5 class=tab-pane role=tabpanel aria-labelledby=tab-certs-5><p><p>Generate the self-signed CA to provision identities for front proxy</p><h3 id=synopsis>Synopsis</h3><p>Generate the self-signed CA to provision identities for front proxy, and save them into front-proxy-ca.crt and front-proxy-ca.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs front-proxy-ca [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for front-proxy-ca</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-6 class=tab-pane role=tabpanel aria-labelledby=tab-certs-6><p><p>Generate the certificate for the front proxy client</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for the front proxy client, and save them into front-proxy-client.crt and front-proxy-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs front-proxy-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for front-proxy-client</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-7 class=tab-pane role=tabpanel aria-labelledby=tab-certs-7><p><p>Generate the self-signed CA to provision identities for etcd</p><h3 id=synopsis>Synopsis</h3><p>Generate the self-signed CA to provision identities for etcd, and save them into etcd/ca.crt and etcd/ca.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs etcd-ca [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-ca</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-8 class=tab-pane role=tabpanel aria-labelledby=tab-certs-8><p><p>Generate the certificate for serving etcd</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for serving etcd, and save them into etcd/server.crt and etcd/server.key files.</p><p>Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs etcd-server [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-server</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-9 class=tab-pane role=tabpanel aria-labelledby=tab-certs-9><p><p>Generate the certificate for etcd nodes to communicate with each other</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for etcd nodes to communicate with each other, and save them into etcd/peer.crt and etcd/peer.key files.</p><p>Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs etcd-peer [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-peer</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-10 class=tab-pane role=tabpanel aria-labelledby=tab-certs-10><p><p>Generate the certificate for liveness probes to healthcheck etcd</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate for liveness probes to healthcheck etcd, and save them into etcd/healthcheck-client.crt and etcd/healthcheck-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs etcd-healthcheck-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd-healthcheck-client</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-11 class=tab-pane role=tabpanel aria-labelledby=tab-certs-11><p><p>Generate the certificate the apiserver uses to access etcd</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificate the apiserver uses to access etcd, and save them into apiserver-etcd-client.crt and apiserver-etcd-client.key files.</p><p>If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs apiserver-etcd-client [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver-etcd-client</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-certs-12 class=tab-pane role=tabpanel aria-labelledby=tab-certs-12><p><p>Generate a private key for signing service account tokens along with its public key</p><h3 id=synopsis>Synopsis</h3><p>Generate the private key for signing service account tokens along with its public key, and save them into sa.key and sa.pub files. If both files already exist, kubeadm skips the generation step and existing files will be used.</p><p>Alpha Disclaimer: this command is currently alpha.</p><pre tabindex=0><code>kubeadm init phase certs sa [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for sa</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-phase-kubeconfig>kubeadm init phase kubeconfig</h2><p>You can create all required kubeconfig files by calling the <code>all</code> subcommand or call them individually.</p><ul class="nav nav-tabs" id=tab-kubeconfig role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubeconfig-0 role=tab aria-controls=tab-kubeconfig-0 aria-selected=true>kubeconfig</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-1 role=tab aria-controls=tab-kubeconfig-1>all</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-2 role=tab aria-controls=tab-kubeconfig-2>admin</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-3 role=tab aria-controls=tab-kubeconfig-3>kubelet</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-4 role=tab aria-controls=tab-kubeconfig-4>controller-manager</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-5 role=tab aria-controls=tab-kubeconfig-5>scheduler</a></li></ul><div class=tab-content id=tab-kubeconfig><div id=tab-kubeconfig-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubeconfig-0><p><p>Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase kubeconfig [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubeconfig</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-kubeconfig-1 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-1><p><p>Generate all kubeconfig files</p><h3 id=synopsis>Synopsis</h3><p>Generate all kubeconfig files</p><pre tabindex=0><code>kubeadm init phase kubeconfig all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-kubeconfig-2 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-2><p><p>Generate a kubeconfig file for the admin to use and for kubeadm itself</p><h3 id=synopsis>Synopsis</h3><p>Generate the kubeconfig file for the admin and for kubeadm itself, and save it to admin.conf file.</p><pre tabindex=0><code>kubeadm init phase kubeconfig admin [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for admin</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-kubeconfig-3 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-3><p><p>Generate a kubeconfig file for the kubelet to use <em>only</em> for cluster bootstrapping purposes</p><h3 id=synopsis>Synopsis</h3><p>Generate the kubeconfig file for the kubelet to use and save it to kubelet.conf file.</p><p>Please note that this should <em>only</em> be used for cluster bootstrapping purposes. After your control plane is up, you should request all kubelet credentials from the CSR API.</p><pre tabindex=0><code>kubeadm init phase kubeconfig kubelet [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-kubeconfig-4 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-4><p><p>Generate a kubeconfig file for the controller manager to use</p><h3 id=synopsis>Synopsis</h3><p>Generate the kubeconfig file for the controller manager to use and save it to controller-manager.conf file</p><pre tabindex=0><code>kubeadm init phase kubeconfig controller-manager [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for controller-manager</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-kubeconfig-5 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-5><p><p>Generate a kubeconfig file for the scheduler to use</p><h3 id=synopsis>Synopsis</h3><p>Generate the kubeconfig file for the scheduler to use and save it to scheduler.conf file.</p><pre tabindex=0><code>kubeadm init phase kubeconfig scheduler [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for scheduler</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save the kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-phase-control-plane>kubeadm init phase control-plane</h2><p>Using this phase you can create all required static Pod files for the control plane components.</p><ul class="nav nav-tabs" id=tab-control-plane role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-control-plane-0 role=tab aria-controls=tab-control-plane-0 aria-selected=true>control-plane</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-1 role=tab aria-controls=tab-control-plane-1>all</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-2 role=tab aria-controls=tab-control-plane-2>apiserver</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-3 role=tab aria-controls=tab-control-plane-3>controller-manager</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-4 role=tab aria-controls=tab-control-plane-4>scheduler</a></li></ul><div class=tab-content id=tab-control-plane><div id=tab-control-plane-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-control-plane-0><p><p>Generate all static Pod manifest files necessary to establish the control plane</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase control-plane [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for control-plane</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-1 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-1><p><p>Generate all static Pod manifest files</p><h3 id=synopsis>Synopsis</h3><p>Generate all static Pod manifest files</p><pre tabindex=0><code>kubeadm init phase control-plane all [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Generates all static Pod manifest files for control plane components,
  # functionally equivalent to what is generated by kubeadm init.
  kubeadm init phase control-plane all
  
  # Generates all static Pod manifest files using options read from a configuration file.
  kubeadm init phase control-plane all --config config.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--apiserver-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname>=&lt;value></p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>--controller-manager-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname>=&lt;value></p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan=2>--scheduler-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname>=&lt;value></p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-2 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-2><p><p>Generates the kube-apiserver static Pod manifest</p><h3 id=synopsis>Synopsis</h3><p>Generates the kube-apiserver static Pod manifest</p><pre tabindex=0><code>kubeadm init phase control-plane apiserver [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--apiserver-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname>=&lt;value></p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for apiserver</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-3 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-3><p><p>Generates the kube-controller-manager static Pod manifest</p><h3 id=synopsis>Synopsis</h3><p>Generates the kube-controller-manager static Pod manifest</p><pre tabindex=0><code>kubeadm init phase control-plane controller-manager [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--controller-manager-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname>=&lt;value></p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for controller-manager</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-4 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-4><p><p>Generates the kube-scheduler static Pod manifest</p><h3 id=synopsis>Synopsis</h3><p>Generates the kube-scheduler static Pod manifest</p><pre tabindex=0><code>kubeadm init phase control-plane scheduler [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't apply any changes; just output what would be done.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for scheduler</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--scheduler-extra-args &lt;comma-separated 'key=value' pairs></td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname>=&lt;value></p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-phase-etcd>kubeadm init phase etcd</h2><p>Use the following phase to create a local etcd instance based on a static Pod file.</p><ul class="nav nav-tabs" id=tab-etcd role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-etcd-0 role=tab aria-controls=tab-etcd-0 aria-selected=true>etcd</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-etcd-1 role=tab aria-controls=tab-etcd-1>local</a></li></ul><div class=tab-content id=tab-etcd><div id=tab-etcd-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-etcd-0><p><p>Generate static Pod manifest file for local etcd</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase etcd [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-etcd-1 class=tab-pane role=tabpanel aria-labelledby=tab-etcd-1><p><p>Generate the static Pod manifest file for a local, single-node local etcd instance</p><h3 id=synopsis>Synopsis</h3><p>Generate the static Pod manifest file for a local, single-node local etcd instance</p><pre tabindex=0><code>kubeadm init phase etcd local [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Generates the static Pod manifest file for etcd, functionally
  # equivalent to what is generated by kubeadm init.
  kubeadm init phase etcd local
  
  # Generates the static Pod manifest file for etcd using options
  # read from a configuration file.
  kubeadm init phase etcd local --config config.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for local</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-phase-upload-config>kubeadm init phase upload-config</h2><p>You can use this command to upload the kubeadm configuration to your cluster.
Alternatively, you can use <a href=/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config</a>.</p><ul class="nav nav-tabs" id=upload-config role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#upload-config-0 role=tab aria-controls=upload-config-0 aria-selected=true>upload-config</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#upload-config-1 role=tab aria-controls=upload-config-1>all</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#upload-config-2 role=tab aria-controls=upload-config-2>kubeadm</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#upload-config-3 role=tab aria-controls=upload-config-3>kubelet</a></li></ul><div class=tab-content id=upload-config><div id=upload-config-0 class="tab-pane show active" role=tabpanel aria-labelledby=upload-config-0><p><p>Upload the kubeadm and kubelet configuration to a ConfigMap</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase upload-config [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for upload-config</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=upload-config-1 class=tab-pane role=tabpanel aria-labelledby=upload-config-1><p><p>Upload all configuration to a config map</p><h3 id=synopsis>Synopsis</h3><p>Upload all configuration to a config map</p><pre tabindex=0><code>kubeadm init phase upload-config all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=upload-config-2 class=tab-pane role=tabpanel aria-labelledby=upload-config-2><p><p>Upload the kubeadm ClusterConfiguration to a ConfigMap</p><h3 id=synopsis>Synopsis</h3><p>Upload the kubeadm ClusterConfiguration to a ConfigMap called kubeadm-config in the kube-system namespace. This enables correct configuration of system components and a seamless user experience when upgrading.</p><p>Alternatively, you can use kubeadm config.</p><pre tabindex=0><code>kubeadm init phase upload-config kubeadm [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # upload the configuration of your cluster
  kubeadm init phase upload-config --config=myConfig.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubeadm</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=upload-config-3 class=tab-pane role=tabpanel aria-labelledby=upload-config-3><p><p>Upload the kubelet component config to a ConfigMap</p><h3 id=synopsis>Synopsis</h3><p>Upload the kubelet configuration extracted from the kubeadm InitConfiguration object to a kubelet-config ConfigMap in the cluster</p><pre tabindex=0><code>kubeadm init phase upload-config kubelet [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Upload the kubelet configuration from the kubeadm Config file to a ConfigMap in the cluster.
  kubeadm init phase upload-config kubelet --config kubeadm.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-phase-upload-certs>kubeadm init phase upload-certs</h2><p>Use the following phase to upload control-plane certificates to the cluster.
By default the certs and encryption key expire after two hours.</p><ul class="nav nav-tabs" id=tab-upload-certs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-upload-certs-0 role=tab aria-controls=tab-upload-certs-0 aria-selected=true>upload-certs</a></li></ul><div class=tab-content id=tab-upload-certs><div id=tab-upload-certs-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-upload-certs-0><p><p>Upload certificates to kubeadm-certs</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase upload-certs [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for upload-certs</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--skip-certificate-key-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Don't print the key used to encrypt the control-plane certificates.</p></td></tr><tr><td colspan=2>--upload-certs</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Upload control-plane certificates to the kubeadm-certs Secret.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-phase-mark-control-plane>kubeadm init phase mark-control-plane</h2><p>Use the following phase to label and taint the node as a control plane node.</p><ul class="nav nav-tabs" id=tab-mark-control-plane role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-mark-control-plane-0 role=tab aria-controls=tab-mark-control-plane-0 aria-selected=true>mark-control-plane</a></li></ul><div class=tab-content id=tab-mark-control-plane><div id=tab-mark-control-plane-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-mark-control-plane-0><p><p>Mark a node as a control-plane</p><h3 id=synopsis>Synopsis</h3><p>Mark a node as a control-plane</p><pre tabindex=0><code>kubeadm init phase mark-control-plane [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Applies control-plane label and taint to the current node, functionally equivalent to what executed by kubeadm init.
  kubeadm init phase mark-control-plane --config config.yaml
  
  # Applies control-plane label and taint to a specific node
  kubeadm init phase mark-control-plane --node-name myNode
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for mark-control-plane</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-phase-bootstrap-token>kubeadm init phase bootstrap-token</h2><p>Use the following phase to configure bootstrap tokens.</p><ul class="nav nav-tabs" id=tab-bootstrap-token role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-bootstrap-token-0 role=tab aria-controls=tab-bootstrap-token-0 aria-selected=true>bootstrap-token</a></li></ul><div class=tab-content id=tab-bootstrap-token><div id=tab-bootstrap-token-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-bootstrap-token-0><p><p>Generates bootstrap tokens used to join a node to a cluster</p><h3 id=synopsis>Synopsis</h3><p>Bootstrap tokens are used for establishing bidirectional trust between a node joining the cluster and a control-plane node.</p><p>This command makes all the configurations required to make bootstrap tokens works and then creates an initial token.</p><pre tabindex=0><code>kubeadm init phase bootstrap-token [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Make all the bootstrap token configurations and create an initial token, functionally
  # equivalent to what generated by kubeadm init.
  kubeadm init phase bootstrap-token
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for bootstrap-token</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--skip-token-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Skip printing of the default bootstrap token generated by 'kubeadm init'.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-phase-kubelet-finalize-all>kubeadm init phase kubelet-finalize</h2><p>Use the following phase to update settings relevant to the kubelet after TLS
bootstrap. You can use the <code>all</code> subcommand to run all <code>kubelet-finalize</code>
phases.</p><ul class="nav nav-tabs" id=tab-kubelet-finalize role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubelet-finalize-0 role=tab aria-controls=tab-kubelet-finalize-0 aria-selected=true>kubelet-finalize</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubelet-finalize-1 role=tab aria-controls=tab-kubelet-finalize-1>kubelet-finalize-all</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubelet-finalize-2 role=tab aria-controls=tab-kubelet-finalize-2>kubelet-finalize-cert-rotation</a></li></ul><div class=tab-content id=tab-kubelet-finalize><div id=tab-kubelet-finalize-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubelet-finalize-0><p><p>Updates settings relevant to the kubelet after TLS bootstrap</p><h3 id=synopsis>Synopsis</h3><p>Updates settings relevant to the kubelet after TLS bootstrap</p><pre tabindex=0><code>kubeadm init phase kubelet-finalize [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Updates settings relevant to the kubelet after TLS bootstrap&#34;
  kubeadm init phase kubelet-finalize all --config
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet-finalize</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-kubelet-finalize-1 class=tab-pane role=tabpanel aria-labelledby=tab-kubelet-finalize-1><p><p>Run all kubelet-finalize phases</p><h3 id=synopsis>Synopsis</h3><p>Run all kubelet-finalize phases</p><pre tabindex=0><code>kubeadm init phase kubelet-finalize all [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Updates settings relevant to the kubelet after TLS bootstrap&#34;
  kubeadm init phase kubelet-finalize all --config
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-kubelet-finalize-2 class=tab-pane role=tabpanel aria-labelledby=tab-kubelet-finalize-2><p><p>Enable kubelet client certificate rotation</p><h3 id=synopsis>Synopsis</h3><p>Enable kubelet client certificate rotation</p><pre tabindex=0><code>kubeadm init phase kubelet-finalize experimental-cert-rotation [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path where to save and store the certificates.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for experimental-cert-rotation</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-phase-addon>kubeadm init phase addon</h2><p>You can install all the available addons with the <code>all</code> subcommand, or
install them selectively.</p><ul class="nav nav-tabs" id=tab-addon role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-addon-0 role=tab aria-controls=tab-addon-0 aria-selected=true>addon</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-addon-1 role=tab aria-controls=tab-addon-1>all</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-addon-2 role=tab aria-controls=tab-addon-2>coredns</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-addon-3 role=tab aria-controls=tab-addon-3>kube-proxy</a></li></ul><div class=tab-content id=tab-addon><div id=tab-addon-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-addon-0><p><p>Install required addons for passing conformance tests</p><h3 id=synopsis>Synopsis</h3><p>This command is not meant to be run on its own. See list of available subcommands.</p><pre tabindex=0><code>kubeadm init phase addon [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for addon</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-addon-1 class=tab-pane role=tabpanel aria-labelledby=tab-addon-1><p><p>Install all the addons</p><h3 id=synopsis>Synopsis</h3><p>Install all the addons</p><pre tabindex=0><code>kubeadm init phase addon all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-addon-2 class=tab-pane role=tabpanel aria-labelledby=tab-addon-2><p><p>Install the CoreDNS addon to a Kubernetes cluster</p><h3 id=synopsis>Synopsis</h3><p>Install the CoreDNS addon components via the API server. Please note that although the DNS server is deployed, it will not be scheduled until CNI is installed.</p><pre tabindex=0><code>kubeadm init phase addon coredns [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A set of key=value pairs that describe feature gates for various features. Options are:<br>PublicKeysECDSA=true|false (ALPHA - default=false)<br>RootlessControlPlane=true|false (ALPHA - default=false)<br>UnversionedKubeletConfigMap=true|false (default=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for coredns</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--print-manifest</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Print the addon manifests to STDOUT instead of installing them</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative range of IP address for service VIPs.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use alternative domain for services, e.g. "myorg.internal".</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-addon-3 class=tab-pane role=tabpanel aria-labelledby=tab-addon-3><p><p>Install the kube-proxy addon to a Kubernetes cluster</p><h3 id=synopsis>Synopsis</h3><p>Install the kube-proxy addon components via the API server.</p><pre tabindex=0><code>kubeadm init phase addon kube-proxy [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify a stable IP address or DNS name for the control plane.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kube-proxy</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "registry.k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a container registry to pull control plane images from</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Choose a specific Kubernetes version for the control plane.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.</p></td></tr><tr><td colspan=2>--print-manifest</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Print the addon manifests to STDOUT instead of installing them</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><p>For more details on each field in the <code>v1beta3</code> configuration you can navigate to our
<a href=/docs/reference/config-api/kubeadm-config.v1beta3/>API reference pages.</a></p><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> to connect a node to the cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a> to try experimental functionality</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-62a742c564b0b5b7ac12a95e67cc425a>12 - kubeadm join phase</h1><p><code>kubeadm join phase</code> enables you to invoke atomic steps of the join process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.</p><p><code>kubeadm join phase</code> is consistent with the <a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/#join-workflow>kubeadm join workflow</a>,
and behind the scene both use the same code.</p><h2 id=cmd-join-phase>kubeadm join phase</h2><ul class="nav nav-tabs" id=tab-phase role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-phase-0 role=tab aria-controls=tab-phase-0 aria-selected=true>phase</a></li></ul><div class=tab-content id=tab-phase><div id=tab-phase-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-phase-0><p><p>Use this command to invoke single phase of the join workflow</p><h3 id=synopsis>Synopsis</h3><p>Use this command to invoke single phase of the join workflow</p><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for phase</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-join-phase-preflight>kubeadm join phase preflight</h2><p>Using this phase you can execute preflight checks on a joining node.</p><ul class="nav nav-tabs" id=tab-preflight role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-preflight-0 role=tab aria-controls=tab-preflight-0 aria-selected=true>preflight</a></li></ul><div class=tab-content id=tab-preflight><div id=tab-preflight-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-preflight-0><p><p>Run join pre-flight checks</p><h3 id=synopsis>Synopsis</h3><p>Run pre-flight checks for kubeadm join.</p><pre tabindex=0><code>kubeadm join phase preflight [api-server-endpoint] [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Run join pre-flight checks using a config file.
  kubeadm join phase preflight --config kubeadm-config.yaml
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this key to decrypt the certificate secrets uploaded by init.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for preflight</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-join-phase-control-plane-prepare>kubeadm join phase control-plane-prepare</h2><p>Using this phase you can prepare a node for serving a control-plane.</p><ul class="nav nav-tabs" id=tab-control-plane-prepare role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-control-plane-prepare-0 role=tab aria-controls=tab-control-plane-prepare-0 aria-selected=true>control-plane-prepare</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-1 role=tab aria-controls=tab-control-plane-prepare-1>all</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-2 role=tab aria-controls=tab-control-plane-prepare-2>download-certs</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-3 role=tab aria-controls=tab-control-plane-prepare-3>certs</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-4 role=tab aria-controls=tab-control-plane-prepare-4>kubeconfig</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-5 role=tab aria-controls=tab-control-plane-prepare-5>control-plane</a></li></ul><div class=tab-content id=tab-control-plane-prepare><div id=tab-control-plane-prepare-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-control-plane-prepare-0><p><p>Prepare the machine for serving a control plane</p><h3 id=synopsis>Synopsis</h3><p>Prepare the machine for serving a control plane</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Prepares the machine for serving a control plane
  kubeadm join phase control-plane-prepare all
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for control-plane-prepare</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-prepare-1 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-1><p><p>Prepare the machine for serving a control plane</p><h3 id=synopsis>Synopsis</h3><p>Prepare the machine for serving a control plane</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare all [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this key to decrypt the certificate secrets uploaded by init.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-prepare-2 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-2><p><p>[EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret</p><h3 id=synopsis>Synopsis</h3><p>[EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare download-certs [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this key to decrypt the certificate secrets uploaded by init.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for download-certs</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-prepare-3 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-3><p><p>Generate the certificates for the new control plane components</p><h3 id=synopsis>Synopsis</h3><p>Generate the certificates for the new control plane components</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare certs [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for certs</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-prepare-4 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-4><p><p>Generate the kubeconfig for the new control plane components</p><h3 id=synopsis>Synopsis</h3><p>Generate the kubeconfig for the new control plane components</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare kubeconfig [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this key to decrypt the certificate secrets uploaded by init.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubeconfig</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-prepare-5 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-5><p><p>Generate the manifests for the new control plane components</p><h3 id=synopsis>Synopsis</h3><p>Generate the manifests for the new control plane components</p><pre tabindex=0><code>kubeadm join phase control-plane-prepare control-plane [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the port for the API Server to bind to.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for control-plane</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-join-phase-kubelet-start>kubeadm join phase kubelet-start</h2><p>Using this phase you can write the kubelet settings, certificates and (re)start the kubelet.</p><ul class="nav nav-tabs" id=tab-kubelet-start role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubelet-start-0 role=tab aria-controls=tab-kubelet-start-0 aria-selected=true>kubelet-start</a></li></ul><div class=tab-content id=tab-kubelet-start><div id=tab-kubelet-start-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubelet-start-0><p><p>Write kubelet settings, certificates and (re)start the kubelet</p><h3 id=synopsis>Synopsis</h3><p>Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.</p><pre tabindex=0><code>kubeadm join phase kubelet-start [api-server-endpoint] [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>--discovery-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For file-based discovery, a file or URL from which to load cluster information.</p></td></tr><tr><td colspan=2>--discovery-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, the token used to validate cluster information fetched from the API server.</p></td></tr><tr><td colspan=2>--discovery-token-ca-cert-hash strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type>:&lt;value>").</p></td></tr><tr><td colspan=2>--discovery-token-unsafe-skip-ca-verification</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet-start</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr><tr><td colspan=2>--tls-bootstrap-token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-join-phase-control-plane-join>kubeadm join phase control-plane-join</h2><p>Using this phase you can join a node as a control-plane instance.</p><ul class="nav nav-tabs" id=tab-control-plane-join role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-control-plane-join-0 role=tab aria-controls=tab-control-plane-join-0 aria-selected=true>control-plane-join</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-1 role=tab aria-controls=tab-control-plane-join-1>all</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-2 role=tab aria-controls=tab-control-plane-join-2>etcd</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-3 role=tab aria-controls=tab-control-plane-join-3>update-status</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-4 role=tab aria-controls=tab-control-plane-join-4>mark-control-plane</a></li></ul><div class=tab-content id=tab-control-plane-join><div id=tab-control-plane-join-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-control-plane-join-0><p><p>Join a machine as a control plane instance</p><h3 id=synopsis>Synopsis</h3><p>Join a machine as a control plane instance</p><pre tabindex=0><code>kubeadm join phase control-plane-join [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Joins a machine as a control plane instance
  kubeadm join phase control-plane-join all
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for control-plane-join</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-join-1 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-1><p><p>Join a machine as a control plane instance</p><h3 id=synopsis>Synopsis</h3><p>Join a machine as a control plane instance</p><pre tabindex=0><code>kubeadm join phase control-plane-join all [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for all</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-join-2 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-2><p><p>Add a new local etcd member</p><h3 id=synopsis>Synopsis</h3><p>Add a new local etcd member</p><pre tabindex=0><code>kubeadm join phase control-plane-join etcd [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for etcd</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-join-3 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-3><p><p>Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap (DEPRECATED)</p><h3 id=synopsis>Synopsis</h3><p>Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap (DEPRECATED)</p><pre tabindex=0><code>kubeadm join phase control-plane-join update-status [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for update-status</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-control-plane-join-4 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-4><p><p>Mark a node as a control-plane</p><h3 id=synopsis>Synopsis</h3><p>Mark a node as a control-plane</p><pre tabindex=0><code>kubeadm join phase control-plane-join mark-control-plane [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to kubeadm config file.</p></td></tr><tr><td colspan=2>--control-plane</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Create a new control plane instance on this node</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for mark-control-plane</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Specify the node name.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> to connect a node to the cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a> to try experimental functionality</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ab2d643d770ca684548de4ddbc7d8c4>13 - kubeadm kubeconfig</h1><p><code>kubeadm kubeconfig</code> provides utilities for managing kubeconfig files.</p><p>For examples on how to use <code>kubeadm kubeconfig user</code> see
<a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#kubeconfig-additional-users>Generating kubeconfig files for additional users</a>.</p><h2 id=cmd-kubeconfig>kubeadm kubeconfig</h2><ul class="nav nav-tabs" id=tab-kubeconfig role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubeconfig-0 role=tab aria-controls=tab-kubeconfig-0 aria-selected=true>overview</a></li></ul><div class=tab-content id=tab-kubeconfig><div id=tab-kubeconfig-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubeconfig-0><p><p>Kubeconfig file utilities</p><h3 id=synopsis>Synopsis</h3><p>Kubeconfig file utilities.</p><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubeconfig</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-kubeconfig-user>kubeadm kubeconfig user</h2><p>This command can be used to output a kubeconfig file for an additional user.</p><ul class="nav nav-tabs" id=tab-kubeconfig-user role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubeconfig-user-0 role=tab aria-controls=tab-kubeconfig-user-0 aria-selected=true>user</a></li></ul><div class=tab-content id=tab-kubeconfig-user><div id=tab-kubeconfig-user-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubeconfig-user-0><p><p>Output a kubeconfig file for an additional user</p><h3 id=synopsis>Synopsis</h3><p>Output a kubeconfig file for an additional user.</p><pre tabindex=0><code>kubeadm kubeconfig user [flags]
</code></pre><h3 id=examples>Examples</h3><pre tabindex=0><code>  # Output a kubeconfig file for an additional user named foo using a kubeadm config file bar
  kubeadm kubeconfig user --client-name=foo --config=bar
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--client-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The name of user. It will be used as the CN if client certificates are created</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a kubeadm configuration file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for user</p></td></tr><tr><td colspan=2>--org strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The organizations of the client certificate. It will be used as the O if client certificates are created</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The token that should be used as the authentication mechanism for this kubeconfig, instead of client certificates</p></td></tr><tr><td colspan=2>--validity-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 8760h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The validity period of the client certificate. It is an offset from the current time.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div></div><div class=td-content style=page-break-before:always><h1 id=pg-b969d0033ce5d9036463521fb1f150b3>14 - kubeadm reset phase</h1><p><code>kubeadm reset phase</code> enables you to invoke atomic steps of the node reset process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.</p><p><code>kubeadm reset phase</code> is consistent with the <a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/#reset-workflow>kubeadm reset workflow</a>,
and behind the scene both use the same code.</p><h2 id=cmd-reset-phase>kubeadm reset phase</h2><ul class="nav nav-tabs" id=tab-phase role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-phase-0 role=tab aria-controls=tab-phase-0 aria-selected=true>phase</a></li></ul><div class=tab-content id=tab-phase><div id=tab-phase-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-phase-0><p><p>Use this command to invoke single phase of the reset workflow</p><h3 id=synopsis>Synopsis</h3><p>Use this command to invoke single phase of the reset workflow</p><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for phase</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-reset-phase-preflight>kubeadm reset phase preflight</h2><p>Using this phase you can execute preflight checks on a node that is being reset.</p><ul class="nav nav-tabs" id=tab-preflight role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-preflight-0 role=tab aria-controls=tab-preflight-0 aria-selected=true>preflight</a></li></ul><div class=tab-content id=tab-preflight><div id=tab-preflight-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-preflight-0><p><p>Run reset pre-flight checks</p><h3 id=synopsis>Synopsis</h3><p>Run pre-flight checks for kubeadm reset.</p><pre tabindex=0><code>kubeadm reset phase preflight [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-f, --force</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Reset the node without prompting for confirmation.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for preflight</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-reset-phase-remove-etcd-member>kubeadm reset phase remove-etcd-member</h2><p>Using this phase you can remove this control-plane node's etcd member from the etcd cluster.</p><ul class="nav nav-tabs" id=tab-remove-etcd-member role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-remove-etcd-member-0 role=tab aria-controls=tab-remove-etcd-member-0 aria-selected=true>remove-etcd-member</a></li></ul><div class=tab-content id=tab-remove-etcd-member><div id=tab-remove-etcd-member-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-remove-etcd-member-0><p><p>Remove a local etcd member.</p><h3 id=synopsis>Synopsis</h3><p>Remove a local etcd member for a control plane node.</p><pre tabindex=0><code>kubeadm reset phase remove-etcd-member [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for remove-etcd-member</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=cmd-reset-phase-cleanup-node>kubeadm reset phase cleanup-node</h2><p>Using this phase you can perform cleanup on this node.</p><ul class="nav nav-tabs" id=tab-cleanup-node role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cleanup-node-0 role=tab aria-controls=tab-cleanup-node-0 aria-selected=true>cleanup-node</a></li></ul><div class=tab-content id=tab-cleanup-node><div id=tab-cleanup-node-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cleanup-node-0><p><p>Run cleanup node.</p><h3 id=synopsis>Synopsis</h3><p>Run cleanup node.</p><pre tabindex=0><code>kubeadm reset phase cleanup-node [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The path to the directory where the certificates are stored. If specified, clean this directory.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for cleanup-node</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> to connect a node to the cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a> to try experimental functionality</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-dfd085b5ab706bd84dda15847dd27f1b>15 - kubeadm upgrade phase</h1><p>In v1.15.0, kubeadm introduced preliminary support for <code>kubeadm upgrade node</code> phases.
Phases for other <code>kubeadm upgrade</code> sub-commands such as <code>apply</code>, could be added in the
following releases.</p><h2 id=cmd-node-phase>kubeadm upgrade node phase</h2><p>Using this phase you can choose to execute the separate steps of the upgrade of
secondary control-plane or worker nodes. Please note that <code>kubeadm upgrade apply</code> still has to
be called on a primary control-plane node.</p><ul class="nav nav-tabs" id=tab-phase role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-phase-0 role=tab aria-controls=tab-phase-0 aria-selected=true>phase</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-1 role=tab aria-controls=tab-phase-1>preflight</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-2 role=tab aria-controls=tab-phase-2>control-plane</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-3 role=tab aria-controls=tab-phase-3>kubelet-config</a></li></ul><div class=tab-content id=tab-phase><div id=tab-phase-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-phase-0><p><p>Use this command to invoke single phase of the node workflow</p><h3 id=synopsis>Synopsis</h3><p>Use this command to invoke single phase of the node workflow</p><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for phase</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-phase-1 class=tab-pane role=tabpanel aria-labelledby=tab-phase-1><p><p>Run upgrade node pre-flight checks</p><h3 id=synopsis>Synopsis</h3><p>Run pre-flight checks for kubeadm upgrade node.</p><pre tabindex=0><code>kubeadm upgrade node phase preflight [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for preflight</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-phase-2 class=tab-pane role=tabpanel aria-labelledby=tab-phase-2><p><p>Upgrade the control plane instance deployed on this node, if any</p><h3 id=synopsis>Synopsis</h3><p>Upgrade the control plane instance deployed on this node, if any</p><pre tabindex=0><code>kubeadm upgrade node phase control-plane [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the renewal of certificates used by component changed during upgrades.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Do not change any state, just output the actions that would be performed.</p></td></tr><tr><td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Perform the upgrade of etcd.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for control-plane</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div><div id=tab-phase-3 class=tab-pane role=tabpanel aria-labelledby=tab-phase-3><p><p>Upgrade the kubelet configuration for this node</p><h3 id=synopsis>Synopsis</h3><p>Download the kubelet configuration from the kubelet-config ConfigMap stored in the cluster</p><pre tabindex=0><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre><h3 id=options>Options</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Do not change any state, just output the actions that would be performed.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>help for kubelet-config</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd", "kubeletconfiguration". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.</p></td></tr></tbody></table><h3 id=options-inherited-from-parent-commands>Options inherited from parent commands</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td></tr></tbody></table></div></div><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> to bootstrap a Kubernetes control-plane node</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> to connect a node to the cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a> to revert any changes made to this host by <code>kubeadm init</code> or <code>kubeadm join</code></li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/>kubeadm upgrade</a> to upgrade a kubeadm node</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a> to try experimental functionality</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-455b6412a275b743ee8ad90f35808393>16 - Implementation details</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [stable]</code></div><p><code>kubeadm init</code> and <code>kubeadm join</code> together provides a nice user experience for creating a
best-practice but bare Kubernetes cluster from scratch.
However, it might not be obvious <em>how</em> kubeadm does that.</p><p>This document provides additional details on what happen under the hood, with the aim of sharing
knowledge on Kubernetes cluster best practices.</p><h2 id=core-design-principles>Core design principles</h2><p>The cluster that <code>kubeadm init</code> and <code>kubeadm join</code> set up should be:</p><ul><li><strong>Secure</strong>: It should adopt latest best-practices like:<ul><li>enforcing RBAC</li><li>using the Node Authorizer</li><li>using secure communication between the control plane components</li><li>using secure communication between the API server and the kubelets</li><li>lock-down the kubelet API</li><li>locking down access to the API for system components like the kube-proxy and CoreDNS</li><li>locking down what a Bootstrap Token can access</li></ul></li><li><strong>User-friendly</strong>: The user should not have to run anything more than a couple of commands:<ul><li><code>kubeadm init</code></li><li><code>export KUBECONFIG=/etc/kubernetes/admin.conf</code></li><li><code>kubectl apply -f &lt;network-of-choice.yaml></code></li><li><code>kubeadm join --token &lt;token> &lt;endpoint>:&lt;port></code></li></ul></li><li><strong>Extendable</strong>:<ul><li>It should <em>not</em> favor any particular network provider. Configuring the cluster network is out-of-scope</li><li>It should provide the possibility to use a config file for customizing various parameters</li></ul></li></ul><h2 id=constants-and-well-known-values-and-paths>Constants and well-known values and paths</h2><p>In order to reduce complexity and to simplify development of higher level tools that build on top of kubeadm, it uses a
limited set of constant values for well-known paths and file names.</p><p>The Kubernetes directory <code>/etc/kubernetes</code> is a constant in the application, since it is clearly the given path
in a majority of cases, and the most intuitive location; other constants paths and file names are:</p><ul><li><p><code>/etc/kubernetes/manifests</code> as the path where kubelet should look for static Pod manifests.
Names of static Pod manifests are:</p><ul><li><code>etcd.yaml</code></li><li><code>kube-apiserver.yaml</code></li><li><code>kube-controller-manager.yaml</code></li><li><code>kube-scheduler.yaml</code></li></ul></li><li><p><code>/etc/kubernetes/</code> as the path where kubeconfig files with identities for control plane
components are stored. Names of kubeconfig files are:</p><ul><li><code>kubelet.conf</code> (<code>bootstrap-kubelet.conf</code> during TLS bootstrap)</li><li><code>controller-manager.conf</code></li><li><code>scheduler.conf</code></li><li><code>admin.conf</code> for the cluster admin and kubeadm itself</li></ul></li><li><p>Names of certificates and key files :</p><ul><li><code>ca.crt</code>, <code>ca.key</code> for the Kubernetes certificate authority</li><li><code>apiserver.crt</code>, <code>apiserver.key</code> for the API server certificate</li><li><code>apiserver-kubelet-client.crt</code>, <code>apiserver-kubelet-client.key</code> for the client certificate used
by the API server to connect to the kubelets securely</li><li><code>sa.pub</code>, <code>sa.key</code> for the key used by the controller manager when signing ServiceAccount</li><li><code>front-proxy-ca.crt</code>, <code>front-proxy-ca.key</code> for the front proxy certificate authority</li><li><code>front-proxy-client.crt</code>, <code>front-proxy-client.key</code> for the front proxy client</li></ul></li></ul><h2 id=kubeadm-init-workflow-internal-design>kubeadm init workflow internal design</h2><p>The <code>kubeadm init</code> <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow>internal workflow</a>
consists of a sequence of atomic work tasks to perform,
as described in <code>kubeadm init</code>.</p><p>The <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/><code>kubeadm init phase</code></a> command allows
users to invoke each task individually, and ultimately offers a reusable and composable
API/toolbox that can be used by other Kubernetes bootstrap tools, by any IT automation tool or by
an advanced user for creating custom clusters.</p><h3 id=preflight-checks>Preflight checks</h3><p>Kubeadm executes a set of preflight checks before starting the init, with the aim to verify
preconditions and avoid common cluster startup problems.
The user can skip specific preflight checks or all of them with the <code>--ignore-preflight-errors</code> option.</p><ul><li>[warning] If the Kubernetes version to use (specified with the <code>--kubernetes-version</code> flag) is
at least one minor version higher than the kubeadm CLI version.</li><li>Kubernetes system requirements:<ul><li>if running on linux:<ul><li>[error] if Kernel is older than the minimum required version</li><li>[error] if required cgroups subsystem aren't set up</li></ul></li></ul></li><li>[error] if the CRI endpoint does not answer</li><li>[error] if user is not root</li><li>[error] if the machine hostname is not a valid DNS subdomain</li><li>[warning] if the host name cannot be reached via network lookup</li><li>[error] if kubelet version is lower that the minimum kubelet version supported by kubeadm (current minor -1)</li><li>[error] if kubelet version is at least one minor higher than the required controlplane version (unsupported version skew)</li><li>[warning] if kubelet service does not exist or if it is disabled</li><li>[warning] if firewalld is active</li><li>[error] if API server bindPort or ports 10250/10251/10252 are used</li><li>[Error] if <code>/etc/kubernetes/manifest</code> folder already exists and it is not empty</li><li>[Error] if <code>/proc/sys/net/bridge/bridge-nf-call-iptables</code> file does not exist/does not contain 1</li><li>[Error] if advertise address is ipv6 and <code>/proc/sys/net/bridge/bridge-nf-call-ip6tables</code> does not exist/does not contain 1.</li><li>[Error] if swap is on</li><li>[Error] if <code>conntrack</code>, <code>ip</code>, <code>iptables</code>, <code>mount</code>, <code>nsenter</code> commands are not present in the command path</li><li>[warning] if <code>ebtables</code>, <code>ethtool</code>, <code>socat</code>, <code>tc</code>, <code>touch</code>, <code>crictl</code> commands are not present in the command path</li><li>[warning] if extra arg flags for API server, controller manager, scheduler contains some invalid options</li><li>[warning] if connection to https://API.AdvertiseAddress:API.BindPort goes through proxy</li><li>[warning] if connection to services subnet goes through proxy (only first address checked)</li><li>[warning] if connection to Pods subnet goes through proxy (only first address checked)</li><li>If external etcd is provided:<ul><li>[Error] if etcd version is older than the minimum required version</li><li>[Error] if etcd certificates or keys are specified, but not provided</li></ul></li><li>If external etcd is NOT provided (and thus local etcd will be installed):<ul><li>[Error] if ports 2379 is used</li><li>[Error] if Etcd.DataDir folder already exists and it is not empty</li></ul></li><li>If authorization mode is ABAC:<ul><li>[Error] if abac_policy.json does not exist</li></ul></li><li>If authorization mode is WebHook<ul><li>[Error] if webhook_authz.conf does not exist</li></ul></li></ul><p>Please note that:</p><ol><li>Preflight checks can be invoked individually with the
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-preflight><code>kubeadm init phase preflight</code></a>
command</li></ol><h3 id=generate-the-necessary-certificates>Generate the necessary certificates</h3><p>Kubeadm generates certificate and private key pairs for different purposes:</p><ul><li><p>A self signed certificate authority for the Kubernetes cluster saved into <code>ca.crt</code> file and
<code>ca.key</code> private key file</p></li><li><p>A serving certificate for the API server, generated using <code>ca.crt</code> as the CA, and saved into
<code>apiserver.crt</code> file with its private key <code>apiserver.key</code>. This certificate should contain
following alternative names:</p><ul><li>The Kubernetes service's internal clusterIP (the first address in the services CIDR, e.g.
<code>10.96.0.1</code> if service subnet is <code>10.96.0.0/12</code>)</li><li>Kubernetes DNS names, e.g. <code>kubernetes.default.svc.cluster.local</code> if <code>--service-dns-domain</code>
flag value is <code>cluster.local</code>, plus default DNS names <code>kubernetes.default.svc</code>,
<code>kubernetes.default</code>, <code>kubernetes</code></li><li>The node-name</li><li>The <code>--apiserver-advertise-address</code></li><li>Additional alternative names specified by the user</li></ul></li><li><p>A client certificate for the API server to connect to the kubelets securely, generated using
<code>ca.crt</code> as the CA and saved into <code>apiserver-kubelet-client.crt</code> file with its private key
<code>apiserver-kubelet-client.key</code>.
This certificate should be in the <code>system:masters</code> organization</p></li><li><p>A private key for signing ServiceAccount Tokens saved into <code>sa.key</code> file along with its public key <code>sa.pub</code></p></li><li><p>A certificate authority for the front proxy saved into <code>front-proxy-ca.crt</code> file with its key
<code>front-proxy-ca.key</code></p></li><li><p>A client cert for the front proxy client, generate using <code>front-proxy-ca.crt</code> as the CA and
saved into <code>front-proxy-client.crt</code> file with its private key<code>front-proxy-client.key</code></p></li></ul><p>Certificates are stored by default in <code>/etc/kubernetes/pki</code>, but this directory is configurable
using the <code>--cert-dir</code> flag.</p><p>Please note that:</p><ol><li>If a given certificate and private key pair both exist, and its content is evaluated compliant with the above specs, the existing files will
be used and the generation phase for the given certificate skipped. This means the user can, for example, copy an existing CA to
<code>/etc/kubernetes/pki/ca.{crt,key}</code>, and then kubeadm will use those files for signing the rest of the certs.
See also <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#custom-certificates>using custom certificates</a></li><li>Only for the CA, it is possible to provide the <code>ca.crt</code> file but not the <code>ca.key</code> file, if all other certificates and kubeconfig files
already are in place kubeadm recognize this condition and activates the ExternalCA , which also implies the <code>csrsigner</code>controller in
controller-manager won't be started</li><li>If kubeadm is running in <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#external-ca-mode>external CA mode</a>;
all the certificates must be provided by the user, because kubeadm cannot generate them by itself</li><li>In case of kubeadm is executed in the <code>--dry-run</code> mode, certificates files are written in a temporary folder</li><li>Certificate generation can be invoked individually with the
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-certs><code>kubeadm init phase certs all</code></a> command</li></ol><h3 id=generate-kubeconfig-files-for-control-plane-components>Generate kubeconfig files for control plane components</h3><p>Kubeadm generates kubeconfig files with identities for control plane components:</p><ul><li><p>A kubeconfig file for the kubelet to use during TLS bootstrap -
/etc/kubernetes/bootstrap-kubelet.conf. Inside this file there is a bootstrap-token or embedded
client certificates for authenticating this node with the cluster.</p><p>This client cert should:</p><ul><li>Be in the <code>system:nodes</code> organization, as required by the
<a href=/docs/reference/access-authn-authz/node/>Node Authorization</a> module</li><li>Have the Common Name (CN) <code>system:node:&lt;hostname-lowercased></code></li></ul></li><li><p>A kubeconfig file for controller-manager, <code>/etc/kubernetes/controller-manager.conf</code>; inside this
file is embedded a client certificate with controller-manager identity. This client cert should
have the CN <code>system:kube-controller-manager</code>, as defined by default
<a href=/docs/reference/access-authn-authz/rbac/#core-component-roles>RBAC core components roles</a></p></li><li><p>A kubeconfig file for scheduler, <code>/etc/kubernetes/scheduler.conf</code>; inside this file is embedded
a client certificate with scheduler identity.
This client cert should have the CN <code>system:kube-scheduler</code>, as defined by default
<a href=/docs/reference/access-authn-authz/rbac/#core-component-roles>RBAC core components roles</a></p></li></ul><p>Additionally, a kubeconfig file for kubeadm itself and the admin is generated and saved into the
<code>/etc/kubernetes/admin.conf</code> file. The "admin" here is defined as the actual person(s) that is
administering the cluster and wants to have full control (<strong>root</strong>) over the cluster. The
embedded client certificate for admin should be in the <code>system:masters</code> organization, as defined
by default <a href=/docs/reference/access-authn-authz/rbac/#user-facing-roles>RBAC user facing role bindings</a>.
It should also include a CN. Kubeadm uses the <code>kubernetes-admin</code> CN.</p><p>Please note that:</p><ol><li><code>ca.crt</code> certificate is embedded in all the kubeconfig files.</li><li>If a given kubeconfig file exists, and its content is evaluated compliant with the above specs,
the existing file will be used and the generation phase for the given kubeconfig skipped</li><li>If kubeadm is running in <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#external-ca-mode>ExternalCA mode</a>,
all the required kubeconfig must be provided by the user as well, because kubeadm cannot
generate any of them by itself</li><li>In case of kubeadm is executed in the <code>--dry-run</code> mode, kubeconfig files are written in a temporary folder</li><li>Kubeconfig files generation can be invoked individually with the
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-kubeconfig><code>kubeadm init phase kubeconfig all</code></a> command</li></ol><h3 id=generate-static-pod-manifests-for-control-plane-components>Generate static Pod manifests for control plane components</h3><p>Kubeadm writes static Pod manifest files for control plane components to
<code>/etc/kubernetes/manifests</code>. The kubelet watches this directory for Pods to create on startup.</p><p>Static Pod manifest share a set of common properties:</p><ul><li><p>All static Pods are deployed on <code>kube-system</code> namespace</p></li><li><p>All static Pods get <code>tier:control-plane</code> and <code>component:{component-name}</code> labels</p></li><li><p>All static Pods use the <code>system-node-critical</code> priority class</p></li><li><p><code>hostNetwork: true</code> is set on all static Pods to allow control plane startup before a network is
configured; as a consequence:</p><ul><li>The <code>address</code> that the controller-manager and the scheduler use to refer the API server is <code>127.0.0.1</code></li><li>If using a local etcd server, <code>etcd-servers</code> address will be set to <code>127.0.0.1:2379</code></li></ul></li><li><p>Leader election is enabled for both the controller-manager and the scheduler</p></li><li><p>Controller-manager and the scheduler will reference kubeconfig files with their respective, unique identities</p></li><li><p>All static Pods get any extra flags specified by the user as described in
<a href=/docs/setup/production-environment/tools/kubeadm/control-plane-flags/>passing custom arguments to control plane components</a></p></li><li><p>All static Pods get any extra Volumes specified by the user (Host path)</p></li></ul><p>Please note that:</p><ol><li>All images will be pulled from registry.k8s.io by default.
See <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images>using custom images</a>
for customizing the image repository</li><li>In case of kubeadm is executed in the <code>--dry-run</code> mode, static Pods files are written in a
temporary folder</li><li>Static Pod manifest generation for control plane components can be invoked individually with
the <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-control-plane><code>kubeadm init phase control-plane all</code></a> command</li></ol><h4 id=api-server>API server</h4><p>The static Pod manifest for the API server is affected by following parameters provided by the users:</p><ul><li>The <code>apiserver-advertise-address</code> and <code>apiserver-bind-port</code> to bind to; if not provided, those
value defaults to the IP address of the default network interface on the machine and port 6443</li><li>The <code>service-cluster-ip-range</code> to use for services</li><li>If an external etcd server is specified, the <code>etcd-servers</code> address and related TLS settings
(<code>etcd-cafile</code>, <code>etcd-certfile</code>, <code>etcd-keyfile</code>);
if an external etcd server is not be provided, a local etcd will be used (via host network)</li><li>If a cloud provider is specified, the corresponding <code>--cloud-provider</code> is configured, together
with the <code>--cloud-config</code> path if such file exists (this is experimental, alpha and will be
removed in a future version)</li></ul><p>Other API server flags that are set unconditionally are:</p><ul><li><p><code>--insecure-port=0</code> to avoid insecure connections to the api server</p></li><li><p><code>--enable-bootstrap-token-auth=true</code> to enable the <code>BootstrapTokenAuthenticator</code> authentication module.
See <a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>TLS Bootstrapping</a> for more details</p></li><li><p><code>--allow-privileged</code> to <code>true</code> (required e.g. by kube proxy)</p></li><li><p><code>--requestheader-client-ca-file</code> to <code>front-proxy-ca.crt</code></p></li><li><p><code>--enable-admission-plugins</code> to:</p><ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#namespacelifecycle><code>NamespaceLifecycle</code></a>
e.g. to avoid deletion of system reserved namespaces</li><li><a href=/docs/reference/access-authn-authz/admission-controllers/#limitranger><code>LimitRanger</code></a>
and <a href=/docs/reference/access-authn-authz/admission-controllers/#resourcequota><code>ResourceQuota</code></a>
to enforce limits on namespaces</li><li><a href=/docs/reference/access-authn-authz/admission-controllers/#serviceaccount><code>ServiceAccount</code></a>
to enforce service account automation</li><li><a href=/docs/reference/access-authn-authz/admission-controllers/#persistentvolumelabel><code>PersistentVolumeLabel</code></a>
attaches region or zone labels to PersistentVolumes as defined by the cloud provider (This
admission controller is deprecated and will be removed in a future version.
It is not deployed by kubeadm by default with v1.9 onwards when not explicitly opting into
using <code>gce</code> or <code>aws</code> as cloud providers)</li><li><a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code></a>
to enforce default storage class on <code>PersistentVolumeClaim</code> objects</li><li><a href=/docs/reference/access-authn-authz/admission-controllers/#defaulttolerationseconds><code>DefaultTolerationSeconds</code></a></li><li><a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction><code>NodeRestriction</code></a>
to limit what a kubelet can modify (e.g. only pods on this node)</li></ul></li><li><p><code>--kubelet-preferred-address-types</code> to <code>InternalIP,ExternalIP,Hostname;</code> this makes <code>kubectl logs</code> and other API server-kubelet communication work in environments where the hostnames of the
nodes aren't resolvable</p></li><li><p>Flags for using certificates generated in previous steps:</p><ul><li><code>--client-ca-file</code> to <code>ca.crt</code></li><li><code>--tls-cert-file</code> to <code>apiserver.crt</code></li><li><code>--tls-private-key-file</code> to <code>apiserver.key</code></li><li><code>--kubelet-client-certificate</code> to <code>apiserver-kubelet-client.crt</code></li><li><code>--kubelet-client-key</code> to <code>apiserver-kubelet-client.key</code></li><li><code>--service-account-key-file</code> to <code>sa.pub</code></li><li><code>--requestheader-client-ca-file</code> to<code>front-proxy-ca.crt</code></li><li><code>--proxy-client-cert-file</code> to <code>front-proxy-client.crt</code></li><li><code>--proxy-client-key-file</code> to <code>front-proxy-client.key</code></li></ul></li><li><p>Other flags for securing the front proxy
(<a href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API Aggregation</a>)
communications:</p><ul><li><code>--requestheader-username-headers=X-Remote-User</code></li><li><code>--requestheader-group-headers=X-Remote-Group</code></li><li><code>--requestheader-extra-headers-prefix=X-Remote-Extra-</code></li><li><code>--requestheader-allowed-names=front-proxy-client</code></li></ul></li></ul><h4 id=controller-manager>Controller manager</h4><p>The static Pod manifest for the controller manager is affected by following parameters provided by
the users:</p><ul><li><p>If kubeadm is invoked specifying a <code>--pod-network-cidr</code>, the subnet manager feature required for
some CNI network plugins is enabled by setting:</p><ul><li><code>--allocate-node-cidrs=true</code></li><li><code>--cluster-cidr</code> and <code>--node-cidr-mask-size</code> flags according to the given CIDR</li></ul></li><li><p>If a cloud provider is specified, the corresponding <code>--cloud-provider</code> is specified, together
with the <code>--cloud-config</code> path if such configuration file exists (this is experimental, alpha
and will be removed in a future version)</p></li></ul><p>Other flags that are set unconditionally are:</p><ul><li><p><code>--controllers</code> enabling all the default controllers plus <code>BootstrapSigner</code> and <code>TokenCleaner</code>
controllers for TLS bootstrap. See <a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>TLS Bootstrapping</a>
for more details</p></li><li><p><code>--use-service-account-credentials</code> to <code>true</code></p></li><li><p>Flags for using certificates generated in previous steps:</p><ul><li><code>--root-ca-file</code> to <code>ca.crt</code></li><li><code>--cluster-signing-cert-file</code> to <code>ca.crt</code>, if External CA mode is disabled, otherwise to <code>""</code></li><li><code>--cluster-signing-key-file</code> to <code>ca.key</code>, if External CA mode is disabled, otherwise to <code>""</code></li><li><code>--service-account-private-key-file</code> to <code>sa.key</code></li></ul></li></ul><h4 id=scheduler>Scheduler</h4><p>The static Pod manifest for the scheduler is not affected by parameters provided by the users.</p><h3 id=generate-static-pod-manifest-for-local-etcd>Generate static Pod manifest for local etcd</h3><p>If you specified an external etcd this step will be skipped, otherwise kubeadm generates a
static Pod manifest file for creating a local etcd instance running in a Pod with following attributes:</p><ul><li>listen on <code>localhost:2379</code> and use <code>HostNetwork=true</code></li><li>make a <code>hostPath</code> mount out from the <code>dataDir</code> to the host's filesystem</li><li>Any extra flags specified by the user</li></ul><p>Please note that:</p><ol><li>The etcd container image will be pulled from <code>registry.gcr.io</code> by default. See
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images>using custom images</a>
for customizing the image repository.</li><li>If you run kubeadm in <code>--dry-run</code> mode, the etcd static Pod manifest is written
into a temporary folder.</li><li>You can directly invoke static Pod manifest generation for local etcd, using the
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-etcd><code>kubeadm init phase etcd local</code></a>
command.</li></ol><h3 id=wait-for-the-control-plane-to-come-up>Wait for the control plane to come up</h3><p>kubeadm waits (upto 4m0s) until <code>localhost:6443/healthz</code> (kube-apiserver liveness) returns <code>ok</code>.
However in order to detect deadlock conditions, kubeadm fails fast if <code>localhost:10255/healthz</code>
(kubelet liveness) or <code>localhost:10255/healthz/syncloop</code> (kubelet readiness) don't return <code>ok</code>
within 40s and 60s respectively.</p><p>kubeadm relies on the kubelet to pull the control plane images and run them properly as static Pods.
After the control plane is up, kubeadm completes the tasks described in following paragraphs.</p><h3 id=save-the-kubeadm-clusterconfiguration-in-a-configmap-for-later-reference>Save the kubeadm ClusterConfiguration in a ConfigMap for later reference</h3><p>kubeadm saves the configuration passed to <code>kubeadm init</code> in a ConfigMap named <code>kubeadm-config</code>
under <code>kube-system</code> namespace.</p><p>This will ensure that kubeadm actions executed in future (e.g <code>kubeadm upgrade</code>) will be able to
determine the actual/current cluster state and make new decisions based on that data.</p><p>Please note that:</p><ol><li>Before saving the ClusterConfiguration, sensitive information like the token is stripped from the configuration</li><li>Upload of control plane node configuration can be invoked individually with the command
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-upload-config><code>kubeadm init phase upload-config</code></a>.</li></ol><h3 id=mark-the-node-as-control-plane>Mark the node as control-plane</h3><p>As soon as the control plane is available, kubeadm executes following actions:</p><ul><li>Labels the node as control-plane with <code>node-role.kubernetes.io/control-plane=""</code></li><li>Taints the node with <code>node-role.kubernetes.io/control-plane:NoSchedule</code></li></ul><p>Please note that the phase to mark the control-plane phase can be invoked
individually with the <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-mark-control-plane><code>kubeadm init phase mark-control-plane</code></a> command.</p><ul><li>Taints the node with <code>node-role.kubernetes.io/master:NoSchedule</code> and
<code>node-role.kubernetes.io/control-plane:NoSchedule</code></li></ul><p>Please note that:</p><ol><li>The <code>node-role.kubernetes.io/master</code> taint is deprecated and will be removed in kubeadm version 1.25</li><li>Mark control-plane phase phase can be invoked individually with the command
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-mark-control-plane><code>kubeadm init phase mark-control-plane</code></a></li></ol><h3 id=configure-tls-bootstrapping-for-node-joining>Configure TLS-Bootstrapping for node joining</h3><p>Kubeadm uses <a href=/docs/reference/access-authn-authz/bootstrap-tokens/>Authenticating with Bootstrap Tokens</a>
for joining new nodes to an existing cluster; for more details see also
<a href=https://git.k8s.io/design-proposals-archive/cluster-lifecycle/bootstrap-discovery.md>design proposal</a>.</p><p><code>kubeadm init</code> ensures that everything is properly configured for this process, and this includes
following steps as well as setting API server and controller flags as already described in
previous paragraphs.</p><p>Please note that:</p><ol><li>TLS bootstrapping for nodes can be configured with the command
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-bootstrap-token><code>kubeadm init phase bootstrap-token</code></a>,
executing all the configuration steps described in following paragraphs;
alternatively, each step can be invoked individually</li></ol><h4 id=create-a-bootstrap-token>Create a bootstrap token</h4><p><code>kubeadm init</code> create a first bootstrap token, either generated automatically or provided by the
user with the <code>--token</code> flag; as documented in bootstrap token specification, token should be
saved as secrets with name <code>bootstrap-token-&lt;token-id></code> under <code>kube-system</code> namespace.</p><p>Please note that:</p><ol><li>The default token created by <code>kubeadm init</code> will be used to validate temporary user during TLS
bootstrap process; those users will be member of
<code>system:bootstrappers:kubeadm:default-node-token</code> group</li><li>The token has a limited validity, default 24 hours (the interval may be changed with the <code>—token-ttl</code> flag)</li><li>Additional tokens can be created with the <a href=/docs/reference/setup-tools/kubeadm/kubeadm-token/><code>kubeadm token</code></a>
command, that provide as well other useful functions for token management.</li></ol><h4 id=allow-joining-nodes-to-call-csr-api>Allow joining nodes to call CSR API</h4><p>Kubeadm ensures that users in <code>system:bootstrappers:kubeadm:default-node-token</code> group are able to
access the certificate signing API.</p><p>This is implemented by creating a ClusterRoleBinding named <code>kubeadm:kubelet-bootstrap</code> between the
group above and the default RBAC role <code>system:node-bootstrapper</code>.</p><h4 id=set-up-auto-approval-for-new-bootstrap-tokens>Set up auto approval for new bootstrap tokens</h4><p>Kubeadm ensures that the Bootstrap Token will get its CSR request automatically approved by the
csrapprover controller.</p><p>This is implemented by creating ClusterRoleBinding named <code>kubeadm:node-autoapprove-bootstrap</code>
between the <code>system:bootstrappers:kubeadm:default-node-token</code> group and the default role
<code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code>.</p><p>The role <code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> should be created as
well, granting POST permission to
<code>/apis/certificates.k8s.io/certificatesigningrequests/nodeclient</code>.</p><h4 id=set-up-nodes-certificate-rotation-with-auto-approval>Set up nodes certificate rotation with auto approval</h4><p>Kubeadm ensures that certificate rotation is enabled for nodes, and that new certificate request
for nodes will get its CSR request automatically approved by the csrapprover controller.</p><p>This is implemented by creating ClusterRoleBinding named
<code>kubeadm:node-autoapprove-certificate-rotation</code> between the <code>system:nodes</code> group and the default
role <code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>.</p><h4 id=create-the-public-cluster-info-configmap>Create the public cluster-info ConfigMap</h4><p>This phase creates the <code>cluster-info</code> ConfigMap in the <code>kube-public</code> namespace.</p><p>Additionally it creates a Role and a RoleBinding granting access to the ConfigMap for
unauthenticated users (i.e. users in RBAC group <code>system:unauthenticated</code>).</p><p>Please note that:</p><ol><li>The access to the <code>cluster-info</code> ConfigMap <em>is not</em> rate-limited. This may or may not be a
problem if you expose your cluster's API server to the internet; worst-case scenario here is a
DoS attack where an attacker uses all the in-flight requests the kube-apiserver can handle to
serving the <code>cluster-info</code> ConfigMap.</li></ol><h3 id=install-addons>Install addons</h3><p>Kubeadm installs the internal DNS server and the kube-proxy addon components via the API server.</p><p>Please note that:</p><ol><li>This phase can be invoked individually with the command
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon><code>kubeadm init phase addon all</code></a>.</li></ol><h4 id=proxy>proxy</h4><p>A ServiceAccount for <code>kube-proxy</code> is created in the <code>kube-system</code> namespace; then kube-proxy is
deployed as a DaemonSet:</p><ul><li>The credentials (<code>ca.crt</code> and <code>token</code>) to the control plane come from the ServiceAccount</li><li>The location (URL) of the API server comes from a ConfigMap</li><li>The <code>kube-proxy</code> ServiceAccount is bound to the privileges in the <code>system:node-proxier</code> ClusterRole</li></ul><h4 id=dns>DNS</h4><ul><li><p>The CoreDNS service is named <code>kube-dns</code>. This is done to prevent any interruption
in service when the user is switching the cluster DNS from kube-dns to CoreDNS
the <code>--config</code> method described <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon>here</a>.</p></li><li><p>A ServiceAccount for CoreDNS is created in the <code>kube-system</code> namespace.</p></li><li><p>The <code>coredns</code> ServiceAccount is bound to the privileges in the <code>system:coredns</code> ClusterRole</p></li></ul><p>In Kubernetes version 1.21, support for using <code>kube-dns</code> with kubeadm was removed.
You can use CoreDNS with kubeadm even when the related Service is named <code>kube-dns</code>.</p><h2 id=kubeadm-join-phases-internal-design>kubeadm join phases internal design</h2><p>Similarly to <code>kubeadm init</code>, also <code>kubeadm join</code> internal workflow consists of a sequence of
atomic work tasks to perform.</p><p>This is split into discovery (having the Node trust the Kubernetes Master) and TLS bootstrap
(having the Kubernetes Master trust the Node).</p><p>see <a href=/docs/reference/access-authn-authz/bootstrap-tokens/>Authenticating with Bootstrap Tokens</a>
or the corresponding <a href=https://git.k8s.io/design-proposals-archive/cluster-lifecycle/bootstrap-discovery.md>design proposal</a>.</p><h3 id=preflight-checks-1>Preflight checks</h3><p><code>kubeadm</code> executes a set of preflight checks before starting the join, with the aim to verify
preconditions and avoid common cluster startup problems.</p><p>Please note that:</p><ol><li><code>kubeadm join</code> preflight checks are basically a subset <code>kubeadm init</code> preflight checks</li><li>Starting from 1.24, kubeadm uses crictl to communicate to all known CRI endpoints.</li><li>Starting from 1.9, kubeadm provides support for joining nodes running on Windows; in that case,
linux specific controls are skipped.</li><li>In any case the user can skip specific preflight checks (or eventually all preflight checks)
with the <code>--ignore-preflight-errors</code> option.</li></ol><h3 id=discovery-cluster-info>Discovery cluster-info</h3><p>There are 2 main schemes for discovery. The first is to use a shared token along with the IP
address of the API server.
The second is to provide a file (that is a subset of the standard kubeconfig file).</p><h4 id=shared-token-discovery>Shared token discovery</h4><p>If <code>kubeadm join</code> is invoked with <code>--discovery-token</code>, token discovery is used; in this case the
node basically retrieves the cluster CA certificates from the <code>cluster-info</code> ConfigMap in the
<code>kube-public</code> namespace.</p><p>In order to prevent "man in the middle" attacks, several steps are taken:</p><ul><li><p>First, the CA certificate is retrieved via insecure connection (this is possible because
<code>kubeadm init</code> granted access to <code>cluster-info</code> users for <code>system:unauthenticated</code> )</p></li><li><p>Then the CA certificate goes trough following validation steps:</p><ul><li>Basic validation: using the token ID against a JWT signature</li><li>Pub key validation: using provided <code>--discovery-token-ca-cert-hash</code>. This value is available
in the output of <code>kubeadm init</code> or can be calculated using standard tools (the hash is
calculated over the bytes of the Subject Public Key Info (SPKI) object as in RFC7469). The
<code>--discovery-token-ca-cert-hash flag</code> may be repeated multiple times to allow more than one public key.</li><li>As a additional validation, the CA certificate is retrieved via secure connection and then
compared with the CA retrieved initially</li></ul></li></ul><p>Please note that:</p><ol><li>Pub key validation can be skipped passing <code>--discovery-token-unsafe-skip-ca-verification</code> flag;
This weakens the kubeadm security model since others can potentially impersonate the Kubernetes Master.</li></ol><h4 id=file-https-discovery>File/https discovery</h4><p>If <code>kubeadm join</code> is invoked with <code>--discovery-file</code>, file discovery is used; this file can be a
local file or downloaded via an HTTPS URL; in case of HTTPS, the host installed CA bundle is used
to verify the connection.</p><p>With file discovery, the cluster CA certificates is provided into the file itself; in fact, the
discovery file is a kubeconfig file with only <code>server</code> and <code>certificate-authority-data</code> attributes
set, as described in <a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/#file-or-https-based-discovery><code>kubeadm join</code></a>
reference doc; when the connection with the cluster is established, kubeadm try to access the
<code>cluster-info</code> ConfigMap, and if available, uses it.</p><h2 id=tls-bootstrap>TLS Bootstrap</h2><p>Once the cluster info are known, the file <code>bootstrap-kubelet.conf</code> is written, thus allowing
kubelet to do TLS Bootstrapping.</p><p>The TLS bootstrap mechanism uses the shared token to temporarily authenticate with the Kubernetes
API server to submit a certificate signing request (CSR) for a locally created key pair.</p><p>The request is then automatically approved and the operation completes saving <code>ca.crt</code> file and
<code>kubelet.conf</code> file to be used by kubelet for joining the cluster, while<code>bootstrap-kubelet.conf</code>
is deleted.</p><p>Please note that:</p><ul><li>The temporary authentication is validated against the token saved during the <code>kubeadm init</code>
process (or with additional tokens created with <code>kubeadm token</code>)</li><li>The temporary authentication resolve to a user member of
<code>system:bootstrappers:kubeadm:default-node-token</code> group which was granted access to CSR api
during the <code>kubeadm init</code> process</li><li>The automatic CSR approval is managed by the csrapprover controller, according with
configuration done the <code>kubeadm init</code> process</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/docs/home/>Home</a>
<a class=text-white href=/blog/>Blog</a>
<a class=text-white href=/training/>Training</a>
<a class=text-white href=/partners/>Partners</a>
<a class=text-white href=/community/>Community</a>
<a class=text-white href=/case-studies/>Case Studies</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>