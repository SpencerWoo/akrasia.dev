<!doctype html><html lang=id class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/scheduling-eviction/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/scheduling-eviction/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/scheduling-eviction/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/scheduling-eviction/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/concepts/scheduling-eviction/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Penjadwalan dan Pengusiran | Kubernetes</title><meta property="og:title" content="Penjadwalan dan Pengusiran"><meta property="og:description" content="Orkestrasi Kontainer dengan Skala Produksi"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/scheduling-eviction/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Penjadwalan dan Pengusiran"><meta itemprop=description content="Orkestrasi Kontainer dengan Skala Produksi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Penjadwalan dan Pengusiran"><meta name=twitter:description content="Orkestrasi Kontainer dengan Skala Produksi"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/scheduling-eviction/"><meta property="og:title" content="Penjadwalan dan Pengusiran"><meta name=twitter:title content="Penjadwalan dan Pengusiran"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/id/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/id/docs/concepts/scheduling-eviction/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/id/docs/concepts/scheduling-eviction/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/concepts/scheduling-eviction/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/concepts/scheduling-eviction/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/concepts/scheduling-eviction/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/scheduling-eviction/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/scheduling-eviction/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/scheduling-eviction/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/scheduling-eviction/>日本語 (Japanese)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/scheduling-eviction/>Português (Portuguese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/concepts/scheduling-eviction/>Return to the regular view of this page</a>.</p></div><h1 class=title>Penjadwalan dan Pengusiran</h1><ul><li>1: <a href=#pg-961126cd43559012893979e568396a49>Bin Packing Sumber Daya untuk Sumber Daya Tambahan</a></li><li>2: <a href=#pg-da22fe2278df236f71efbe672f392677>Overhead Pod</a></li><li>3: <a href=#pg-21169f516071aea5d16734a4c27789a5>Menetapkan Pod ke Node</a></li><li>4: <a href=#pg-ede4960b56a3529ee0bfe7c8fe2d09a5>Taint dan Toleration</a></li><li>5: <a href=#pg-598f36d691ab197f9d995784574b0a12>Penjadwal Kubernetes</a></li><li>6: <a href=#pg-602208c95fe7b1f1170310ce993f5814>Kerangka Kerja Penjadwalan (Scheduling Framework)</a></li><li>7: <a href=#pg-d9574a30fcbc631b0d2a57850e161e89>Penyetelan Kinerja Penjadwal</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-961126cd43559012893979e568396a49>1 - Bin Packing Sumber Daya untuk Sumber Daya Tambahan</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.16 [alpha]</code></div><p><em>Kube-scheduler</em> dapat dikonfigurasikan untuk mengaktifkan pembungkusan rapat
(<em>bin packing</em>) sumber daya bersama dengan sumber daya tambahan melalui fungsi prioritas
<code>RequestedToCapacityRatioResourceAllocation</code>. Fungsi-fungsi prioritas dapat digunakan
untuk menyempurnakan <em>kube-scheduler</em> sesuai dengan kebutuhan.</p><h2 id=mengaktifkan-bin-packing-menggunakan-requestedtocapacityratioresourceallocation>Mengaktifkan <em>Bin Packing</em> menggunakan RequestedToCapacityRatioResourceAllocation</h2><p>Sebelum Kubernetes 1.15, <em>kube-scheduler</em> digunakan untuk memungkinkan mencetak
skor berdasarkan rasio permintaan terhadap kapasitas sumber daya utama seperti
CPU dan Memori. Kubernetes 1.16 menambahkan parameter baru ke fungsi prioritas
yang memungkinkan pengguna untuk menentukan sumber daya beserta dengan bobot
untuk setiap sumber daya untuk memberi nilai dari Node berdasarkan rasio
permintaan terhadap kapasitas. Hal ini memungkinkan pengguna untuk <em>bin pack</em>
sumber daya tambahan dengan menggunakan parameter yang sesuai untuk meningkatkan
pemanfaatan sumber daya yang langka dalam klaster yang besar. Perilaku
<code>RequestedToCapacityRatioResourceAllocation</code> dari fungsi prioritas dapat
dikontrol melalui pilihan konfigurasi yang disebut <code>RequestToCapacityRatioArguments</code>.
Argumen ini terdiri dari dua parameter yaitu <code>shape</code> dan <code>resources</code>. Shape
memungkinkan pengguna untuk menyempurnakan fungsi menjadi yang paling tidak
diminta atau paling banyak diminta berdasarkan nilai <code>utilization</code> dan <code>score</code>.
Sumber daya terdiri dari <code>name</code> yang menentukan sumber daya mana yang dipertimbangkan
selama penilaian dan <code>weight</code> yang menentukan bobot masing-masing sumber daya.</p><p>Di bawah ini adalah contoh konfigurasi yang menetapkan <code>requestedToCapacityRatioArguments</code>
pada perilaku <em>bin packing</em> untuk sumber daya tambahan <code>intel.com/foo</code> dan <code>intel.com/bar</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span> : <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span> : <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;priorities&#34;</span> : [
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;RequestedToCapacityRatioPriority&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;weight&#34;</span>: <span style=color:#666>2</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;argument&#34;</span>: {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;requestedToCapacityRatioArguments&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;shape&#34;</span>: [
</span></span><span style=display:flex><span>              {<span style=color:green;font-weight:700>&#34;utilization&#34;</span>: <span style=color:#666>0</span>, <span style=color:green;font-weight:700>&#34;score&#34;</span>: <span style=color:#666>0</span>},
</span></span><span style=display:flex><span>              {<span style=color:green;font-weight:700>&#34;utilization&#34;</span>: <span style=color:#666>100</span>, <span style=color:green;font-weight:700>&#34;score&#34;</span>: <span style=color:#666>10</span>}
</span></span><span style=display:flex><span>            ],
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;resources&#34;</span>: [
</span></span><span style=display:flex><span>              {<span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;intel.com/foo&#34;</span>, <span style=color:green;font-weight:700>&#34;weight&#34;</span>: <span style=color:#666>3</span>},
</span></span><span style=display:flex><span>              {<span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;intel.com/bar&#34;</span>, <span style=color:green;font-weight:700>&#34;weight&#34;</span>: <span style=color:#666>5</span>}
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p><strong>Fitur ini dinonaktifkan secara <em>default</em></strong></p><h3 id=tuning-requestedtocapacityratioresourceallocation-priority-function>Tuning RequestedToCapacityRatioResourceAllocation Priority Function</h3><p><code>shape</code> digunakan untuk menentukan perilaku dari fungsi <code>RequestedToCapacityRatioPriority</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 0, &#34;score&#34;: </span><span style=color:#666>0</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 100, &#34;score&#34;: </span><span style=color:#666>10</span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>Argumen di atas memberikan Node nilai 0 jika utilisasi 0% dan 10 untuk utilisasi 100%,
yang kemudian mengaktfikan perilaku <em>bin packing</em>. Untuk mengaktifkan dari paling
yang tidak diminta, nilainya harus dibalik sebagai berikut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 0, &#34;score&#34;: </span><span style=color:#666>100</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 100, &#34;score&#34;: </span><span style=color:#666>0</span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>resources</code> adalah parameter opsional yang secara <em>default</em> diatur ke:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>&#34;resources&#34;: </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;CPU&#34;, &#34;weight&#34;: </span><span style=color:#666>1</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;Memory&#34;, &#34;weight&#34;: </span><span style=color:#666>1</span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Ini dapat digunakan untuk menambahkan sumber daya tambahan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>&#34;resources&#34;: </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;intel.com/foo&#34;, &#34;weight&#34;: </span><span style=color:#666>5</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;CPU&#34;, &#34;weight&#34;: </span><span style=color:#666>3</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;Memory&#34;, &#34;weight&#34;: </span><span style=color:#666>1</span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Parameter <code>weight</code> adalah opsional dan diatur ke 1 jika tidak ditentukan.
Selain itu, <code>weight</code> tidak dapat diatur ke nilai negatif.</p><h3 id=bagaimana-fungsi-prioritas-requestedtocapacityratioresourceallocation-menilai-node>Bagaimana Fungsi Prioritas RequestedToCapacityRatioResourceAllocation Menilai Node</h3><p>Bagian ini ditujukan bagi kamu yang ingin memahami secara detail internal
dari fitur ini.
Di bawah ini adalah contoh bagaimana nilai dari Node dihitung untuk satu kumpulan
nilai yang diberikan.</p><pre tabindex=0><code>Sumber daya yang diminta

intel.com/foo : 2
Memory: 256MB
CPU: 2

Bobot dari sumber daya

intel.com/foo : 5
Memory: 1
CPU: 3

FunctionShapePoint {{0, 0}, {100, 10}}

Spesifikasi dari Node 1

Tersedia:

intel.com/foo : 4
Memory : 1 GB
CPU: 8

Digunakan:

intel.com/foo: 1
Memory: 256MB
CPU: 1


Nilai Node:

intel.com/foo  = resourceScoringFunction((2+1),4)
               =  (100 - ((4-3)*100/4)
               =  (100 - 25)
               =  75
               =  rawScoringFunction(75)
               = 7

Memory         = resourceScoringFunction((256+256),1024)
               = (100 -((1024-512)*100/1024))
               = 50
               = rawScoringFunction(50)
               = 5

CPU            = resourceScoringFunction((2+1),8)
               = (100 -((8-3)*100/8))
               = 37.5
               = rawScoringFunction(37.5)
               = 3

NodeScore   =  (7 * 5) + (5 * 1) + (3 * 3) / (5 + 1 + 3)
            =  5


Spesifikasi dari Node 2

Tersedia:

intel.com/foo: 8
Memory: 1GB
CPU: 8

Digunakan:

intel.com/foo: 2
Memory: 512MB
CPU: 6


Nilai Node:

intel.com/foo  = resourceScoringFunction((2+2),8)
               =  (100 - ((8-4)*100/8)
               =  (100 - 25)
               =  50
               =  rawScoringFunction(50)
               = 5

Memory         = resourceScoringFunction((256+512),1024)
               = (100 -((1024-768)*100/1024))
               = 75
               = rawScoringFunction(75)
               = 7

CPU            = resourceScoringFunction((2+6),8)
               = (100 -((8-8)*100/8))
               = 100
               = rawScoringFunction(100)
               = 10

NodeScore   =  (5 * 5) + (7 * 1) + (10 * 3) / (5 + 1 + 3)
            =  7
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-da22fe2278df236f71efbe672f392677>2 - Overhead Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>Ketika kamu menjalankan Pod pada Node, Pod itu akan mengambil sejumlah sumber daya sistem. Sumber daya ini adalah tambahan terhadap sumber daya yang diperlukan untuk menjalankan Container di dalam Pod (<em>overhead</em>).
<em>Pod Overhead</em> adalah fitur yang berfungsi untuk menghitung sumber daya digunakan oleh infrastruktur Pod selain permintaan dan limit Container.</p><h2 id=overhead-pod>Overhead Pod</h2><p>Pada Kubernetes, Overhead Pod ditentukan pada
<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#what-are-admission-webhooks>saat admisi</a> sesuai dengan Overhead yang ditentukan di dalam
<a href=/id/docs/concepts/containers/runtime-class/>RuntimeClass</a> milik Pod.</p><p>Ketika Overhead Pod diaktifkan, Overhead akan dipertimbangkan sebagai tambahan terhadap jumlah permintaan sumber daya Container
saat menjadwalkan Pod. Begitu pula Kubelet, yang akan memasukkan Overhead Pod saat menentukan ukuran
cgroup milik Pod, dan saat melakukan pemeringkatan pengusiran (<em>eviction</em>) Pod.</p><h3 id=yang-perlu-disiapkan>Yang perlu disiapkan</h3><p>Kamu harus memastikan bahwa
<a href=/docs/reference/command-line-tools-reference/feature-gates/><em>feature gate</em></a> <code>PodOverhead</code> telah diaktifkan (secara bawaan dinonaktifkan)
di seluruh klaster kamu, yang berarti:</p><ul><li>Pada <a class=glossary-tooltip title='Komponen control plane yang bertugas mengamati Pod baru yang belum ditempatkan di node manapun dan kemudian memilihkan node di mana Pod baru tersebut akan dijalankan.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li><li>Pada <a class=glossary-tooltip title='Komponen control plane yang mengekspos API Kubernetes. Merupakan front-end dari control plane Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label=kube-apiserver>kube-apiserver</a></li><li>Pada <a class=glossary-tooltip title='Agen yang dijalankan pada setiap node di klaster yang bertugas untuk memastikan kontainer dijalankan di dalam Pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> di setiap Node</li><li>Pada peladen API khusus (<em>custom</em>) apa pun yang menggunakan <em>feature gate</em></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pengguna yang dapat mengubah sumber daya RuntimeClass dapat memengaruhi kinerja beban kerja klaster secara keseluruhan. Kamu dapat membatasi akses terhadap kemampuan ini dengan kontrol akses Kubernetes.
Lihat <a href=/docs/reference/access-authn-authz/authorization/>Ringkasan Otorisasi</a> untuk lebih lanjut.</div><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/concepts/containers/runtime-class/>RuntimeClass</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/20190226-pod-overhead.md>Desain PodOverhead</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-21169f516071aea5d16734a4c27789a5>3 - Menetapkan Pod ke Node</h1><p>Kamu dapat memaksa sebuah <a href=/id/docs/concepts/workloads/pods/pod/>pod</a> untuk hanya dapat berjalan pada <a href=/id/docs/concepts/architecture/nodes/>node</a> tertentu atau mengajukannya agar berjalan pada node tertentu. Ada beberapa cara untuk melakukan hal tersebut. Semua cara yang direkomendasikan adalah dengan menggunakan <a href=/id/docs/concepts/overview/working-with-objects/labels/><em>selector</em> label</a> untuk menetapkan pilihan yang kamu inginkan. Pada umumnya, pembatasan ini tidak dibutuhkan, sebagaimana <em>scheduler</em> akan melakukan penempatan yang proporsional dengan otomatis (seperti contohnya menyebar pod di node-node, tidak menempatkan pod pada node dengan sumber daya yang tidak memadai, dst.) tetapi ada keadaan-keadaan tertentu yang membuat kamu memiliki kendali lebih terhadap node yang menjadi tempat pod dijalankan, contohnya untuk memastikan pod dijalankan pada mesin yang telah terpasang SSD, atau untuk menempatkan pod-pod dari dua servis yang berbeda yang sering berkomunikasi bersamaan ke dalam zona ketersediaan yang sama.</p><p>Kamu dapat menemukan semua berkas untuk contoh-contoh berikut pada <a href=https://github.com/kubernetes/website/tree/main/content/en/docs/concepts/configuration/>dokumentasi yang kami sediakan di sini</a></p><h2 id=nodeselector>nodeSelector</h2><p>Penggunaan <code>nodeSelector</code> adalah cara pembatasan pemilihan node paling sederhana yang direkomendasikan. <code>nodeSelector</code> adalah sebuah <em>field</em> pada PodSpec. <code>nodeSelector</code> memerinci sebuah map berisi pasangan kunci-nilai. Agar pod dapat dijalankan pada sebuah node yang memenuhi syarat, node tersebut harus memiliki masing-masing dari pasangan kunci-nilai yang dinyatakan sebagai label (namun node juga dapat memiliki label tambahan diluar itu). Penggunaan paling umum adalah satu pasang kunci-nilai.</p><p>Mari kita telusuri contoh dari penggunaan <code>nodeSelector</code>.</p><h3 id=langkah-nol-prasyarat>Langkah Nol: Prasyarat</h3><p>Contoh ini mengasumsikan bahwa kamu memiliki pemahaman dasar tentang pod Kubernetes dan kamu telah <a href=https://github.com/kubernetes/kubernetes#documentation>membuat klaster Kubernetes</a>.</p><h3 id=langkah-satu-menyematkan-label-pada-node>Langkah Satu: Menyematkan label pada node</h3><p>Jalankan <code>kubectl get nodes</code> untuk mendapatkan nama dari node-node yang ada dalam klaster kamu. Temukan node yang akan kamu tambahkan label, kemudian jalankan perintah <code>kubectl label nodes &lt;node-name> &lt;label-key>=&lt;label-value></code> untuk menambahkan label pada node yang telah kamu pilih. Sebagai contoh, jika nama node yang saya pilih adalah 'kubernetes-foo-node-1.c.a-robinson.internal' dan label yang ingin saya tambahkan adalah 'disktype=ssd', maka saya dapat menjalankan <code>kubectl label nodes kubernetes-foo-node-1.c.a-robinson.internal disktype=ssd</code>.</p><p>Jika terjadi kegagalan dengan kesalahan perintah yang tidak <em>valid</em> ("<em>invalid command</em>"), kemungkinan besar kamu menggunakan kubectl dengan versi lebih lama yang tidak memiliki perintah <code>label</code>. Dalam hal ini, lihat [versi sebelumnya] (<a href=https://github.com/kubernetes/kubernetes/blob/a053dbc313572ed60d89dae9821ecab8bfd676dc/examples/node-selection/README.md>https://github.com/kubernetes/kubernetes/blob/a053dbc313572ed60d89dae9821ecab8bfd676dc/examples/node-selection/README.md</a>) dari petunjuk ini untuk instruksi tentang cara menetapkan label pada node.</p><p>Kamu dapat memastikan perintah telah berhasil dengan menjalankan ulang perintah <code>kubectl get nodes --show-labels</code> and memeriksa bahwa node yang dipilih sekarang sudah memiliki label yang ditambahkan. Kamu juga dapat menggunakan <code>kubectl describe node "nodename"</code> untuk melihat daftar lengkap label yang dimiliki sebuah node.</p><h3 id=langkah-dua-menambahkan-sebuah-nodeselector-ke-konfigurasi-pod-kamu>Langkah Dua: Menambahkan sebuah nodeSelector ke konfigurasi pod kamu</h3><p>Ambil berkas konfigurasi pod manapun yang akan kamu jalankan, dan tambahkan sebuah bagian <code>nodeSelector</code> pada berkas tersebut, seperti berikut. Sebagai contoh, jika berikut ini adalah konfigurasi pod saya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kemudian tambahkan sebuah <code>nodeSelector</code> seperti berikut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-yaml")' title="Copy pods/pod-nginx.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Ketika kamu menjalankan perintah <code>kubectl apply -f https://k8s.io/examples/pods/pod-nginx.yaml</code>, pod tersebut akan dijadwalkan pada node yang memiliki label yang dirinci. Kamu dapat memastikan penambahan nodeSelector berhasil dengan menjalankan <code>kubectl get pods -o wide</code> dan melihat "NODE" tempat Pod ditugaskan.</p><h2 id=selingan-label-node-built-in>Selingan: label node <em>built-in</em></h2><p>Sebagai tambahan dari label yang kamu <a href=#step-one-attach-label-to-the-node>sematkan</a>, node sudah terisi dengan satu set label standar. Pada Kubernetes v1.4 label tersebut adalah</p><ul><li><code>kubernetes.io/hostname</code></li><li><code>failure-domain.beta.kubernetes.io/zone</code></li><li><code>failure-domain.beta.kubernetes.io/region</code></li><li><code>beta.kubernetes.io/instance-type</code></li><li><code>kubernetes.io/os</code></li><li><code>kubernetes.io/arch</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Nilai dari label-label tersebut spesifik untuk setiap penyedia layanan <em>cloud</em> dan tidak dijamin reliabilitasnya.
Contohnya, nilai dari <code>kubernetes.io/hostname</code> bisa saja sama dengan nama node pada beberapa lingkungan dan berbeda pada lingkungan lain.</div><h2 id=isolasi-pembatasan-node>Isolasi/pembatasan Node</h2><p>Menambahkan label pada objek node memungkinkan penargetan pod pada node atau grup node yang spesifik. Penambahan label ini dapat digunakan untuk memastikan pod yang spesifik hanya berjalan pada node dengan isolasi, keamanan, atau pengaturan tertentu. Saat menggunakan label untuk tujuan tersebut, memilih kunci label yang tidak bisa dimodifikasi oleh proses kubelet pada node sangat direkomendasikan. Hal ini mencegah node yang telah diubah untuk menggunakan kredensial kubelet-nya untuk mengatur label-label pada objek nodenya sediri, dan mempengaruhi scheduler untuk menjadwalkan <em>workload</em> ke node yang telah diubah tersebut.</p><p><em>Plugin</em> penerimaan <code>NodeRestriction</code> mencegah kubeletes untuk megatur atau mengubah label dengan awalan <code>node-restriction.kubernetes.io/</code>.
Untuk memanfaatkan awalan label untuk isolasi node:</p><ol><li><p>Pastikan kamu menggunakan <a href=/docs/reference/access-authn-authz/node/><em>authorizer</em> node</a> dan mengaktifkan [<em>plugin admission NodeRestriction</em>(/docs/reference/access-authn-authz/admission-controllers/#noderestriction).</p></li><li><p>Tambah label dengan awalan <code>node-restriction.kubernetes.io/</code> ke objek node kamu, dan gunakan label tersebut pada node <em>selector</em> kamu. Contohnya, <code>example.com.node-restriction.kubernetes.io/fips=true</code> or <code>example.com.node-restriction.kubernetes.io/pci-dss=true</code>.</p></li></ol><h2 id=afinitas-dan-anti-afinitas>Afinitas dan anti-afinitas</h2><p><code>_Field_ nodeSelector</code> menyediakan cara yang sangat sederhana untuk membatasi pod ke node dengan label-label tertentu. Fitur afinitas/anti-afinitas saat ini bersifat beta dan memperluas tipe pembatasan yang dapat kamu nyatakan. Peningkatan kunci dari fitur ini adalah</p><ol><li>Bahasa yang lebih ekspresif (tidak hanya "AND of exact match")</li><li>Kamu dapat memberikan indikasi bahwa aturan yang dinyatakan bersifat rendah/preferensi dibanding dengan persyaratan mutlak sehingga jika scheduler tidak dapat memenuhinya, pod tetap akan dijadwalkan</li><li>Kamu dapat membatasi dengan label pada pod-pod lain yang berjalan pada node (atau domain <em>topological</em> lain), daripada dengan label pada node itu sendiri, yang memungkinkan pengaturan tentang pod yang dapat dan tidak dapat dilokasikan bersama.</li></ol><p>Fitur afinitas terdiri dari dua tipe afinitas yaitu "node afinitas" dan "inter-pod afinitas/anti-afinitas"
Node afinitas adalah seperti <code>nodeSelector</code> yang telah ada (tetapi dengam dua kelebihan pertama yang terdaftar di atas), sementara inter-pod afinitas/anti-afinitas membatasi pada label pod daripada label node, seperti yang dijelaskan pada item ketiga pada daftar di atas, sebagai tambahan dari item pertama dan kedua.</p><p><em>Field</em> <code>nodeSelector</code> tetap berjalan seperti biasa, namun pada akhirnya akan ditinggalkan karena afinitas node dapat menyatakan semua yang <code>nodeSelector</code> dapat nyatakan.</p><h3 id=afinitas-node-fitur-beta>Afinitas node (fitur beta)</h3><p>Afinitas node diperkenalkan sebagai fitur alfa pada Kubernetes 1.2.
Afinitas node secara konseptual mirip dengan <code>nodeSelector</code> yang memungkinkan kamu untuk membatasi node yang memenuhi syarat untuk penjadwalan pod, berdasarkan label pada node.</p><p>Saat ini ada dia tipe afinitas node, yaitu <code>requiredDuringSchedulingIgnoredDuringExecution</code> dan
<code>preferredDuringSchedulingIgnoredDuringExecution</code>. Kamu dapat menganggap dua tipe ini sebagai "kuat" dan "lemah" secara berurutan, dalam arti tipe pertama menyatakan peraturan yang <em>harus</em> dipenuhi agar pod dapat dijadwalkan pada node (sama seperti <code>nodeSelector</code> tetapi menggunakan sintaksis yang lebih ekpresif), sementara tipe kedua menyatakan <em>preferensi</em> yang akan dicoba dilaksanakan tetapi tidak akan dijamin oleh scheduler. Bagian "IgnoredDuringExecution" dari nama tipe ini berarti, mirip dengan cara kerja <code>nodeSelector</code>, jika label pada node berubah pada <em>runtime</em> yang menyebabkan aturan afinitas pada pod tidak lagi terpenuhi, pod akan tetap berjalan pada node. Pada masa yang akan datang kami berencana menawarkan <code>requiredDuringSchedulingRequiredDuringExecution</code> yang akan berjalan seperti <code>requiredDuringSchedulingIgnoredDuringExecution</code> hanya saja tipe ini akan mengeluarkan pod dari node yang gagal untuk memenuhi persyaratan afinitas node pod.</p><p>Dengan denikian, contoh dari <code>requiredDuringSchedulingIgnoredDuringExecution</code> adalah "hanya jalankan pod pada node dengan Intel CPU" dan contoh dari <code>preferredDuringSchedulingIgnoredDuringExecution</code> adalah "coba jalankan set pod ini dalam zona ketersediaan XYZ, tetapi jika tidak memungkinkan, maka biarkan beberapa pod berjalan di tempat lain".</p><p>Afinitas node dinyatakan sebagai <em>field</em> <code>nodeAffinity</code> dari <em>field</em> <code>affinity</code> pada PodSpec.</p><p>Berikut ini contoh dari pod yang menggunakan afinitas node:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-with-node-affinity.yaml download=pods/pod-with-node-affinity.yaml><code>pods/pod-with-node-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-with-node-affinity-yaml")' title="Copy pods/pod-with-node-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-with-node-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/e2e-az-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- e2e-az1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- e2e-az2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>another-node-label-key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- another-node-label-value<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0</span></span></code></pre></div></div></div><p>Aturan afinitas node tersebut menyatakan pod hanya bisa ditugaskan pada node dengan label yang memiliki kunci <code>kubernetes.io/e2e-az-name</code> dan bernilai <code>e2e-az1</code> atau <code>e2e-az2</code>. Selain itu, dari semua node yang memenuhi kriteria tersebut, mode dengan label dengan kunci <code>another-node-label-key</code> and bernilai <code>another-node-label-value</code> harus lebih diutamakan.</p><p>Kamu dapat meilhat operator <code>In</code> digunakan dalam contoh berikut. Sitaksis afinitas node yang baru mendukung operator-operator berikut: <code>In</code>, <code>NotIn</code>, <code>Exists</code>, <code>DoesNotExist</code>, <code>Gt</code>, <code>Lt</code>. Kamu dapat menggunakan <code>NotIn</code> dan <code>DoesNotExist</code> untuk mewujudkan perilaku node anti-afinitas, atau menggunakan <a href=/id/docs/concepts/scheduling-eviction/taint-and-toleration/>node taints</a> untuk menolak pod dari node tertentu.</p><p>Jika kamu menyatakan <code>nodeSelector</code> dan <code>nodeAffinity</code>. <em>keduanya</em> harus dipenuhi agar pod dapat dijadwalkan pada node kandidat.</p><p>Jika kamu menyatakan beberapa <code>nodeSelectorTerms</code> yang terkait dengan tipe <code>nodeAffinity</code>, maka pod akan dijadwalkan pada node <strong>jika salah satu</strong> dari <code>nodeSelectorTerms</code> dapat terpenuhi.</p><p>Jika kamu menyatakan beberapa <code>matchExpressions</code> yang terkait dengan <code>nodeSelectorTerms</code>, makan pod dapat dijadwalkan pada node <strong>hanya jika semua</strong> <code>matchExpressions</code> dapat terpenuhi.</p><p>Jika kamu menghapus atau mengubah label pada node tempat pod dijadwalkan, pod tidak akan dihapus. Dengan kata lain, pemilihan afinitas hanya bekerja pada saat waktu penjadwalan pod.</p><p><em>Field</em> <code>weight</code> pada <code>preferredDuringSchedulingIgnoredDuringExecution</code> berada pada rentang nilai 1-100. Untuk setiap node yang memenuhi semua persyaratan penjadwalan (permintaan sumber daya, pernyataan afinitas RequiredDuringScheduling, dll.), <em>scheduler</em> akan menghitung nilai jumlah dengan melakukan iterasi pada elemen-elemen dari <em>field</em> ini dan menambah "bobot" pada jumlah jika node cocok dengan MatchExpressions yang sesuai. Nilai ini kemudian digabungkan dengan nilai dari fungsi prioritas lain untuk node. Node dengan nilai tertinggi adalah node lebih diutamakan.</p><p>Untuk informasi lebih lanjut tentang afinitas node kamu dapat melihat <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/nodeaffinity.md>design doc</a>.</p><h3 id=afinitas-and-anti-afinitas-antar-pod-fitur-beta>Afinitas and anti-afinitas antar pod (fitur beta)</h3><p>Afinitas and anti-afinitas antar pod diperkenalkan pada Kubernetes 1.4. Afinitas and anti-afinitas antar pod memungkinkan kamu untuk membatasi node yang memenuhi syarat untuk penjadwalan pod <em>berdasarkan label-label pada pod yang sudah berjalan pada node</em> daripada berdasarkan label-label pada node. Aturan tersebut berbentuk "pod ini harus (atau, dalam kasus
anti-afinitas, tidak boleh) berjalan dalam X jika X itu sudah menjalankan satu atau lebih pod yang memenuhi aturan Y". Y dinyatakan sebagai sebuah LabelSelector dengan daftar namespace terkait; tidak seperti node, karena pod are namespaced (maka dari itu label-label pada pod diberi namespace secara implisit), sebuah label selector di atas label-label pod harus menentukan namespace yang akan diterapkan selector. Secara konsep X adalah domain topologi seperti node, rack, zona penyedia cloud, daerah penyedia cloud, dll. Kamu dapat menyatakannya menggunakan <code>topologyKey</code> yang merupakan kunci untuk label node yang digunakan sistem untuk menunjukkan domain topologi tersebut, contohnya lihat kunci label yang terdaftar di atas pada bagian <a href=#interlude-built-in-node-labels>Selingan: label node built-in</a>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Afinitas and anti-afinitas antar pod membutuhkan jumlah pemrosesan yang substansial yang dapat memperlambat penjadwalan pada klaster berukuran besar secara signifikan. Kami tidak merekomendasikan penggunaan mereka pada klaster yang berukuran lebih besar dari beberapa ratus node.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Anti-afinitas pod mengharuskan node untuk diberi label secara konsisten, misalnya setiap node dalam klaster harus memiliki label sesuai yang cocok dengan <code>topologyKey</code>. Jika sebagian atau semua node tidak memiliki label <code>topologyKey</code> yang dinyatakan, hal ini dapat menyebabkan perilaku yang tidak diinginkan.</div><p>Seperti afinitas node, ada dua tipe afinitas dan anti-afinitas pod, yaitu <code>requiredDuringSchedulingIgnoredDuringExecution</code> dan
<code>preferredDuringSchedulingIgnoredDuringExecution</code> yang menunjukan persyaratan "kuat" vs. "lemah". Lihat deskripsi pada bagian afinitas node sebelumnya.
Sebuah contoh dari afinitas <code>requiredDuringSchedulingIgnoredDuringExecution</code> adalah "Tempatkan bersamaan pod layanan A dan layanan B di zona yang sama, karena mereka banyak berkomunikasi satu sama lain"
dan contoh <code>preferDuringSchedulingIgnoredDuringExecution</code> anti-afinitas akan menjadi "sebarkan pod dari layanan ini di seluruh zona" (persyaratan kuat tidak masuk akal, karena kamu mungkin memiliki lebih banyak pod daripada zona).</p><p>Afinitas antar pod dinyatakan sebagai <em>field</em> <code>podAffinity</code> dari <em>field</em> <code>affinity</code> pada PodSpec dan anti-afinitas antar pod dinyatakan sebagai <em>field</em> <code>podAntiAffinity</code> dari <em>field</em> <code>affinity</code> pada PodSpec.</p><h4 id=contoh-pod-yang-menggunakan-pod-affinity>Contoh pod yang menggunakan pod affinity:</h4><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-with-pod-affinity.yaml download=pods/pod-with-pod-affinity.yaml><code>pods/pod-with-pod-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-with-pod-affinity-yaml")' title="Copy pods/pod-with-pod-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-with-pod-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- S1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>failure-domain.beta.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinityTerm</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- S2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>failure-domain.beta.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Afinitas pada pod tersebut menetapkan sebuah aturan afinitas pod dan aturan anti-afinitas pod. Pada contoh ini, <code>podAffinity</code> adalah <code>requiredDuringSchedulingIgnoredDuringExecution</code>
sementara <code>podAntiAffinity</code> adalah <code>preferredDuringSchedulingIgnoredDuringExecution</code>. Aturan afinitas pod menyatakan bahwa pod dapat dijadwalkan pada node hanya jika node tersebut berada pada zona yang sama dengan minimal satu pod yang sudah berjalan yang memiliki label dengan kunci "security" dan bernilai "S1". (Lebih detail, pod dapat berjalan pada node N jika node N memiliki label dengan kunci <code>failure-domain.beta.kubernetes.io/zone</code>dan nilai V sehingga ada minimal satu node dalam klaster dengan kunci <code>failure-domain.beta.kubernetes.io/zone</code> dan bernilai V yang menjalankan pod yang memiliki label dengan kunci "security" dan bernilai "S1".) Aturan anti-afinitas pod menyatakan bahwa pod memilih untuk tidak dijadwalkan pada sebuah node jika node tersebut sudah menjalankan pod yang memiliki label dengan kunci "security" dan bernilai "S2". (Jika <code>topologyKey</code> adalah <code>failure-domain.beta.kubernetes.io/zone</code> maka dapat diartikan bahwa pod tidak dapat dijadwalkan pada node jika node berada pada zona yang sama dengan pod yang memiliki label dengan kunci "security" dan bernilai "S2".) Lihat <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>design doc</a> untuk lebih banyak contoh afinitas dan anti-afinitas pod, baik <code>requiredDuringSchedulingIgnoredDuringExecution</code>
maupun <code>preferredDuringSchedulingIgnoredDuringExecution</code>.</p><p>Operator yang sah untuk afinitas dan anti-afinitas pod adalah <code>In</code>, <code>NotIn</code>, <code>Exists</code>, <code>DoesNotExist</code>.</p><p>Pada dasarnya, <code>topologyKey</code> dapat berupa label-kunci apapun yang sah. Namun, untuk alasan performa dan keamanan, ada beberapa batasan untuk <code>topologyKey</code>:</p><ol><li>Untuk afinitas and anti-afinitas pod <code>requiredDuringSchedulingIgnoredDuringExecution</code>, <code>topologyKey</code> tidak boleh kosong.</li><li>Untuk anti-afinitas pod <code>requiredDuringSchedulingIgnoredDuringExecution</code>, pengontrol penerimaan <code>LimitPodHardAntiAffinityTopology</code> diperkenalkan untuk membatasi <code>topologyKey</code> pada <code>kubernetes.io/hostname</code>. Jika kamu menginginkan untuk membuatnya tersedia untuk topologi khusus, kamu dapat memodifikasi pengontrol penerimaan, atau cukup menonaktifkannya saja.</li><li>Untuk anti-afinitas pod <code>preferredDuringSchedulingIgnoredDuringExecution</code>, <code>topologyKey</code> yang kosong diinterpretasikan sebagai "semua topologi" ("semua topologi" sekarang dibatasi pada kombinasi dari <code>kubernetes.io/hostname</code>, <code>failure-domain.beta.kubernetes.io/zone</code> dan <code>failure-domain.beta.kubernetes.io/region</code>).</li><li>Kecuali untuk kasus-kasus di atas, <code>topologyKey</code> dapat berupa label-kunci apapun yang sah.</li></ol><p>Sebagai tambahan untuk <code>labelSelector</code> and <code>topologyKey</code>, kamu secara opsional dapat menyatakan daftar <code>namespaces</code> dari namespaces yang akan digunakan untuk mencocokan <code>labelSelector</code> (daftar ini berjalan pada level definisi yang sama dengan <code>labelSelector</code> dan <code>topologyKey</code>)</p><p>Jika dihilangkan atau kosong, daftar ini sesuai standar akan merujuk pada <em>namespace</em> dari pod tempat definisi afinitas/anti-afinitas dinyatakan.</p><p>Semua <code>matchExpressions</code> berkaitan dengan afinitas and anti-afinitas <code>requiredDuringSchedulingIgnoredDuringExecution</code> harus dipenuhi agar pod dapat dijadwalkan pada node.</p><h4 id=penggunaan-yang-lebih-praktikal>Penggunaan yang lebih praktikal</h4><p>Afinitas and anti-afinitas antar pod dapat menjadi lebih berguna saat digunakan bersamaan dengan koleksi dengan level yang lebih tinggi seperti ReplicaSets, StatefulSets, Deployments, dll. Pengguna dapat dengan mudah mengkonfigurasi bahwa satu set workload harus
ditempatkan bersama dalam topologi yang didefinisikan sama, misalnya, node yang sama.</p><h5 id=selalu-ditempatkan-bersamaan-pada-node-yang-sama>Selalu ditempatkan bersamaan pada node yang sama</h5><p>Dalam klaster berisi 3 node, sebuah aplikasi web memiliki in-memory cache seperti redis. Kita menginginkan agar <em>web-server</em> dari aplikasi ini sebisa mungkin ditempatkan bersamaan dengan cache.</p><p>Berikut ini kutipan yaml dari deployment redis sederhana dengan 3 replika dan label selector <code>app=store</code>, Deployment memiliki konfigurasi <code>PodAntiAffinity</code> untuk memastikan <em>scheduler</em> tidak menempatkan replika bersamaan pada satu node.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-cache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis:3.2-alpine<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kutipan yaml dari deployment webserver berikut ini memiliki konfigurasi <code>podAntiAffinity</code> dan <code>podAffinity</code>. Konfigurasi ini menginformasikan scheduler bahwa semua replika harus ditempatkan bersamaan dengan pod yang memiliki label selector <code>app=store</code>. Konfigurasi ini juga memastikan bahwa setiap replika webserver tidak ditempatkan bersamaan pada satu node.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>- web-store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.12-alpine<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika kita membuat kedua dployment di atas, klaster berisi 3 node kita seharusnya menjadi seperti berikut.</p><table><thead><tr><th style=text-align:center>node-1</th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center><em>webserver-1</em></td><td style=text-align:center><em>webserver-2</em></td><td style=text-align:center><em>webserver-3</em></td></tr><tr><td style=text-align:center><em>cache-1</em></td><td style=text-align:center><em>cache-2</em></td><td style=text-align:center><em>cache-3</em></td></tr></tbody></table><p>st
Seperti yang kamu lihat, semua 3 replika dari <code>web-server</code> secara otomatis ditempatkan bersama dengan cache seperti yang diharapkan.</p><pre tabindex=0><code>$ kubectl get pods -o wide
NAME                           READY     STATUS    RESTARTS   AGE       IP           NODE
redis-cache-1450370735-6dzlj   1/1       Running   0          8m        10.192.4.2   kube-node-3
redis-cache-1450370735-j2j96   1/1       Running   0          8m        10.192.2.2   kube-node-1
redis-cache-1450370735-z73mh   1/1       Running   0          8m        10.192.3.1   kube-node-2
web-server-1287567482-5d4dz    1/1       Running   0          7m        10.192.2.3   kube-node-1
web-server-1287567482-6f7v5    1/1       Running   0          7m        10.192.4.3   kube-node-3
web-server-1287567482-s330j    1/1       Running   0          7m        10.192.3.2   kube-node-2
</code></pre><h5 id=tidak-akan-pernah-ditempatkan-bersamaan-dalam-node-yang-sama>Tidak akan pernah ditempatkan bersamaan dalam node yang sama</h5><p>Contoh di atas menggunakan aturan <code>PodAntiAffinity</code> dengan <code>topologyKey: "kubernetes.io/hostname"</code> untuk melakukan deploy klaster redis sehingga tidak ada dua instance terletak pada hos yang sama.
Lihat <a href=/docs/tutorials/stateful-application/zookeeper/#tolerating-node-failure>tutorial ZooKeeper</a> untuk contoh dari konfigurasi StatefulSet dengan anti-afinitas untuk ketersediaan tinggi, menggunakan teknik yang sama.</p><p>Untuk informasi lebih lanjut tentang afinitas/anti-afinitas antar pod, lihat <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>design doc</a>.</p><p>Kamu juga dapat mengecek <a href=/id/docs/concepts/scheduling-eviction/taint-and-toleration/>Taints</a>, yang memungkinkan sebuah <em>node</em> untuk <em>menolak</em> sekumpulan pod.</p><h2 id=nodename>nodeName</h2><p><code>nodeName</code> adalah bentuk paling sederhana dari pembatasan pemilihan node, tetapi karena
keterbatasannya biasanya tidak digunakan. <code>nodeName</code> adalah sebuah <em>field</em> dari
PodSpec. Jika tidak kosong, scheduler mengabaikan pod dan
kubelet yang berjalan pada node tersebut yang mencoba menjalankan pod. Maka, jika
<code>nodeName</code> disediakan dalam PodSpec, ia memiliki hak yang lebih tinggi dibanding metode-metode di atas untuk pemilihan node.</p><p>Beberapa keterbatasan dari penggunaan <code>nodeName</code> untuk memilih node adalah:</p><ul><li>Jika node yang disebut tidak ada, maka pod tidak akan dijalankan, dan dalam beberapa kasus akan
dihapus secara otomatis.</li><li>Jika node yang disebut tidak memiliki resource yang cukup untuk mengakomodasi pod, pod akan gagal
dan alasannya akan mengindikasikan sebab kegagalan, misalnya OutOfmemory atau OutOfcpu.</li><li>Nama node pada lingkungan cloud tidak selalu dapat diprediksi atau stabil.</li></ul><p>Berikut ini contoh konfigurasi pod menggunakan <em>field</em> <code>nodeName</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>kube-01<span style=color:#bbb>
</span></span></span></code></pre></div><p>Pod di atas akan berjalan pada node kube-01.</p><h2 id=selanjutnya>Selanjutnya</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-ede4960b56a3529ee0bfe7c8fe2d09a5>4 - Taint dan Toleration</h1><p>Afinitas Node, seperti yang dideskripsikan <a href=/id/docs/concepts/configuration/assign-pod-node/#node-affinity-beta-feature>di sini</a>,
adalah salah satu properti dari Pod yang menyebabkan pod tersebut memiliki preferensi
untuk ditempatkan di sekelompok Node tertentu (preferensi ini dapat berupa <em>soft constraints</em> atau
<em>hard constraints</em> yang harus dipenuhi). <em>Taint</em> merupakan kebalikan dari afinitas --
properti ini akan menyebabkan Pod memiliki preferensi untuk tidak ditempatkan pada sekelompok Node tertentu.</p><p><em>Taint</em> dan <em>toleration</em> bekerja sama untuk memastikan Pod dijadwalkan pada Node
yang sesuai. Satu atau lebih <em>taint</em> akan diterapkan pada suatu node; hal ini akan menyebabkan
node tidak akan menerima pod yang tidak mengikuti <em>taint</em> yang sudah diterapkan.</p><h2 id=konsep>Konsep</h2><p>Kamu dapat menambahkan <em>taint</em> pada sebuah <em>node</em> dengan menggunakan perintah <a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a>.
Misalnya,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key</span><span style=color:#666>=</span>value:NoSchedule
</span></span></code></pre></div><p>akan menerapkan <em>taint</em> pada <em>node</em> <code>node1</code>. <em>Taint</em> tersebut memiliki <em>key</em> <code>key</code>, <em>value</em> <code>value</code>,
dan <em>effect</em> <em>taint</em> <code>NoSchedule</code>. Hal ini artinya pod yang ada tidak akan dapat dijadwalkan pada <code>node1</code>
kecuali memiliki <em>taint</em> yang sesuai.</p><p>Untuk menghilangkan <em>taint</em> yang ditambahkan dengan perintah di atas, kamu dapat menggunakan
perintah di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 key:NoSchedule-
</span></span></code></pre></div><p>Kamu dapat memberikan spesifikasi <em>toleration</em> untuk <em>pod</em> pada bagian PodSpec.
Kedua <em>toleration</em> yang diterapkan di bawa ini "sesuai" dengan <em>taint</em> yang
<em>taint</em> yang dibuat dengan perintah <code>kubectl taint</code> di atas, sehingga sebuah <em>pod</em>
dengan <em>toleration</em> yang sudah didefinisikan akan mampu di-<em>schedule</em> ke node <code>node</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Sebuah <em>toleration</em> "sesuai" dengan sebuah <em>taint</em> jika <em>key</em> dan efek yang
ditimbulkan sama:</p><ul><li><code>operator</code> dianggap <code>Exists</code> (pada kasus dimana tidak ada <code>value</code> yang diberikan), atau</li><li><code>operator</code> dianggap <code>Equal</code> dan <code>value</code> yang ada sama</li></ul><p><code>Operator</code> bernilai <code>Equal</code> secara <em>default</em> jika tidak diberikan spesifikasi khusus.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Terdapat dua kasus khusus:</p><ul><li>Sebuah <code>key</code> dengan operator <code>Exists</code> akan sesuai dengan semua <em>key</em>, <em>value</em>, dan <em>effect</em> yang ada.
Dengan kata lain, <em>tolaration</em> ini akan menerima semua hal yang diberikan.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li>Sebuah <code>effect</code> yang kosong akan dianggap sesuai dengan semua <em>effect</em> dengan <em>key</em> <code>key</code>.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div><p>Contoh yang diberikan di atas menggunakan <code>effect</code> untuk <code>NoSchedule</code>.
Alternatif lain yang dapat digunakan adalah <code>effect</code> untuk <code>PreferNoSchedule</code>.
<code>PreferNoSchedule</code> merupakan "preferensi" yang lebih fleksibel dari <code>NoSchedule</code> --
sistem akan mencoba untuk tidak menempatkan pod yang tidak menoleransi <em>taint</em>
pada <em>node</em>, tapi hal ini bukan merupakan sesuatu yang harus dipenuhi. Jenis ketiga
dari <code>effect</code> adalah <code>NoExecute</code>, akan dijelaskan selanjutnya.</p><p>Kamu dapat menerapkan beberapa <em>taint</em> sekaligus pada <em>node</em> atau
beberapa <em>toleration</em> sekaligus pada sebuah <em>pod</em>. Mekanisme Kubernetes dapat
memproses beberapa <em>taint</em> dan <em>toleration</em> sekaligus sama halnya seperti sebuah
<em>filter</em>: memulai dengan <em>taint</em> yang ada pada <em>node</em>, kemudian mengabaikan
<em>taint</em> yang sesuai pada pod yang memiliki <em>toleration</em> yang sesuai; kemudian
<em>taint</em> yang diterapkan pada pod yang sudah disaring tadi akan menghasilkan suatu
<em>effect</em> pada pod. Secara khusus:</p><ul><li>jika terdapat <em>taint</em> yang tidak tersaring dengan <em>effect</em> <code>NoSchedule</code> maka Kubernetes tidak akan menempatkan
<em>pod</em> pada <em>node</em> tersebut</li><li>jika tidak terdapat <em>taint</em> yang tidak tersaring dengan <em>effect</em> <code>NoSchedule</code>
tapi terdapat setidaknya satu <em>taint</em> yang tidak tersaring dengan
<em>effect</em> <code>PreferNoSchedule</code> maka Kubernetes akan mencoba untuk tidak akan menempatkan
<em>pod</em> pada <em>node</em> tersebut</li><li>jika terdapat <em>taint</em> yang tidak tersaring dengan <em>effect</em> <code>NoExecute</code> maka <em>pod</em> akan
berada dalam kondisi <em>evicted</em> dari <em>node</em> (jika <em>pod</em> tersebut sudah terlanjur ditempatkan pada <em>node</em>
tersebut), dan tidak akan di-<em>schedule</em> lagi pada <em>node</em> tersebut.</li></ul><p>Sebagai contoh, bayangkan kamu memberikan <em>taint</em> pada <em>node</em> sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule
</span></span><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoExecute
</span></span><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key2</span><span style=color:#666>=</span>value2:NoSchedule
</span></span></code></pre></div><p>Dan <em>pod</em> memiliki dua <em>toleration</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Pada kasus ini, <em>pod</em> tidak akan di-<em>schedule</em> pada <em>node</em>, karena tidak ada
<em>toleration</em> yang sesuai dengan <em>taint</em> ketiga. Akan tetapi, <em>pod</em> yang sebelumnya
sudah dijalankan di <em>node</em> dimana <em>taint</em> ditambahkan akan tetap jalan, karena <em>taint</em>
ketiga merupakan <em>taint</em> yang tidak ditoleransi oleh <em>pod</em>.</p><p>Pada umumnya, jika sebuah <em>taint</em> memiliki <em>effect</em> <code>NoExecute</code> ditambahkan pada <em>node</em>,
maka semua pod yang tidak menoleransi <em>taint</em> tersebut akan berada dalam <em>state</em>
<em>evicted</em> secara langsung, dan semua <em>pod</em> yang menoleransi <em>taint</em> tersebut
tidak akan berjalan seperti biasanya (tidak dalam <em>state</em> <em>evicted</em>). Meskipun demikian,
<em>toleration</em> dengan <em>effect</em> <code>NoExecute</code> dapat dispesfikasikan sebagai <em>field</em> opsional
<code>tolerationSeconds</code> yang memberikan perintah berapa lama suatu <em>pod</em> akan berada
pada <em>node</em> apabila sebuah <em>taint</em> ditambahkan. Contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>ini berarti apabila sebuah <em>pod</em> sedang dalam berada dalam <em>state</em> <em>running</em>,
kemudian sebuah <em>taint</em> yang sesuai ditambahkan pada <em>node</em>, maka <em>pod</em> tersebut
akan tetap berada di dalam <em>node</em> untuk periode 3600 detik sebelum <em>state</em>-nya
berubah menjadi <em>evicted</em>. Jika <em>taint</em> dihapus sebelum periode tersebut, maka <em>pod</em>
tetap berjalan sebagaimana mestinya.</p><h2 id=contoh-penggunaan>Contoh Penggunaan</h2><p><em>Taint</em> dan <em>toleration</em> adalah mekanisme fleksibel yang digunakan untuk
memaksa <em>pod</em> agar tidak dijadwalkan pada <em>node-node</em> tertentu atau
mengubah <em>state</em> <em>pod</em> menjadi <em>evicted</em>. Berikut adalah beberapa contoh penggunaannya:</p><ul><li><p><strong>Node-Node yang Sifatnya <em>Dedicated</em></strong>: Jika kamu ingin menggunakan
sekumpulan <em>node</em> dengan penggunaan eksklusif dari sekumpulan pengguna,
kamu dapat menambahkan <em>taint</em> pada <em>node-node</em> tersebut (misalnya,
<code>kubectl taint nodes nodename dedicated=groupName:NoSchedule</code>) dan kemudian
menambahkan <em>toleration</em> yang sesuai pada <em>pod-pod</em> yang berada di dalamnya (hal ini
dapat dilakukan dengan mudah dengan cara menulis
<a href=/docs/reference/access-authn-authz/admission-controllers/><em>admission controller</em></a> yang
bersifat khusus). <em>Pod-pod</em> dengan <em>toleration</em> nantinya akan diperbolehkannya untuk menggunakan
<em>node</em> yang sudah di-<em>taint</em> (atau dengan kata lain didedikasikan penggunaannya) maupun
<em>node</em> lain yang ada di dalam klaster. Jika kamu ingin mendedikasikan <em>node</em> khusus
yang hanya digunakan oleh <em>pod-pod</em> tadi serta memastikan <em>pod-pod</em> tadi hanya menggunakan
<em>node</em> yang didedikasikan, maka kamu harus menambahkan sebuah <em>label</em> yang serupa dengan
<em>taint</em> yang diberikan pada sekelompok <em>node</em> (misalnya, <code>dedicated=groupName</code>), dan
<em>admission controller</em> sebaiknya menambahkan afininitas <em>node</em> untuk memastikan <em>pod-pod</em>
tadi hanya dijadwalkan pada <em>node</em> dengan <em>label</em> <code>dedicated=groupName</code>.</p></li><li><p><strong>Node-Node dengan Perangkat Keras Khusus</strong>: Pada suatu klaster dimana
sebagian kecuali <em>node</em> memiliki perangkat keras khusus (misalnya GPU), kita ingin
memastikan hanya <em>pod-pod</em> yang membutuhkan GPU saja yang dijadwalkan di <em>node</em> dengan GPU.
Hal ini dapat dilakukan dengan memberikan <em>taint</em> pada <em>node</em> yang memiliki perangkat keras
khusus (misalnya, <code>kubectl taint nodes nodename special=true:NoSchedule</code> atau
<code>kubectl taint nodes nodename special=true:PreferNoSchedule</code>) serta menambahkan <em>toleration</em>
yang sesuai pada <em>pod</em> yang menggunakan <em>node</em> dengan perangkat keras khusus. Seperti halnya pada
kebutuhan <em>dedicated</em> <em>node</em>, hal ini dapat dilakukan dengan mudah dengan cara menulis
<a href=/docs/reference/access-authn-authz/admission-controllers/><em>admission controller</em></a> yang
bersifat khusus. Misalnya, kita dapat menggunakan <a href=/id/docs/concepts/configuration/manage-compute-resources-container/#extended-resources><em>Extended Resource</em></a>
untuk merepresentasikan perangkat keras khusus, kemudian <em>taint</em> <em>node</em> dengan perangkat keras khusus
dengan nama <em>extended resource</em> dan jalankan <em>admission controller</em>
<a href=/docs/reference/access-authn-authz/admission-controllers/#extendedresourcetoleration>ExtendedResourceToleration</a>.
Setelah itu, karena <em>node</em> yang ada sudah di-<em>taint</em>, maka tidak akan ada <em>pod</em> yang
tidak memiliki <em>toleration</em> yang akan dijadwalkan pada <em>node</em> tersebut_.
Meskipun begitu, ketika kamu membuat suatu <em>pod</em> yang membutuhkan <em>extended resource</em>,
maka <em>admission controller</em> dari <code>ExtendedResourceToleration</code> akan mengoreksi
<em>toleration</em> sehingga <em>pod</em> tersebut dapat dijadwalkan pada <em>node</em> dengan perangkat keras khusus.
Dengan demikian, kamu tidak perlu menambahkan <em>toleration</em> secara manual pada pod yang ada.</p></li><li><p><strong><em>Eviction</em> berbasis <em>Taint</em> (fitur beta)</strong>: Konfigurasi <em>eviction</em> per <em>pod</em>
yang terjadi ketika <em>pod</em> mengalami gangguan, hal ini akan dibahas lebih lanjut di bagian
selanjutnya.</p></li></ul><h2 id=eviction-berbasis-taint><em>Eviction</em> berbasis <em>Taint</em></h2><p>Sebelumnya, kita sudah pernah membahas soal <em>effect</em> <em>taint</em> <code>NoExecute</code>,
yang memengaruhi <em>pod</em> yang sudah dijalankan dengan cara sebagai berikut:</p><ul><li><em>pod</em> yang tidak menoleransi <em>taint</em> akan segera diubah <em>state</em>-nya menjadi <em>evicted</em></li><li><em>pod</em> yang menoleransi <em>taint</em> yang tidak menspesifikasikan <code>tolerationSeconds</code> pada
spesifikasi <em>toleration</em> yang ada akan tetap berada di dalam <em>node</em> tanpa adanya batas waktu tertentu</li><li><em>pod</em> yang menoleransi <em>taint</em> yang menspesifikasikan <code>tolerationSeconds</code>
spesifikasi <em>toleration</em> yang ada akan tetap berada di dalam <em>node</em> hingga batas waktu tertentu</li></ul><p>Sebagai tambahan, Kubernetes 1.6 memperkenalkan dukungan alfa untuk merepresentasikan
<em>node</em> yang bermasalah. Dengan kata lain, <em>node controller</em> akan secara otomatis memberikan <em>taint</em>
pada sebuah <em>node</em> apabila <em>node</em> tersebut memenuhi kriteria tertentu. Berikut merupakan <em>taint</em>
yang secara <em>default</em> disediakan:</p><ul><li><code>node.kubernetes.io/not-ready</code>: <em>Node</em> berada dalam <em>state</em> <em>not ready</em>. Hal ini terjadi apabila
<em>value</em> dari <em>NodeCondition</em> <code>Ready</code> adalah "<code>False</code>".</li><li><code>node.kubernetes.io/unreachable</code>: <em>Node</em> berada dalam <em>state</em> <em>unreachable</em> dari <em>node controller</em>
Hal ini terjadi apabila <em>value</em> dari <em>NodeCondition</em> <code>Ready</code> adalah "<code>Unknown</code>".</li><li><code>node.kubernetes.io/out-of-disk</code>: <em>Node</em> kehabisan kapasitas <em>disk</em>.</li><li><code>node.kubernetes.io/memory-pressure</code>: <em>Node</em> berada diambang kapasitas memori.</li><li><code>node.kubernetes.io/disk-pressure</code>: <em>Node</em> berada diambang kapasitas <em>disk</em>.</li><li><code>node.kubernetes.io/network-unavailable</code>: Jaringan pada <em>Node</em> bersifat <em>unavailable</em>.</li><li><code>node.kubernetes.io/unschedulable</code>: <em>Node</em> tidak dapat dijadwalkan.</li><li><code>node.cloudprovider.kubernetes.io/uninitialized</code>: Ketika <em>kubelet</em> dijalankan dengan
penyedia layanan <em>cloud</em> "eksternal", <em>taint</em> ini akan diterapkan pada <em>node</em> untuk menandai
<em>node</em> tersebut tidak digunakan. Setelah kontroler dari <em>cloud-controller-manager</em> melakukan
inisiasi <em>node</em> tersebut, maka <em>kubelet</em> akan menghapus <em>taint</em> yang ada.</li></ul><p>Pada versi 1.13, fitur <code>TaintBasedEvictions</code> diubah menjadi beta dan diaktifkan secara <em>default</em>,
dengan demikian <em>taint-taint</em> tersebut secara otomatis ditambahkan oleh <em>NodeController</em> (atau <em>kubelet</em>)
dan logika normal untuk melakukan <em>eviction</em> pada <em>pod</em> dari suatu <em>node</em> tertentu berdasarkan <em>value</em>
dari <em>Ready</em> yang ada pada <em>NodeCondition</em> dinonaktifkan.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk menjaga perilaku <a href=/id/docs/concepts/architecture/nodes/><em>rate limiting</em></a> yang
ada pada <em>eviction</em> <em>pod</em> apabila <em>node</em> mengalami masalah, sistem sebenarnya menambahkan
<em>taint</em> dalam bentuk <em>rate limiter</em>. Hal ini mencegah <em>eviction</em> besar-besaran pada <em>pod</em>
pada skenario dimana master menjadi terpisah dari <em>node</em> lainnya.</div><p>Fitur beta ini, bersamaan dengan <code>tolerationSeconds</code>, mengizinkan sebuah <em>pod</em>
untuk menspesifikasikan berapa lama <em>pod</em> harus tetap sesuai dengan sebuah <em>node</em>
apabila <em>node</em> tersebut bermasalah.</p><p>Misalnya, sebuah aplikasi dengan banyak <em>state</em> lokal akan lebih baik untuk tetap
berada di suatu <em>node</em> pada saat terjadi partisi jaringan, dengan harapan partisi jaringan
tersebut dapat diselesaikan dan mekanisme <em>eviction</em> <em>pod</em> tidak akan dilakukan.
<em>Toleration</em> yang ditambahkan akan berbentuk sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;node.kubernetes.io/unreachable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>6000</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Perhatikan bahwa Kubernetes secara otomatis menambahkan <em>toleration</em> untuk
<code>node.kubernetes.io/not-ready</code> dengan <code>tolerationSeconds=300</code>
kecuali konfigurasi lain disediakan oleh pengguna.
Kubernetes juga secara otomatis menambahkan <em>toleration</em> untuk
<code>node.kubernetes.io/unreachable</code> dengan <code>tolerationSeconds=300</code>
kecuali konfigurasi lain disediakan oleh pengguna.</p><p><em>Toleration</em> yang ditambahkan secara otomatis ini menjamin bahwa
perilaku <em>default</em> dari suatu <em>pod</em> adalah tetap bertahan selama 5 menit pada
<em>node</em> apabila salah satu masalah terdeteksi.
Kedua <em>toleration</em> <em>default</em> tadi ditambahkan oleh <a href=https://git.k8s.io/kubernetes/plugin/pkg/admission/defaulttolerationseconds>DefaultTolerationSeconds
<em>admission controller</em></a>.</p><p><em>Pod-pod</em> pada <a href=/id/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a> dibuat dengan <em>toleration</em>
<code>NoExecute</code> untuk <em>taint</em> tanpa <code>tolerationSeconds</code>:</p><ul><li><code>node.kubernetes.io/unreachable</code></li><li><code>node.kubernetes.io/not-ready</code></li></ul><p>Hal ini menjamin <em>pod-pod</em> yang merupakan bagian dari DaemonSet tidak pernah berada di dalam
<em>state</em> <em>evicted</em> apabila terjadi permasalahan pada <em>node</em>.</p><h2 id=taint-pada-node-berdasarkan-kondisi-tertentu><em>Taint</em> pada <em>Node</em> berdasarkan Kondisi Tertentu</h2><p>Pada versi 1.12, fitur <code>TaintNodesByCondition</code> menjadi fitur beta, dengan demikian <em>lifecycle</em>
dari kontroler <em>node</em> akan secara otomatis menambahkan <em>taint</em> sesuai dengan kondisi <em>node</em>.
Hal yang sama juga terjadi pada <em>scheduler</em>, <em>scheduler</em> tidak bertugas memeriksa kondisi <em>node</em>
tetapi kondisi <em>taint</em>. Hal ini memastikan bahwa kondisi <em>node</em> tidak memengaruhi apa
yang dijadwalkan di <em>node</em>. Pengguna dapat memilih untuk mengabaikan beberapa permasalahan yang
ada pada <em>node</em> (yang direpresentasikan oleh kondisi <em>Node</em>) dengan menambahkan <em>toleration</em> <em>Pod</em> <code>NoSchedule</code>.
Sedangkan <em>taint</em> dengan <em>effect</em> <code>NoExecute</code> dikendalikan oleh <code>TaintBasedEviction</code> yang merupakan
fitur beta yang diaktifkan secara <em>default</em> oleh Kubernetes sejak versi 1.13.</p><p>Sejak Kubernetes versi 1.8, kontroler DaemonSet akan secara otomatis
menambahkan <em>toleration</em> <code>NoSchedule</code> pada semua <em>daemon</em> untuk menjaga
fungsionalitas DaemonSet.</p><ul><li><code>node.kubernetes.io/memory-pressure</code></li><li><code>node.kubernetes.io/disk-pressure</code></li><li><code>node.kubernetes.io/out-of-disk</code> (hanya untuk pod yang bersifat <em>critical</em>)</li><li><code>node.kubernetes.io/unschedulable</code> (versi 1.10 atau yang lebih baru)</li><li><code>node.kubernetes.io/network-unavailable</code> (hanya untuk jaringan <em>host</em>)</li></ul><p>Menambahkan <em>toleration</em> ini menjamin <em>backward compatibility</em>.
Kamu juga dapat menambahkan <em>toleration</em> lain pada DaemonSet.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-598f36d691ab197f9d995784574b0a12>5 - Penjadwal Kubernetes</h1><p>Dalam Kubernetes, <em>scheduling</em> atau penjadwalan ditujukan untuk memastikan
<a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> mendapatkan
<a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a> sehingga
<a class=glossary-tooltip title='Agen yang dijalankan pada setiap node di klaster yang bertugas untuk memastikan kontainer dijalankan di dalam Pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a> dapat menjalankannya.</p><h2 id=penjadwalan>Ikhtisar Penjadwalan</h2><p>Sebuah penjadwal mengawasi Pod yang baru saja dibuat dan belum ada Node yang
dialokasikan untuknya. Untuk setiap Pod yang ditemukan oleh penjadwal, maka
penjadwal tersebut bertanggung jawab untuk menemukan Node terbaik untuk
menjalankan Pod. Penjadwal dapat menetapkan keputusan penempatan ini dengan
mempertimbangkan prinsip-prinsip penjadwalan yang dijelaskan di bawah ini.</p><p>Jika kamu ingin memahami mengapa Pod ditempatkan pada Node tertentu, atau jika
kamu berencana untuk mengimplementasikan penjadwal kustom sendiri, halaman ini
akan membantu kamu belajar tentang penjadwalan.</p><h2 id=kube-scheduler>Kube-scheduler</h2><p><a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/><em>Kube-scheduler</em></a>
adalah penjadwal standar untuk Kubernetes dan dijalankan sebagai bagian dari
<a class=glossary-tooltip title='Merupakan lapisan orkestrasi Container yang mengekspos API dan antarmuka untuk mendefinisikan, menggelar, dan mengelola siklus hidup suatu Container.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='_control plane_'>_control plane_</a>.
<em>Kube-scheduler</em> dirancang agar jika kamu mau dan perlu, kamu bisa menulis
komponen penjadwalan kamu sendiri dan menggunakannya.</p><p>Untuk setiap Pod yang baru dibuat atau Pod yang tak terjadwal lainnya,
<em>kube-scheduler</em> memilih Node yang optimal untuk menjalankannya. Namun, setiap
kontainer masuk Pod memiliki persyaratan sumber daya yang berbeda dan setiap Pod
juga memiliki persyaratan yang berbeda juga. Oleh karena itu, Node yang ada
perlu dipilih sesuai dengan persyaratan khusus penjadwalan.</p><p>Dalam sebuah Klaster, Node yang memenuhi persyaratan penjadwalan untuk suatu Pod
disebut Node <em>feasible</em>. Jika tidak ada Node yang cocok, maka Pod tetap tidak
terjadwal sampai penjadwal yang mampu menempatkannya.</p><p>Penjadwal menemukan Node-Node yang layak untuk sebuah Pod dan kemudian
menjalankan sekumpulan fungsi untuk menilai Node-Node yang layak dan mengambil
satu Node dengan skor tertinggi di antara Node-Node yang layak untuk menjalankan
Pod. Penjadwal kemudian memberi tahu server API tentang keputusan ini dalam
proses yang disebut dengan <em>binding</em>.</p><p>Beberapa faktor yang perlu dipertimbangkan untuk keputusan penjadwalan termasuk
persyaratan sumber daya individu dan kolektif, aturan kebijakan / perangkat keras /
lunak, spesifikasi persamaan dan anti-persamaan, lokalitas data, interferensi
antar Workloads, dan sebagainya.</p><h3 id=kube-scheduler-implementation>Pemilihan node pada kube-scheduler</h3><p><em>Kube-scheduler</em> memilih node untuk pod dalam 2 langkah operasi:</p><ol><li>Filtering</li><li>Scoring</li></ol><p>Langkah <em>filtering</em> menemukan sekumpulan Nodes yang layak untuk menjadwalkan
Pod. Misalnya, penyarin PodFitsResources memeriksa apakah Node kandidat
memiliki sumber daya yang cukup untuk memenuhi permintaan spesifik sumber daya dari
Pod. Setelah langkah ini, daftar Node akan berisi Node-node yang sesuai;
seringkali, akan terisi lebih dari satu. Jika daftar itu kosong, maka Pod itu
tidak (belum) dapat dijadwalkan.</p><p>Pada langkah <em>scoring</em>, penjadwal memberi peringkat pada Node-node yang tersisa
untuk memilih penempatan paling cocok untuk Pod. Penjadwal memberikan skor
untuk setiap Node yang sudah tersaring, memasukkan skor ini pada aturan
penilaian yang aktif.</p><p>Akhirnya, <em>kube-scheduler</em> memberikan Pod ke Node dengan peringkat tertinggi.
Jika ada lebih dari satu node dengan skor yang sama, maka <em>kube-scheduler</em>
memilih salah satunya secara acak.</p><p>Ada dua cara yang didukung untuk mengkonfigurasi perilaku penyaringan dan
penilaian oleh penjadwal:</p><ol><li><a href=/docs/reference/scheduling/policies>Aturan Penjadwalan</a> yang memungkinkan
kamu untuk mengkonfigurasi <em>Predicates</em> untuk pemfilteran dan <em>Priorities</em>
untuk penilaian.</li><li><a href=/docs/reference/scheduling/profiles>Profil Penjadwalan</a> yang memungkinkan
kamu mengkonfigurasi <em>Plugin</em> yang menerapkan tahapan penjadwalan berbeda,
termasuk: <code>QueueSort</code>, <code>Filter</code>, <code>Score</code>, <code>Bind</code>, <code>Reserve</code>, <code>Permit</code>, dan
lainnya. Kamu juga bisa mengonfigurasi <em>kube-scheduler</em> untuk menjalankan
profil yang berbeda.</li></ol><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Baca tentang <a href=/id/docs/concepts/scheduling-eviction/scheduler-perf-tuning/>penyetelan performa penjadwal</a></li><li>Baca tentang <a href=/id/docs/concepts/workloads/pods/pod-topology-spread-constraints/>pertimbangan penyebarang topologi pod</a></li><li>Baca <a href=/docs/reference/command-line-tools-reference/kube-scheduler/>referensi dokumentasi</a> untuk <em>kube-scheduler</em></li><li>Pelajari tentang <a href=/docs/tasks/administer-cluster/configure-multiple-schedulers/>mengkonfigurasi beberapa penjadwal</a></li><li>Pelajari tentang <a href=/docs/tasks/administer-cluster/topology-manager/>aturan manajemen topologi</a></li><li>Pelajari tentang <a href=/id/docs/concepts/configuration/pod-overhead/>pengeluaran tambahan Pod</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-602208c95fe7b1f1170310ce993f5814>6 - Kerangka Kerja Penjadwalan (Scheduling Framework)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.15 [alpha]</code></div><p>Kerangka kerja penjadwalan (<em>Scheduling Framework</em>) adalah arsitektur yang dapat
dipasang (<em>pluggable</em>) pada penjadwal Kubernetes untuk membuat kustomisasi
penjadwal lebih mudah. Hal itu dilakukan dengan menambahkan satu kumpulan "plugin"
API ke penjadwal yang telah ada. <em>Plugin</em> dikompilasi ke dalam penjadwal.
Beberapa API memungkinkan sebagian besar fitur penjadwalan diimplementasikan
sebagai <em>plugin</em>, sambil tetap mempertahankan penjadwalan "inti" sederhana dan
terpelihara. Silahkan merujuk pada [proposal desain dari kerangka penjadwalan]
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md>kep</a> untuk informasi teknis lebih lanjut tentang desain kerangka kerja
tersebut.</p><h1 id=alur-kerja-kerangka-kerja>Alur kerja kerangka kerja</h1><p>Kerangka kerja penjadwalan mendefinisikan beberapa titik ekstensi. <em>Plugin</em> penjadwal
mendaftar untuk dipanggil di satu atau lebih titik ekstensi. Beberapa <em>plugin</em> ini
dapat mengubah keputusan penjadwalan dan beberapa hanya bersifat informasi.</p><p>Setiap upaya untuk menjadwalkan satu Pod dibagi menjadi dua fase, <strong>Siklus Penjadwalan (<em>Scheduling Cycle</em>)</strong> dan <strong>Siklus Pengikatan (<em>Binding Cycle</em>)</strong>.</p><h2 id=siklus-penjadwalan-dan-siklus-pengikatan>Siklus Penjadwalan dan Siklus Pengikatan</h2><p>Siklus penjadwalan memilih sebuah Node untuk Pod, dan siklus pengikatan menerapkan
keputusan tersebut ke klaster. Secara bersama-sama, siklus penjadwalan dan siklus
pengikatan diartikan sebagai sebuah "konteks penjadwalan (<em>scheduling context</em>)".</p><p>Siklus penjadwalan dijalankan secara serial, sementara siklus pengikatan dapat
berjalan secara bersamaan.</p><p>Siklus penjadwalan atau pengikatan dapat dibatalkan jika Pod telah ditentukan
untuk tidak terjadwalkan atau jika terdapat kesalahan internal. Pod akan
dikembalikan ke antrian dan dicoba lagi.</p><h2 id=titik-titik-ekstensi>Titik-titik ekstensi</h2><p>Gambar berikut menunjukkan konteks penjadwalan Pod dan titik-titik ekstensi
yang diperlihatkan oleh kerangka penjadwalan. Dalam gambar ini "Filter"
setara dengan "Predicate" dan "Scoring" setara dengan "Priority Function".</p><p>Satu <em>plugin</em> dapat mendaftar di beberapa titik ekstensi untuk melakukan pekerjaan
yang lebih kompleks atau <em>stateful</em>.</p><figure><img src=/images/docs/scheduling-framework-extensions.png><figcaption><h4>Titik-titik ekstensi dari kerangka kerja Penjadwalan</h4></figcaption></figure><h3 id=queue-sort>QueueSort</h3><p><em>Plugin</em> ini digunakan untuk mengurutkan Pod-Pod dalam antrian penjadwalan. <em>Plugin</em>
QueueSort pada dasarnya menyediakan fungsi <code>Less (Pod1, Pod2)</code>. Hanya satu jenis
<em>plugin</em> QueueSort yang dapat diaktifkan dalam waktu yang bersamaan.</p><h3 id=pre-filter>PreFilter</h3><p><em>Plugin</em> ini digunakan untuk melakukan pra-proses informasi tentang Pod, atau untuk
memeriksa tertentu kondisi yang harus dipenuhi oleh klaster atau Pod. Jika
<em>plugin</em> PreFilter menghasilkan hasil yang salah, siklus penjadwalan dibatalkan.</p><h3 id=filter>Filter</h3><p><em>Plugin</em> ini digunakan untuk menyaring Node yang tidak dapat menjalankan Pod.
Untuk setiap Node, penjadwal akan memanggil <em>plugin</em> Filter sesuai dengan urutan
mereka dikonfigurasi. Jika ada <em>plugin</em> Filter menandai Node menjadi <em>infeasible</em>,
maka <em>plugin</em> yang lainnya tidak akan dipanggil untuk Node itu. Node-Node dapat dievaluasi
secara bersamaan.</p><h3 id=post-filter>PostFilter</h3><p>Plugin ini disebut setelah fase Filter, tetapi hanya ketika tidak ada node yang layak
ditemukan untuk pod. Plugin dipanggil dalam urutan yang dikonfigurasi. Jika
plugin postFilter menandai node sebagai 'Schedulable', plugin yang tersisa
tidak akan dipanggil. Implementasi PostFilter yang khas adalah preemption, yang
mencoba membuat pod dapat di menjadwalkan dengan mendahului Pod lain.</p><h3 id=pre-score>PreScore</h3><p><em>Plugin</em> ini digunakan untuk melakukan pekerjaan "pra-penilaian", yang
menghasilkan keadaan yang dapat dibagi untuk digunakan oleh <em>plugin-plugin</em> Score.
Jika <em>plugin</em> PreScore mengeluarkan hasil salah, maka siklus penjadwalan dibatalkan.</p><h3 id=score>Score</h3><p><em>Plugin</em> ini digunakan untuk menentukan peringkat Node yang telah melewati fase
penyaringan. Penjadwal akan memanggil setiap <em>plugin</em> Score untuk setiap Node.
Akan ada kisaran bilangan bulat yang telah ditetapkan untuk mewakili skor
minimum dan maksimum. Setelah fase <a href=#normalize-scoring>NormalizeScore</a>,
penjadwal akan menggabungkan skor Node dari semua <em>plugin</em> sesuai dengan bobot
<em>plugin</em> yang telah dikonfigurasi.</p><h3 id=normalize-score>NormalizeScore</h3><p><em>Plugin</em> ini digunakan untuk memodifikasi skor sebelum penjadwal menghitung
peringkat akhir Node-Node. <em>Plugin</em> yang mendaftar untuk titik ekstensi ini akan
dipanggil dengan hasil <a href=#score>Score</a> dari <em>plugin</em> yang sama. Hal ini dilakukan
sekali untuk setiap <em>plugin</em> dan setiap siklus penjadwalan.</p><p>Sebagai contoh, anggaplah sebuah <em>plugin</em> <code>BlinkingLightScorer</code> memberi peringkat
pada Node-Node berdasarkan berapa banyak kedipan lampu yang mereka miliki.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>ScoreNode</span>(_ <span style=color:#666>*</span>v1.pod, n <span style=color:#666>*</span>v1.Node) (<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#0b0;font-weight:700>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>getBlinkingLightCount</span>(n)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Namun, jumlah maksimum kedipan lampu mungkin kecil jika dibandingkan dengan
<code>NodeScoreMax</code>. Untuk memperbaikinya, <code>BlinkingLightScorer</code> juga harus mendaftar
untuk titik ekstensi ini.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>NormalizeScores</span>(scores <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>    highest <span style=color:#666>:=</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> _, score <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> scores {
</span></span><span style=display:flex><span>        highest = <span style=color:#00a000>max</span>(highest, score)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> node, score <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> scores {
</span></span><span style=display:flex><span>        scores[node] = score<span style=color:#666>*</span>NodeScoreMax<span style=color:#666>/</span>highest
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Jika ada <em>plugin</em> NormalizeScore yang menghasilkan hasil yang salah, maka siklus
penjadwalan dibatalkan.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <em>Plugin</em> yang ingin melakukan pekerjaan "pra-pemesanan" harus menggunakan
titik ekstensi NormalizeScore.</div><h3 id=reserve>Reserve</h3><p>Ini adalah titik ekstensi yang bersifat informasi. <em>Plugin</em> yang mempertahankan
keadaan <em>runtime</em> (alias "<em>stateful plugins</em>") harus menggunakan titik ekstensi ini
untuk diberitahukan oleh penjadwal ketika sumber daya pada suatu Node dicadangkan
untuk Pod yang telah disiapkan. Proses ini terjadi sebelum penjadwal benar-benar
mengikat Pod ke Node, dan itu ada untuk mencegah kondisi balapan (<em>race conditions</em>)
ketika penjadwal menunggu agar pengikatan berhasil.</p><p>Ini adalah langkah terakhir dalam siklus penjadwalan. Setelah Pod berada dalam
status dicadangkan, maka itu akan memicu <em>plugin</em> <a href=#unreserve>Unreserve</a>
(apabila gagal) atau <em>plugin</em> <a href=#post-bind>PostBind</a> (apabila sukses)
di akhir siklus pengikatan.</p><h3 id=permit>Permit</h3><p><em>Plugin</em> Permit dipanggil pada akhir siklus penjadwalan untuk setiap Pod
untuk mencegah atau menunda pengikatan ke Node kandidat. <em>Plugin</em> Permit dapat
melakukan salah satu dari ketiga hal ini:</p><ol><li><p><strong>approve</strong><br>     Setelah semua <em>plugin</em> Permit menyetujui sebuah Pod, Pod tersebut akan dikirimkan untuk diikat.</p></li><li><p><strong>deny</strong><br>     Jika ada <em>plugin</em> Permit yang menolak sebuah Pod, Pod tersebut akan dikembalikan ke
antrian penjadwalan. Hal ini akan memicu <em>plugin</em> <a href=#unreserve>Unreserve</a>.</p></li><li><p><strong>wait</strong> (dengan batas waktu)<br>     Jika <em>plugin</em> Permit menghasilkan "wait", maka Pod disimpan dalam
     daftar Pod "yang menunggu" internal, dan siklus pengikatan Pod ini dimulai tetapi akan langsung diblokir
     sampai mendapatkan <a href=#frameworkhandle><em>approved</em></a>. Jika waktu tunggu habis, ** wait ** menjadi ** deny **
     dan Pod dikembalikan ke antrian penjadwalan, yang memicu <em>plugin</em> <a href=#unreserve>Unreserve</a>.</p></li></ol><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Ketika setiap <em>plugin</em> dapat mengakses daftar Pod-Pod "yang menunggu" dan menyetujuinya
(silahkan lihat <a href=#frameworkhandle><code>FrameworkHandle</code></a>), kami hanya mengharapkan
<em>plugin</em> Permit untuk menyetujui pengikatan Pod dalam kondisi "menunggu" yang
telah dipesan. Setelah Pod disetujui, akan dikirim ke fase <a href=#pre-bind>PreBind</a>.</div><h3 id=pre-bind>PreBind</h3><p><em>Plugin</em> ini digunakan untuk melakukan pekerjaan apa pun yang diperlukan sebelum
Pod terikat. Sebagai contoh, <em>plugin</em> PreBind dapat menyediakan <em>network volume</em>
dan melakukan <em>mounting</em> pada Node target sebelum mengizinkan Pod berjalan di
sana.</p><p>Jika ada <em>plugin</em> PreBind yang menghasilkan kesalahan, maka Pod <a href=#unreserve>ditolak</a>
dan kembali ke antrian penjadwalan.</p><h3 id=bind>Bind</h3><p><em>Plugin</em> ini digunakan untuk mengikat Pod ke Node. <em>Plugin-plugin</em> Bind tidak akan
dipanggil sampai semua <em>plugin</em> PreBind selesai. Setiap <em>plugin</em> Bind dipanggil
sesuai urutan saat dikonfigurasi. <em>Plugin</em> Bind dapat memilih untuk menangani
atau tidak Pod yang diberikan. Jika <em>plugin</em> Bind memilih untuk menangani Pod,
** <em>plugin</em> Bind yang tersisa dilewati **.</p><h3 id=post-bind>PostBind</h3><p>Ini adalah titik ekstensi bersifat informasi. <em>Plugin-plugin</em> PostBind dipanggil
setelah sebuah Pod berhasil diikat. Ini adalah akhir dari siklus pengikatan, dan
dapat digunakan untuk membersihkan sumber daya terkait.</p><h3 id=unreserve>Unreserve</h3><p>Ini adalah titik ekstensi bersifat informasi. Jika sebuah Pod telah dipesan dan
kemudian ditolak di tahap selanjutnya, maka <em>plugin-plugin</em> Unreserve akan
diberitahu. <em>Plugin</em> Unreserve harus membersihkan status yang terkait dengan Pod
yang dipesan.</p><p><em>Plugin</em> yang menggunakan titik ekstensi ini sebaiknya juga harus digunakan
<a href=#unreserve>Reserve</a>.</p><h2 id=plugin-api><em>Plugin</em> API</h2><p>Ada dua langkah untuk <em>plugin</em> API. Pertama, <em>plugin</em> harus mendaftar dan mendapatkan
konfigurasi, kemudian mereka menggunakan antarmuka titik ekstensi. Antarmuka (<em>interface</em>)
titik ekstensi memiliki bentuk sebagai berikut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> Plugin <span style=color:#a2f;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#00a000>Name</span>() <span style=color:#0b0;font-weight:700>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> QueueSortPlugin <span style=color:#a2f;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    Plugin
</span></span><span style=display:flex><span>    <span style=color:#00a000>Less</span>(<span style=color:#666>*</span>v1.pod, <span style=color:#666>*</span>v1.pod) <span style=color:#0b0;font-weight:700>bool</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> PreFilterPlugin <span style=color:#a2f;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    Plugin
</span></span><span style=display:flex><span>    <span style=color:#00a000>PreFilter</span>(context.Context, <span style=color:#666>*</span>framework.CycleState, <span style=color:#666>*</span>v1.pod) <span style=color:#0b0;font-weight:700>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>// ...
</span></span></span></code></pre></div><h2 id=konfigurasi-plugin>Konfigurasi <em>plugin</em></h2><p>Kamu dapat mengaktifkan atau menonaktifkan <em>plugin</em> dalam konfigurasi penjadwal.
Jika kamu menggunakan Kubernetes v1.18 atau yang lebih baru, kebanyakan
<a href=/docs/reference/scheduling/profiles/#scheduling-plugins>plugin-plugin penjadwalan</a>
sudah digunakan dan diaktifkan secara bawaan.</p><p>Selain <em>plugin-plugin</em> bawaan, kamu juga dapat mengimplementasikan <em>plugin-plugin</em> penjadwalan
kamu sendiri dan mengonfigurasinya bersama-sama dengan <em>plugin-plugin</em> bawaan.
Kamu bisa mengunjungi <a href=https://github.com/kubernetes-sigs/scheduler-plugins>plugin-plugin penjadwalan</a>
untuk informasi lebih lanjut.</p><p>Jika kamu menggunakan Kubernetes v1.18 atau yang lebih baru, kamu dapat
mengonfigurasi sekumpulan <em>plugin</em> sebagai profil penjadwal dan kemudian menetapkan
beberapa profil agar sesuai dengan berbagai jenis beban kerja. Pelajari lebih
lanjut di <a href=/docs/reference/scheduling/profiles/#multiple-profiles>multi profil</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d9574a30fcbc631b0d2a57850e161e89>7 - Penyetelan Kinerja Penjadwal</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [beta]</code></div><p><a href=/id/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler>kube-scheduler</a>
merupakan penjadwal (<em>scheduler</em>) Kubernetes bawaan yang bertanggung jawab
terhadap penempatan Pod-Pod pada seluruh Node di dalam sebuah klaster.</p><p>Node-Node di dalam klaster yang sesuai dengan syarat-syarat penjadwalan dari
sebuah Pod disebut sebagai Node-Node layak (<em>feasible</em>). Penjadwal mencari Node-Node
layak untuk sebuah Pod dan kemudian menjalankan fungsi-fungsi untuk menskor Node-Node tersebut, memilih sebuah Node dengan skor tertinggi di antara
Node-Node layak lainnya, di mana Pod akan dijalankan. Penjadwal kemudian memberitahu
API server soal keputusan ini melalui sebuah proses yang disebut <em>Binding</em>.</p><p>Laman ini menjelaskan optimasi penyetelan (<em>tuning</em>) kinerja yang relevan
untuk klaster Kubernetes berskala besar.</p><p>Pada klaster berskala besar, kamu bisa menyetel perilaku penjadwal
untuk menyeimbangkan hasil akhir penjadwalan antara latensi (seberapa cepat Pod-Pod baru ditempatkan)
dan akurasi (seberapa akurat penjadwal membuat keputusan penjadwalan yang tepat).</p><p>Kamu bisa mengonfigurasi setelan ini melalui pengaturan <code>percentageOfNodesToScore</code> pada kube-scheduler.
Pengaturan KubeSchedulerConfiguration ini menentukan sebuah ambang batas untuk
penjadwalan Node-Node di dalam klaster kamu.</p><h3 id=pengaturan-ambang-batas>Pengaturan Ambang Batas</h3><p>Opsi <code>percentageOfNodesToScore</code> menerima semua angka numerik antara 0 dan 100.
Angka 0 adalah angka khusus yang menandakan bahwa kube-scheduler harus menggunakan
nilai bawaan.
Jika kamu mengatur <code>percentageOfNodesToScore</code> dengan angka di atas 100, kube-scheduler
akan membulatkan ke bawah menjadi 100.</p><p>Untuk mengubah angkanya, sunting berkas konfigurasi kube-scheduler (biasanya <code>/etc/kubernetes/config/kube-scheduler.yaml</code>),
lalu <em>ulang kembali</em> kube-scheduler.</p><p>Setelah kamu selesai menyunting, jalankan perintah</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get componentstatuses
</span></span></code></pre></div><p>untuk memverifikasi komponen kube-scheduler berjalan dengan baik (<em>healthy</em>). Keluarannya kira-kira seperti ini:</p><pre tabindex=0><code>NAME                 STATUS    MESSAGE             ERROR
controller-manager   Healthy   ok
scheduler            Healthy   ok
...
</code></pre><h2 id=persentase-penskoran-node>Ambang Batas Penskoran Node</h2><p>Untuk meningkatan kinerja penjadwalan, kube-scheduler dapat berhenti mencari
Node-Node yang layak saat sudah berhasil menemukannya. Pada klaster berskala besar,
hal ini menghemat waktu dibandingkan dengan pendekatan awam yang mengecek setiap Node.</p><p>Kamu bisa mengatur ambang batas untuk menentukan berapa banyak jumlah Node minimal yang dibutuhkan, sebagai
persentase bagian dari seluruh Node di dalam klaster kamu. kube-scheduler akan mengubahnya menjadi
bilangan bulat berisi jumlah Node. Saat penjadwalan, jika kube-scheduler mengidentifikasi
cukup banyak Node-Node layak untuk melewati jumlah persentase yang diatur, maka kube-scheduler
akan berhenti mencari Node-Node layak dan lanjut ke [fase penskoran] (/id/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler-implementation).</p><p><a href=#bagaimana-penjadwal-mengecek-node>Bagaimana penjadwal mengecek Node</a> menjelaskan proses ini secara detail.</p><h3 id=ambang-batas-bawaan>Ambang Batas Bawaan</h3><p>Jika kamu tidak mengatur sebuah ambang batas, maka Kubernetes akan
menghitung sebuah nilai menggunakan pendekatan linier, yaitu 50% untuk klaster dengan 100 Node,
serta 10% untuk klaster dengan 5000 Node.</p><p>Artinya, kube-scheduler selalu menskor paling tidak 5% dari klaster kamu, terlepas dari
seberapa besar klasternya, kecuali kamu secara eksplisit mengatur <code>percentageOfNodesToScore</code>
menjadi lebih kecil dari 5.</p><p>Jika kamu ingin penjadwal untuk memasukkan seluruh Node di dalam klaster ke dalam penskoran,
maka aturlah <code>percentageOfNodesToScore</code> menjadi 100.</p><h2 id=contoh>Contoh</h2><p>Contoh konfigurasi di bawah ini mengatur <code>percentageOfNodesToScore</code> menjadi 50%.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>algorithmSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>provider</span>:<span style=color:#bbb> </span>DefaultProvider<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>percentageOfNodesToScore</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=menyetel-percentageofnodestoscore>Menyetel percentageOfNodesToScore</h2><p><code>percentageOfNodesToScore</code> merupakan angka 1 sampai 100 dengan
nilai bawaan yang dihitung berdasarkan ukuran klaster. Di sini juga terdapat
batas bawah yang telah ditetapkan, yaitu 50 Node.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Pada klaster dengan kurang dari 50 Node layak, penjadwal masih
terus memeriksa seluruh Node karena Node-Node layak belum mencukupi supaya
penjadwal dapat menghentikan proses pencarian lebih awal.</p><p>Pada klaster kecil, jika kamu mengatur <code>percentageOfNodesToScore</code> dengan angka kecil,
pengaturan ini hampir atau sama sekali tidak berpengaruh, karena alasan yang sama.</p><p>Jika klaster kamu punya ratusan Node, gunakan angka bawaan untuk opsi konfigurasi ini.
Mengubah angkanya kemungkinan besar tidak akan mengubah kinerja penjadwal secara berarti.</p></div><p>Sebuah catatan penting yang perlu dipertimbangkan saat mengatur angka ini adalah
ketika klaster dengan jumlah Node sedikit diperiksa untuk kelayakan, beberapa Node
tidak dikirim untuk diskor bagi sebuah Pod. Hasilnya, sebuah Node yang mungkin memiliki
nilai lebih tinggi untuk menjalankan Pod tersebut bisa saja tidak diteruskan ke fase penskoran.
Hal ini berdampak pada penempatan Pod yang kurang ideal.</p><p>Kamu sebaiknya menghindari pengaturan <code>percentageOfNodesToScore</code> menjadi sangat rendah,
agar kube-scheduler tidak seringkali membuat keputusan penempatan Pod yang buruk.
Hindari pengaturan persentase di bawah 10%, kecuali <em>throughput</em> penjadwal sangat penting
untuk aplikasi kamu dan skor dari Node tidak begitu penting. Dalam kata lain, kamu
memilih untuk menjalankan Pod pada Node manapun selama Node tersebut layak.</p><h2 id=bagaimana-penjadwal-mengecek-node>Bagaimana Penjadwal Mengecek Node</h2><p>Bagian ini ditujukan untuk kamu yang ingin mengerti bagaimana fitur ini bekerja secara internal.</p><p>Untuk memberikan semua Node di dalam klaster sebuah kesempatan yang adil untuk
dipertimbangkan dalam menjalankan Pod, penjadwal mengecek Node satu persatu
secara <em>round robin</em>. Kamu dapat membayangkan Node-Node ada di dalam sebuah array.
Penjadwal mulai dari indeks array pertama dan mengecek kelayakan dari Node sampai
jumlahnya telah mencukupi sesuai dengan <code>percentageOfNodesToScore</code>. Untuk Pod berikutnya,
penjadwal melanjutkan dari indeks array Node yang terhenti ketika memeriksa
kelayakan Node-Node untuk Pod sebelumnya.</p><p>Jika Node-Node berada di beberapa zona, maka penjadwal akan mengecek Node satu persatu
pada seluruh zona untuk memastikan bahwa Node-Node dari zona berbeda masuk dalam pertimbangan
kelayakan. Sebagai contoh, ada 6 Node di dalam 2 zona:</p><pre tabindex=0><code>Zona 1: Node 1, Node 2, Node 3, Node 4
Zona 2: Node 5, Node 6
</code></pre><p>Penjadwal mempertimbangkan kelayakan dari Node-Node tersebut dengan urutan berikut:</p><pre tabindex=0><code>Node 1, Node 5, Node 2, Node 6, Node 3, Node 4
</code></pre><p>Setelah semua Node telah dicek, penjadwal akan kembali pada Node 1.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>