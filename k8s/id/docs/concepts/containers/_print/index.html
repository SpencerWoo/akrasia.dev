<!doctype html><html lang=id class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/containers/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/containers/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/containers/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/containers/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/containers/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/containers/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/containers/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/containers/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/containers/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/containers/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/concepts/containers/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Kontainer | Kubernetes</title><meta property="og:title" content="Kontainer"><meta property="og:description" content="Orkestrasi Kontainer dengan Skala Produksi"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/containers/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Kontainer"><meta itemprop=description content="Orkestrasi Kontainer dengan Skala Produksi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kontainer"><meta name=twitter:description content="Orkestrasi Kontainer dengan Skala Produksi"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/containers/"><meta property="og:title" content="Kontainer"><meta name=twitter:title content="Kontainer"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/id/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/id/docs/concepts/containers/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/id/docs/concepts/containers/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/concepts/containers/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/concepts/containers/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/concepts/containers/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/containers/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/containers/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/containers/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/containers/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/containers/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/containers/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/containers/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/containers/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/containers/>Português (Portuguese)</a>
<a class=dropdown-item href=/vi/docs/concepts/containers/>Tiếng Việt (Vietnamese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/concepts/containers/>Return to the regular view of this page</a>.</p></div><h1 class=title>Kontainer</h1><ul><li>1: <a href=#pg-8fda96dc403731ceba5e0ddd0ab3ad15>Ikhtisar Kontainer</a></li><li>2: <a href=#pg-16042b4652ad19e565c7263824029a43>Image</a></li><li>3: <a href=#pg-643212488f778acf04bebed65ba34441>Kontainer Environment</a></li><li>4: <a href=#pg-a858027489648786a3b16264e451272b>Runtime Class</a></li><li>5: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>Lifecyle Hook pada Kontainer</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-8fda96dc403731ceba5e0ddd0ab3ad15>1 - Ikhtisar Kontainer</h1><p>Kontainer adalah teknologi untuk mengemas kode (yang telah dikompilasi) menjadi
suatu aplikasi beserta dengan dependensi-dependensi yang dibutuhkannya pada saat
dijalankan. Setiap kontainer yang Anda jalankan dapat diulang; standardisasi
dengan menyertakan dependensinya berarti Anda akan mendapatkan perilaku yang
sama di mana pun Anda menjalankannya.</p><p>Kontainer memisahkan aplikasi dari infrastruktur host yang ada dibawahnya. Hal
ini membuat penyebaran lebih mudah di lingkungan cloud atau OS yang berbeda.</p><h2 id=image-image-kontainer>Image-Image Kontainer</h2><p><a href=/id/docs/concepts/containers/images/>Kontainer image</a> meruapakan paket perangkat lunak
yang siap dijalankan, mengandung semua yang diperlukan untuk menjalankan
sebuah aplikasi: kode dan setiap <em>runtime</em> yang dibutuhkan, <em>library</em> dari
aplikasi dan sistem, dan nilai <em>default</em> untuk penganturan yang penting.</p><p>Secara desain, kontainer tidak bisa berubah: Anda tidak dapat mengubah kode
dalam kontainer yang sedang berjalan. Jika Anda memiliki aplikasi yang
terkontainerisasi dan ingin melakukan perubahan, maka Anda perlu membuat
kontainer baru dengan menyertakan perubahannya, kemudian membuat ulang kontainer
dengan memulai dari <em>image</em> yang sudah diubah.</p><h2 id=kontainer-runtime>Kontainer <em>runtime</em></h2><p>Kontainer <em>runtime</em> adalah perangkat lunak yang bertanggung jawab untuk
menjalankan kontainer. Kubernetes mendukung beberapa kontainer <em>runtime</em>:
<a class=glossary-tooltip title='Docker merupakan suatu teknologi perangkat lunak yang menyediakan virtualisasi pada level sistem operasi yang juga dikenal sebagai Container.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>,
<a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>,
<a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>, dan semua implementasi dari
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Baca tentang <a href=https://kubernetes.io/docs/concepts/containers/images/>image-image kontainer</a></li><li>Baca tentang <a href=https://kubernetes.io/docs/concepts/workloads/pods/>Pod</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-16042b4652ad19e565c7263824029a43>2 - Image</h1><p>Kamu membuat Docker <em>image</em> dan mengunduhnya ke sebuah registri sebelum digunakan di dalam Kubernetes Pod.</p><p>Properti <code>image</code> dari sebuah Container mendukung sintaksis yang sama seperti perintah <code>docker</code>, termasuk registri privat dan <em>tag</em>.</p><h2 id=memperbarui-image>Memperbarui Image</h2><p>Kebijakan <em>pull default</em> adalah <code>IfNotPresent</code> yang membuat Kubelet tidak
lagi mengunduh (<em>pull</em>) sebuah image jika sudah ada terlebih dahulu. Jika kamu ingin agar
selalu diunduh, kamu bisa melakukan salah satu dari berikut:</p><ul><li>mengatur <code>imagePullPolicy</code> dari Container menjadi <code>Always</code>.</li><li>buang <code>imagePullPolicy</code> dan gunakan <code>:latest</code> <em>tag</em> untuk <em>image</em> yang digunakan.</li><li>buang <code>imagePullPolicy</code> dan juga <em>tag</em> untuk <em>image</em>.</li><li>aktifkan <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> <em>admission controller</em>.</li></ul><p>Harap diingat kamu sebaiknya hindari penggunaan <em>tag</em> <code>:latest</code>, lihat <a href=/id/docs/concepts/configuration/overview/#container-images>panduan konfigurasi</a> untuk informasi lebih lanjut.</p><h2 id=membuat-image-multi-arsitektur-dengan-manifest>Membuat Image Multi-arsitektur dengan Manifest</h2><p>Docker CLI saat ini mendukung perintah <code>docker manifest</code> dengan anak perintah <code>create</code>, <code>annotate</code>, dan <code>push</code>. Perintah-perintah ini dapat digunakan
untuk membuat (<em>build</em>) dan mengunggah (<em>push</em>) manifes. Kamu dapat menggunakan perintah <code>docker manifest inspect</code> untuk membaca manifes.</p><p>Lihat dokumentasi docker di sini:
<a href=https://docs.docker.com/edge/engine/reference/commandline/manifest/>https://docs.docker.com/edge/engine/reference/commandline/manifest/</a></p><p>Lihat contoh-contoh bagaimana kami menggunakan ini untuk proses <em>build harness</em>:
<a href="https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&i=nope&files=&repos=">https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&i=nope&files=&repos=</a></p><p>Perintah-perintah ini bergantung pada Docker CLI, dan diimplementasi hanya di sisi CLI. Kamu harus mengubah <code>$HOME/.docker/config.json</code> dan mengatur <em>key</em> <code>experimental</code> untuk mengaktifkan
atau cukup dengan mengatur <code>DOCKER_CLI_EXPERIMENTAL</code> variabel <em>environment</em> menjadi <code>enabled</code> ketika memanggil perintah-perintah CLI.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Gunakan Docker <em>18.06 ke atas</em>, versi-versi di bawahnya memiliki <em>bug</em> ataupun tidak mendukung perintah eksperimental. Contohnya <a href=https://github.com/docker/cli/issues/1135>https://github.com/docker/cli/issues/1135</a> yang menyebabkan masalah di bawah containerd.</div><p>Kalau kamu terkena masalah ketika mengunggah manifes-manifes yang rusak, cukup bersihkan manifes-manifes yang lama di <code>$HOME/.docker/manifests</code> untuk memulai dari awal.</p><p>Untuk Kubernetes, kami biasanya menggunakan <em>image-image</em> dengan sufiks <code>-$(ARCH)</code>. Untuk kompatibilitas (<em>backward compatibility</em>), lakukan <em>generate image-image</em> yang lama dengan sufiks. Idenya adalah men-<em>generate</em>, misalnya <code>pause</code> image yang memiliki manifes untuk semua arsitektur dan misalnya <code>pause-amd64</code> yang punya kompatibilitas terhadap konfigurasi-konfigurasi lama atau berkas-berkas YAML yang bisa saja punya <em>image-image</em> bersufiks yang di-<em>hardcode</em>.</p><h2 id=menggunakan-registri-privat>Menggunakan Registri Privat (<em>Private Registry</em>)</h2><p>Biasanya kita memerlukan <em>key</em> untuk membaca <em>image-image</em> yang tersedia pada suatu registri privat.
Kredensial ini dapat disediakan melalui beberapa cara:</p><ul><li>Menggunakan Google Container Registry<ul><li>per-klaster</li><li>konfigurasi secara otomatis pada Google Compute Engine atau Google Kubernetes Engine</li><li>semua Pod dapat membaca registri privat yang ada di dalam proyek</li></ul></li><li>Menggunakan Amazon Elastic Container Registry (ECR)<ul><li>menggunakan IAM <em>role</em> dan <em>policy</em> untuk mengontrol akses ke repositori ECR</li><li>secara otomatis <em>refresh</em> kredensial login ECR</li></ul></li><li>Menggunakan Oracle Cloud Infrastructure Registry (OCIR)<ul><li>menggunakan IAM <em>role</em> dan <em>policy</em> untuk mengontrol akses ke repositori OCIR</li></ul></li><li>Menggunakan Azure Container Registry (ACR)</li><li>Menggunakan IBM Cloud Container Registry<ul><li>menggunakan IAM <em>role</em> dan <em>policy</em> untuk memberikan akses ke IBM Cloud Container Registry</li></ul></li><li>Konfigurasi Node untuk otentikasi registri privat<ul><li>semua Pod dapat membaca registri privat manapun</li><li>memerlukan konfigurasi Node oleh admin klaster</li></ul></li><li>Pra-unduh <em>image</em><ul><li>semua Pod dapat menggunakan <em>image</em> apapun yang di-<em>cached</em> di dalam sebuah Node</li><li>memerlukan akses root ke dalam semua Node untuk pengaturannya</li></ul></li><li>Mengatur ImagePullSecrets dalam sebuah Pod<ul><li>hanya Pod-Pod yang menyediakan <em>key</em> sendiri yang dapat mengakses registri privat</li></ul></li></ul><p>Masing-masing opsi dijelaskan lebih lanjut di bawah ini.</p><h3 id=menggunakan-google-container-registry>Menggunakan Google Container Registry</h3><p>Kubernetes memiliki dukungan <em>native</em> untuk <a href=https://cloud.google.com/tools/container-registry/>Google Container
Registry (GCR)</a>, ketika dijalankan pada
Google Compute Engine (GCE). Jika kamu menjalankan klaster pada GCE atau Google Kubernetes Engine,
cukup gunakan nama panjang <em>image</em> (misalnya gcr.io/my_project/image:tag).</p><p>Semua Pod di dalam klaster akan memiliki akses baca <em>image</em> di registri ini.</p><p>Kubelet akan melakukan otentikasi GCR menggunakan <em>service account</em> yang dimiliki
<em>instance</em> Google. <em>Service acccount</em> pada <em>instance</em> akan memiliki sebuah <code>https://www.googleapis.com/auth/devstorage.read_only</code>,
sehingga dapat mengunduh dari GCR di proyek yang sama, tapi tidak untuk unggah.</p><h3 id=menggunakan-amazon-elastic-container-registry>Menggunakan Amazon Elastic Container Registry</h3><p>Kubernetes memiliki dukungan <em>native</em> untuk <a href=https://aws.amazon.com/ecr/>Amazon Elastic Container Registry</a>, ketika Node adalah
AWS EC2 <em>instance</em>.</p><p>Cukup gunakan nama panjang <em>image</em> (misalnya <code>ACCOUNT.dkr.ecr.REGION.amazonaws.com/imagename:tag</code>) di dalam definisi Pod.</p><p>Semua pengguna klaster yang dapat membuat Pod akan bisa menjalankan Pod yang dapat menggunakan
<em>image-image</em> di dalam registri ECR.</p><p>Kubelet akan mengambil dan secara periodik memperbarui kredensial ECR, yang memerlukan <em>permission</em> sebagai berikut:</p><ul><li><code>ecr:GetAuthorizationToken</code></li><li><code>ecr:BatchCheckLayerAvailability</code></li><li><code>ecr:GetDownloadUrlForLayer</code></li><li><code>ecr:GetRepositoryPolicy</code></li><li><code>ecr:DescribeRepositories</code></li><li><code>ecr:ListImages</code></li><li><code>ecr:BatchGetImage</code></li></ul><p>Persyaratan:</p><ul><li>Kamu harus menggunakan versi kubelet <code>v1.2.0</code> atau lebih (misal jalankan <code>/usr/bin/kubelet --version=true</code>).</li><li>Jika Node yang kamu miliki ada di region A dan registri kamu ada di region yang berbeda misalnya B, kamu perlu versi <code>v1.3.0</code> atau lebih.</li><li>ECR harus tersedia di region kamu.</li></ul><p>Cara <em>troubleshoot</em>:</p><ul><li>Verifikasi semua persyaratan di atas.</li><li>Dapatkan kredensial $REGION (misalnya <code>us-west-2</code>) pada <em>workstation</em> kamu. Lakukan SSH ke dalam <em>host</em> dan jalankan Docker secara manual menggunakan kredensial tersebut. Apakah berhasil?</li><li>Tambahkan verbositas level <em>log</em> kubelet paling tidak 3 dan periksa <em>log</em> kubelet (misal <code>journalctl -u kubelet</code>) di baris-baris yang seperti ini:<ul><li><code>aws_credentials.go:109] unable to get ECR credentials from cache, checking ECR API</code></li><li><code>aws_credentials.go:116] Got ECR credentials from ECR API for &lt;AWS account ID for ECR>.dkr.ecr.&lt;AWS region>.amazonaws.com</code></li></ul></li></ul><h3 id=menggunakan-azure-container-registry-acr>Menggunakan Azure Container Registry (ACR)</h3><p>Ketika menggunakan <a href=https://azure.microsoft.com/en-us/services/container-registry/>Azure Container Registry</a>
kamu dapat melakukan otentikasi menggunakan pengguna admin maupun sebuah <em>service principal</em>.
Untuk keduanya, otentikasi dilakukan melalui proses otentikasi Docker standar. Instruksi-instruksi ini
menggunakan perangkat <a href=https://github.com/azure/azure-cli>azure-cli</a>.</p><p>Kamu pertama perlu membuat sebuah registri dan men-<em>generate</em> kredensial, dokumentasi yang lengkap tentang hal ini
dapat dilihat pada <a href=https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli>dokumentasi Azure container registry</a>.</p><p>Setelah kamu membuat registri, kamu akan menggunakan kredensial berikut untuk login:</p><ul><li><code>DOCKER_USER</code> : <em>service principal</em>, atau pengguna admin</li><li><code>DOCKER_PASSWORD</code>: kata sandi dari <em>service principal</em>, atau kata sandi dari pengguna admin</li><li><code>DOCKER_REGISTRY_SERVER</code>: <code>${some-registry-name}.azurecr.io</code></li><li><code>DOCKER_EMAIL</code>: <code>${some-email-address}</code></li></ul><p>Ketika kamu sudah memiliki variabel-variabel di atas, kamu dapat
<a href=/id/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>mengkonfigurasi sebuah Kubernetes Secret dan menggunakannya untuk <em>deploy</em> sebuah Pod</a>.</p><h3 id=menggunakan-ibm-cloud-container-registry>Menggunakan IBM Cloud Container Registry</h3><p>IBM Cloud Container Registry menyediakan sebuah registri <em>image</em> privat yang <em>multi-tenant</em>, dapat kamu gunakan untuk menyimpan dan membagikan <em>image-image</em> secara aman. Secara <em>default</em>, <em>image-image</em> di dalam registri privat kamu akan dipindai (<em>scan</em>) oleh Vulnerability Advisor terintegrasi untuk deteksi isu
keamanan dan kerentanan (<em>vulnerability</em>) yang berpotensi. Para pengguna di dalam akun IBM Cloud kamu dapat mengakses <em>image</em>, atau kamu dapat menggunakan IAM
<em>role</em> dan <em>policy</em> untuk memberikan akses ke <em>namespace</em> di IBM Cloud Container Registry.</p><p>Untuk instalasi <em>plugin</em> CLI di IBM Cloud Containerr Registry dan membuat sebuah <em>namespace</em> untuk <em>image-image</em> kamu, lihat <a href="https://cloud.ibm.com/docs/Registry?topic=registry-getting-started">Mulai dengan IBM Cloud Container Registry</a>.</p><p>Jika kamu menggunakan akun dan wilayah (<em>region</em>) yang sama, kamu dapat melakukan <em>deploy image-image</em> yang disimpan di dalam IBM Cloud Container Registry
ke dalam <em>namespace default</em> dari klaster IBM Cloud Kubernetes Service yang kamu miliki tanpa konfigurasi tambahan, lihat <a href="https://cloud.ibm.com/docs/containers?topic=containers-images">Membuat kontainer dari <em>image</em></a>. Untuk opsi konfigurasi lainnya, lihat <a href="https://cloud.ibm.com/docs/containers?topic=containers-registry#cluster_registry_auth">Bagaimana cara mengotorasi klaster untuk mengunduh <em>image</em> dari sebuah registri</a>.</p><h3 id=konfigurasi-node-untuk-otentikasi-ke-sebuah-registri-privat>Konfigurasi Node untuk Otentikasi ke sebuah Registri Privat</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika kamu jalan di Google Kubernetes Engine, akan ada <code>.dockercfg</code> pada setiap Node dengan kredensial untuk Google Container Registry. Kamu tidak bisa menggunakan cara ini.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika kamu jalan di AWS EC2 dan menggunakan EC2 Container Registry (ECR), kubelet pada setiap Node akan dapat
mengatur dan memperbarui kredensial login ECR. Kamu tidak bisa menggunakan cara ini.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Cara ini cocok jika kamu dapat mengontrol konfigurasi Node. Cara ini tidak akan bekerja dengan baik pada GCE,
dan penyedia layanan cloud lainnya yang tidak melakukan penggantian Node secara otomatis.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kubernetes pada saat ini hanya mendukung bagian <code>auths</code> dan <code>HttpHeaders</code> dari konfigurasi docker. Hal ini berarti bantuan kredensial (<code>credHelpers</code> atau <code>credsStore</code>) tidak didukung.</div><p>Docker menyimpan <em>key</em> untuk registri privat pada <code>$HOME/.dockercfg</code> atau berkas <code>$HOME/.docker/config.json</code>. Jika kamu menempatkan berkas yang sama
pada daftar jalur pencarian (<em>search path</em>) berikut, kubelet menggunakannya sebagai penyedia kredensial saat mengunduh <em>image</em>.</p><ul><li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li><li><code>{cwd of kubelet}/config.json</code></li><li><code>${HOME}/.docker/config.json</code></li><li><code>/.docker/config.json</code></li><li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li><li><code>{cwd of kubelet}/.dockercfg</code></li><li><code>${HOME}/.dockercfg</code></li><li><code>/.dockercfg</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu mungkin harus mengatur <code>HOME=/root</code> secara eksplisit pada berkas <em>environment</em> kamu untuk kubelet.</div><p>Berikut langkah-langkah yang direkomendasikan untuk mengkonfigurasi Node kamu supaya bisa menggunakan registri privat.
Pada contoh ini, coba jalankan pada <em>desktop/laptop</em> kamu:</p><ol><li>Jalankan <code>docker login [server]</code> untuk setiap set kredensial yang ingin kamu gunakan. Ini akan memperbarui <code>$HOME/.docker/config.json</code>.</li><li>Lihat <code>$HOME/.docker/config.json</code> menggunakan <em>editor</em> untuk memastikan sudah berisi kredensial yang ingin kamu gunakan.</li><li>Dapatkan daftar Node, contohnya:<ul><li>jika kamu ingin mendapatkan nama: <code>nodes=$(kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}')</code></li><li>jika kamu ingin mendapatkan IP: <code>nodes=$(kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}')</code></li></ul></li><li>Salin <code>.docker/config.json</code> yang ada di lokal kamu pada salah satu jalur pencarian di atas.<ul><li>contohnya: <code>for n in $nodes; do scp ~/.docker/config.json root@$n:/var/lib/kubelet/config.json; done</code></li></ul></li></ol><p>Verifikasi dengana membuat sebuah Pod yanag menggunakan <em>image</em> privat, contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: private-image-test-1
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: uses-private-image
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: $PRIVATE_IMAGE_NAME
</span></span></span><span style=display:flex><span><span style=color:#b44>      imagePullPolicy: Always
</span></span></span><span style=display:flex><span><span style=color:#b44>      command: [ &#34;echo&#34;, &#34;SUCCESS&#34; ]
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><pre tabindex=0><code>pod/private-image-test-1 created
</code></pre><p>Jika semuanya berjalan dengan baik, maka setelah beberapa lama, kamu dapat menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs private-image-test-1
</span></span></code></pre></div><p>dan lihat pada keluaran perintah:</p><pre tabindex=0><code>SUCCESS
</code></pre><p>Jika kamu mencurigai ada perintah yang gagal, kamu dapat menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#39;Failed&#39;</span>
</span></span></code></pre></div><p>Pada kasus gagal, keluarannya mirip seperti:</p><pre tabindex=0><code>  Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image &#34;user/privaterepo:v1&#34;: Error: image user/privaterepo:v1 not found
</code></pre><p>Kamu harus memastikan semua Node di dalam klaster memiliki <code>.docker/config.json</code> yang sama. Jika tidak, Pod-Pod
akan jalan pada beberapa Node saja dan gagal di Node lainnya. Contohnya, jika kamu menggunakan Node <em>autoscaling</em>, maka
setiap templat <em>instance</em> perlu untuk mempunyai <code>.docker/config.json</code> atau <em>mount</em> sebuah penyimpanan yang berisi berkas tersebut.</p><p>Semua Pod memiliki akses baca (<em>read</em>) untuk <em>image-image</em> di registri privat manapun ketika
<em>key</em> registri privat ditambahkan pada <code>.docker/config.json</code>.</p><h3 id=image-pra-unduh><em>Image</em> Pra-unduh</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika kamu jalan di Google Kubernetes Engine, maka akan ada <code>.dockercfg</code> pada setiap Node dengan kredensial untuk Google Container Registry. Kamu dapat menggunakan cara ini.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Cara ini cocok jika kamu dapat mengontrol konfigurasi Node. Cara ini tidak akan
bisa berjalan dengan baik pada GCE, dan penyedia cloud lainnya yang tidak menggantikan
Node secara otomatis.</div><p>Secara <em>default</em>, kubelet akan mencoba untuk mengunduh setiap <em>image</em> dari registri yang dispesifikasikan.
Hanya saja, jika properti <code>imagePullPolicy</code> diatur menjadi <code>IfNotPresent</code> atau <code>Never</code>, maka
sebuah <em>image</em> lokal digunakan.</p><p>Jika kamu ingin memanfaatkan <em>image</em> pra-unduh sebagai pengganti untuk otentikasi registri,
kamu harus memastikan semua Node di dalam klaster memiliki <em>image</em> pra-unduh yang sama.</p><p>Cara ini bisa digunakan untuk memuat <em>image</em> tertentu untuk kecepatan atau sebagai alternatif untuk otentikasi untuk sebuah registri privat.</p><p>Semua Pod akan mendapatkan akses baca ke <em>image</em> pra-unduh manapun.</p><h3 id=tentukan-imagepullsecrets-pada-sebuah-pod>Tentukan ImagePullSecrets pada sebuah Pod</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Cara ini merupakan cara yang direkomendasikan saat ini untuk Google Kubernetes Engine, GCE, dan penyedia cloud lainnya yang
secara otomatis dapat membuat Node.</div><p>Kubernetes mendukung penentuan <em>key</em> registri pada sebuah Pod.</p><h4 id=membuat-sebuah-secret-dengan-docker-config>Membuat sebuah Secret dengan Docker Config</h4><p>Jalankan perintah berikut, ganti nilai huruf besar dengan yang tepat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</span></span></code></pre></div><p>Jika kamu sudah memiliki berkas kredensial Docker, daripada menggunakan perintah di atas,
kamu dapat mengimpor berkas kredensial sebagai Kubernetes Secret.
<a href=/id/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>Membuat sebuah Secret berbasiskan pada kredensial Docker yang sudah ada</a> menjelaskan bagaimana mengatur ini.
Cara ini berguna khususnya jika kamu menggunakan beberapa registri kontainer privat,
perintah <code>kubectl create secret docker-registry</code> akan membuat sebuah Secret yang akan
hanya bekerja menggunakan satu registri privat.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pod-Pod hanya dapat mengacu pada imagePullSecrets di dalam <em>namespace</em>,
sehingga proses ini perlu untuk diselesaikan satu kali setiap <em>namespace</em>.</div><h4 id=mengacu-pada-imagepullsecrets-di-dalam-sebuah-pod>Mengacu pada imagePullSecrets di dalam sebuah Pod</h4><p>Sekarang, kamu dapat membuat Pod yang mengacu pada Secret dengan menambahkan bagian <code>imagePullSecrets</code>
untuk sebuah definisi Pod.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Cara ini perlu untuk diselesaikan untuk setiap Pod yang mengguunakan registri privat.</p><p>Hanya saja, mengatur <em>field</em> ini dapat diotomasi dengan mengatur imagePullSecrets di dalam
sumber daya <a href=/docs/user-guide/service-accounts>serviceAccount</a>.
Periksa <a href=/id/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Tambahan ImagePullSecrets untuk sebuah Service Account</a> untuk instruksi yang lebih detail.</p><p>Kamu dapat menggunakan cara ini bersama <code>.docker/config.json</code> pada setiap Node. Kredensial-kredensial
akan dapat di-<em>merged</em>. Cara ini akan dapat bekerja pada Google Kubernetes Engine.</p><h3 id=kasus-kasus-penggunaan-use-case>Kasus-Kasus Penggunaan (<em>Use Case</em>)</h3><p>Ada beberapa solusi untuk konfigurasi registri privat. Berikut beberapa kasus penggunaan
dan solusi yang disarankan.</p><ol><li>Klaster yang hanya menjalankan <em>image non-proprietary</em> (misalnya open-source). Tidak perlu unutuk menyembunyikan <em>image</em>.<ul><li>Gunakan <em>image</em> publik pada Docker hub.<ul><li>Tidak ada konfigurasi yang diperlukan.</li><li>Pada GCE/Google Kubernetes Engine, sebuah <em>mirror</em> lokal digunakan secara otomatis untuk meningkatkan kecepatan dan ketersediaan.</li></ul></li></ul></li><li>Klaster yang menjalankan <em>image proprietary</em> yang seharusnya disembunyikan dari luar perusahaan, tetapi bisa terlihat oleh pengguna klaster.<ul><li>Gunakan sebuah privat <a href=https://docs.docker.com/registry/>registri Docker</a> yang <em>hosted</em>.<ul><li>Bisa saja di-<em>host</em> pada <a href=https://hub.docker.com/signup>Docker Hub</a>, atau lainnya.</li><li>Konfigurasi <code>.docker/config.json</code> secara manual pada setiap Node seperti dijelaskan di atas.</li></ul></li><li>Atau, jalankan sebuah registri privat internal di belakang <em>firewall</em> kamu dengan akses baca terbuka.<ul><li>Tidak ada konfigurasi Kubernetes yang diperlukan.</li></ul></li><li>Atau, ketika pada GCE/Google Kubernetes Engine, menggunakan Google Container Registry yang ada di proyek.<ul><li>Hal ini bisa bekerja baik dengan <em>autoscaling</em> klaster dibandingkan konfigurasi Node manual.</li></ul></li><li>Atau, pada sebuah klaster dimana mengubah konfigurasi Node tidak nyaman, gunakan <code>imagePullSecrets</code>.</li></ul></li><li>Klaster dengan <em>image proprietary</em>, beberapa memerlukan akses kontrol yang lebih ketat.<ul><li>Pastikan <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages <em>admission controller</em></a> aktif. Sebaliknya, semua Pod berpotensi memiliki akses ke semua <em>image</em>.</li><li>Pindahkan data sensitif pada sumber daya "Secret", daripada mengemasnya menjadi sebuah <em>image</em>.</li></ul></li><li>Sebuah klaster <em>multi-tenant</em> dimana setiap <em>tenant</em> memerlukan registri privatnya masing-masing.<ul><li>Pastikan <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages <em>admission controller</em></a> aktif. Sebaliknya, semua Pod dari semua tenant berpotensi memiliki akses pada semua <em>image</em>.</li><li>Jalankan sebuah registri privat dimana otorisasi diperlukan.</li><li>Men-<em>generate</em> kredensial registri uuntuk setiap <em>tenant</em>, masukkan ke dalam <em>secret</em> uuntuk setiap <em>namespace tenant</em>.</li><li><em>Tenant</em> menambahkan <em>secret</em> pada imagePullSecrets uuntuk setiap <em>namespace</em>.</li></ul></li></ol><p>Jika kamu memiliki akses pada beberapa registri, kamu dapat membuat satu <em>secret</em> untuk setiap registri.
Kubelet akan melakukan <em>merge</em> <code>imagePullSecrets</code> manapun menjadi sebuah virtual <code>.docker/config.json</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-643212488f778acf04bebed65ba34441>3 - Kontainer Environment</h1><p>Laman ini menjelaskan berbagai <em>resource</em> yang tersedia di dalam Kontainer pada suatu <em>environment</em>.</p><h2 id=environment-kontainer><em>Environment</em> Kontainer</h2><p><em>Environment</em> Kontainer pada Kubernetes menyediakan beberapa <em>resource</em> penting yang tersedia di dalam Kontainer:</p><ul><li>Sebuah <em>Filesystem</em>, yang merupakan kombinasi antara <a href=/id/docs/concepts/containers/images/>image</a> dan satu atau banyak <a href=/id/docs/concepts/storage/volumes/><em>volumes</em></a>.</li><li>Informasi tentang Kontainer tersebut.</li><li>Informasi tentang objek-objek lain di dalam klaster.</li></ul><h3 id=informasi-tentang-kontainer>Informasi tentang Kontainer</h3><p><em>Hostname</em> sebuah Kontainer merupakan nama dari Pod dimana Kontainer dijalankan.
Informasi ini tersedia melalui perintah <code>hostname</code> atau panggilan (<em>function call</em>)
<a href=http://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a> pada <code>libc</code>.</p><p>Nama Pod dan <em>namespace</em> tersedia sebagai variabel <em>environment</em> melalui <a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>API <em>downward</em></a>.</p><p>Variabel <em>environment</em> yang ditulis pengguna dalam Pod <em>definition</em> juga tersedia di dalam Kontainer,
seperti halnya variabel <em>environment</em> yang ditentukan secara statis di dalam <em>image</em> Docker.</p><h3 id=informasi-tentang-klaster>Informasi tentang Klaster</h3><p>Daftar semua <em>Service</em> yang dijalankan ketika suatu Kontainer dibuat, tersedia di dalam Kontainer tersebut sebagai variabel <em>environment</em>.
Variabel-variabel <em>environment</em> tersebut sesuai dengan sintaksis <em>links</em> dari Docker.</p><p>Untuk suatu <em>Service</em> bernama <em>foo</em> yang terkait dengan Kontainer bernama <em>bar</em>,
variabel-variabel di bawah ini tersedia:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;host dimana service dijalankan&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;port dimana service dijalankan&gt;
</span></span></code></pre></div><p>Semua <em>Service</em> memiliki alamat-alamat IP yang bisa didapatkan di dalam Kontainer melalui DNS,
jika <a href=http://releases.k8s.io/main/cluster/addons/dns/><em>addon</em> DNS</a> diaktifkan. </p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/containers/container-lifecycle-hooks/>berbagai <em>hook</em> pada <em>lifecycle</em> Kontainer</a>.</li><li>Dapatkan pengalaman praktis soal
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>memberikan <em>handler</em> untuk <em>event</em> dari <em>lifecycle</em> Kontainer</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a858027489648786a3b16264e451272b>4 - Runtime Class</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [beta]</code></div><p>Laman ini menjelaskan tentang <em>resource</em> RuntimeClass dan proses pemilihan <em>runtime</em>.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> RuntimeClass memiliki <em>breaking change</em> untuk pembaruan ke beta pada v1.14. Jika kamu menggunakan
RuntimeClass sebelum v1.14, lihat <a href=#memperbarui-runtimeclass-dari-alpha-ke-beta>Memperbarui RuntimeClass dari Alpha ke Beta</a>.</div><h2 id=runtime-class><code>Runtime Class</code></h2><p>RuntimeClass merupakan sebuah fitur untuk memilih konfigurasi <em>runtime</em> kontainer. Konfigurasi
tersebut digunakan untuk menjalankan kontainer-kontainer milik suatu Pod.</p><h3 id=persiapan>Persiapan</h3><p>Pastikan gerbang fitur (<em>feature gate</em>) <code>RuntimeClass</code> sudah aktif (secara <em>default</em> sudah aktif).
Lihat <a href=/docs/reference/command-line-tools-reference/feature-gates/>Gerbang Fitur</a> untuk lebih
jelasnya soal pengaktifan gerbang fitur.
Gerbang fitur RuntimeClass ini harus aktif pada semua apiserver dan kubelet.</p><ol><li>Lakukan konfigurasi pada implementasi CRI untuk setiap <em>node</em> (tergantung <em>runtime</em> yang dipilih)</li><li>Buat <em>resource</em> RuntimeClass yang terkait</li></ol><h4 id=1-lakukan-konfigurasi-pada-implementasi-cri-untuk-setiap-node>1. Lakukan konfigurasi pada implementasi CRI untuk setiap <em>node</em></h4><p>Pilihan konfigurasi yang tersedia melalui RuntimeClass tergantung pada implementasi
<em>Container Runtime Interface</em> (CRI). Lihat bagian (<a href=#konfigurasi-cri>di bawah ini</a>)
soal bagaimana melakukan konfigurasi untuk implementasi CRI yang kamu miliki.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk saat ini, RuntimeClass berasumsi bahwa semua <em>node</em> di dalam klaster punya
konfigurasi yang sama (homogen). Jika ada <em>node</em> yang punya konfigurasi berbeda dari
yang lain (heterogen), maka perbedaan ini harus diatur secara independen di luar RuntimeClass
melalui fitur <em>scheduling</em> (lihat <a href=/id/docs/concepts/scheduling-eviction/assign-pod-node/>Menempatkan Pod pada Node</a>).</div><p>Seluruh konfigurasi memiliki nama <code>handler</code> yang terkait, dijadikan referensi oleh RuntimeClass.
Nama <em>handler</em> harus berupa valid label 1123 DNS (alfanumerik + karakter <code>-</code>).</p><h4 id=2-buat-resource-runtimeclass-yang-terkait>2. Buat <em>resource</em> <code>RuntimeClass</code> yang terkait</h4><p>Masing-masing konfigurasi pada langkah no.1 punya nama <code>handler</code> yang merepresentasikan
konfigurasi-konfigurasi tersebut. Untuk masing-masing <code>handler</code>, buatlah sebuah objek RuntimeClass terkait.</p><p><em>Resource</em> RuntimeClass saat ini hanya memiliki 2 <em>field</em> yang penting: nama RuntimeClass tersebut
(<code>metadata.name</code>) dan <em>handler</em> (<code>handler</code>). Definisi objek tersebut terlihat seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1beta1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># RuntimeClass didefinisikan pada grup API node.k8s.io</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Nama dari RuntimeClass yang nantinya akan dijadikan referensi</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RuntimeClass merupakan resource tanpa namespace</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>myconfiguration <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Nama dari konfigurasi CRI terkait</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sangat disarankan untuk hanya memperbolehkan admin klaster melakukan operasi
<em>write</em> pada RuntimeClass. Biasanya ini sudah jadi <em>default</em>. Lihat <a href=/docs/reference/access-authn-authz/authorization/>Ikhtisar
Autorisasi</a> untuk penjelasan lebih jauh.</div><h3 id=penggunaan>Penggunaan</h3><p>Ketika RuntimeClass sudah dikonfigurasi pada klaster, penggunaannya sangatlah mudah.
Kamu bisa tentukan <code>runtimeClassName</code> di dalam <code>spec</code> sebuah Pod, sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Kubelet akan mendapat instruksi untuk menggunakan RuntimeClass dengan nama yang sudah ditentukan tersebut
untuk menjalankan Pod ini. Jika RuntimeClass dengan nama tersebut tidak ditemukan, atau CRI tidak dapat
menjalankan <em>handler</em> yang terkait, maka Pod akan memasuki <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>tahap</a> <code>Failed</code>.
Lihat <a href=/docs/tasks/debug-application-cluster/debug-application-introspection/><em>event</em></a> untuk mengetahui pesan error yang terkait.</p><p>Jika tidak ada <code>runtimeClassName</code> yang ditentukan di dalam Pod, maka RuntimeHandler yang <em>default</em> akan digunakan.
Untuk kasus ini, perilaku klaster akan seperti saat fitur RuntimeClass dinonaktifkan.</p><h3 id=konfigurasi-cri>Konfigurasi CRI</h3><p>Lihat <a href=/docs/setup/cri/>instalasi CRI</a> untuk lebih detail mengenai pengaturan <em>runtime</em> CRI.</p><h4 id=dockershim>dockershim</h4><p><em>Built-in</em> dockershim CRI yang dimiliki Kubernetes tidak mendukung <em>handler runtime</em>.</p><h4 id=containerd-https-containerd-io><a href=https://containerd.io/>containerd</a></h4><p><em>Handler runtime</em> diatur melalui konfigurasi containerd pada <code>/etc/containerd/config.toml</code>.
<em>Handler</em> yang valid dapat dikonfigurasi pada bagian <em>runtime</em>:</p><pre tabindex=0><code>[plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.${HANDLER_NAME}]
</code></pre><p>Lihat dokumentasi konfigurasi containerd untuk lebih detail:
<a href=https://github.com/containerd/containerd/blob/main/docs/cri/config.md>https://github.com/containerd/containerd/blob/main/docs/cri/config.md</a></p><h4 id=cri-o-https-cri-o-io><a href=https://cri-o.io/>cri-o</a></h4><p><em>Handler runtime</em> dapat diatur menggunakan konfigurasi cri-o pada <code>/etc/crio/crio.conf</code>.
<em>Handler</em> yang valid dapat dikonfigurasi pada <a href=https://github.com/kubernetes-sigs/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table>tabel crio.runtime</a>:</p><pre tabindex=0><code>[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = &#34;${PATH_TO_BINARY}&#34;
</code></pre><p>Lihat dokumentasi konfigurasi cri-o untuk lebih detail:
<a href=https://github.com/kubernetes-sigs/cri-o/blob/master/cmd/crio/config.go>https://github.com/kubernetes-sigs/cri-o/blob/master/cmd/crio/config.go</a></p><h3 id=memperbarui-runtimeclass-dari-alpha-ke-beta>Memperbarui RuntimeClass dari Alpha ke Beta</h3><p>Fitur Beta pada RuntimeClass memiliki perubahan sebagai berikut:</p><ul><li>Grup API <em>resource</em> <code>node.k8s.io</code> dan <code>runtimeclasses.node.k8s.io</code> telah dimigrasi ke suatu
API <em>built-in</em> dari CustomResourceDefinition.</li><li>Atribut <code>spec</code> telah disederhakan pada definisi RuntimeClass (tidak ada lagi yang namanya
RuntimeClassSpec).</li><li><em>Field</em> <code>runtimeHandler</code> telah berubah nama menjadi <code>handler</code>.</li><li><em>Field</em> <code>handler</code> sekarang bersifat wajib untuk semua versi API. Artinya, <em>field</em> <code>runtimeHandler</code>
pada API Alpha juga bersifat wajib.</li><li><em>Field</em> <code>handler</code> haruslah berupa label DNS valid (<a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>),
yang artinya tidak bisa berisi karakter <code>.</code> (pada semua versi). <em>Handler</em> valid harus sesuai dengan
<em>regular expression</em> ini: <code>^[a-z0-9]([-a-z0-9]*[a-z0-9])?$</code>.</li></ul><p><strong>Tindakan yang diperlukan:</strong> Tindakan-tindaka berikut ini diperlukan untuk melakukan
pembaruan fitur RuntimeClass dari versi alpha ke versi beta:</p><ul><li><em>Resource</em> RuntimeClass harus dibuat ulang <strong>setelah</strong> diperbarui ke v.1.14, dan
CRD <code>runtimeclasses.node.k8s.io</code> harus dihapus secara manual:<pre tabindex=0><code>kubectl delete customresourcedefinitions.apiextensions.k8s.io runtimeclasses.node.k8s.io
</code></pre></li><li>Fitur Alpha pada RuntimeClass akan menjadi tidak valid, jika <code>runtimeHandler</code> tidak ditentukan atau
kosong atau menggunakan karakter <code>.</code> pada <em>handler</em>. Ini harus dimigrasi ke <em>handler</em> dengan
konfigurasi yang valid (lihat petunjuk di atas).</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e6941d969d81540208a3e78bc56f43bc>5 - Lifecyle Hook pada Kontainer</h1><p>Laman ini menjelaskan bagaimana semua Kontainer yang diatur kubelet menggunakan <em>framework lifecycle hook</em>
untuk menjalankan kode yang di-<em>trigger</em> oleh <em>event</em> selama <em>lifecycle</em> berlangsung.</p><h2 id=ikhtisar>Ikhtisar</h2><p>Kubernetes menyediakan <em>hook</em> untuk <em>lifecycle</em> Kontainer. Hal ini sejalan dengan <em>framework</em> bahasa
pemrograman pada umumnya yang memiliki <em>hook</em> untuk <em>lifecycle</em> komponen, seperti Angular contohnya.
<em>Hook</em> tersebut digunakan Kontainer untuk selalu siap menerima <em>event</em> selama <em>lifecycle</em> dan
menjalankan kode yang diimplementasi pada suatu <em>handler</em>, ketika <em>hook lifecycle</em> terkait telah dieksekusi.</p><h2 id=jenis-jenis-hook-pada-kontainer>Jenis-jenis <em>hook</em> pada Kontainer</h2><p>Ada dua jenis <em>hook</em> yang diekspos pada Kontainer:</p><p><code>PostStart</code></p><p><em>Hook</em> ini dijalankan segera setelah suatu kontainer dibuat.
Hanya saja, tidak ada jaminan bahwa <em>hook</em> akan tereksekusi sebelum <code>ENTRYPOINT</code> dari kontainer.
Tidak ada parameter yang diberikan pada <em>handler</em>.</p><p><code>PreStop</code></p><p><em>Hook</em> ini akan dipanggil sesaat sebelum kontainer dimatikan, karena suatu <em>request</em> API atau <em>event</em> pengaturan,
contohnya kegagalan pada <em>liveness probe</em>, <em>preemption</em>, perebutan <em>resource</em>, dan lainnya.
Sebuah panggilan untuk <em>hook</em> <code>PreStop</code> akan gagal jika kontainer tersebut telah ada pada <em>state terminate</em> atau <em>complete</em>.
Hal ini bersifat <em>blocking</em>, yang artinya panggilan bersifat sinkron (<em>synchronous</em>), harus menunggu eksekusi selesai, sebelum melakukan panggilan
untuk menghapus kontainer tersebut.
Tidak ada parameter yang diberikan pada <em>handler</em>.</p><p>Penjelasan yang lebih rinci tentang proses terminasi dapat dilihat pada <a href=/id/docs/concepts/workloads/pods/pod/#termination-of-pods>Terminasi Pod</a>.</p><h3 id=implementasi-handler-untuk-hook>Implementasi <em>handler</em> untuk <em>hook</em></h3><p>Kontainer dapat mengakses sebuah <em>hook</em> melalui implementasi dan registrasi sebuah <em>handler</em> untuk <em>hook</em> tersebut.
Ada dua jenis <em>handler</em> untuk <em>hook</em> yang dapat diimplementasikan untuk Kontainer:</p><ul><li>Exec - Mengeksekusi sebuah perintah tertentu, contohnya <code>pre-stop.sh</code>, di dalam cgroups dan <em>namespace</em> suatu Kontainer. <em>Resource</em> yang dikonsumsi oleh perintah tersebut dianggap sebagai bagian dari Kontainer.</li><li>HTTP - Mengeksekusi sebuah <em>request</em> HTTP untuk <em>endpoint</em> tertentu pada Kontainer tersebut.</li></ul><h3 id=eksekusi-handler-untuk-hook>Eksekusi <em>handler</em> untuk <em>hook</em></h3><p>Ketika manajemen <em>hook</em> untuk suatu <em>lifecycle</em> Kontainer dipanggil, sistem manajemen internal pada Kubernetes
akan mengeksekusi <em>handler</em> di dalam Kontainer yang terdaftar untuk <em>hook</em> tersebut.</p><p>Panggilan <em>handler</em> untuk <em>hook</em> semuanya bersifat <em>synchronous</em> di dalam konteks Pod yang
memiliki Kontainer tersebut. Artinya, untuk <em>hook</em> <code>PostStart</code>, Kontainer <code>ENTRYPOINT</code>
dan <em>hook</em> dieksekusi secara <em>asyncrhonous</em>. Akan tetapi, jika <em>hook</em> mengambil waktu terlalu lama,
atau <em>hang</em>, Kontainer tersebut tidak bisa sampai ke <em>state</em> <code>running</code>.</p><p>Perilaku ini mirip dengan yang terjadi pada <em>hook</em> <code>PreStop</code>.
Jika <em>hook</em> terlalu lama atau <em>hang</em> saat dieksekusi, Pod tersebut tetap ada pada <em>state</em> <code>Terminating</code>
dan akan dimatikan setelah <code>terminationGracePeriodSeconds</code> Pod selesai.
Jika sebuah <em>hook</em> <code>PostStart</code> atau <code>PreStop</code> gagal dieksekusi, Kontainer akan dimatikan.</p><p>Para pengguna sangat disarankan membuat <em>handler</em> untuk <em>hook</em> seringan mungkin (<em>lightweight</em>).
Biar bagaimanapun, ada beberapa kasus yang memang membutuhkan waktu lama untuk mengeksekusi
suatu perintah, misalnya saat proses penyimpanan <em>state</em> sebelum Kontainer dimatikan.</p><h3 id=jaminan-pengiriman-hook>Jaminan pengiriman <em>hook</em></h3><p>Proses pengiriman <em>hook</em> akan dilakukan <strong>paling tidak satu kali</strong>.
Artinya suatu <em>hook</em> boleh dipanggil beberapa kali untuk <em>event</em> yang sama,
seperti dalam <code>PostStart</code> atau<code>PreStop</code>.
Namun begitu, implementasi <em>hook</em> masing-masing harus memastikan bagaimana
menangani kasus ini dengan benar.</p><p>Pada umumnya, hanya terjadi satu proses pengiriman.
Jika misalnya sebuah penerima HTTP <em>hook</em> mati atau tidak bisa menerima trafik,
maka tidak ada usaha untuk mengirimkan kembali.
Namun demikian, bisa saja terjadi dua kali proses pengiriman untuk kasus tertentu.
Contohnya, jika kubelet <em>restart</em> saat di tengah proses pengiriman <em>hook</em>,
<em>hook</em> tersebut akan dikirimkan kembali saat kubelet sudah hidup kembali.</p><h3 id=melakukan-debug-handler-untuk-hook>Melakukan <em>debug</em> <em>handler</em> untuk <em>hook</em></h3><p><em>Log</em> untuk suatu <em>handler hook</em> tidak terekspos pada <em>event</em> Pod.
Jika <em>handler</em> gagal dieksekusi untuk alasan tertentu, <em>handler</em> akan melakukan <em>broadcast</em> sebuah <em>event</em>.
Untuk <code>PostStart</code>, akan dilakukan <em>broadcast event</em> <code>FailedPostStartHook</code>,
dan untuk <code>PreStop</code>, akan dilakukan <em>broadcast event</em> <code>FailedPreStopHook</code>.
Kamu dapat melihat <em>event-event</em> ini dengan menjalankan perintah <code>kubectl describe pod &lt;pod_name></code>.
Berikut merupakan contoh keluaran <em>event-event</em> setelah perintah tersebut dijalankan.</p><pre tabindex=0><code>Events:
  FirstSeen  LastSeen  Count  From                                                   SubobjectPath          Type      Reason               Message
  ---------  --------  -----  ----                                                   -------------          --------  ------               -------
  1m         1m        1      {default-scheduler }                                                          Normal    Scheduled            Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulling              pulling image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Created              Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined]
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulled               Successfully pulled image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Started              Started container with docker id 5c6a256a2567
  38s        38s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1
  37s        37s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1
  38s        37s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}                         Warning   FailedSync           Error syncing pod, skipping: failed to &#34;StartContainer&#34; for &#34;main&#34; with RunContainerError: &#34;PostStart handler: Error executing in Docker Container: 1&#34;
  1m         22s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Warning   FailedPostStartHook
</code></pre><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/containers/container-environment-variables/><em>environment</em> Kontainer</a>.</li><li>Pelajari bagaimana caranya
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>melakukan <em>attach handler</em> pada <em>event lifecycle</em> sebuah Kontainer</a>.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>