<!doctype html><html lang=id class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/overview/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/overview/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/overview/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/overview/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/overview/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/overview/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/overview/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/overview/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/overview/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/overview/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/overview/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/overview/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/overview/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/concepts/overview/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Ikhtisar | Kubernetes</title><meta property="og:title" content="Ikhtisar"><meta property="og:description" content="Orkestrasi Kontainer dengan Skala Produksi"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/overview/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Ikhtisar"><meta itemprop=description content="Orkestrasi Kontainer dengan Skala Produksi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ikhtisar"><meta name=twitter:description content="Orkestrasi Kontainer dengan Skala Produksi"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/overview/"><meta property="og:title" content="Ikhtisar"><meta name=twitter:title content="Ikhtisar"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/id/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/id/docs/concepts/overview/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/id/docs/concepts/overview/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/concepts/overview/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/concepts/overview/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/concepts/overview/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/overview/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/overview/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/overview/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/overview/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/overview/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/overview/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/overview/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/overview/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/overview/>Português (Portuguese)</a>
<a class=dropdown-item href=/vi/docs/concepts/overview/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/concepts/overview/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/concepts/overview/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/concepts/overview/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/concepts/overview/>Return to the regular view of this page</a>.</p></div><h1 class=title>Ikhtisar</h1><ul><li>1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Apa itu Kubernetes?</a></li><li>2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Komponen-Komponen Kubernetes</a></li><li>3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>API Kubernetes</a></li><li>4: <a href=#pg-110f33530cf761140cb1dab536baef04>Menggunakan Objek-Objek Kubernetes</a></li><ul><li>4.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Memahami Konsep Objek-Objek yang ada pada Kubernetes</a></li><li>4.2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>Pengaturan Objek Kubernetes</a></li><li>4.3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>Nama</a></li><li>4.4: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Namespace</a></li><li>4.5: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>Label dan Selektor</a></li><li>4.6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>Anotasi</a></li><li>4.7: <a href=#pg-046c03090d47bc4b89b818dc645c3865>Selektor Field</a></li><li>4.8: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>Label yang Disarankan</a></li></ul></ul><div class=content></div></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>1 - Apa itu Kubernetes?</h1><div class=lead>Kubernetes merupakan <em>platform open-source</em> yang digunakan untuk melakukan manajemen <em>workloads</em> aplikasi yang dikontainerisasi, serta menyediakan konfigurasi dan otomatisasi secara deklaratif. Kubernetes berada di dalam ekosistem yang besar dan berkembang cepat. <em>Service</em>, <em>support</em>, dan perkakas Kubernetes tersedia secara meluas. Kubernetes merupakan <em>platform open-source</em> yang digunakan untuk melakukan manajemen <em>workloads</em> aplikasi yang dikontainerisasi, serta menyediakan konfigurasi dan otomatisasi secara deklaratif. Kubernetes berada di dalam ekosistem yang besar dan berkembang cepat. <em>Service</em>, <em>support</em>, dan perkakas Kubernetes tersedia secara meluas.</div><p>Laman ini merupakan ikhtisar Kubernetes.</p><p>Kubernetes merupakan <i>platform open-source</i> yang digunakan untuk melakukan
manajemen <i>workloads</i> aplikasi yang dikontainerisasi, serta menyediakan
konfigurasi dan otomatisasi secara deklaratif. Kubernetes berada di dalam ekosistem
yang besar dan berkembang cepat. <i>Service</i>, <i>support</i>, dan perkakas
Kubernetes tersedia secara meluas.</p><p>Google membuka Kubernetes sebagai proyek <i>open source</i> pada tahun 2014.
Kubernetes dibangun berdasarkan <a href=https://research.google.com/pubs/pub43438.html>pengalaman Google selama satu setengah dekade dalam menjalankan workloads</a>
bersamaan dengan kontribusi berupa ide-ide terbaik yang diberikan oleh komunitas.</p><h2 id=mengapa-kubernetes-dan-hal-apa-saja-yang-dapat-dilakukan-oleh-kubernetes>Mengapa Kubernetes dan hal apa saja yang dapat dilakukan oleh Kubernetes?</h2><p>Kubernetes memiliki sejumlah fitur yang dapat dijabarkan sebagai berikut:</p><ul><li><i>platform</i> kontainer</li><li><i>platform microservices</i></li><li><i>platform cloud</i> yang tidak mudah dipindahkan</li></ul><p>Kubernetes menyediakan manajemen <i>environment</i> yang berpusat pada kontainer.
Kubernetes melakukan orkestrasi terhadap <i>computing</i>, <i>networking</i>,
dan inftrastruktur penyimpanan. Fitur inilah yang kemudian membuat konsep Platform as a Service (PaaS)
menjadi lebih sederhana dilengkapi dengan fleksibilitas yang dimiliki oleh Infrastructure as a Service (IaaS).</p><h2 id=lalu-apa-yang-menyebabkan-kubernetes-disebut-sebagai-sebuah-platform>Lalu apa yang menyebabkan Kubernetes disebut sebagai sebuah platform?</h2><p>Meskipun Kubernetes menyediakan banyak fungsionalitas, selalu ada keadaan dimana
hal tersebut membutuhkan fitur baru. <i>Workflow</i> spesifik yang terkait dengan
proses pengembangan aplikasi dapat ditambahkan pada <i>streamline</i> untuk meningkatkan
produktivitas developer. Orkestrasi ad-hoc yang dapat diterima biasanya membutuhkan desain
otomatisasi yang kokoh agar bersifat <i>scalable</i>. Hal inilah yang membuat
Kubernetes juga didesain sebagai <i>platform</i> untuk membangun ekosistem komponen dan
dan perkakas untuk memudahkan proses <i>deployment</i>, <i>scale</i>, dan juga manajemen
aplikasi.</p><p><a href>Labels</a> memudahkan pengguna mengkategorisasikan <i>resources</i> yang mereka miliki
sesuai dengan kebutuhan. <a href>Annotations</a> memungkinkan pengguna untuk menambahkan informasi
tambahan pada <i>resource</i> yang dimiliki.</p><p>Selain itu, <a href>Kubernetes control plane</a> dibuat berdasarkan
<a href=/docs/reference/using-api/api-overview/>API</a> yang tersedia bagi pengguna dan developer. Pengguna
dapat mengimplementasikan kontroler sesuai dengan kebutuhan mereka, contohnya adalah
<a href=https://github.com/kubernetes/community/blob/main/contributors/devel/scheduler.md>schedulers</a>,
dengan <a href>API kustom yang mereka miliki</a>, kontroler kustom ini kemudian dapat digunakan
pada <a href>command-line
tool</a> generik yang ada.</p><p><a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md>Desain</a>
inilah yang memungkinkan beberapa sistem lain untuk dapat dibangun di atas Kubernetes.</p><h2 id=lalu-hal-apakah-yang-tidak-termasuk-di-dalam-kubernetes>Lalu hal apakah yang tidak termasuk di dalam Kubernetes?</h2><p>Kubernetes bukanlah sebuah <i>PaaS (Platform as a
Service)</i> yang biasanya. Meskipun Kubernetes dijalankan pada tingkatan kontainer
dan bukan pada tingkatan perangkat keras, Kubernetes menyediakan beberapa fitur
yang biasanya disediakan oleh Paas, seperti <i>deployment</i>, <i>scaling</i>,
<i>load balancing</i>, <i>logging</i>, dan <i>monitoring</i>. Akan tetapi,
Kubernetes bukanlah sistem monolitik, melainkan suatu sistem yang bersifat sebagai
<i>bulding block</i> dan <i>pluggable</i> yang dapat digunakan untuk membangun sebuah
platform yang dibutuhkan oleh developer dengan tetap mengutamakan konsep fleksibilitas.</p><p>Kubernetes:</p><ul><li>Tidak melakukan limitasi terhadap aplikasi yang di-support. Kubernetes bertujuan
untuk mendukung berbagai variasi <i>workloads</i>, termasuk
<i>stateless</i>, <i>stateful</i>, dan <i>data-processing</i>. Jika sebuah
aplikasi dapat dijalankan di atas kontainer, maka aplikasi tersebut juga dapat
dijalankan di atas Kubernetes.</li><li>Tidak menyediakan mekanisme untuk melakukan <i>deploy</i> kode sumber
maupun mekanisme <i>build</i> sebuah aplikasi. <i>Continuous Integration, Delivery, and Deployment
(CI/CD) workflows</i> ditentukan oleh preferensi serta kebutuhan teknis organisasi.</li><li>Tidak menyediakan <i>application-level services</i>, seperti <i>middleware
(e.g., message buses)</i>, <i>data-processing frameworks (for example,
Spark)</i>, <i>databases (e.g., mysql)</i>, <i>caches</i>, maupun <i>cluster storage systems (e.g.,
Ceph)</i> sebagai suatu <i>built-in services</i>. Komponen tersebut dapat dijalankan di atas Kubernetes, dan/atau
dapat diakses oleh aplikasi yang dijalankan di atas Kubernetes melalui sebuah mekanisme tidak mudah dipindahkan
misalnya saja <i>Open Service Broker</i>.</li><li>Tidak membatasi penyedia layanan <i>logging</i>, <i>monitoring</i>, maupun <i>alerting</i> yang digunakan.
Kubernetes menyediakan <i>proof of concept</i> dan mekanisme integrasi yang dapat digunakan
untuk mengumpulkan serta mengekspor metriks yang ada.</li><li>Tidak menyediakan atau mengharuskan penggunaan <i>configuration language/system (e.g.,
<a href=https://github.com/google/jsonnet>jsonnet</a>)</i>. Kubernetes menyediakan suatu API deklaratif
yang dapat digunakan oleh berbagai jenis spesifikasi deklaratif.</li><li>Tidak menyediakan atau mengadaptasi sebuah konfigurasi, <i>maintenance</i>, manajemen, atau
<i>self-healing</i> mesin dengan spesifikasi khusus.</li></ul><p>Sebagai tambahan, Kubernetes bukanlah sebuah <em>sitem orkestrasi biasa</em>. Bahkan pada kenyataannya,
Kubernetes menghilangkan kebutuhan untuk melakukan orkestrasi. Definisi teknis dari
<em>orkestrasi</em> merupakan eksekusi dari sebuah workflow yang sudah didefinisikan sebelumnya: pertama kerjakan A, kemudian B,
dan terakhir C. Sebaliknya, Kubernetes disusun oleh seperangkat
proses kontrol yang dapat idekomposisi yang selalu menjalankan <i>state</i> yang ada
saat ini hingga sesuai dengan <i>state</i> yang dinginkan.
Kita tidak perlu peduli proses apa saja yang perlu dilakukan untuk melakukan A hingga C.
Mekanisme kontrol yang tersentralisasi juga tidak dibutuhkan. Dengan demikian, sistem yang
dihasilkan lebih mudah digunakan lebih kokoh, serta lebih <i>extensible</i>.</p><h2 id=mengapa-kontainer>Mengapa kontainer?</h2><p>Mencari alasan kenapa kita harus menggunakan kontainer?</p><p><img src=/images/docs/why_containers.svg alt="Mengapa kontainer?"></p><p><em>Cara Lama</em> untuk melakukan mekanisme <i>deploy</i> suatu aplikasi
adalah dengan cara instalasi aplikasi tersebut pada sebuah mesin
dengan menggunakan <i>package manager</i> yang dimiliki oleh sistem operasi
mesin tersebut. Hal ini menciptakan suatu ketergantungan antara <i>executables</i>,
konfigurasi, serta ketergantungan lain yang dibutuhkan aplikasi dengan sistem operasi
yang digunakan oleh mesin. Untuk mengatasi hal ini, tentunya bisa saja kita melakukan
mekanisme <i>build</i> suatu <i>image</i> VM yang <i>immutable</i> untuk mendapatkan
mekanisme <i>rollouts</i> dan <i>rollback</i> yang dapat diprediksi.
Meskipun demikian, VM masih dianggap "berat" dan tidak tidak mudah dipindahkan.</p><p><em>Cara Baru</em> adalah dengan melakukan mekanisme <i>deploy</i> kontainer pada tingkatan
virtualisasi di level sistem operasi (OS) bukan pada tingkatan virtualisasi perangkat keras.
Kontainer ini berada dalam lingkungan yang terisolasi satu sama lain serta terisolasi dengan
mesin dimana kontainer ini berada. Kontainer ini memiliki <i>filesystems</i> masing-masing.
Selain itu, setiap kontainer tidak dapat "melihat" <i>process</i> yang sedang dijalankan di
kontainer lain. Selain itu <i>resource</i> komputasi yang digunakan oleh kontainer
ini juga dapat dibatasi. Kontainer juga dapat dengan lebih mudah di-<i>build</i> jika
dibandingkan dengan VM, karena kontainer tidak bergantung pada <i>filesystem</i>
yang dimiliki mesin, serta dengan mudah dapat didistribusikan.</p><p>Karena kontainer ukurannya kecil dan lebih cepat, sebuah aplikasi dapat dibangun di setiap
<i>image</i> kontainer. Mekanisme pemetaan satu-satu antara kontainer dan aplikasi
inilah yang membuka keuntungan secara meyeluruh yang dapat diberikan oleh kontainer.
Dengan menggunakan kontainer, <i>image</i> kontainer dapat dibuat diwaktu rilis aplikasi.
Pembuatan <i>image</i> ini memungkinkan aplikasi secara konsisten dirilis pada
<i>environment</i> <i>development</i> maupun <i>production</i>. Selain itu,
kontainer juga memiliki transparasi yang lebih tinggi dibandingkan dengan VM. Maksudnya,
infrastruktur punya tugas untuk mengatur lifecycle seluruh process yang ada di dalam kontainer. Ini bukanlah lagi tugas sebuah supervisor process yang tersembunyi di dalam kontainer.</p><p>Secara garis besar, penggunaan kontainer memiliki keuntungan sebagai berikut:</p><ul><li><strong>Mekanisme pembuatan aplikasi serta proses deployment yang lebih efektif</strong>:
Kontainer dapat meningkatkan kemudahan dan efisiensi jika dibandingkan dengan penggunaan VM.</li><li><strong>Continuous development, integration, and deployment</strong>:
Digunakan untuk melakukan proses <i>build</i> dan <i>deploy</i> yang sering dilakukan
serta kemudahan mekanisme <i>rollback</i> karena image yang ada sifatnya <i>immutable</i>.</li><li><strong>Pemisahan kepentingan antara Dev dan Ops</strong>:
Pembuatan <i>image</i> container dilakukan pada saat rilis dan bukan pada saat <i>deploy</i>
mengurangi ketergantungan aplikasi dan infrastruktur.</li><li><strong>Observabilitas</strong>
Tidak hanya informasi dan metriks pada level OS, tapi juga kesehatan aplikasi dan <i>signal</i> lain.</li><li><strong>Konsistensi <i>environment</i> pada masa pengembangan , <i>testing</i>, dan <i>production</i></strong>:
Memiliki perilaku yang sama baik ketika dijalankan di mesin lokal maupun penyedia layanan <i>cloud</i>.</li><li><strong>Portabilitas antar penyedia layanan <i>cloud</i> maupun distribusi OS</strong>:
Dapat dijalankan pada Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine, dan dimanapun.</li><li><strong>Manajemen yang bersifat Aplikasi sentris</strong>:
Meningkatkan level abstraksi dari proses menjalankan OS pada perangkat keras virtual
ke proses menjalankan aplikasi pada sebuah OS dengan menggunakan <i>resource</i> logis.</li><li><strong><a href=https://martinfowler.com/articles/microservices.html>Mikroservis</a> yang renggang (loosely coupled), terdistribusi, elastis, dan terliberasi</strong>:
Aplikasi dapat dipecah menjadi komponen yang lebih kecil yang independen dan dapat
di-<i>deploy</i> dan diatur secara dinamis -- bukan sebuah sistem monolitik yang dijalankan pada
sebuah mesin yang hanya punya satu tujuan.</li><li><strong>Isolasi <i>resource</i></strong>:
Performa aplikasi yang bisa diprediksi.</li><li><strong>Utilisasi <i>resource</i></strong>:
Efisiensi yang tinggi</li></ul><h2 id=apakah-arti-kubernetes-k8s>Apakah arti Kubernetes? K8s?</h2><p>Nama <strong>Kubernetes</strong> berasal dari Bahasa Yunani, yang berarti <em>juru mudi</em> atau
<em>pilot</em>, dan merupakan asal kata <em>gubernur</em> dan
<a href="http://www.etymonline.com/index.php?term=cybernetics">cybernetic</a>. <em>K8s</em>
merupakan sebuah singkatan yang didapat dengan mengganti 8 huruf "ubernete" dengan
"8".</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Siap untuk <a href=/docs/setup/>memulai</a>?</li><li>Untuk penjelasan lebih rinci, silahkan lihat <a href=/docs/home/>Dokumentasi Kubernetes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>2 - Komponen-Komponen Kubernetes</h1><div class=lead>Sebuah klaster Kubernetes terdiri dari komponen yang merepresentasikan bidang kontrol dan sepasang mesin yaitu <em>nodes</em>.</div><p>Dokumen ini merupakan ikhtisar yang mencakup berbagai komponen
yang dibutuhkan agar klaster Kubernetes dapat berjalan secara fungsional.</p><h2 id=komponen-i-master-i>Komponen <i>Master</i></h2><p>Komponen <i>master</i> menyediakan <i>control plane</i> bagi klaster.
Komponen ini berperan dalam proses pengambilan secara global
pada klaster (contohnya, mekanisme <i>schedule</i>), serta berperan dalam proses
deteksi serta pemberian respons terhadap <i>events</i> yang berlangsung di dalam klaster
(contohnya, penjadwalan pod baru apabila jumlah replika yang ada pada
<i>replication controller</i> tidak terpenuhi).</p><p>Komponen master dapat dijalankan di mesin manapun yang ada di klaster. Meski begitu,
untuk memudahkan proses yang ada, <i>script</i> inisiasi awal yang dijalankan
biasanya memulai komponen master pada mesin yang sama, serta tidak menjalankan
kontainer bagi pengguna di mesin ini. Contoh konfigurasi <i>multi-master VM</i>
dapat dilihat di modul [Membangun Klaster HA] (/docs/admin/high-availability/).</p><h3 id=kube-apiserver>kube-apiserver</h3><p>Komponen <em>control plane</em> yang mengekspos API Kubernetes. Merupakan <em>front-end</em> dari <em>control plane</em> Kubernetes.</p><p>Komponen ini didesain agar dapat diskalakan secara horizontal. Lihat <a href=/docs/admin/high-availability/>Membangun Klaster HA</a>.</p><h3 id=etcd>etcd</h3><p>Penyimpanan <i>key value</i> konsisten yang digunakan sebagai penyimpanan data klaster Kubernetes.</p><p>Selalu perhatikan mekanisme untuk mem-<i>backup</i> data etcd pada klaster Kubernetes kamu. Untuk informasi lebih lanjut tentang etcd, lihat <a href=https://etcd.io/docs>dokumentasi etcd</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Komponen <em>control plane</em> yang bertugas mengamati <a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> baru yang belum ditempatkan di node manapun dan kemudian memilihkan <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a> di mana Pod baru tersebut akan dijalankan.</p><p>Faktor-faktor yang dipertimbangkan untuk keputusan penjadwalan termasuk: kebutuhan sumber daya secara individual dan kolektif, batasan perangkat keras/perangkat lunak/peraturan, spesifikasi afinitas dan nonafinitas, lokalisasi data, interferensi antar beban kerja dan tenggat waktu.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Komponen <em>control plane</em> yang menjalankan pengontrol.</p><p>Secara logis, setiap pengontrol adalah sebuah proses yang berbeda, tetapi untuk mengurangi kompleksitas, kesemuanya dikompilasi menjadi sebuah biner (<em>binary</em>) yang dijalankan sebagai satu proses.</p><p>Kontroler-kontroler ini meliputi:</p><ul><li>Kontroler <i>Node</i> : Bertanggung jawab untuk mengamati dan memberikan
respons apabila jumlah <i>node</i> berkurang.</li><li>Kontroler Replikasi : Bertanggung jawab untuk menjaga jumlah <i>pod</i> agar
jumlahnya sesuai dengan kebutuhan setiap objek kontroler replikasi yang ada di sistem.</li><li>Kontroler <i>Endpoints</i> : Menginisiasi objek <i>Endpoints</i>
(yang merupakan gabungan <i>Pods</i> dan <i>Services</i>).</li><li>Kontroler <i>Service Account & Token</i>: Membuat akun dan
akses token API standar untuk setiap <i>namespaces</i> yang dibuat.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/>Cloud-controller-manager</a> merupakan kontroler yang berinteraksi dengan penyedia layanan <i>cloud</i>.
Kontroler ini merupakat fitur alfa yang diperkenalkan pada Kubernetes versi 1.6.</p><p><i>Cloud-controller-manager</i> hanya menjalankan iterasi kontroler <i>cloud-provider-specific</i> .
Kamu harus menonaktifkan iterasi kontroler ini pada <i>kube-controller-manager</i>.
Kamu dapat menonaktifka iterasi kontroler ini dengan mengubah nilai argumen <code>--cloud-provider</code> dengan <code>external</code>
ketika menginisiasi <i>kube-controller-manager</i>.</p><p>Adanya <i>cloud-controller-manager</i> memungkinkan kode yang dimiliki oleh penyedia layanan <i>cloud</i>
dan kode yang ada pada Kubernetes saling tidak bergantung selama masa <i>development</i>.
Pada versi sebelumnya, Kubernetes bergantung pada fungsionalitas spesifik yang disediakan oleh
penyedia layanan <i>cloud</i>. Di masa mendatang, kode yang secara spesifik dimiliki oleh
penyedia layanan <i>cloud</i> akan dipelihara oleh penyedia layanan <i>cloud</i> itu sendiri,
kode ini selanjutnya akan dihubungkan dengan <i>cloud-controller-manager</i> ketika Kubernetes dijalankan.</p><p>Kontroler berikut ini memiliki keterkaitan dengan penyedia layanan <i>cloud</i>:</p><ul><li>Kontroler Node : Melakukan pengecekan pada penyedia layanan <i>cloud</i> ketika menentukan apakah sebuah <i>node</i> telah dihapus pada <i>cloud</i> apabila <i>node</i> tersebut berhenti memberikan respons.</li><li>Kontroler Route : Melakukan pengaturan awal <i>route</i> yang ada pada penyedia layanan <i>cloud</i></li><li>Kontroler Service : Untuk membuat, memperbaharui, menghapus <i>load balancer</i> yang disediakan oleh penyedia layanan <i>cloud</i></li><li>Kontroler Volume : Untuk membuat, meng-attach, dan melakukan <i>mount volume</i> serta melakukan inetraksi dengan penyedia layanan <i>cloud</i> untuk melakukan orkestrasi <i>volume</i></li></ul><h2 id=komponen-i-node-i>Komponen <i>Node</i></h2><p>Komponen ini ada pada setiap <i>node</i>, fungsinya adalah melakukan pemeliharaan terhadap <i>pod</i> serta menyediakan <i>environment runtime</i> bagi Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Agen yang dijalankan pada setiap node di klaster yang bertugas untuk memastikan kontainer dijalankan di dalam Pod.</p><h3 id=kube-proxy>kube-proxy</h3><p><a href=/docs/admin/kube-proxy/>kube-proxy</a> membantu abstraksi service Kubernetes melakukan tugasnya. Hal ini terjadi dengan cara memelihara aturan-aturan jaringan (network rules) serta meneruskan koneksi yang ditujukan pada suatu host.</p><h3 id=i-container-runtime-i><i>Container Runtime</i></h3><p><i>Container runtime</i> adalah perangkat lunak yang bertanggung jawab dalam menjalankan kontainer.
Kubernetes mendukung beberapa <i>runtime</i>, diantaranya adalah: <a href=http://www.docker.com>Docker</a>, <a href=https://containerd.io>containerd</a>, <a href=https://cri-o.io/>cri-o</a>, <a href=https://github.com/kubernetes-incubator/rktlet>rktlet</a> dan semua implementasi <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=i-addons-i><i>Addons</i></h2><p><i>Addons</i> merupakan pod dan service yang mengimplementasikan fitur-fitur yang diperlukan klaster.</p><p>Beberapa <i>addons</i> akan dijelaskan selanjutnya.</p><h3 id=dns>DNS</h3><p>Meskipun tidak semua <i>addons</i> dibutuhkan, semua klaster Kubernetes hendaknya
memiliki DNS klaster. Komponen ini penting karena banyak dibutuhkan oleh komponen
lainnya.</p><p><a href=/id/docs/concepts/cluster-administration/addons/>Klaster DNS</a> adalah server DNS, selain beberapa server DNS lain yang sudah ada di
<i>environment</i> kamu, yang berfungsi sebagai catatan DNS bagi Kubernetes <i>services</i></p><p>Kontainer yang dimulai oleh kubernetes secara otomatis akan memasukkan server DNS ini
ke dalam mekanisme pencarian DNS yang dimilikinya.</p><h3 id=i-web-ui-i-dasbor><i>Web UI</i> (Dasbor)</h3><p><a href=/id/docs/tasks/access-application-cluster/web-ui-dashboard/>Dasbor</a> adalah antar muka berbasis web multifungsi yang ada pada klaster Kubernetes.
Dasbor ini memungkinkan user melakukan manajemen dan <i>troubleshooting</i> klaster maupun
aplikasi yang ada pada klaster itu sendiri.</p><h3 id=i-container-resource-monitoring-i><i>Container Resource Monitoring</i></h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Container Resource Monitoring</a> mencatat metrik <i>time-series</i> yang diperoleh
dari kontainer ke dalam basis data serta menyediakan antar muka yang dapat digunakan
untuk melakukan pencarian data yang dibutuhkan.</p><h3 id=i-cluster-level-logging-i><i>Cluster-level Logging</i></h3><p><a href=/id/docs/concepts/cluster-administration/logging/>Cluster-level logging</a> bertanggung jawab mencatat <i>log</i> kontainer pada
penyimpanan <i>log</i> terpusat dengan antar muka yang dapat digunakan untuk melakukan
pencarian.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>3 - API Kubernetes</h1><div class=lead>API Kubernetes membuatmu dapat melakukan <em>query</em> dan memanipulasi keadaan objek dalam Kubernetes. Inti dari bidang kontrol Kubernetes adalah <em>server</em> API dan HTTP API yang diekspos. Pengguna, berbagai bagian klastermu, dan komponen eksternal semuanya berkomunikasi satu sama lain melalui server API.</div><p>Secara keseluruhan standar yang digunakan untuk API dijelaskan di dalam <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>dokumentasi API standar</a>.</p><p><i>Endpoints API</i>, <i>resource types</i> serta contoh penggunaan dijelaskan di dalam <a href=/docs/reference>API Reference</a>.</p><p>Akses <i>remote</i> penggunaan API dijelaskan di dalam <a href=/docs/reference/access-authn-authz/controlling-access/>dokumentasi akses API</a>.</p><p>API Kubernetes juga berperan sebagai skema konfigurasi yang deklaratif di dalam sistem.. Sementara itu, <a href=/docs/reference/kubectl/overview/>kubectl</a> merupakan <i>command-line</i> yang dapat digunakan untuk membuat, menmperbaharui, menghapus, dan mendapatkan obyek API.</p><p>Kubernetes menyimpan bentuk terserialisasi dari obyek API yang dimilikinya di dalam <a href=https://coreos.com/docs/distributed-configuration/getting-started-with-etcd/>etcd</a>.</p><p>Kubernetes sendiri dibagi menjadi beberapa komponen yang saling dapat saling interaksi melalui API.</p><h2 id=perubahan-api>Perubahan API</h2><p>Berdasarkan pengalaman kami, semua sistem yang berhasil memerlukan kebutuhan
untuk terus tumbuh dan berkembang seiring dengan bertambahnya kebutuhan
yang ada. Dengan demikian, kami berekspektasi bahwa API akan selalu berubah seiring dengan bertambahnya kebutuhan yang ada.
Meski begitu, perubahan yang ada akan selalu kompatibel dengan implementasi sebelumnya, untuk jangka waktu tertentu.
Secara umum, penambahan pada sebuah resource API atau field resource bisa sering terjadi.. Penghapusan <i>resource API</i> atau suatu <i>field</i>, di sisi lain,
diharapkan untuk dapat memenuhi <a href=/docs/reference/using-api/deprecation-policy/>kaidah deprecation API</a>.</p><p>Hal-hal apa saja yang perlu diperhatikan untuk menjamin kompatibilitas API
secara rinci dibahas di dalam <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md>dokumentasi perubahan API</a>.</p><h2 id=swagger-and-openapi-definition>Swagger and OpenAPI Definition</h2><p>Detail mengenai API didokumentasikan dengan menggunakan <a href=https://www.openapis.org/>OpenAPI</a>.</p><p>Semenjak Kubernetes versi 1.10, Kubernetes menghadirkan spesifikasi <i>OpenAPI</i> melalui <i>endpoint</i> <code>/openapi/v2</code>.
Format <i>request</i> dapat diterapkan dengan cara menambahkan <i>header HTTP</i>:</p><table><thead><tr><th>Header</th><th>Opsi</th></tr></thead><tbody><tr><td>Accept</td><td><code>application/json</code>, <code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code> (<i>content-type</i> standar yang digunakan adalah <code>application/json</code> untuk <code>*/*</code>)</td></tr><tr><td>Accept-Encoding</td><td><code>gzip</code></td></tr></tbody></table><p>Sebelum versi 1.14, terdapat 4 buah <i>endpoint</i> yang menyediakan spesifikasi <i>OpenAPI</i>
dalam format berbeda yang dapat digunakan (<code>/swagger.json</code>, <code>/swagger-2.0.0.json</code>, <code>/swagger-2.0.0.pb-v1</code>, <code>/swagger-2.0.0.pb-v1.gz</code>).
<i>Endpoint</i> ini bersifat <i>deprecated</i> dan akan dihapus pada Kubernetes versi 1.14.</p><p><strong>Cara mendapatkan spesifikasi <i>OpenAPI</i></strong>:</p><table><thead><tr><th>Sebelum 1.10</th><th>Mulai Kubernetes 1.10</th></tr></thead><tbody><tr><td>GET /swagger.json</td><td>GET /openapi/v2 <strong>Accept</strong>: application/json</td></tr><tr><td>GET /swagger-2.0.0.pb-v1</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf</td></tr><tr><td>GET /swagger-2.0.0.pb-v1.gz</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf <strong>Accept-Encoding</strong>: gzip</td></tr></tbody></table><p>Kubernetes juga menyediakan alternatif mekanisme serialisasi lain,
yaitu dengan menggunakan <i>Protobuf</i>, yang secara umum digunakan untuk mekanisme komunikasi
intra-klaster, hal ini didokumentasikan di dalam <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md>proposal desain</a>
serta berkas IDL sebagai bentuk spesifikasi skema berada dalam <i>package</i> Go</p><p>Sebelum Kubernetes versi 1.14, <i>apiserver</i> Kubernetes juga mengekspos API
yang dapat digunakan untuk mendapatkan spesifikasi <a href=http://swagger.io/>Swagger v1.2</a> pada <i>endpoint</i> <code>/swaggerapi</code>.
<i>Endpoint</i> ini akan sudah bersifat <i>deprecated</i> dan akan dihapus pada
Kubernetes versi 1.14.</p><h2 id=pemberian-versi-pada-api>Pemberian Versi pada API</h2><p>Untuk memudahkan restrukturisasi field dan resource yang ada,
Kubernetes menyediakan beberapa versi API yang berada pada <i>path</i> yang berbeda,
misalnya <code>/api/v1</code> atau <code>/apis/extensions/v1beta1</code>.</p><p>Kita dapat memilih versi yang akan digunakan pada tingkatan API
dan bukan pada tingkatan <i>field</i> atau <i>resource</i> untuk memastikan
API yang digunakan memperlihatkan gambaran yang jelas serta konsisten
mengenai <i>resoure</i> dan sifat sistem yang ada.</p><p>Perhatikan bahwa pemberian versi pada API dan pemberian versi pada API dan perangkat lunak memiliki keterkaitan secara tak langsung.
Proposal <a href=https://git.k8s.io/community/contributors/design-proposals/release/versioning.md>API and release
versioning</a> memberikan deskripsi keterkaitan antara
pemberian versi pada API dan pemberian versi pada perangkat lunak.</p><p>API dengan versi yang berbeda menunjukan tingkatan kestabilan dan ketersediaan yang diberikan pada versi tersebut.
Kriteria untuk setiap tingkatan dideskripsikan secara lebih detail di dalam
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>dokumentasi perubahan API</a>. They are summarized here:</p><ul><li>Tingkatan <i>Alpha</i>:<ul><li>Nama dari versi ini mengandung string <code>alpha</code> (misalnya, <code>v1alpha1</code>).</li><li>Bisa jadi terdapat <i>bug</i>. Secara <i>default</i> fitur ini tidak diekspos.</li><li>Ketersediaan untuk fitur yang ada bisa saja dihilangkan pada suatu waktu tanpa pemberitahuan sebelumnya.</li><li>API yang ada mungkin saja berubah tanpa memperhatikan kompatibilitas dengan versi perangkat lunak sebelumnya.</li><li>Hanya direkomendasikan untuk klaster yang digunakan untuk tujuan <i>testing</i>.</li></ul></li><li>Tingkatan <i>Beta</i>:<ul><li>Nama dari versi ini mengandung string <code>beta</code> (misalnya <code>v2beta3</code>).</li><li>Kode yang ada sudah melalui mekanisme <i>testing</i> yang cukup baik. Menggunakan fitur ini dianggap cukup aman. Fitur ini diekspos secara <i>default</i>.</li><li>Ketersediaan untuk fitur secara menyeluruh tidak akan dihapus, meskipun begitu detail untuk suatu fitur bisa saja berubah.</li><li>Skema dan/atau semantik dari suatu obyek mungkin saja berubah tanpa memerhatikan kompatibilitas pada rilis <i>beta</i> selanjutnya.
Jika hal ini terjadi, kami akan menyediakan suatu instruksi untuk melakukan migrasi di versi rilis selanjutnya. hal ini bisa saja terdiri dari penghapusan, pengubahan, ataupun pembuatan
obyek API. Proses pengubahan mungkin saja membutuhkan pemikiran yang matang. Dampak proses ini bisa saja menyebabkan <i>downtime</i> aplikasi yang bergantung pada fitur ini.</li><li>Disarankan hanya untuk digunakan untuk penggunaan yang untuk penggunaan yang tidak berdampak langsung pada bisnis kamu.</li><li><strong>Kami mohon untuk mencoba versi <i>beta</i> yang kami sediakan dan berikan masukan terhadap fitur yang kamu pakai! Apabila fitur tersebut sudah tidak lagi berada di dalam tingkatan <i>beta</i> perubahan yang kami buat terhadap fitur tersebut bisa jadi tidak lagi dapat digunakan</strong></li></ul></li><li>Tingkatan stabil:<ul><li>Nama dari versi ini mengandung string <code>vX</code> dimana <code>X</code> merupakan bilangan bulat.</li><li>Fitur yang ada pada tingkatan ini akan selalu muncul di rilis berikutnya.</li></ul></li></ul><h2 id=i-api-groups-i><i>API groups</i></h2><p>Untuk memudahkan proses ekstensi suatu API Kubernetes, kami mengimplementasikan <a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md><em>API groups</em></a>.
<i>API group</i> ini dispesifikasikan di dalam <i>path</i> <i>REST</i> serta di dalam <i>field</i> <code>apiVersion</code> dari sebuah obyek yang sudah diserialisasi.</p><p>Saat ini, terdapat beberapa <i>API groups</i> yang digunakan:</p><ol><li><p>Kelompok <em>core</em>, seringkali disebut sebagai <em>legacy group</em>, berada pada <i>path</i> <i>REST</i> <code>/api/v1</code> serta menggunakan <code>apiVersion: v1</code>.</p></li><li><p><i>Named groups</i> berada pada <i>path</i> <i>REST</i> <code>/apis/$GROUP_NAME/$VERSION</code>, serta menggunakan <code>apiVersion: $GROUP_NAME/$VERSION</code>
(misalnya <code>apiVersion: batch/v1</code>). Daftar menyeluruh mengenai apa saja <i>API groups</i> dapat dilihat di <a href=/docs/reference/>Kubernetes API reference</a>.</p></li></ol><p>Ekstensi API dengan custom resources dapat dilakukan melalui dua buah path:</p><ol><li><a href>CustomResourceDefinition</a>
digunakan jika memerlukan seluruh set semantik Kubernetes API, pengguna boleh implementasi apiserver sendiri dengan menggunakan aggregator.</li><li>Pengguna yang membutuhkan seperangkat semantik API Kubernetes API dapat mengimplementasikan <i>apiserver</i> mereka sendiri.
dengan menggunakan <a href>aggregator</a>
untuk membuat integrasi dengan klien menjadi lebih mudah.</li></ol><h2 id=mengaktifkan-i-api-groups-i>Mengaktifkan <i>API groups</i></h2><p>Beberapa <i>resources</i> dan <i>API groups</i> sudah diaktifkan secara <i>default</i>.
<i>Resource</i> dan <i>API groups</i> ini dapat diaktifkan dan dinonaktifkan dengan mengatur penanda <code>--runtime-config</code>
pada <i>apiserver</i>. <code>--runtime-config</code> menerima nilai yang dipisahkan oleh koma. Sebagai contoh: untuk menonaktifkan batch/v1, tetapkan
<code>--runtime-config=batch/v1=false</code>, untuk mengaktifkan batch/v2alpha1, tetapkan <code>--runtime-config=batch/v2alpha1</code>.
Penanda menerima nilai yang dipisahkan oleh pasangan <code>key=value</code> yang mendeskripsikan konfigurasi <i>runtime</i> pada <i>apiserver</i>.</p><p>PENTING: Melakukan proses mengaktifkan atau menonaktifkan <i>groups</i> atau <i>resources</i>
membutuhkan mekanisme <i>restart</i> <i>apiserver</i> dan <i>controller-manager</i>
agar <i>apiserver</i> dapat menerima perubahan <code>--runtime-config</code>.</p><h2 id=mengaktifkan-i-resources-i-di-dalam-i-groups-i>Mengaktifkan <i>resources</i> di dalam <i>groups</i></h2><p><i>DaemonSets</i>, <i>Deployments</i>, <i>HorizontalPodAutoscalers</i>,
<i>Ingresses</i>, <i>Jobs</i>, dan <i>ReplicaSets</i> diaktifkan secara <i>default</i>.
Ekstensi lain dapat diaktifkan penanda <code>--runtime-config</code> pada <i>apiserver</i>. Penanda <code>--runtime-config</code> menerima nilai yang dipisahkan oleh koma.
Sebagai contoh untuk menonaktifkan <i>deployments</i> dan <i>ingress</i>, tetapkan.
<code>--runtime-config=extensions/v1beta1/deployments=false,extensions/v1beta1/ingresses=false</code></p></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>4 - Menggunakan Objek-Objek Kubernetes</h1><div class=lead>Objek-objek Kubernetes adalah entitas yang tetap dalam sistem Kubernetes. Kubernetes menggunakan entitas tersebut untuk merepresentasikan keadaan dari klastermu. Pelajari tentang objek model Kubernetes dan bagaimana menggunakan objek tersebut.</div></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>4.1 - Memahami Konsep Objek-Objek yang ada pada Kubernetes</h1><p>Laman ini menjelaskan bagaimana objek-objek Kubernetes direpresentasikan di dalam API Kubernetes,
dan bagaimana kamu dapat merepresentasikannya di dalam format <code>.yaml</code>.</p><h2 id=memahami-konsep-objek-objek-yang-ada-pada-kubernetes>Memahami Konsep Objek-Objek yang Ada pada Kubernetes</h2><p>Objek-objek Kubernetes adalah entitas persisten di dalam sistem Kubernetes.
Kubernetes menggunakan entitas ini untuk merepresentasikan <em>state</em> yang ada pada
klaster kamu. Secara spesifik, hal itu dapat dideskripsikan sebagai:</p><ul><li>Aplikasi-aplikasi kontainer apa sajakah yang sedang dijalankan (serta pada <em>node</em> apa aplikasi tersebut dijalankan)</li><li><em>Resource</em> yang tersedia untuk aplikasi tersebut</li><li><em>Policy</em> yang mengatur bagaimana aplikasi tersebut dijalankan, misalnya <em>restart</em>, <em>upgrade</em>, dan <em>fault-tolerance</em>.</li></ul><p>Objek Kubernetes merupakan sebuah <em>"record of intent"</em>--yang mana sekali kamu membuat suatu objek,
sistem Kubernetes akan bekerja secara konsisten untuk menjamin
bahwa objek tersebut akan selalu ada. Dengan membuat sebuah objek, secara tak langsung kamu
memberikan informasi pada sistem Kubernetes mengenai perilaku apakah yang kamu inginkan pada <em>workload</em> klaster yang kamu miliki;
dengan kata lain ini merupakan definisi <em>state</em> klaster yang kamu inginkan.</p><p>Untuk menggunakan objek-objek Kubernetes--baik membuat, mengubah, atau menghapus objek-objek tersebut--kamu
harus menggunakan <a href=/id/docs/concepts/overview/kubernetes-api/>API Kubernetes</a>.
Ketika kamu menggunakan perintah <code>kubectl</code>, perintah ini akan melakukan <em>API call</em> untuk perintah
yang kamu berikan. Kamu juga dapat menggunakan API Kubernetes secara langsung pada program yang kamu miliki
menggunakan salah satu <a href=/docs/reference/using-api/client-libraries/><em>library</em> klien</a> yang disediakan.</p><h3 id=spec-dan-status-objek><em>Spec</em> dan Status Objek</h3><p>Setiap objek Kubernetes memiliki <em>field</em> berantai yang mengatur konfigurasi sebuah objek:
<em>spec</em> dan status. <em>Spec</em>, merupakan <em>field</em> yang harus kamu sediakan, <em>field</em> ini mendeskripsikan
<em>state</em> yang kamu inginkan untuk objek tersebut--karakteristik dari objek yang kamu miliki.
Status mendeskripsikan <em>state</em> yang sebenarnya dari sebuah objek, dan hal ini disediakan dan selalu diubah oleh
sistem Kubernetes. Setiap saat, <em>Control Plane</em> Kubernetes selalu memantau apakah <em>state</em> aktual sudah sesuai dengan
<em>state</em> yang diinginkan.</p><p>Sebagai contoh, <em>Deployment</em> merupakan sebuah objek yang merepresentasikan sebuah aplikasi yang dijalankan di klaster kamu.
Ketika kamu membuat sebuah <em>Deployment</em>, kamu bisa saja memberikan <em>spec</em> bagi <em>Deployment</em> untuk memberikan spesifikasi
berapa banyak <em>replica</em> yang kamu inginkan. Sistem Kubernetes kemudian akan membaca konfigurasi yang kamu berikan
dan mengaktifkan tiga buah instans untuk aplikasi yang kamu inginkan--mengubah status yang ada saat ini agar sesuai dengan apa yang kamu inginkan.
Jika terjadi kegagalan dalam instans yang dibuat, sistem Kubernetes akan memberikan respons bahwa terdapat perbedaan antara <em>spec</em> dan status serta
melakukan penyesuaian dengan cara memberikan instans pengganti.</p><p>Informasi lebih lanjut mengenai <em>spec</em> objek, status, dan <em>metadata</em> dapat kamu baca di <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Konvensi API Kubernetes</a>.</p><h3 id=mendeskripsikan-objek-kubernetes>Mendeskripsikan Objek Kubernetes</h3><p>Ketika kamu membuat sebuah objek di Kubernetes, kamu harus menyediakan <em>spec</em> objek yang
mendeskripsikan <em>state</em> yang diinginkan, serta beberapa informasi tentang objek tersebut (seperti nama).
Ketika kamu menggunakan API Kubernetes untuk membuat objek tersebut (baik secara langsung atau menggunakan perintah
<code>kubectl</code>), <em>request</em> API yang dibuat harus mencakup informasi seperti <em>request body</em> dalam format JSON.
Apabila kamu memberikan <strong>informasi dalam bentuk <code>.yaml</code> ketika menggunakan perintah <code>kubectl</code></strong> maka <code>kubectl</code>
akan mengubah informasi yang kamu berikan ke dalam format JSON ketika melakukan <em>request</em> API.</p><p>Berikut merupakan contoh <em>file</em> <code>.yaml</code> yang menunjukkan <em>field</em> dan <em>spec</em> objek untuk <em>Deployment</em>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Salah satu cara untuk membuat <em>Deployment</em> menggunakan <em>file</em> <code>.yaml</code>
seperti yang dijabarkan di atas adalah dengan menggunakan perintah
<a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>
pada <em>command-line interface</em> <code>kubectl</code> kamu menerapkan <em>file</em> <code>.yaml</code> sebagai sebuah argumen.
Berikut merupakan contoh penggunaannya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
</span></span></code></pre></div><p>Keluaran yang digunakan kurang lebih akan ditampilkan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/nginx-deployment created
</span></span></code></pre></div><h3 id=field-field-yang-dibutuhkan><em>Field-Field</em> yang dibutuhkan</h3><p>Pada <em>file</em> <code>.yaml</code> untuk objek Kubernetes yang ingin kamu buat, kamu perlu
menyediakan <em>value</em> untuk <em>field-field</em> berikut:</p><ul><li><em>apiVersion</em> - Version API Kubernetes mana yang kamu gunakan untuk membuat objek tersebut</li><li><em>kind</em> - Objek apakah yang ingin kamu buat</li><li><em>metadata</em> - Data yang dapat kamu gunakan untuk melakukan identifikasi objek termasuk <em>name</em> dalam betuk string, <em>UID</em>, dan <em>namespace</em> yang bersifat opsional</li></ul><p>Kamu juga harus menyediakan <em>field</em> <em>spec</em>. Format spesifik dari <em>spec</em> sebuah objek akan berbeda bergantung
pada objek apakah yang ingin kamu buat, serta mengandung <em>field</em> berantai yang spesifik bagi objek tersebut.
<a href=/docs/reference/generated/kubernetes-api/v1.25/>Referensi API Kubernetes</a> memberikan penjelasan
lebih lanjut mengenai format <em>spec</em> untuk semua objek Kubernetes yang dapat kamu buat. Misalnya saja format <em>spec</em>
untuk <em>Pod</em> dapat kamu temukan <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>di sini</a>,
dan format <em>spec</em> untuk <em>Deployment</em> dapat ditemukan
<a href=/docs/reference/generated/kubernetes-api/v1.25/#deploymentspec-v1-apps>di sini</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut mengenai dasar-dasar penting bagi objek Kubernetes, seperti <a href=/id/docs/concepts/workloads/pods/pod-overview/>Pod</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6751db8ff5409476de8225d17d6c42dd>4.2 - Pengaturan Objek Kubernetes</h1><p>Perangkat <code>kubectl</code> mendukung beberapa cara untuk membuat dan mengatur objek-objek Kubernetes.
Laman ini menggambarkan berbagai macam metodenya. Baca <a href=https://kubectl.docs.kubernetes.io>Kubectl gitbook</a>
untuk penjelasan pengaturan objek dengan Kubectl secara detail.</p><h2 id=metode-pengaturan>Metode pengaturan</h2><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Sebuah objek Kubernetes hanya boleh diatur dengan menggunakan satu metode saja. Mengkombinasikan
beberapa metode untuk objek yang sama dapat menghasilkan perilaku yang tidak diinginkan.</div><table><thead><tr><th>Metode pengaturan</th><th>Dijalankan pada</th><th><em>Environment</em> yang disarankan</th><th>Jumlah penulis yang didukung</th><th>Tingkat kesulitan mempelajari</th></tr></thead><tbody><tr><td>Perintah imperatif</td><td>Objek <em>live</em></td><td>Proyek pengembangan (<em>dev</em>)</td><td>1+</td><td>Terendah</td></tr><tr><td>Konfigurasi objek imperatif</td><td>Berkas individu</td><td>Proyek produksi (<em>prod</em>)</td><td>1</td><td>Sedang</td></tr><tr><td>Konfigurasi objek deklaratif</td><td>Direktori berkas</td><td>Proyek produksi (<em>prod</em>)</td><td>1+</td><td>Tertinggi</td></tr></tbody></table><h2 id=perintah-imperatif>Perintah imperatif</h2><p>Ketika menggunakan perintah-perintah imperatif, seorang pengguna menjalankan operasi secara langsung
pada objek-objek <em>live</em> dalam sebuah klaster. Pengguna menjalankan operasi tersebut melalui
argumen atau <em>flag</em> pada perintah <code>kubectl</code>.</p><p>Ini merupakan cara yang paling mudah untuk memulai atau menjalankan tugas "sekali jalan" pada sebuah klaster.
Karena metode ini dijalankan secara langsung pada objek <em>live</em>, tidak ada <em>history</em> yang menjelaskan konfigurasi-konfigurasi terkait sebelumnya.</p><h3 id=contoh>Contoh</h3><p>Menjalankan sebuah instans Container nginx dengan membuat suatu objek Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl run nginx --image nginx
</span></span></code></pre></div><p>Melakukan hal yang sama menggunakan sintaks yang berbeda:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id=kelebihan-dan-kekurangan>Kelebihan dan kekurangan</h3><p>Beberapa kelebihan metode ini dibandingkan metode konfigurasi objek:</p><ul><li>Sederhana, mudah dipelajari dan diingat.</li><li>Hanya memerlukan satu langkah untuk membuat perubahan pada klaster.</li></ul><p>Beberapa kekurangan metode ini dibandingkan metode konfigurasi objek:</p><ul><li>Tidak terintegrasi dengan proses peninjauan (<em>review</em>) perubahan.</li><li>Tidak menyediakan jejak audit yang terkait dengan perubahan.</li><li>Tidak menyediakan sumber <em>record</em> kecuali dari apa yang <em>live</em> terlihat.</li><li>Tidak menyediakan templat untuk membuat objek-objek baru.</li></ul><h2 id=konfigurasi-objek-imperatif>Konfigurasi objek imperatif</h2><p>Pada konfigurasi objek imperatif, perintah kubectl menetapkan jenis operasi
(<em>create</em>, <em>replace</em>, etc.), <em>flag-flag</em> pilihan dan minimal satu nama berkas.
Berkas ini harus berisi definisi lengkap dari objek tersebut
dalam bentuk YAML atau JSON.</p><p>Lihat <a href=/docs/reference/generated/kubernetes-api/v1.25/>referensi API</a>
untuk info lebih detail mengenai definisi objek.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Perintah imperatif <code>replace</code> menggantikan spek yang sudah ada dengan spek yang baru,
membuang semua perubahan terhadap objek tersebut yang tidak didefinisikan pada berkas konfigurasi.
Metode ini sebaiknya tidak dilakukan pada tipe sumber daya yang spek-nya diperbarui
secara independen di luar berkas konfigurasi. Service dengan tipe <code>LoadBalancer</code>, sebagai contoh,
memiliki <em>field</em> <code>externalIPs</code> yang diperbarui secara independen di luar konfigurasi, dilakukan
oleh klaster.</div><h3 id=contoh-1>Contoh</h3><p>Membuat objek yang didefinisikan pada sebuah berkas konfigurasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>Menghapus objek-objek yang didefinisikan pada dua berkas konfigurasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>Memperbarui objek yang didefinisikan pada sebuah berkas konfigurasi dengan
menimpa konfigurasi <em>live</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id=kelebihan-dan-kekurangan-1>Kelebihan dan kekurangan</h3><p>Beberapa kelebihan dibandingkan metode perintah imperatif:</p><ul><li>Konfigurasi objek dapat disimpan pada suatu sistem kontrol kode seperti Git.</li><li>Konfigurasi objek dapat diintegrasikan dengan proses-proses, misalnya peninjauan (<em>review</em>) perubahan sebelum <em>push</em> dan jejak audit.</li><li>Konfigurasi objek dapat menyediakan templat untuk membuat objek-objek baru.</li></ul><p>Beberapa kekurangan dibandingkan metode perintah imperatif:</p><ul><li>Konfigurasi objek memerlukan pemahaman yang mendasar soal skema objek.</li><li>Konfigurasi objek memerlukan langkah tambahan untuk menulis berkas YAML.</li></ul><p>Beberapa kelebihan dibandingkan metode konfigurasi objek deklaratif:</p><ul><li>Konfigurasi objek imperatif memiliki perilaku yang lebih sederhana dan mudah dimengerti.</li><li>Sejak Kubernetes versi 1.5, konfigurasi objek imperatif sudah lebih stabil.</li></ul><p>Beberapa kekurangan dibandingkan metode konfigurasi objek deklaratif:</p><ul><li>Konfigurasi objek imperatif bekerja dengan baik untuk berkas-berkas, namun tidak untuk direktori.</li><li>Pembaruan untuk objek-objek <em>live</em> harus diterapkan pada berkas-berkas konfigurasi, jika tidak, hasil perubahan akan hilang pada penggantian berikutnya.</li></ul><h2 id=konfigurasi-objek-deklaratif>Konfigurasi objek deklaratif</h2><p>Ketika menggunakan konfigurasi objek deklaratif, seorang pengguna beroperasi pada berkas-berkas
konfigurasi objek yang disimpan secara lokal, namun pengguna tidak mendefinisikan operasi
yang akan dilakukan pada berkas-berkas tersebut. Operasi <em>create</em>, <em>update</em>, dan <em>delete</em>
akan dideteksi secara otomatis per-objek dengan <code>kubectl</code>. Hal ini memungkinkan penerapan
melalui direktori, dimana operasi yang berbeda mungkin diperlukan untuk objek-objek yang berbeda.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Konfigurasi objek deklaratif mempertahankan perubahan yang dibuat oleh penulis lainnya, bahkan
jika perubahan tidak digabungkan (<em>merge</em>) kembali pada berkas konfigurasi objek. Hal ini
bisa terjadi dengan menggunakan operasi API <code>patch</code> supaya hanya perbedaannya saja yang ditulis,
daripada menggunakan operasi API <code>replace</code> untuk menggantikan seluruh konfigurasi objek.</div><h3 id=contoh-2>Contoh</h3><p>Melakukan pemrosesan pada semua berkas konfigurasi objek di direktori <code>configs</code>, dan melakukan
<em>create</em> atau <em>patch</em> untuk objek-objek <em>live</em>. Kamu dapat terlebih dahulu melakukan <code>diff</code> untuk
melihat perubahan-perubahan apa saja yang akan dilakukan, dan kemudian terapkan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -f configs/
</span></span><span style=display:flex><span>kubectl apply -f configs/
</span></span></code></pre></div><p>Melakukan pemrosesan direktori secara rekursif:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -R -f configs/
</span></span><span style=display:flex><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id=kelebihan-dan-kekurangan-2>Kelebihan dan kekurangan</h3><p>Beberapa kelebihan dibandingkan konfigurasi objek imperatif:</p><ul><li>Perubahan-perubahan yang dilakukan secara langsung pada objek-objek <em>live</em> akan dipertahankan, bahkan jika perubahan tersebut tidak digabungkan kembali pada berkas-berkas konfigurasi.</li><li>Konfigurasi objek deklaratif memiliki dukungan yang lebih baik dalam mengoperasikan direktori dan secara otomatis mendeteksi tipe operasi (<em>create</em>, <em>patch</em>, <em>delete</em>) per-objek.</li></ul><p>Beberapa kekurangan dibandingkan konfigurasi objek imperatif:</p><ul><li>Konfigurasi objek deklaratif lebih sulit untuk di-<em>debug</em> dan hasilnya lebih sulit dimengerti untuk perilaku yang tidak diinginkan.</li><li>Pembaruan sebagian menggunakan <em>diff</em> menghasilkan operasi <em>merge</em> dan <em>patch</em> yang rumit.</li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-command/>Mengatur Objek Kubernetes menggunakan Perintah Imperatif</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-config/>Mengatur Objek Kubernetes menggunakan Konfigurasi Objek (Imperatif)</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/declarative-config/>Mengatur Objek Kubernetes menggunakan Konfigurasi Objek (Deklaratif)</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Mengatur Objek Kubernetes menggunakan Kustomize (Deklaratif)</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Referensi Perintah Kubectl</a></li><li><a href=https://kubectl.docs.kubernetes.io>Kubectl Gitbook</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Referensi API Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>4.3 - Nama</h1><p>Seluruh objek di dalam REST API Kubernetes secara jelas ditandai dengan nama dan UID.</p><p>Apabila pengguna ingin memberikan atribut tidak unik, Kubernetes menyediakan <a href=/docs/user-guide/labels>label</a> dan <a href=/id/docs/concepts/overview/working-with-objects/annotations/>anotasi</a>.</p><p>Bacalah <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md>dokumentasi desain penanda</a> agar kamu dapat memahami lebih lanjut sintaks yang digunakan untuk Nama dan UID.</p><h2 id=nama>Nama</h2><p>String yang dihasilkan oleh klien yang mengacu pada sebuah objek dalam suatu URL <em>resource</em>, seperti <code>/api/v1/pods/some-name</code>.</p><p>Sebuah objek dengan kind yang sama tidak boleh memiliki nama yang sama pada suatu waktu tertentu. Meskipun begitu, apabila kamu menghapus sebuah objek, kamu membuat sebuah objek baru (yang memiliki kind yang sama) dengan nama yang sama dengan objek yang kamu hapus sebelumnya.</p><p>Berdasarkan ketentuan, nama dari <em>resources</em> Kubernetes memiliki panjang maksimum 253 karakter yang terdiri dari karakter alfanumerik huruf kecil, <code>-</code>, dan <code>.</code>, tetapi <em>resources</em> tertentu punya lebih banyak batasan yang spesifik</p><h2 id=uid>UID</h2><p>String yang dihasilkan oleh sistem Kubernetes untuk mengidentifikasi objek secara unik.</p><p>Setiap objek yang ada pada klaster Kubernetes memiliki UID yang unik. Hal ini dilakukan untuk membedakan keberadaan historis suatu entitas dengan kind dan nama yang serupa.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>4.4 - Namespace</h1><p>Kubernetes mendukung banyak klaster virtual di dalam satu klaster fisik. Klaster virtual tersebut disebut dengan <em>namespace</em>.</p><h2 id=kapan-menggunakan-banyak-namespace>Kapan menggunakan banyak Namespace</h2><p><em>Namespace</em> dibuat untuk digunakan di <em>environment</em> dengan banyak pengguna yang berada di dalam banyak tim ataupun proyek. Untuk sebuah klaster dengan beberapa pengguna saja, kamu tidak harus membuat ataupun memikirkan tentang <em>namespace</em>. Mulai gunakan <em>namespace</em> saat kamu membutuhkan fitur dari <em>namespace</em> itu sendiri.</p><p><em>Namespace</em> menyediakan ruang untuk nama objek. Nama dari <em>resource</em> atau objek harus berbeda di dalam sebuah <em>namespace</em>, tetapi boleh sama jika berbeda <em>namespace</em>. <em>Namespace</em> tidak bisa dibuat di dalam <em>namespace</em> lain dan setiap <em>resource</em> atau objek Kubernetes hanya dapat berada di dalam satu <em>namespace</em>.</p><p><em>Namespace</em> merupakan cara yang digunakan untuk memisahkan <em>resource</em> klaster untuk beberapa pengguna (dengan <a href=/id/docs/concepts/policy/resource-quotas/><em>resource quota</em></a>).</p><p>Dalam versi Kubernetes yang akan datang, objek di dalam satu <em>namespace</em> akan mempunyai <em>access control policies</em> yang sama secara <em>default</em>.</p><p>Tidak perlu menggunakan banyak <em>namespace</em> hanya untuk memisahkan sedikit perbedaan pada <em>resource</em>, seperti perbedaan versi dari perangkat lunak yang sama: gunakan <a href=/docs/user-guide/labels>label</a> untuk membedakan <em>resource</em> di dalam <em>namespace</em> yang sama.</p><h2 id=bekerja-dengan-namespace>Bekerja dengan Namespace</h2><p>Pembuatan dan penghapusan <em>namespace</em> dijelaskan di <a href=/docs/admin/namespaces>dokumentasi panduan admin untuk <em>namespace</em></a>.</p><h3 id=melihat-namespace>Melihat namespace</h3><p>Kamu dapat melihat daftar <em>namespace</em> di dalam klaster menggunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE
default       Active    1d
kube-system   Active    1d
kube-public   Active    1d
</code></pre><p>Kubernetes berjalan dengan tiga <em>namespace</em> awal:</p><ul><li><code>default</code>, <em>namespace default</em> untuk objek yang dibuat tanpa mencantumkan <em>namespace</em> pada spesifikasinya.</li><li><code>kube-system</code>, <em>namespace</em> yang digunakan untuk objek yang dibuat oleh sistem Kubernetes.</li><li><code>kube-public</code>, <em>namespace</em> ini dibuat secara otomatis dan dapat diakses oleh semua pengguna (termasuk yang tidak diautentikasi). <em>Namespace</em> ini disediakan untuk penggunaan klaster, jika beberapa <em>resouce</em> harus terlihat dan dapat dibaca secara publik di seluruh klaster. Aspek publik dari <em>namespace</em> ini hanya sebuah konvensi, bukan persyaratan.</li></ul><h3 id=mengkonfigurasi-namespace-untuk-request>Mengkonfigurasi namespace untuk request</h3><p>Untuk mengkonfigurasi sementara <em>request</em> untuk menggunakan <em>namespace</em> tertentu, gunakan <code>--namespace</code> <em>flag</em>.</p><p>Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt; run nginx --image<span style=color:#666>=</span>nginx
</span></span><span style=display:flex><span>kubectl --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt; get pods
</span></span></code></pre></div><h3 id=mengkonfigurasi-preferensi-namespace>Mengkonfigurasi preferensi namespace</h3><p>Kamu dapat menyimpan konfigurasi <em>namespace</em> untuk semua perintah <code>kubectl</code> dengan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Cek namespace</span>
</span></span><span style=display:flex><span>kubectl config view | grep namespace:
</span></span></code></pre></div><h2 id=namespace-dan-dns>Namespace dan DNS</h2><p>Saat kamu membuat sebuah <a href=/docs/user-guide/services>Service</a>, Kubernetes membuat <a href=/id/docs/concepts/services-networking/dns-pod-service/>Entri DNS</a> untuk <em>service</em> tersebut. Entri <em>DNS</em> ini berformat <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code>, yang berarti jika sebuah kontainer hanya menggunakan <code>&lt;service-name></code>, kontainer tersebut akan berkomunikasi dengan <em>service</em> yang berada di dalam satu <em>namespace</em>. Ini berguna untuk menggunakan konfigurasi yang sama di beberapa <em>namespace</em> seperti <em>Development</em>, <em>Staging</em>, dan <em>Production</em>. Jika kamu ingin berkomunikasi antar <em>namespace</em>, kamu harus menggunakan seluruh <em>fully qualified domain name (FQDN)</em>.</p><h2 id=tidak-semua-objek-di-dalam-namespace>Tidak semua objek di dalam Namespace</h2><p>Kebanyakan <em>resource</em> di Kubernetes (contohnya <em>pod</em>, <em>service</em>, <em>replication controller</em>, dan yang lain) ada di dalam <em>namespace</em>. Namun <em>resource namespace</em> sendiri tidak berada di dalam <em>namespace</em>. Dan <em>low-level resource</em> seperti <a href=/docs/admin/node>node</a> dan <em>persistentVolume</em> tidak berada di <em>namespace</em> manapun.</p><p>Untuk melihat <em>resource</em> di dalam kubernetes yang berada di dalam <em>namespace</em> ataupun tidak:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Di dalam namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Tidak di dalam namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>4.5 - Label dan Selektor</h1><p><em>Label</em> merupakan pasangan <em>key/value</em> yang melekat pada objek-objek, misalnya pada Pod.
Label digunakan untuk menentukan atribut identitas dari objek agar memiliki arti dan relevan bagi para pengguna, namun tidak secara langsung memiliki makna terhadap sistem inti.
Label dapat digunakan untuk mengatur dan memilih sebagian dari banyak objek. Label-label dapat ditempelkan ke objek-objek pada saat dibuatnya objek-objek tersebut dan kemudian ditambahkan atau diubah kapan saja setelahnya.
Setiap objek dapat memiliki satu set label <em>key/value</em>. Setiap <em>Key</em> harus unik untuk objek tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Label memungkinkan untuk menjalankan kueri dan pengamatan dengan efisien, serta ideal untuk digunakan pada UI dan CLI. Informasi yang tidak digunakan untuk identifikasi sebaiknya menggunakan <a href=/id/docs/concepts/overview/working-with-objects/annotations/>anotasi</a>.</p><h2 id=motivasi>Motivasi</h2><p>Label memungkinkan pengguna untuk memetakan struktur organisasi mereka ke dalam objek-objek sistem yang tidak terikat secara erat, tanpa harus mewajibkan klien untuk menyimpan pemetaan tersebut.</p><p><em>Service deployments</em> dan <em>batch processing pipelines</em> sering menjadi entitas yang berdimensi ganda (contohnya partisi berganda atau <em>deployment</em>, jalur rilis berganda, tingkatan berganda, <em>micro-services</em> berganda per tingkatan). Manajemen seringkali membutuhkan operasi lintas tim, yang menyebabkan putusnya enkapsulasi dari representasi hierarki yang ketat, khususnya pada hierarki-hierarki kaku yang justru ditentukan oleh infrastruktur, bukan oleh pengguna.</p><p>Contoh label:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>Ini hanya contoh label yang biasa digunakan; kamu bebas mengembangkan caramu sendiri. Perlu diingat bahwa <em>Key</em> dari label harus unik untuk objek tersebut.</p><h2 id=sintaksis-dan-set-karakter>Sintaksis dan set karakter</h2><p><em>Label</em> merupakan pasangan <em>key/value</em>. <em>Key-key</em> dari Label yang valid memiliki dua segmen: sebuah prefiks dan nama yang opsional, yang dipisahkan oleh garis miring (<code>/</code>). Segmen nama wajib diisi dan tidak boleh lebih dari 63, dimulai dan diakhiri dengan karakter alfanumerik (<code>[a-z0-9A-Z]</code>) dengan tanda pisah (<code>-</code>), garis bawah (<code>_</code>), titik (<code>.</code>), dan alfanumerik di antaranya. Sedangkan prefiks bersifat opsional. Jika ditentukan, prefiks harus berupa subdomain DNS: rangkaian label DNS yang dipisahkan oleh titik (<code>.</code>), dengan total tidak lebih dari 253 karakter, yang diikuti oleh garis miring (<code>/</code>).</p><p>Jika prefiks dihilangkan, <em>Key</em> dari label diasumsikan privat bagi pengguna. Komponen sistem otomatis (contoh <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, atau otomasi pihak ketiga lainnya) yang akan menambah label ke objek-objek milik pengguna akhir harus menentukan prefiks.</p><p>Prefiks <code>kubernetes.io/</code> dan <code>k8s.io/</code> dikhususkan untuk komponen inti Kubernetes.</p><p>Nilai label yang valid tidak boleh lebih dari 63 karakter dan harus kosong atau diawali dan diakhiri dengan karakter alfanumerik (<code>[a-z0-9A-Z]</code>) dengan tanda pisah (<code>-</code>), garis bawah (<code>_</code>), titik (<code>.</code>), dan alfanumerik di antaranya.</p><p>Contoh di bawah ini merupakan berkas konfigurasi untuk Pod yang memiliki dua label <code>environment: production</code> dan <code>app: nginx</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selektor-label>Selektor label</h2><p>Tidak seperti <a href=/id/docs/concepts/overview/working-with-objects/names/>nama dan UID</a>, label tidak memberikan keunikan. Secara umum, kami memperkirakan bahwa banyak objek yang akan memiliki label yang sama.</p><p>Menggunakan sebuah <em>label selector</em>, klien/pengguna dapat mengidentifikasi suatu kumpulan objek. Selektor label merupakan alat/cara pengelompokan utama pada Kubernetes.</p><p>Saat ini API mendukung dua jenis selektor: <em>equality-based</em> dan <em>set-based</em>.
Sebuah selektor label dapat dibuat dari kondisi berganda yang dipisahkan oleh koma. Pada kasus kondisi berganda, semua kondisi harus dipenuhi sehingga separator koma dapat bertindak sebagai operator logika <em>AND</em> (<code>&&</code>).</p><p>Makna dari selektor yang kosong atau tidak diisi tergantung dari konteks, dan tipe API yang menggunakan selektor harus mendokumentasikan keabsahan dan arti dari selektor yang kosong tersebut.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk beberapa tipe API, seperti ReplicaSet, selektor label untuk dua objek tidak boleh tumpang tindih dengan Namespace, jika tidak maka <em>controller</em> akan melihatnya sebagai instruksi yang menyebabkan konflik dan akan gagal menentukan berapa banyak replika yang seharusnya tersedia.</div><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Untuk kedua kondisi <em>equality-based</em> dan <em>set-based</em> tidak ada logika operator <em>OR</em> (<code>||</code>). Pastikan struktur pernyataan filter kamu ikut disesuaikan.</div><h3 id=kondisi-equality-based>Kondisi <em>Equality-based</em></h3><p>Kondisi <em>Equality-based</em> atau <em>inequality-based</em> memungkinkan untuk melakukan filter dengan menggunakan <em>key</em> dan <em>value</em> dari label. Objek yang cocok harus memenuhi semua batasan label yang telah ditentukan, meskipun mereka dapat memiliki label tambahan lainnya.
Terdapat tiga jenis operator yang didukung yaitu <code>=</code>,<code>==</code>,<code>!=</code>. Dua operator pertama menyatakan kesamaan (keduanya hanyalah sinonim), sementara operator terakhir menyatakan ketidaksamaan. Contoh:</p><pre tabindex=0><code>environment = production
tier != frontend
</code></pre><p>Kondisi pertama akan memilih semua sumber daya dengan <em>key</em> <code>environment</code> dan nilai <em>key</em> <code>production</code>.
Kondisi berikutnya akan memilih semua sumber daya dengan <em>key</em> <code>tier</code> dan nilai <em>key</em> selain <code>frontend</code>, dan semua sumber daya yang tidak memiliki label dengan <em>key</em> <code>tier</code>.
Kamu juga dapat memfilter sumber daya dalam <code>production</code> selain <code>frontend</code> dengan menggunakan operator koma: <code>environment=production,tier!=frontend</code></p><p>Salah satu skenario penggunaan label dengan kondisi <em>equality-based</em> yaitu untuk kriteria pemilihan Node untuk Pod-Pod. Sebagai contoh, Pod percontohan di bawah ini akan memilih Node dengan label "<code>accelerator=nvidia-tesla-p100</code>".</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=kondisi-set-based>Kondisi <em>Set-based</em></h3><p>Kondisi label <em>Set-based</em> memungkinkan memfilter <em>key</em> terhadap suatu kumpulan nilai. Terdapat tiga jenis operator yang didukung, yaitu: <code>in</code>,<code>notin</code>, dan <code>exists</code> (hanya <em>key</em>-nya saja). Contoh:</p><pre tabindex=0><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><p>Contoh pertama akan memilih semua sumber daya dengan <em>key</em> <code>environment</code> dan nilai <code>production</code> atau <code>qa</code>.
Contoh kedua akan memilih semua sumber daya dengan <em>key</em> <code>tier</code> dan nilai selain <code>frontend</code> dan <code>backend</code>, serta semua sumber daya yang tidak memiliki label dengan <em>key</em> <code>tier</code>.
Contoh ketiga akan memilih semua sumber daya yang memiliki <em>key</em> dari label<code>partition</code>; nilainya tidak diperiksa.
Sedangkan contoh keempat akan memilih semua sumber daya yang tidak memiliki label dengan <em>key</em> <code>partition</code>; nilainya tidak diperiksa.
Secara serupa, operator koma bertindak sebagai operator <em>AND</em>. Sehingga penyaringan sumber daya dengan <em>key</em> <code>partition</code> (tidak peduli nilai dari <em>key</em>) dan <code>environment</code> yang tidak sama dengan <code>qa</code> dapat dicapai dengan <code>partition,environment notin (qa)</code>.
Selektor label <em>set-based</em> merupakan bentuk umum persamaan karena <code>environment=production</code> sama dengan <code>environment in (production)</code>; demikian pula <code>!=</code> dan <code>notin</code>.</p><p>Kondisi <em>Set-based</em> dapat digabungkan dengan kondisi <em>equality-based</em>. Contoh: <code>partition in (customerA, customerB),environment!=qa</code>.</p><h2 id=api>API</h2><h3 id=penyaringan-list-dan-watch>Penyaringan LIST dan WATCH</h3><p>Operasi LIST dan WATCH dapat menentukan selektor label untuk memfilter suatu kumpulan objek yang didapat dengan menggunakan parameter kueri. Kedua jenis kondisi diperbolehkan (ditampilkan sebagai berikut, sama seperti saat tampil pada string kueri di URL):</p><ul><li>Kondisi <em>equality-based</em>: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li>Kondisi <em>set-based</em>: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>Kedua jenis selektor label dapat digunakan untuk menampilkan (<em>list</em>) dan mengamati (<em>watch</em>) sumber daya melalui klien REST. Contohnya, menargetkan <code>apiserver</code> dengan <code>kubectl</code> dan menggunakan <em>equality-based</em> kamu dapat menuliskan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>atau menggunakan kondisi <em>set-based</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</span></span></code></pre></div><p>Seperti yang telah disebutkan sebelumnya, kondisi <em>set-based</em> lebih ekspresif. Sebagai contoh, mereka dapat digunakan untuk mengimplementasi operator <em>OR</em> pada nilai:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</span></span></code></pre></div><p>atau membatasi pencocokan negatif dengan operator <em>exists</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</span></span></code></pre></div><h3 id=mengatur-referensi-pada-objek-api>Mengatur referensi pada objek API</h3><p>Pada beberapa objek Kubernetes, seperti <a href=/docs/user-guide/services><code>Service</code></a> dan <a href=/id/docs/concepts/workloads/controllers/replicationcontroller/><code>ReplicationController</code></a>, juga menggunakan selektor label untuk menentukan kumpulan dari sumber daya lain, seperti <a href=/id/docs/concepts/workloads/pods/pod>Pod</a>.</p><h4 id=service-dan-replicationcontroller>Service dan ReplicationController</h4><p>Kumpulan Pod yang ditargetkan oleh sebuah <code>service</code> ditentukan dengan selektor label. Demikian pula kumpulan Pod yang harus ditangani oleh <code>replicationcontroller</code> juga ditentukan dengan selektor label.</p><p>Selektor label untuk kedua objek tersebut ditentukan dalam berkas <code>json</code> atau <code>yaml</code> menggunakan <em>maps</em>, dan hanya mendukung kondisi <em>equality-based</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>atau</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div><p>selektor ini (baik dalam bentuk <code>json</code> atau <code>yaml</code>) sama dengan <code>component=redis</code> atau <code>component in (redis)</code>.</p><h4 id=sumber-daya-yang-mendukung-kondisi-set-based>Sumber daya yang mendukung kondisi set-based</h4><p>Sumber daya yang lebih baru, seperti <a href=/id/docs/concepts/workloads/controllers/jobs-run-to-completion/><code>Job</code></a>, <a href=/id/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>, <a href=/id/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>, dan <a href=/id/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>, juga mendukung kondisi <em>set-based</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>matchLabels</code> merupakan pemetaan dari pasangan <code>{key,value}</code>. Sebuah <code>{key,value}</code> pada pemetaan <code>matchLabels</code> adalah sama dengan elemen dari <code>matchExpressions</code>, yang nilai <code>key</code> nya adalah "key", dengan <code>operator</code> "In", dan <em>array</em> <code>values</code> hanya berisi "value". <code>matchExpressions</code> merupakan daftar kondisi untuk selektor Pod. Operator yang valid termasuk In, NotIn, Exists, dan DoesNotExist. Kumpulan nilai ini tidak boleh kosong pada kasus In dan NotIn. Semua kondisi, baik dari <code>matchLabels</code> dan <code>matchExpressions</code> di-AND secara sekaligus -- mereka harus memenuhi semua kondisi agar cocok.</p><h4 id=memilih-kumpulan-node>Memilih kumpulan Node</h4><p>Salah satu contoh penggunaan pemilihan dengan menggunakan label yaitu untuk membatasi suatu kumpulan Node tertentu yang dapat digunakan oleh Pod.
Lihat dokumentasi pada <a href=/id/docs/concepts/scheduling-eviction/assign-pod-node/>pemilihan Node</a> untuk informasi lebih lanjut.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>4.6 - Anotasi</h1><p>Kamu dapat menggunakan fitur anotasi dari Kubernetes untuk menempelkan sembarang
metadata tanpa identitas pada suatu objek. Klien, seperti perangkat dan <em>library</em>,
dapat memperoleh metadata tersebut.</p><h2 id=mengaitkan-metadata-pada-objek>Mengaitkan metadata pada objek</h2><p>Kamu dapat menggunakan label maupun anotasi untuk menempelkan metadata pada suatu
objek Kubernetes. Label dapat digunakan untuk memilih objek dan mencari sekumpulan
objek yang memenuhi kondisi tertentu. Sebaliknya, anotasi tidak digunakan untuk
mengenali atau memilih objek. Metadata dalam sebuah anotasi bisa berukuran kecil atau besar,
terstruktur atau tidak terstruktur, dan dapat berisikan karakter-karakter yang tidak
diperbolehkan oleh label.</p><p>Anotasi, seperti label, merupakan pemetaan <em>key/value</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Berikut merupakan beberapa contoh informasi yang dapat dicatat dengan menggunakan anotasi:</p><ul><li><p><em>Field-field</em> yang dikelola secara deklaratif oleh <em>layer</em> konfigurasi. Menempelkan
<em>field-field</em> tersebut sebagai anotasi membedakan mereka dari nilai <em>default</em> yang
ditetapkan oleh klien ataupun server, dari <em>field-field</em> yang otomatis di-<em>generate</em>, serta
dari <em>field-field</em> yang ditetapkan oleh sistem <em>auto-sizing</em> atau <em>auto-scaling</em>.</p></li><li><p>Informasi mengenai <em>build</em>, rilis, atau <em>image</em>, seperti <em>timestamp</em>, rilis ID, git <em>branch</em>,
nomor PR, <em>hash</em> suatu <em>image</em>, dan alamat registri.</p></li><li><p>Penanda untuk <em>logging</em>, <em>monitoring</em>, <em>analytics</em>, ataupun repositori audit.</p></li><li><p>Informasi mengenai <em>library</em> klien atau perangkat yang dapat digunakan untuk <em>debugging</em>:
misalnya, informasi nama, versi, dan <em>build</em>.</p></li><li><p>Informasi yang berhubungan dengan pengguna atau perangkat/sistem, seperti URL objek yang terkait
dengan komponen dari ekosistem lain.</p></li><li><p>Metadata untuk perangkat <em>rollout</em> yang ringan (<em>lightweight</em>): contohnya, untuk
konfigurasi atau penanda (<em>checkpoint</em>).</p></li><li><p>Nomor telepon atau <em>pager</em> dari orang yang bertanggung jawab, atau entri direktori
yang berisi informasi lebih lanjut, seperti <em>website</em> sebuah tim.</p></li><li><p>Arahan dari pengguna (<em>end-user</em>) untuk melakukan implementasi, perubahan perilaku,
ataupun untuk interaksi dengan fitur-fitur non-standar.</p></li></ul><p>Tanpa menggunakan anotasi, kamu dapat saja menyimpan informasi-informasi dengan tipe
di atas pada suatu basis data atau direktori eksternal, namun hal ini sangat mempersulit
pembuatan <em>library</em> klien dan perangkat yang bisa digunakan sama-sama (<em>shared</em>) untuk melakukan
<em>deploy</em>, pengelolaan, introspeksi, dan semacamnya.</p><h2 id=sintaksis-dan-sekumpulan-karakter>Sintaksis dan sekumpulan karakter</h2><p>Anotasi merupakan <em>key/value pair</em>. <em>Key</em> dari sebuah anotasi yang valid memiliki dua segmen: segmen prefiks yang opsional dan segmen nama, dipisahkan
oleh sebuah garis miring (<code>/</code>). Segmen nama bersifat wajib dan harus terdiri dari 63 karakter atau kurang, dimulai dan diakhiri dengan karakter alfanumerik (<code>[a-z0-9A-Z]</code>) dengan tanda minus (<code>-</code>), garis bawah (<code>_</code>), titik (<code>.</code>), dan alfanumerik di tengahnya. Jika terdapat prefiks,
prefiks haruslah berupa subdomain DNS: urutan dari label DNS yang dipisahkan oleh titik (<code>.</code>), totalnya tidak melebihi 253 karakter,
diikuti dengan garis miring (<code>/</code>).</p><p>Jika tidak terdapat prefiks, maka <em>key</em> dari anotasi diasumsikan hanya bisa dilihat oleh pengguna (privat). Komponen sistem otomasi
(seperti <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, ataupun otomasi pihak ketiga) yang menambahkan anotasi
pada objek-objek pengguna harus memiliki sebuah prefiks.</p><p>Prefiks <code>kubernetes.io/</code> dan <code>k8s.io/</code> merupakan reservasi dari komponen inti Kubernetes.</p><h2 id=selanjutnya>Selanjutnya</h2><p>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/overview/working-with-objects/labels/>Label dan Selektor</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>4.7 - Selektor Field</h1><p>Selektor <em>field</em> memungkinkan kamu untuk <a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects>memilih (<em>select</em>) <em>resource</em> Kubernetes</a> berdasarkan
nilai dari satu atau banyak <em>field resource</em>. Di bawah ini merupakan contoh dari beberapa <em>query</em> selektor <em>field</em>:</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>Perintah <code>kubectl</code> di bawah ini memilih semua Pod dengan <em>field</em> <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a> yang bernilai
<code>Running</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Pada dasarnya, selektor <em>field</em> merupakan filter dari <em>resource</em>. Secara <em>default</em>, tidak ada selektor/filter apapun yang diterapkan. Artinya,
semua <em>resource</em> dengan tipe apapun akan terpilih. Akibatnya, <em>query</em> dengan perintah <code>kubectl</code> di bawah ini akan memberikan hasil yang sama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>kubectl get pods --field-selector <span style=color:#b44>&#34;&#34;</span>
</span></span></code></pre></div></div><h2 id=field-yang-didukung><em>Field</em> yang didukung</h2><p>Selektor-selektor <em>field</em> yang didukung oleh Kubernetes bervariasi tergantung dari tipe <em>resource</em>. Semua tipe <em>resource</em> mendukung <em>field</em>
<code>metadata.name</code> dan <code>metadata.namespace</code>. Jika kamu menggunakan selektor <em>field</em> yang tidak didukung, maka akan terjadi error. Contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=operator-yang-didukung>Operator yang didukung</h2><p>Kamu dapat menggunakan operator <code>=</code>, <code>==</code>, dan <code>!=</code> pada selektor <em>field</em> (<code>=</code> dan <code>==</code> punya arti yang sama). Sebagai contoh, perintah <code>kubectl</code> ini
memilih semua Kubernetes Service yang tidak terdapat pada <em>namespace</em> <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=selektor-berantai>Selektor berantai</h2><p>Seperti halnya <a href=/id/docs/concepts/overview/working-with-objects/labels>label</a> dan selektor-selektor lainnya, kamu dapat membuat selektor <em>field</em> berantai
(<em>chained</em>) dengan <em>list</em> yang dipisahkan oleh koma. Perintah <code>kubectl</code> di bawah ini memilih semua Pod dengan <code>status.phase</code> tidak sama dengan
<code>Running</code> dan <em>field</em> <code>spec.restartPolicy</code> sama dengan <code>Always</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=resource-dengan-beberapa-tipe><em>Resource</em> dengan beberapa tipe</h2><p>Kamu dapat menggunakan selektor-selektor <em>field</em> dengan beberapa tipe <em>resource</em> sekaligus. Perintah <code>kubectl</code> di bawah ini memilih semua Statefulset
dan Service yang tidak terdapat pada <em>namespace</em> <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>4.8 - Label yang Disarankan</h1><p>Kamu dapat melakukan visualisasi dan mengatur objek Kubernetes dengan lebih banyak <em>tools</em>
dibandingkan dengan perintah kubectl dan dasbor. Sekumpulan label mengizinkan <em>tools</em>
untuk bekerja dengan interoperabilitas, mendeskripsikan objek dengan cara yang umum yang dapat
dipahami semua <em>tools</em>.</p><p>Sebagai tambahan bagi <em>tooling</em> tambahan, label yang disarankan ini mendeskripsikan
aplikasi sehingga informasi yang ada diapat di-<em>query</em>.</p><p>Metadata ini diorganisasi berbasis konsep dari sebuah aplikasi. Kubernetes bukan merupakan
sebuah platform sebagai sebuah <em>service</em> (<em>platform as a service</em>/PaaS) dan tidak
mewajibkan sebuah gagasan formal dari sebuah aplikasi.
Sebagai gantinya, aplikasi merupakan suatu hal informal yang dideskripsikan melalui metadata.
Definisi yang dimiliki oleh sebuah aplikasi merupakan sebuah hal yang cukup longgar.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Berikut merupakan label yang disarankan. Label ini mempermudah
proses manajemen aplikasi tetapi tidak dibutuhkan untuk <em>tooling</em> utama apa pun.</div><p>Label yang digunakan secara umum serta anotasi memiliki prefiks yang serupa: <code>app.kubernetes.io</code>. Label
tanpa sebuah prefiks bersifat privat khusus pengguna saja. Prefiks yang digunakan secara umum tadi
menjamin bahwa label tadi tidak akan mengganggu label <em>custom</em> yang diberikan oleh pengguna.</p><h2 id=label>Label</h2><p>Untuk mendapatkan keuntungan menyeluruh dari penggunaan label ini,
label harus digunakan pada seluruh objek sumber daya.</p><table><thead><tr><th><em>Key</em></th><th>Deskripsi</th><th>Contoh</th><th>Tipe</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>Nama aplikasi</td><td><code>mysql</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>Nama unik yang bersifat sebagai pengidentifikasi dari sebuah instans aplikasi</td><td><code>wordpress-abcxzy</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>Versi saat ini dari aplikasi (misalnya sebuah versi semantik, hash revisi, etc.)</td><td><code>5.7.21</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>Komponen yang ada pada arsitektur</td><td><code>database</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>Nama dari komponen lebih tinggi dari aplikasi yang mencakup bagian ini</td><td><code>wordpress</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>Alat yang digunakan untuk mengatur operasi pada aplikasi</td><td><code>helm</code></td><td>string</td></tr></tbody></table><p>Untuk memberikan ilustrasi dari penggunaan label, bayangkan sebuah objek StatefulSet yang didefinisikan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=aplikasi-dan-instans-aplikasi>Aplikasi dan Instans Aplikasi</h2><p>Sebuah aplikasi dapat diinstal sekali atau beberapa kali di dalam klaster Kubernetes dan,
pada beberapa kasus, di dalam sebuah <em>namespace</em> yang sama. Misalnya, wordpress dapat
diinstal lebih dari satu kali dimana situs web yang berbeda merupakan hasil instalasi yang berbeda.</p><p>Nama dari sebuah aplikasi dan nama instans akan dicatat secara terpisah. Sebagai contoh,
WordPress memiliki <code>wordpress</code> sebagai nilai dari <code>app.kubernetes.io/name</code> dimana
nama instans yang digunakan adalah <code>wordpress-abcxzy</code> yang merupakan nilai dari <code>app.kubernetes.io/instance</code>.
Hal ini memungkinkan aplikasi dan instans aplikasi untuk dapat diidentifikasi. Setiap instans dari aplikasi
haruslah memiliki nama yang unik.</p><h2 id=contoh>Contoh</h2><p>Untuk memberikan ilustrasi dengan cara yang berbeda pada penggunaan label, contoh di bawah ini
memiliki tingkat kompleksitas yang cukup beragam.</p><h3 id=sebuah-aplikasi-stateless-sederhana>Sebuah Aplikasi <em>Stateless</em> Sederhana</h3><p>Bayangkan sebuah kasus dimana sebuah aplikasi <em>stateless</em> di-<em>deploy</em>
menggunakan Deployment dan Service. Di bawah ini merupakan
contoh kutipan yang merepresentasikan bagaimana
label dapat digunakan secara sederhana.</p><p>Deployment digunakan untuk memastikan Pod dijalankan untuk aplikasi itu sendiri.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Service digunakan untuk mengekspos aplikasi.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=sebuah-aplikasi-web-dengan-basis-data>Sebuah Aplikasi Web dengan Basis Data</h3><p>Bayangkan sebuah aplikasi yang lebih kompleks: sebuah aplikasi web (WordPress)
yang menggunakan basis data (MySQL), yang diinstal menggunakan Helm.
Kutipan berikut merepresentasikan objek yang di-<em>deploy</em> untuk aplikasi ini.</p><p>Berikut merupakan konfigurasi Deployment yang digunakan untuk WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Service yang digunakan untuk mengekspos WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL diekspos sebagai StatefulSet dengan metadata yang digunakan untuk StatefulSet tersebut serta aplikasi yang menggunakannya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Service yang digunakan untuk mengekspos MySQL sebagai bagian dari WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Dengan StatefulSet MySQL dan Service kamu dapat mengetahui informasi yang ada pada MySQL dan Wordpress.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>