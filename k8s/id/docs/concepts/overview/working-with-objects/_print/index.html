<!doctype html><html lang=id class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/overview/working-with-objects/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/overview/working-with-objects/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/concepts/overview/working-with-objects/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Menggunakan Objek-Objek Kubernetes | Kubernetes</title><meta property="og:title" content="Menggunakan Objek-Objek Kubernetes"><meta property="og:description" content="Objek-objek Kubernetes adalah entitas yang tetap dalam sistem Kubernetes.  Kubernetes menggunakan entitas tersebut untuk merepresentasikan keadaan dari klastermu. Pelajari tentang objek model Kubernetes dan bagaimana menggunakan objek tersebut.
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/overview/working-with-objects/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Menggunakan Objek-Objek Kubernetes"><meta itemprop=description content="Objek-objek Kubernetes adalah entitas yang tetap dalam sistem Kubernetes.  Kubernetes menggunakan entitas tersebut untuk merepresentasikan keadaan dari klastermu. Pelajari tentang objek model Kubernetes dan bagaimana menggunakan objek tersebut.
"><meta name=twitter:card content="summary"><meta name=twitter:title content="Menggunakan Objek-Objek Kubernetes"><meta name=twitter:description content="Objek-objek Kubernetes adalah entitas yang tetap dalam sistem Kubernetes.  Kubernetes menggunakan entitas tersebut untuk merepresentasikan keadaan dari klastermu. Pelajari tentang objek model Kubernetes dan bagaimana menggunakan objek tersebut.
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Objek-objek Kubernetes adalah entitas yang tetap dalam sistem Kubernetes.  Kubernetes menggunakan entitas tersebut untuk merepresentasikan keadaan dari klastermu. Pelajari tentang objek model Kubernetes dan bagaimana menggunakan objek tersebut.
"><meta property="og:description" content="Objek-objek Kubernetes adalah entitas yang tetap dalam sistem Kubernetes.  Kubernetes menggunakan entitas tersebut untuk merepresentasikan keadaan dari klastermu. Pelajari tentang objek model Kubernetes dan bagaimana menggunakan objek tersebut.
"><meta name=twitter:description content="Objek-objek Kubernetes adalah entitas yang tetap dalam sistem Kubernetes.  Kubernetes menggunakan entitas tersebut untuk merepresentasikan keadaan dari klastermu. Pelajari tentang objek model Kubernetes dan bagaimana menggunakan objek tersebut.
"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/overview/working-with-objects/"><meta property="og:title" content="Menggunakan Objek-Objek Kubernetes"><meta name=twitter:title content="Menggunakan Objek-Objek Kubernetes"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/id/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/id/docs/concepts/overview/working-with-objects/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/id/docs/concepts/overview/working-with-objects/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/concepts/overview/working-with-objects/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/concepts/overview/working-with-objects/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/concepts/overview/working-with-objects/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/overview/working-with-objects/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/overview/working-with-objects/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/overview/working-with-objects/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/overview/working-with-objects/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/overview/working-with-objects/>Français (French)</a>
<a class=dropdown-item href=/es/docs/concepts/overview/working-with-objects/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/overview/working-with-objects/>Português (Portuguese)</a>
<a class=dropdown-item href=/ru/docs/concepts/overview/working-with-objects/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/concepts/overview/working-with-objects/>Return to the regular view of this page</a>.</p></div><h1 class=title>Menggunakan Objek-Objek Kubernetes</h1><div class=lead>Objek-objek Kubernetes adalah entitas yang tetap dalam sistem Kubernetes. Kubernetes menggunakan entitas tersebut untuk merepresentasikan keadaan dari klastermu. Pelajari tentang objek model Kubernetes dan bagaimana menggunakan objek tersebut.</div><ul><li>1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Memahami Konsep Objek-Objek yang ada pada Kubernetes</a></li><li>2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>Pengaturan Objek Kubernetes</a></li><li>3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>Nama</a></li><li>4: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Namespace</a></li><li>5: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>Label dan Selektor</a></li><li>6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>Anotasi</a></li><li>7: <a href=#pg-046c03090d47bc4b89b818dc645c3865>Selektor Field</a></li><li>8: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>Label yang Disarankan</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>1 - Memahami Konsep Objek-Objek yang ada pada Kubernetes</h1><p>Laman ini menjelaskan bagaimana objek-objek Kubernetes direpresentasikan di dalam API Kubernetes,
dan bagaimana kamu dapat merepresentasikannya di dalam format <code>.yaml</code>.</p><h2 id=memahami-konsep-objek-objek-yang-ada-pada-kubernetes>Memahami Konsep Objek-Objek yang Ada pada Kubernetes</h2><p>Objek-objek Kubernetes adalah entitas persisten di dalam sistem Kubernetes.
Kubernetes menggunakan entitas ini untuk merepresentasikan <em>state</em> yang ada pada
klaster kamu. Secara spesifik, hal itu dapat dideskripsikan sebagai:</p><ul><li>Aplikasi-aplikasi kontainer apa sajakah yang sedang dijalankan (serta pada <em>node</em> apa aplikasi tersebut dijalankan)</li><li><em>Resource</em> yang tersedia untuk aplikasi tersebut</li><li><em>Policy</em> yang mengatur bagaimana aplikasi tersebut dijalankan, misalnya <em>restart</em>, <em>upgrade</em>, dan <em>fault-tolerance</em>.</li></ul><p>Objek Kubernetes merupakan sebuah <em>"record of intent"</em>--yang mana sekali kamu membuat suatu objek,
sistem Kubernetes akan bekerja secara konsisten untuk menjamin
bahwa objek tersebut akan selalu ada. Dengan membuat sebuah objek, secara tak langsung kamu
memberikan informasi pada sistem Kubernetes mengenai perilaku apakah yang kamu inginkan pada <em>workload</em> klaster yang kamu miliki;
dengan kata lain ini merupakan definisi <em>state</em> klaster yang kamu inginkan.</p><p>Untuk menggunakan objek-objek Kubernetes--baik membuat, mengubah, atau menghapus objek-objek tersebut--kamu
harus menggunakan <a href=/id/docs/concepts/overview/kubernetes-api/>API Kubernetes</a>.
Ketika kamu menggunakan perintah <code>kubectl</code>, perintah ini akan melakukan <em>API call</em> untuk perintah
yang kamu berikan. Kamu juga dapat menggunakan API Kubernetes secara langsung pada program yang kamu miliki
menggunakan salah satu <a href=/docs/reference/using-api/client-libraries/><em>library</em> klien</a> yang disediakan.</p><h3 id=spec-dan-status-objek><em>Spec</em> dan Status Objek</h3><p>Setiap objek Kubernetes memiliki <em>field</em> berantai yang mengatur konfigurasi sebuah objek:
<em>spec</em> dan status. <em>Spec</em>, merupakan <em>field</em> yang harus kamu sediakan, <em>field</em> ini mendeskripsikan
<em>state</em> yang kamu inginkan untuk objek tersebut--karakteristik dari objek yang kamu miliki.
Status mendeskripsikan <em>state</em> yang sebenarnya dari sebuah objek, dan hal ini disediakan dan selalu diubah oleh
sistem Kubernetes. Setiap saat, <em>Control Plane</em> Kubernetes selalu memantau apakah <em>state</em> aktual sudah sesuai dengan
<em>state</em> yang diinginkan.</p><p>Sebagai contoh, <em>Deployment</em> merupakan sebuah objek yang merepresentasikan sebuah aplikasi yang dijalankan di klaster kamu.
Ketika kamu membuat sebuah <em>Deployment</em>, kamu bisa saja memberikan <em>spec</em> bagi <em>Deployment</em> untuk memberikan spesifikasi
berapa banyak <em>replica</em> yang kamu inginkan. Sistem Kubernetes kemudian akan membaca konfigurasi yang kamu berikan
dan mengaktifkan tiga buah instans untuk aplikasi yang kamu inginkan--mengubah status yang ada saat ini agar sesuai dengan apa yang kamu inginkan.
Jika terjadi kegagalan dalam instans yang dibuat, sistem Kubernetes akan memberikan respons bahwa terdapat perbedaan antara <em>spec</em> dan status serta
melakukan penyesuaian dengan cara memberikan instans pengganti.</p><p>Informasi lebih lanjut mengenai <em>spec</em> objek, status, dan <em>metadata</em> dapat kamu baca di <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Konvensi API Kubernetes</a>.</p><h3 id=mendeskripsikan-objek-kubernetes>Mendeskripsikan Objek Kubernetes</h3><p>Ketika kamu membuat sebuah objek di Kubernetes, kamu harus menyediakan <em>spec</em> objek yang
mendeskripsikan <em>state</em> yang diinginkan, serta beberapa informasi tentang objek tersebut (seperti nama).
Ketika kamu menggunakan API Kubernetes untuk membuat objek tersebut (baik secara langsung atau menggunakan perintah
<code>kubectl</code>), <em>request</em> API yang dibuat harus mencakup informasi seperti <em>request body</em> dalam format JSON.
Apabila kamu memberikan <strong>informasi dalam bentuk <code>.yaml</code> ketika menggunakan perintah <code>kubectl</code></strong> maka <code>kubectl</code>
akan mengubah informasi yang kamu berikan ke dalam format JSON ketika melakukan <em>request</em> API.</p><p>Berikut merupakan contoh <em>file</em> <code>.yaml</code> yang menunjukkan <em>field</em> dan <em>spec</em> objek untuk <em>Deployment</em>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Salah satu cara untuk membuat <em>Deployment</em> menggunakan <em>file</em> <code>.yaml</code>
seperti yang dijabarkan di atas adalah dengan menggunakan perintah
<a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>
pada <em>command-line interface</em> <code>kubectl</code> kamu menerapkan <em>file</em> <code>.yaml</code> sebagai sebuah argumen.
Berikut merupakan contoh penggunaannya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
</span></span></code></pre></div><p>Keluaran yang digunakan kurang lebih akan ditampilkan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/nginx-deployment created
</span></span></code></pre></div><h3 id=field-field-yang-dibutuhkan><em>Field-Field</em> yang dibutuhkan</h3><p>Pada <em>file</em> <code>.yaml</code> untuk objek Kubernetes yang ingin kamu buat, kamu perlu
menyediakan <em>value</em> untuk <em>field-field</em> berikut:</p><ul><li><em>apiVersion</em> - Version API Kubernetes mana yang kamu gunakan untuk membuat objek tersebut</li><li><em>kind</em> - Objek apakah yang ingin kamu buat</li><li><em>metadata</em> - Data yang dapat kamu gunakan untuk melakukan identifikasi objek termasuk <em>name</em> dalam betuk string, <em>UID</em>, dan <em>namespace</em> yang bersifat opsional</li></ul><p>Kamu juga harus menyediakan <em>field</em> <em>spec</em>. Format spesifik dari <em>spec</em> sebuah objek akan berbeda bergantung
pada objek apakah yang ingin kamu buat, serta mengandung <em>field</em> berantai yang spesifik bagi objek tersebut.
<a href=/docs/reference/generated/kubernetes-api/v1.25/>Referensi API Kubernetes</a> memberikan penjelasan
lebih lanjut mengenai format <em>spec</em> untuk semua objek Kubernetes yang dapat kamu buat. Misalnya saja format <em>spec</em>
untuk <em>Pod</em> dapat kamu temukan <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>di sini</a>,
dan format <em>spec</em> untuk <em>Deployment</em> dapat ditemukan
<a href=/docs/reference/generated/kubernetes-api/v1.25/#deploymentspec-v1-apps>di sini</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut mengenai dasar-dasar penting bagi objek Kubernetes, seperti <a href=/id/docs/concepts/workloads/pods/pod-overview/>Pod</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6751db8ff5409476de8225d17d6c42dd>2 - Pengaturan Objek Kubernetes</h1><p>Perangkat <code>kubectl</code> mendukung beberapa cara untuk membuat dan mengatur objek-objek Kubernetes.
Laman ini menggambarkan berbagai macam metodenya. Baca <a href=https://kubectl.docs.kubernetes.io>Kubectl gitbook</a>
untuk penjelasan pengaturan objek dengan Kubectl secara detail.</p><h2 id=metode-pengaturan>Metode pengaturan</h2><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Sebuah objek Kubernetes hanya boleh diatur dengan menggunakan satu metode saja. Mengkombinasikan
beberapa metode untuk objek yang sama dapat menghasilkan perilaku yang tidak diinginkan.</div><table><thead><tr><th>Metode pengaturan</th><th>Dijalankan pada</th><th><em>Environment</em> yang disarankan</th><th>Jumlah penulis yang didukung</th><th>Tingkat kesulitan mempelajari</th></tr></thead><tbody><tr><td>Perintah imperatif</td><td>Objek <em>live</em></td><td>Proyek pengembangan (<em>dev</em>)</td><td>1+</td><td>Terendah</td></tr><tr><td>Konfigurasi objek imperatif</td><td>Berkas individu</td><td>Proyek produksi (<em>prod</em>)</td><td>1</td><td>Sedang</td></tr><tr><td>Konfigurasi objek deklaratif</td><td>Direktori berkas</td><td>Proyek produksi (<em>prod</em>)</td><td>1+</td><td>Tertinggi</td></tr></tbody></table><h2 id=perintah-imperatif>Perintah imperatif</h2><p>Ketika menggunakan perintah-perintah imperatif, seorang pengguna menjalankan operasi secara langsung
pada objek-objek <em>live</em> dalam sebuah klaster. Pengguna menjalankan operasi tersebut melalui
argumen atau <em>flag</em> pada perintah <code>kubectl</code>.</p><p>Ini merupakan cara yang paling mudah untuk memulai atau menjalankan tugas "sekali jalan" pada sebuah klaster.
Karena metode ini dijalankan secara langsung pada objek <em>live</em>, tidak ada <em>history</em> yang menjelaskan konfigurasi-konfigurasi terkait sebelumnya.</p><h3 id=contoh>Contoh</h3><p>Menjalankan sebuah instans Container nginx dengan membuat suatu objek Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl run nginx --image nginx
</span></span></code></pre></div><p>Melakukan hal yang sama menggunakan sintaks yang berbeda:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id=kelebihan-dan-kekurangan>Kelebihan dan kekurangan</h3><p>Beberapa kelebihan metode ini dibandingkan metode konfigurasi objek:</p><ul><li>Sederhana, mudah dipelajari dan diingat.</li><li>Hanya memerlukan satu langkah untuk membuat perubahan pada klaster.</li></ul><p>Beberapa kekurangan metode ini dibandingkan metode konfigurasi objek:</p><ul><li>Tidak terintegrasi dengan proses peninjauan (<em>review</em>) perubahan.</li><li>Tidak menyediakan jejak audit yang terkait dengan perubahan.</li><li>Tidak menyediakan sumber <em>record</em> kecuali dari apa yang <em>live</em> terlihat.</li><li>Tidak menyediakan templat untuk membuat objek-objek baru.</li></ul><h2 id=konfigurasi-objek-imperatif>Konfigurasi objek imperatif</h2><p>Pada konfigurasi objek imperatif, perintah kubectl menetapkan jenis operasi
(<em>create</em>, <em>replace</em>, etc.), <em>flag-flag</em> pilihan dan minimal satu nama berkas.
Berkas ini harus berisi definisi lengkap dari objek tersebut
dalam bentuk YAML atau JSON.</p><p>Lihat <a href=/docs/reference/generated/kubernetes-api/v1.25/>referensi API</a>
untuk info lebih detail mengenai definisi objek.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Perintah imperatif <code>replace</code> menggantikan spek yang sudah ada dengan spek yang baru,
membuang semua perubahan terhadap objek tersebut yang tidak didefinisikan pada berkas konfigurasi.
Metode ini sebaiknya tidak dilakukan pada tipe sumber daya yang spek-nya diperbarui
secara independen di luar berkas konfigurasi. Service dengan tipe <code>LoadBalancer</code>, sebagai contoh,
memiliki <em>field</em> <code>externalIPs</code> yang diperbarui secara independen di luar konfigurasi, dilakukan
oleh klaster.</div><h3 id=contoh-1>Contoh</h3><p>Membuat objek yang didefinisikan pada sebuah berkas konfigurasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>Menghapus objek-objek yang didefinisikan pada dua berkas konfigurasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>Memperbarui objek yang didefinisikan pada sebuah berkas konfigurasi dengan
menimpa konfigurasi <em>live</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id=kelebihan-dan-kekurangan-1>Kelebihan dan kekurangan</h3><p>Beberapa kelebihan dibandingkan metode perintah imperatif:</p><ul><li>Konfigurasi objek dapat disimpan pada suatu sistem kontrol kode seperti Git.</li><li>Konfigurasi objek dapat diintegrasikan dengan proses-proses, misalnya peninjauan (<em>review</em>) perubahan sebelum <em>push</em> dan jejak audit.</li><li>Konfigurasi objek dapat menyediakan templat untuk membuat objek-objek baru.</li></ul><p>Beberapa kekurangan dibandingkan metode perintah imperatif:</p><ul><li>Konfigurasi objek memerlukan pemahaman yang mendasar soal skema objek.</li><li>Konfigurasi objek memerlukan langkah tambahan untuk menulis berkas YAML.</li></ul><p>Beberapa kelebihan dibandingkan metode konfigurasi objek deklaratif:</p><ul><li>Konfigurasi objek imperatif memiliki perilaku yang lebih sederhana dan mudah dimengerti.</li><li>Sejak Kubernetes versi 1.5, konfigurasi objek imperatif sudah lebih stabil.</li></ul><p>Beberapa kekurangan dibandingkan metode konfigurasi objek deklaratif:</p><ul><li>Konfigurasi objek imperatif bekerja dengan baik untuk berkas-berkas, namun tidak untuk direktori.</li><li>Pembaruan untuk objek-objek <em>live</em> harus diterapkan pada berkas-berkas konfigurasi, jika tidak, hasil perubahan akan hilang pada penggantian berikutnya.</li></ul><h2 id=konfigurasi-objek-deklaratif>Konfigurasi objek deklaratif</h2><p>Ketika menggunakan konfigurasi objek deklaratif, seorang pengguna beroperasi pada berkas-berkas
konfigurasi objek yang disimpan secara lokal, namun pengguna tidak mendefinisikan operasi
yang akan dilakukan pada berkas-berkas tersebut. Operasi <em>create</em>, <em>update</em>, dan <em>delete</em>
akan dideteksi secara otomatis per-objek dengan <code>kubectl</code>. Hal ini memungkinkan penerapan
melalui direktori, dimana operasi yang berbeda mungkin diperlukan untuk objek-objek yang berbeda.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Konfigurasi objek deklaratif mempertahankan perubahan yang dibuat oleh penulis lainnya, bahkan
jika perubahan tidak digabungkan (<em>merge</em>) kembali pada berkas konfigurasi objek. Hal ini
bisa terjadi dengan menggunakan operasi API <code>patch</code> supaya hanya perbedaannya saja yang ditulis,
daripada menggunakan operasi API <code>replace</code> untuk menggantikan seluruh konfigurasi objek.</div><h3 id=contoh-2>Contoh</h3><p>Melakukan pemrosesan pada semua berkas konfigurasi objek di direktori <code>configs</code>, dan melakukan
<em>create</em> atau <em>patch</em> untuk objek-objek <em>live</em>. Kamu dapat terlebih dahulu melakukan <code>diff</code> untuk
melihat perubahan-perubahan apa saja yang akan dilakukan, dan kemudian terapkan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -f configs/
</span></span><span style=display:flex><span>kubectl apply -f configs/
</span></span></code></pre></div><p>Melakukan pemrosesan direktori secara rekursif:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -R -f configs/
</span></span><span style=display:flex><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id=kelebihan-dan-kekurangan-2>Kelebihan dan kekurangan</h3><p>Beberapa kelebihan dibandingkan konfigurasi objek imperatif:</p><ul><li>Perubahan-perubahan yang dilakukan secara langsung pada objek-objek <em>live</em> akan dipertahankan, bahkan jika perubahan tersebut tidak digabungkan kembali pada berkas-berkas konfigurasi.</li><li>Konfigurasi objek deklaratif memiliki dukungan yang lebih baik dalam mengoperasikan direktori dan secara otomatis mendeteksi tipe operasi (<em>create</em>, <em>patch</em>, <em>delete</em>) per-objek.</li></ul><p>Beberapa kekurangan dibandingkan konfigurasi objek imperatif:</p><ul><li>Konfigurasi objek deklaratif lebih sulit untuk di-<em>debug</em> dan hasilnya lebih sulit dimengerti untuk perilaku yang tidak diinginkan.</li><li>Pembaruan sebagian menggunakan <em>diff</em> menghasilkan operasi <em>merge</em> dan <em>patch</em> yang rumit.</li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-command/>Mengatur Objek Kubernetes menggunakan Perintah Imperatif</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-config/>Mengatur Objek Kubernetes menggunakan Konfigurasi Objek (Imperatif)</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/declarative-config/>Mengatur Objek Kubernetes menggunakan Konfigurasi Objek (Deklaratif)</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Mengatur Objek Kubernetes menggunakan Kustomize (Deklaratif)</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Referensi Perintah Kubectl</a></li><li><a href=https://kubectl.docs.kubernetes.io>Kubectl Gitbook</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Referensi API Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>3 - Nama</h1><p>Seluruh objek di dalam REST API Kubernetes secara jelas ditandai dengan nama dan UID.</p><p>Apabila pengguna ingin memberikan atribut tidak unik, Kubernetes menyediakan <a href=/docs/user-guide/labels>label</a> dan <a href=/id/docs/concepts/overview/working-with-objects/annotations/>anotasi</a>.</p><p>Bacalah <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md>dokumentasi desain penanda</a> agar kamu dapat memahami lebih lanjut sintaks yang digunakan untuk Nama dan UID.</p><h2 id=nama>Nama</h2><p>String yang dihasilkan oleh klien yang mengacu pada sebuah objek dalam suatu URL <em>resource</em>, seperti <code>/api/v1/pods/some-name</code>.</p><p>Sebuah objek dengan kind yang sama tidak boleh memiliki nama yang sama pada suatu waktu tertentu. Meskipun begitu, apabila kamu menghapus sebuah objek, kamu membuat sebuah objek baru (yang memiliki kind yang sama) dengan nama yang sama dengan objek yang kamu hapus sebelumnya.</p><p>Berdasarkan ketentuan, nama dari <em>resources</em> Kubernetes memiliki panjang maksimum 253 karakter yang terdiri dari karakter alfanumerik huruf kecil, <code>-</code>, dan <code>.</code>, tetapi <em>resources</em> tertentu punya lebih banyak batasan yang spesifik</p><h2 id=uid>UID</h2><p>String yang dihasilkan oleh sistem Kubernetes untuk mengidentifikasi objek secara unik.</p><p>Setiap objek yang ada pada klaster Kubernetes memiliki UID yang unik. Hal ini dilakukan untuk membedakan keberadaan historis suatu entitas dengan kind dan nama yang serupa.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>4 - Namespace</h1><p>Kubernetes mendukung banyak klaster virtual di dalam satu klaster fisik. Klaster virtual tersebut disebut dengan <em>namespace</em>.</p><h2 id=kapan-menggunakan-banyak-namespace>Kapan menggunakan banyak Namespace</h2><p><em>Namespace</em> dibuat untuk digunakan di <em>environment</em> dengan banyak pengguna yang berada di dalam banyak tim ataupun proyek. Untuk sebuah klaster dengan beberapa pengguna saja, kamu tidak harus membuat ataupun memikirkan tentang <em>namespace</em>. Mulai gunakan <em>namespace</em> saat kamu membutuhkan fitur dari <em>namespace</em> itu sendiri.</p><p><em>Namespace</em> menyediakan ruang untuk nama objek. Nama dari <em>resource</em> atau objek harus berbeda di dalam sebuah <em>namespace</em>, tetapi boleh sama jika berbeda <em>namespace</em>. <em>Namespace</em> tidak bisa dibuat di dalam <em>namespace</em> lain dan setiap <em>resource</em> atau objek Kubernetes hanya dapat berada di dalam satu <em>namespace</em>.</p><p><em>Namespace</em> merupakan cara yang digunakan untuk memisahkan <em>resource</em> klaster untuk beberapa pengguna (dengan <a href=/id/docs/concepts/policy/resource-quotas/><em>resource quota</em></a>).</p><p>Dalam versi Kubernetes yang akan datang, objek di dalam satu <em>namespace</em> akan mempunyai <em>access control policies</em> yang sama secara <em>default</em>.</p><p>Tidak perlu menggunakan banyak <em>namespace</em> hanya untuk memisahkan sedikit perbedaan pada <em>resource</em>, seperti perbedaan versi dari perangkat lunak yang sama: gunakan <a href=/docs/user-guide/labels>label</a> untuk membedakan <em>resource</em> di dalam <em>namespace</em> yang sama.</p><h2 id=bekerja-dengan-namespace>Bekerja dengan Namespace</h2><p>Pembuatan dan penghapusan <em>namespace</em> dijelaskan di <a href=/docs/admin/namespaces>dokumentasi panduan admin untuk <em>namespace</em></a>.</p><h3 id=melihat-namespace>Melihat namespace</h3><p>Kamu dapat melihat daftar <em>namespace</em> di dalam klaster menggunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE
default       Active    1d
kube-system   Active    1d
kube-public   Active    1d
</code></pre><p>Kubernetes berjalan dengan tiga <em>namespace</em> awal:</p><ul><li><code>default</code>, <em>namespace default</em> untuk objek yang dibuat tanpa mencantumkan <em>namespace</em> pada spesifikasinya.</li><li><code>kube-system</code>, <em>namespace</em> yang digunakan untuk objek yang dibuat oleh sistem Kubernetes.</li><li><code>kube-public</code>, <em>namespace</em> ini dibuat secara otomatis dan dapat diakses oleh semua pengguna (termasuk yang tidak diautentikasi). <em>Namespace</em> ini disediakan untuk penggunaan klaster, jika beberapa <em>resouce</em> harus terlihat dan dapat dibaca secara publik di seluruh klaster. Aspek publik dari <em>namespace</em> ini hanya sebuah konvensi, bukan persyaratan.</li></ul><h3 id=mengkonfigurasi-namespace-untuk-request>Mengkonfigurasi namespace untuk request</h3><p>Untuk mengkonfigurasi sementara <em>request</em> untuk menggunakan <em>namespace</em> tertentu, gunakan <code>--namespace</code> <em>flag</em>.</p><p>Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt; run nginx --image<span style=color:#666>=</span>nginx
</span></span><span style=display:flex><span>kubectl --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt; get pods
</span></span></code></pre></div><h3 id=mengkonfigurasi-preferensi-namespace>Mengkonfigurasi preferensi namespace</h3><p>Kamu dapat menyimpan konfigurasi <em>namespace</em> untuk semua perintah <code>kubectl</code> dengan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Cek namespace</span>
</span></span><span style=display:flex><span>kubectl config view | grep namespace:
</span></span></code></pre></div><h2 id=namespace-dan-dns>Namespace dan DNS</h2><p>Saat kamu membuat sebuah <a href=/docs/user-guide/services>Service</a>, Kubernetes membuat <a href=/id/docs/concepts/services-networking/dns-pod-service/>Entri DNS</a> untuk <em>service</em> tersebut. Entri <em>DNS</em> ini berformat <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code>, yang berarti jika sebuah kontainer hanya menggunakan <code>&lt;service-name></code>, kontainer tersebut akan berkomunikasi dengan <em>service</em> yang berada di dalam satu <em>namespace</em>. Ini berguna untuk menggunakan konfigurasi yang sama di beberapa <em>namespace</em> seperti <em>Development</em>, <em>Staging</em>, dan <em>Production</em>. Jika kamu ingin berkomunikasi antar <em>namespace</em>, kamu harus menggunakan seluruh <em>fully qualified domain name (FQDN)</em>.</p><h2 id=tidak-semua-objek-di-dalam-namespace>Tidak semua objek di dalam Namespace</h2><p>Kebanyakan <em>resource</em> di Kubernetes (contohnya <em>pod</em>, <em>service</em>, <em>replication controller</em>, dan yang lain) ada di dalam <em>namespace</em>. Namun <em>resource namespace</em> sendiri tidak berada di dalam <em>namespace</em>. Dan <em>low-level resource</em> seperti <a href=/docs/admin/node>node</a> dan <em>persistentVolume</em> tidak berada di <em>namespace</em> manapun.</p><p>Untuk melihat <em>resource</em> di dalam kubernetes yang berada di dalam <em>namespace</em> ataupun tidak:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Di dalam namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Tidak di dalam namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>5 - Label dan Selektor</h1><p><em>Label</em> merupakan pasangan <em>key/value</em> yang melekat pada objek-objek, misalnya pada Pod.
Label digunakan untuk menentukan atribut identitas dari objek agar memiliki arti dan relevan bagi para pengguna, namun tidak secara langsung memiliki makna terhadap sistem inti.
Label dapat digunakan untuk mengatur dan memilih sebagian dari banyak objek. Label-label dapat ditempelkan ke objek-objek pada saat dibuatnya objek-objek tersebut dan kemudian ditambahkan atau diubah kapan saja setelahnya.
Setiap objek dapat memiliki satu set label <em>key/value</em>. Setiap <em>Key</em> harus unik untuk objek tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Label memungkinkan untuk menjalankan kueri dan pengamatan dengan efisien, serta ideal untuk digunakan pada UI dan CLI. Informasi yang tidak digunakan untuk identifikasi sebaiknya menggunakan <a href=/id/docs/concepts/overview/working-with-objects/annotations/>anotasi</a>.</p><h2 id=motivasi>Motivasi</h2><p>Label memungkinkan pengguna untuk memetakan struktur organisasi mereka ke dalam objek-objek sistem yang tidak terikat secara erat, tanpa harus mewajibkan klien untuk menyimpan pemetaan tersebut.</p><p><em>Service deployments</em> dan <em>batch processing pipelines</em> sering menjadi entitas yang berdimensi ganda (contohnya partisi berganda atau <em>deployment</em>, jalur rilis berganda, tingkatan berganda, <em>micro-services</em> berganda per tingkatan). Manajemen seringkali membutuhkan operasi lintas tim, yang menyebabkan putusnya enkapsulasi dari representasi hierarki yang ketat, khususnya pada hierarki-hierarki kaku yang justru ditentukan oleh infrastruktur, bukan oleh pengguna.</p><p>Contoh label:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>Ini hanya contoh label yang biasa digunakan; kamu bebas mengembangkan caramu sendiri. Perlu diingat bahwa <em>Key</em> dari label harus unik untuk objek tersebut.</p><h2 id=sintaksis-dan-set-karakter>Sintaksis dan set karakter</h2><p><em>Label</em> merupakan pasangan <em>key/value</em>. <em>Key-key</em> dari Label yang valid memiliki dua segmen: sebuah prefiks dan nama yang opsional, yang dipisahkan oleh garis miring (<code>/</code>). Segmen nama wajib diisi dan tidak boleh lebih dari 63, dimulai dan diakhiri dengan karakter alfanumerik (<code>[a-z0-9A-Z]</code>) dengan tanda pisah (<code>-</code>), garis bawah (<code>_</code>), titik (<code>.</code>), dan alfanumerik di antaranya. Sedangkan prefiks bersifat opsional. Jika ditentukan, prefiks harus berupa subdomain DNS: rangkaian label DNS yang dipisahkan oleh titik (<code>.</code>), dengan total tidak lebih dari 253 karakter, yang diikuti oleh garis miring (<code>/</code>).</p><p>Jika prefiks dihilangkan, <em>Key</em> dari label diasumsikan privat bagi pengguna. Komponen sistem otomatis (contoh <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, atau otomasi pihak ketiga lainnya) yang akan menambah label ke objek-objek milik pengguna akhir harus menentukan prefiks.</p><p>Prefiks <code>kubernetes.io/</code> dan <code>k8s.io/</code> dikhususkan untuk komponen inti Kubernetes.</p><p>Nilai label yang valid tidak boleh lebih dari 63 karakter dan harus kosong atau diawali dan diakhiri dengan karakter alfanumerik (<code>[a-z0-9A-Z]</code>) dengan tanda pisah (<code>-</code>), garis bawah (<code>_</code>), titik (<code>.</code>), dan alfanumerik di antaranya.</p><p>Contoh di bawah ini merupakan berkas konfigurasi untuk Pod yang memiliki dua label <code>environment: production</code> dan <code>app: nginx</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selektor-label>Selektor label</h2><p>Tidak seperti <a href=/id/docs/concepts/overview/working-with-objects/names/>nama dan UID</a>, label tidak memberikan keunikan. Secara umum, kami memperkirakan bahwa banyak objek yang akan memiliki label yang sama.</p><p>Menggunakan sebuah <em>label selector</em>, klien/pengguna dapat mengidentifikasi suatu kumpulan objek. Selektor label merupakan alat/cara pengelompokan utama pada Kubernetes.</p><p>Saat ini API mendukung dua jenis selektor: <em>equality-based</em> dan <em>set-based</em>.
Sebuah selektor label dapat dibuat dari kondisi berganda yang dipisahkan oleh koma. Pada kasus kondisi berganda, semua kondisi harus dipenuhi sehingga separator koma dapat bertindak sebagai operator logika <em>AND</em> (<code>&&</code>).</p><p>Makna dari selektor yang kosong atau tidak diisi tergantung dari konteks, dan tipe API yang menggunakan selektor harus mendokumentasikan keabsahan dan arti dari selektor yang kosong tersebut.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk beberapa tipe API, seperti ReplicaSet, selektor label untuk dua objek tidak boleh tumpang tindih dengan Namespace, jika tidak maka <em>controller</em> akan melihatnya sebagai instruksi yang menyebabkan konflik dan akan gagal menentukan berapa banyak replika yang seharusnya tersedia.</div><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Untuk kedua kondisi <em>equality-based</em> dan <em>set-based</em> tidak ada logika operator <em>OR</em> (<code>||</code>). Pastikan struktur pernyataan filter kamu ikut disesuaikan.</div><h3 id=kondisi-equality-based>Kondisi <em>Equality-based</em></h3><p>Kondisi <em>Equality-based</em> atau <em>inequality-based</em> memungkinkan untuk melakukan filter dengan menggunakan <em>key</em> dan <em>value</em> dari label. Objek yang cocok harus memenuhi semua batasan label yang telah ditentukan, meskipun mereka dapat memiliki label tambahan lainnya.
Terdapat tiga jenis operator yang didukung yaitu <code>=</code>,<code>==</code>,<code>!=</code>. Dua operator pertama menyatakan kesamaan (keduanya hanyalah sinonim), sementara operator terakhir menyatakan ketidaksamaan. Contoh:</p><pre tabindex=0><code>environment = production
tier != frontend
</code></pre><p>Kondisi pertama akan memilih semua sumber daya dengan <em>key</em> <code>environment</code> dan nilai <em>key</em> <code>production</code>.
Kondisi berikutnya akan memilih semua sumber daya dengan <em>key</em> <code>tier</code> dan nilai <em>key</em> selain <code>frontend</code>, dan semua sumber daya yang tidak memiliki label dengan <em>key</em> <code>tier</code>.
Kamu juga dapat memfilter sumber daya dalam <code>production</code> selain <code>frontend</code> dengan menggunakan operator koma: <code>environment=production,tier!=frontend</code></p><p>Salah satu skenario penggunaan label dengan kondisi <em>equality-based</em> yaitu untuk kriteria pemilihan Node untuk Pod-Pod. Sebagai contoh, Pod percontohan di bawah ini akan memilih Node dengan label "<code>accelerator=nvidia-tesla-p100</code>".</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=kondisi-set-based>Kondisi <em>Set-based</em></h3><p>Kondisi label <em>Set-based</em> memungkinkan memfilter <em>key</em> terhadap suatu kumpulan nilai. Terdapat tiga jenis operator yang didukung, yaitu: <code>in</code>,<code>notin</code>, dan <code>exists</code> (hanya <em>key</em>-nya saja). Contoh:</p><pre tabindex=0><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><p>Contoh pertama akan memilih semua sumber daya dengan <em>key</em> <code>environment</code> dan nilai <code>production</code> atau <code>qa</code>.
Contoh kedua akan memilih semua sumber daya dengan <em>key</em> <code>tier</code> dan nilai selain <code>frontend</code> dan <code>backend</code>, serta semua sumber daya yang tidak memiliki label dengan <em>key</em> <code>tier</code>.
Contoh ketiga akan memilih semua sumber daya yang memiliki <em>key</em> dari label<code>partition</code>; nilainya tidak diperiksa.
Sedangkan contoh keempat akan memilih semua sumber daya yang tidak memiliki label dengan <em>key</em> <code>partition</code>; nilainya tidak diperiksa.
Secara serupa, operator koma bertindak sebagai operator <em>AND</em>. Sehingga penyaringan sumber daya dengan <em>key</em> <code>partition</code> (tidak peduli nilai dari <em>key</em>) dan <code>environment</code> yang tidak sama dengan <code>qa</code> dapat dicapai dengan <code>partition,environment notin (qa)</code>.
Selektor label <em>set-based</em> merupakan bentuk umum persamaan karena <code>environment=production</code> sama dengan <code>environment in (production)</code>; demikian pula <code>!=</code> dan <code>notin</code>.</p><p>Kondisi <em>Set-based</em> dapat digabungkan dengan kondisi <em>equality-based</em>. Contoh: <code>partition in (customerA, customerB),environment!=qa</code>.</p><h2 id=api>API</h2><h3 id=penyaringan-list-dan-watch>Penyaringan LIST dan WATCH</h3><p>Operasi LIST dan WATCH dapat menentukan selektor label untuk memfilter suatu kumpulan objek yang didapat dengan menggunakan parameter kueri. Kedua jenis kondisi diperbolehkan (ditampilkan sebagai berikut, sama seperti saat tampil pada string kueri di URL):</p><ul><li>Kondisi <em>equality-based</em>: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li>Kondisi <em>set-based</em>: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>Kedua jenis selektor label dapat digunakan untuk menampilkan (<em>list</em>) dan mengamati (<em>watch</em>) sumber daya melalui klien REST. Contohnya, menargetkan <code>apiserver</code> dengan <code>kubectl</code> dan menggunakan <em>equality-based</em> kamu dapat menuliskan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>atau menggunakan kondisi <em>set-based</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</span></span></code></pre></div><p>Seperti yang telah disebutkan sebelumnya, kondisi <em>set-based</em> lebih ekspresif. Sebagai contoh, mereka dapat digunakan untuk mengimplementasi operator <em>OR</em> pada nilai:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</span></span></code></pre></div><p>atau membatasi pencocokan negatif dengan operator <em>exists</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</span></span></code></pre></div><h3 id=mengatur-referensi-pada-objek-api>Mengatur referensi pada objek API</h3><p>Pada beberapa objek Kubernetes, seperti <a href=/docs/user-guide/services><code>Service</code></a> dan <a href=/id/docs/concepts/workloads/controllers/replicationcontroller/><code>ReplicationController</code></a>, juga menggunakan selektor label untuk menentukan kumpulan dari sumber daya lain, seperti <a href=/id/docs/concepts/workloads/pods/pod>Pod</a>.</p><h4 id=service-dan-replicationcontroller>Service dan ReplicationController</h4><p>Kumpulan Pod yang ditargetkan oleh sebuah <code>service</code> ditentukan dengan selektor label. Demikian pula kumpulan Pod yang harus ditangani oleh <code>replicationcontroller</code> juga ditentukan dengan selektor label.</p><p>Selektor label untuk kedua objek tersebut ditentukan dalam berkas <code>json</code> atau <code>yaml</code> menggunakan <em>maps</em>, dan hanya mendukung kondisi <em>equality-based</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>atau</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div><p>selektor ini (baik dalam bentuk <code>json</code> atau <code>yaml</code>) sama dengan <code>component=redis</code> atau <code>component in (redis)</code>.</p><h4 id=sumber-daya-yang-mendukung-kondisi-set-based>Sumber daya yang mendukung kondisi set-based</h4><p>Sumber daya yang lebih baru, seperti <a href=/id/docs/concepts/workloads/controllers/jobs-run-to-completion/><code>Job</code></a>, <a href=/id/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>, <a href=/id/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>, dan <a href=/id/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>, juga mendukung kondisi <em>set-based</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>matchLabels</code> merupakan pemetaan dari pasangan <code>{key,value}</code>. Sebuah <code>{key,value}</code> pada pemetaan <code>matchLabels</code> adalah sama dengan elemen dari <code>matchExpressions</code>, yang nilai <code>key</code> nya adalah "key", dengan <code>operator</code> "In", dan <em>array</em> <code>values</code> hanya berisi "value". <code>matchExpressions</code> merupakan daftar kondisi untuk selektor Pod. Operator yang valid termasuk In, NotIn, Exists, dan DoesNotExist. Kumpulan nilai ini tidak boleh kosong pada kasus In dan NotIn. Semua kondisi, baik dari <code>matchLabels</code> dan <code>matchExpressions</code> di-AND secara sekaligus -- mereka harus memenuhi semua kondisi agar cocok.</p><h4 id=memilih-kumpulan-node>Memilih kumpulan Node</h4><p>Salah satu contoh penggunaan pemilihan dengan menggunakan label yaitu untuk membatasi suatu kumpulan Node tertentu yang dapat digunakan oleh Pod.
Lihat dokumentasi pada <a href=/id/docs/concepts/scheduling-eviction/assign-pod-node/>pemilihan Node</a> untuk informasi lebih lanjut.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>6 - Anotasi</h1><p>Kamu dapat menggunakan fitur anotasi dari Kubernetes untuk menempelkan sembarang
metadata tanpa identitas pada suatu objek. Klien, seperti perangkat dan <em>library</em>,
dapat memperoleh metadata tersebut.</p><h2 id=mengaitkan-metadata-pada-objek>Mengaitkan metadata pada objek</h2><p>Kamu dapat menggunakan label maupun anotasi untuk menempelkan metadata pada suatu
objek Kubernetes. Label dapat digunakan untuk memilih objek dan mencari sekumpulan
objek yang memenuhi kondisi tertentu. Sebaliknya, anotasi tidak digunakan untuk
mengenali atau memilih objek. Metadata dalam sebuah anotasi bisa berukuran kecil atau besar,
terstruktur atau tidak terstruktur, dan dapat berisikan karakter-karakter yang tidak
diperbolehkan oleh label.</p><p>Anotasi, seperti label, merupakan pemetaan <em>key/value</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Berikut merupakan beberapa contoh informasi yang dapat dicatat dengan menggunakan anotasi:</p><ul><li><p><em>Field-field</em> yang dikelola secara deklaratif oleh <em>layer</em> konfigurasi. Menempelkan
<em>field-field</em> tersebut sebagai anotasi membedakan mereka dari nilai <em>default</em> yang
ditetapkan oleh klien ataupun server, dari <em>field-field</em> yang otomatis di-<em>generate</em>, serta
dari <em>field-field</em> yang ditetapkan oleh sistem <em>auto-sizing</em> atau <em>auto-scaling</em>.</p></li><li><p>Informasi mengenai <em>build</em>, rilis, atau <em>image</em>, seperti <em>timestamp</em>, rilis ID, git <em>branch</em>,
nomor PR, <em>hash</em> suatu <em>image</em>, dan alamat registri.</p></li><li><p>Penanda untuk <em>logging</em>, <em>monitoring</em>, <em>analytics</em>, ataupun repositori audit.</p></li><li><p>Informasi mengenai <em>library</em> klien atau perangkat yang dapat digunakan untuk <em>debugging</em>:
misalnya, informasi nama, versi, dan <em>build</em>.</p></li><li><p>Informasi yang berhubungan dengan pengguna atau perangkat/sistem, seperti URL objek yang terkait
dengan komponen dari ekosistem lain.</p></li><li><p>Metadata untuk perangkat <em>rollout</em> yang ringan (<em>lightweight</em>): contohnya, untuk
konfigurasi atau penanda (<em>checkpoint</em>).</p></li><li><p>Nomor telepon atau <em>pager</em> dari orang yang bertanggung jawab, atau entri direktori
yang berisi informasi lebih lanjut, seperti <em>website</em> sebuah tim.</p></li><li><p>Arahan dari pengguna (<em>end-user</em>) untuk melakukan implementasi, perubahan perilaku,
ataupun untuk interaksi dengan fitur-fitur non-standar.</p></li></ul><p>Tanpa menggunakan anotasi, kamu dapat saja menyimpan informasi-informasi dengan tipe
di atas pada suatu basis data atau direktori eksternal, namun hal ini sangat mempersulit
pembuatan <em>library</em> klien dan perangkat yang bisa digunakan sama-sama (<em>shared</em>) untuk melakukan
<em>deploy</em>, pengelolaan, introspeksi, dan semacamnya.</p><h2 id=sintaksis-dan-sekumpulan-karakter>Sintaksis dan sekumpulan karakter</h2><p>Anotasi merupakan <em>key/value pair</em>. <em>Key</em> dari sebuah anotasi yang valid memiliki dua segmen: segmen prefiks yang opsional dan segmen nama, dipisahkan
oleh sebuah garis miring (<code>/</code>). Segmen nama bersifat wajib dan harus terdiri dari 63 karakter atau kurang, dimulai dan diakhiri dengan karakter alfanumerik (<code>[a-z0-9A-Z]</code>) dengan tanda minus (<code>-</code>), garis bawah (<code>_</code>), titik (<code>.</code>), dan alfanumerik di tengahnya. Jika terdapat prefiks,
prefiks haruslah berupa subdomain DNS: urutan dari label DNS yang dipisahkan oleh titik (<code>.</code>), totalnya tidak melebihi 253 karakter,
diikuti dengan garis miring (<code>/</code>).</p><p>Jika tidak terdapat prefiks, maka <em>key</em> dari anotasi diasumsikan hanya bisa dilihat oleh pengguna (privat). Komponen sistem otomasi
(seperti <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, ataupun otomasi pihak ketiga) yang menambahkan anotasi
pada objek-objek pengguna harus memiliki sebuah prefiks.</p><p>Prefiks <code>kubernetes.io/</code> dan <code>k8s.io/</code> merupakan reservasi dari komponen inti Kubernetes.</p><h2 id=selanjutnya>Selanjutnya</h2><p>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/overview/working-with-objects/labels/>Label dan Selektor</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>7 - Selektor Field</h1><p>Selektor <em>field</em> memungkinkan kamu untuk <a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects>memilih (<em>select</em>) <em>resource</em> Kubernetes</a> berdasarkan
nilai dari satu atau banyak <em>field resource</em>. Di bawah ini merupakan contoh dari beberapa <em>query</em> selektor <em>field</em>:</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>Perintah <code>kubectl</code> di bawah ini memilih semua Pod dengan <em>field</em> <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a> yang bernilai
<code>Running</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Pada dasarnya, selektor <em>field</em> merupakan filter dari <em>resource</em>. Secara <em>default</em>, tidak ada selektor/filter apapun yang diterapkan. Artinya,
semua <em>resource</em> dengan tipe apapun akan terpilih. Akibatnya, <em>query</em> dengan perintah <code>kubectl</code> di bawah ini akan memberikan hasil yang sama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>kubectl get pods --field-selector <span style=color:#b44>&#34;&#34;</span>
</span></span></code></pre></div></div><h2 id=field-yang-didukung><em>Field</em> yang didukung</h2><p>Selektor-selektor <em>field</em> yang didukung oleh Kubernetes bervariasi tergantung dari tipe <em>resource</em>. Semua tipe <em>resource</em> mendukung <em>field</em>
<code>metadata.name</code> dan <code>metadata.namespace</code>. Jika kamu menggunakan selektor <em>field</em> yang tidak didukung, maka akan terjadi error. Contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=operator-yang-didukung>Operator yang didukung</h2><p>Kamu dapat menggunakan operator <code>=</code>, <code>==</code>, dan <code>!=</code> pada selektor <em>field</em> (<code>=</code> dan <code>==</code> punya arti yang sama). Sebagai contoh, perintah <code>kubectl</code> ini
memilih semua Kubernetes Service yang tidak terdapat pada <em>namespace</em> <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=selektor-berantai>Selektor berantai</h2><p>Seperti halnya <a href=/id/docs/concepts/overview/working-with-objects/labels>label</a> dan selektor-selektor lainnya, kamu dapat membuat selektor <em>field</em> berantai
(<em>chained</em>) dengan <em>list</em> yang dipisahkan oleh koma. Perintah <code>kubectl</code> di bawah ini memilih semua Pod dengan <code>status.phase</code> tidak sama dengan
<code>Running</code> dan <em>field</em> <code>spec.restartPolicy</code> sama dengan <code>Always</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=resource-dengan-beberapa-tipe><em>Resource</em> dengan beberapa tipe</h2><p>Kamu dapat menggunakan selektor-selektor <em>field</em> dengan beberapa tipe <em>resource</em> sekaligus. Perintah <code>kubectl</code> di bawah ini memilih semua Statefulset
dan Service yang tidak terdapat pada <em>namespace</em> <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>8 - Label yang Disarankan</h1><p>Kamu dapat melakukan visualisasi dan mengatur objek Kubernetes dengan lebih banyak <em>tools</em>
dibandingkan dengan perintah kubectl dan dasbor. Sekumpulan label mengizinkan <em>tools</em>
untuk bekerja dengan interoperabilitas, mendeskripsikan objek dengan cara yang umum yang dapat
dipahami semua <em>tools</em>.</p><p>Sebagai tambahan bagi <em>tooling</em> tambahan, label yang disarankan ini mendeskripsikan
aplikasi sehingga informasi yang ada diapat di-<em>query</em>.</p><p>Metadata ini diorganisasi berbasis konsep dari sebuah aplikasi. Kubernetes bukan merupakan
sebuah platform sebagai sebuah <em>service</em> (<em>platform as a service</em>/PaaS) dan tidak
mewajibkan sebuah gagasan formal dari sebuah aplikasi.
Sebagai gantinya, aplikasi merupakan suatu hal informal yang dideskripsikan melalui metadata.
Definisi yang dimiliki oleh sebuah aplikasi merupakan sebuah hal yang cukup longgar.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Berikut merupakan label yang disarankan. Label ini mempermudah
proses manajemen aplikasi tetapi tidak dibutuhkan untuk <em>tooling</em> utama apa pun.</div><p>Label yang digunakan secara umum serta anotasi memiliki prefiks yang serupa: <code>app.kubernetes.io</code>. Label
tanpa sebuah prefiks bersifat privat khusus pengguna saja. Prefiks yang digunakan secara umum tadi
menjamin bahwa label tadi tidak akan mengganggu label <em>custom</em> yang diberikan oleh pengguna.</p><h2 id=label>Label</h2><p>Untuk mendapatkan keuntungan menyeluruh dari penggunaan label ini,
label harus digunakan pada seluruh objek sumber daya.</p><table><thead><tr><th><em>Key</em></th><th>Deskripsi</th><th>Contoh</th><th>Tipe</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>Nama aplikasi</td><td><code>mysql</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>Nama unik yang bersifat sebagai pengidentifikasi dari sebuah instans aplikasi</td><td><code>wordpress-abcxzy</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>Versi saat ini dari aplikasi (misalnya sebuah versi semantik, hash revisi, etc.)</td><td><code>5.7.21</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>Komponen yang ada pada arsitektur</td><td><code>database</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>Nama dari komponen lebih tinggi dari aplikasi yang mencakup bagian ini</td><td><code>wordpress</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>Alat yang digunakan untuk mengatur operasi pada aplikasi</td><td><code>helm</code></td><td>string</td></tr></tbody></table><p>Untuk memberikan ilustrasi dari penggunaan label, bayangkan sebuah objek StatefulSet yang didefinisikan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=aplikasi-dan-instans-aplikasi>Aplikasi dan Instans Aplikasi</h2><p>Sebuah aplikasi dapat diinstal sekali atau beberapa kali di dalam klaster Kubernetes dan,
pada beberapa kasus, di dalam sebuah <em>namespace</em> yang sama. Misalnya, wordpress dapat
diinstal lebih dari satu kali dimana situs web yang berbeda merupakan hasil instalasi yang berbeda.</p><p>Nama dari sebuah aplikasi dan nama instans akan dicatat secara terpisah. Sebagai contoh,
WordPress memiliki <code>wordpress</code> sebagai nilai dari <code>app.kubernetes.io/name</code> dimana
nama instans yang digunakan adalah <code>wordpress-abcxzy</code> yang merupakan nilai dari <code>app.kubernetes.io/instance</code>.
Hal ini memungkinkan aplikasi dan instans aplikasi untuk dapat diidentifikasi. Setiap instans dari aplikasi
haruslah memiliki nama yang unik.</p><h2 id=contoh>Contoh</h2><p>Untuk memberikan ilustrasi dengan cara yang berbeda pada penggunaan label, contoh di bawah ini
memiliki tingkat kompleksitas yang cukup beragam.</p><h3 id=sebuah-aplikasi-stateless-sederhana>Sebuah Aplikasi <em>Stateless</em> Sederhana</h3><p>Bayangkan sebuah kasus dimana sebuah aplikasi <em>stateless</em> di-<em>deploy</em>
menggunakan Deployment dan Service. Di bawah ini merupakan
contoh kutipan yang merepresentasikan bagaimana
label dapat digunakan secara sederhana.</p><p>Deployment digunakan untuk memastikan Pod dijalankan untuk aplikasi itu sendiri.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Service digunakan untuk mengekspos aplikasi.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=sebuah-aplikasi-web-dengan-basis-data>Sebuah Aplikasi Web dengan Basis Data</h3><p>Bayangkan sebuah aplikasi yang lebih kompleks: sebuah aplikasi web (WordPress)
yang menggunakan basis data (MySQL), yang diinstal menggunakan Helm.
Kutipan berikut merepresentasikan objek yang di-<em>deploy</em> untuk aplikasi ini.</p><p>Berikut merupakan konfigurasi Deployment yang digunakan untuk WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Service yang digunakan untuk mengekspos WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL diekspos sebagai StatefulSet dengan metadata yang digunakan untuk StatefulSet tersebut serta aplikasi yang menggunakannya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Service yang digunakan untuk mengekspos MySQL sebagai bagian dari WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Dengan StatefulSet MySQL dan Service kamu dapat mengetahui informasi yang ada pada MySQL dan Wordpress.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>