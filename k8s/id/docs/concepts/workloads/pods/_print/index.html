<!doctype html><html lang=id class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/workloads/pods/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/workloads/pods/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/workloads/pods/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/workloads/pods/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/workloads/pods/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/workloads/pods/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/concepts/workloads/pods/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Pods | Kubernetes</title><meta property="og:title" content="Pods"><meta property="og:description" content="Orkestrasi Kontainer dengan Skala Produksi"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/workloads/pods/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Pods"><meta itemprop=description content="Orkestrasi Kontainer dengan Skala Produksi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pods"><meta name=twitter:description content="Orkestrasi Kontainer dengan Skala Produksi"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/workloads/pods/"><meta property="og:title" content="Pods"><meta name=twitter:title content="Pods"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/id/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/id/docs/concepts/workloads/pods/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/id/docs/concepts/workloads/pods/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/concepts/workloads/pods/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/concepts/workloads/pods/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/concepts/workloads/pods/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/workloads/pods/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/workloads/pods/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/workloads/pods/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/workloads/pods/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/workloads/pods/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/workloads/pods/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/workloads/pods/>Español (Spanish)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/concepts/workloads/pods/>Return to the regular view of this page</a>.</p></div><h1 class=title>Pods</h1><ul><li>1: <a href=#pg-37afa6c66c74400d1579f10faf55e5b6>Pengenalan Pod</a></li><li>2: <a href=#pg-99cce294fe789317ee684a6e1f07f20f>Pod</a></li><li>3: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>Siklus Hidup Pod</a></li><li>4: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>Init Container</a></li><li>5: <a href=#pg-c8d62295ca703fdcef1aaf89fb4c916a>Batasan Persebaran Topologi Pod</a></li><li>6: <a href=#pg-4e9b9cbc9776b12e7335c53da377c9c8>Pod Preset</a></li><li>7: <a href=#pg-4aaf43c715cd764bc8ed4436f3537e68>Disrupsi</a></li><li>8: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>Kontainer Sementara (Ephemeral)</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-37afa6c66c74400d1579f10faf55e5b6>1 - Pengenalan Pod</h1><p>Halaman ini menyajikan ikhtisar dari <code>Pod</code>, objek terkecil yang dapat di <em>deploy</em> di dalam objek model Kubernetes.</p><h2 id=memahami-pod>Memahami Pod</h2><p>Sebuah <em>Pod</em> adalah unit dasar di Kubernetes--unit terkecil dan paling sederhana di dalam objek model Kubernetes yang dapat dibuat dan di <em>deploy</em>. Sebuah <em>Pod</em> merepresentasikan suatu proses yang berjalan di dalam klaster.</p><p><em>Pod</em> membungkus sebuah kontainer (atau, di beberapa kasus, beberapa kontainer), sumber penyimpanan, alamat jaringan <em>IP</em> yang unik, dan opsi yang mengatur bagaimana kontainer harus dijalankan. <em>Pod</em> merupakan representasi dari unit <em>deployment</em>: sebuah <em>instance</em> aplikasi di dalam Kubernetes, yang mungkin terdiri dari satu kontainer atau sekumpulan kontainer yang berbagi <em>resource</em>.</p><p><a href=https://www.docker.com>Docker</a> adalah salah satu kontainer <em>runtime</em> yang paling umum digunakan di Kubernetes <em>Pod</em>, tetapi <em>Pod</em> mendukung kontainer <em>runtime</em> lainnya.</p><p><em>Pod</em> di Kubernetes klaster dapat digunakan dengan dua cara:</p><ul><li><strong>Pod menjalankan satu kontainer</strong>. Model satu kontainer per <em>Pod</em> adalah model yang umum digunakan di Kubernetes; kamu dapat membayangkan sebuah <em>Pod</em> sebagai pembungkus kontainer tersebut, dan Kubernetes tidak mengelola kontainer secara langsung tetapi mengelola <em>Pod</em> tersebut.</li><li><strong>Pod menjalankan beberapa kontainer yang perlu berjalan bersamaan</strong>. Sebuah <em>Pod</em> dapat membungkus sebuah aplikasi yang terdiri dari beberapa kontainer yang perlu berbagi <em>resource</em>. Kontainer yang ditempatkan di dalam satu <em>Pod</em> ini membentuk sebuah layanan. Sebuah kontainer menyajikan berkas dari sumber penyimpanan ke publik, sedangkan kontainer <em>sidecar</em> yang lain melakukan pembaharuan terhadap berkas tersebut. <em>Pod</em> membungkus semua kontainer dan <em>resource</em> penyimpanan sebagai satu kesatuan yang dapat dikelola.</li></ul><p><a href=http://kubernetes.io/blog>Kubernetes Blog</a> menyediakan beberapa informasi tambahan terkait penggunaan <em>Pod</em>. Informasi selengkapnya, kunjungi:</p><ul><li><a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System Toolkit: Patterns for Composite Containers</a></li><li><a href=https://kubernetes.io/blog/2016/06/container-design-patterns>Container Design Patterns</a></li></ul><p>Setiap <em>Pod</em> dimaksudkan untuk menjalankan satu <em>instance</em> aplikasi. Jika kamu ingin mengembangkan aplikasi secara horizontal (contoh, banyak <em>instance</em> sekaligus), kamu dapat menggunakan banyak <em>Pod</em>, satu untuk setiap <em>instance</em>. Di Kubernetes, konsep ini umumnya disebut dengan replikasi. <em>Pod</em> yang direplikasi biasanya dibuat dan dikelola sebagai grup oleh objek abstraksi yang disebut kontroler. Lihat <a href=#pod-dan-kontroler>Pod dan Kontroler</a> untuk informasi selengkapnya.</p><h3 id=bagaimana-pod-mengelola-beberapa-kontainer>Bagaimana <em>Pod</em> mengelola beberapa Kontainer</h3><p><em>Pod</em> didesain untuk mendukung banyak proses (sebagai kontainer) yang membentuk sebuah layanan. Kontainer di dalam sebuah <em>Pod</em> akan otomatis ditempatkan bersama di dalam satu mesin fisik atau mesin <em>virtual</em> di dalam klaster. Kontainer tersebut dapat berbagi <em>resource</em> dan dependensi, berkomunikasi satu sama lain, dan berkoordinasi kapan dan bagaimana mereka diterminasi.</p><p>Perhatikan bahwa mengelompokan kontainer di dalam satu <em>Pod</em> merupakan kasus lanjutan. Kamu dapat menggunakan pola ini hanya dalam kasus tertentu. Sebagai contoh, kamu memiliki kontainer yang bertindak sebagai <em>web server</em> yang menyajikan berkas dari <em>resource</em> penyimpanan bersama, dan kontainer <em>sidecar</em> melakukan pembaharuan terhadap berkas tersebut dari sumber lain, seperti dalam diagram <em>Pod</em> berikut:<figure><img src=/images/docs/pod.svg width=50%><figcaption><h4>Pod diagram</h4></figcaption></figure></p><p><em>Pod</em> menyediakan dua jenis <em>resource</em> sebagai penyusun dari kontainer: <em>jaringan</em> dan <em>penyimpanan</em>.</p><h4 id=jaringan>Jaringan</h4><p>Setiap <em>Pod</em> diberikan sebuah alamat <em>IP</em> unik. Setiap kontainer di dalam <em>Pod</em> berbagi <em>network namespace</em>, termasuk alamat <em>IP</em> dan <em>port</em> jaringan. Setiap kontainer di dalam <em>Pod</em> dapat berkomunikasi satu sama lain menggunakan <em>localhost</em>. Saat para kontainer di dalam <em>Pod</em> berkomunikasi dengan entitas lain di luar <em>Pod</em>, mereka harus berkoordinasi satu sama lain bagaimana mereka menggunakan <em>resource</em> jaringan (seperti <em>Port</em>).</p><h4 id=penyimpanan>Penyimpanan</h4><p><em>Pod</em> dapat menentukan penyimpanan bersama yaitu <em>volumes</em>. Semua kontainer di dalam <em>Pod</em> dapat mengakses <em>volumes</em> ini, mengizinkan kontainer untuk berbagi data. <em>Volumes</em> juga memungkinkan data di <em>Pod</em> untuk bertahan jika salah satu kontainer perlu melakukan proses <em>restart</em>. Lihat <em><a href=/id/docs/concepts/storage/volumes/>Volumes</a></em> untuk informasi lebih lanjut bagaimana Kubernetes mengimplementasikan penyimpanan di dalam <em>Pod</em>.</p><h2 id=bekerja-dengan-pod>Bekerja dengan Pod</h2><p>Kamu akan jarang membuat <em>Pod</em> secara langsung di Kubernetes. Ini karena <em>Pod</em> dirancang sebagai entitas sesaat. Saat <em>Pod</em> dibuat (baik oleh kamu, atau secara tidak langsung oleh kontroler), <em>Pod</em> ditempatkan dan dijalankan di sebuah <em>Node</em> di dalam klaster. <em>Pod</em> akan tetap di <em>Node</em> tersebut sampai proses dihentikan, Objek <em>Pod</em> dihapus, <em>Pod</em> dihentikan karena kekurangan <em>resource</em>, atau <em>Node</em> tersebut berhenti berjalan.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Tidak perlu bingung untuk membedakan antara menjalankan ulang sebuah kontainer di dalam <em>Pod</em> dan menjalankan ulang <em>Pod</em>. <em>Pod</em> itu sendiri tidak berjalan, tetapi <em>Pod</em> adalah <em>environment</em> kontainer itu berjalan dan akan tetap ada sampai dihapus.</div><p><em>Pod</em> tidak melakukan mekanisme penyembuhan diri sendiri. Jika <em>Pod</em> ditempatkan disebuah <em>Node</em> yang gagal, atau proses penempatan <em>Pod</em> itu sendiri gagal, <em>Pod</em> akan dihapus; demikian juga, <em>Pod</em> tidak akan bertahan jika <em>Node</em> tersebut kehabisan <em>resource</em> atau sedang dalam tahap pemeliharaan. Kubernetes menggunakan abstraksi yang disebut kontroler, yang menangani dan mengelola <em>Pod</em>. Jadi, meskipun <em>Pod</em> dapat dipakai secara langsung di Kubernetes, kontroler merupakan cara umum yang digunakan untuk mengelola <em>Pod</em>. Lihat <a href=#pod-dan-kontroler>Pod dan kontroler</a> untuk informasi lebih lanjut bagaimana Kubernetes menggunakan kontroler untuk mengimpelentasikan mekanisme penyembuhan diri sendiri dan replikasi pada <em>Pod</em>.</p><h3 id=pod-dan-kontroler>Pod dan Kontroler</h3><p>Kontroler dapat membuat dan mengelola banyak <em>Pod</em> untuk kamu, menangani replikasi dan menyediakan kemampuan penyembuhan diri sendiri pada lingkup klaster. Sebagai contoh, jika sebuah <em>Node</em> gagal, kontroler akan otomatis mengganti <em>Pod</em> tersebut dengan menempatkan <em>Pod</em> yang identik di <em>Node</em> yang lain.</p><p>Beberapa contoh kontroler yang berisi satu atau lebih <em>Pod</em> meliputi:</p><ul><li><a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/id/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/id/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li></ul><p>Secara umum, kontroler menggunakan templat <em>Pod</em> yang kamu sediakan untuk membuat <em>Pod</em>.</p><h2 id=templat-pod>Templat Pod</h2><p>Templat <em>Pod</em> adalah spesifikasi dari <em>Pod</em> yang termasuk di dalam objek lain seperti
<a href=/id/docs/concepts/workloads/controllers/replicationcontroller/>Replication Controllers</a>, <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/>Jobs</a>, dan <a href=/id/docs/concepts/workloads/controllers/daemonset/>DaemonSets</a>. Kontroler menggunakan templat <em>Pod</em> untuk membuat <em>Pod</em>.</p><p>Contoh di bawah merupakan manifestasi sederhana untuk <em>Pod</em> yang berisi kontainer yang membuat sebuah pesan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo Hello Kubernetes! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Perubahan yang terjadi pada templat atau berganti ke templat yang baru tidak memiliki efek langsung pada <em>Pod</em> yang sudah dibuat. <em>Pod</em> yang dibuat oleh <em>replication controller</em> dapat diperbarui secara langsung.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang perilaku <em>Pod</em>:<ul><li><a href=/id/docs/concepts/workloads/pods/pod/#termination-of-pods>Terminasi Pod</a></li><li><a href=/id/docs/concepts/workloads/pods/pod-lifecycle/>Lifecycle Pod</a></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-99cce294fe789317ee684a6e1f07f20f>2 - Pod</h1><p>Pod adalah unit komputasi terkecil yang bisa di-<em>deploy</em> dan dibuat serta dikelola dalam Kubernetes.</p><h2 id=apa-itu-pod>Apa Itu Pod?</h2><p>Sebuah Pod (seperti pod pada paus atau kacang polong) adalah sebuah kelompok yang
terdiri dari satu atau lebih <a class=glossary-tooltip title='Sebuah image yang ringan dan dapat dijalankan yang mengandung perangkat lunak and segala dependensi yang dibutuhkan.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/what-is-kubernetes/#mengapa-kontainer target=_blank aria-label=kontainer>kontainer</a>
(misalnya kontainer Docker), dengan ruang penyimpanan ataupun jaringan yang dipakai bersama,
dan sebuah spesifikasi mengenai bagaimana menjalankan kontainer. Isi dari Pod akan
selalu diletakkan dan dijadwalkan bersama, serta berjalan dalam konteks yang sama.
Sebuah Pod memodelkan <em>"logical host"</em> yang spesifik terhadap aplikasi. Ini mengandung
lebih dari satu kontainer aplikasi yang secara relatif saling terhubung erat. Sebelum
masa kontainer, menjalankan aplikasi dalam mesin fisik atau <em>virtual</em> berarti
menjalankan dalam <em>logical host</em> yang sama.</p><p>Walaupun Kubernetes mendukung lebih banyak <em>runtime</em> kontainer selain Docker,
namun Docker adalah yang paling umum diketahui dan ini membantu dalam menjelaskan
Pod dengan istilah pada Docker.</p><p>Konteks bersama dalam sebuah Pod adalah kumpulan Linux namespace, cgroup dan
kemungkinan segi isolasi lain, hal yang sama yang mengisolasi kontainer Docker.
Dalam sebuah konteks pada Pod, setiap aplikasi bisa menerapkan sub-isolasi lebih lanjut.</p><p>Semua kontainer dalam suatu Pod akan berbagi alamat IP dan <em>port</em> yang sama,
dan bisa saling berkomunikasi melalui <code>localhost</code>. Komunikasi tersebut mengunakan
standar <em>inter-process communications</em> (IPC) seperti SystemV semaphores
atau POSIX shared memory. Kontainer pada Pod yang berbeda memiliki alamat IP
yang berbeda dan tidak dapat berkomunikasi menggunakan IPC tanpa
<a href=/id/docs/concepts/policy/pod-security-policy/>pengaturan khusus</a>. Kontainer ini
biasa berkomunikasi dengan yang lain menggunakan alamat IP setiap Pod.</p><p>Aplikasi dalam suatu Pod juga memiliki akses ke <a class=glossary-tooltip title='Sebuah direktori yang mengandung data, dapat diakses o;eh kontainer-kontainer di dalam pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label='ruang penyimpanan'>ruang penyimpanan</a> bersama,
yang didefinisikan sebagai bagian dari Pod dan dibuat bisa diikatkan ke masing-masing
<em>filesystem</em> pada aplikasi.</p><p>Dalam istilah konsep <a href=https://www.docker.com/>Docker</a>, sebuah Pod dimodelkan sebagai
gabungan dari kontainer Docker yang berbagi <em>namespace</em> dan ruang penyimpanan <em>filesystem</em>.</p><p>Layaknya aplikasi dengan kontainer, Pod dianggap sebagai entitas yang relatif tidak kekal
(tidak bertahan lama). Seperti yang didiskusikan dalam
<a href=/id/docs/concepts/workloads/pods/pod-lifecycle/>siklus hidup Pod</a>, Pod dibuat, diberikan
ID unik (UID), dan dijadwalkan pada suatu mesin dan akan tetap disana hingga dihentikan
(bergantung pada aturan <em>restart</em>) atau dihapus. Jika <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=mesin>mesin</a>
mati, maka semua Pod pada mesin tersebut akan dijadwalkan untuk dihapus, namun setelah
suatu batas waktu. Suatu Pod tertentu (sesuai dengan ID unik) tidak akan dijadwalkan ulang
ke mesin baru, namun akan digantikan oleh Pod yang identik, bahkan jika dibutuhkan bisa
dengan nama yang sama, tapi dengan ID unik yang baru
(baca <a href=/id/docs/concepts/workloads/controllers/replicationcontroller/><em>replication controller</em></a>
untuk info lebih lanjut)</p><p>Ketika sesuatu dikatakan memiliki umur yang sama dengan Pod, misalnya saja ruang penyimpanan,
maka itu berarti akan tetap ada selama Pod tersebut masih ada. Jika Pod dihapus dengan
alasan apapun, sekalipun Pod pengganti yang identik telah dibuat, semua yang berhubungan
(misalnya ruang penyimpanan) akan dihapus dan dibuat ulang.</p><figure><img src=/images/docs/pod.svg width=50%><figcaption><h4>Pod diagram</h4></figcaption></figure><p><em>Sebuah Pod dengan banyak kontainer, yaitu <em>File Puller</em> dan <em>Web Server</em> yang menggunakan
ruang penyimpanan persisten untuk berbagi ruang penyimpanan bersama antara kontainer.</em></p><h2 id=motivasi-suatu-pods>Motivasi suatu Pods</h2><h3 id=pengelolaan>Pengelolaan</h3><p>Pod adalah suatu model dari pola beberapa proses yang bekerja sama dan membentuk
suatu unit layanan yang kohesif. Menyederhanakan proses melakukan <em>deploy</em> dan
pengelolaan aplikasi dengan menyediakan abstraksi tingkat yang lebih tinggi
daripada konstituen aplikasinya. Pod melayani sebagai unit dari <em>deployment</em>,
penskalaan horizontal, dan replikasi. <em>Colocation</em> (<em>co-scheduling</em>), berbagi nasib
(misalnya dimatikan), replikasi terkoordinasi, berbagi sumber daya dan
pengelolaan ketergantungan akan ditangani otomatis untuk kontainer dalam suatu Pod.</p><h3 id=berbagi-sumber-daya-dan-komunikasi>Berbagi sumber daya dan komunikasi</h3><p>Pod memungkinkan berbagi data dan komunikasi diantara konstituennya.</p><p>Semua aplikasi dalam suatu Pod menggunakan <em>namespace</em> jaringan yang sama
(alamat IP dan <em>port</em> yang sama), dan menjadikan bisa saling mencari dan berkomunikasi
dengan menggunakan <code>localhost</code>. Oleh karena itu, aplikasi dalam Pod harus
berkoordinasi mengenai penggunaan <em>port</em>. Setiap Pod memiliki alamat IP
dalam satu jaringan bersama yang bisa berkomunikasi dengan komputer lain
dan Pod lain dalam jaringan yang sama.</p><p>Kontainer dalam suatu Pod melihat <em>hostname</em> sistem sebagai sesuatu yang sama
dengan konfigurasi <code>name</code> pada Pod. Informasi lebih lanjut terdapat dibagian
<a href=/id/docs/concepts/cluster-administration/networking/>jaringan</a>.</p><p>Sebagai tambahan dalam mendefinisikan kontainer aplikasi yang berjalan dalam Pod,
Pod memberikan sepaket sistem penyimpanan bersama. Sistem penyimpanan memungkinkan
data untuk bertahan saat kontainer dijalankan ulang dan dibagikan kepada semua
aplikasi dalam Pod tersebut.</p><h2 id=penggunaan-pod>Penggunaan Pod</h2><p>Pod dapat digunakan untuk menjalankan beberapa aplikasi yang terintegrasi
secara vertikal (misalnya LAMP), namun motivasi utamanya adalah untuk mendukung
berlokasi bersama, mengelola program pembantu, diantaranya adalah:</p><ul><li>sistem pengelolaan konten, pemuat berkas dan data, manajer <em>cache</em> lokal, dll.</li><li>catatan dan <em>checkpoint</em> cadangan, kompresi, rotasi, dll.</li><li>pengamat perubahan data, pengintip catatan, adapter pencatatan dan pemantauan,
penerbit peristiwa, dll.</li><li>proksi, jembatan dan adaptor.</li><li>pengontrol, manajer, konfigurasi dan pembaharu.</li></ul><p>Secara umum, masing-masing Pod tidak dimaksudkan untuk menjalankan beberapa
aplikasi yang sama.</p><p>Penjelasan lebih lengkap bisa melihat <a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System ToolKit: Patterns for Composite Containers</a>.</p><h2 id=alternatif-pertimbangan>Alternatif pertimbangan</h2><p>Kenapa tidak menjalankan banyak program dalam satu kontainer (Docker)?</p><ol><li>Transparansi. Membuat kontainer dalam suatu Pod menjadi terlihat dari infrastruktur,
memungkinkan infrastruktur menyediakan servis ke kontainer tersebut, misalnya saja
pengelolaan proses dan pemantauan sumber daya. Ini memfasilitasi sejumlah
kenyamanan untuk pengguna.</li><li>Pemisahan ketergantungan perangkat lunak. Setiap kontainer mungkin memiliki
versi, dibuat dan dijalankan ulang secara independen. Kubernetes mungkin mendukung
pembaharuan secara langsung terhadap suatu kontainer, suatu saat nanti.</li><li>Mudah digunakan. Penguna tidak diharuskan menjalankan manajer prosesnya sendiri,
khawatir dengan sinyal dan propagasi <em>exit-code</em>, dan lain sebagainya.</li><li>Efisiensi. Karena infrastruktur memegang lebih banyak tanggung jawab, kontainer
bisa lebih ringan.</li></ol><p>Kenapa tidak mendukung penjadwalan kontainer berdasarkan <em>affinity</em>?</p><p>Cara itu bisa menyediakan lokasi yang sama, namun tidak memberikan banyak
keuntungan dari Pod, misalnya saja berbagi sumber daya, IPC, jaminan berbagi nasib
dan kemudahan manajemen.</p><h2 id=ketahanan-suatu-pod-atau-kekurangan>Ketahanan suatu Pod (atau kekurangan)</h2><p>Pod tidak dimaksudkan untuk diperlakukan sebagai entitas yang tahan lama.
Mereka tidak akan bertahan dengan kegagalan penjadwalan, kegagalan mesin,
atau <em>eviction</em> (pengusiran), misalnya karena kurangnya sumber daya atau dalam suatu
kasus mesin sedang dalam pemeliharaan.</p><p>Secara umum, pengguna tidak seharusnya butuh membuat Pod secara langsung. Mereka
seharusnya selalu menggunakan pengontrol, sekalipun untuk yang tunggal, misalnya,
<a href=/id/docs/concepts/workloads/controllers/deployment/><em>Deployment</em></a>. Pengontrol
menyediakan penyembuhan diri dengan ruang lingkup kelompok, begitu juga dengan
pengelolaan replikasi dan penluncuran.
Pengontrol seperti <a href=/id/docs/concepts/workloads/controllers/statefulset.md><em>StatefulSet</em></a>
bisa memberikan dukungan terhadap Pod yang <em>stateful</em>.</p><p>Penggunaan API kolektif sebagai <em>user-facing primitive</em> utama adalah hal yang
relatif umum diantara sistem penjadwalan kluster, seperti</p><p><a href=https://research.google.com/pubs/pub43438.html>Borg</a>,
<a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a>,
<a href=http://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a>, dan
<a href=https://www.slideshare.net/Docker/aravindnarayanan-facebook140613153626phpapp02-37588997>Tupperware</a>.</p><p>Pod diekspose sebagai <em>primitive</em> untuk memfasilitasi hal berikut:</p><ul><li>penjadwalan dan pengontrol sifat <em>pluggability</em></li><li>mendukung operasi pada level Pod tanpa perlu melakukan proksi melalui API pengontrol</li><li>pemisahan antara umur suatu Pod dan pengontrol, seperti misalnya <em>bootstrapping</em>.</li><li>pemisahan antara pengontrol dan servis, pengontrol <em>endpoint</em> hanya memperhatikan Pod</li><li>komposisi yang bersih antara fungsionalitas dilevel Kubelet dan klaster. Kubelet
secara efektif adalah pengontrol Pod.</li><li>aplikasi dengan ketersediaan tinggi, yang akan mengharapkan Pod akan digantikan
sebelum dihentikan dan tentu saja sebelum dihapus, seperti dalam kasus penggusuran
yang direncanakan atau pengambilan gambar.</li></ul><h2 id=penghentian-pod>Penghentian Pod</h2><p>Karena Pod merepresentasikan proses yang berjalan pada mesin didalam klaster, sangat
penting untuk memperbolehkan proses ini berhenti secara normal ketika sudah tidak
dibutuhkan (dibandingkan dengan dihentikan paksa dengan sinyal KILL dan tidak memiliki
waktu untuk dibersihkan). Pengguna seharusnya dapat meminta untuk menghapus dan tahu
proses penghentiannya, serta dapat memastikan penghentian berjalan sempurna. Ketika
pengguna meminta menghapus Pod, sistem akan mencatat masa tenggang untuk penghentian
secara normal sebelum Pod dipaksa untuk dihentikan, dan sinyal TERM akan dikirim ke
proses utama dalam setiap kontainer. Setelah masa tenggang terlewati, sinyal KILL
akan dikirim ke setiap proses dan Pod akan dihapus dari API server. Jika Kubelet
atau kontainer manajer dijalankan ulang ketika menunggu suatu proses dihentikan,
penghentian tersebut akan diulang dengan mengembalikan masa tenggang senilai semula.</p><p>Contohnya sebagai berikut:</p><ol><li>Pengguna mengirim perintah untuk menghapus Pod, dengan masa tenggang (30 detik)</li><li>Pod dalam API server akan diperbarui dengan waktu dimana Pod dianggap "mati"
bersama dengan masa tenggang.</li><li>Pod ditampilkan dalam status "Terminating" ketika tercantum dalam perintah klien</li><li>(bersamaan dengan poin 3) Ketika Kubelet melihat Pod sudah ditandai sebagai
"Terminating" karena waktu pada poin 2 sudah diatur, ini memulai proses penghentian Pod<ol><li>Jika salah satu kontainer pada Pod memiliki
<a href=/id/docs/concepts/containers/container-lifecycle-hooks/#hook-details>preStop <em>hook</em></a>,
maka akan dipanggil di dalam kontainer. Jika <code>preStop</code> <em>hook</em> masih berjalan
setelah masa tenggang habis, langkah 2 akan dipanggil dengan tambahan masa tenggang
yang sedikit, 2 detik.</li><li>Semua kontainer akan diberikan sinyal TERM. Sebagai catatan, tidak semua kontainer
akan menerima sinyal TERM dalam waktu yang sama dan mungkin butuh waktu untuk
menjalankan <code>preStop</code> <em>hook</em> jika bergantung pada urutan penghentiannya.</li></ol></li><li>(bersamaan dengan poin 3) Pod akan dihapus dari daftar <em>endpoint</em> untuk servis dan
tidak lagi dianggap sebagai bagian dari Pod yang berjalan dalam <em>replication controllers</em>.
Pod yang dihentikan, secara perlahan tidak akan melayani permintaan karena load balancer
(seperti servis proksi) menghapus mereka dari daftar rotasi.</li><li>Ketika masa tenggang sudah lewat, semua proses yang masih berjalan dalam Pod
akan dihentikan dengan sinyal SIGKILL.</li><li>Kubelet akan selesai menghapus Pod dalam API server dengan mengatur masa tenggang
menjadi 0 (langsung menghapus). Pod akan menghilang dari API dan tidak lagi terlihat
oleh klien.</li></ol><p>Secara <em>default</em>, semua penghapusan akan berjalan normal selama 30 detik. Perintah
<code>kubectl delete</code> mendukung opsi <code>--grace-period=&lt;waktu dalam detik></code> yang akan
memperbolehkan pengguna untuk menimpa nilai awal dan memberikan nilai sesuai keinginan
pengguna. Nilai <code>0</code> akan membuat Pod
<a href=/id/docs/concepts/workloads/pods/pod/#force-deletion-of-pods>dihapus paksa</a>.
Kamu harus memberikan opsi tambahan <code>--force</code> bersamaan dengan <code>--grace-period=0</code>
untuk melakukan penghapusan paksa.</p><h3 id=penghapusan-paksa-sebuah-pod>Penghapusan paksa sebuah Pod</h3><p>Penghapusan paksa dari sebuah Pod didefinisikan sebagai penghapusan Pod dari <em>state</em>
klaster dan etcd secara langsung. Ketika penghapusan paksa dilakukan, API server tidak
akan menunggu konfirmasi dari kubelet bahwa Pod sudah dihentikan pada mesin ia berjalan.
Ini menghapus Pod secara langsung dari API, sehingga Pod baru bisa dibuat dengan nama
yang sama. Dalam mesin, Pod yang dihentikan paksa akan tetap diberikan sedikit masa
tenggang sebelum dihentikan paksa.</p><p>Penghentian paksa dapat menyebabkan hal berbahaya pada beberapa Pod dan seharusnya
dilakukan dengan perhatian lebih. Dalam kasus StatefulSet Pods, silakan melihat
dokumentasi untuk <a href=/docs/tasks/run-application/force-delete-stateful-set-pod/>penghentian Pod dari StatefulSet</a>.</p><h2 id=hak-istimewa-untuk-kontainer-pada-pod>Hak istimewa untuk kontainer pada Pod</h2><p>Setiap kontainer dalam Pod dapat mengaktifkan hak istimewa (mode <em>privileged</em>), dengan menggunakan tanda
<code>privileged</code> pada <a href=/id/docs/tasks/configure-pod-container/security-context/>konteks keamanan</a>
pada spesifikasi kontainer. Ini akan berguna untuk kontainer yang ingin menggunakan
kapabilitas Linux seperti memanipulasi jaringan dan mengakses perangkat. Proses dalam
kontainer mendapatkan hak istimewa yang hampir sama dengan proses di luar kontainer.
Dengan hak istimerwa, seharusnya lebih mudah untuk menulis pada jaringan dan <em>plugin</em>
ruang penyimpanan sebagai Pod berbeda yang tidak perlu dikompilasi ke dalam kubelet.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <em>Runtime</em> kontainer kamu harus mendukung konsep hak istimewa kontainer untuk membuat
pengaturan ini menjadi relevan.</div><h2 id=api-object>API Object</h2><p>Pod adalah sumber daya tingkat tinggi dalam Kubernetes REST API.
Definisi <a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>Objek Pod API</a> menjelaskan mengenai objek secara lengkap.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c3c2b9cf30915ec9d46c147201da3332>3 - Siklus Hidup Pod</h1><p></p><p>Halaman ini menjelaskan siklus hidup sebuah Pod</p><h2 id=fase-pod>Fase Pod</h2><p><em>Field</em> <code>status</code> dari sebuah Pod merupakan sebuah objek <a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>, yang memiliki sebuah <em>field</em> <code>phase</code>.</p><p>Fase dari sebuah Pod adalah sesuatu yang sederhana, ringkasan yang lebih tinggi tentang Pod dalam siklus hidupnya. Fase ini tidak ditujukan sebagai sebuah kesimpulan yang luas dari observasi suatu kontainer atau <em>state</em> suatu Pod, serta tidak ditujukan sebagai <em>state machine</em> yang luas.</p><p>Jumlah dan arti dari nilai-nilai fase Pod dijaga ketat. Selain yang ada dalam dokumentasi ini, tidak perlu berasumsi mengenai Pod telah diberikan nilai <code>phase</code>.</p><p>Berikut adalah nilai yang mungkin diberikan untuk suatu <code>phase</code>:</p><table><thead><tr><th style=text-align:left>Nilai</th><th style=text-align:left>Deskripsi</th></tr></thead><tbody><tr><td style=text-align:left><code>Pending</code></td><td style=text-align:left>Pod telah disetujui oleh sistem Kubernetes, tapi ada satu atau lebih <em>image</em> kontainer yang belum terbuat. Ini termasuk saat sebelum dijadwalkan dan juga saat mengunduh <em>image</em> melalui jaringan, yang mungkin butuh beberapa waktu.</td></tr><tr><td style=text-align:left><code>Running</code></td><td style=text-align:left>Pod telah terikat ke suatu node, dan semua kontainer telah terbuat. Setidaknya ada 1 kontainer yang masih berjalan, atau dalam proses memulai atau <em>restart</em>.</td></tr><tr><td style=text-align:left><code>Succeeded</code></td><td style=text-align:left>Semua kontainer di dalam Pod sudah berhasil dihentikan, dan tidak akan dilakukan <em>restart</em>.</td></tr><tr><td style=text-align:left><code>Failed</code></td><td style=text-align:left>Semua kontainer dalan suatu Pod telah dihentikan, dan setidaknya ada satu kontainer yang terhenti karena kegagalan. Itu merupakan kontainer yang keluar dengan kode status bukan 0 atau dihentikan oleh sistem.</td></tr><tr><td style=text-align:left><code>Unknown</code></td><td style=text-align:left><em>State</em> suatu Pod tidak dapat diperoleh karena suatu alasan, biasanya karena kesalahan dalam komunikasi dengan <em>host</em> yang digunakan Pod tersebut.</td></tr></tbody></table><h2 id=kondisi-pod>Kondisi Pod</h2><p>Suatu Pod memiliki sebuah PodStatus, yang merupakan <em>array</em> dari <a href=/docs/reference/generated/kubernetes-api/v1.25/#podcondition-v1-core>PodConditions</a> yang telah atau belum dilewati oleh Pod. Setiap elemen dari <em>array</em> PodConditions mungkin memiliki enam <em>field</em> berikut:</p><ul><li><p><em>Field</em> <code>lastProbeTime</code> memberikan nilai <em>timestamp</em> yang menandakan kapan terakhir kali kondisi kondisi Pod diperiksa.</p></li><li><p><em>Field</em> <code>lastTransitionTime</code> memberikan nilai <em>timestamp</em> yang menandakan kapan terakhir kali Pod berubah status ke status lain.</p></li><li><p><em>Field</em> <code>message</code> adalah pesan yang bisa dibaca manusia yang mengidikasikan detail dari suatu transisi.</p></li><li><p><em>Field</em> <code>reason</code> adalah suatu alasan yang unik, satu kata, ditulis secara <em>CamelCase</em> untuk kondisi transisi terakhir.</p></li><li><p><em>Field</em> <code>status</code> adalah sebuah kata dengan kemungkinan nilainya berupa "<code>True</code>", "<code>False</code>", dan "<code>Unknown</code>".</p></li><li><p><em>Field</em> <code>type</code> adalah sebuah kata yang memiliki kemungkinan nilai sebagai berikut:</p><ul><li><code>PodScheduled</code>: Pod telah dijadwalkan masuk ke node;</li><li><code>Ready</code>: Pod sudah mampu menerima <em>request</em> masuk dan seharusnya sudah ditambahkan ke daftar pembagian beban kerja untuk servis yang sama;</li><li><code>Initialized</code>: Semua <a href=/id/docs/concepts/workloads/pods/init-containers>init containers</a> telah berjalan sempurna.</li><li><code>Unschedulable</code>: <em>scheduler</em> belum dapat menjadwalkan Pod saat ini, sebagai contoh karena kekurangan <em>resources</em> atau ada batasan-batasan lain.</li><li><code>ContainersReady</code>: Semua kontainer di dalam Pod telah siap.</li></ul></li></ul><h2 id=pemeriksaan-kontainer>Pemeriksaan Kontainer</h2><p>Sebuah <a href=/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core>Probe</a> adalah sebuah diagnosa yang dilakukan secara berkala oleh <a href=/docs/admin/kubelet/>kubelet</a> dalam suatu kontainer. Untuk melakukan diagnosa, kubelet memanggil sebuah <a href=https://godoc.org/k8s.io/kubernetes/pkg/api/v1#Handler>Handler</a> yang diimplementasikan oleh kontainer. Ada 3 tipe <em>Handler</em> yang tersedia, yaitu:</p><ul><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#execaction-v1-core>ExecAction</a>: Mengeksekusi perintah tertentu di dalam kontainer. Diagnosa dikatakan berhasil jika perintah selesai dengan kode status 0.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#tcpsocketaction-v1-core>TCPSocketAction</a>: Melakukan pengecekan TCP terhadap alamat IP kontainer dengan <em>port</em> tertentu. Diagnosa dikatakan berhasil jika <em>port</em> tersebut terbuka.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#httpgetaction-v1-core>HTTPGetAction</a>: Melakukan sebuah <em>request</em> HTTP Get terhadap alamat IP kontainer dengan <em>port</em> dan <em>path</em> tertentu. Diagnosa dikatakan berhasil jika responnya memiliki kode status lebih besar atau sama dengan 200 dan kurang dari 400.</p></li></ul><p>Setiap pemeriksaan akan menghasilkan salah satu dari tiga hasil berikut:</p><ul><li><em>Success</em>: Kontainer berhasil melakukan diagnosa.</li><li><em>Failure</em>: Kontainer gagal melakukan diagnosa.</li><li><em>Unknown</em>: Gagal melakukan diagnosa, sehingga tidak ada aksi yang harus dilakukan.</li></ul><p><em>Kubelet</em> dapat secara optimal melakukan dan bereaksi terhadap dua jenis pemeriksaan yang sedang berjalan pada kontainer, yaitu:</p><ul><li><p><code>livenessProbe</code>: Ini menunjukkan apakah kontainer sedang berjalan. Jika tidak berhasil melakukan pemeriksaan terhadap <em>liveness</em> dari kontainer, maka kubelet akan mematikan kontainer, dan kontainer akan mengikuti aturan dari <a href=#restart-policy><em>restart policy</em></a>. Jika kontainer tidak menyediakan pemeriksaan terhadap <em>liveness</em>, maka nilai dari <em>state</em> adalah <code>Success</code>.</p></li><li><p><code>readinessProbe</code>: Ini menunjukan apakah kontainer sudah siap melayani <em>request</em>. Jika tidak berhasil melakukan pemeriksaan terhadap kesiapan dari kontainer, maka <em>endpoints controller</em> akan menghapus alamat IP Pod dari daftar semua <em>endpoint</em> untuk servis yang sama dengan Pod. Nilai awal <em>state</em> sebelum jeda awal adalah <code>Failure</code>. Jika kontainer tidak menyediakan pemeriksaan terhadap <em>readiness</em>, maka nilai awal <em>state</em> adalah <code>Success</code>.</p></li></ul><h3 id=kapan-sebaiknya-menggunakan-pemeriksaan-terhadap-liveness-atau-readiness>Kapan sebaiknya menggunakan pemeriksaan terhadap <em>liveness</em> atau <em>readiness</em>?</h3><p>Jika proses dalam kontainer mungkin gagal yang dikarenakan menghadapi suatu masalah
atau menjadi tidak sehat, maka pemeriksaan terhadap <em>liveness</em> tidak diperlukan.
Kubelet akan secara otomatis melakukan aksi yang tepat mengikuti <code>restartPolicy</code> dari Pod.</p><p>Jika kamu ingin kontainer bisa dimatikan dan dijalankan ulang ketika gagal melakukan
pemeriksaan, maka tentukan pemeriksaan <em>liveness</em> dan tentukan nilai <code>restartPolicy</code> sebagai <code>Always</code> atau <code>OnFailure</code>.</p><p>Jika kamu ingin mulai mengirim <em>traffic</em> ke Pod hanya ketika pemeriksaan berhasil,
maka tentukan pemeriksaan <em>readiness</em>. Dalam kasus ini, pemeriksaan <em>readiness</em> mungkin
akan sama dengan pemeriksaan <em>liveness</em>, tapi keberadaan pemeriksaan <em>readiness</em> dalam
<em>spec</em> berarti Pod akan tetap dijalankan tanpa menerima <em>traffic</em> apapun dan akan
mulai menerima <em>traffic</em> ketika pemeriksaan yang dilakukan mulai berhasil.
Jika kontainermu dibutuhkan untuk tetap berjalan ketika <em>loading</em> data yang besar,
<em>file</em> konfigurasi, atau melakukan migrasi ketika <em>startup</em>, maka tentukanlah pemeriksaan <em>readiness</em>.</p><p>Jika kamu ingin kontainermu dalam mematikan dirinya sendiri, kamu dapat menentukan
suatu pemeriksaan <em>readiness</em> yang melakukan pengecekan terhadap <em>endpoint</em> untuk <em>readiness</em>.
<em>endpoint</em> tersebut berbeda dengan <em>endpoint</em> untuk pengecekan <em>liveness</em>.</p><p>Perlu dicatat, jika kamu hanya ingin bisa menutup <em>request</em> ketika Pod sedang dihapus
maka kamu tidak perlu menggunakan pemeriksaan <em>readiness</em>. Dalam penghapusan, Pod akan
secara otomatis mengubah <em>state</em> dirinya menjadi <em>unready</em> tanpa peduli apakah terdapat
pemeriksaan <em>readiness</em> atau tidak. Pod tetap ada pada <em>state unready</em> selama menunggu
kontainer dalam Pod berhenti.</p><p>Untuk informasi lebih lanjut mengenai pengaturan pemeriksaan <em>liveness</em> atau <em>readiness</em>, lihat bagian
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>Konfigurasi <em>Liveness</em> dan <em>Readiness</em> <em>Probe</em></a>.</p><h2 id=status-pod-dan-kontainer>Status Pod dan Kontainer</h2><p>Untuk informasi lebih mendalam mengenai status Pod dan kontainer, silakan lihat
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>
dan
<a href=/docs/reference/generated/kubernetes-api/v1.25/#containerstatus-v1-core>ContainerStatus</a>.
Mohon diperhatikan, informasi tentang status Pod bergantung pada
<a href=/docs/reference/generated/kubernetes-api/v1.25/#containerstatus-v1-core>ContainerState</a>.</p><h2 id=state-kontainer>State Kontainer</h2><p>Ketika Pod sudah ditempatkan pada suatu node oleh scheduler, kubelet mulai membuat kontainer menggunakan <em>runtime</em> kontainer.
Ada tiga kemungkinan <em>state</em> untuk suatu kontainer, yaitu Waiting, Running, dan Terminated.
Untuk mengecek <em>state</em> suatu kontainer, kamu bisa menggunakan perintah <code>kubectl describe pod [NAMA_POD]</code>.
<em>State</em> akan ditampilkan untuk masing-masing kontainer dalam Pod tersebut.</p><ul><li><p><code>Waiting</code>: Merupakan <em>state</em> default dari kontainer. Jika <em>state</em> kontainer bukan Running atau Terminated, berarti dalam <em>Wating state</em>.
Suatu kontainer dalam Waiting <em>state</em> akan tetap menjalan operasi-operasi yang dibutuhkan, misalnya mengunduh <em>images</em>, mengaplikasikan Secrets, dsb.
Bersamaan dengan <em>state</em> ini, sebuah pesan dan alasan tentang <em>state</em> akan ditampilkan untuk memberi informasi lebih.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>State</span>:<span style=color:#bbb>          </span>Waiting<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>Reason</span>:<span style=color:#bbb>       </span>ErrImagePull<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p><code>Running</code>: Menandakan kontainer telah berjalan tanpa masalah. Setelah kontainer masuk ke <em>state</em> Running, jika terdapat <em>hook</em> <code>postStart</code> maka akan dijalankan. <em>State</em> ini juga menampilkan waktu ketika kontainer masuk ke <em>state</em> Running.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>State</span>:<span style=color:#bbb>          </span>Running<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>Started</span>:<span style=color:#bbb>      </span>Wed, 30 Jan 2019 16:46:38 +0530<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p><code>Terminated</code>: Menandakan kontainer telah menyelesaikan "tugasnya". Kontainer akan menjadi <em>state</em> ini ketika telah menyelesaikan eksekusi atau terjadi kesalahan. Terlepas dari itu, sebuah alasan dan <em>exit code</em> akan ditampilkan, bersama dengan waktu kontainer mulai dijalankan dan waktu berhenti. Sebelum kontainer masuk ke <em>state</em> Terminated, jika terdapat <code>preStop</code> <em>hook</em> maka akan dijalankan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>State</span>:<span style=color:#bbb>          </span>Terminated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Reason</span>:<span style=color:#bbb>       </span>Completed<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Exit Code</span>:<span style=color:#bbb>    </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Started</span>:<span style=color:#bbb>      </span>Wed, 30 Jan 2019 11:45:26 +0530<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Finished</span>:<span style=color:#bbb>     </span>Wed, 30 Jan 2019 11:45:26 +0530<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span></span></span></code></pre></div></li></ul><h2 id=pod-readiness-gate>Pod readiness gate</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><p>Dalam rangka menambahkan ekstensibilitas terhadap kesiapan Pod dengan menggunakan
injeksi umpan balik tambahan atau sinyal ke dalam <code>PodStatus</code>,
Kubernetes 1.11 memperkenalkan sebuah fitur bernama <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/0007-pod-ready%2B%2B.md>Pod ready++</a>.
Kamu dapat menggunakan <em>field</em> baru <code>ReadinessGate</code> dalam sebuah <code>PodSpec</code> untuk
menunjukan kondisi tambahan yang akan dievaluasi untuk kesiapan Pod. Jika Kubernetes
tidak dapat menemukan kondisi pada <em>field</em> <code>status.conditions</code> dalam suatu Pod,
maka statusnya akan secara otomatis menjadi <code>False</code>. Berikut adalah contoh pemakaiannya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readinessGates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>conditionType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready <span style=color:#bbb> </span><span style=color:#080;font-style:italic># ini adalah PodCondition yang telah tersedia</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># sebuah PodCondition tambahan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://abcd...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Kondisi Pod yang baru harus memenuhi <a href=/id/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set>format label</a> pada Kubernetes.
Sejak perintah <code>kubectl patch</code> belum mendukung perubahan status objek, kondisi Pod yang baru harus mengubah melalui aksi <code>PATCH</code> dengan menggunakan
salah satu dari <a href=/docs/reference/using-api/client-libraries/>KubeClient <em>libraries</em></a>.</p><p>Dengan diperkenalkannya kondisi Pod yang baru, sebuah Pod akan dianggap siap hanya jika memenuhi dua syarat berikut:</p><ul><li>Semua kontainer dalam Pod telah siap.</li><li>Semua kontainer yang diatur dalam <code>ReadinessGates</code> bernilai "<code>True</code>".</li></ul><p>Untuk memfasilitasi perubahan tersebut terhadap evaluasi kesiapan Pod, dibuatkan sebuah kondisi Pod baru yaitu <code>ContainerReady</code>,
untuk dapat menangani kondisi Pod <code>Ready</code> yang sudah ada.</p><p>Dalam K8s 1.11, sebagai fitur <em>alpha</em>, fitur "Pod Ready++" harus diaktifkan melalui pengaturan
<a href=/docs/reference/command-line-tools-reference/feature-gates/>fitur <em>gate</em> pada <code>PodReadinessGates</code></a>.</p><p>Dalam K8s 1.12, fitur tersebut sudah diaktifkan dari awal.</p><h2 id=aturan-menjalankan-ulang>Aturan Menjalankan Ulang</h2><p>Sebuah PodSpec memiliki <em>field</em> <code>restartPolicy</code> dengan kemungkinan nilai berupa Always, OnFailure, dan Never.
Nilai awalnya berupa Always. <code>restartPolicy</code> akan berlaku untuk semua kontainer dalam Pod.
Kontainer yang mati dan dijalankan ulang oleh kubelet akan dijalankan ulang dengan jeda waktu yang ekponensial (10s, 20s, 40s, ...)
dengan batas atas senilai lima menit. Jeda waktu ini akan diatur ulang setelah sukses berjalan selama 10 menit.
Sesuai dengan diskusi pada <a href=/docs/user-guide/pods/#durability-of-pods-or-lack-thereof>dokumen Pod</a>,
setelah masuk ke suatu node, sebuah Pod tidak akan pindah ke node lain.</p><h2 id=umur-pod>Umur Pod</h2><p>Secara umum, Pod tidak hilang sampai ada yang menghapusnya. Ini mungkin dihapus oleh orang atau pengontrol.
Satu pengecualian untuk aturan ini adalah Pod dengan <code>phase</code> bernilai Succeeded atau Failed untuk waktu
beberapa lama yang akan berakhir dan secara otomatis akan dihapus.
(diatur dalam <code>terminated-pod-gc-threshold</code> pada master)</p><p>Tiga tipe pengontrol yang tersedia yaitu:</p><ul><li><p>Menggunakan sebuah <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/>Job</a> untuk Pod yang diharapkan akan berakhir,
sebagai contoh, penghitungan dalam jumlah banyak. Jobs hanyak cocok untuk Pod dengan <code>restartPolicy</code> yang
bernilai OnFailure atau Never.</p></li><li><p>Menggunakan sebuah <a href=/id/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>,
<a href=/id/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>, atau
<a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a> untuk Pod yang tidak diharapkan untuk berakhir,
sebagai contoh, <em>web servers</em>. ReplicationControllers hanya cocok digunakan pada Pod dengan <code>restartPolicy</code>
yang bernilai Always.</p></li><li><p>Menggunakan sebuah <a href=/id/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a> untuk Pod yang akan berjalan
hanya satu untuk setiap mesin, karena menyediakan servis yang spesifik untuk suatu mesin.</p></li></ul><p>Ketiga tipe pengontrol ini memiliki sebuah PodTemplate. Direkomdasikan untuk membuat
pengontrol yang sesuai dan membiarkan ini membuat Pod, daripada membuat Pod sendiri secara langsung.
Karena Pod itu sendiri tidak tahan terhadap gagalnya suatu mesin, namun pengontrol tahan.</p><p>Jika node mati atau sambungannya terputus dari klaster, Kubernetes mengatur
<code>phase</code> dari semua Pod pada node yang mati untuk menjadi Failed.</p><h2 id=contoh>Contoh</h2><h3 id=contoh-liveness-probe-tingkat-lanjut>Contoh <em>Liveness Probe</em> tingkat lanjut</h3><p><em>Liveness probe</em> dieksekusi oleh kubelet, jadi semua permintaan akan dilakukan
di dalam <em>namespace</em> jaringan kubelet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ketika &#34;host&#34; tidak ditentukan, &#34;PodIP&#34; akan digunakan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># host: my-host</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ketika &#34;scheme&#34; tidak ditentukan, _scheme_ &#34;HTTP&#34; akan digunakan. Hanya &#34;HTTP&#34; and &#34;HTTPS&#34; yang diperbolehkan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># scheme: HTTPS</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>X-Custom-Header<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>Awesome<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=contoh-state>Contoh <em>State</em></h3><ul><li><p>Pod sedang berjalan dan memiliki sebuah kontainer. Kontainer berhenti dengan sukses.</p><ul><li>Mencatat <em>event</em> penyelesaian.</li><li>Jika nilai <code>restartPolicy</code> adalah:<ul><li>Always: Jalankan ulang kontainer; nilai <code>phase</code> Pod akan tetap Running.</li><li>OnFailure: nilai <code>phase</code> Pod akan berubah menjadi Succeeded.</li><li>Never: nilai <code>phase</code> Pod akan berubah menjadi Succeeded.</li></ul></li></ul></li><li><p>Pod sedang berjalan dan memiliki sebuah kontainer. Kontainer berhenti dengan kegagalan.</p><ul><li>Mencatat <em>event</em> kegagalan.</li><li>Jika nilai <code>restartPolicy</code> adalah:<ul><li>Always: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>OnFailure: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>Never: nilai <code>phase</code> Pod akan menjadi Failed.</li></ul></li></ul></li><li><p>Pod sedang berjalan dan memiliki dua kontainer. Kontainer pertama berhenti dengan kegagalan.</p><ul><li>Mencatat <em>event</em> kegagalan.</li><li>Jika nilai <code>restartPolicy</code> adalah:<ul><li>Always: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>OnFailure: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>Never: Tidak akan menjalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li></ul></li><li>Jika kontainer pertama tidak berjalan dan kontainer kedua berhenti:<ul><li>Mencatat <em>event</em> kegagalan.</li><li>Jika nilai <code>restartPolicy</code> adalah:<ul><li>Always: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>OnFailure: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>Never: nilai <code>phase</code> Pod akan menjadi Failed.</li></ul></li></ul></li></ul></li><li><p>Pod sedang berjalan dan memiliki satu kontainer. Kontainer berhenti karena kehabisan <em>memory</em>.</p><ul><li>Kontainer diberhentikan dengan kegagalan.</li><li>Mencatat kejadian kehabisan <em>memory</em> (OOM)</li><li>Jika nilai <code>restartPolicy</code> adalah:<ul><li>Always: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>OnFailure: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>Never: Mencatat kejadian kegagalan, nilai <code>phase</code> Pod akan menjadi Failed.</li></ul></li></ul></li><li><p>Pod sedang berjalan dan sebuah <em>disk</em> mati.</p><ul><li>Menghentikan semua kontainer.</li><li>Mencatat kejadian yang sesuai.</li><li>Nilai <code>phase</code> Pod menjadi Failed.</li><li>Jika berjalan menggunakan pengontrol, maka Pod akan dibuat ulang di tempat lain.</li></ul></li><li><p>Pod sedang berjalan, dan node mengalami <em>segmented out</em>.</p><ul><li>Node pengontrol menunggu sampai suatu batas waktu.</li><li>Node pengontrol mengisi nilai <code>phase</code> Pod menjadi Failed.</li><li>Jika berjalan menggunakan pengontrol, maka Pod akan dibuat ulang di tempat lain.</li></ul></li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Dapatkan pengalaman langsung mengenai
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>penambahan <em>handlers</em> pada kontainer <em>lifecycle events</em></a>.</p></li><li><p>Dapatkan pengalaman langsung mengenai
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>pengaturan <em>liveness</em> dan <em>readiness probes</em></a>.</p></li><li><p>Pelajari lebih lanjut mengenai <a href=/id/docs/concepts/containers/container-lifecycle-hooks/><em>lifecycle hooks</em> pada kontainer</a>.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>4 - Init Container</h1><p>Halaman ini menyediakan ikhtisar untuk Init Container, yaitu Container khusus yang dijalankan sebelum Container aplikasi dan berisi skrip peralatan atau <em>setup</em> yang tidak tersedia di dalam <em>image</em> dari Container aplikasi.</p><p>Fitur ini telah keluar dari trek Beta sejak versi 1.6. Init Container dapat dispesifikasikan di dalam PodSpec bersama dengan <em>array</em> <code>containers</code> aplikasi. Nilai anotasi <em>beta</em> akan tetap diperhitungkan dan akan menimpa nilai pada PodSpec, tetapi telah ditandai sebagai kedaluarsa pada versi 1.6 dan 1.7. Pada versi 1.8, anotasi <em>beta</em> tidak didukung lagi dan harus diganti menjadi nilai pada PodSpec.</p><h2 id=memahami-init-container>Memahami Init Container</h2><p>Sebuah <a href=/id/docs/concepts/workloads/pods/pod-overview/>Pod</a> dapat memiliki beberapa Container yang berjalan di dalamnya, dan dapat juga memiliki satu atau lebih Init Container, yang akan berjalan sebelum Container aplikasi dijalankan.</p><p>Init Container sama saja seperti Container biasa, kecuali:</p><ul><li>Mereka selalu berjalan hingga selesai.</li><li>Setiap Init Container harus selesai secara sukses sebelum Init Container berikutnya dijalankan.</li></ul><p>Jika sebuah Init Container tidak selesai secara sukses untuk sebuah Pod, Kubernetes akan mengulang kembali Pod tersebut secara terus menerus hingga Init Container selesai secara sukses. Tetapi, jika Pod tersebut memiliki nilai <code>restartPolicy</code> berupa <code>Never</code>, Pod tersebut tidak akan diulang kembali.</p><p>Untuk menspesifikasikan sebuah Container sebagai Init Container, tambahkan kolom <code>initContainers</code> pada PodSpec sebagai sebuah <em>array</em> JSON yang berisi objek dengan tipe <a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Container</a>, berdampingan dengan array <code>containers</code> aplikasi.
Status-status dari Init Container dikembalikan di kolom <code>.status.initContainerStatuses</code> sebagai sebuah <em>array</em> dari status-status Container (mirip seperti kolom <code>status.containerStatuses</code>)</p><h3 id=perbedaan-dengan-container-biasa>Perbedaan dengan Container biasa</h3><p>Init Container mendukung semua kolom dan fitur dari Container aplikasi, termasuk konfigurasi <code>limit</code> sumber daya, <code>volume</code>, dan keamanan. Tetapi, <code>request</code> dan <code>limit</code> sumber daya dari sebuah Init Container ditangani dengan cara yang sedikit berbeda, yang didokumentasikan di bagian <a href=#sumber-daya>Sumber Daya</a> di bawah. Juga, Init Container tidak mendukung <em>readiness probe</em> karena mereka harus berjalan hingga selesai sebelum Pod dapat siap.</p><p>Jika beberapa Init Container dispesifikasikan untuk sebuah Pod, Container-container tersebut akan dijalankan satu per satu secara berurutan. Setiap Init Container harus selesai secara sukses sebelum yang berikutnya dapat berjalan.
Saat semua Init Container telah berjalan hingga selesai, Kubernetes akan menginisialisasi Pod dan menjalankan Container aplikasi seperti biasa.</p><h2 id=apa-kegunaan-init-container>Apa kegunaan Init Container?</h2><p>Karena Init Container memiliki <em>image</em> yang berbeda dengan Container aplikasi, mereka memiliki beberapa kelebihan untuk kode yang berhubungan dengan dimulainya Init Container:</p><ul><li>Mereka dapat berisi dan menjalankan skrip peralatan yang tidak diinginkan untuk berada di dalam <em>image</em> Container aplikasi karena alasan keamanan.</li><li>Mereka dapat berisi skrip peralatan atau <em>setup</em> yang tidak tersedia di dalam <em>image</em> aplikasi. Misalnya, kita tidak perlu membuat <em>image</em> dengan instruksi <code>FROM</code> dari <em>image</em> lainnya hanya untuk menggunakan peralatan seperti <code>sed</code>, <code>awk</code>, <code>python</code>, atau <code>dig</code> pada saat <em>setup</em>.</li><li>Peran <em>builder</em> atau <em>deployer</em> dari <em>image</em> dapat bekerja secara independen tanpa harus digabung untuk membuat satu <em>image</em> aplikasi.</li><li>Mereka menggunakan <em>namespace</em> Linux, sehingga mereka dapat memiliki sudut pandang <em>filesystem</em> yang berbeda dengan Container aplikasi. Oleh karenanya, mereka dapat diberikan akses terhadap <code>Secret</code> yang tidak boleh diakses oleh Container aplikasi.</li><li>Mereka berjalan hingga selesai sebelum Container aplikasi manapun dimulai, sedangkan Container aplikasi dijalankan secara paralel, sehingga Init Container menyediakan cara yang mudah untuk menunda dijalankannya Container aplikasi hingga ketentuan-ketentuan yang diinginkan dipenuhi.</li></ul><h3 id=contoh-contoh>Contoh-contoh</h3><p>Berikut beberapa contoh kasus penggunaan Init Container:</p><ul><li><p>Menunggu sebuah Service untuk dibuat dengan perintah <em>shell</em> seperti:</p><pre><code>for i in {1..100}; do sleep 1; if dig myservice; then exit 0; fi; done; exit 1
</code></pre></li><li><p>Mendaftarkan suatu Pod ke sebuah peladen terpisah dari <em>downward API</em> dengan perintah seperti:</p><pre><code>`curl -X POST http://$MANAGEMENT_SERVICE_HOST:$MANAGEMENT_SERVICE_PORT/register -d 'instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)'`
</code></pre></li><li><p>Menunggu beberapa waktu sebelum menjalankan Container aplikasi dengan perintah seperti <code>sleep 60</code>.</p></li><li><p>Mengklon sebuah <em>git repository</em> ke dalam sebuah <em>volume</em>.</p></li><li><p>Menaruh nilai-nilai tertentu ke dalam sebuah <em>file</em> konfigurasi dan menjalankan peralatan <em>template</em> untuk membuat <em>file</em> konfigurasi secara dinamis untuk Container aplikasi utama. Misalnya, untuk menaruh nilai POD_IP ke dalam sebuah konfigurasi dan membuat konfigurasi aplikasi utama menggunakan Jinja.</p></li></ul><p>Contoh-contoh penggunaan yang lebih detail dapat dilihat pada <a href=/id/docs/concepts/workloads/controllers/statefulset/>dokumentasi StatefulSet</a> dan <a href=/docs/tasks/configure-pod-container/configure-pod-initialization/>petunjuk Produksi Pod</a>.</p><h3 id=menggunakan-init-container>Menggunakan Init Container</h3><p><em>File</em> YAML untuk Kubernetes 1.5 berikut menguraikan sebuah Pod sederhana yang memiliki dua buah Init Container.
Pod pertama menunggu <code>myservice</code> dan yang kedua menunggu <code>mydb</code>. Saat kedua Init Container tersebut sudah selesai, Podnya akan dijalankan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod.beta.kubernetes.io/init-containers</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;[
</span></span></span><span style=display:flex><span><span style=color:#b44>        {
</span></span></span><span style=display:flex><span><span style=color:#b44>            &#34;name&#34;: &#34;init-myservice&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>            &#34;image&#34;: &#34;busybox:1.28&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>            &#34;command&#34;: [&#39;</span>sh&#39;, &#39;-c&#39;, &#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&#34;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;name&#34;: </span><span style=color:#b44>&#34;init-mydb&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;image&#34;: </span><span style=color:#b44>&#34;busybox:1.28&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;command&#34;: </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>]<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: myapp-container
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox:1.28
</span></span></span><span style=display:flex><span><span style=color:#b44>    command: [&#39;</span>sh&#39;, &#39;-c&#39;, &#39;echo The app is running! &amp;&amp; sleep 3600&#39;]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Ada sintaksis baru pada Kubernetes 1.6, walaupun sintaksis anotasi yang lama tetap akan bekerja untuk versi 1.6 dan 1.7. Sintaksis yang baru harus digunakan untuk versi 1.8 ke atas. Deklarasi Init Container dipindahkan ke dalam <code>spec</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo The app is running! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Sintaksis versi 1.5 tetap akan bekerja pada versi 1.6 dan 1.7, tetapi kami menyarankan untuk menggunakan sintaksis versi 1.6. Pada Kubernetes 1.6, Init Container dijadikan sebagai sebuah kolom di dalam API Kubernetes. Anotasi <em>beta</em> tetap akan diperhitungkan pada versi 1.6 dan 1.7, tetapi tidak didukung lagi pada versi 1.8 ke atas.</p><p><em>File</em> YAML di bawah menguraikan Service <code>mydb</code> dan <code>myservice</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Pod ini dapat dijalankan dan di-<em>debug</em> dengan menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f myapp.yaml
</span></span></code></pre></div><pre tabindex=0><code>pod/myapp-pod created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><pre tabindex=0><code>NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe -f myapp.yaml
</span></span></code></pre></div><pre tabindex=0><code>Name:          myapp-pod
Namespace:     default
[...]
Labels:        app=myapp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># Memeriksa Init Container pertama</span>
</span></span><span style=display:flex><span>kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># Memeriksa Init Container kedua</span>
</span></span></code></pre></div><p>Saat kita menjalankan Service <code>mydb</code> dan <code>myservice</code>, kita dapat melihat Init Container telah selesai dan <code>myapp-pod</code> pun dibuat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f services.yaml
</span></span></code></pre></div><pre tabindex=0><code>service/myservice created
service/mydb created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span><span style=display:flex><span>NAME        READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>myapp-pod   1/1       Running   <span style=color:#666>0</span>          9m
</span></span></code></pre></div><p>Contoh ini sangat sederhana, tetapi dapat memberikan sedikit petunjuk bagi kamu untuk membuat Init Container sendiri.</p><h2 id=perilaku-mendetail>Perilaku mendetail</h2><p>Saat dimulainya sebuah Pod, Init Container dijalankan secara berurutan, setelah jaringan dan <em>volume</em> telah diinisialisasi. Setiap Init Container harus selesai dan keluar secara berhasil sebelum yang berikutnya dijalankan. Jika ada Init Container yang gagal dijalankan atau keluar secara gagal, dia akan diulang kembali sesuai dengan <code>restartPolicy</code> yang dimiliki Pod. Tetapi, jika <code>restartPolicy</code> Pod disetel dengan nilai <code>Always</code>, Init Container akan menggunakan strategi <code>RestartPolicy</code> <code>OnFailure</code>.</p><p>Sebuah Pod tidak dapat masuk ke status <code>Ready</code> hingga semua Init Container berhasil selesai. <em>Port</em> di sebuah Init Container tidak diagregasikan di dalam sebuah Service. Sebuah Pod yang sedang diinisalisasikan akan masuk ke dalam status <code>Pending</code>, tetapi akan memiliki kondisi <code>Initialized</code> yang disetel menjadi <code>true</code>.</p><p>Jika sebuah Pod diulang <a href=#alasan-pod-diulang-kembali>kembali</a>, semua Init Container harus dijalankan kembali.</p><p>Perubahan pada spesifikasi Init Container dibatasi hanya pada kolom <code>image</code> pada Init Container. Mengganti kolom <code>image</code> sebuah Init Container sama dengan mengulang kembali Pod tersebut.</p><p>Karena Init Container dapat diulang kembali, dicoba ulang, atau dijalankan ulang, Init Container sebaiknya bersifat <em>idempotent</em>. Khususnya, kode yang menulis ke dalam <em>file</em> pada <code>EmptyDir</code> sebaiknya dipersiapkan untuk menangani kemungkinan jika <em>file</em> keluaran yang diharapkan sudah ada di dalam <code>EmptyDir</code> tersebut.</p><p>Init Container memiliki semua kolom yang dimiliki oleh Container aplikasi. Tetapi, Kubernetes melarang penggunaan <code>readinessProbe</code> karena Init Container tidak dapat mendefinisikan/menggunakan <em>readiness probe</em> setelah selesai/keluar secara berhasil. Hal ini dipaksakan saat proses validasi.</p><p>Gunakan <code>activeDeadlineSeconds</code> pada Pod dan <code>livenessProbe</code> pada Container untuk mencegah Init Container gagal terus menerus. Nilai <code>activeDeadlineSeconds</code> berlaku juga terhadap Init Container.</p><p>Nama setiap Container aplikasi dan Init Container pada sebuah Pod haruslah unik; Kesalahan validasi akan terjadi jika ada Container atau Init Container yang memiliki nama yang sama.</p><h3 id=sumber-daya>Sumber Daya</h3><p>Karena eksekusi Init Container yang berurutan, aturan-aturan untuk sumber daya berlaku sebagai berikut:</p><ul><li>Yang tertinggi antara <code>request</code> atau <code>limit</code> sumber daya yang didefinisikan pada <strong>semua Init Container</strong> adalah <strong><code>request</code>/<code>limit</code> inisialisasi yang berlaku</strong>.</li><li><code>request</code>/<code>limit</code> sumber daya Pod yang berlaku adalah yang paling besar diantara:<ul><li>Jumah <code>request</code>/<code>limit</code> semua Container aplikasi untuk suatu sumber daya.</li><li><code>request</code>/<code>limit</code> inisialisasi yang berlaku untuk suatu sumber daya.</li></ul></li><li>Penjadwalan dilakukan berdasarkan <code>request</code>/<code>limit</code> (Pod) yang berlaku, yang berarti bahwa Init Container dapat mengambil sumber daya inisialisasi yang tidak digunakan selama umur Pod tersebut.</li><li><strong>Tingkat QoS yang berlaku</strong> milik Pod adalah sama dengan tingkat QoS untuk Init Container dan Container aplikasi.</li></ul><p><code>ResourceQuota</code> dan <code>limitedResources</code> diberlakukan berdasarkan <code>request</code> dan <code>limit</code> Pod yang berlaku.</p><p>Cgroup pada tingat Pod didasarkan pada <code>request</code> dan <code>limit</code> Pod yang berlaku, sama dengan <em>scheduler</em>.</p><h3 id=alasan-pod-diulang-kembali>Alasan Pod diulang kembali</h3><p>Pod dapat diulang kembali, yang berakibat pada diulangnya eksekusi Init Container, diakibatkan oleh beberapa alasan berikut:</p><ul><li>Seorang pengguna memperbarui <code>PodSpec</code>, mengakibatkan <code>image</code> Init Container berubah. Perubahan apapun pada <code>image</code> Init Container akan mengulang kembali Pod tersebut. Perubahan pada <code>image</code> Container aplikasi hanya mengulang kembali Container aplikasi yang bersangkutan.</li><li>Infrastruktur Container Pod diulang kembali. Hal ini jarang terjadi, dan hanya dapat dilakukan oleh seseorang yang memiliki akses <em>root</em> pada <em>node</em> yang bersangkutan.</li><li>Semua Container di dalam Pod diterminasi, dengan nilai <code>restartPolicy</code> yang disetel sebagai <code>Always</code>, memaksa pengulangan kembali, dan catatan selesainya Init Container telah hilang karena <em>garbage collection</em>.</li></ul><h2 id=dukungan-dan-kompatibilitas>Dukungan dan kompatibilitas</h2><p>Sebuah klaster dengan versi Apiserver 1.6.0 ke atas mendukung Init Container melalui kolom <code>.spec.initContainers</code>. Versi-versi sebelumnya mendukung Init Container melalui anotasi <em>alpha</em> atau <em>beta</em>. Kolom <code>.spec.initContainers</code> juga diduplikasikan dalam bentuk anotasi <em>alpha</em> dan <em>beta</em> agar Kubelet versi 1.3.0 ke atas dapat menjalankan Init Container, dan agar Apiserver versi 1.6 dapat dengan aman dikembalikan ke versi 1.5.x tanpa kehilangan fungsionalitas Pod-pod yang telah dibuat sebelumnya.</p><p>Pada Apiserver dan Kubelet versi 1.8.0 ke atas, dukungan untuk anotasi <em>alpha</em> dan <em>beta</em> telah dihapus, sehingga dibutuhkan konversi (manual) dari anotasi yang telah kedaluwarsa tersebut ke dalam bentuk kolom <code>.spec.initContainers</code>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container>Membuat Pod yang memiliki Init Container</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c8d62295ca703fdcef1aaf89fb4c916a>5 - Batasan Persebaran Topologi Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Kamu dapat menggunakan batasan perseberan topologi (<em>topology spread constraints</em>)
untuk mengatur bagaimana <a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> akan disebarkan
pada klaster yang ditetapkan sebagai <em>failure-domains</em>, seperti wilayah, zona, Node dan domain
topologi yang ditentukan oleh pengguna. Ini akan membantu untuk mencapai ketersediaan yang tinggi
dan juga penggunaan sumber daya yang efisien.</p><h2 id=persyaratan>Persyaratan</h2><h3 id=mengaktifkan-gerbang-fitur>Mengaktifkan Gerbang Fitur</h3><p><a href=/docs/reference/command-line-tools-reference/feature-gates/>Gerbang fitur (<em>feature gate</em>)</a>
<code>EvenPodsSpread</code> harus diaktifkan untuk
<a class=glossary-tooltip title='Komponen control plane yang mengekspos API Kubernetes. Merupakan front-end dari control plane Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API Server'>API Server</a> <strong>dan</strong>
<a class=glossary-tooltip title='Komponen control plane yang bertugas mengamati Pod baru yang belum ditempatkan di node manapun dan kemudian memilihkan node di mana Pod baru tersebut akan dijalankan.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label='penjadwal (_scheduler_)'>penjadwal (_scheduler_)</a>.</p><h3 id=label-node>Label Node</h3><p>Batasan persebaran topologi bergantung dengan label pada Node untuk menentukan
domain topologi yang memenuhi untuk semua Node. Misalnya saja, sebuah Node bisa memiliki
label sebagai berikut: <code>node=node1,zone=us-east-1a,region=us-east-1</code></p><p>Misalkan kamu memiliki klaster dengan 4 Node dengan label sebagai berikut:</p><pre tabindex=0><code>NAME    STATUS   ROLES    AGE     VERSION   LABELS
node1   Ready    &lt;none&gt;   4m26s   v1.16.0   node=node1,zone=zoneA
node2   Ready    &lt;none&gt;   3m58s   v1.16.0   node=node2,zone=zoneA
node3   Ready    &lt;none&gt;   3m17s   v1.16.0   node=node3,zone=zoneB
node4   Ready    &lt;none&gt;   2m43s   v1.16.0   node=node4,zone=zoneB
</code></pre><p>Maka klaster tersebut secara logika akan dilihat sebagai berikut:</p><pre tabindex=0><code>+---------------+---------------+
|     zoneA     |     zoneB     |
+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+
</code></pre><p>Tanpa harus memberi label secara manual, kamu dapat menggunakan [label ternama]
(/docs/reference/kubernetes-api/labels-annotations-taints/) yang terbuat dan terkumpulkan
secara otomatis pada kebanyakan klaster.</p><h2 id=batasan-persebaran-untuk-pod>Batasan Persebaran untuk Pod</h2><h3 id=api>API</h3><p><em>Field</em> <code>pod.spec.topologySpreadConstraints</code> diperkenalkan pada versi 1.16 sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span>&lt;integer&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>minDomains</span>:<span style=color:#bbb> </span>&lt;integer&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>&lt;string&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>&lt;string&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb> </span>&lt;object&gt;<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kamu dapat mendefinisikan satu atau lebih <code>topologySpreadConstraint</code> untuk menginstruksikan
kube-scheduler mengenai cara peletakan tiap Pod baru dengan menggunakan kondisi Pod yang
sudah ada dalam klaster kamu. <em>Field</em> yang ada adalah:</p><ul><li><strong>maxSkew</strong> menentukan batasan yang menandakan Pod tidak tersebar secara merata.
Ini merupakan nilai maksimal dari selisih jumlah Pod yang sama untuk setiap 2 domain topologi
yang sama. Nilai ini harus lebih dari 0.</li><li><strong>topologyKey</strong> adalah kunci dari label Node. Jika terdapat dua Node memiliki label dengan
kunci ini dan memiliki nilai yang identik untuk label tersebut, maka penjadwal akan menganggap
kedua Noode dalam topologi yang sama. Penjadwal akan mencoba untuk menyeimbangkan jumlah Pod
dalam setiap domain topologi.</li><li><strong>whenUnsatisfiable</strong> mengindikasikan cara menangani Pod yang tidak memenuhi batasan persebaran:<ul><li><code>DoNotSchedule</code> (<em>default</em>) memberitahukan penjadwal untuk tidak menjadwalkan Pod tersebut.</li><li><code>ScheduleAnyway</code> memberitahukan penjadwal untuk tetap menjadwalkan Pod namun tetap menjaga ketidakseimbangan Node sekecil mungkin.</li></ul></li><li><strong>labelSelector</strong> digunakan untuk mencari Pod yang sesuai. Pod dengan label yang sama dengan ini akan dihitung untuk menentukan jumlah Pod dalam domain topologi yang sesuai. Silakan baca <a href=/id/docs/concepts/overview/working-with-objects/labels/#selektor-label>Label dan Selector</a> untuk lebih detailnya.</li></ul><p>Kamu juga bisa membaca lebih detail mengenai <em>field</em> ini dengan menjalankan perintah
<code>kubectl explain Pod.spec.topologySpreadConstraints</code>.</p><h3 id=contoh-satu-topologyspreadconstraint>Contoh: Satu TopologySpreadConstraint</h3><p>Misalkan kamu memiliki klaster dengan 4 Node dimana 3 Pod berlabel <code>foo:bar</code> terdapat pada node1,
node2 dan node3 (<code>P</code> merepresentasikan Pod):</p><pre tabindex=0><code>+---------------+---------------+
|     zoneA     |     zoneB     |
+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+
|   P   |   P   |   P   |       |
+-------+-------+-------+-------+
</code></pre><p>Jika kita ingin Pod baru akan disebar secara merata berdasarkan Pod yang telah ada pada semua zona,
maka <em>spec</em> bernilai sebagai berikut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/topology-spread-constraints/one-constraint.yaml download=pods/topology-spread-constraints/one-constraint.yaml><code>pods/topology-spread-constraints/one-constraint.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-topology-spread-constraints-one-constraint-yaml")' title="Copy pods/topology-spread-constraints/one-constraint.yaml to clipboard"></img></div><div class=includecode id=pods-topology-spread-constraints-one-constraint-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</span></span></code></pre></div></div></div><p><code>topologyKey: zone</code> berarti persebaran merata hanya akan digunakan pada Node dengan pasangan label
"zone: <nilai apapun>". <code>whenUnsatisfiable: DoNotSchedule</code> memberitahukan penjadwal untuk membiarkan
tetap ditunda jika Pod yang baru tidak memenuhi batasan yang diterapkan.</p><p>Jika penjadwal menempatkan Pod baru pada "zoneA", persebaran Pod akan menjadi [3, 1], menjadikan
ketidakseimbangan menjadi bernilai 2 (3 - 1), yang mana akan melanggar batasan <code>maxSkew: 1</code>.
Dalam contoh ini, Pod baru hanya dapat ditempatkan pada "zoneB":</p><pre tabindex=0><code>+---------------+---------------+      +---------------+---------------+
|     zoneA     |     zoneB     |      |     zoneA     |     zoneB     |
+-------+-------+-------+-------+      +-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |  OR  | node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+      +-------+-------+-------+-------+
|   P   |   P   |   P   |   P   |      |   P   |   P   |  P P  |       |
+-------+-------+-------+-------+      +-------+-------+-------+-------+
</code></pre><p>Kamu dapat mengatur spesifikasi Pod untuk memenuhi beberapa persyaratan berikut:</p><ul><li>Ubah nilai <code>maxSkew</code> menjadi lebih besar, misal "2", sehingga Pod baru dapat ditempatkan pada "zoneA".</li><li>Ubah nilai <code>topologyKey</code> menjadi "node" agar Pod disebarkan secara merata pada semua Node, bukan zona. Pada contoh di atas, jika <code>maxSkew</code> tetap bernilai "1", maka Pod baru hanya akan ditempatkan pada "node4".</li><li>Ubah nilai <code>whenUnsatisfiable: DoNotSchedule</code> menjadi <code>whenUnsatisfiable: ScheduleAnyway</code> untuk
menjamin agar semua Pod baru akan tetap dijadwalkan (misalkan saja API penjadwalan lain tetap
terpenuhi). Namun, ini lebih suka ditempatkan pada domain topologi yang memiliki lebih sedikit
Pod yang sesuai. (Harap diperhatikan bahwa preferensi ini digabungkan bersama dengan prioritas
penjadwalan internal yang lain, seperti rasio penggunaan sumber daya, dan lain sebagainya.)</li></ul><h3 id=contoh-beberapa-topologyspreadconstraint>Contoh: Beberapa TopologySpreadConstraint</h3><p>Ini dibuat berdasarkan contoh sebelumnya. Misalkan kamu memiliki klaster dengan 4 Node dengan
3 Pod berlabel <code>foo:bar</code> yang ditempatkan pada node1, node2 dan node3. (<code>P</code> merepresentasikan Pod):</p><pre tabindex=0><code>+---------------+---------------+
|     zoneA     |     zoneB     |
+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+
|   P   |   P   |   P   |       |
+-------+-------+-------+-------+
</code></pre><p>Kamu dapat menggunakan 2 TopologySpreadConstraint untuk mengatur persebaran Pod pada zona dan Node:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/topology-spread-constraints/two-constraints.yaml download=pods/topology-spread-constraints/two-constraints.yaml><code>pods/topology-spread-constraints/two-constraints.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-topology-spread-constraints-two-constraints-yaml")' title="Copy pods/topology-spread-constraints/two-constraints.yaml to clipboard"></img></div><div class=includecode id=pods-topology-spread-constraints-two-constraints-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>node<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</span></span></code></pre></div></div></div><p>Dalam contoh ini, untuk memenuhi batasan pertama, Pod yang baru hanya akan ditempatkan pada "zoneB",
sedangkan untuk batasan kedua, Pod yang baru hanya akan ditempatkan pada "node4". Maka hasil dari
2 batasan ini akan digunakan (<em>AND</em>), sehingga opsi untuk menempatkan Pod hanya pada "node4".</p><p>Beberapa batasan dapat berujung pada konflik. Misalnya saja kamu memiliki klaster dengan 3 Node
pada 2 zona berbeda:</p><pre tabindex=0><code>+---------------+-------+
|     zoneA     | zoneB |
+-------+-------+-------+
| node1 | node2 | node3 |
+-------+-------+-------+
|  P P  |   P   |  P P  |
+-------+-------+-------+
</code></pre><p>Jika kamu menerapkan "two-constraints.yaml" pada klaster ini, kamu akan mendapatkan "mypod" tetap
dalam kondisi <code>Pending</code>. Ini dikarenakan oleh: untuk memenuhi batasan pertama, "mypod" hanya dapat
ditempatkan pada "zoneB", sedangkan untuk batasan kedua, "mypod" hanya dapat ditempatkan pada
"node2". Tidak ada hasil penggabungan dari "zoneB" dan "node2".</p><p>Untuk mengatasi situasi ini, kamu bisa menambahkan nilai <code>maxSkew</code> atau mengubah salah satu dari
batasan untuk menggunakan <code>whenUnsatisfiable: ScheduleAnyway</code>.</p><h3 id=konvensi>Konvensi</h3><p>Ada beberapa konvensi implisit yang perlu diperhatikan di sini:</p><ul><li><p>Hanya Pod dengan Namespace yang sama dengan Pod baru yang bisa menjadi kandidat yang cocok.</p></li><li><p>Node tanpa memiliki <code>topologySpreadConstraints[*].topologyKey</code> akan dilewatkan. Ini berarti:</p><ol><li>Pod yang ditempatkan pada Node tersebut tidak berpengaruh pada perhitungan <code>maxSkew</code>. Dalam contoh di atas, misalkan "node1" tidak memiliki label "zone", maka kedua Pod tidak diperhitungkan dan menyebabkan Pod yang baru akan dijadwalkan masuk ke "zoneA".</li><li>Pod yang baru tidak memiliki kesempatan untuk dijadwalkan ke Node tersebut, pada contoh di atas, misalkan terdapat "node5" dengan label <code>{zone-typo: zoneC}</code> bergabung dalam klaster, Node ini akan dilewatkan karena tidak memiliki label dengan kunci "zone".</li></ol></li><li><p>Harap diperhatikan mengenai hal yang terjadi jika nilai <code>topologySpreadConstraints[*].labelSelector</code> pada Pod yang baru tidak sesuai dengan labelnya.
Pada contoh di atas, jika kita menghapus label pada Pod yang baru, maka Pod akan tetap ditempatkan
pada "zoneB" karena batasan yang ada masih terpenuhi. Namun, setelah ditempatkan, nilai
ketidakseimbangan pada klaster masih tetap tidak berubah, zoneA tetap memiliki 2 Pod dengan label
{foo:bar} dan zoneB memiliki 1 Pod dengan label {foo:bar}. Jadi jika ini tidak yang kamu harapkan,
kami menyarankan nilai dari <code>topologySpreadConstraints[*].labelSelector</code> disamakan dengan labelnya.</p></li><li><p>Jika Pod yang baru memiliki <code>spec.nodeSelector</code> atau <code>spec.affinity.nodeAffinity</code>, Node yang tidak
sesuai dengan nilai tersebut akan dilewatkan.</p><p>Misalkan kamu memiliki klaster dengan 5 Node dari zoneA sampai zoneC:</p><pre tabindex=0><code>+---------------+---------------+-------+
|     zoneA     |     zoneB     | zoneC |
+-------+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 | node5 |
+-------+-------+-------+-------+-------+
|   P   |   P   |   P   |       |       |
+-------+-------+-------+-------+-------+
</code></pre><p>dan kamu mengetahui bahwa "zoneC" harus tidak diperhitungkan. Dalam kasus ini, kamu dapat membuat
berkas yaml seperti di bawah, jadi "mypod" akan ditempatkan pada "zoneB", bukan "zoneC".
Demikian juga <code>spec.nodeSelector</code> akan digunakan.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml download=pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml><code>pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-topology-spread-constraints-one-constraint-with-nodeaffinity-yaml")' title="Copy pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml to clipboard"></img></div><div class=includecode id=pods-topology-spread-constraints-one-constraint-with-nodeaffinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>NotIn<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- zoneC<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</span></span></code></pre></div></div></div></li></ul><h3 id=batasan-default-pada-tingkat-klaster>Batasan <em>default</em> pada tingkat klaster</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [alpha]</code></div><p>Ini memungkinkan untuk mengatur batasan persebaran topologi bawaan untuk klaster.
Batasan persebaran topologi bawaan akan digunakan pada Pod jika dan hanya jika:</p><ul><li>Hal ini tidak mendefinisikan batasan apapun pada <code>.spec.topologySpreadConstraints</code>.</li><li>Hal ini milik sebuah Service, ReplicationController, ReplicaSet atau StatefulSet.</li></ul><p>Batasan bawaan akan diatur sebagai bagian dari argumen pada <em>plugin</em> <code>PodTopologySpread</code>
di dalam sebuah <a href=/docs/reference/scheduling/profiles>profil penjadwalan</a>.
Batasan dispesifikasikan dengan <a href=#api>API yang sama dengan di atas</a>, kecuali bagian <code>labelSelector</code>
harus kosong. <em>selector</em> akan dihitung dari Service, ReplicationController, ReplicaSet atau
StatefulSet yang dimiliki oleh Pod tersebut.</p><p>Sebuah contoh konfigurasi sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1alpha2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodTopologySpread<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>defaultConstraints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>ScheduleAnyway<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Nilai yang dihasilkan oleh batasan penjadwalan bawaan mungkin akan konflik dengan
nilai yang dihasilkan oleh
<a href=/docs/reference/scheduling/profiles/#scheduling-plugins><code>DefaultPodTopologySpread</code> plugin</a>.
Direkomendasikan untuk kamu menonaktifkan <em>plugin</em> ini dalam profil penjadwalan ketika
menggunakan batasan <em>default</em> untuk <code>PodTopologySpread</code>.</div><h2 id=perbandingan-dengan-podaffinity-podantiaffinity>Perbandingan dengan PodAffinity/PodAntiAffinity</h2><p>Di Kubernetes, arahan yang terkait dengan "Afinitas" mengontrol bagaimana Pod dijadwalkan -
lebih terkumpul atau lebih tersebar.</p><ul><li>Untuk <code>PodAffinity</code>, kamu dapat mencoba mengumpulkan beberapa Pod ke dalam suatu
domain topologi yang memenuhi syarat.</li><li>Untuk <code>PodAntiAffinity</code>, hanya satu Pod yang dalam dijadwalkan pada sebuah domain topologi.</li></ul><p>Fitur "EvenPodsSpread" memberikan opsi fleksibilas untuk mendistribusikan Pod secara merata
pada domain topologi yang berbeda, untuk meraih ketersediaan yang tinggi atau menghemat biaya.
Ini juga dapat membantu saat perbaruan bergilir dan menaikan jumlah replika dengan lancar.
Silakan baca <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20190221-even-pods-spreading.md#motivation>motivasi</a> untuk lebih detail.</p><h2 id=limitasi-yang-diketahui>Limitasi yang diketahui</h2><p>Pada versi 1.18, dimana fitur ini masih Beta, beberapa limitasi yang sudah diketahui:</p><ul><li>Pengurangan jumlah Deployment akan membuat ketidakseimbangan pada persebaran Pod.</li><li>Pod yang cocok pada <em>tainted</em> Node akan dihargai. Lihat <a href=https://github.com/kubernetes/kubernetes/issues/80921>Issue 80921</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4e9b9cbc9776b12e7335c53da377c9c8>6 - Pod Preset</h1><p>Halaman ini menyajikan gambaran umum tentang PodPreset, yang merupakan objek untuk memasukkan informasi tertentu ke dalam Pod pada saat waktu penciptaan. Informasi dapat berupa <em>secret</em>, <em>volume</em>, <em>volume mount</em>, dan variabel <em>environment</em>.</p><h2 id=memahami-pod-preset>Memahami Pod Preset</h2><hr><p>Sebuah <code>Pod Preset</code> adalah sebuah <em>resource</em> API untuk memasukkan kebutuhan <em>runtime</em> tambahan ke dalam sebuah Pod pada saat waktu penciptaan. Kamu akan menggunakan <em>label selector</em> untuk menunjuk Pod dimana Pod Preset diterapkan.</p><p>Menggunakan sebuah Pod Preset memungkinkan pembuat templat pod untuk tidak menyediakan secara eksplisit semua informasi untuk setiap pod. Dengan demikian, pembuat templat pod yang mengkonsumsi sebuah <em>service</em> spesifik tidak perlu tahu semua detail-detail tentang <em>service</em> tersebut.</p><p>Untuk informasi lebih lanjut mengenai latar belakang lihat <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/service-catalog/pod-preset.md>proposal desain untuk PodPreset</a>.</p><h2 id=bagaimana-cara-kerja-pod-preset>Bagaimana Cara Kerja Pod Preset</h2><hr><p>Kubernetes menyediakan sebuah <em>admission controller</em> (<code>PodPreset</code>) dimana, ketika diaktifkan, PodPreset diterapkan kepada permintaan penciptaan Pod yang akan datang. Ketika sebuah penciptaan Pod terjadi, sistem melakukan hal-hal berikut:</p><ol><li>Mengambil semua <code>PodPreset</code> yang tersedia untuk digunakan.</li><li>Cek jika <em>label selector</em> dari salah satu <code>PodPreset</code> cocok dengan <em>label</em> pada pod yang sedang diciptakan.</li><li>Usaha untuk menggabungkan berbagai <em>resource</em> didefinisikan oleh <code>PodPreset</code> ke dalam Pod yang sedang diciptakan.</li><li>Ketika terjadi galat, lempar sebuah <em>event</em> yang mendokumentasikan galat penggabungan dalam pod, dan membuat pod tanpa salah satu <em>resource</em> dari <code>PodPreset</code>.</li><li>Anotasikan hasil spesifikasi Pod yang telah dimodifikasi untuk menunjukkan bahwa Pod telah dimodifikasi oleh sebuah PodPreset. Anotasi berupa <code>podpreset.admission.kubernetes.io/podpreset-&lt;nama pod-preset>: "&lt;versi resource>"</code>.</li></ol><p>Tiap Pod akan bisa dipasangkan oleh nol atau lebih PodPreset; dan tiap PodPreset bisa diterapkan ke nol atau lebih Pod. Ketika sebuah PodPreset diterapkan ke satu atau lebih Pod, Kubernetes memodifikasi Pod Spec. Untuk perubahan terhadap <code>Env</code>,<code>EnvFrom</code>, dan <code>VolumeMount</code>, Kubernetes memodifikasi spesifikasi kontainer untuk semua kontainer di dalam Pod; Untuk perubahan terhadap <code>Volume</code>, Kubernetes memodifikasi Pod Spec.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah Pod Preset mampu memodifikasi kolom <code>.spec.containers</code> pada sebuah Pod Spec jika sesuai. Tidak ada definisi resource dari Pod Preset yang akan diterapkan kepada kolom <code>initContainer</code>.</div><h3 id=menonaktifkan-pod-preset-untuk-sebuah-pod-spesifik>Menonaktifkan Pod Preset untuk sebuah Pod Spesifik</h3><p>Mungkin akan ada keadaan dimana kamu menginginkan sebuah Pod tidak bisa diubah oleh sebuah mutasi PodPreset. Pada kasus ini, kamu bisa menambahkan sebuah anotasi pada Pod Spec dalam bentuk: <code>podpreset.admission.kubernetes.io/exclude: "true"</code>.</p><h2 id=mengaktifkan-pod-preset>Mengaktifkan Pod Preset</h2><hr><p>Dalam rangka untuk menggunakan Pod Preset di dalam klaster kamu, kamu harus memastikan hal berikut:</p><ol><li><p>Kamu telah mengaktifkan tipe API <code>settings.k8s.io/v1alpha1/podpreset</code>. Sebagai contoh, ini bisa dilakukan dengan menambahkan <code>settings.k8s.io/v1alpha1=true</code> di dalam opsi <code>--runtime-config</code> untuk API <em>server</em>. Dalam <em>minikube</em> tambahkan argumen berikut <code>--extra-config=apiserver.runtime-config=settings.k8s.io/v1alpha1=true</code> saat menginisialisasi klaster.</p></li><li><p>Kamu telah mengaktifkan <em>admission controller</em> dari <code>PodPreset</code>. Salah satu cara untuk melakukannya adalah dengan menambahkan <code>PodPreset</code> di dalam nilai opsi <code>--enable-admission-plugins</code> yang dispesifikasikan untuk API <em>server</em>. Dalam <em>minikube</em> tambahkan argumen berikut</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--extra-config<span style=color:#666>=</span>apiserver.enable-admission-plugins<span style=color:#666>=</span>NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset
</span></span></code></pre></div><p>saat menginisialisasi klaster.</p></li><li><p>Kamu telah membuat objek <code>PodPreset</code> pada <em>namespace</em> yang kamu gunakan dengan cara mendefinisikan Pod Preset.</p></li></ol><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/concepts/workloads/pods/pod/#injecting-data-into-a-pod-using-podpreset.md>Memasukkan data ke dalam sebuah Pod dengan PodPreset</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4aaf43c715cd764bc8ed4436f3537e68>7 - Disrupsi</h1><p>Petunjuk ini ditujukan pada pemilik aplikasi yang meninginkan aplikasinya memiliki ketersediaan yang tinggi, sehingga butuh untuk mengerti jenis-jenis Disrupsi yang dapat terjadi pada Pod-pod.</p><p>Petunjuk ini juga ditujukan pada administrator klaster yang ingin melakukan berbagai tindakan otomasi pada klaster, seperti pembaruan dan <em>autoscaling</em> klaster.</p><h2 id=disrupsi-yang-disengaja-dan-tidak-disengaja>Disrupsi yang Disengaja dan Tidak Disengaja</h2><p>Pod-pod tidak akan terhapus sampai sesuatu (orang ataupun <em>pengendali</em>) menghancurkan mereka atau ada kesalahan perangkat keras maupun perangkat lunak yang tidak dapat dihindari.</p><p>Kita menyebut kasus-kasus yang tidak dapat dihindari sebagai <strong>disrupsi yang tidak disengaja</strong> terhadap aplikasi. Beberapa contohnya adalah sebagai berikut:</p><ul><li>Kesalahan perangkat keras pada mesin yang menjalankan Node</li><li>Administrator klaster menghapus <em>virtual machine</em> secara tidak sengaja</li><li>Kesalahan pada penyedia layanan <em>cloud</em> yang mengakibatkan terhapusnya <em>virtual machine</em></li><li>Sebuah <em>kernel panic</em></li><li>Node menghilang dari klaster karena partisi jaringan klaster</li><li>Pod mengalami <em>eviction</em> karena Node <a href=/docs/tasks/administer-cluster/out-of-resource>kehabisan sumber daya</a></li></ul><p>Dengan pengecualian pada kondisi kehabisan sumber daya, kondisi-kondisi tersebut pada umumnya diketahui oleh kebanyakan pengguna karena kondisi-kondisi tersebut tidak spesifik pada Kubernetes saja.</p><p>Kita menyebut kasus-kasus lainnya sebagai <strong>disrupsi yang disengaja</strong>. Hal ini termasuk tindakan yang dilakukan oleh pemilik aplikasi atau yang dilakukan oleh administrator klaster. Pemilik aplikasi umumnya melakukan hal-hal berikut:</p><ul><li>Menghapus Deployment atau pengendali yang mengatur Pod</li><li>Memperbarui templat Pod yang menyebabkan pengulangan kembali/<em>restart</em></li><li>Menghapus Pod secara langsung</li></ul><p>Administrator klaster umumnya melakukan hal-hal berikut:</p><ul><li><a href=/docs/tasks/administer-cluster/safely-drain-node/>Melakukan <em>drain</em> terhadap Node</a> untuk perbaikan atau pembaruan.</li><li>Melakukan <em>drain</em> terhadap sebuah node dari klaster untuk memperkecil ukuran klaster (untuk lebih lanjutnya, pelajari <a href=/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaler><em>Autoscaling</em> klaster</a>).</li><li>Menghapus sebuah Pod dari node untuk memuat Pod lain ke node tersebut.</li></ul><p>Tindakan-tindakan tersebut dapat dilakukan secara langsung oleh administrator klaster, atau oleh alat otomasi yang dijalankan oleh administrator klaster, atau oleh penyedia layanan Kubernetes kamu.</p><p>Tanyakan administrator klaster atau penyedia layanan <em>cloud</em> kamu, atau lihatlah dokumentasi penyedia layanan Kubernetes kamu untuk mengetahui bila ada sumber-sumber yang berpotensi mengakibatkan disrupsi yang disengaja yang ada pada klastermu. Jika tidak ada, kamu bisa melewatkan pembuatan <em>PodDisruptionBudget</em></p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Tidak semua disrupsi yang disengaja dibatasi oleh Pod Disruption Budget. Contohnya, menghapus Deployment atau Pod dapat mengabaikan PodDisruptionBudget.</div><h2 id=mengatasi-disrupsi>Mengatasi Disrupsi</h2><p>Berikut beberapa cara untuk mengatasi disrupsi yang tidak disengaja:</p><ul><li>Pastikan Pod-pod kamu <a href=/docs/tasks/configure-Pod-container/assign-cpu-ram-container>merinci permintaan sumber daya klaster</a> yang dibutuhkan.</li><li>Replikasikan aplikasimu jika membutuhkan ketersediaan yang tinggi. (Pelajari tentang menjalankan aplikasi
<a href=/docs/tasks/run-application/run-stateless-application-deployment/><em>stateless</em></a> dan <a href=/docs/tasks/run-application/run-replicated-stateful-application/><em>stateful</em></a>).</li><li>Untuk mencapai ketersediaan yang bahkan lebih tinggi lagi saat mereplikasikan aplikasi, sebarkanlah Pod-pod kamu di rak-rak pada <em>data center</em> (menggunakan <a href=/docs/user-guide/node-selection/#inter-Pod-affinity-and-anti-affinity-beta-feature><em>anti-affinity</em></a>) atau di seluruh zona (jika kamu menggunakan <a href=/docs/setup/multiple-zones>klaster pada beberapa zona</a>).</li></ul><p>Frekuensi disrupsi yang disengaja dapat berubah-ubah. Pada klaster Kubernetes yang dasar, tidak ada disrupsi yang disengaja sama sekali. Tetapi, administrator klaster atau penyedia layanan Kubernetes kamu mungkin saja menjalankan beberapa servis tambahan yang dapat mengakibatkan disrupsi yang disengaja. Misalnya, memperbarui perangkat lunak pada node yang dapat mengakibatkan disrupsi yang disengaja. Selain itu, beberapa implementasi <em>autoscaling</em> klaster (atau node) dapat mengakibatkan disrupsi yang disengaja untuk merapikan dan memadatkan node-node pada klaster.
Administrator klaster atau penyedia layanan Kubernetes kamu perlu mendokumentasikan tingkatan disrupsi yang disengaja, jika ada disrupsi yang telah diperkirakan.</p><p>Kubernetes menawarkan fitur-fitur untuk membantu menjalankan aplikasi-aplikasi dengan ketersediaan tinggi bersamaan dengan seringnya disrupsi yang disengaja, fitur-fitur tersebut dinamai <em>Disruption Budget</em>.</p><h2 id=bagaimana-cara-kerja-disruption-budget>Bagaimana cara kerja <em>Disruption Budget</em></h2><p>Pemilik aplikasi dapat membuat objek <code>PodDisruptionBudget</code> (PDB) untuk setiap aplikasi. Sebuah PDB membatasi jumlah Pod yang boleh mati secara bersamaan pada aplikasi yang direplikasi dikarenakan disrupsi yang disengaja.
Misalnya, sebuah aplikasi yang bekerja secara <em>quorum</em> mau memastikan bahwa jumlah replika yang berjalan tidak jatuh ke bawah yang dibutuhkan untuk membentuk sebuah <em>quorum</em>. Contoh lainnya, sebuah <em>front-end</em> web mungkin perlu memastikan bahwa jumlah replika yang melayani trafik tidak pernah turun ke total persentase yang telah ditentukan.</p><p>Administrator klaster dan penyedia layanan Kubernetes sebaiknya menggunakan alat-alat yang menghormati PDB dengan cara berkomunikasi dengan <a href=/docs/tasks/administer-cluster/safely-drain-node/#the-eviction-api>Eviction API</a> dari pada menghapus Pod atau Deployment secara langsung. Contohnya adalah perintah <code>kubectl drain</code> dan skrip pembaruan Kubernetes-on-GCE (<code>cluster/gce/upgrade.sh</code>)</p><p>Saat seorang administrator klaster ingin melakukan <em>drain</em> terhadap sebuah node, ia akan menggunakan perintah <code>kubectl drain</code>. Alat tersebut mencoba untuk "mengusir" semua Pod di node tersebut. Permintaan untuk mengusir Pod tersebut mungkin ditolak untuk sementara, dan alat tersebut akan mencoba ulang permintaannya secara periodik hingga semua Pod dihapus, atau hingga batas waktu yang ditentukan telah dicapai.</p><p>Sebua PDB merinci jumlah replika yang dapat ditoleransi oleh sebuah aplikasi, relatif terhadap berapa banyak yang seharusnya dimiliki oleh aplikasi tersebut. Sebagai contoh, sebuah Deployment yang memiliki rincian <code>.spec.replicas :5</code> diharapkan memiliki 5 Pod pada satu waktu. Jika PDB aplikasi tersebut mengizinkan ada 4 replika pada satu waktu, maka Eviction API akan mengizinkan disrupsi yag disengaja sebanyak satu, tapi tidak mengizinkan dua, pada satu waktu.</p><p>Sebuah kelompok Pod yang mewakili aplikasi dispesifikasikan menggunakan sebuah <em>label selector</em> yang sama dengan yang digunakan oleh pengatur aplikasi tersebut (Deployment, StatefulSet, dsb.)</p><p>Jumlah Pod yang "diharapkan" dihitung dari <code>.spec.replicas</code> dari pengendali Pod tersebut. Pengendali dari sebuah Pod dapat ditemukan di spesifikasi <code>.metadata.ownerReferences</code> objek Pod yang bersangkutan.</p><p>PDB tidak dapat mencegah <a href=#disrupsi-yang-disengaja-dan-tidak-disengaja>disrupsi yang tidak disengaja</a>, tapi disrupsi ini akan dihitung terhadap bujet PDB.</p><p>Pod yang dihapus atau tidak tersetia dikarenakan pembaruan bertahap juga dihitung terhadap bujet PDB, tetapi pengendali (seperti Deployment dan StatefulSet) tidak dibatasi oleh PDB ketika melakukan pembaruan bertahap; Penanganan kerusakan saat pembaruan aplikasi dikonfigurasikan pada spesifikasi pengendali. (Pelajari tentang <a href=/id/docs/concepts/workloads/controllers/deployment/#updating-a-deployment>memperbarui sebuah Deployment</a>.)</p><p>Saat sebuah Pod diusir menggunakan <em>eviction API</em>, Pod tersebut akan dihapus secara <em>graceful</em> (lihat <code>terminationGracePeriodSeconds</code> pada <a href=/docs/reference/generated/kubernetes-api/v1.25/#Podspec-v1-core>PodSpec</a>.))</p><h2 id=contoh-pdb>Contoh PDB</h2><p>Kita ambil contoh sebuah klaster dengan 3 node, <code>node-1</code> hingga <code>node-3</code>.
Klaster tersebut menjalankan beberapa aplikasi. Salah satu dari aplikasi tersebut awalnya memiliki 3 replika, yang akan kita namai <code>Pod-a</code>, <code>Pod-b</code>, dan <code>Pod-c</code>. Sebuah Pod lain yang tidak bersangkutan dan tidak memiliki PDB, dinamai <code>Pod-x</code> juga terlihat. Awalnya, Pod-pod tersebut berada pada node-node sebagai berikut:</p><table><thead><tr><th style=text-align:center>node-1</th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>Pod-a <em>available</em></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td></tr><tr><td style=text-align:center>Pod-x <em>available</em></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>3 Pod <code>Pod-a</code> hingga <code>Pod-c</code> adalah bagian dari sebuah Deployment, dan mereka secara kolektif memiliki sebuah PDB yang mengharuskan ada setidaknya 2 dari 3 Pod untuk tersedia sepanjang waktu.</p><p>Sebagai contoh, asumsikan administrator klaster ingin me-<em>reboot</em> ke dalam versi kernel baru untuk memperbaiki kesalahan di dalam kernel lama. Administator klaster pertama-tama mencoba untuk melakukan <em>drain</em> terhadap <code>node-1</code> menggunakan perintah <code>kubectl drain</code>. Perintah tersebut mencoba untuk mengusir <code>Pod-a</code> dan <code>Pod-x</code>. Hal ini langsung berhasil. Kedua Pod tersebut masuk ke dalam kondisi <code>terminating</code> secara bersamaan. Hal ini mengubah kondisi klaster menjadi sebagai berikut:</p><table><thead><tr><th style=text-align:center>node-1 <em>draining</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>Pod-a <em>terminating</em></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td></tr><tr><td style=text-align:center>Pod-x <em>terminating</em></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>Deployment tersebut melihat bahwa salah satu Pod berada dalam kondisi <code>terminating</code>, sehingga Deployment mencoba untuk membuat penggantinya, <code>Pod-d</code>. Sejak <code>node-1</code> ditutup (karena perintah <code>kubectl-drain</code>), <code>Pod-d</code> masuk ke node lainnya. Sesuatu juga membuat <code>Pod-y</code> sebagai pengganti <code>Pod-x</code></p><p>(Catatan: untuk sebuah StatefulSet, <code>Pod-a</code>, akan dinamai dengan <code>Pod-1</code>, harus diterminasi hingga selesai sebelum penggantinya, yang juga dinamai <code>Pod-1</code> tetapi memiliki UID yang berbeda, akan dibuat. Selain hal ini, seluruh contoh ini juga berlaku untuk StatefulSet.)</p><p>Sekarang, klaster berada pada kondisi berikut:</p><table><thead><tr><th style=text-align:center>node-1 <em>draining</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>Pod-a <em>terminating</em></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td></tr><tr><td style=text-align:center>Pod-x <em>terminating</em></td><td style=text-align:center>Pod-d <em>starting</em></td><td style=text-align:center>Pod-y</td></tr></tbody></table><p>Pada satu waktu, Pod-pod yang diusir pun selesai diterminasi, dan kondisi klaster menjadi seperti berikut:</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>Pod-d <em>starting</em></td><td style=text-align:center>Pod-y</td></tr></tbody></table><p>Pada titik ini, jika seorang administrator klaster yang tidak sabar mencoba untuk melakukan <em>drain</em> terhadap <code>node-2</code> atau <code>node-3</code>, perintah untuk melakukan <em>drain</em> terhadap node tersebut akan terhalang, karena hanya ada 2 Pod yang tersedia, dan PDB-nya membutuhkan setidaknya ada 2 Pod tersedia. Setelah beberapa waktu, <code>Pod-d</code> menjadi tersedia.</p><p>Kondisi klaster menjadi seperti berikut:</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>Pod-d <em>available</em></td><td style=text-align:center>Pod-y</td></tr></tbody></table><p>Sekarang, administrator klaster mencoba untuk melakukan <em>drain</em> terhadap <code>node-2</code>. Perintah <em>drain</em> tersebut akan mencoba mengusir Pod-pod tersebut secara berurutan (tidak bersamaan), misalnya <code>Pod-b</code> yang pertama dan diikuti dengan <code>Pod-d</code>. Perintah tersebut akan berhasil mengusir <code>Pod-b</code>. Tetapi, pada saat ia mencoba untuk mengusir <code>Pod-d</code>, hal tersebut akan ditolak karena hal tersebut akan mengakibatkan hanya satu Pod yang tersedia untuk Deployment yang bersangkutan.</p><p>Deployment tersebut membuat pengganti <code>Pod-b</code> yang dinamai <code>Pod-e</code>.
Karena tidak ada sumber daya klaster yang cukup untuk mengalokasikan <code>Pod-e</code>, proses <em>drain</em> akan kembali terhalang.
Klaster mungkin berada pada kondisi berikut:</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th><th style=text-align:center><em>no node</em></th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td><td style=text-align:center>Pod-e <em>pending</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>Pod-d <em>available</em></td><td style=text-align:center>Pod-y</td><td style=text-align:center></td></tr></tbody></table><p>Pada titik ini, administrator klaster mesti menambah sebuah node untuk klaster agar bisa melanjutkan pembaruan klaster.</p><p>Kamu dapat melihat bagaimana frekuensi disrupsi dapat berubah-ubah pada Kubernetes, tergantung pada:</p><ul><li>Berapa banyak replika yang dibutuhkan sebuah aplikasi</li><li>Berapa lama waktu yang dibutuhkan untuk mematikan sebuah Pod secara <em>graceful</em></li><li>Berapa lama waktu yang dibutuhkan untuk memulai sebuah Pod</li><li>Tipe pengendali</li><li>Kapasitas sumber daya klaster</li></ul><h2 id=memisahkan-peran-pemilik-klaster-dan-pemilik-aplikasi>Memisahkan Peran Pemilik Klaster dan Pemilik Aplikasi</h2><p>Seringkali akan bermanfaat untuk berpikir Administrator Klaster dan Pemilik Aplikasi sebagai peran yang terpisah dan dengan pengetahuan yang terbatas satu sama lainnya. Pemisahan ini dapat dimengerti dalam beberapa skenario berikut:</p><ul><li>Saat ada banyak tim aplikasi yang berbagi pakai sebuah klaster Kubernetes, dan ada pembagian peran yang spesifik</li><li>Saat alat atau servis pihak ketiga digunakan untuk melakukan otomasi manajemen klaster.</li></ul><p>PDB mendukung pemisahan peran ini dengan cara menyediakan antarmuka bagi peran-peran tersebut.</p><p>Jika kamu tidak memiliki pemisahan peran seperti ini pada organisasimu, kamu mungkin tidak membutuhkan PDB.</p><h2 id=bagaimana-cara-melakukan-tindakan-disruptif-terhadap-klaster>Bagaimana cara melakukan Tindakan Disruptif terhadap Klaster</h2><p>Jika kamu adalah Administrator Klaster, maka kamu mesti melakukan tindakan disruptif pada setiap node di klastermu, seperti melakukan pembaruan perangkat lunak pada node, berikut beberapa opsinya:</p><ul><li>Menerima <em>downtime</em> pada saat pembaruan node</li><li>Melakukan <em>failover</em> ke replika lengkap klaster lain.<ul><li>Tanpa <em>downtime</em>, tetapi mungkin lebih mahal, baik ongkos duplikasi node-node dan tenaga yang dibutuhkan untuk melakukan <em>failover</em>.</li></ul></li><li>Membuat aplikasi yang toleran terhadap disrupsi, dan gunakan PDB.<ul><li>Tanpa <em>downtime</em>.</li><li>Duplikasi sumber daya yang minimal.</li><li>Mengizinkan lebih banyak otomasi administrasi klaster.</li><li>Membuat aplikasi yang toleran terhadap disrupsi agak rumit, tetapi usaha yang dilakukan untuk menoleransi disrupsi yang disengaja kebanyakan beririsan dengan usaha untuk mendukung <em>autoscaling</em> dan menoleransi disrupsi yang tidak disengaja.</li></ul></li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Ikuti langkah-langkah untuk melindungi aplikasimu dengan <a href=/docs/tasks/run-application/configure-pdb/>membuat sebuah PodDisruptionBudget</a>.</p></li><li><p>Pelajari lebih lanjut mengenai <a href=/docs/tasks/administer-cluster/safely-drain-node/>melakukan <em>drain</em> terhadap node</a>.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>8 - Kontainer Sementara (Ephemeral)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>Halaman ini memberikan gambaran umum tentang kontainer sementara: satu jenis
kontainer khusus yang berjalan sementara pada <a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>
yang sudah ada untuk melakukan tindakan yang diinisiasi oleh pengguna seperti
dalam pemecahan masalah. Kamu menggunakan kontainer sementara untuk memeriksa
layanan bukan untuk membangun aplikasi.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Kontainer sementara masih berada dalam fase alpha dan tidak cocok untuk
klaster produksi. Kamu harus mengharapkan adanya suatu fitur yang tidak akan
berfungsi dalam beberapa situasi tertentu, seperti saat menargetkan <em>namespace</em>
dari suatu kontainer. Sesuai dengan Kubernetes
<a href=/docs/reference/using-api/deprecation-policy/><em>Deprecation Policy</em></a>, fitur alpha
ini dapat berubah secara signifikan di masa depan atau akan dihapus seluruhnya.</div><h2 id=memahami-kontainer-sementara>Memahami Kontainer Sementara</h2><p><a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> adalah blok pembangun
fundamental dalam aplikasi Kubernetes. Karena Pod diharapkan digunakan hanya
sekali dan dapat diganti, sehingga kamu tidak dapat menambahkan kontainer ke
dalam Pod setelah Pod tersebut dibuat. Sebaliknya, kamu biasanya menghapus dan
mengganti beberapa Pod dengan cara yang terkontrol melalui
<a class=glossary-tooltip title='Mengelola aplikasi yang direplikasi di dalam klastermu.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>.</p><p>Namun, kadang-kadang perlu juga untuk memeriksa keadaan Pod yang telah ada,
sebagai contoh untuk memecahkan masalah <em>bug</em> yang sulit direproduksi. Dalam
kasus ini, kamu dapat menjalankan sebuah kontainer sementara di dalam suatu Pod
yang sudah ada untuk memeriksa statusnya dan menjalankannya segala macam
perintah.</p><h3 id=apa-itu-kontainer-sementara>Apa itu Kontainer Sementara?</h3><p>Kontainer sementara berbeda dengan kontainer lainnya karena tidak memiliki
jaminan sumber daya maupun akan eksekusi, dan mereka tidak akan pernah secara
otomatis melakukan <em>restart</em>, jadi mereka tidak sesuai untuk membangun aplikasi.
Kontainer sementara dideskripsikan dengan menggunakan ContainerSpec yang sama
dengan kontainer biasa, tetapi banyak bagian yang tidak kompatibel dan tidak
diperbolehkan untuk kontainer sementara.</p><ul><li>Kontainer sementara mungkin tidak memiliki port, sehingga bagian seperti
<code>port</code>, <code>livenessProbe</code>, <code>readinessProbe</code> tidak diperbolehkan.</li><li>Alokasi sumber daya untuk Pod tidak dapat diubah, sehingga pengaturan
sumber daya tidak diperbolehkan.</li><li>Untuk daftar lengkap bagian yang diperbolehkan, dapat di lihat
<a href=/docs/reference/generated/kubernetes-api/v1.25/#ephemeralcontainer-v1-core>referensi dokumentasi Kontainer Sementara</a>.</li></ul><p>Kontainer sementara dibuat dengan menggunakan <em>handler</em> khusus
EphemeralContainers dalam API tanpa menambahkannya langsung ke <code>pod.spec</code>,
sehingga tidak memungkinan untuk menambahkan kontainer sementara dengan
menggunakan <code>kubectl edit</code>.</p><p>Seperti dengan kontainer biasa, kamu tidak dapat mengubah atau menghapus
kontainer sementara setelah kamu memasukkannya ke dalam sebuah Pod.</p><h2 id=penggunaan-kontainer-sementara>Penggunaan Kontainer Sementara</h2><p>Kontainer sementara berguna untuk pemecahan masalah secara interaktif pada saat
<code>kubectl exec</code> tidak mencukupi karena sebuah kontainer telah hancur atau
kontainer <em>image</em> tidak memiliki utilitas untuk <em>debugging</em>.</p><p>Khususnya, untuk <a href=https://github.com/GoogleContainerTools/distroless><em>images_distroless</em></a>
memungkinkan kamu untuk menyebarkan kontainer <em>image</em> minimal yang mengurangi
<em>surface attack</em> dan paparan <em>bug</em> dan <em>vulnerability</em>. Karena
<em>image distroless</em> tidak mempunyai sebuah <em>shell</em> atau utilitas <em>debugging</em> apa
pun, sehingga sulit untuk memecahkan masalah <em>image distroless</em> dengan
menggunakan <code>kubectl exec</code> saja.</p><p>Saat menggunakan kontainer sementara, akan sangat membantu untuk mengaktifkan
<a href=/id/docs/tasks/configure-pod-container/share-process-namespace/><em>process namespace sharing</em></a>
sehingga kamu dapat melihat proses pada kontainer lain.</p><h3 id=contoh>Contoh</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Contoh-contoh pada bagian ini membutuhkan <code>EphemeralContainers</code> <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature
gate</a> untuk
diaktifkan, dan membutuhkan Kubernetes klien dan server versi v1.16 atau
yang lebih baru.</div><p>Contoh-contoh pada bagian ini menunjukkan bagaimana kontainer sementara muncul
dalam API. Kamu biasanya dapat menggunakan plugin <code>kubectl</code> untuk mengatasi
masalah untuk mengotomatiskan langkah-langkah ini.</p><p>Kontainer sementara dibuat menggunakan <em>subresource</em> <code>ephemeralcontainers</code>
Pod, yang dapat didemonstrasikan menggunakan <code>kubectl --raw</code>. Pertama-tama
deskripsikan kontainer sementara untuk ditambahkan dalam daftar
<code>EphemeralContainers</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example-pod&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>: [{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>: <span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;stdin&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;tty&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>: <span style=color:#b44>&#34;File&#34;</span>
</span></span><span style=display:flex><span>    }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Untuk memperbarui kontainer yang sudah berjalan dalam <code>example-pod</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace --raw /api/v1/namespaces/default/pods/example-pod/ephemeralcontainers  -f ec.json
</span></span></code></pre></div><p>Ini akan menampilkan daftar baru dari seluruh kontainer sementara:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;example-pod&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>:<span style=color:#b44>&#34;/api/v1/namespaces/default/pods/example-pod/ephemeralcontainers&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;uid&#34;</span>:<span style=color:#b44>&#34;a14a6d9b-62f2-4119-9d8e-e2ed6bc3a47c&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>:<span style=color:#b44>&#34;15886&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>:<span style=color:#b44>&#34;2019-08-29T06:41:42Z&#34;</span>
</span></span><span style=display:flex><span>   },
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>:[
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;command&#34;</span>:[
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>         ],
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;resources&#34;</span>:{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         },
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>:<span style=color:#b44>&#34;File&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>:<span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;stdin&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;tty&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kamu dapat melihat kondisi kontainer sementara yang baru dibuat dengan
menggunakan <code>kubectl describe</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod example-pod
</span></span></code></pre></div><pre tabindex=0><code>...
Ephemeral Containers:
  debugger:
    Container ID:  docker://cf81908f149e7e9213d3c3644eda55c72efaff67652a2685c1146f0ce151e80f
    Image:         busybox
    Image ID:      docker-pullable://busybox@sha256:9f1003c480699be56815db0f8146ad2e22efea85129b5b5983d0e0fb52d9ab70
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Command:
      sh
    State:          Running
      Started:      Thu, 29 Aug 2019 06:42:21 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre><p>Kamu dapat mengakses kontainer sementara yang baru menggunakan
<code>kubectl attach</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it example-pod -c debugger
</span></span></code></pre></div><p>Jika proses berbagi <em>namespace</em> diaktifkan, kamu dapat melihat proses dari semua
kontainer dalam Pod tersebut. Misalnya, setelah mengakses, kamu jalankan
<code>ps</code> di kontainer <em>debugger</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan ini pada _shell_ dalam _debugger_ dari kontainer sementara</span>
</span></span><span style=display:flex><span>ps auxww
</span></span></code></pre></div><p>Hasilnya akan seperti ini:</p><pre tabindex=0><code>PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    6 root      0:00 nginx: master process nginx -g daemon off;
   11 101       0:00 nginx: worker process
   12 101       0:00 nginx: worker process
   13 101       0:00 nginx: worker process
   14 101       0:00 nginx: worker process
   15 101       0:00 nginx: worker process
   16 101       0:00 nginx: worker process
   17 101       0:00 nginx: worker process
   18 101       0:00 nginx: worker process
   19 root      0:00 /pause
   24 root      0:00 sh
   29 root      0:00 ps auxww
</code></pre></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>