<!doctype html><html lang=id class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/architecture/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/architecture/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/architecture/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/architecture/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/architecture/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/architecture/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/architecture/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/architecture/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/architecture/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/architecture/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/architecture/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/concepts/architecture/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Arsitektur Kubernetes | Kubernetes</title><meta property="og:title" content="Arsitektur Kubernetes"><meta property="og:description" content="Orkestrasi Kontainer dengan Skala Produksi"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/architecture/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Arsitektur Kubernetes"><meta itemprop=description content="Orkestrasi Kontainer dengan Skala Produksi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Arsitektur Kubernetes"><meta name=twitter:description content="Orkestrasi Kontainer dengan Skala Produksi"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/architecture/"><meta property="og:title" content="Arsitektur Kubernetes"><meta name=twitter:title content="Arsitektur Kubernetes"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/id/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/id/docs/concepts/architecture/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/id/docs/concepts/architecture/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/concepts/architecture/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/concepts/architecture/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/concepts/architecture/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/architecture/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/architecture/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/architecture/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/architecture/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/architecture/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/architecture/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/architecture/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/architecture/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/architecture/>Português (Portuguese)</a>
<a class=dropdown-item href=/vi/docs/concepts/architecture/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/concepts/architecture/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/concepts/architecture/>Return to the regular view of this page</a>.</p></div><h1 class=title>Arsitektur Kubernetes</h1><ul><li>1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Node</a></li><li>2: <a href=#pg-c0251def6da29b30afebfb04549f1703>Komunikasi antara Control Plane dan Node</a></li><li>3: <a href=#pg-ca8819042a505291540e831283da66df>Controller</a></li><li>4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Konsep-konsep di balik Controller Manager</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>1 - Node</h1><p>Node merupakan sebuah mesin <i>worker</i> di dalam Kubernetes, yang sebelumnya dinamakan <code>minion</code>.
Sebuah node bisa berupa VM ataupun mesin fisik, tergantung dari klaster-nya.
Masing-masing node berisi beberapa servis yang berguna untuk menjalankan banyak <a href=/id/docs/concepts/workloads/pods/pod/>pod</a> dan diatur oleh komponen-komponen yang dimiliki oleh master.
Servis-servis di dalam sebuah node terdiri dari <a href=/id/docs/concepts/overview/components/#node-components>runtime kontainer</a>, kubelet dan kube-proxy.
Untuk lebih detail, lihat dokumentasi desain arsitektur pada <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Node Kubernetes</a>.</p><h2 id=status-node>Status Node</h2><p>Sebuah status node berisikan informasi sebagai berikut:</p><ul><li><a href=#addresses>Addresses</a></li><li><a href=#condition>Condition</a></li><li><a href=#capacity>Capacity</a></li><li><a href=#info>Info</a></li></ul><p>Masing-masing bagian dijelaskan secara rinci di bawah ini.</p><h3 id=addresses>Addresses</h3><p>Penggunaan <i>field-field</i> ini bergantung pada penyedia layanan cloud ataupun konfigurasi bare metal yang kamu punya.</p><ul><li>HostName: Merupakan hostname yang dilaporkan oleh kernel node. Dapat diganti melalui parameter <code>--hostname-override</code> pada kubelet.</li><li>ExternalIP: Biasanya merupakan alamat IP pada node yang punya <i>route</i> eksternal (bisa diakses dari luar klaster).</li><li>InternalIP: Biasanya merupakan alamat IP pada node yang hanya punya <i>route</i> di dalam klaster.</li></ul><h3 id=condition>Condition</h3><p><i>Field</i> <code>conditions</code> menjelaskan tentang status dari semua node yang sedang berjalan (<code>Running</code>).</p><table><thead><tr><th>Kondisi Node</th><th>Penjelasan</th></tr></thead><tbody><tr><td><code>OutOfDisk</code></td><td><code>True</code> jika node sudah tidak punya cukup kapasitas disk untuk menjalankan pod baru, <code>False</code> jika sebaliknya</td></tr><tr><td><code>Ready</code></td><td><code>True</code> jika node sehat (<i>healthy</i>) dan siap untuk menerima pod, <code>False</code> jika node tidak lagi sehat (<i>unhealthy</i>) dan tidak siap menerima pod, serta <code>Unknown</code> jika kontroler node tidak menerima pesan di dalam <code>node-monitor-grace-period</code> (standarnya 40 detik)</td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> jika memori pada node terkena tekanan (<i>pressure</i>) -- maksudnya, jika kapasitas memori node sudah di titik rendah; <code>False</code> untuk sebaliknya</td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> jika <i>process-process</i> mengalami tekanan (<i>pressure</i>) -- maksudnya, jika node menjalankan terlalu banyak <i>process</i>; <code>False</code> untuk sebaliknya</td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> jika ukuran disk mengalami tekanan (<i>pressure</i>) -- maksudnya, jika kapasitas disk sudah di titik rendah; <code>False</code> untuk sebaliknya</td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> jika jaringan untuk node tidak dikonfigurasi dengan benar, <code>False</code> untuk sebaliknya</td></tr></tbody></table><p><i>Condition</i> pada node direpresentasikan oleh suatu obyek JSON. Sebagai contoh, respon berikut ini menggambarkan node yang sedang sehat (<i>healthy</i>).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Jika status untuk <code>Ready condition</code> bernilai <code>Unknown</code> atau <code>False</code> untuk waktu yang lebih dari <code>pod-eviction-timeout</code>, tergantung bagaimana <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> dikonfigurasi, semua pod yang dijalankan pada node tersebut akan dihilangkan oleh Kontroler Node.
Durasi <i>eviction timeout</i> yang standar adalah <strong>lima menit</strong>.
Pada kasus tertentu ketika node terputus jaringannya, apiserver tidak dapat berkomunikasi dengan kubelet yang ada pada node.
Keputusan untuk menghilangkan pod tidak dapat diberitahukan pada kubelet, sampai komunikasi dengan apiserver terhubung kembali.
Sementara itu, pod-pod akan terus berjalan pada node yang sudah terputus, walaupun mendapati <i>schedule</i> untuk dihilangkan.</p><p>Pada versi Kubernetes sebelum 1.5, kontroler node dapat menghilangkan dengan paksa (<a href=/id/docs/concepts/workloads/pods/pod/#force-deletion-of-pods>force delete</a>) pod-pod yang terputus dari apiserver.
Namun, pada versi 1.5 dan seterusnya, kontroler node tidak menghilangkan pod dengan paksa, sampai ada konfirmasi bahwa pod tersebut sudah berhenti jalan di dalam klaster.
Pada kasus dimana Kubernetes tidak bisa menarik kesimpulan bahwa ada node yang telah meninggalkan klaster, admin klaster mungkin perlu untuk menghilangkan node secara manual.
Menghilangkan obyek node dari Kubernetes akan membuat semua pod yang berjalan pada node tersebut dihilangkan oleh apiserver, dan membebaskan nama-namanya agar bisa digunakan kembali.</p><p>Pada versi 1.12, fitur <code>TaintNodesByCondition</code> telah dipromosikan ke beta, sehingga kontroler <i>lifecycle</i> node secara otomatis membuat <a href=/id/docs/concepts/configuration/taint-and-toleration/>taints</a> yang merepresentasikan <i>conditions</i>.
Akibatnya, <i>scheduler</i> menghiraukan <i>conditions</i> ketika mempertimbangkan sebuah Node; <i>scheduler</i> akan melihat pada <i>taints</i> sebuah Node dan <i>tolerations</i> sebuah Pod.</p><p>Sekarang, para pengguna dapat memilih antara model <i>scheduling</i> yang lama dan model <i>scheduling</i> yang lebih fleksibel.
Pada model yang lama, sebuah pod tidak memiliki <i>tolerations</i> apapun sampai mendapat giliran <i>schedule</i>. Namun, pod dapat dijalankan pada Node tertentu, dimana pod melakukan toleransi terhadap <i>taints</i> yang dimiliki oleh Node tersebut.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Mengaktifkan fitur ini menambahkan <i>delay</i> sedikit antara waktu saat suatu <i>condition</i> terlihat dan saat suatu <i>taint</i> dibuat. <i>Delay</i> ini biasanya kurang dari satu detik, tapi dapat menambahkan jumlah yang telah berhasil mendapat <i>schedule</i>, namun ditolak oleh kubelet untuk dijalankan.</div><h3 id=capacity>Capacity</h3><p>Menjelaskan tentang <i>resource-resource</i> yang ada pada node: CPU, memori, dan jumlah pod secara maksimal yang dapat dijalankan pada suatu node.</p><h3 id=info>Info</h3><p>Informasi secara umum pada suatu node, seperti versi kernel, versi Kubernetes (versi kubelet dan kube-proxy), versi Docker (jika digunakan), nama OS.
Informasi ini dikumpulkan oleh Kubelet di dalam node.</p><h2 id=manajemen>Manajemen</h2><p>Tidak seperti <a href=/id/docs/concepts/workloads/pods/pod/>pod</a> dan <a href=/id/docs/concepts/services-networking/service/>service</a>, sebuah node tidaklah dibuat dan dikonfigurasi oleh Kubernetes: tapi node dibuat di luar klaster oleh penyedia layanan cloud, seperti Google Compute Engine, atau <i>pool</i> mesin fisik ataupun virtual (VM) yang kamu punya.
Jadi ketika Kubernetes membuat sebuah node, obyek yang merepresentasikan node tersebut akan dibuat.
Setelah pembuatan, Kubernetes memeriksa apakah node tersebut valid atau tidak.
Contohnya, jika kamu mencoba untuk membuat node dari konten berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kubernetes membuat sebuah obyek node secara internal (representasinya), dan melakukan validasi terhadap node. Validasi dilakukan dengan memeriksa kondisi kesehatan node (<i>health checking</i>), berdasarkan <i>field</i> <code>metadata.name</code>. Jika node valid -- terjadi saat semua servis yang diperlukan sudah jalan -- maka node diperbolehkan untuk menjalankan sebuah pod.
Namun jika tidak valid, node tersebut akan dihiraukan untuk aktivitas apapun yang berhubungan dengan klaster, sampai telah menjadi valid.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kubernetes tetap menyimpan obyek untuk node yang tidak valid, dan terus memeriksa apakah node telah menjadi valid atau belum.
Kamu harus secara eksplisit menghilangkan obyek Node tersebut untuk menghilangkan proses ini.</div><p>Saat ini, ada tiga komponen yang berinteraksi dengan antarmuka node di Kubernetes: kontroler node, kubelet, dan kubectl.</p><h3 id=kontroler-node>Kontroler Node</h3><p>Kontroler node adalah komponen master Kubernetes yang berfungsi untuk mengatur berbagai aspek dari node.</p><p>Kontroler node memiliki berbagai peran (<i>role</i>) dalam sebuah <i>lifecycle</i> node.
Pertama, menetapkan blok CIDR pada node tersebut saat registrasi (jika CIDR <i>assignment</i> diaktifkan).</p><p>Kedua, terus memperbarui daftar internal node di dalam kontroler node, sesuai dengan daftar mesin yang tersedia di dalam penyedia layanan cloud.
Ketika berjalan di dalam <i>environment</i> cloud, kapanpun saat sebuah node tidak lagi sehat (<i>unhealthy</i>), kontroler node bertanya pada penyedia cloud, apakah VM untuk node tersebut masihkah tersedia atau tidak.
Jika sudah tidak tersedia, kontroler node menghilangkan node tersebut dari daftar node.</p><p>Ketiga, melakukan monitor terhadap kondisi kesehatan (<i>health</i>) node.
Kontroler node bertanggung jawab untuk mengubah status <code>NodeReady condition</code> pada <code>NodeStatus</code> menjadi <code>ConditionUnknown</code>, ketika sebuah node terputus jaringannya (kontroler node tidak lagi mendapat <i>heartbeat</i> karena suatu hal, contohnya karena node tidak hidup), dan saat kemudian melakukan <i>eviction</i> terhadap semua pod yang ada pada node tersebut (melalui terminasi halus -- <i>graceful</i>) jika node masih terus terputus. (<i>Timeout</i> standar adalah 40 detik untuk mulai melaporkan <code>ConditionUnknown</code> dan 5 menit setelah itu untuk mulai melakukan <i>eviction</i> terhadap pod.)</p><p>Kontroler node memeriksa <i>state</i> masing-masing node untuk durasi yang ditentukan oleh argumen <code>--node-monitor-period</code>.</p><p>Pada versi Kubernetes sebelum 1.13, <code>NodeStatus</code> adalah <i>heartbeat</i> yang diberikan oleh node.
Setelah versi 1.13, fitur <i>node lease</i> diperkenalkan sebagai fitur alpha (fitur gate <code>NodeLease</code>,
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md>KEP-0009</a>).
Ketika fitur <i>node lease</i> diaktifasi, setiap node terhubung dengan obyek <code>Lease</code> di dalam <i>namespace</i> <code>kube-node-lease</code> yang terus diperbarui secara berkala.
Kemudian, <code>NodeStatus</code> dan <i>node lease</i> keduanya dijadikan sebagai <i>heartbeat</i> dari node.
Semua <i>node lease</i> diperbarui sesering mungkin, sedangkan <code>NodeStatus</code> dilaporkan dari node untuk master hanya ketika ada perubahan atau telah melewati periode waktu tertentu (<i>default</i>-nya 1 menit, lebih lama daripada <i>default timeout</i> node-node yang terputus jaringannya).
Karena <i>node lease</i> jauh lebih ringan daripada <code>NodeStatus</code>, fitur ini membuat <i>heartbeat</i> dari node jauh lebih murah secara signifikan dari sudut pandang skalabilitas dan performa.</p><p>Di Kubernetes 1.4, kami telah memperbarui <i>logic</i> dari kontroler node supaya lebih baik dalam menangani kasus saat banyak sekali node yang tidak bisa terhubung dengan master (contohnya, karena master punya masalah jaringan).
Mulai dari 1.4, kontroler node melihat <i>state</i> dari semua node di dalam klaster, saat memutuskan untuk melakukan <i>eviction</i> pada pod.</p><p>Pada kasus kebanyakan, kontroler node membatasi <i>rate eviction</i> menjadi <code>--node-eviction-rate</code> (<i>default</i>-nya 0.1) per detik.
Artinya, kontroler node tidak akan melakukan <i>eviction</i> pada pod lebih dari 1 node per 10 detik.</p><p>Perlakuan <i>eviction</i> pada node berubah ketika sebuah node menjadi tidak sehat (<i>unhealthy</i>) di dalam suatu zona <i>availability</i>.
Kontroler node memeriksa berapa persentase node di dalam zona tersebut yang tidak sehat (saat <code>NodeReady condition</code> menjadi <code>ConditionUnknown</code> atau <code>ConditionFalse</code>) pada saat yang bersamaan.
Jika persentase node yang tidak sehat bernilai <code>--unhealthy-zone-threshold</code> (<i>default</i>-nya 0.55), maka <i>rate eviction</i> berkurang: untuk ukuran klaster yang kecil (saat jumlahnya lebih kecil atau sama dengan jumlah node <code>--large-cluster-size-threshold</code> - <i>default</i>-nya 50), maka <i>eviction</i> akan berhenti dilakukan.
Jika masih besar jumlahnya, <i>rate eviction</i> dikurangi menjadi <code>--secondary-node-eviction-rate</code> (<i>default</i>-nya 0.01) per detik.</p><p>Alasan kenapa hal ini diimplementasi untuk setiap zona <i>availability</i> adalah karena satu zona bisa saja terputus dari master, saat yang lainnya masih terhubung.
Jika klaster tidak menjangkau banyak zona <i>availability</i> yang disediakan oleh penyedia cloud, maka hanya ada satu zona (untuk semua node di dalam klaster).</p><p>Alasan utama untuk menyebarkan node pada banyak zona <i>availability</i> adalah supaya <i>workload</i> dapat dipindahkan ke zona sehat (<i>healthy</i>) saat suatu zona mati secara menyeluruh.
Kemudian, jika semua node di dalam suatu zona menjadi tidak sehat (<i>unhealthy</i>), maka kontroler node melakukan <i>eviction</i> pada <i>rate</i> normal <code>--node-eviction-rate</code>.
Kasus khusus, ketika seluruh zona tidak ada satupun sehat (tidak ada node yang sehat satupun di dalam klaster).
Pada kasus ini, kontroler node berasumsi ada masalah pada jaringan master, dan menghentikan semua <i>eviction</i> sampai jaringan terhubung kembali.</p><p>Mulai dari Kubernetes 1.6, kontroler node juga bertanggung jawab untuk melakukan <i>eviction</i> pada pod-pod yang berjalan di atas node dengan <i>taints</i> <code>NoExecute</code>, ketika pod-pod tersebut sudah tidak lagi <i>tolerate</i> terhadap <i>taints</i>.
Sebagai tambahan, hal ini di-nonaktifkan secara <i>default</i> pada fitur alpha, kontroler node bertanggung jawab untuk menambahkan <i>taints</i> yang berhubungan dengan masalah pada node, seperti terputus atau <code>NotReady</code>.
Lihat <a href=/id/docs/concepts/scheduling-eviction/taint-and-toleration/>dokumentasi ini</a> untuk bahasan detail tentang <i>taints</i> <code>NoExecute</code> dan fitur alpha.</p><p>Mulai dari versi 1.8, kontroler node bisa diatur untuk bertanggung jawab pada pembuatan <i>taints</i> yang merepresentasikan node <i>condition</i>.
Ini merupakan fitur alpha untuk versi 1.8.</p><h3 id=i-self-registration-i-untuk-node><i>Self-Registration</i> untuk Node</h3><p>Ketika argumen <code>--register-node</code> pada kubelet bernilai <i>true</i> (<i>default</i>-nya), kubelet akan berusaha untuk registrasi dirinya melalui API server.
Ini merupakan <i>pattern</i> yang disukai, digunakan oleh kebanyakan <i>distros</i>.</p><p>Kubelet memulai registrasi diri (<i>self-registration</i>) dengan opsi-opsi berikut:</p><ul><li><code>--kubeconfig</code> - <i>Path</i> berisi kredensial-kredensial yang digunakan untuk registrasi diri pada apiserver.</li><li><code>--cloud-provider</code> - Cara berbicara pada sebuah penyedia layanan cloud, baca tentang metadata-nya.</li><li><code>--register-node</code> - Registrasi secara otomatis pada API server.</li><li><code>--register-with-taints</code> - Registrasi node dengan daftar <i>taints</i> (dipisahkan oleh koma <code>&lt;key>=&lt;value>:&lt;effect></code>). No-op jika <code>register-node</code> bernilai <i>false</i>.</li><li><code>--node-ip</code> - Alamat IP dari node dimana kubelet berjalan.</li><li><code>--node-labels</code> - Label-label untuk ditambahkan saat melakukan registrasi untuk node di dalam klaster (lihat label yang dibatasi secara paksa oleh <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a> untuk 1.13+).</li><li><code>--node-status-update-frequency</code> - Menentukan seberapa sering kubelet melaporkan status pada master.</li></ul><p>Ketika mode <a href=/docs/reference/access-authn-authz/node/>otorisasi Node</a> dan <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a> diaktifkan, semua kubelet hanya punya otoritas untuk membuat/modifikasi <i>resource</i> Node masing-masing.</p><h4 id=administrasi-node-secara-manual>Administrasi Node secara Manual</h4><p>Seorang admin klaster dapat membuat dan memodifikasi obyek node.</p><p>Jika admin ingin untuk membuat obyek node secara manual, atur argument <code>--register-node=false</code> pada kubelet.</p><p>Admin dapat memodifikasi <i>resource-resource</i> node (terlepas dari <code>--register-node</code>).
Modifikasi terdiri dari pengaturan label pada node dan membuat node tidak dapat di-<i>schedule</i>.</p><p>Label-label pada node digunakan oleh <i>selector</i> node untuk mengatur proses <i>schedule</i> untuk pod, misalnya, membatasi sebuah pod hanya boleh dijalankan pada node-node tertentu.</p><p>Menandai sebuah node untuk tidak dapat di-<i>schedule</i> mencegah pod baru untuk tidak di-<i>schedule</i> pada node, tanpa mempengaruhi pod-pod yang sudah berjalan pada node tersebut.
Ini berguna sebagai langkah persiapan untuk melakukan <i>reboote</i> pada node.
Sebagai contoh, untuk menandai sebuah node untuk tidak dapat di-<i>schedule</i>, jalankan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pod-pod yang dibuat oleh suatu kontroler DaemonSet menghiraukan <i>scheduler</i> Kubernetes dan mengabaikan tanda <i>unschedulable</i> pada node.
Hal ini mengasumsikan bahwa <i>daemons</i> dimiliki oleh mesin, walaupun telah dilakukan <i>drain</i> pada aplikasi, saat melakukan persaiapan <i>reboot</i>.</div><h3 id=kapasitas-node>Kapasitas Node</h3><p>Kapasitas node (jumlah CPU dan memori) adalah bagian dari obyek node.
Pada umumnya, node-node melakukan registrasi diri dan melaporkan kapasitasnya saat obyek node dibuat.
Jika kamu melakukan <a href=#manual-node-administration>administrasi node manual</a>, maka kamu perlu mengatur kapasitas node saat menambahkan node baru.</p><p><i>Scheduler</i> Kubernetes memastikan kalau ada <i>resource</i> yang cukup untuk menjalankan semua pod di dalam sebuah node.
Kubernetes memeriksa jumlah semua <i>request</i> untuk kontainer pada sebuah node tidak lebih besar daripada kapasitas node.
Hal ini termasuk semua kontainer yang dijalankan oleh kubelet. Namun, ini tidak termasuk kontainer-kontainer yang dijalankan secara langsung oleh <a href=/id/docs/concepts/overview/components/#node-components>runtime kontainer</a> ataupun <i>process</i> yang ada di luar kontainer.</p><p>Kalau kamu ingin secara eksplisit menyimpan <i>resource</i> cadangan untuk menjalankan <i>process-process</i> selain Pod, ikut tutorial <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>menyimpan resource cadangan untuk <i>system daemon</i></a>.</p><h2 id=obyek-api>Obyek API</h2><p>Node adalah tingkatan tertinggi dari <i>resource</i> di dalam Kubernetes REST API.
Penjelasan lebih detail tentang obyek API dapat dilihat pada: <a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>Obyek Node API</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>2 - Komunikasi antara Control Plane dan Node</h1><p>Dokumen ini menjelaskan tentang jalur-jalur komunikasi di antara klaster Kubernetes dan control plane yang sebenarnya hanya berhubungan dengan apiserver saja.
Kenapa ada dokumen ini? Supaya kamu, para pengguna Kubernetes, punya gambaran bagaimana mengatur instalasi untuk memperketat konfigurasi jaringan di dalam klaster.
Hal ini cukup penting, karena klaster bisa saja berjalan pada jaringan tak terpercaya (<i>untrusted network</i>), ataupun melalui alamat-alamat IP publik pada penyedia cloud.</p><h2 id=node-menuju-control-plane>Node Menuju Control Plane</h2><p>Kubernetes memiliki sebuah pola API "hub-and-spoke". Semua penggunaan API dari Node (atau Pod dimana Pod-Pod tersebut dijalankan) akan diterminasi pada apiserver (tidak ada satu komponen <em>control plane</em> apa pun yang didesain untuk diekspos pada servis <em>remote</em>).
Apiserver dikonfigurasi untuk mendengarkan koneksi aman <em>remote</em> yang pada umumnya terdapat pada porta HTTPS (443) dengan satu atau lebih bentuk <a href=/docs/reference/access-authn-authz/authentication/>autentikasi</a> klien yang dipasang.
Sebaiknya, satu atau beberapa metode <a href=/docs/reference/access-authn-authz/authorization/>otorisasi</a> juga dipasang, terutama jika kamu memperbolehkan <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>permintaan anonim (<i>anonymous request</i>)</a> ataupun <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>service account token</a>.</p><p>Jika diperlukan, Pod-Pod dapat terhubung pada apiserver secara aman dengan menggunakan ServiceAccount.
Dengan ini, Kubernetes memasukkan <em>public root certificate</em> dan <em>bearer token</em> yang valid ke dalam Pod, secara otomatis saat Pod mulai dijalankan.
Kubernetes Service (di dalam semua Namespace) diatur dengan sebuah alamat IP virtual. Semua yang mengakses alamat IP ini akan dialihkan (melalui kube-proxy) menuju <em>endpoint</em> HTTPS dari apiserver.</p><p>Komponen-komponen juga melakukan koneksi pada apiserver klaster melalui porta yang aman.</p><p>Akibatnya, untuk konfigurasi yang umum dan standar, semua koneksi dari klaster (node-node dan pod-pod yang berjalan di atas node tersebut) menujucontrol planesudah terhubung dengan aman.
Dan juga, klaster dancontrol planebisa terhubung melalui jaringan publik dan/atau yang tak terpercaya (<i>untrusted</i>).</p><h2 id=control-plane-menuju-node>Control Plane menuju Node</h2><p>Ada dua jalur komunikasi utama dari <em>control plane</em> (apiserver) menuju klaster. Pertama, dari apiserver ke proses kubelet yang berjalan pada setiap Node di dalam klaster. Kedua, dari apiserver ke setiap Node, Pod, ataupun Service melalui fungsi proksi pada apiserver</p><h3 id=apiserver-menuju-kubelet>Apiserver menuju kubelet</h3><p>Koneksi dari apiserver menuju kubelet bertujuan untuk:</p><ul><li>Melihat log dari pod-pod.</li><li>Masuk ke dalam pod-pod yang sedang berjalan (<i>attach</i>).</li><li>Menyediakan fungsi port-forward dari kubelet.</li></ul><p>Semua koneksi ini diterminasi pada <i>endpoint</i> HTTPS dari kubelet.
Secara <i>default</i>, apiserver tidak melakukan verifikasi <i>serving certificate</i> dari kubelet, yang membuat koneksi terekspos pada serangan <i>man-in-the-middle</i>, dan juga <strong>tidak aman</strong> untuk terhubung melalui jaringan tak terpercaya (<i>untrusted</i>) dan/atau publik.</p><p>Untuk melakukan verifikasi koneksi ini, berikan <i>root certificate</i> pada apiserver melalui tanda <code>--kubelet-certificate-authority</code>, sehingga apiserver dapat memverifikasi <i>serving certificate</i> dari kubelet.</p><p>Cara lainnya, gunakan <a href=/docs/concepts/architecture/master-node-communication/#ssh-tunnels>tunnel SSH</a> antara apiserver dan kubelet jika diperlukan, untuk menghindari komunikasi melalui jaringan tak terpercaya (<i>untrusted</i>) atau publik.</p><p>Terakhir, yang terpenting, aktifkan <a href=/docs/admin/kubelet-authentication-authorization/>autentikasi dan/atau otorisasi Kubelet</a> untuk mengamankan API kubelet.</p><h3 id=apiserver-menuju-node-pod-dan-service>Apiserver menuju Node, Pod, dan Service</h3><p>Secara <i>default</i>, koneksi apiserver menuju node, pod atau service hanyalah melalui HTTP polos (<i>plain</i>), sehingga tidak ada autentikasi maupun enkripsi.
Koneksi tersebut bisa diamankan melalui HTTPS dengan menambahkan <code>https:</code> pada URL API dengan nama dari node, pod, atau service.
Namun, koneksi tidak tervalidasi dengan <i>certificate</i> yang disediakan oleh <i>endpoint</i> HTTPS maupun kredensial <i>client</i>, sehingga walaupun koneksi sudah terenkripsi, tidak ada yang menjamin integritasnya.
Koneksi ini <strong>tidak aman</strong> untuk dilalui pada jaringan publik dan/atau tak terpercaya <i>untrusted</i>.</p><h3 id=tunnel-ssh>Tunnel SSH</h3><p>Kubernetes menyediakan tunnel SSH untuk mengamankan jalur komunikasi control plane -> Klaster.
Dengan ini, apiserver menginisiasi sebuah <i>tunnel</i> SSH untuk setiap node di dalam klaster (terhubung ke server SSH di port 22) dan membuat semua trafik menuju kubelet, node, pod, atau service dilewatkan melalui <i>tunnel</i> tesebut.
<i>Tunnel</i> ini memastikan trafik tidak terekspos keluar jaringan dimana node-node berada.</p><p><i>Tunnel</i> SSH saat ini sudah usang (<i>deprecated</i>), jadi sebaiknya jangan digunakan, kecuali kamu tahu pasti apa yang kamu lakukan.
Sebuah desain baru untuk mengganti kanal komunikasi ini sedang disiapkan.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>3 - Controller</h1><p>Dalam bidang robotika dan otomatisasi, <em>control loop</em> atau kontrol tertutup adalah
lingkaran tertutup yang mengatur keadaan suatu sistem.</p><p>Berikut adalah salah satu contoh kontrol tertutup: termostat di sebuah ruangan.</p><p>Ketika kamu mengatur suhunya, itu mengisyaratkan ke termostat
tentang <em>keadaan yang kamu inginkan</em>. Sedangkan suhu kamar yang sebenarnya
adalah <em>keadaan saat ini</em>. Termostat berfungsi untuk membawa keadaan saat ini
mendekati ke keadaan yang diinginkan, dengan menghidupkan atau mematikan
perangkat.</p><p>Di Kubernetes, <em>controller</em> adalah kontrol tertutup yang mengawasi keadaan klaster
<a class=glossary-tooltip title='Sekumpulan mesin pekerja, yang dikenal sebagai Node, yang menjalankan aplikasi dalam Container. Setiap klaster setidaknya mempunyai satu Node pekerja.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=klaster>klaster</a> kamu, lalu membuat atau meminta
perubahan jika diperlukan. Setiap <em>controller</em> mencoba untuk memindahkan status
klaster saat ini mendekati keadaan yang diinginkan.</p>Di Kubernetes, pengontrol adalah kontrol tertutup yang mengawasi kondisi <a class=glossary-tooltip title='Sekumpulan mesin pekerja, yang dikenal sebagai Node, yang menjalankan aplikasi dalam Container. Setiap klaster setidaknya mempunyai satu Node pekerja.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=klaster>klaster</a>, lalu membuat atau meminta perubahan jika diperlukan. Setiap pengontrol mencoba untuk memindahkan status klaster saat ini lebih dekat ke kondisi yang diinginkan.<h2 id=pola-controller>Pola <em>controller</em></h2><p>Sebuah <em>controller</em> melacak sekurang-kurangnya satu jenis sumber daya dari
Kubernetes.
<a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects/>objek-objek</a> ini
memiliki <em>spec field</em> yang merepresentasikan keadaan yang diinginkan. Satu atau
lebih <em>controller</em> untuk <em>resource</em> tersebut bertanggung jawab untuk membuat
keadaan sekarang mendekati keadaan yang diinginkan.</p><p><em>Controller</em> mungkin saja melakukan tindakan itu sendiri; namun secara umum, di
Kubernetes, <em>controller</em> akan mengirim pesan ke
<a class=glossary-tooltip title='Komponen control plane yang mengekspos API Kubernetes. Merupakan front-end dari control plane Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API server'>API server</a> yang
mempunyai efek samping yang bermanfaat. Kamu bisa melihat contoh-contoh
di bawah ini.</p><h3 id=kontrol-melalui-server-api>Kontrol melalui server API</h3><p><em>Controller</em> <a class=glossary-tooltip title='Tugas terbatas atau bertumpuk (batch) yang berjalan sampai selesai.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> adalah contoh dari <em>controller</em>
bawaan dari Kubernetes. <em>Controller</em> bawaan tersebut mengelola status melalui
interaksi dengan server API dari suatu klaster.</p><p>Job adalah sumber daya dalam Kubernetes yang menjalankan a
<a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>, atau mungkin beberapa Pod sekaligus,
untuk melakukan sebuah pekerjaan dan kemudian berhenti.</p><p>(Setelah <a href=../../../../en/docs/concepts/scheduling-eviction/>dijadwalkan</a>, objek Pod
akan menjadi bagian dari keadaan yang diinginkan oleh kubelet).</p><p>Ketika <em>controller job</em> melihat tugas baru, maka <em>controller</em> itu memastikan bahwa,
di suatu tempat pada klaster kamu, kubelet dalam sekumpulan Node menjalankan
Pod-Pod dengan jumlah yang benar untuk menyelesaikan pekerjaan. <em>Controller job</em>
tidak menjalankan sejumlah Pod atau kontainer apa pun untuk dirinya sendiri.
Namun, <em>controller job</em> mengisyaratkan kepada server API untuk membuat atau
menghapus Pod. Komponen-komponen lain dalam
<a class=glossary-tooltip title='Merupakan lapisan orkestrasi Container yang mengekspos API dan antarmuka untuk mendefinisikan, menggelar, dan mengelola siklus hidup suatu Container.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>
bekerja berdasarkan informasi baru (adakah Pod-Pod baru untuk menjadwalkan dan
menjalankan pekerjan), dan pada akhirnya pekerjaan itu selesai.</p><p>Setelah kamu membuat Job baru, status yang diharapkan adalah bagaimana
pekerjaan itu bisa selesai. <em>Controller job</em> membuat status pekerjaan saat ini
agar mendekati dengan keadaan yang kamu inginkan: membuat Pod yang melakukan
pekerjaan yang kamu inginkan untuk Job tersebut, sehingga Job hampir
terselesaikan.</p><p><em>Controller</em> juga memperbarui objek yang mengkonfigurasinya. Misalnya: setelah
pekerjaan dilakukan untuk Job tersebut, <em>controller job</em> memperbarui objek Job
dengan menandainya <code>Finished</code>.</p><p>(Ini hampir sama dengan bagaimana beberapa termostat mematikan lampu untuk
mengindikasikan bahwa kamar kamu sekarang sudah berada pada suhu yang kamu
inginkan).</p><h3 id=kontrol-langsung>Kontrol Langsung</h3><p>Berbeda dengan sebuah Job, beberapa dari <em>controller</em> perlu melakukan perubahan
sesuatu di luar dari klaster kamu.</p><p>Sebagai contoh, jika kamu menggunakan kontrol tertutup untuk memastikan apakah
cukup <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>
dalam kluster kamu, maka <em>controller</em> memerlukan sesuatu di luar klaster saat ini
untuk mengatur Node-Node baru apabila dibutuhkan.</p><p><em>controller</em> yang berinteraksi dengan keadaan eksternal dapat menemukan keadaan
yang diinginkannya melalui server API, dan kemudian berkomunikasi langsung
dengan sistem eksternal untuk membawa keadaan saat ini mendekat keadaan yang
diinginkan.</p><p>(Sebenarnya ada sebuah <a href=https://github.com/kubernetes/autoscaler/><em>controller</em></a> yang melakukan penskalaan node secara
horizontal dalam klaster kamu.</p><h2 id=sekarang-banding-diinginkan>Status sekarang berbanding status yang diinginkan</h2><p>Kubernetes mengambil pandangan sistem secara <em>cloud-native</em>, dan mampu menangani
perubahan yang konstan.</p><p>Klaster kamu dapat mengalami perubahan kapan saja pada saat pekerjaan sedang
berlangsung dan kontrol tertutup secara otomatis memperbaiki setiap kegagalan.
Hal ini berarti bahwa, secara potensi, klaster kamu tidak akan pernah mencapai
kondisi stabil.</p><p>Selama <em>controller</em> dari klaster kamu berjalan dan mampu membuat perubahan yang
bermanfaat, tidak masalah apabila keadaan keseluruhan stabil atau tidak.</p><h2 id=perancangan>Perancangan</h2><p>Sebagai prinsip dasar perancangan, Kubernetes menggunakan banyak <em>controller</em> yang
masing-masing mengelola aspek tertentu dari keadaan klaster. Yang paling umum,
kontrol tertutup tertentu menggunakan salah satu jenis sumber daya
sebagai suatu keadaan yang diinginkan, dan memiliki jenis sumber daya yang
berbeda untuk dikelola dalam rangka membuat keadaan yang diinginkan terjadi.</p><p>Sangat penting untuk memiliki beberapa <em>controller</em> sederhana daripada hanya satu
<em>controller</em> saja, dimana satu kumpulan monolitik kontrol tertutup saling
berkaitan satu sama lain. Karena <em>controller</em> bisa saja gagal, sehingga Kubernetes
dirancang untuk memungkinkan hal tersebut.</p><p>Misalnya: <em>controller</em> pekerjaan melacak objek pekerjaan (untuk menemukan
adanya pekerjaan baru) dan objek Pod (untuk menjalankan pekerjaan tersebut dan
kemudian melihat lagi ketika pekerjaan itu sudah selesai). Dalam hal ini yang
lain membuat pekerjaan, sedangkan <em>controller</em> pekerjaan membuat Pod-Pod.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Ada kemungkinan beberapa <em>controller</em> membuat atau memperbarui jenis objek yang
sama. Namun di belakang layar, <em>controller</em> Kubernetes memastikan bahwa mereka
hanya memperhatikan sumbr daya yang terkait dengan sumber daya yang mereka
kendalikan.</p><p>Misalnya, kamu dapat memiliki Deployment dan Job; dimana keduanya akan membuat
Pod. <em>Controller Job</em> tidak akan menghapus Pod yang dibuat oleh Deployment kamu,
karena ada informasi (<a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a>)
yang dapat oleh <em>controller</em> untuk membedakan Pod-Pod tersebut.</p></div><h2 id=menjalankan-_controller_>Berbagai cara menjalankan beberapa <em>controller</em></h2><p>Kubernetes hadir dengan seperangkat <em>controller</em> bawaan yang berjalan di dalam
<a class=glossary-tooltip title='Komponen control plane yang menjalankan pengontrol.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>. Beberapa <em>controller</em>
bawaan memberikan perilaku inti yang sangat penting.</p><p><em>Controller Deployment</em> dan <em>controller Job</em> adalah contoh dari <em>controller</em> yang
hadir sebagai bagian dari Kubernetes itu sendiri (<em>controller</em> "bawaan").
Kubernetes memungkinkan kamu menjalankan <em>control plane</em> yang tangguh, sehingga
jika ada <em>controller</em> bawaan yang gagal, maka bagian lain dari <em>control plane</em> akan
mengambil alih pekerjaan.</p><p>Kamu juga dapat menemukan pengontrol yang berjalan di luar <em>control plane</em>, untuk
mengembangkan lebih jauh Kubernetes. Atau, jika mau, kamu bisa membuat
<em>controller</em> baru sendiri. Kamu dapat menjalankan <em>controller</em> kamu sendiri sebagai
satu kumpulan dari beberapa Pod, atau bisa juga sebagai bagian eksternal dari
Kubernetes. Manakah yang paling sesuai akan tergantung pada apa yang <em>controller</em>
khusus itu lakukan.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Silahkan baca tentang <a href=/docs/concepts/#kubernetes-control-plane><em>control plane</em> Kubernetes</a></li><li>Temukan beberapa dasar tentang <a href=/docs/concepts/#kubernetes-objects>objek-objek Kubernetes</a></li><li>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/overview/kubernetes-api/>Kubernetes API</a></li><li>Apabila kamu ingin membuat <em>controller</em> sendiri, silakan lihat <a href=/id/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>pola perluasan</a> dalam memperluas Kubernetes.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>4 - Konsep-konsep di balik Controller Manager</h1><p>Konsep <em>Cloud Controller Manager</em>/CCM (jangan tertukar dengan program biner kube-controller-manager) awalnya dibuat untuk memungkinkan kode vendor <em>cloud</em> spesifik dan kode inti Kubernetes untuk berkembang secara independen satu sama lainnya. CCM berjalan bersama dengan komponen Master lainnya seperti Kubernetes Controller Manager, API Server, dan Scheduler. CCM juga dapat dijalankan sebagai Kubernetes Addon (tambahan fungsi terhadap Kubernetes), yang akan berjalan di atas klaster Kubernetes.</p><p>Desain CCM didasarkan pada mekanisme <em>plugin</em> yang memungkinkan penyedia layanan <em>cloud</em> untuk berintegrasi dengan Kubernetes dengan mudah dengan menggunakan <em>plugin</em>. Sudah ada rencana untuk pengenalan penyedia layanan <em>cloud</em> baru pada Kubernetes, dan memindahkan penyedia layanan <em>cloud</em> yang sudah ada dari model yang lama ke model CCM.</p><p>Dokumen ini mendiskusikan konsep di balik CCM dan mendetail fungsi-fungsinya.</p><p>Berikut adalah arsitektur sebuah klaster Kubernetes tanpa CCM:</p><p><img src=/images/docs/pre-ccm-arch.png alt="Pre CCM Kube Arch"></p><h2 id=desain>Desain</h2><p>Pada diagram sebelumnya, Kubernetes dan penyedia layanan <em>cloud</em> diintegrasikan melalui beberapa komponen berbeda:</p><ul><li>Kubelet</li><li>Kubernetes Controller Manager</li><li>Kubernetes API server</li></ul><p>CCM menggabungkan semua logika yang bergantung pada <em>cloud</em> dari dalam tiga komponen tersebut ke dalam sebuah titik integrasi dengan <em>cloud</em>. Arsitektur baru di dalam model CCM adalah sebagai berikut:</p><p><img src=/images/docs/post-ccm-arch.png alt="CCM Kube Arch"></p><h2 id=komponen-komponen-ccm>Komponen-komponen CCM</h2><p>CCM memisahkan beberapa fungsi Kubernetes Controller Manager (KCM) dan menjalankannya sebagai proses yang berbeda. Secara spesifik, CCM memisahkan pengendali-pengendali (<em>controller</em>) di dalam KCM yang bergantung terhadap penyedia layanan <em>cloud</em>. KCM memiliki beberapa komponen pengendali yang bergantung pada <em>cloud</em> sebagai berikut:</p><ul><li>Node Controller</li><li>Volume Controller</li><li>Route Controller</li><li>Service Controller</li></ul><p>Pada versi 1.9, CCM menjalankan pengendali-pengendali dari daftar sebelumnya sebagai berikut:</p><ul><li>Node Controller</li><li>Route Controller</li><li>Service Controller</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Volume Controller secara sengaja tidak dipilih sebagai bagian dari CCM. Hal ini adalah karena kerumitan untuk melakukannya, dan mempertimbangkan usaha-usaha yang sedang berlangsung untuk memisahkan logika volume yang spesifik vendor dari KCM, sehingga diputuskan bahwa Volume Contoller tidak akan dipisahkan dari KCM ke CCM.</div><p>Rencana awal untuk mendukung volume menggunakan CCM adalah dengan menggunakan FlexVolume untuk mendukung penambahan volume secara <em>pluggable</em>. Namun, ada sebuah usaha lain yang diberi nama Container Storage Interface (CSI) yang sedang berlangsung untuk menggantikan FlexVolume.</p><p>Mempertimbangkan dinamika tersebut, kami memutuskan untuk mengambil tindakan sementara hingga CSI siap digunakan.</p><h2 id=fungsi-fungsi-ccm>Fungsi-fungsi CCM</h2><p>Fungsi-fungsi CCM diwarisi oleh komponen-komponen Kubernetes yang bergantung pada penyedia layanan <em>cloud</em>. Bagian ini disusun berdasarkan komponen-komponen tersebut.</p><h3 id=1-kubernetes-controller-manager>1. Kubernetes Controller Manager</h3><p>Kebanyakan fungsi CCM diturunkan dari KCM. Seperti yang telah disebutkan pada bagian sebelumnya, CCM menjalankan komponen-komponen pengendali sebagai berikut:</p><ul><li>Node Controller</li><li>Route Controller</li><li>Service Controller</li></ul><h4 id=node-controller>Node Controller</h4><p>Node Controller bertugas untuk menyiapkan sebuah node dengan cara mengambil informasi node-node yang berjalan di dalam klaster dari penyedia layanan <em>cloud</em>. Node Controller melakukan fungsi-fungsi berikut:</p><ol><li>Menyiapkan sebuah node dengan memberi label <em>zone</em>/<em>region</em> yang spesifik pada <em>cloud</em>.</li><li>Menyiapkan sebuah node dengan informasi <em>instance</em> yang spesifik <em>cloud</em> , misalnya tipe dan ukurannya.</li><li>Mendapatkan alamat jaringan dan <em>hostname</em> milik node tersebut.</li><li>Dalam hal sebuah node menjadi tidak responsif, memeriksa <em>cloud</em> untuk melihat apakah node tersebut telah dihapus dari <em>cloud</em>. Juga, menghapus objek Node tersebut dari klaster Kubernetes, jika node tersebut telah dihapus dari <em>cloud</em>.</li></ol><h4 id=route-controller>Route Controller</h4><p>Route Controller bertugas mengkonfigurasi rute jaringan di dalam <em>cloud</em> secara sesuai agar Container pada node-node yang berbeda di dalam klaster Kubernetes dapat berkomunikasi satu sama lain. Route Controller hanya berlaku untuk klaster yang berjalan pada Google Compute Engine (GCE) di penyedia layanan <em>cloud</em> GCP.</p><h4 id=service-controller>Service Controller</h4><p>Service Controller bertugas memantau terjadinya operasi <code>create</code>, <code>update</code>, dan <code>delete</code> pada Service. Berdasarkan keadaan terkini Service-service pada klaster Kubernetes, Service Controller mengkonfigurasi <em>load balancer</em> spesifik <em>cloud</em> (seperti ELB, Google LB, atau Oracle Cloud Infrastructure LB) agar sesuai dengan keadaan Service-service pada klaster Kubernetes. Sebagai tambahan, Service Controller juga memastikan bahwa <em>service backend</em> (target dari <em>load balancer</em> yang bersangkutan) dari <em>load balancer cloud</em> tersebut berada dalam kondisi terkini.</p><h3 id=2-kubelet>2. Kubelet</h3><p>Node Controller berisi fungsi Kubelet yang bergantung pada <em>cloud</em>. Sebelum CCM, Kubelet bertugas untuk menyiapkan node dengan informasi spesifik <em>cloud</em> seperti alamat IP, label <em>zone</em>/<em>region</em>, dan tipe <em>instance</em>. Setelah diperkenalkannya CCM, tugas tersebut telah dipindahkan dari Kubelet ke dalam CCM.</p><p>Pada model baru ini, Kubelet menyiapkan sebuah node tanpa informasi spesifik <em>cloud</em>. Namun, Kubelet menambahkan sebuah Taint pada node yang baru dibuat yang menjadikan node tersebut tidak dapat dijadwalkan (sehingga tidak ada Pod yang dapat dijadwalkan ke node tersebut) hingga CCM menyiapkan node tersebut dengan informasi spesifik <em>cloud</em>. Setelah itu, Kubelet menghapus Taint tersebut.</p><h2 id=mekanisme-plugin>Mekanisme <em>Plugin</em></h2><p>CCM menggunakan <em>interface</em> Go untuk memungkinkan implementasi dari <em>cloud</em> apapun untuk ditambahkan. Secara spesifik, CCM menggunakan CloudProvider Interface yang didefinisikan <a href=https://github.com/kubernetes/cloud-provider/blob/9b77dc1c384685cb732b3025ed5689dd597a5971/cloud.go#L42-L62>di sini</a></p><p>Implementasi dari empat kontroler-kontroler yang disorot di atas, dan beberapa kerangka kerja, bersama dengan CloudProvider Interface, akan tetap berada pada kode inti Kubernetes. Implementasi spesifik penyedia layanan <em>cloud</em> akan dibuat di luar kode inti dan menggunakan CloudProvider Interface yang didefinisikan di kode inti.</p><p>Untuk informasi lebih lanjut mengenai pengembangan <em>plugin</em>, lihat <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Mengembangkan Cloud Controller Manager</a>.</p><h2 id=otorisasi>Otorisasi</h2><p>Bagian ini memerinci akses yang dibutuhkan oleh CCM terhadap berbagai objek API untuk melakukan tugas-tugasnya.</p><h3 id=akses-untuk-node-controller>Akses untuk Node Controller</h3><p>Node Controller hanya berinteraksi dengan objek-objek Node. Node Controller membutuhkan akses penuh untuk operasi <code>get</code>, <code>list</code>, <code>create</code>, <code>update</code>, <code>patch</code>, <code>watch</code>, dan <code>delete</code> terhadap objek-objek Node.</p><p>v1/Node:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=akses-untuk-route-controller>Akses untuk Route Controller</h3><p>Route Controller memantau pembuatan objek Node dan mengkonfigurasi rute jaringan secara sesuai. Route Controller membutuhkan akses untuk operasi <code>get</code> terhadap objek-objek Node.</p><p>v1/Node:</p><ul><li>Get</li></ul><h3 id=akses-untuk-service-controller>Akses untuk Service Controller</h3><p>Service Controller memantau terjadinya operasi <code>create</code>, <code>update</code> dan <code>delete</code>, kemudian mengkonfigurasi Endpoint untuk Service-service tersebut secara sesuai.</p><p>Untuk mengakses Service-service, Service Controller membutuhkan akses untuk operasi <em>list</em> dan <em>watch</em>. Untuk memperbarui Service-service, dibutuhkan akses untuk operasi <code>patch</code> dan <code>update</code>.</p><p>Untuk menyiapkan Endpoint bagi untuk Service-service, dibutuhkan akses untuk operasi <code>create</code>, <code>list</code>, <code>get</code>, <code>watch</code>, dan <code>update</code>.</p><p>v1/Service:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=akses-lainnya>Akses Lainnya</h3><p>Implementasi dari inti CCM membutuhkan akses untuk membuat Event, dan untuk memastikan operasi yang aman, dibutuhkan akses untuk membuat ServiceAccount.</p><p>v1/Event:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p>v1/ServiceAccount:</p><ul><li>Create</li></ul><p>Detail RBAC dari ClusterRole untuk CCM adalah sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=implementasi-vendor-vendor>Implementasi Vendor-vendor</h2><p>Penyedia layanan cloud berikut telah mengimplementasikan CCM:</p><ul><li><a href=https://github.com/digitalocean/digitalocean-cloud-controller-manager>Digital Ocean</a></li><li><a href=https://github.com/oracle/oci-cloud-controller-manager>Oracle</a></li><li><a href=https://github.com/kubernetes/cloud-provider-azure>Azure</a></li><li><a href=https://github.com/kubernetes/cloud-provider-gcp>GCP</a></li><li><a href=https://github.com/kubernetes/cloud-provider-aws>AWS</a></li><li><a href=https://github.com/baidu/cloud-provider-baiducloud>BaiduCloud</a></li><li><a href=https://github.com/linode/linode-cloud-controller-manager>Linode</a></li></ul><h2 id=administrasi-klaster>Administrasi Klaster</h2><p>Petunjuk lengkap untuk mengkonfigurasi dan menjalankan CCM disediakan <a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>di sini</a>.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>