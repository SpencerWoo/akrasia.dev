<!doctype html><html lang=id class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/configuration/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/configuration/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/configuration/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/configuration/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/configuration/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/configuration/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/configuration/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/configuration/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/configuration/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/configuration/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/concepts/configuration/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Konfigurasi | Kubernetes</title><meta property="og:title" content="Konfigurasi"><meta property="og:description" content="Orkestrasi Kontainer dengan Skala Produksi"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/configuration/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Konfigurasi"><meta itemprop=description content="Orkestrasi Kontainer dengan Skala Produksi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Konfigurasi"><meta name=twitter:description content="Orkestrasi Kontainer dengan Skala Produksi"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/configuration/"><meta property="og:title" content="Konfigurasi"><meta name=twitter:title content="Konfigurasi"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/id/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/id/docs/concepts/configuration/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/id/docs/concepts/configuration/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/concepts/configuration/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/concepts/configuration/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/concepts/configuration/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/configuration/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/configuration/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/configuration/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/configuration/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/configuration/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/configuration/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/configuration/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/configuration/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/configuration/>Português (Portuguese)</a>
<a class=dropdown-item href=/uk/docs/concepts/configuration/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/concepts/configuration/>Return to the regular view of this page</a>.</p></div><h1 class=title>Konfigurasi</h1><ul><li>1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>Konfigurasi dan Penerapan Konsep</a></li><li>2: <a href=#pg-4c9401ed6b037e1adb958cbce20630c7>Mengatur Sumber Daya Komputasi untuk Container</a></li><li>3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secret</a></li><li>4: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>Mengatur Akses Klaster Menggunakan Berkas kubeconfig</a></li><li>5: <a href=#pg-ed4ae5e4344d619bc6df6e1278efae74>Prioritas dan Pemindahan Pod</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>1 - Konfigurasi dan Penerapan Konsep</h1><p>Dokumen ini menyoroti dan memperkuat pemahaman konsep konfigurasi yang dikenalkan di seluruh panduan pengguna, dokumentasi Memulai, dan contoh-contoh.</p><p>Dokumentasi ini terbuka. Jika Anda menemukan sesuatu yang tidak ada dalam daftar ini tetapi mungkin bermanfaat bagi orang lain, jangan ragu untuk mengajukan issue atau mengirimkan PR.</p><h2 id=tip-konfigurasi-secara-umum>Tip konfigurasi secara umum</h2><ul><li><p>Saat mendefinisikan konfigurasi, tentukan versi API stabil terbaru.</p></li><li><p>File konfigurasi harus disimpan dalam version control sebelum di push ke cluster. Ini memungkinkan Anda untuk dengan cepat mengembalikan perubahan konfigurasi jika perlu. Ini juga membantu penciptaan dan restorasi cluster.</p></li><li><p>Tulis file konfigurasi Anda menggunakan YAML tidak dengan JSON. Meskipun format ini dapat digunakan secara bergantian di hampir semua skenario, YAML cenderung lebih ramah pengguna.</p></li><li><p>Kelompokkan objek terkait ke dalam satu file yang memungkinkan. Satu file seringkali lebih mudah dikelola daripada beberapa file. Lihat pada <a href=https://github.com/kubernetes/examples/tree/master/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a> sebagai contoh file sintaks ini.</p></li><li><p>Perhatikan juga bahwa banyak perintah <code>kubectl</code> dapat dipanggil pada direktori. Misalnya, Anda dapat memanggil <code>kubectl apply</code> pada direktori file konfigurasi.</p></li><li><p>Jangan tentukan nilai default yang tidak perlu: sederhana, konfigurasi minimal akan membuat kesalahan lebih kecil.</p></li><li><p>Masukkan deskripsi objek dalam anotasi, untuk memungkinkan introspeksi yang lebih baik.</p></li></ul><h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"Naked" Pods vs ReplicaSets, Deployments, and Jobs</h2><ul><li><p>Jangan gunakan Pods naked (artinya, Pods tidak terikat dengan a <a href=/id/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> a <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a>) jika kamu bisa menghindarinya. Pod naked tidak akan dijadwal ulang jika terjadi kegagalan pada node.</p><p>Deployment, yang keduanya menciptakan ReplicaSet untuk memastikan bahwa jumlah Pod yang diinginkan selalu tersedia, dan menentukan strategi untuk mengganti Pods (seperti <a href=/id/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment>RollingUpdate</a>), hampir selalu lebih disukai daripada membuat Pods secara langsung, kecuali untuk beberapa yang eksplisit <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>restartPolicy: Never</code></a> banyak skenario . A <a href=/id/docs/concepts/workloads/controllers/job/>Job</a> mungkin juga sesuai.</p></li></ul><h2 id=services>Services</h2><ul><li><p>Buat <a href=/id/docs/concepts/services-networking/service/>Service</a> sebelum workloads backend terkait (Penyebaran atau ReplicaSets), dan sebelum workloads apa pun yang perlu mengaksesnya. Ketika Kubernetes memulai sebuah container, ia menyediakan environment variabel yang menunjuk ke semua Layanan yang berjalan ketika container itu dimulai. Misalnya, jika Layanan bernama <code>foo</code> ada, semua container akan mendapatkan variabel berikut di environment awalnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;the host the Service is running on&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;the port the Service is running on&gt;
</span></span></code></pre></div><p>*Ini menunjukan persyaratan pemesanan * - <code>Service</code> apa pun yang ingin diakses oleh <code>Pod</code> harus dibuat sebelum <code>Pod</code> itu sendiri, atau environment variabel tidak akan diisi. DNS tidak memiliki batasan ini.</p></li><li><p>Opsional (meskipun sangat disarankan) <a href=/id/docs/concepts/cluster-administration/addons/>cluster add-on</a> adalah server DNS.
Server DNS melihat API Kubernetes untuk <code>Service</code> baru dan membuat satu set catatan DNS untuk masing-masing. Jika DNS telah diaktifkan di seluruh cluster maka semua <code>Pods</code> harus dapat melakukan resolusi nama<code>Service</code> secara otomatis.</p></li><li><p>Jangan tentukan <code>hostPort</code> untuk Pod kecuali jika benar-benar diperlukan. Ketika Anda bind Pod ke <code>hostPort</code>, hal itu membatasi jumlah tempat Pod dapat dijadwalkan, karena setiap kombinasi &lt;<code>hostIP</code>, <code>hostPort</code>, <code>protokol</code>> harus unik. Jika Anda tidak menentukan <code>hostIP</code> dan <code>protokol</code> secara eksplisit, Kubernetes akan menggunakan <code>0.0.0.0</code> sebagai <code>hostIP</code> dan <code>TCP</code> sebagai default <code>protokol</code>.</p><p>Jika kamu hanya perlu akses ke port untuk keperluan debugging, Anda bisa menggunakan <a href=/id/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a> atau <a href=/id/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>.</p><p>Jika Anda secara eksplisit perlu mengekspos port Pod pada node, pertimbangkan untuk menggunakan <a href=/id/docs/concepts/services-networking/service/#nodeport>NodePort</a> Service sebelum beralih ke <code>hostPort</code>.</p></li><li><p>Hindari menggunakan <code>hostNetwork</code>, untuk alasan yang sama seperti <code>hostPort</code>.</p></li><li><p>Gunakan [headless Services](/id/docs/concepts/services-networking/service/#headless-
services) (yang memiliki <code>ClusterIP</code> dari <code>None</code>) untuk Service discovery yang mudah ketika Anda tidak membutuhkan <code>kube-proxy</code> load balancing.</p></li></ul><h2 id=menggunakan-label>Menggunakan label</h2><ul><li>Deklarasi dan gunakan [labels] (/id/docs/concepts/overview/working-with-objects/labels/) untuk identifikasi <strong>semantic attributes</strong> aplikasi atau Deployment kamu, seperti <code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>. Kamu dapat menggunakan label ini untuk memilih Pod yang sesuai untuk sumber daya lainnya; misalnya, Service yang memilih semua <code>tier: frontend</code> Pods, atau semua komponen <code>phase: test</code> dari <code>app: myapp</code>. Lihat <a href=https://github.com/kubernetes/examples/tree/main/guestbook/>guestbook</a> aplikasi untuk contoh-contoh pendekatan ini.</li></ul><p>Service dapat dibuat untuk menjangkau beberapa Penyebaran dengan menghilangkan label khusus rilis dari pemilihnya. <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployments</a> membuatnya mudah untuk memperbarui Service yang sedang berjalan tanpa downtime.</p><p>Keadaan objek yang diinginkan dideskripsikan oleh Deployment, dan jika perubahan terhadap spesifikasi tersebut adalah <em>applied</em>, Deployment controller mengubah keadaan aktual ke keadaan yang diinginkan pada tingkat yang terkontrol.</p><ul><li>Kamu dapat memanipulasi label untuk debugging. Karena Kubernetes controller (seperti ReplicaSet) dan Service Match dengan Pods menggunakan label pemilih, menghapus label yang relevan dari Pod akan menghentikannya dari dianggap oleh Controller atau dari lalu lintas yang dilayani oleh Service. Jika Anda menghapus label dari Pod yang ada, Controller akan membuat Pod baru untuk menggantikannya. Ini adalah cara yang berguna untuk men-debug Pod yang sebelumnya "live" di Environment "quarantine". Untuk menghapus atau menambahkan label secara interaktif, gunakan <a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>.</li></ul><h2 id=container-images>Container Images</h2><p>Ini <a href=/id/docs/concepts/containers/images/#updating-images>imagePullPolicy</a> dan tag dari image mempengaruhi ketika <a href=/docs/admin/kubelet/>kubelet</a> mencoba menarik image yang ditentukan</p><ul><li><p><code>imagePullPolicy: IfNotPresent</code>: image ditarik hanya jika belum ada secara lokal.</p></li><li><p><code>imagePullPolicy: Always</code>: Image ditarik setiap kali pod dimulai.</p></li><li><p><code>imagePullPolicy</code> dihilangkan dan tag imagenya adalah <code>:latest</code> atau dihilangkan:<code>always</code> diterapkan.</p></li><li><p><code>imagePullPolicy</code> dihilangkan dan tag image ada tetapi tidak <code>:latest</code>:<code> IfNotPresent</code> diterapkan.</p></li><li><p><code>imagePullPolicy: Never</code>: image diasumsikan ada secara lokal. Tidak ada upaya yang dilakukan untuk menarik image.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk memastikan container selalu menggunakan versi image yang sama, Anda bisa menentukannya <a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>digest</a>, untuk contoh <code>sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>. digest mengidentifikasi secara unik versi image tertentu, sehingga tidak pernah diperbarui oleh Kubernetes kecuali Anda mengubah nilai digest.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Anda harus menghindari penggunaan tag <code>: latest</code> saat menempatkan container dalam produksi karena lebih sulit untuk melacak versi image mana yang sedang berjalan dan lebih sulit untuk memutar kembali dengan benar.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Semantik caching dari penyedia gambar yang mendasarinya membuat bahkan <code>imagePullPolicy: Always</code> efisien. Dengan Docker, misalnya, jika image sudah ada, upaya pull cepat karena semua lapisan image di-cache dan tidak perlu mengunduh image.</div><h2 id=menggunakan-kubectl>Menggunakan kubectl</h2><ul><li><p>Gunakan <code>kubectl apply -f &lt;directory></code>. Ini mencari konfigurasi Kubernetes di semua file <code>.yaml</code>, <code>.yml</code>, dan <code>.json</code> di <code>&lt;directory></code> dan meneruskannya ke <code>apply</code>.</p></li><li><p>Gunakan label selector untuk operasi <code>get</code> dan <code>delete</code> alih-alih nama objek tertentu. Lihat bagian di <a href=/id/docs/concepts/overview/working-with-objects/labels/#label-selectors>label selectors</a> dan <a href=/id/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>using labels effectively</a>.</p></li><li><p>Gunakan <code>kubectl run</code> dan <code>kubectl expose</code> untuk dengan cepat membuat Deployment dan Service single-container. Lihat <a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Use a Service to Access an Application in a Cluster</a> untuk Contoh.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4c9401ed6b037e1adb958cbce20630c7>2 - Mengatur Sumber Daya Komputasi untuk Container</h1><p>Saat kamu membuat spesifikasi sebuah <a href=/id/docs/concepts/workloads/pods/pod/>Pod</a>, kamu
dapat secara opsional menentukan seberapa banyak CPU dan memori (RAM) yang dibutuhkan
oleh setiap Container. Saat Container-Container menentukan <em>request</em> (permintaan) sumber daya,
scheduler dapat membuat keputusan yang lebih baik mengenai Node mana yang akan dipilih
untuk menaruh Pod-Pod. Dan saat limit (batas) sumber daya Container-Container telah ditentukan,
maka kemungkinan rebutan sumber daya pada sebuah Node dapat dihindari.
Untuk informasi lebih lanjut mengenai perbedaan <code>request</code> dan <code>limit</code>, lihat <a href=https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md>QoS Sumber Daya</a>.</p><h2 id=jenis-jenis-sumber-daya>Jenis-jenis sumber daya</h2><p><em>CPU</em> dan <em>memori</em> masing-masing merupakan <em>jenis sumber daya</em> (<em>resource type</em>).
Sebuah jenis sumber daya memiliki satuan dasar. CPU ditentukan dalam satuan jumlah <em>core</em>,
dan memori ditentukan dalam satuan <em>bytes</em>. Jika kamu menggunakan Kubernetes v1.14 keatas,
kamu dapat menentukan sumber daya <em>huge page</em>. <em>Huge page</em> adalah fitur khusus Linux
di mana kernel Node mengalokasikan blok-blok memori yang jauh lebih besar daripada ukuran
<em>page</em> bawaannya.</p><p>Sebagai contoh, pada sebuah sistem di mana ukuran <em>page</em> bawaannya adalah 4KiB, kamu
dapat menentukan sebuah limit, <code>hugepages-2Mi: 80Mi</code>. Jika kontainer mencoba mengalokasikan
lebih dari 40 <em>huge page</em> berukuran 20MiB (total 80MiB), maka alokasi tersebut akan gagal.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu tidak dapat melakukan <em>overcommit</em> terhadap sumber daya <code>hugepages-*</code>.
Hal ini berbeda dari sumber daya <code>memory</code> dan <code>cpu</code> (yang dapat di-<em>overcommit</em>).</div><p>CPU dan memori secara kolektif disebut sebagai <em>sumber daya komputasi</em>, atau cukup
<em>sumber daya</em> saja. Sumber daya komputasi adalah jumlah yang dapat diminta, dialokasikan,
dan dikonsumsi. Mereka berbeda dengan <a href=/id/docs/concepts/overview/kubernetes-api/>sumber daya API</a>.
Sumber daya API, seperti Pod dan <a href=/id/docs/concepts/services-networking/service/>Service</a> adalah
objek-objek yang dapat dibaca dan diubah melalui Kubernetes API Server.</p><h2 id=request-dan-limit-sumber-daya-dari-pod-dan-container>Request dan Limit Sumber daya dari Pod dan Container</h2><p>Setiap Container dari sebuah Pod dapat menentukan satu atau lebih dari hal-hal berikut:</p><ul><li><code>spec.containers[].resources.limits.cpu</code></li><li><code>spec.containers[].resources.limits.memory</code></li><li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li><li><code>spec.containers[].resources.requests.cpu</code></li><li><code>spec.containers[].resources.requests.memory</code></li><li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li></ul><p>Walaupun <code>requests</code> dan <code>limits</code> hanya dapat ditentukan pada Container individual, akan
lebih mudah untuk membahas tentang request dan limit sumber daya dari Pod. Sebuah
<em>request/limit sumber daya Pod</em> untuk jenis sumber daya tertentu adalah jumlah dari
request/limit sumber daya pada jenis tersebut untuk semua Container di dalam Pod tersebut.</p><h2 id=arti-dari-cpu>Arti dari CPU</h2><p>Limit dan request untuk sumber daya CPU diukur dalam satuan <em>cpu</em>.
Satu cpu, dalam Kubernetes, adalah sama dengan:</p><ul><li>1 vCPU AWS</li><li>1 Core GCP</li><li>1 vCore Azure</li><li>1 vCPU IBM</li><li>1 <em>Hyperthread</em> pada sebuah prosesor Intel <em>bare-metal</em> dengan Hyperthreading</li></ul><p>Request dalam bentuk pecahan diizinkan. Sebuah Container dengan
<code>spec.containers[].resources.requests.cpu</code> bernilai <code>0.5</code> dijamin mendapat
setengah CPU dibandingkan dengan yang meminta 1 CPU. Ekspresi nilai <code>0.1</code> ekuivalen
dengan ekspresi nilai <code>100m</code>, yang dapat dibaca sebagai "seratus milicpu". Beberapa
orang juga membacanya dengan "seratus milicore", dan keduanya ini dimengerti sebagai
hal yang sama. Sebuah request dengan angka di belakang koma, seperti <code>0.1</code> dikonversi
menjadi <code>100m</code> oleh API, dan presisi yang lebih kecil lagi dari <code>1m</code> tidak dibolehkan.
Untuk alasan ini, bentuk <code>100m</code> mungkin lebih disukai.</p><p>CPU juga selalu diminta dalam jumlah yang mutlak, tidak sebagai jumlah yang relatif;
0.1 adalah jumlah CPU yang sama pada sebuah mesin <em>single-core</em>, <em>dual-core</em>, atau
<em>48-core</em>.</p><h2 id=arti-dari-memori>Arti dari Memori</h2><p>Limit dan request untuk <code>memory</code> diukur dalam satuan <em>bytes</em>. Kamu dapat mengekspresikan
memori sebagai <em>plain integer</em> atau sebagai sebuah <em>fixed-point integer</em> menggunakan
satu dari sufiks-sufiks berikut: E, P, T, G, M, K. Kamu juga dapat menggunakan bentuk
pangkat dua ekuivalennya: Ei, Pi, Ti, Gi, Mi, Ki.
Sebagai contoh, nilai-nilai berikut kurang lebih sama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M, 123Mi
</span></span></code></pre></div><p>Berikut sebuah contoh.
Pod berikut memiliki dua Container. Setiap Container memiliki request 0.25 cpu dan
64MiB (2<sup>26</sup> bytes) memori. Setiap Container memiliki limit 0.5 cpu dan
128MiB memori. Kamu dapat berkata bahwa Pod tersebut memiliki request 0.5 cpu dan
128MiB memori, dan memiliki limit 1 cpu dan 265MiB memori.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;password&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=bagaimana-pod-pod-dengan-request-sumber-daya-dijadwalkan>Bagaimana Pod-Pod dengan request sumber daya dijadwalkan</h2><p>Saat kamu membuat sebuah Pod, Kubernetes scheduler akan memilih sebuah Node
untuk Pod tersebut untuk dijalankan. Setiap Node memiliki kapasitas maksimum
untuk setiap jenis sumber daya: jumlah CPU dan memori yang dapat disediakan
oleh Node tersebut untuk Pod-Pod. Scheduler memastikan bahwa, untuk setiap
jenis sumber daya, jumlah semua request sumber daya dari Container-Container
yang dijadwalkan lebih kecil dari kapasitas Node tersebut. Perlu dicatat
bahwa walaupun penggunaan sumber daya memori atau CPU aktual/sesungguhnya pada
Node-Node sangat rendah, scheduler tetap akan menolak untuk menaruh sebuah
Pod pada sebuah Node jika pemeriksaan kapasitasnya gagal. Hal ini adalah untuk
menjaga dari kekurangan sumber daya pada sebuah Node saat penggunaan sumber daya
meningkat suatu waktu, misalnya pada saat titik puncak <em>traffic</em> harian.</p><h2 id=bagaimana-pod-pod-dengan-limit-sumber-daya-dijalankan>Bagaimana Pod-Pod dengan limit sumber daya dijalankan</h2><p>Saat Kubelet menjalankan sebuah Container dari sebuah Pod, Kubelet tersebut
mengoper limit CPU dan memori ke <em>runtime</em> kontainer.</p><p>Ketika menggunakan Docker:</p><ul><li><p><code>spec.containers[].resources.requests.cpu</code> diubah menjadi nilai <em>core</em>-nya,
yang mungkin berbentuk angka pecahan, dan dikalikan dengan 1024. Nilai yang
lebih besar antara angka ini atau 2 digunakan sebagai nilai dari <em>flag</em>
<a href=https://docs.docker.com/engine/reference/run/#cpu-share-constraint><code>--cpu-shares</code></a>
pada perintah <code>docker run</code>.</p></li><li><p><code>spec.containers[].resources.limits.cpu</code> diubah menjadi nilai <em>millicore</em>-nya dan
dikalikan dengan 100. Nilai hasilnya adalah jumlah waktu CPU yang dapat digunakan oleh
sebuah kontainer setiap 100 milidetik. Sebuah kontainer tidak dapat menggunakan lebih
dari jatah waktu CPU-nya selama selang waktu ini.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Periode kuota bawaan adalah 100ms. Resolusi minimum dari kuota CPU adalah 1 milidetik.</div></li><li><p><code>spec.containers[].resources.limits.memory</code> diubah menjadi sebuah bilangan bulat, dan
digunakan sebagai nilai dari <em>flag</em> <a href=https://docs.docker.com/engine/reference/run/#/user-memory-constraints><code>--memory</code></a>
dari perintah <code>docker run</code>.</p></li></ul><p>Jika sebuah Container melebihi batas memorinya, Container tersebut mungkin akan diterminasi.
Jika Container tersebut dapat diulang kembali, Kubelet akan mengulangnya kembali, sama
seperti jenis kegagalan lainnya.</p><p>Jika sebuah Container melebihi request memorinya, kemungkinan Pod-nya akan dipindahkan
kapanpun Node tersebut kehabisan memori.</p><p>Sebuah Container mungkin atau mungkin tidak diizinkan untuk melebihi limit CPU-nya
untuk periode waktu yang lama. Tetapi, Container tersebut tidak akan diterminasi karena
penggunaan CPU yang berlebihan.</p><p>Untuk menentukan apabila sebuah Container tidak dapat dijadwalkan atau sedang diterminasi
karena limit sumber dayanya, lihat bagian <a href=#penyelesaian-masalah>Penyelesaian Masalah</a>.</p><h2 id=memantau-penggunaan-sumber-daya-komputasi>Memantau penggunaan sumber daya komputasi</h2><p>Penggunaan sumber daya dari sebuah Pod dilaporkan sebagai bagian dari kondisi Pod.</p><p>Jika <a href=http://releases.k8s.io/main/cluster/addons/cluster-monitoring/README.md><em>monitoring</em> opsional</a> diaktifkan pada klaster kamu, maka penggunaan sumber daya Pod dapat diambil
dari sistem <em>monitoring</em> kamu.</p><h2 id=penyelesaian-masalah>Penyelesaian Masalah</h2><h3 id=pod-pod-saya-berkondisi-pending-tertunda-dengan-event-message-failedscheduling>Pod-Pod saya berkondisi Pending (tertunda) dengan <em>event message</em> failedScheduling</h3><p>Jika scheduler tidak dapat menemukan Node manapun yang muat untuk sebuah Pod,
Pod tersebut tidak akan dijadwalkan hingga ditemukannya sebuah tempat yang
muat. Sebuah <em>event</em> akan muncul setiap kali scheduler gagal menemukan tempat
untuk Pod tersebut, seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod frontend | grep -A <span style=color:#666>3</span> Events
</span></span></code></pre></div><pre tabindex=0><code>Events:
  FirstSeen LastSeen   Count  From          Subobject   PathReason      Message
  36s   5s     6      {scheduler }              FailedScheduling  Failed for reason PodExceedsFreeCPU and possibly others
</code></pre><p>Pada contoh di atas, Pod bernama "frontend" gagal dijadwalkan karena kekurangan
sumber daya CPU pada Node tersebut. Pesan kesalahan yang serupa dapat juga menunjukkan
kegagalan karena kekurangan memori (PodExceedsFreeMemroy). Secara umum, jika sebuah
Pod berkondisi Pending (tertunda) dengan sebuah pesan seperti ini, ada beberapa hal yang
dapat dicoba:</p><ul><li>Tambah lebih banyak Node pada klaster.</li><li>Terminasi Pod-Pod yang tidak dibutuhkan untuk memberikan ruangan untuk Pod-Pod yang
tertunda.</li><li>Periksa jika nilai request Pod tersebut tidak lebih besar dari Node-node yang ada.
Contohnya, jika semua Node memiliki kapasitas <code>cpu: 1</code>, maka Pod dengan request
<code>cpu: 1.1</code> tidak akan pernah dijadwalkan.</li></ul><p>Kamu dapat memeriksa kapasitas Node-Node dan jumlah-jumlah yang telah dialokasikan
dengan perintah <code>kubectl describe nodes</code>. Contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe nodes e2e-test-node-pool-4lw4
</span></span></code></pre></div><pre tabindex=0><code>Name:            e2e-test-node-pool-4lw4
[ ... lines removed for clarity ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... beberapa baris dihapus untuk kejelasan ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limit mungkin melebihi 100 persen, misalnya, karena _overcommit_.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (12%)        1070Mi (14%)
</code></pre><p>Pada keluaran di atas, kamu dapat melihat bahwa jika sebuah Pod meminta lebih dari
1120m CPU atau 6.23Gi memori, Pod tersebut tidak akan muat pada Node tersebut.</p><p>Dengan melihat pada bagian <code>Pods</code>, kamu dapat melihat Pod-Pod mana saja yang memakan
sumber daya pada Node tersebut.
Jumlah sumber daya yang tersedia untuk Pod-Pod kurang dari kapasitas Node, karena
<em>daemon</em> sistem menggunakan sebagian dari sumber daya yang ada. Kolom <code>allocatable</code> pada
<a href=/docs/reference/generated/kubernetes-api/v1.25/#nodestatus-v1-core>NodeStatus</a>
memberikan jumlah sumber daya yang tersedia untuk Pod-Pod. Untuk lebih lanjut, lihat
<a href=https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md>Sumber daya Node yang dapat dialokasikan</a>.</p><p>Fitur <a href=/id/docs/concepts/policy/resource-quotas/>kuota sumber daya</a> dapat disetel untuk
membatasi jumlah sumber daya yang dapat digunakan. Jika dipakai bersama dengan Namespace,
kuota sumber daya dapat mencegah suatu tim menghabiskan semua sumber daya.</p><h3 id=container-saya-diterminasi>Container saya diterminasi</h3><p>Container kamu mungkin diterminasi karena Container tersebut melebihi batasnya. Untuk
memeriksa jika sebuah Container diterminasi karena ia melebihi batas sumber dayanya,
gunakan perintah <code>kubectl describe pod</code> pada Pod yang bersangkutan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod simmemleak-hra99
</span></span></code></pre></div><pre tabindex=0><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Replication Controllers:        simmemleak (1/1 replicas created)
Containers:
  simmemleak:
    Image:  saadali/simmemleak
    Limits:
      cpu:                      100m
      memory:                   50Mi
    State:                      Running
      Started:                  Tue, 07 Jul 2015 12:54:41 -0700
    Last Termination State:     Terminated
      Exit Code:                1
      Started:                  Fri, 07 Jul 2015 12:54:30 -0700
      Finished:                 Fri, 07 Jul 2015 12:54:33 -0700
    Ready:                      False
    Restart Count:              5
Conditions:
  Type      Status
  Ready     False
Events:
  FirstSeen                         LastSeen                         Count  From                              SubobjectPath                       Reason      Message
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {scheduler }                                                          scheduled   Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   pulled      Pod container image &#34;k8s.gcr.io/pause:0.8.0&#34; already present on machine
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   created     Created with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   started     Started with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    spec.containers{simmemleak}         created     Created with docker id 87348f12526a
</code></pre><p>Pada contoh di atas, <code>Restart Count: 5</code> menunjukkan bahwa Container <code>simmemleak</code>
pada Pod tersebut diterminasi dan diulang kembali sebanyak lima kali.</p><p>Kamu dapat menggunakan perintah <code>kubectl get pod</code> dengan opsi <code>-o go-template=...</code> untuk
mengambil kondisi dari Container-Container yang sebelumnya diterminasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range.status.containerStatuses}}{{&#34;Container Name: &#34;}}{{.name}}{{&#34;\r\nLastState: &#34;}}{{.lastState}}{{end}}&#39;</span>  simmemleak-hra99
</span></span></code></pre></div><pre tabindex=0><code>Container Name: simmemleak
LastState: map[terminated:map[exitCode:137 reason:OOM Killed startedAt:2015-07-07T20:58:43Z finishedAt:2015-07-07T20:58:43Z containerID:docker://0e4095bba1feccdfe7ef9fb6ebffe972b4b14285d5acdec6f0d3ae8a22fad8b2]]
</code></pre><p>Kamu dapat lihat bahwa Container tersebut diterminasi karena <code>reason:OOM Killed</code>, di mana
<code>OOM</code> merupakan singkatan dari <em>Out Of Memory</em>, atau kehabisan memori.</p><h2 id=penyimpanan-lokal-sementara>Penyimpanan lokal sementara</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [beta]</code></div><p>Kubernetes versi 1.8 memperkenalkan sebuah sumber daya baru, <em>ephemeral-storage</em> untuk mengatur penyimpanan lokal yang bersifat sementara. Pada setiap Node Kubernetes, direktori <em>root</em> dari Kubelet (secara bawaan /var/lib/kubelet) dan direktori log (/var/log) ditaruh pada partisi <em>root</em> dari Node tersebut. Partisi ini juga digunakan bersama oleh Pod-Pod melalui volume emptyDir, log kontainer, lapisan <em>image</em>, dan lapisan kontainer yang dapat ditulis.</p><p>Partisi ini bersifat "sementara" dan aplikasi-aplikasi tidak dapat mengharapkan SLA kinerja (misalnya <em>Disk IOPS</em>) dari partisi ini. Pengelolaan penyimpanan lokal sementara hanya berlaku untuk partisi <em>root</em>; partisi opsional untuk lapisan <em>image</em> dan lapisan yang dapat ditulis berada di luar ruang lingkup.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika sebuah partisi <em>runtime</em> opsional digunakan, partisi <em>root</em> tidak akan menyimpan lapisan <em>image</em> ataupun lapisan yang dapat ditulis manapun.</div><h3 id=menyetel-request-dan-limit-dari-penyimpanan-lokal-sementara>Menyetel request dan limit dari penyimpanan lokal sementara</h3><p>Setiap Container dari sebuah Pod dapat menentukan satu atau lebih dari hal-hal berikut:</p><ul><li><code>spec.containers[].resources.limits.ephemeral-storage</code></li><li><code>spec.containers[].resources.requests.ephemeral-storage</code></li></ul><p>Limit dan request untuk <code>ephemeral-storage</code> diukur dalam satuan <em>bytes</em>. Kamu dapat menyatakan
penyimpanan dalam bilangan bulat biasa, atau sebagai <em>fixed-point integer</em> menggunakan satu dari
sufiks-sufiks ini: E, P, T, G, M, K. Kamu jika dapat menggunakan bentuk pangkat dua ekuivalennya:
Ei, Pi, Ti, Gi, Mi, Ki. Contohnya, nilai-nilai berikut kurang lebih sama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M, 123Mi
</span></span></code></pre></div><p>Contohnya, Pod berikut memiliki dua Container. Setiap Container memiliki request 2GiB untuk penyimpanan lokal sementara. Setiap Container memiliki limit 4GiB untuk penyimpanan lokal sementara. Maka, Pod tersebut memiliki jumlah request 4GiB penyimpanan lokal sementara, dan limit 8GiB.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;password&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=bagaimana-pod-pod-dengan-request-ephemeral-storage-dijadwalkan>Bagaimana Pod-Pod dengan request ephemeral-storage dijadwalkan</h3><p>Saat kamu membuat sebuah Pod, Kubernetes scheduler memilih sebuah Node di mana Pod
tersebut akan dijalankan. Setiap Node memiliki jumlah maksimum penyimpanan lokal sementara yang dapat disediakan.
Untuk lebih lanjut, lihat <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>"Hal-hal yang dapat dialokasikan Node"</a>.</p><p>Scheduler memastikan bahwa jumlah dari request-request sumber daya dari Container-Container yang dijadwalkan lebih kecil dari kapasitas Node.</p><h3 id=bagaimana-pod-pod-dengan-limit-ephemeral-storage-dijalankan>Bagaimana Pod-Pod dengan limit ephemeral-storage dijalankan</h3><p>Untuk isolasi pada tingkat kontainer, jika lapisan yang dapat ditulis dari sebuah Container dan penggunaan log melebihi limit penyimpanannya, maka Pod tersebut akan dipindahkan. Untuk isolasi pada tingkat Pod, jika jumlah dari penyimpanan lokal sementara dari semua Container dan juga volume emptyDir milik Pod melebihi limit, maka Pod teresebut akan dipindahkan.</p><h3 id=memantau-penggunaan-ephemeral-storage>Memantau penggunaan ephemeral-storage</h3><p>Saat penyimpanan lokal sementara digunakan, ia dipantau terus-menerus
oleh Kubelet. Pemantauan dilakukan dengan cara memindai setiap volume
emptyDir, direktori log, dan lapisan yang dapat ditulis secara periodik.
Dimulai dari Kubernetes 1.15, volume emptyDir (tetapi tidak direktori log
atau lapisan yang dapat ditulis) dapat, sebagai pilihan dari operator
klaster, dikelola dengan menggunakan <a href=http://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide/tmp/en-US/html/xfs-quotas.html><em>project quotas</em></a>.
<em>Project quotas</em> aslinya diimplementasikan dalam XFS, dan baru-baru ini
telah diubah ke ext4fs. <em>Project quotas</em> dapat digunakan baik untuk
<em>monitoring</em> dan pemaksaan; sejak Kubernetes 1.16, mereka tersedia sebagai
fitur <em>alpha</em> untuk <em>monitoring</em> saja.</p><p><em>Quota</em> lebih cepat dan akurat dibandingkan pemindaian direktori. Saat
sebuah direktori ditentukan untuk sebuah proyek, semua berkas yang dibuat
pada direktori tersebut dibuat untuk proyek tersebut, dan kernel hanya
perlu melacak berapa banyak blok yang digunakan oleh berkas-berkas pada
proyek tersebut. Jika sebuah berkas dibuat dan dihapus, tetapi tetap dengan
sebuah <em>file descriptor</em> yang terbuka, maka berkas tersebut tetap akan
memakan ruangan penyimpanan. Ruangan ini akan dilacak oleh <em>quota</em> tersebut,
tetapi tidak akan terlihat oleh sebuah pemindaian direktori.</p><p>Kubernetes menggunakan ID proyek yang dimulai dari 1048576. ID-ID yang
digunakan akan didaftarkan di dalam <code>/etc/projects</code> dan <code>/etc/projid</code>.
Jika ID-ID proyek pada kisaran ini digunakan untuk tujuan lain pada sistem,
ID-ID proyek tersebut harus terdaftar di dalam <code>/etc/projects</code> dan <code>/etc/projid</code>
untuk mencegah Kubernetes menggunakan ID-ID tersebut.</p><p>Untuk mengaktifkan penggunaan <em>project quotas</em>, operator klaster
harus melakukan hal-hal berikut:</p><ul><li><p>Aktifkan <em>feature gate</em> <code>LocalStorageCapacityIsolationFSQuotaMonitoring=true</code>
pada konfigurasi Kubelet. Nilainya secara bawaan <code>false</code> pada
Kubernetes 1.16, jadi harus secara eksplisit disetel menjadi <code>true</code>.</p></li><li><p>Pastikan bahwa partisi <em>root</em> (atau partisi opsional <em>runtime</em>)
telah dibangun (<em>build</em>) dengan mengaktifkan <em>project quotas</em>. Semua sistem berkas (<em>filesystem</em>)
XFS mendukung <em>project quotas</em>, tetapi sistem berkas ext4 harus dibangun
secara khusus untuk mendukungnya</p></li><li><p>Pastikan bahwa partisi <em>root</em> (atau partisi opsional <em>runtime</em>) ditambatkan (<em>mount</em>)
dengan <em>project quotas</em> yang telah diaktifkan.</p></li></ul><h4 id=membangun-dan-menambatkan-sistem-berkas-dengan-project-quotas-yang-telah-diaktifkan>Membangun dan menambatkan sistem berkas dengan <em>project quotas</em> yang telah diaktifkan</h4><p>Sistem berkas XFS tidak membutuhkan tindakan khusus saat dibangun;
mereka secara otomatis telah dibangun dengan <em>project quotas</em> yang
telah diaktifkan.</p><p>Sistem berkas <em>ext4fs</em> harus dibangun dengan mengaktifkan <em>quotas</em>,
kemudian mereka harus diaktifkan pada sistem berkas tersebut.</p><pre tabindex=0><code>% sudo mkfs.ext4 other_ext4fs_args... -E quotatype=prjquota /dev/block_device
% sudo tune2fs -O project -Q prjquota /dev/block_device
</code></pre><p>Untuk menambatkan sistem berkasnya, baik ext4fs dan XFS membutuhkan opsi
<code>prjquota</code> disetel di dalam <code>/etc/fstab</code>:</p><pre tabindex=0><code>/dev/block_device	/var/kubernetes_data	defaults,prjquota	0	0
</code></pre><h2 id=sumber-daya-yang-diperluas>Sumber daya yang diperluas</h2><p>Sumber daya yang diperluas (<em>Extended Resource</em>) adalah nama sumber daya di luar domain <code>kubernetes.io</code>.
Mereka memungkinkan operator klaster untuk menyatakan dan pengguna untuk menggunakan
sumber daya di luar sumber daya bawaan Kubernetes.</p><p>Ada dua langkah untuk menggunakan sumber daya yang diperluas. Pertama, operator
klaster harus menyatakan sebuah Extended Resource. Kedua, pengguna harus meminta
sumber daya yang diperluas tersebut di dalam Pod.</p><h3 id=mengelola-sumber-daya-yang-diperluas>Mengelola sumber daya yang diperluas</h3><h4 id=sumber-daya-yang-diperluas-pada-tingkat-node>Sumber daya yang diperluas pada tingkat Node</h4><p>Sumber daya yang diperluas pada tingkat Node terikat pada Node.</p><h5 id=sumber-daya-device-plugin-yang-dikelola>Sumber daya Device Plugin yang dikelola</h5><p>Lihat <a href=/id/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>Device
Plugin</a> untuk
cara menyatakan sumber daya <em>device plugin</em> yang dikelola pada setiap node.</p><h5 id=sumber-daya-lainnya>Sumber daya lainnya</h5><p>Untuk menyatakan sebuah sumber daya yang diperluas tingkat Node, operator klaster
dapat mengirimkan permintaan HTTP <code>PATCH</code> ke API server untuk menentukan kuantitas
sumber daya yang tersedia pada kolom <code>status.capacity</code> untuk Node pada klaster.
Setelah itu, <code>status.capacity</code> pada Node akan memiliki sumber daya baru tersebut.
Kolom <code>status.allocatable</code> diperbarui secara otomatis dengan sumber daya baru
tersebut secara <em>asynchrounous</em> oleh Kubelet. Perlu dicatat bahwa karena scheduler
menggunakan nilai <code>status.allocatable</code> milik Node saat mengevaluasi muat atau tidaknya
Pod, mungkin ada waktu jeda pendek antara melakukan <code>PATCH</code> terhadap kapasitas Node
dengan sumber daya baru dengan Pod pertama yang meminta sumber daya tersebut untuk
dapat dijadwalkan pada Node tersebut.</p><p><strong>Contoh:</strong></p><p>Berikut sebuah contoh yang menunjukkan bagaimana cara menggunakan <code>curl</code> untuk
mengirim permintaan HTTP yang menyatakan lima sumber daya "example.com/foo" pada
Node <code>k8s-node-1</code> yang memiliki master <code>k8s-master</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pada permintaan HTTP di atas, <code>~1</code> adalah <em>encoding</em> untuk karakter <code>/</code> pada jalur (<em>path</em>) <em>patch</em>.
Nilai jalur operasi tersebut di dalam JSON-Patch diinterpretasikan sebagai sebuah JSON-Pointer.
Untuk lebih lanjut, lihat <a href=https://tools.ietf.org/html/rfc6901#section-3>IETF RFC 6901, bagian 3</a>.</div><h4 id=sumber-daya-yang-diperluas-pada-tingkat-klaster>Sumber daya yang diperluas pada tingkat klaster</h4><p>Sumber daya yang diperluas pada tingkat klaster tidak terikat pada Node. Mereka
biasanya dikelola oleh <em>scheduler extender</em>, yang menangani penggunaan sumber daya
dan kuota sumber daya.</p><p>Kamu dapat menentukan sumber daya yang diperluas yang ditangani oleh <em>scheduler extender</em>
pada <a href=https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/scheduler/api/v1/types.go#L31>konfigurasi kebijakan scheduler</a>.</p><p><strong>Contoh:</strong></p><p>Konfigurasi untuk sebuah kebijakan scheduler berikut menunjukkan bahwa
sumber daya yang diperluas pada tingkat klaster "example.com/foo" ditangani
oleh <em>scheduler extender</em>.</p><ul><li>Scheduler mengirim sebuah Pod ke <em>scheduler extender</em> hanya jika Pod tersebut
meminta "example.com/foo".</li><li>Kolom <code>ignoredByScheduler</code> menentukan bahwa scheduler tidak memeriksa sumber daya
"example.com/foo" pada predikat <code>PodFitsResources</code> miliknya.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=menggunakan-sumber-daya-yang-diperluas>Menggunakan sumber daya yang diperluas</h3><p>Pengguna dapat menggunakan sumber daya yang diperluas di dalam spesifikasi Pod
seperti CPU dan memori. Scheduler menangani akuntansi sumber daya tersebut agar
tidak ada alokasi untuk yang melebihi jumlah yang tersedia.</p><p>API server membatasi jumlah sumber daya yang diperluas dalam bentuk
bilangan bulat. Contoh jumlah yang <em>valid</em> adalah <code>3</code>, <code>3000m</code>, dan
<code>3Ki</code>. Contoh jumlah yang <em>tidak valid</em> adalah <code>0.5</code> dan <code>1500m</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sumber daya yang diperluas menggantikan Opaque Integer Resource.
Pengguna dapat menggunakan prefiks nama domain selain <code>kubernetes.io</code> yang sudah dipakai.</div><p>Untuk menggunakan sebuah sumber daya yang diperluas di sebuah Pod, masukkan nama
sumber daya tersebut sebagai nilai <em>key</em> dari map <code>spec.containers[].resources.limit</code>
pada spesifikasi Container.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sumber daya yang diperluas tidak dapat di-<em>overcommit</em>, sehingga
request dan limit nilainya harus sama jika keduanya ada di spesifikasi
sebuah Container.</div><p>Sebuah Pod hanya dijadwalkan jika semua request sumber dayanya terpenuhi, termasuk
CPU, memori, dan sumber daya yang diperluas manapun. Pod tersebut akan tetap
berada pada kondisi <code>PENDING</code> selama request sumber daya tersebut tidak terpenuhi.</p><p><strong>Contoh:</strong></p><p>Pod di bawah meminta 2 CPU dan 1 "example.com/foo" (sebuah sumber daya yang diperluas).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Dapatkan pengalaman langsung <a href=/docs/tasks/configure-pod-container/assign-memory-resource/>menentukan sumber daya memori untuk Container dan Pod</a>.</p></li><li><p>Dapatkan pengalaman langsung <a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>menentukan sumber daya CPU untuk Container dan Pod</a>.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Container API</a></p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#resourcerequirements-v1-core>ResourceRequirements</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>3 - Secret</h1><p>Objek <code>secret</code> pada Kubernetes mengizinkan kamu menyimpan dan mengatur informasi yang sifatnya sensitif, seperti
<em>password</em>, token OAuth, dan ssh <em>keys</em>. Menyimpan informasi yang sifatnya sensitif ini ke dalam <code>secret</code>
cenderung lebih aman dan fleksible jika dibandingkan dengan menyimpan informasi tersebut secara apa adanya pada definisi <a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> atau di dalam <a class=glossary-tooltip title='Instans yang disimpan dari sebuah Container yang memuat seperangkat perangkat lunak yang dibutuhkan untuk menjalankan sebuah aplikasi.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='container image'>container image</a>.
Silahkan lihat <a href=https://git.k8s.io/community/contributors/design-proposals/auth/secrets.md>Dokumen desain Secret</a> untuk informasi yang sifatnya mendetail.</p><h2 id=ikhtisar-secret>Ikhtisar Secret</h2><p>Sebuah Secret merupakan sebuah objek yang mengandung informasi yang sifatnya
sensitif, seperti <em>password</em>, token, atau <em>key</em>. Informasi tersebut sebenarnya bisa saja
disimpan di dalam spesifikasi Pod atau <em>image</em>; meskipun demikian, melakukan penyimpanan
di dalam objek Secret mengizinkan pengguna untuk memiliki kontrol lebih lanjut mengenai
bagaimana Secret ini disimpan, serta mencegah tereksposnya informasi sensitif secara
tidak disengaja.</p><p>Baik pengguna dan sistem memiliki kemampuan untuk membuat objek Secret.</p><p>Untuk menggunakan Secret, sebuah Pod haruslah merujuk pada Secret tersebut.
Sebuah Secret dapat digunakan di dalam sebuah Pod melalui dua cara:
sebagai <em>file</em> yang ada di dalam <em>volume</em> <a class=glossary-tooltip title='Sebuah direktori yang mengandung data, dapat diakses o;eh kontainer-kontainer di dalam pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>
yang di-<em>mount</em> pada salah satu container Pod, atau digunakan oleh kubelet
ketika menarik <em>image</em> yang digunakan di dalam Pod.</p><h3 id=secret-built-in>Secret <em>Built-in</em></h3><h4 id=sebuah-service-account-akan-secara-otomatis-dibuat-dan-meng-attach-secret-dengan-kredensial-api>Sebuah <em>Service Account</em> akan Secara Otomatis Dibuat dan Meng-<em>attach</em> Secret dengan Kredensial API</h4><p>Kubernetes secara otomatis membuat secret yang mengandung kredensial
yang digunakan untuk mengakses API, serta secara otomatis memerintahkan Pod untuk menggunakan
Secret ini.</p><p>Mekanisme otomatisasi pembuatan secret dan penggunaan kredensial API dapat di nonaktifkan
atau di-<em>override</em> jika kamu menginginkannya. Meskipun begitu, jika apa yang kamu butuhkan
hanyalah mengakses apiserver secara aman, maka mekanisme <em>default</em> inilah yang disarankan.</p><p>Baca lebih lanjut dokumentasi <a href=/id/docs/tasks/configure-pod-container/configure-service-account/><em>Service Account</em></a>
untuk informasi lebih lanjut mengenai bagaimana cara kerja <em>Service Account</em>.</p><h3 id=membuat-objek-secret-kamu-sendiri>Membuat Objek Secret Kamu Sendiri</h3><h4 id=membuat-secret-dengan-menggunakan-kubectl>Membuat Secret dengan Menggunakan kubectl</h4><p>Misalnya saja, beberapa Pod memerlukan akses ke sebuah basis data. Kemudian <em>username</em>
dan <em>password</em> yang harus digunakan oleh Pod-Pod tersebut berada pada mesin lokal kamu
dalam bentuk <em>file-file</em> <code>./username.txt</code> dan <code>./password.txt</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Buatlah berkas yang selanjutnya akan digunakan pada contoh-contoh selanjutnya</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> &gt; ./username.txt
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> &gt; ./password.txt
</span></span></code></pre></div><p>Perintah <code>kubectl create secret</code> akan mengemas <em>file-file</em> ini menjadi Secret dan
membuat sebuah objek pada Apiserver.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic db-user-pass --from-file<span style=color:#666>=</span>./username.txt --from-file<span style=color:#666>=</span>./password.txt
</span></span></code></pre></div><pre tabindex=0><code>secret &#34;db-user-pass&#34; created
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Karakter spesial seperti <code>$</code>, <code>\*</code>, and <code>!</code> membutuhkan mekanisme <em>escaping</em>.
Jika <em>password</em> yang kamu gunakan mengandung karakter spesial, kamu perlu melakukan <em>escape</em> karakter dengan menggunakan karakter <code>\\</code>. Contohnya, apabila <em>password</em> yang kamu miliki adalah <code>S!B\*d$zDsb</code>, maka kamu harus memanggil perintah kubectl dengan cara berikut:
kubectl create secret generic dev-db-secret --from-literal=username=devuser --from-literal=password=S\!B\\*d\$zDsb
Perhatikan bahwa kamu tidak perlu melakukan <em>escape</em> karakter apabila massukan yang kamu berikan merupakan <em>file</em> (<code>--from-file</code>).</div><p>Kamu dapat memastikan apakah suatu Secret sudah dibuat atau belum dengan menggunakan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><pre tabindex=0><code>NAME                  TYPE                                  DATA      AGE
db-user-pass          Opaque                                2         51s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe secrets/db-user-pass
</span></span></code></pre></div><pre tabindex=0><code>Name:            db-user-pass
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password.txt:    12 bytes
username.txt:    5 bytes
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Perintah-perintah <code>kubectl get</code> dan <code>kubectl describe</code> secara <em>default</em> akan
mencegah ditampilkannya informasi yang ada di dalam Secret.
Hal ini dilakukan untuk melindungi agar Secret tidak terekspos secara tidak disengaja oleh orang lain,
atau tersimpan di dalam <em>log</em> <em>terminal</em>.</div><p>Kamu dapat membaca <a href=#decoding-a-secret>bagaimana cara melakukan <em>decode</em> sebuah secret</a>
untuk mengetahui bagaimana cara melihat isi dari Secret.</p><h4 id=membuat-secret-secara-manual>Membuat Secret Secara Manual</h4><p>Kamu dapat membuat sebuah Secret dengan terlebih dahulu membuat <em>file</em> yang berisikan
informasi yang ingin kamu jadikan Secret dalam bentuk yaml atau json dan kemudian membuat objek
dengan menggunakan <em>file</em> tersebut. <a href=/docs/reference/generated/kubernetes-api/v1.12/#secret-v1-core>Secret</a>
mengandung dua buah <em>map</em>: <em>data</em> dan <em>stringData</em>. <em>Field</em> <em>data</em> digunakan untuk menyimpan sembarang data,
yang di-<em>encode</em> menggunakan base64. Sementara itu <em>stringData</em> disediakan untuk memudahkan kamu untuk menyimpan
informasi sensitif dalam format yang tidak di-<em>encode</em>.</p><p>Sebagai contoh, untuk menyimpan dua buah string di dalam Secret dengan menggunakan <em>field</em> data, ubahlah
informasi tersebut ke dalam base64 dengan menggunakan mekanisme sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> | base64
</span></span><span style=display:flex><span><span style=color:#b8860b>YWRtaW4</span><span style=color:#666>=</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> | base64
</span></span><span style=display:flex><span>MWYyZDFlMmU2N2Rm
</span></span></code></pre></div><p>Buatlah sebuah Secret yang memiliki bentuk sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kemudian buatlah Secret menggunakan perintah <a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./secret.yaml
</span></span></code></pre></div><pre tabindex=0><code>secret &#34;mysecret&#34; created
</code></pre><p>Untuk beberapa skenario, kamu bisa saja ingin menggunakan opsi <em>field</em> stringData.
<em>Field</em> ini mengizinkan kamu untuk memberikan masukan berupa informasi yang belum di-<em>encode</em> secara langsung
pada sebuah Secret, informasi dalam bentuk string ini kemudian akan di-<em>encode</em> ketika Secret dibuat maupun diubah.</p><p>Contoh praktikal dari hal ini adalah ketika kamu melakukan proses <em>deploy</em> aplikasi
yang menggunakan Secret sebagai penyimpanan <em>file</em> konfigurasi, dan kamu ingin mengisi
bagian dari konfigurasi <em>file</em> tersebut ketika aplikasi di_deploy_.</p><p>Jika kamu ingin aplikasi kamu menggunakan <em>file</em> konfigurasi berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiUrl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my.api.com/api/v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;password&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Kamu dapat menyimpan Secret ini dengan menggunakan cara berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    apiUrl: &#34;https://my.api.com/api/v1&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    username: {{username}}
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    password: {{password}}</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>Alat <em>deployment</em> yang kamu gunakan kemudian akan mengubah templat variabel <code>{{username}}</code> dan <code>{{password}}</code>
sebelum menjalankan perintah <code>kubectl apply</code>.</p><p>stringData merupakan <em>field</em> yang sifatnya <em>write-only</em> untuk alasan kenyamanan pengguna.
<em>Field</em> ini tidak pernah ditampilkan ketika Secret dibaca. Sebagai contoh, misalkan saja kamu menjalankan
perintah sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret mysecret -o yaml
</span></span></code></pre></div><p>Keluaran yang diberikan kurang lebih akan ditampilkan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:40:59Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7225&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/secrets/mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>c280ad2e-e916-11e8-98f2-025000000001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IHt7dXNlcm5hbWV9fQpwYXNzd29yZDoge3twYXNzd29yZH19<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika sebuah <em>field</em> dispesifikasikan dalam bentuk data maupun stringData,
maka nilai dari stringData-lah yang akan digunakan. Sebagai contoh, misalkan saja terdapat
definisi Secret sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>administrator<span style=color:#bbb>
</span></span></span></code></pre></div><p>Akan menghasilkan Secret sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:46:46Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7579&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/secrets/mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>91460ecb-e917-11e8-98f2-025000000001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW5pc3RyYXRvcg==<span style=color:#bbb>
</span></span></span></code></pre></div><p>Dimana string <code>YWRtaW5pc3RyYXRvcg==</code> akan di-<em>decode</em> sebagai <code>administrator</code>.</p><p><em>Key</em> dari data dan stringData yang boleh tersusun atas karakter alfanumerik,
'-', '_' atau '.'.</p><p><strong>Catatan <em>Encoding</em>:</strong> <em>Value</em> dari JSON dan YAML yang sudah diseriakisasi dari data Secret
akan di-<em>encode</em> ke dalam string base64. <em>Newline</em> dianggap tidak valid pada string ini dan harus
dihilangkan. Ketika pengguna Darwin/macOS menggunakan alat <code>base64</code>, maka pengguna
tersebut harus menghindari opsi <code>-b</code> yang digunakan untuk memecah baris yang terlalu panjang.
Sebaliknya pengguna Linux <em>harus</em> menambahkan opsi <code>-w 0</code> pada perintah <code>base64</code> atau
melakukan mekanisme <em>pipeline</em> <code>base64 | tr -d '\n'</code> jika tidak terdapat opsi <code>-w</code>.</p><h4 id=membuat-secret-dengan-menggunakan-generator>Membuat Secret dengan Menggunakan <em>Generator</em></h4><p>Kubectl mendukung <a href=/docs/tasks/manage-kubernetes-objects/kustomization/>mekanisme manajemen objek dengan menggunakan Kustomize</a>
sejak versi 1.14. Dengan fitur baru ini, kamu juga dapat membuat sebuah Secret dari sebuah <em>generator</em>
dan kemudian mengaplikasikannya untuk membuat sebuah objek pada Apiserver. <em>Generator</em> yang digunakan haruslah
dispesifikasikan di dalam sebuah <em>file</em> <code>kustomization.yaml</code> di dalam sebuah direktori.</p><p>Sebagai contoh, untuk menghasilan sebuah Secret dari <em>file-file</em> <code>./username.txt</code> dan <code>./password.txt</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat sebuah berkas kustomization.yaml dengan SecretGenerator</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>secretGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: db-user-pass
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - username.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>  - password.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Gunakan direktori <em>kustomization</em> untuk membuat objek Secret yang diinginkan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ kubectl apply -k .
</span></span><span style=display:flex><span>secret/db-user-pass-96mffmfh4k created
</span></span></code></pre></div><p>Kamu dapat memastikan Secret tersebut sudah dibuat dengan menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ kubectl get secrets
</span></span><span style=display:flex><span>NAME                             TYPE                                  DATA      AGE
</span></span><span style=display:flex><span>db-user-pass-96mffmfh4k          Opaque                                <span style=color:#666>2</span>         51s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ kubectl describe secrets/db-user-pass-96mffmfh4k
</span></span><span style=display:flex><span>Name:            db-user-pass
</span></span><span style=display:flex><span>Namespace:       default
</span></span><span style=display:flex><span>Labels:          &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:     &lt;none&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Type:            Opaque
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b8860b>Data</span>
</span></span><span style=display:flex><span><span style=color:#666>====</span>
</span></span><span style=display:flex><span>password.txt:    <span style=color:#666>12</span> bytes
</span></span><span style=display:flex><span>username.txt:    <span style=color:#666>5</span> bytes
</span></span></code></pre></div><p>Sebagai contoh, untuk membuat sebuah Secret dari literal <code>username=admin</code> dan <code>password=secret</code>,
kamu dapat menspesifikasikan <em>generator</em> Secret pada <em>file</em> <code>kustomization.yaml</code> sebagai</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat sebuah berkas kustomization.yaml dengan menggunakan SecretGenerator</span>
</span></span><span style=display:flex><span>$ cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>secretGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: db-user-pass
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - username=admin
</span></span></span><span style=display:flex><span><span style=color:#b44>  - password=secret
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Aplikasikan direktori <em>kustomization</em> untuk membuat objek Secret.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ kubectl apply -k .
</span></span><span style=display:flex><span>secret/db-user-pass-dddghtt9b5 created
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Secret yang dihasilkan nantinya akan memiliki tambahan sufix dengan cara melakukan teknik <em>hashing</em>
pada isi Secret tersebut. Hal ini dilakukan untuk menjamin dibuatnya sebuah Secret baru setiap kali terjadi
perubahan isi dari Secret tersebut.</div><h4 id=melakukan-proses-decode-pada-secret>Melakukan Proses <em>Decode</em> pada Secret</h4><p>Secret dapat dibaca dengan menggunakan perintah <code>kubectl get secret</code>.
Misalnya saja, untuk membaca Secret yang dibuat pada bagian sebelumya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret mysecret -o yaml
</span></span></code></pre></div><pre tabindex=0><code>apiVersion: v1
kind: Secret
metadata:
  creationTimestamp: 2016-01-22T18:41:56Z
  name: mysecret
  namespace: default
  resourceVersion: &#34;164619&#34;
  selfLink: /api/v1/namespaces/default/secrets/mysecret
  uid: cfee02d6-c137-11e5-8d73-42010af00002
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
</code></pre><p>Kemudian lakukan mekanisme <em>decode</em> <em>field</em> <em>password</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;MWYyZDFlMmU2N2Rm&#39;</span> | base64 --decode
</span></span></code></pre></div><pre tabindex=0><code>1f2d1e2e67df
</code></pre><h2 id=menggunakan-secret>Menggunakan Secret</h2><p>Secret dapat di-<em>mount</em> sebagai <em>volume</em> data atau dapat diekspos sebagai <a class=glossary-tooltip title='Variabel lingkungan Container merupakan pasangan nama=nilai yang dapat digunakan untuk menyediakan informasi penting bagi Container yang dijalankan pada Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment-variables/ target=_blank aria-label='variabel-variabel environment'>variabel-variabel environment</a>
dapat digunakan di dalam Pod. Secret ini juga dapat digunakan secara langsug
oleh bagian lain dari sistem, tanpa secara langsung berkaitan dengan Pod.
Sebagai contoh, Secret dapat berisikan kredensial bagian suatu sistem lain yang digunakan
untuk berinteraksi dengan sistem eksternal yang kamu butuhkan.</p><h3 id=menggunakan-secret-sebagai-file-melalui-pod>Menggunakan Secret sebagai <em>File</em> melalui Pod</h3><p>Berikut adalah langkah yang harus kamu penuhi agar kamu dapat menggunakan Secret di dalam <em>volume</em> dalam sebuah Pod:</p><ol><li>Buatlah sebuah Secret, atau gunakan sebuah Secret yang sudah kamu buat sebelumnya. Beberapa Pod dapat merujuk pada sebuah Secret yang sama.</li><li>Modifikasi definisi Pod kamu dengan cara menambahkan sebuah <em>volume</em> di bawah <code>.spec.volumes[]</code>. Berilah <em>volume</em> tersebut nama, dan pastikan <em>field</em> <code>.spec.volumes[].secret.secretName</code> merujuk pada nama yang sama dengan objek secret.</li><li>Tambahkan <em>field</em> <code>.spec.containers[].volumeMounts[]</code> pada setiap container yang membutuhkan Secret. Berikan spesifikasi <code>.spec.containers[].volumeMounts[].readOnly = true</code> dan <code>.spec.containers[].volumeMounts[].mountPath</code> pada direktori dimana Secret tersebut diletakkan.</li><li>Modifikasi image dan/atau <em>command line</em> kamu agar program yang kamu miliki merujuk pada <em>file</em> di dalam direktori tersebut. Setiap <em>key</em> pada map <code>data</code> Secret akan menjadi nama dari sebuah <em>file</em> pada <code>mountPath</code>.</li></ol><p>Berikut merupakan salah satu contoh dimana sebuah Pod melakukan proses <em>mount</em> Secret pada sebuah <em>volume</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span></code></pre></div><p>Setiap Secret yang ingin kamu gunakan harus dirujuk pada <em>field</em> <code>.spec.volumes</code>.</p><p>Jika terdapat lebih dari satu container di dalam Pod,
maka setiap container akan membutuhkan blok <code>volumeMounts</code>-nya masing-masing,
meskipun demikian hanya sebuah <em>field</em> <code>.spec.volumes</code> yang dibutuhkan untuk setiap Secret.</p><p>Kamu dapat menyimpan banyak <em>file</em> ke dalam satu Secret,
atau menggunakan banyak Secret, hal ini tentunya bergantung pada preferensi pengguna.</p><p><strong>Proyeksi <em>key</em> Secret pada Suatu <em>Path</em> Spesifik</strong></p><p>Kita juga dapat mengontrol <em>path</em> di dalam <em>volume</em> di mana sebuah Secret diproyeksikan.
Kamu dapat menggunakan <em>field</em> <code>.spec.volumes[].secret.items</code> untuk mengubah
<em>path</em> target dari setiap <em>key</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span></code></pre></div><p>Apa yang akan terjadi jika kita menggunakan definisi di atas:</p><ul><li>Secret <code>username</code> akan disimpan pada <em>file</em> <code>/etc/foo/my-group/my-username</code> dan bukan <code>/etc/foo/username</code>.</li><li>Secret <code>password</code> tidak akan diproyeksikan.</li></ul><p>Jika <em>field</em> <code>.spec.volumes[].secret.items</code> digunakan, hanya <em>key-key</em> yang dispesifikan di dalam
<code>items</code> yang diproyeksikan. Untuk mengonsumsi semua <em>key-key</em> yang ada dari Secret,
semua <em>key</em> yang ada harus didaftarkan pada <em>field</em> <code>items</code>.
Semua <em>key</em> yang didaftarkan juga harus ada di dalam Secret tadi.
Jika tidak, <em>volume</em> yang didefinisikan tidak akan dibuat.</p><p><strong><em>Permission</em> <em>File-File</em> Secret</strong></p><p>Kamu juga dapat menspesifikasikan mode <em>permission</em> dari <em>file</em> Secret yang kamu inginkan.
Jika kamu tidak menspesifikasikan hal tersebut, maka nilai <em>default</em> yang akan diberikan adalah <code>0644</code> is used by default.
Kamu dapat memberikan mode <em>default</em> untuk semua Secret yang ada serta melakukan mekanisme <em>override</em> <em>permission</em>
pada setiap <em>key</em> jika memang diperlukan.</p><p>Sebagai contoh, kamu dapat memberikan spesifikasi mode <em>default</em> sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>256</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Kemudian, sebuah Secret akan di-<em>mount</em> pada <code>/etc/foo</code>, selanjutnya semua <em>file</em>
yang dibuat pada <em>volume</em> secret tersebut akan memiliki <em>permission</em> <code>0400</code>.</p><p>Perhatikan bahwa spesifikasi JSON tidak mendukung notasi <em>octal</em>, dengan demikian gunakanlah
<em>value</em> 256 untuk <em>permission</em> 0400. Jika kamu menggunakan format YAML untuk spesifikasi Pod,
kamu dapat menggunakan notasi <em>octal</em> untuk memberikan spesifikasi <em>permission</em> dengan cara yang lebih
natural.</p><p>Kamu juga dapat melakukan mekanisme pemetaan, seperti yang sudah dilakukan pada contoh sebelumnya,
dan kemudian memberikan spesifikasi <em>permission</em> yang berbeda untuk <em>file</em> yang berbeda.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>511</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Pada kasus tersebut, <em>file</em> yang dihasilkan pada <code>/etc/foo/my-group/my-username</code> akan memiliki
<em>permission</em> <code>0777</code>. Karena terdapat batasan pada representasi JSON, maka kamu
harus memberikan spesifikasi mode <em>permission</em> dalam bentuk notasi desimal.</p><p>Perhatikan bahwa <em>permission</em> ini bida saja ditampilkan dalam bentuk notasi desimal,
hal ini akan ditampilkan pada bagian selanjutnya.</p><p><strong>Mengonsumsi <em>Value</em> dari Secret melalui Volume</strong></p><p>Di dalam sebuah container dimana <em>volume</em> secret di-<em>mount</em>,
<em>key</em> dari Secret akan ditampilkan sebagai <em>file</em> dan <em>value</em> dari Secret yang berada dalam bentuk
base64 ini akan di-<em>decode</em> dam disimpan pada <em>file-file</em> tadi.
Berikut merupakan hasil dari eksekusi perintah di dalam container berdasarkan contoh
yang telah dipaparkan di atas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /etc/foo/
</span></span></code></pre></div><pre tabindex=0><code>username
password
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/username
</span></span></code></pre></div><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/password
</span></span></code></pre></div><pre tabindex=0><code>1f2d1e2e67df
</code></pre><p>Program di dalam container bertanggung jawab untuk membaca Secret
dari <em>file-file</em> yang ada.</p><p><strong>Secret yang di-<em>mount</em> Akan Diubah Secara Otomatis</strong></p><p>Ketika sebuah Secret yang sedang digunakan di dalam <em>volume</em> diubah,
maka <em>key</em> yang ada juga akan diubah. Kubelet akan melakukan mekanisme pengecekan secara periodik
apakah terdapat perubahan pada Secret yang telah di-<em>mount</em>. Meskipun demikian,
proses pengecekan ini dilakukan dengan menggunakan <em>cache</em> lokal untuk mendapatkan <em>value</em> saat ini
dari sebuah Secret. Tipe <em>cache</em> yang ada dapat diatur dengan menggunakan
(<em>field</em> <code>ConfigMapAndSecretChangeDetectionStrategy</code> pada
<a href=https://github.com/kubernetes/kubernetes/blob/main/staging/src/k8s.io/kubelet/config/v1beta1/types.go><em>struct</em> KubeletConfiguration</a>).
Mekanisme ini kemudian dapat diteruskan dengan mekanisme <em>watch</em>(<em>default</em>), ttl, atau melakukan pengalihan semua
<em>request</em> secara langsung pada kube-apiserver.
Sebagai hasilnya, <em>delay</em> total dari pertama kali Secret diubah hingga dilakukannya mekanisme
proyeksi <em>key</em> yang baru pada Pod berlangsung dalam jangka waktu sinkronisasi periodik kubelet +
<em>delay</em> propagasi <em>cache</em>, dimana <em>delay</em> propagasi <em>cache</em> bergantung pada jenis <em>cache</em> yang digunakan
(ini sama dengan <em>delay</em> propagasi <em>watch</em>, ttl dari <em>cache</em>, atau nol).</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah container menggunakan Secret sebagai
<a href=/id/docs/concepts/storage/volumes#using-subpath>subPath</a> dari <em>volume</em>
yang di-<em>mount</em> tidak akan menerima perubahan Secret.</div><h3 id=menggunakan-secret-sebagai-variabel-environment>Menggunakan Secret sebagai Variabel <em>Environment</em></h3><p>Berikut merupakan langkah-langkah yang harus kamu terapkan,
untuk menggunakan secret sebagai <a class=glossary-tooltip title='Variabel lingkungan Container merupakan pasangan nama=nilai yang dapat digunakan untuk menyediakan informasi penting bagi Container yang dijalankan pada Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment-variables/ target=_blank aria-label='variabel _environment_'>variabel _environment_</a>
pada sebuah Pod:</p><ol><li>Buatlah sebuah Secret, atau gunakan sebuah Secret yang sudah kamu buat sebelumnya. Beberapa Pod dapat merujuk pada sebuah Secret yang sama.</li><li>Modifikasi definisi Pod pada setiap container dimana kamu menginginkan container tersebut dapat mengonsumsi your Pod definition in each container that you wish to consume the value of a secret key to add an environment variabele for each secret key you wish to consume. The environment variabele that consumes the secret key should populate the secret's name and key in <code>env[].valueFrom.secretKeyRef</code>.</li><li>Modifikasi <em>image</em> dan/atau <em>command line</em> kamu agar program yang kamu miliki merujuk pada <em>value</em> yang sudah didefinisikan pada variabel <em>environment</em>.</li></ol><p>Berikut merupakan contoh dimana sebuah Pod menggunakan Secret sebagai variabel <em>environment</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><p><strong>Menggunakan Secret dari Variabel <em>Environment</em></strong></p><p>Di dalam sebuah container yang mengkonsumsi Secret pada sebuah variabel <em>environment</em>, <em>key</em> dari sebuah secret
akan ditampilkan sebagai variabel <em>environment</em> pada umumnya dengan <em>value</em> berupa informasi yang telah di-<em>decode</em>
ke dalam base64. Berikut merupakan hasil yang didapatkan apabila perintah-perintah di bawah ini
dijalankan dari dalam container yang didefinisikan di atas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_USERNAME</span>
</span></span></code></pre></div><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_PASSWORD</span>
</span></span></code></pre></div><pre tabindex=0><code>1f2d1e2e67df
</code></pre><h3 id=menggunakan-imagepullsecrets>Menggunakan imagePullSecrets</h3><p>Sebuah <code>imagePullSecret</code> merupakan salah satu cara yang dapat digunakan untuk menempatkan secret
yang mengandung <em>password</em> dari registri Docker (atau registri <em>image</em> lainnya)
pada Kubelet, sehingga Kubelet dapat mengunduh <em>image</em> dan menempatkannya pada Pod.</p><p><strong>Memberikan spesifikasi manual dari sebuah imagePullSecret</strong></p><p>Penggunaan imagePullSecrets dideskripsikan di dalam <a href=/id/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>dokumentasi <em>image</em></a></p><h3 id=mekanisme-yang-dapat-diterapkan-agar-imagepullsecrets-dapat-secara-otomatis-digunakan>Mekanisme yang Dapat Diterapkan agar imagePullSecrets dapat Secara Otomatis Digunakan</h3><p>Kamu dapat secara manual membuat sebuah imagePullSecret, serta merujuk imagePullSecret
yang sudah kamu buat dari sebuah serviceAccount. Semua Pod yang dibuat dengan menggunakan
serviceAccount tadi atau serviceAccount <em>default</em> akan menerima <em>field</em> imagePullSecret dari
serviceAccount yang digunakan.
Bacalah <a href=/id/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Cara menambahkan ImagePullSecrets pada sebuah <em>service account</em></a>
untuk informasi lebih detail soal proses yang dijalankan.</p><h3 id=mekanisme-mounting-otomatis-dari-secret-yang-sudah-dibuat>Mekanisme <em>Mounting</em> Otomatis dari Secret yang Sudah Dibuat</h3><p>Secret yang dibuat secara manual (misalnya, secret yang mengandung token yang dapat digunakan
untuk mengakses akun GitHub) dapat di-<em>mount</em> secara otomatis pada sebuah Pod berdasarkan <em>service account</em>
yang digunakan oleh Pod tadi.
Baca <a href=/docs/tasks/inject-data-application/podpreset/>Bagaimana Penggunaan PodPreset untuk Memasukkan Informasi ke Dalam Pod</a> untuk informasi lebih lanjut.</p><h2 id=detail>Detail</h2><h3 id=batasan-batasan>Batasan-Batasan</h3><p>Sumber dari <em>secret volume</em> akan divalidasi untuk menjamin rujukan pada
objek yang dispesifikasikan mengarah pada objek dengan <em>type</em> <code>Secret</code>.
Oleh karenanya, sebuah <em>secret</em> harus dibuat sebelum Pod yang merujuk pada <em>secret</em>
tersebut dibuat.</p><p>Sebuah objek API Secret berada di dalam sebuah <a class=glossary-tooltip title='Sebuah abstraksi yang digunakan oleh Kubernetes untuk mendukung multipel klaster virtual pada klaster fisik yang sama.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Objek-objek ini hanya dapat dirujuk oleh Pod-Pod yang ada pada namespace yang sama.</p><p>Secret memiliki batasi dalam hal ukuran maksimalnya yaitu hanya sampai 1MiB per objek.
Oleh karena itulah, pembuatan secret dalam ukuran yang sangat besar tidak dianjurkan
karena dapat menghabiskan sumber daya apiserver dan memori kubelet. Meskipun demikian,
pembuatan banyak secret dengan ukuran kecil juga dapat menhabiskan memori. Pembatasan
sumber daya yang diizinkan untuk pembuatan secret merupakan salah satu fitur tambahan
yang direncanakan kedepannya.</p><p>Kubelet hanya mendukung penggunaan secret oleh Pod apabila Pod tersebut
didapatkan melalui apiserver. Hal ini termasuk Pod yang dibuat dengan menggunakan
kubectl, atau secara tak langsung melalui <em>replication controller</em>. Hal ini tidak
termasuk Pod yang dibuat melalui <em>flag</em> <code>--manifest-url</code> yang ada pada kubelet,
maupun REST API yang disediakan (hal ini bukanlah merupakan mekanisme umum yang dilakukan
untuk membuat sebuah Pod).</p><p>Secret harus dibuat sebelum digunakan oleh Pod sebagai variabel <em>environment</em>,
kecuali apabila variabel <em>environment</em> ini dianggap opsional. Rujukan pada Secret
yang tidak dapat dipenuhi akan menyebabkan Pod gagal <em>start</em>.</p><p>Rujukan melalui <code>secretKeyRef</code> pada <em>key</em> yang tidak ada pada <em>named</em> Secret
akan akan menyebabkan Pod gagal <em>start</em>.</p><p>Secret yang digunakan untuk memenuhi variabel <em>environment</em> melalui <code>envFrom</code> yang
memiliki <em>key</em> yang dianggap memiliki penamaan yang tidak valid akan diabaikan.
Hal ini akan akan menyebabkan Pod gagal <em>start</em>. Selanjutnya akan terdapat <em>event</em>
dengan alasan <code>InvalidvariabeleNames</code> dan pesan yang berisikan <em>list</em> dari
<em>key</em> yang diabaikan akibat penamaan yang tidak valid. Contoh yang ada akan menunjukkan
sebuah pod yang merujuk pada secret <code>default/mysecret</code> yang mengandung dua buah <em>key</em>
yang tidak valid, yaitu 1badkey dan 2alsobad.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><pre tabindex=0><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentvariabeleNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variabele names.
</code></pre><h3 id=interaksi-secret-dan-pod-lifetime>Interaksi Secret dan Pod Lifetime</h3><p>Ketika sebuah pod dibuat melalui API, tidak terdapat mekanisme pengecekan
yang digunakan untuk mengetahui apakah sebuah Secret yang dirujuk sudah dibuat
atau belum. Ketika sebuah Pod di-<em>schedule</em>, kubelet akan mencoba mengambil
informasi mengenai <em>value</em> dari secret tadi. Jika secret tidak dapat diambil
<em>value</em>-nya dengan alasan temporer karena hilangnya koneksi ke API server atau
secret yang dirujuk tidak ada, kubelet akan melakukan mekanisme <em>retry</em> secara periodik.
Kubelet juga akan memberikan laporan mengenai <em>event</em> yang terjadi pada Pod serta alasan
kenapa Pod tersebut belum di-<em>start</em>. Apabila Secret berhasil didapatkan, kubelet
akan membuat dan me-<em>mount</em> volume yang mengandung secret tersebut. Tidak akan ada
container dalam pod yang akan di-<em>start</em> hingga semua volume pod berhasil di-<em>mount</em>.</p><h2 id=contoh-contoh-penggunaan>Contoh-Contoh Penggunaan</h2><h3 id=contoh-penggunaan-pod-dengan-ssh-key>Contoh Penggunaan: Pod dengan <em>ssh key</em></h3><p>Buatlah sebuah kustomization.yaml dengan SecretGenerator yang mengandung beberapa <em>ssh key</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</span></span></code></pre></div><pre tabindex=0><code>secret &#34;ssh-key-secret&#34; created
</code></pre><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Pikirkanlah terlebih dahulu sebelum kamu menggunakan <em>ssh key</em> milikmu sendiri: pengguna lain pada kluster tersebut bisa saja memiliki akses pada secret yang kamu definisikan.
Gunakanlah service account untuk membagi informasi yang kamu inginkan di dalam kluster tersebut, dengan demikian kamu dapat membatalkan service account tersebut apabila secret tersebut disalahgunakan.</div><p>Sekarang, kita dapat membuat sebuah pod yang merujuk pada secret dengan <em>ssh key</em> yang sudah
dibuat tadi serta menggunakannya melalui sebuah volume yang di-<em>mount</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ketika sebuah perintah dijalankan di dalam container, bagian dari <em>key</em> tadi akan
terdapat pada:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/etc/secret-volume/ssh-publickey
</span></span><span style=display:flex><span>/etc/secret-volume/ssh-privatekey
</span></span></code></pre></div><p>container kemudian dapat menggunakan secret secara bebas untuk
membuat koneksi ssh.</p><h3 id=contoh-penggunaan-pod-dengan-kredensial-prod-test>Contoh Penggunaan: Pod dengan kredensial prod / test</h3><p>Contoh ini memberikan ilustrasi pod yang mengonsumsi secret yang mengandung
kredensial dari <em>environment</em> <em>production</em> atau <em>environment</em> <em>test</em>.</p><p>Buatlah suatu kustomization.yaml dengan SecretGenerator</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</span></span></code></pre></div><pre tabindex=0><code>secret &#34;prod-db-secret&#34; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</span></span></code></pre></div><pre tabindex=0><code>secret &#34;test-db-secret&#34; created
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Karakter spesial seperti <code>$</code>, <code>\*</code>, dan <code>!</code> membutuhkan mekanisme <em>escaping</em>.
Jika password yang kamu gunakan memiliki karakter spesial, kamu dapat melakukan mekanisme <em>escape</em>
dengan karakter <code>\\</code> character. Sebagai contohnya, jika <em>password</em> kamu yang sebenarnya adalah
<code>S!B\*d$zDsb</code>, maka kamu harus memanggil perintah eksekusi dengan cara sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>S<span style=color:#b62;font-weight:700>\\</span>!B<span style=color:#b62;font-weight:700>\\\*</span>d<span style=color:#b62;font-weight:700>\\</span><span style=color:#b8860b>$zDsb</span>
</span></span></code></pre></div><p>Kamu tidak perlu melakukan mekanisme <em>escape</em> karakter apabila menggunakan opsi melalui <em>file</em> (<code>--from-file</code>).</p></div><p>Kemudian buatlah Pod-Pod yang dibutuhkan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: List
</span></span></span><span style=display:flex><span><span style=color:#b44>items:
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: prod-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: prod-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: prod-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: test-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: test-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: test-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Tambahkan Pod-Pod terkait pada <em>file</em> kustomization.yaml yang sama</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Terapkan semua perubahan pada objek-objek tadi ke Apiserver dengan menggunakan</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply --k .
</span></span></code></pre></div><p>Kedua container kemudian akan memiliki <em>file-file</em> berikut ini di dalam
<em>filesystem</em> keduanya dengan <em>value</em> sebagai berikut untuk masing-masing <em>environment</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/etc/secret-volume/username
</span></span><span style=display:flex><span>/etc/secret-volume/password
</span></span></code></pre></div><p>Perhatikan bahwa <em>specs</em> untuk kedua pod berbeda hanya pada satu <em>field</em> saja;
hal ini bertujuan untuk memfasilitasi adanya kapabilitas yang berbeda dari templat
konfigurasi umum yang tersedia.</p><p>Kamu dapat mensimplifikasi spesifikasi dasar Pod dengan menggunakan dua buah <em>service account</em> yang berbeda:
misalnya saja salah satunya disebut sebagai <code>prod-user</code> dengan <code>prod-db-secret</code>, dan satunya lagi disebut
<code>test-user</code> dengan <code>test-db-secret</code>. Kemudian spesifikasi Pod tadi dapat diringkas menjadi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=contoh-penggunaan-dotfiles-pada-volume-secret>Contoh Penggunaan: <em>Dotfiles</em> pada volume secret</h3><p>Dengan tujuan membuat data yang ada 'tersembunyi' (misalnya, di dalam sebuah <em>file</em> dengan nama yang dimulai
dengan karakter titik), kamu dapat melakukannya dengan cara yang cukup sederhana, yaitu cukup dengan membuat
karakter awal <em>key</em> yang kamu inginkan dengan titik. Contohnya, ketika sebuah secret di bawah ini di-<em>mount</em>
pada sebuah volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Volume <code>secret-volume</code> akan mengandung sebuah <em>file</em>, yang disebut sebagai <code>.secret-file</code>, serta
container <code>dotfile-test-container</code> akan memiliki <em>file</em> konfigurasinya pada <em>path</em>
<code>/etc/secret-volume/.secret-file</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <em>File-file</em> yang diawali dengan karakter titik akan "tersembunyi" dari keluaran perintah <code>ls -l</code>;
kamu harus menggunakan perintah <code>ls -la</code> untuk melihat <em>file-file</em> tadi dari sebuah direktori.</div><h3 id=contoh-penggunaan-secret-yang-dapat-diakses-hanya-pada-salah-satu-container-di-dalam-pod>Contoh Penggunaan: Secret yang dapat diakses hanya pada salah satu container di dalam pod</h3><p>Misalkan terdapat sebuah program yang memiliki kebutuhan untuk menangani <em>request</em> HTTP,
melakukan logika bisnis yang kompleks, serta kemudian menandai beberapa <em>message</em> yang ada
dengan menggunakan HMAC. Karena program ini memiliki logika aplikasi yang cukup kompleks,
maka bisa jadi terdapat beberapa celah terjadinya eksploitasi <em>remote</em> <em>file</em> pada server,
yang nantinya bisa saja mengekspos <em>private key</em> yang ada pada <em>attacker</em>.</p><p>Hal ini dapat dipisah menjadi dua buah proses yang berbeda di dalam dua container:
sebuah container <em>frontend</em> yang menangani interaksi pengguna dan logika bisnis, tetapi
tidak memiliki kapabilitas untuk melihat <em>private key</em>; container lain memiliki kapabilitas
melihat <em>private key</em> yang ada dan memiliki fungsi untuk menandai <em>request</em> yang berasal
dari <em>frontend</em> (melalui jaringan <em>localhost</em>).</p><p>Dengan strategi ini, seorang <em>attacker</em> harus melakukan teknik tambahan
untuk memaksa aplikasi melakukan hal yang acak, yang kemudian menyebabkan
mekanisme pembacaan <em>file</em> menjadi lebih susah.</p><h2 id=best-practices><em>Best practices</em></h2><h3 id=klien-yang-menggunakan-api-secret>Klien yang menggunakan API secret</h3><p>Ketika men-<em>deploy</em> aplikasi yang berinteraksi dengan API secret, akses yang dilakukan
haruslah dibatasi menggunakan <a href=/docs/reference/access-authn-authz/authorization/><em>policy</em> autorisasi</a> seperti <a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>.</p><p>Secret seringkali menyimpan <em>value</em> yang memiliki jangkauan spektrum
kepentingan, yang mungkin saja dapat menyebabkan terjadinya eskalasi baik
di dalam Kubernetes (misalnya saja token dari sebuah <em>service account</em>) maupun<br>sistem eksternal. Bahkan apabila setiap aplikasi secara individual memiliki
kapabilitas untuk memahami tingkatan yang dimilikinya untuk berinteraksi dengan secret tertentu,
aplikasi lain dalam namespace itu bisa saja menyebabkan asumsi tersebut menjadi tidak valid.</p><p>Karena alasan-alasan yang sudah disebutkan tadi <em>request</em> <code>watch</code> dan <code>list</code> untuk sebuah
secret di dalam suatu namespace merupakan kapabilitas yang sebisa mungkin harus dihindari,
karena menampilkan semua secret yang ada berimplikasi pada akses untuk melihat isi yang ada
pada secret yang ada. Kapabilitas untuk melakukan <em>request</em> <code>watch</code> dan <code>list</code> pada semua secret di kluster
hanya boleh dimiliki oleh komponen pada sistem level yang paling <em>previleged</em>.</p><p>Aplikasi yang membutuhkan akses ke API secret harus melakukan <em>request</em> <code>get</code> pada
secret yang dibutuhkan. Hal ini memungkinkan administrator untuk membatasi
akses pada semua secret dengan tetap memberikan <a href=/id/docs/reference/access-authn-authz/rbac/#referring-to-resources>akses pada instans secret tertentu</a>
yang dibutuhkan aplikasi.</p><p>Untuk meningkatkan performa dengan menggunakan iterasi <code>get</code>, klien dapat mendesain
sumber daya yang merujuk pada suatu secret dan kemudian melakukan <code>watch</code> pada secret tersebut,
serta melakukan <em>request</em> secret ketika terjadi perubahan pada rujukan tadi. Sebagai tambahan, <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/bulk_watch.md>API "bulk watch"</a>
yang dapat memberikan kapabilitas <code>watch</code> individual pada sumber daya melalui klien juga sudah direncanakan,
dan kemungkinan akan diimplementasikan dirilis Kubernetes selanjutnya.</p><h2 id=properti-keamanan>Properti Keamanan</h2><h3 id=proteksi>Proteksi</h3><p>Karena objek <code>secret</code> dapat dibuat secara independen dengan <code>pod</code> yang menggunakannya,
risiko tereksposnya secret di dalam workflow pembuatan, pemantauan, serta pengubahan pod.
Sistem yang ada juga dapat memberikan tindakan pencegahan ketika berinteraksi dengan <code>secret</code>,
misalnya saja tidak melakukan penulisan isi <code>secret</code> ke dalam disk apabila hal tersebut
memungkinkan.</p><p>Sebuah secret hanya diberikan pada node apabila pod yang ada di dalam node
membutuhkan secret tersebut. Kubelet menyimpan secret yang ada pada <code>tmpfs</code>
sehingga secret tidak ditulis pada disk. Setelah pod yang bergantung pada secret tersebut dihapus,
maka kubelet juga akan menghapus salinan lokal data secret.</p><p>Di dalam sebuah node bisa saja terdapat beberapa secret yang dibutuhkan
oleh pod yang ada di dalamnya. Meskipun demikian, hanya secret yang di-<em>request</em>
oleh sebuah pod saja yang dapat dilihat oleh container yang ada di dalamnya.
Dengan demikian, sebuah Pod tidak memiliki akses untuk melihat secret yang ada
pada pod yang lain.</p><p>Di dalam sebuah pod bisa jadi terdapat beberapa container.
Meskipun demikian, agar sebuah container bisa mengakses <em>volume secret</em>, container
tersebut haruslah mengirimkan <em>request</em> <code>volumeMounts</code> yang ada dapat diakses dari
container tersebut. Pengetahuan ini dapat digunakan untuk membentuk <a href=#contoh-penggunaan-secret-yang-dapat-diakses-hanya-pada-salah-satu-container-di-dalam-pod>partisi security
pada level pod</a>.</p><p>Pada sebagian besar distribusi yang dipelihara projek Kubernetes,
komunikasi antara pengguna dan apiserver serta apisserver dan kubelet dilindungi dengan menggunakan SSL/TLS.
Dengan demikian, secret dalam keadaan dilindungi ketika ditransmisi.</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code></div><p>Kamu dapat mengaktifkan <a href=/docs/tasks/administer-cluster/encrypt-data/>enkripsi pada rest</a>
untuk data secret, sehingga secret yang ada tidak akan ditulis ke dalam <a class=glossary-tooltip title='Penyimpanan key value konsisten yang digunakan sebagai penyimpanan data klaster Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>
dalam keadaan tidak terenkripsi.</p><h3 id=resiko>Resiko</h3><ul><li>Pada API server, data secret disimpan di dalam <a class=glossary-tooltip title='Penyimpanan key value konsisten yang digunakan sebagai penyimpanan data klaster Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>;
dengan demikian:<ul><li>Administrator harus mengaktifkan enkripsi pada rest untuk data kluster (membutuhkan versi v1.13 atau lebih)</li><li>Administrator harus membatasi akses etcd pada pengguna dengan kapabilitas admin</li><li>Administrator bisa saja menghapus data disk yang sudah tidak lagi digunakan oleh etcd</li><li>Jika etcd dijalankan di dalam kluster, administrator harus memastikan SSL/TLS
digunakan pada proses komunikasi peer-to-peer etcd.</li></ul></li><li>Jika kamu melakukan konfigurasi melalui sebuah <em>file</em> manifest (JSON or YAML)
yang menyimpan data secret dalam bentuk base64, membagi atau menyimpan secret ini
dalam repositori kode sumber sama artinya dengan memberikan informasi mengenai data secret.
Mekanisme <em>encoding</em> base64 bukanlah merupakan teknik enkripsi dan nilainya dianggap sama saja dengan <em>plain text</em>.</li><li>Aplikasi masih harus melindungi <em>value</em> dari secret setelah membaca nilainya dari suatu volume
dengan demikian risiko terjadinya <em>logging</em> secret secara tidak engaja dapat dihindari.</li><li>Seorang pengguna yang dapat membuat suatu pod yang menggunakan secret, juga dapat melihat <em>value</em> secret.
Bahkan apabila <em>policy</em> apiserver tidak memberikan kapabilitas untuk membaca objek secret, pengguna
dapat menjalankan pod yang mengekspos secret.</li><li>Saat ini, semua orang dengan akses <em>root</em> pada node dapat membaca secret <em>apapun</em> dari apiserver,<br>dengan cara meniru kubelet. Meskipun begitu, terdapat fitur yang direncanakan pada rilis selanjutnya yang memungkinkan pengiriman secret hanya dapat
mengirimkan secret pada node yang membutuhkan secret tersebut untuk membatasi adanya eksploitasi akses <em>root</em> pada node ini.</li></ul><h2 id=selanjutnya>Selanjutnya</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>4 - Mengatur Akses Klaster Menggunakan Berkas kubeconfig</h1><p>Gunakan berkas kubeconfig untuk mengatur informasi mengenai klaster, pengguna,
<em>namespace</em>, dan mekanisme autentikasi. Perintah <code>kubectl</code> menggunakan berkas
kubeconfig untuk mencari informasi yang dibutuhkan untuk memilih klaster dan
berkomunikasi dengan API server dari suatu klaster.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah berkas yang digunakan untuk mengatur akses pada klaster disebut dengan
berkas kubeconfig. Ini cara yang umum digunakan untuk mereferensikan berkas
konfigurasi. Ini tidak berarti ada berkas dengan nama <code>kubeconfig</code>.</div><p>Secara <em>default</em>, <code>kubectl</code> mencari berkas dengan nama <code>config</code> pada direktori
<code>$HOME/.kube</code>. Kamu bisa mengatur lokasi berkas kubeconfig dengan mengatur
nilai <code>KUBECONFIG</code> pada variabel <em>environment</em> atau dengan mengatur menggunakan
tanda <a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>.</p><p>Instruksi langkah demi langkah untuk membuat dan menentukan berkas kubeconfig,
bisa mengacu pada [Mengatur Akses Pada Beberapa Klaster]
(/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters).</p><h2 id=mendukung-beberapa-klaster-pengguna-dan-mekanisme-autentikasi>Mendukung beberapa klaster, pengguna, dan mekanisme autentikasi</h2><p>Misalkan kamu memiliki beberapa klaster, pengguna serta komponen dapat melakukan
autentikasi dengan berbagai cara. Sebagai contoh:</p><ul><li>Kubelet yang berjalan dapat melakukan autentikasi dengan menggunakan sertifikat</li><li>Pengguna bisa melakukan autentikasi dengan menggunakan token</li><li>Administrator bisa memiliki beberapa sertifikat yang diberikan kepada pengguna
individu.</li></ul><p>Dengan berkas kubeconfig, kamu bisa mengatur klaster, pengguna, dan <em>namespace</em>.
Kamu juga bisa menentukan konteks untuk mempercepat dan mempermudah perpindahan
antara klaster dan <em>namespace</em>.</p><h2 id=konteks>Konteks</h2><p>Sebuah elemen konteks pada berkas kubeconfig digunakan untuk mengelompokkan
parameter akses dengan nama yang mudah. Setiap konteks akan memiliki 3 parameter:
klaster, pengguna, dan <em>namespace</em>. Secara <em>default</em>, perintah <code>kubectl</code> menggunakan
parameter dari konteks yang aktif untuk berkomunikasi dengan klaster.</p><p>Untuk memilih konteks yang aktif, bisa menggunakan perintah berikut:</p><pre tabindex=0><code>kubectl config use-context
</code></pre><h2 id=variabel-environment-kubeconfig>Variabel <em>environment</em> KUBECONFIG</h2><p>Variabel <em>environment</em> <code>KUBECONFIG</code> berisikan beberapa berkas kubeconfig. Untuk
Linux dan Mac, beberapa berkas tersebut dipisahkan dengan tanda titik dua (:).
Untuk Windows, dipisahkan dengan menggunakan tanda titik koma (;). Variabel
<em>environment</em> <code>KUBECONFIG</code> tidak diwajibkan untuk ada. Jika variabel <em>environment</em>
<code>KUBECONFIG</code> tidak ada, maka <code>kubectl</code> akan menggunakan berkas kubeconfig pada
<code>$HOME/.kube/config</code>.</p><p>Jika variabel <em>environment</em> <code>KUBECONFIG</code> ternyata ada, maka <code>kubectl</code> akan menggunakan
konfigurasi yang merupakan hasil gabungan dari berkas-berkas yang terdapat pada
variabel <em>environment</em> <code>KUBECONFIG</code>.</p><h2 id=menggabungkan-berkas-berkas-kubeconfig>Menggabungkan berkas-berkas kubeconfig</h2><p>Untuk melihat konfigurasimu, gunakan perintah berikut ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>Seperti yang dijelaskan sebelumnya, hasil perintah diatas bisa berasal dari sebuah
berkas kubeconfig, atau bisa juga merupakan hasil gabungan dari beberapa berkas kubeconfig.</p><p>Berikut adalah aturan yang digunakan <code>kubectl</code> ketika menggabungkan beberapa berkas
kubeconfig:</p><ol><li><p>Jika menggunakan tanda <code>--kubeconfig</code>, maka akan menggunakan berkas yang ditentukan.
Tidak digabungkan. Hanya 1 tanda <code>--kubeconfig</code> yang diperbolehkan.</p><p>Sebaliknya, jika variabel <em>environment</em> <code>KUBECONFIG</code> digunakan, maka akan menggunakan
ini sebagai berkas-berkas yang akan digabungkan. Penggabungan berkas-berkas yang terdapat
pada variabel <em>environment</em> <code>KUBECONFIG</code> akan mengikuti aturan sebagai berikut:</p><ul><li>Mengabaikan berkas tanpa nama.</li><li>Mengeluarkan pesan kesalahan untuk berkas dengan isi yang tidak dapat dideserialisasi.</li><li>Berkas pertama yang menentukan nilai atau <em>key</em> pada <em>map</em> maka akan digunakan
pada <em>map</em> tersebut.</li><li>Tidak pernah mengubah nilai atau <em>key</em> dari suatu <em>map</em>.
Contoh: Pertahankan konteks pada berkas pertama yang mengatur <code>current-context</code>.
Contoh: Jika terdapat dua berkas yang menentukan nilai <code>red-user</code>, maka hanya gunakan
nilai <code>red-user</code> dari berkas pertama.
Meskipun berkas kedua tidak memiliki entri yang bertentangan pada <code>red-user</code>,
abaikan mereka.</li></ul><p>Beberapa contoh pengaturan variabel <em>environment</em> <code>KUBECONFIG</code>, bisa melihat pada
<a href=/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>pengaturan vaiabel <em>environment</em> KUBECONFIG</a>.</p><p>Sebaliknya, bisa menggunakan berkas kubeconfig <em>default</em>, <code>$HOME/.kube/config</code>,
tanpa melakukan penggabungan.</p></li><li><p>Konteks ditentukan oleh yang pertama sesuai dari pilihan berikut:</p><ol><li>Menggunakan tanda <code>--context</code> pada perintah</li><li>Menggunakan nilai <code>current-context</code> dari hasil gabungan berkas kubeconfig.</li></ol><p>Konteks yang kosong masih diperbolehkan pada tahap ini.</p></li><li><p>Menentukan klaster dan pengguna. Pada tahap ini, mungkin akan ada atau tidak ada konteks.
Menentukan klaster dan pengguna berdasarkan yang pertama sesuai dengan pilihan berikut,
yang mana akan dijalankan dua kali: sekali untuk pengguna dan sekali untuk klaster:</p><ol><li>Jika ada, maka gunakan tanda pada perintah: <code>--user</code> atau <code>--cluster</code>.</li><li>Jika konteks tidak kosong, maka pengguna dan klaster didapat dari konteks.</li></ol><p>Pengguna dan klaster masih diperbolehkan kosong pada tahap ini.</p></li><li><p>Menentukan informasi klaster sebenarnya yang akan digunakan. Pada tahap ini, mungkin
akan ada atau tidak ada informasi klaster. Membentuk informasi klaster berdasarkan urutan
berikut dan yang pertama sesuai akan digunakan:</p><ol><li>Jika ada, maka gunakan tanda pada perintah: <code>--server</code>, <code>--certificate-authority</code>, <code>--insecure-skip-tls-verify</code>.</li><li>Jika terdapat atribut informasi klaster dari hasil gabungan berkas kubeconfig,
maka gunakan itu.</li><li>Jika tidak terdapat informasi mengenai lokasi server, maka dianggap gagal.</li></ol></li><li><p>Menentukan informasi pengguna sebenarnya yang akan digunakan. Membentuk informasi
pengguna dengan aturan yang sama dengan pembentukan informasi klaster, namun hanya
diperbolehkan ada satu teknik autentikasi untuk setiap pengguna:</p><ol><li>Jika ada, gunakan tanda pada perintah: <code>--client-certificate</code>, <code>--client-key</code>, <code>--username</code>, <code>--password</code>, <code>--token</code>.</li><li>Menggunakan <em>field</em> <code>user</code> dari hasil gabungan berkas kubeconfig.</li><li>Jika terdapat dua teknik yang bertentangan, maka dianggap gagal.</li></ol></li><li><p>Untuk setiap informasi yang masih belum terisi, akan menggunakan nilai <code>default</code> dan
kemungkinan akan meminta informasi autentikasi.</p></li></ol><h2 id=referensi-berkas>Referensi berkas</h2><p>Referensi <em>file</em> dan <em>path</em> pada berkas kubeconfig adalah bernilai relatif terhadap
lokasi dari berkas kubeconfig.
Referensi <em>file</em> pada perintah adalah relatif terhadap direktori kerja saat ini.
Dalam <code>$HOME/.kube/config</code>, <em>relative path</em> akan disimpan secara relatif, dan
<em>absolute path</em> akan disimpan secara mutlak.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Mengatur Akses Pada Beberapa Klaster</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ed4ae5e4344d619bc6df6e1278efae74>5 - Prioritas dan Pemindahan Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.14 [stable]</code></div><p><a href=/docs/user-guide/pods>Pod</a> dapat memiliki <em>priority</em> (prioritas). Priority mengindikasikan lebih penting atau tidaknya sebuah Pod dibandingkan dengan Pod-pod lainnya. Jika sebuah Pod tidak dapat dijadwalkan (tertunda/<em>pending</em>), penjadwal akan mencoba untuk melakukan <em>preemption</em>/pemindahan (mengusir/<em>evict</em>) Pod-pod dengan prioritas lebih rendah agar penjadwalan Pod yang tertunda sebelumnya dapat dilakukan.</p><p>Pada Kubernetes 1.9 dan sesudahnya, Priority juga memengaruhi urutan penjadwalan Pod-pod dan urutan pengusiran Pod-pod dari Node pada kasus kehabisan sumber daya.</p><p>Priority dan Pemindahan Pod lulus menjadi <em>beta</em> pada Kubernetes 1.11 dan menjadi GA (<em>Generally Available</em>) pada Kubernetes 1.14. Mereka telah dihidupkan secara bawaan sejak versi 1.11.</p><p>Pada versi-versi Kubernetes di mana Priority dan pemindahan Pod masih berada pada tingkat fitur <em>alpha</em>, kamu harus menghidupkannya secara eksplisit. Untuk menggunakan fitur-fitur pada versi-versi lama Kubernetes, ikuti petunjuk di dokumentasi versi Kubernetes kamu, melalui arsip versi dokumentasi untuk versi Kubernetes kamu.</p><table><thead><tr><th>Versi Kubernetes</th><th style=text-align:center>Keadaan Priority and Pemindahan</th><th style=text-align:center>Dihidupkan secara Bawaan</th></tr></thead><tbody><tr><td>1.8</td><td style=text-align:center>alpha</td><td style=text-align:center>tidak</td></tr><tr><td>1.9</td><td style=text-align:center>alpha</td><td style=text-align:center>tidak</td></tr><tr><td>1.10</td><td style=text-align:center>alpha</td><td style=text-align:center>tidak</td></tr><tr><td>1.11</td><td style=text-align:center>beta</td><td style=text-align:center>ya</td></tr><tr><td>1.14</td><td style=text-align:center>stable</td><td style=text-align:center>ya</td></tr></tbody></table><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Pada sebuah klaster di mana tidak semua pengguna dipercaya, seorang pengguna yang berniat jahat dapat membuat Pod-pod dengan prioritas paling tinggi, membuat Pod-pod lainnya dipindahkan/tidak dapat dijadwalkan. Untuk mengatasi masalah ini, <a href=/id/docs/concepts/policy/resource-quotas/>ResourceQuota</a> ditambahkan untuk mendukung prioritas Pod. Seorang admin dapat membuat ResourceQuota untuk pengguna-pengguna pada tingkat prioritas tertentu, mencegah mereka untuk membuat Pod-pod pada prioritas tinggi. Fitur ini telah beta sejak Kubernetes 1.12.</div><h2 id=bagaimana-cara-menggunakan-priority-dan-pemindahan-pod>Bagaimana cara menggunakan Priority dan pemindahan Pod</h2><p>Untuk menggunakan Priority dan pemindahan Pod pada Kubernetes 1.11 dan sesudahnya, ikuti langkah-langkah berikut:</p><ol><li><p>Tambahkan satu atau lebih <a href=#priorityclass>PriorityClass</a>.</p></li><li><p>Buat Pod-pod dengan <a href=#prioritas-pod><code>priorityClassName</code></a>
disetel menjadi salah satu dari PriorityClass yang ditambahkan.
Tentu saja kamu tidak perlu membuat Pod-pod tersebut secara langsung;
Biasanya kamu akan menambahkan <code>priorityClassName</code> pada
<code>template</code> Pod dari sebuah objek kumpulan seperti sebuah Deployment.</p></li></ol><p>Teruslah membaca untuk lebih banyak informasi mengenai langkah-langkah tersebut.</p><p>Jika kamu mencoba fitur ini dan memutuskan untuk mematikannya, kamu harus menghapus <em>command-line flag</em> PodPriority atau menyetelnya menjadi <code>false</code>, kemudian melakukan pengulangan kembali terhadap API Server dan Scheduler. Setelah fitur ini dimatikan, Pod-pod yang sudah ada tetap akan memiliki kolom priority mereka, tetapi pemindahan Pod akan dimatikan, dan kolom-kolom priority tersebut diabaikan. Jika fitur tersebut telah dimatikan, kamu tidak dapat menyetel kolom <code>priorityClassName</code> pada Pod-pod baru.</p><h2 id=cara-mematikan-pemindahan-pod>Cara mematikan pemindahan Pod</h2><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pada Kubernetes 1.12 ke atas, Pod-pod yang penting mengandalkan oleh Schneduler agar dapat dijadwalkan saat klaster berada pada kondisi kekurangan sumber daya. Untuk alasan ini, tidak direkomendasikan untuk mematikan fitur pemindahan Pod.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pada Kubernetes 1.15 ke atas, jika fitur <code>NonPreemptingPriority</code> diaktifkan, PriorityClass memiliki pilihan untuk menyetel <code>preemptionPolicy: Never</code>.
Hal ini akan mencegah Pod-pod dari PriorityClass tersebut untuk memicu pemindahan Pod-pod lainnya.</div><p>Pada Kubernetes 1.11 dan sesudahnya, pemindahan Pod dikontrol oleh sebuah <em>flag</em> kube-scheduler yaitu <code>disablePreemption</code>, yang disetel menjadi <code>false</code> secara bawaan. Jika kamu ingin mematikan pemindahan Pod meskipun ada catatan di atas, kamu dapat menyetel <code>disablePreemption</code> menjadi <code>true</code>.</p><p>Opsi ini hanya tersedia pada (berkas) konfigurasi komponen saja, dan tidak tersedia pada cara lama melalui <em>command line options</em>. Berikut contoh konfigurasi komponen untuk mematikan pemindahan (<em>preemption</em>) Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>algorithmSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>provider</span>:<span style=color:#bbb> </span>DefaultProvider<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>disablePreemption</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=priorityclass>PriorityClass</h2><p>Sebuah PriorityClass adalah sebuah objek tanpa Namespace yang mendefinisikan pemetaan dari sebuah nama kelas prioritas menjadi nilai <em>integer</em> dari prioritas tersebut. Nama tersebut dirinci pada kolom <code>name</code> dari <code>metadata</code> objek PriorityClass tersebut. Nilainya dirinci pada kolom <code>value</code> yang diperlukan. Semakin tinggi nilainya, maka semakin tinggi juga prioritasnya.</p><p>Sebuah objek PriorityClass dapat memiliki nilai <em>integer</em> 32-bit apa pun yang kurang dari atau sama dengan 1 miliar. Angka-angka yang lebih besar dicadangkan untuk Pod-pod pada sistem yang sangat penting yang secara normal sebaiknya tidak dipindahkan atau diusir. Seorang admin klaster sebaiknya membuat sebuah objek PriorityClass untuk setiap pemetaan seperti ini yang ia inginkan.</p><p>PriorityClass juga memiliki dua kolom opsional: <code>globalDefault</code> dan <code>description</code>. Kolom <code>globalDefault</code> mengindikasikan bahwa nilai PriorityClass ini sebaiknya digunakan tanpa sebuah <code>priorityClassName</code>. Hanya sebuah PriorityClass dengan <code>globalDefault</code> disetel menjadi <code>true</code> dapat berada pada sistem/klaster. Jika tidak ada PriorityClass dengan <code>globalDefault</code> yang telah disetel, prioritas Pod-pod tanpa <code>priorityClassName</code> adalah nol.</p><p>Kolom <code>description</code> adalah <em>string</em> yang sembarang. Kolom ini diperuntukkan untuk memberitahukan pengguna-pengguna klaster kapan mereka harus menggunakan PriorityClass ini.</p><h3 id=catatan-mengenai-podpriority-dan-klaster-klaster-yang-sudah-ada>Catatan mengenai PodPriority dan Klaster-klaster yang sudah ada</h3><ul><li><p>Jika kamu meningkatkan versi klaster kamu dan menghidupkan fitur ini, prioritas
Pod-pod kamu yang sudah ada akan secara efektif menjadi nol.</p></li><li><p>Penambahan dari sebuah PriorityClass dengan <code>globalDefault</code> yang disetel menjadi
<code>true</code> tidak mengubah prioritas-prioritas Pod-pod yang sudah ada. Nilai dari
PriorityClass semacam ini digunakan hanya untuk Pod-pod yang dibuat setelah
PriorityClass tersebut ditambahkan.</p></li><li><p>Jika kamu menghapus sebuah PriorityClass, Pod-pod yang sudah ada yang menggunakan
nama dari PriorityClass yang dihapus tersebut tidak akan berubah, tetapi kamu tidak
dapat membuat lebih banyak Pod yang menggunakan nama dari PriorityClass yang telah
dihapus tersebut.</p></li></ul><h3 id=contoh-priorityclass>Contoh PriorityClass</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Kelas prioritas ini sebaiknya hanya digunakan untuk Pod-pod layanan XYZ saja.&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=non-preempting-priority-class>PriorityClass yang <em>Non-preempting</em> (alpha)</h3><p>Kubernetes 1.15 menambahkan kolom <code>PreemptionPolicy</code> sebagai sebuah fitur <em>alpha</em>. Fitur ini dimatikan secara bawaan pada 1.15, dan membutuhkan diaktifkannya <a href=/docs/reference/command-line-tools-reference/feature-gates/><em>feature gate</em></a> <code>NonPreemptingPriority</code>.</p><p>Pod-pod dengan <code>PreemptionPolicy: Never</code> akan ditaruh pada antrean penjadwalkan mendahului Pod-pod dengan prioritas rendah, tetapi mereka tidak dapat memicu pemindahan Pod-pod lainnya (disebut juga Pod yang <em>non-preempting</em>).
Sebuah Pod yang <em>non-preempting</em> yang sedang menunggu untuk dijadwalkan akan tetap berada pada antrean penjadwalan, hingga sumber daya yang cukup tersedia, dan ia dapat dijadwalkan. Pod yang <em>non-preempting</em>, seperti Pod-pod lainnya, tunduk kepada <em>back-off</em> dari Scheduler. Hal ini berarti bahwa jika Scheduler mencoba untuk menjadwalkan Pod-pod ini dan mereka tidak dapat dijadwalkan, mereka akan dicoba kembali dengan frekuensi (percobaan) yang lebih rendah, memungkinkan Pod-pod lain dengan prioritas yang lebih rendah untuk dijadwalkan sebelum mereka dijadwalkan.</p><p>Pod yang <em>non-preempting</em> tetap dapat dipicu untuk dipindahkan oleh Pod lainnya yang memiliki prioritas yang lebih tinggi.</p><p><code>PreemptionPolicy</code> secara bawaan nilainya <code>PreemptionLowerPriority</code>, yang memungkinkan Pod-pod dengan PriorityClass tersebut untuk memicu pemindahan Pod-pod dengan prioritas lebih rendah (sama seperti sifat bawaan). Jika <code>PreemptionPolicy</code> disetel menjadi <code>Never</code>, Pod-pod pada PriorityClass tersebut akan menjadi Pod yang <em>non-preempting</em>.</p><p>Sebuah contoh kasus misalnya pada beban kerja <em>data science</em>.
Seorang pengguna dapat memasukkan sebuah beban kerja yang mereka ingin prioritaskan di atas beban kerja lainnya, tetapi tidak ingin menghapus beban kerja yang sudah ada melalui pemicuan pemindahan Pod-pod yang sedang berjalan.
Beban kerja prioritas tinggi dengan <code>PreemptionPolicy: Never</code> akan dijadwalkan mendahului Pod-pod lainnya yang berada dalam antrean, segera setelah sumber daya klaster "secara alami" menjadi cukup.</p><h4 id=contoh-priorityclass-yang-non-preempting>Contoh PriorityClass yang <em>Non-preempting</em></h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority-nonpreempting<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preemptionPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Kelas prioritas ini tidak akan memicu pemindahan Pod-pod lainnya.&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=prioritas-pod>Prioritas Pod</h2><p>Setelah kamu memiliki satu atau lebih PriorityClass, kamu dapat membuat Pod-pod yang merinci satu dari nama-nama PriorityClass tersebut pada spesifikasi mereka. Admission Controller prioritas menggunakan kolom <code>priorityClassName</code> dan mengumpulkan nilai <em>integer</em> dari prioritasnya. Jika PriorityClass-nya tidak ditemukan, maka Pod tersebut akan ditolak.</p><p>YAML berikut adalah contoh sebuah konfigurasi Pod yang menggunakan PriorityClass yang telah dibuat pada contoh sebelumnya. Admission Controller prioritas akan memeriksa spesifikasi tersebut dan memetakan prioritas Pod tersebut menjadi nilai 1000000.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=efek-prioritas-pod-terhadap-urutan-penjadwalan>Efek prioritas Pod terhadap urutan penjadwalan</h3><p>Pada Kubernetes 1.9 dan sesudahnya, saat prioritas Pod dihidupkan, Scheduler mengurutkan Pod-pod yang tertunda berdasarkan prioritas mereka dan sebuah Pod yang tertunda diletakkan mendahului Pod-pod tertunda lainnya yang memiliki prioritas yang lebih rendah pada antrean penjadwalan. Sebagai hasilnya, Pod dengan prioritas lebih tinggi dapat dijadwalkan lebih awal daripada Pod-pod dengan prioritas yang lebih rendah jika syarat penjadwalan terpenuhi. Jika Pod ini tidak dapat dijadwalkan, Scheduler akan melewatkannya dan mencoba untuk menjadwalkan Pod-pod lain dengan prioritas yang lebih rendah.</p><h2 id=pemindahan-pod>Pemindahan Pod</h2><p>Saat Pod-pod dibuat, mereka masuk ke sebuah antrean dan menunggu untuk dijadwalkan. Scheduler memilih sebuah Pod dari antrean dan mencoba untuk menjadwalkannya pada sebuah Node. Jika tidak ditemukan Node yang memenuhi semua kebutuhan Pod tersebut, logika program pemindahan Pod dipicu untuk Pod yang tertunda tersebut. Kita akan menyebut Pod tertunda tersebut dengan P. Logika program pemindahan Pod mencoba untuk menemukan sebuah Node di mana penghapusan dari satu atau lebih Pod dengan prioritas yang lebih rendah daripada P dapat memungkinkan P untuk dijadwalkan pada Node tersebut. Jika Node tersebut ditemukan, satu atau lebih Pod dengan prioritas lebih rendah akan dipindahkan dari Node tersebut. Setelah Pod-pod tersebut dihapus, P dapat dijadwalkan pada Node tersebut.</p><h3 id=informasi-yang-diekspos-pengguna>Informasi yang diekspos pengguna</h3><p>Saat Pod P memicu pemindahan satu atau lebih Pod pada Node N, kolom <code>nominatedNodeName</code> pada status Pod P disetel menjadi nama dari node N. Kolom ini membantu Scheduler untuk melacak sumber daya yang dicadangkan untuk Pod P dan juga memberikan informasi mengenai pemindahan Pod pada klaster untuk pengguna-pengguna.</p><p>Harap catat bahwa Pod P tidak harus dijadwalkan pada "<em>nominated</em> Node" (Node yang dicalonkan) tersebut. Setelah Pod-pod yang terpilih telah dipindahkan, mereka akan mendapatkan periode penghentian secara sopan (<em>graceful</em>) mereka. Jika Node lain menjadi tersedia saat Scheduler sedang menunggu penghentian Pod-pod yang terpilih untuk dipindahkan, Scheduler akan menggunakan Node lain tersebut untuk menjadwalkan Pod P. Sebagai hasilnya <code>nominatedNodeName</code> dan <code>nodeName</code> dari spesifikasi Pod belum tentu selalu sama. Juga, jika Scheduler memindahkan Pod-pod pada Node N, tapi kemudian sebuah Pod lain dengan prioritas lebih tinggi daripada Pod P tiba, Scheduler boleh memberikan Node N kepada Pod dengan prioritas lebih tinggi tersebut. Pada kasus demikian, Scheduler menghapus <code>nominatedPodName</code> dari Pod P. Dengan melakukan ini, Scheduler membuat Pod P berhak untuk memicu pemindahan Pod-pod lain pada Node lain.</p><h3 id=batasan-batasan-pemindahan-pod>Batasan-batasan pemindahan Pod</h3><h4 id=penghentian-secara-sopan-dari-korban-korban-pemindahan-pod>Penghentian secara sopan dari korban-korban pemindahan Pod</h4><p>Saat Pod-pod dipindahkan, korban-korbannya mendapatkan <a href=/id/docs/concepts/workloads/pods/pod/#penghentian-pod>periode penghentian secara sopan</a>. Mereka memiliki waktu sebanyak itu untuk menyelesaikan pekerjaan merekan dan berhenti. Jika mereka tidak menyelesaikannya sebelum waktu tersebut, mereka akan dihentikan secara paksa. Periode penghentian secara sopan ini membuat sebuah jarak waktu antara saat di mana Scheduler memindahkan Pod-pod dengan waktu saat Pod yang tertunda tersebut (P) dapat dijadwalkan pada Node tersebut (N). Sementara itu, Scheduler akan terus menjadwalkan Pod-pod lain yang tertunda. Oleh karena itu, biasanya ada jarak waktu antara titik di mana Scheduler memindahkan korban-korban dan titik saat Pod P dijadwalkan. Untuk meminimalkan jarak waktu ini, kamu dapat menyetel periode penghentian secara sopan dari Pod-pod dengan prioritas lebih rendah menjadi nol atau sebuah angka yang kecil.</p><h4 id=poddisruptionbudget-didukung-tapi-tidak-dijamin>PodDisruptionBudget didukung, tapi tidak dijamin!</h4><p>Sebuah <a href=/id/docs/concepts/workloads/pods/disruptions/>Pod Disruption Budget (PDB)</a> memungkinkan pemilik-pemilik aplikasi untuk membatasi jumlah Pod-pod dari sebuah aplikasi yang direplikasi yang mati secara bersamaan dikarenakan disrupsi yang disengaja. Kubernetes 1.9 mendukung PDB saat memindahkan Pod-pod, tetapi penghormatan terhadap PDB ini bersifat "usaha terbaik" (<em>best-effort</em>). Scheduler akan mencoba mencari korban-korban yang PDB-nya tidak dilanggar oleh pemindahan, tetapi jika tidak ada korban yang ditemukan, pemindahan akan tetap terjadi, dan Pod-pod dengan prioritas lebih rendah akan dihapus/dipindahkan meskipun PDB mereka dilanggar.</p><h4 id=afinitas-antar-pod-pada-pod-pod-dengan-prioritas-lebih-rendah>Afinitas antar-Pod pada Pod-pod dengan prioritas lebih rendah</h4><p>Sebuah Node akan dipertimbangkan untuk pemindahan Pod hanya jika jawaban pertanyaan berikut adalah "ya": "Jika semua Pod-pod dengan prioritas lebih rendah dari Pod yang tertunda dipindahkan dari Node, dapatkan Pod yang tertunda tersebut dijadwalkan (secara sukses) ke Node tersebut?"</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pemindahan Pod tidak harus memindahkan semua Pod-pod dengan prioritas lebih rendah. Jika Pod yang tertunda dapat dijadwalkan dengan memindahkan lebih sedikit daripada semua Pod-pod dengan prioritas yang lebih rendah, maka hanya sebagian dari Pod-pod dengan prioritas lebih rendah tersebut akan dipindahkan. Meskipun demikian, jawaban untuk pertanyaan sebelumnya haruslah "ya". Jika jawabannya adalah "tidak", maka Node tersebut tidak akan dipertimbangkan untuk pemindahan Pod.</div><p>Jika sebuah Pod yang tertunda memiliki afinitas antar-Pod terhadap satu atau lebih dari Pod-pod dengan prioritas lebih rendah pada Node tersebut, maka aturan afinitas antar-Pod tersebut tidak dapat terpenuhi tanpa hadirnya Pod-pod dengan prioritas lebih rendah tersebut. Pada kasus ini, Scheduler tidak melakukan pemindahan terhadap Pod-pod manapun pada Node tersebut. Sebagai gantinya, ia mencari Node lainnya. Scheduler mungkin mendapatkan Node yang cocok atau tidak. Tidak ada jaminan bahwa Pod yang tertunda tersebut dapat dijadwalkan.</p><p>Solusi yang direkomendasikan untuk masalah ini adalah dengan cara membuat afinitas antar-Pod hanya terhadap Pod-pod dengan prioritas yang sama atau lebih tinggi.</p><h4 id=pemindahan-pod-antar-node>Pemindahan Pod antar Node</h4><p>Misalnya sebuah Node N sedang dipertimbangkan untuk pemindahan Pod sehingga sebuah Pod P yang tertunda dapat dijadwalkan pada N. P mungkin menjadi layak untuk N hanya jika sebuah Pod pada Node lain dipindahkan. Berikut sebuah contoh:</p><ul><li>Pod P dipertimbangkan untuk Node N.</li><li>Pod Q sedang berjalan pada Node lain pada Zona yang sama dengan Node N.</li><li>Pod P memiliki anti-afinitas yang berlaku pada seluruh Zona terhadap Pod Q (<code>topologyKey: topology.kubernetes.io/zone</code>).</li><li>Tidak ada kasus anti-afinitas lain antara Pod P dengan Pod-pod lainnya pada Zona tersebut.</li><li>Untuk dapat menjadwalkan Pod P pada Node N, Pod Q dapat dipindahkan, tetapi
Scheduler tidak melakukan pemindahan Pod antar Node. Jadi, Pod P akan
dianggap tidak dapat dijadwalkan pada Node N.</li></ul><p>Jika Pod Q dihapus dari Node-nya, pelanggaran terhadap anti-afinitas Pod tersebut akan hilang, dan Pod P dapat dijadwalkan pada Node N.</p><p>Kita mungkin mempertimbangkan untuk menambahkan pemindahan Pod antar Node pada versi-versi yang akan datang jika ada permintaan yang cukup dari pengguna, dan kami menemukan algoritma dengan kinerja yang layak.</p><h2 id=memecahkan-masalah-pada-prioritas-dan-pemindahan-pod>Memecahkan masalah pada Prioritas dan Pemindahan Pod</h2><p>Prioritas dan Pemindahan Pod adalah sebuah fitur besar yang berpotensi dapat mengganggu penjadwalan Pod jika fitur ini memiliki kesalahan (<em>bug</em>).</p><h3 id=masalah-yang-berpotensi-diakibatkan-oleh-prioritas-dan-pemindahan-pod>Masalah yang berpotensi diakibatkan oleh Prioritas dan Pemindahan Pod</h3><p>Berikut adalah beberapa masalah yang dapat diakibatkan oleh kesalahan-kesalahan pada implementasi fitur ini. Daftar ini tidak lengkap.</p><h4 id=pod-pod-dipindahkan-secara-tidak-perlu>Pod-pod dipindahkan secara tidak perlu</h4><p>Pemindahan Pod menghapus Pod-pod yang sudah ada dari sebuah klaster yang sedang mengalami kekurangan sumber daya untuk menyediakan ruangan untuk Pod-pod tertunda yang memiliki prioritas yang lebih tinggi. Jika seorang pengguna memberikan prioritas-prioritas tinggi untuk Pod-pod tertentu dengan tidak semestinya (karena kesalahan), Pod-pod prioritas tinggi yang tidak disengaja tersebut dapat mengakibatkan pemindahan Pod-pod pada klaster tersebut. Seperti disebutkan di atas, prioritas Pod dispesifikasikan dengan menyetel kolom <code>priorityClassName</code> dari <code>podSpec</code>. Nilai <em>integer</em> dari prioritas tersebut kemudian dipetakan dan diisi pada kolom <code>priority</code> dari <code>podSpec</code>.</p><p>Untuk menyelesaikan masalah tersebut, <code>priorityClassName</code> dari Pod-pod tersebut harus diubah untuk menggunakan kelas dengan prioritas yang lebih rendah, atau dibiarkan kosong saja. Kolom <code>priorityClassName</code> yang kosong dipetakan menjadi nol secara bawaan.</p><p>Saat sebuah Pod dipindahkan, akan ada <em>Event</em> yang direkam untuk Pod yang dipindahkan tersebut. Pemindahan seharusnya hanya terjadi saat sebuah klaster tidak memiliki sumber daya yang cukup untuk sebuah Pod. Pada kasus seperti ini, pemindahan terjadi hanya saat prioritas dari Pod yang tertunda tersebut lebih tinggi daripada Pod-pod korban. Pemindahan tidak boleh terjadi saat tidak ada Pod yang tertunda (<em>preemptor</em>), atau saat Pod-pod yang tertunda memiliki prioritas yang sama atau lebih rendah dari korban-korbannya. Jika pemindahan terjadi pada skenario demikian, mohon daftarkan sebuah Issue.</p><h4 id=pod-pod-dipindahkan-tetapi-preemptor-tidak-dijadwalkan>Pod-pod dipindahkan, tetapi <em>preemptor</em> tidak dijadwalkan</h4><p>Saat Pod-pod dijadwalkan, mereka menerima periode penghentian secara sopan mereka, yang secara bawaan bernilai 30 detik, tetapi dapat bernilai apa pun sesuai dengan yang disetel pada PodSpec. Jika Pod-pod korban tidak berhenti sebelum periode ini, mereka akan dihentikan secara paksa. Saat semua korban telah pergi, Pod <em>preemptor</em> dapat dijadwalkan.</p><p>Saat Pod <em>preemptor</em> sedang menunggu korban-korban dipindahkan, sebuah Pod dengan prioritas lebih tinggi boleh dibuat jika muat pada Node yang sama. Pada kasus ini, Scheduler akan menjadwalkan Pod dengan prioritas lebih tinggi tersebut alih-alih menjadwalkan Pod <em>preemptor</em>.</p><p>Dalam ketidakhadiran Pod dengan prioritas lebih tinggi tersebut, kita mengharapkan Pod <em>preemptor</em> dijadwalkan setelah periode penghentian secara sopan korban-korbannya telah berakhir.</p><h4 id=pod-pod-dengan-prioritas-lebih-tinggi-dipindahkan-karena-pod-pod-dengan-prioritas-lebih-rendah>Pod-pod dengan prioritas lebih tinggi dipindahkan karena Pod-pod dengan prioritas lebih rendah</h4><p>Saat Scheduler mencoba mencari Node-node yang dapat menjalankan sebuah Pod yang tertunda, dan tidak ada Node yang ditemukan, ia akan mencoba untuk memindahkan Pod-pod dengan prioritas lebih rendah dari salah satu Node untuk menyediakan ruangan untuk Pod yang tertunda tersebut. Jika sebuah Node dengan Pod-pod dengan prioritas lebih rendah tidak layak untuk menjalankan Pod yang tertunda tersebut, Scheduler mungkin memilih Node lain dengan Pod yang memiliki prioritas lebih tinggi (dibandingkan dengan Pod-pod pada Node lain tadi) untuk dipindahkan. Korban-korban tersebut harus tetap memiliki prioritas yang lebih rendah dari Pod <em>preemptor</em>.</p><p>Saat ada beberapa Node yang tersedia untuk pemindahan, Scheduler mencoba untuk memilih Node dengan kumpulan Pod yang memiliki prioritas paling rendah. Namun, jika Pod-pod tersebut memiliki PodDisruptionBudget yang akan dilanggar apabila mereka dipindahkan, maka Scheduler akan memilih Node lain dengan Pod-pod yang memiliki prioritas lebih tinggi.</p><p>Saat ada beberapa Node tersedia untuk pemindahan dan tidak ada satupun skenario di atas yang berlaku, kita mengharapkan Scheduler memilih Node dengan prioritas paling rendah. Apabila hal tersebut tidak terjadi, hal ini mungkin menunjukkan bahwa terdapat kesalahan pada Scheduler.</p><h2 id=interaksi-interaksi-prioritas-pod-dan-qos>Interaksi-interaksi prioritas Pod dan QoS</h2><p>Prioritas Pod dan <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/resource-qos.md>QoS</a> adalah dua fitur terpisah dengan interaksi yang sedikit dan tidak ada batasan bawaan terhadap penyetelan prioritas Pod berdasarkan kelas QoS-nya. Logika program pemindahan Scheduler tidak mempertimbangkan QoS saat memilih sasaran-sasaran pemindahan. Pemindahan mempertimbangkan prioritas Pod dan mencoba memilih kumpulan sasaran dengan prioritas terendah. Pod-pod dengan prioritas lebih tinggi dipertimbangkan untuk pemindahan hanya jika penghapusan Pod-pod dengan prioritas terendah tidak cukup untuk memungkinkan Scheduler untuk menjadwalkan Pod <em>preemptor</em>, atau jika Pod-pod dengan prioritas terendah tersebut dilindungi oleh <code>PodDisruptionBudget</code>.</p><p>Komponen satu-satunya yang mempertimbangkan baik QoS dan prioritas Pod adalah <a href=/docs/tasks/administer-cluster/out-of-resource/>pengusiran oleh Kubelet karena kehabisan sumber daya</a>.
Kubelet menggolongkan Pod-pod untuk pengusiran pertama-tama berdasarkan apakah penggunaan sumber daya mereka melebihi <code>requests</code> mereka atau tidak, kemudian berdasarkan Priority, dan kemudian berdasarkan penggunaan sumber daya yang terbatas tersebut relatif terhadap <code>requests</code> dari Pod-pod tersebut.
Lihat <a href=/docs/tasks/administer-cluster/out-of-resource/#mengusir-pod-pod-pengguna>Mengusir Pod-pod pengguna</a> untuk lebih detail. Pengusiran oleh Kubelet karena kehabisan sumber daya tidak mengusir Pod-pod yang memiliki penggunaan sumber daya yang tidak melebihi <code>requests</code> mereka. Jika sebuah Pod dengan prioritas lebih rendah tidak melebihi <code>requests</code>-nya, ia tidak akan diusir. Pod lain dengan prioritas lebih tinggi yang melebihi <code>requests</code>-nya boleh diusir.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>