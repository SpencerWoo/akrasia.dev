<!doctype html><html lang=id class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/services-networking/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/services-networking/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/services-networking/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/services-networking/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/services-networking/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/services-networking/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/services-networking/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/services-networking/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/services-networking/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/concepts/services-networking/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Services, Load Balancing, dan Jaringan | Kubernetes</title><meta property="og:title" content="Services, Load Balancing, dan Jaringan"><meta property="og:description" content="Orkestrasi Kontainer dengan Skala Produksi"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/services-networking/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Services, Load Balancing, dan Jaringan"><meta itemprop=description content="Orkestrasi Kontainer dengan Skala Produksi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Services, Load Balancing, dan Jaringan"><meta name=twitter:description content="Orkestrasi Kontainer dengan Skala Produksi"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/services-networking/"><meta property="og:title" content="Services, Load Balancing, dan Jaringan"><meta name=twitter:title content="Services, Load Balancing, dan Jaringan"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/id/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/id/docs/concepts/services-networking/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/id/docs/concepts/services-networking/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/concepts/services-networking/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/concepts/services-networking/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/concepts/services-networking/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/services-networking/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/services-networking/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/services-networking/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/services-networking/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/services-networking/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/services-networking/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/services-networking/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/services-networking/>Português (Portuguese)</a>
<a class=dropdown-item href=/uk/docs/concepts/services-networking/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/concepts/services-networking/>Return to the regular view of this page</a>.</p></div><h1 class=title>Services, Load Balancing, dan Jaringan</h1><ul><li>1: <a href=#pg-5701136fd2ce258047b6ddc389112352>Service</a></li><li>2: <a href=#pg-3a38878244d862dfdb8d7adb32f77584>Topologi Service (Service Topology)</a></li><li>3: <a href=#pg-f51db1097575de8072afe1f5b156a70c>EndpointSlice</a></li><li>4: <a href=#pg-91cb8a4438b003df11bc1c426a81b756>DNS untuk Service dan Pod</a></li><li>5: <a href=#pg-f804ac0532fcade3966ea2e3769ca031>Menghubungkan aplikasi dengan Service</a></li><li>6: <a href=#pg-199bcc92443dbc9bed44819467d7eb75>Ingress</a></li><li>7: <a href=#pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>Kontroler Ingress</a></li><li>8: <a href=#pg-ded1daafdcd293023ee333728007ca61>NetworkPolicy</a></li><li>9: <a href=#pg-509638b5ca0e420fa426f14f34e2d3b1>Menambahkan Entry pada /etc/hosts Pod dengan HostAliases</a></li><li>10: <a href=#pg-21f8d19c60c33914baab66224c3d46a7>Dual-stack IPv4/IPv6</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-5701136fd2ce258047b6ddc389112352>1 - Service</h1><p><a href=/id/docs/concepts/workloads/pods/pod/><code>Pod</code></a> pada Kubernetes bersifat <em>mortal</em>.
Artinya apabila <em>pod-pod</em> tersebut dibuat dan kemudian mati, <em>pod-pod</em> tersebut
tidak akan dihidupkan kembali. <a href=/id/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSets</code></a> secara
khusus bertugas membuat dan menghapus <code>Pod</code> secara dinamis (misalnya, pada proses <em>scaling out</em> atau <em>scaling in</em>).
Meskipun setiap <code>Pod</code> memiliki alamat IP-nya masing-masing, kamu tidak dapat mengandalkan alamat IP
yang diberikan pada <em>pod-pod</em> tersebut, karena alamat IP yang diberikan tidak stabil.
Hal ini kemudian menimbulkan pertanyaan baru: apabila sebuah sekumpulan <code>Pod</code> (yang selanjutnya kita sebut <em>backend</em>)
menyediakan <em>service</em> bagi sebuah sekumpulan <code>Pod</code> lain (yang selanjutnya kita sebut <em>frontend</em>) di dalam
klaster Kubernetes, bagaimana cara <em>frontend</em> menemukan <em>backend</em> mana yang digunakan?</p><p>Inilah alasan kenapa <code>Service</code> ada.</p><p>Sebuah <code>Service</code> pada Kubernetes adalah sebuah abstraksi yang memberikan definisi
set logis yang terdiri beberapa <code>Pod</code> serta <em>policy</em> bagaimana cara kamu mengakses sekumpulan <code>Pod</code> tadi - seringkali disebut sebagai <em>microservices</em>.
Set <code>Pod</code> yang dirujuk oleh suatu <code>Service</code> (biasanya) ditentukan oleh sebuah <a href=/id/docs/concepts/overview/working-with-objects/labels/#label-selectors><code>Label Selector</code></a>
(lihat penjelasan di bawah untuk mengetahui alasan kenapa kamu mungkin saja membutuhkan <code>Service</code> tanpa
sebuah <em>selector</em>).</p><p>Sebagai contoh, misalnya terdapat sebuah <em>backend</em> yang menyediakan fungsionalitas <em>image-processing</em>
yang memiliki 3 buah <em>replica</em>. <em>Replica-replica</em> tadi sifatnya sepadan - dengan kata lain <em>frontend</em>
tidak peduli <em>backend</em> manakah yang digunakan. Meskipun <code>Pod</code> penyusun sekumpulan <em>backend</em> bisa berubah,
<em>frontend</em> tidak perlu peduli bagaimana proses ini dijalankan atau menyimpan <em>list</em> dari <em>backend-backend</em>
yang ada saat itu. <code>Service</code> memiliki tujuan untuk <em>decouple</em> mekanisme ini.</p><p>Untuk aplikasi yang dijalankan di atas Kubernetes, Kubernetes menyediakan API <em>endpoint</em> sederhana
yang terus diubah apabila <em>state</em> sebuah sekumpulan <code>Pod</code> di dalam suatu <code>Service</code> berubah. Untuk
aplikasi <em>non-native</em>, Kubernetes menyediakan <em>bridge</em> yang berbasis <em>virtual-IP</em> bagi <code>Service</code>
yang diarahkan pada <code>Pod</code> <em>backend</em>.</p><h2 id=mendefinisikan-sebuah-service>Mendefinisikan sebuah <code>Service</code></h2><p>Sebuah <code>Service</code> di Kubernetes adalah sebuah objek REST, layaknya sebuah <code>Pod</code>. Seperti semua
objek <em>REST</em>, definisi <code>Service</code> dapat dikirim dengan <em>method POST</em> pada <em>apiserver</em> untuk membuat
sebuah instans baru. Sebagai contoh, misalnya saja kamu memiliki satu sekumpulan <code>Pod</code> yang mengekspos <em>port</em>
9376 dan memiliki <em>label</em> <code>"app=MyApp"</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Spesifikasi ini akan ditranslasikan sebagai sebuah objek <code>Service</code> baru dengan nama <code>"my-service"</code>
dengan <em>target port</em> 9376 pada setiap <code>Pod</code> yang memiliki <em>label</em> <code>"app=MyApp"</code>. <code>Service</code> ini
juga akan memiliki alamat IP tersendiri (yang terkadang disebut sebagai <em>"cluster IP"</em>), yang nantinya
akan digunakan oleh <em>service proxy</em> (lihat di bagian bawah). <em>Selector</em> pada <code>Service</code> akan selalu dievaluasi
dan hasilnya akan kembali dikirim dengan menggunakan <em>method POST</em> ke objek <code>Endpoints</code>
yang juga disebut <code>"my-service"</code>.</p><p>Perhatikan bahwa sebuah <code>Service</code> dapat melakukan pemetaan setiap <em>incoming port</em> pada <code>targetPort</code>
mana pun. Secara <em>default</em>, <em>field</em> <code>targetPort</code> akan memiliki <em>value</em> yang sama dengan <em>value</em> dari <em>field</em> <code>port</code>.
Hal menarik lainnya adalah <em>value</em> dari <code>targetPort</code> bisa saja berupa string yang merujuk pada nama
dari <em>port</em> yang didefinisikan pada <code>Pod</code> <em>backend</em>. Nomor <em>port</em> yang diberikan pada <em>port</em> dengan nama
tadi bisa saja memiliki nilai yang berbeda di setiap <code>Pod</code> <em>backend</em>. Hal ini memberikan fleksibilitas
pada saat kamu melakukan <em>deploy</em> atau melakukan perubahan terhadap <code>Service</code>. Misalnya saja suatu saat
kamu ingin mengubah nomor <em>port</em> yang ada pada <code>Pod</code> <em>backend</em> pada rilis selanjutnya tanpa menyebabkan
permasalahan pada sisi klien.</p><p>Secara <em>default</em>, protokol yang digunakan pada <em>service</em> adalah <code>TCP</code>, tapi kamu bisa saja menggunakan
<a href=#protokol-yang-tersedia>protokol yang tersedia</a>. Karena banyak <code>Service</code> memiliki kebutuhan untuk
mengekspos lebih dari sebuah <em>port</em>, Kubernetes menawarkan definisi <em>multiple</em> <em>port</em> pada sebuah objek
<em>Service</em>. Setiap definisi <em>port</em> dapat memiliki protokol yang berbeda.</p><h3 id=service-tanpa-selector><code>Service</code> tanpa <em>selector</em></h3><p>Secara umum, <code>Service</code> memberikan abstraksi mekanisme yang dilakukan untuk mengakses <code>Pod</code>, tapi
mereka juga melakukan abstraksi bagi <em>backend</em> lainnya. Misalnya saja:</p><ul><li>Kamu ingin memiliki sebuah basis data eksternal di <em>environment</em> <em>production</em> tapi pada tahap <em>test</em>,
kamu ingin menggunakan basis datamu sendiri.</li><li>Kamu ingin merujuk <em>service</em> kamu pada <em>service</em> lainnya yang berada pada
<a href=/id/docs/concepts/overview/working-with-objects/namespaces/><em>Namespace</em></a> yang berbeda atau bahkan klaster yang berbeda.</li><li>Kamu melakukan migrasi <em>workloads</em> ke Kubernetes dan beberapa <em>backend</em> yang kamu miliki masih
berada di luar klaster Kubernetes.</li></ul><p>Berdasarkan skenario-skenario di atas, kamu dapat membuat sebuah <code>Service</code> tanpa <em>selector</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Karena <code>Service</code> ini tidak memiliki <em>selector</em>, objek <code>Endpoints</code> bagi <code>Service</code> ini tidak akan dibuat.
Dengan demikian, kamu bisa membuat <code>Endpoints</code> yang kamu inginkan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subsets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>1.2.3.4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Perhatikan bahwa alamat IP yang kamu buat untuk <code>Endpoints</code> tidak boleh berupa
<em>loopback</em> (127.0.0.0/8), <em>link-local</em> (169.254.0.0/16), atau <em>link-local multicast</em> (224.0.0.0/24).
Alamat IP tersebut juga tidak boleh berupa <em>cluster IP</em> dari <code>Service</code> Kubernetes lainnya,
karena <code>kube-proxy</code> belum menyediakan dukungan IP virtual sebagai <em>destination</em>.</div><p>Cara mengakses suatu <code>Service</code> tanpa <em>selector</em> sama saja dengan mengakses suatu <code>Service</code>
dengan <em>selector</em>. Trafik yang ada akan di-<em>route</em> ke <code>Endpoints</code> yang dispesifikasikan oleh
pengguna (dalam contoh kali ini adalah <code>1.2.3.4:9376</code>).</p><p>Sebuah <code>ExternalName</code> <code>Service</code> merupakan kasus spesial dari <code>Service</code>
dimana <code>Service</code> tidak memiliki <em>selector</em> dan menggunakan penamaan <em>DNS</em>. Untuk
informasi lebih lanjut silahkan baca bagian <a href=#externalname>ExternalName</a>.</p><h2 id=ip-virtual-dan-proxy-service>IP Virtual dan <em>proxy</em> <code>Service</code></h2><p>Setiap <em>node</em> di klaster Kubernetes menjalankan <code>kube-proxy</code>. <code>kube-proxy</code>
bertanggung jawab terhadap implementasi IP virtual bagi <em>Services</em> dengan tipe
selain <a href=#externalname><code>ExternalName</code></a>.</p><p>Pada Kubernetes versi v1.0, <em>Services</em> adalah "layer 4" (TCP/UDP pada IP), <em>proxy</em>
yang digunakan murni berada pada <em>userspace</em>. Pada Kubernetes v1.1, API <code>Ingress</code>
ditambahkan untuk merepresentasikan "layer 7"(HTTP), <em>proxy</em> <code>iptables</code> juga ditambahkan
dan menjadi mode operasi <em>default</em> sejak Kubernetes v1.2. Pada Kubernetes v1.8.0-beta.0,
<em>proxy</em> <em>ipvs</em> juga ditambahkan.</p><h3 id=mode-proxy-userspace>Mode <em>Proxy</em>: <em>userspace</em></h3><p>Pada mode ini, <code>kube-proxy</code> mengamati master Kubernetes apabila terjadi penambahan
atau penghapusan objek <code>Service</code> dan <code>Endpoints</code>. Untuk setiap <code>Service</code>, <code>kube-proxy</code>
akan membuka sebuah <em>port</em> (yang dipilih secara acak) pada <em>node</em> lokal. Koneksi
pada <em>"proxy port"</em> ini akan dihubungkan pada salah satu <code>Pod</code> <em>backend</em> dari <code>Service</code>
(yang tercatat pada <code>Endpoints</code>). <code>Pod</code> <em>backend</em> yang akan digunakan akan diputuskan berdasarkan
<code>SessionAffinity</code> pada <code>Service</code>. Langkah terakhir yang dilakukan oleh <code>kube-proxy</code>
adalah melakukan instalasi <em>rules</em> <code>iptables</code> yang akan mengarahkan trafik yang ada pada
<code>clusterIP</code> (IP virtual) dan <em>port</em> dari <code>Service</code> serta melakukan <em>redirect</em> trafik ke <em>proxy</em>
yang memproksikan <code>Pod</code> <em>backend</em>. Secara <em>default</em>, mekanisme <em>routing</em> yang dipakai adalah
<em>round robin</em>.</p><p><img src=/images/docs/services-userspace-overview.svg alt="Ikhtisar diagram Services pada proxy userspace"></p><h3 id=mode-proxy-iptables>Mode <em>Proxy</em>: iptables</h3><p>Pada mode ini, <code>kube-proxy</code> mengamati master Kubernetes apabila terjadi penambahan
atau penghapusan objek <code>Service</code> dan <code>Endpoints</code>. Untuk setiap <code>Service</code>,
<code>kube-proxy</code> akan melakukan instalasi <em>rules</em> <code>iptables</code> yang akan mengarahkan
trafik ke <code>clusterIP</code> (IP virtual) dan <em>port</em> dari <code>Service</code>. Untuk setiap objek <code>Endpoints</code>,
<code>kube-proxy</code> akan melakukan instalasi <em>rules</em> <code>iptables</code> yang akan memilih satu buah <code>Pod</code>
<em>backend</em>. Secara <em>default</em>, pemilihan <em>backend</em> ini dilakukan secara acak.</p><p>Tentu saja, <code>iptables</code> yang digunakan tidak boleh melakukan <em>switching</em>
antara <em>userspace</em> dan <em>kernelspace</em>, mekanisme ini harus lebih kokoh dan lebih cepat
dibandingkan dengan <em>userspace</em> <em>proxy</em>. Meskipun begitu, berbeda dengan mekanisme
<em>proxy</em> <em>userspace</em>, <em>proxy</em> <code>iptables</code> tidak bisa secara langsung menjalankan mekanisme
<em>retry</em> ke <code>Pod</code> lain apabila <code>Pod</code> yang sudah dipilih sebelumnya tidak memberikan respons,
dengan kata lain hal ini akan sangat bergantung pada
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#defining-readiness-probes>readiness probes</a>.</p><p><img src=/images/docs/services-iptables-overview.svg alt="Ikhtisar diagram Services pada proxy iptables"></p><h3 id=mode-proxy-ipvs>Mode <em>Proxy</em>: ipvs</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.9 [beta]</code></div><p>Pada mode ini, <code>kube-proxy</code> mengamati <em>Services</em> dan <code>Endpoints</code>, kemudian memanggil
<em>interface</em> <em>netlink</em> untuk membuat <em>rules</em> <em>ipvs</em> yang sesuai serta melakukan sinkronisasi
<em>rules</em> <em>ipvs</em> dengan <em>Services</em> dan <code>Endpoints</code> Kubernetes secara periodik, untuk memastikan
status <em>ipvs</em> konsisten dengan apa yang diharapkan. Ketika sebuah <em>Services</em> diakses,
trafik yang ada akan diarahkan ke salah satu <code>Pod</code> <em>backend</em>.</p><p>Sama halnya dengan <code>iptables</code>, <em>ipvs</em> juga berdasarkan pada fungsi <em>hook</em> <em>netfilter</em>,
bedanya adalah <em>ipvs</em> menggunakan struktur data <em>hash table</em> dan bekerja di <em>kernelspace</em>.
Dengan kata lain <em>ipvs</em> melakukan <em>redirect</em> trafik dengan lebih cepat dan dengan performa yang lebih
baik ketika melakukan sinkronisasi <em>rules</em> <em>proxy</em>. Selain itu, <em>ipvs</em> juga menyediakan
lebih banyak opsi algoritma <em>load balancing</em>:</p><ul><li><code>rr</code>: round-robin</li><li><code>lc</code>: least connection</li><li><code>dh</code>: destination hashing</li><li><code>sh</code>: source hashing</li><li><code>sed</code>: shortest expected delay</li><li><code>nq</code>: never queue</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Mode <em>ipvs</em> menggunakan <em>module</em> <em>IPVS</em> <em>kernel</em> yang diinstal pada <em>node</em>
sebelum <code>kube-proxy</code> dijalankan. Ketika <code>kube-proxy</code> dijalankan dengan mode <em>proxy</em> <em>ipvs</em>,
<code>kube-proxy</code> akan melakukan proses validasi, apakah <em>module</em> <em>IPVS</em> sudah diinstal di <em>node</em>,
jika <em>module</em> tersebut belum diinstal, maka <code>kube-proxy</code> akan menggunakan mode <code>iptables</code>.</div><p><img src=/images/docs/services-ipvs-overview.svg alt="Ikhtisar diagram Services pada proxy ipvs"></p><p>Dari sekian model <em>proxy</em> yang ada, trafik <em>inbound</em> apa pun yang ada diterima oleh <em>IP:Port</em> pada <code>Service</code>
akan dilanjutkan melalui <em>proxy</em> pada <em>backend</em> yang sesuai, dan klien tidak perlu mengetahui
apa informasi mendetail soal Kubernetes, <code>Service</code>, atau <code>Pod</code>. afinitas <em>session</em> (<em>session affinity</em>) berbasis
<em>Client-IP</em> dapat dipilih dengan cara menerapkan nilai <em>"ClientIP"</em> pada <code>service.spec.sessionAffinity</code>
(nilai <em>default</em> untuk hal ini adalah <em>"None"</em>), kamu juga dapat mengatur nilai maximum <em>session</em>
<em>timeout</em> yang ada dengan mengatur opsi <code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> jika
sebelumnya kamu sudah menerapkan nilai <em>"ClusterIP"</em> pada <code>service.spec.sessionAffinity</code>
(nilai <em>default</em> untuk opsi ini adalah <em>"10800"</em>).</p><h2 id=multi-port-services><em>Multi-Port Services</em></h2><p>Banyak <em>Services</em> dengan kebutuhan untuk mengekspos lebih dari satu <em>port</em>.
Untuk kebutuhan inilah, Kubernetes mendukung <em>multiple</em> <em>port</em> <em>definitions</em> pada objek <code>Service</code>.
Ketika menggunakan <em>multiple</em> <em>port</em>, kamu harus memberikan nama pada setiap <em>port</em> yang didefinisikan,
sehingga <em>Endpoint</em> yang dibentuk tidak ambigu. Contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Perhatikan bahwa penamaan <em>port</em> hanya boleh terdiri dari karakter <em>alphanumeric</em> <em>lowercase</em>
dan <em>-</em>, serta harus dimulai dan diakhiri dengan karakter <em>alphanumeric</em>, misalnya saja <code>123-abc</code> dan <code>web</code>
merupakan penamaan yang valid, tapi <code>123_abc</code> dan <code>-web</code> bukan merupakan penamaan yang valid.</p><h2 id=memilih-sendiri-alamat-ip-yang-kamu-inginkan>Memilih sendiri alamat IP yang kamu inginkan</h2><p>Kamu dapat memberikan spesifikasi alamat <em>cluster IP</em> yang kamu inginkan
sebagai bagian dari <em>request</em> pembuatan objek <code>Service</code>. Untuk melakukan hal ini,
kamu harus mengisi <em>fields</em> <code>.spec.clusterIP</code> field. Contoh penggunaannya adalah sebagai berikut,
misalnya saja kamu sudah memiliki <em>entry</em> DNS yang ingin kamu gunakan kembali,
atau sebuah sistem <em>legacy</em> yang sudah diatur pada alamat IP spesifik
dan sulit untuk diubah. Alamat IP yang ingin digunakan pengguna haruslah merupakan alamat IP
yang valid dan berada di dalam <em>range</em> <em>CIDR</em> <code>service-cluster-ip-range</code> yang dispesifikasikan di dalam
penanda yang diberikan <em>apiserver</em>. Jika <em>value</em> yang diberikan tidak valid, <em>apiserver</em> akan
mengembalikan <em>response</em> <em>code</em> HTTP <em>422</em> yang mengindikasikan <em>value</em> yang diberikan tidak valid.</p><h3 id=mengapa-tidak-menggunakan-dns-round-robin>Mengapa tidak menggunakan DNS <em>round-robin</em>?</h3><p>Pertanyaan yang selalu muncul adalah kenapa kita menggunakan IP virtual dan bukan
DNS <em>round-robin</em> standar? Terdapat beberapa alasan dibalik semua itu:</p><ul><li>Terdapat sejarah panjang dimana <em>library</em> DNS tidak mengikuti <em>TTL</em> DNS dan
melakukan <em>caching</em> hasil dari <em>lookup</em> yang dilakukan.</li><li>Banyak aplikasi yang melakukan <em>lookup</em> DNS hanya sekali dan kemudian melakukan <em>cache</em> hasil yang diperoleh.</li><li>Bahkan apabila aplikasi dan <em>library</em> melakukan resolusi ulang yang <em>proper</em>, <em>load</em> dari setiap
klien yang melakukan resolusi ulang DNS akan sulit untuk di <em>manage</em>.</li></ul><p>Kami berusaha untuk mengurangi ketertarikan pengguna untuk melakukan yang mungkin akan menyusahkan pengguna.
Dengan demikian, apabila terdapat justifikasi yang cukup kuat, kami mungkin saja memberikan implementasi
alternatif yang ada.</p><h2 id=discovering-services><em>Discovering services</em></h2><p>Kubernetes mendukung 2 buah mode primer untuk melakukan <code>Service</code> - variabel <em>environment</em> dan DNS.</p><h3 id=variabel-environment>Variabel <em>Environment</em></h3><p>Ketika sebuah <code>Pod</code> dijalankan pada <em>node</em>, <em>kubelet</em> menambahkan seperangkat variabel <em>environment</em>
untuk setiap <code>Service</code> yang aktif. <em>Environment</em> yang didukung adalah <a href=https://docs.docker.com/userguide/dockerlinks/>Docker links compatible</a> variabel (perhatikan
<a href=http://releases.k8s.io/main/pkg/kubelet/envvars/envvars.go#L49>makeLinkVariables</a>)
dan variabel <code>{SVCNAME}_SERVICE_HOST</code> dan <code>{SVCNAME}_SERVICE_PORT</code>, dinama nama <code>Service</code> akan diubah
menjadi huruf kapital dan tanda <em>minus</em> akan diubah menjadi <em>underscore</em>.</p><p>Sebagai contoh, <code>Service</code> <code>"redis-master"</code> yang mengekspos <em>port</em> TCP 6379 serta <em>alamat</em>
<em>cluster IP</em> <em>10.0.0.11</em> akan memiliki <em>environment</em> sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_SERVICE_HOST</span><span style=color:#666>=</span>10.0.0.11
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_SERVICE_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PROTO</span><span style=color:#666>=</span>tcp
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_ADDR</span><span style=color:#666>=</span>10.0.0.11
</span></span></code></pre></div><p>Hal ini merupakan kebutuhan yang urutannya harus diperhatikan - <code>Service</code> apa pun yang
akan diakses oleh sebuah <code>Pod</code> harus dibuat sebelum <code>Pod</code> tersebut dibuat,
jika tidak variabel <em>environment</em> tidak akan diinisiasi.
Meskipun begitu, DNS tidak memiliki keterbatasan ini.</p><h3 id=dns>DNS</h3><p>Salah satu <a href=/id/docs/concepts/cluster-administration/addons/><em>add-on</em></a> opsional
(meskipun sangat dianjurkan) adalah server DNS. Server DNS bertugas untuk mengamati apakah
terdapat objek <code>Service</code> baru yang dibuat dan kemudian bertugas menyediakan DNS baru untuk
<em>Service</em> tersebut. Jika DNS ini diaktifkan untuk seluruh klaster, maka semua <code>Pod</code> akan secara otomatis
dapat melakukan resolusi DNS.</p><p>Sebagai contoh, apabila kamu memiliki sebuah <code>Service</code> dengan nama <code>"my-service"</code> pada <em>Namespace</em>
<em>"my-ns"</em>, maka <em>record</em> DNS <code>"my-service.my-ns"</code> akan dibuat. <code>Pod</code> yang berada di dalam
<em>Namespace</em> <em>"my-ns"</em> dapat langsung melakukan <em>lookup</em> dengan hanya menggunakan <code>"my-service"</code>.
Sedangkan <code>Pod</code> yang berada di luar <em>Namespace</em> <em>my-ns"</em> harus menggunakan <code>"my-service.my-ns"</code>.
Hasil dari resolusi ini menrupakan <em>cluster IP</em>.</p><p>Kubernetes juga menyediakan <em>record</em> DNS SRV (service) untuk <em>named ports</em>. Jika
<em>Service</em> <code>"my-service.my-ns"</code> memiliki <em>port</em> dengan nama <code>"http"</code> dengan protokol <code>TCP</code>,
kamu dapat melakukan <em>query</em> DNS SRV untuk <code>"_http._tcp.my-service.my-ns"</code> untuk mengetahui
nomor <em>port</em> yang digunakan oleh <em>http</em>.</p><p>Server DNS Kubernetes adalah satu-satunya cara untuk mengakses
<em>Service</em> dengan tipe <code>ExternalName</code>. Informasi lebih lanjut tersedia di
<a href=/id/docs/concepts/services-networking/dns-pod-service/>DNS <em>Pods</em> dan <em>Services</em></a>.</p><h2 id=service-headless><code>Service</code> <em>headless</em></h2><p>Terkadang kamu tidak membutuhkan mekanisme <em>load-balancing</em> dan sebuah <em>single</em> IP <em>Sevice</em>.
Dalam kasus ini, kamu dapat membuat <em>"headless"</em> <code>Service</code> dengan cara memberikan spesifikasi
<em>None</em> pada <em>cluster IP</em> (<code>.spec.clusterIP</code>).</p><p>Opsi ini memungkinkan pengguna mengurangi ketergantungan terhadap sistem Kubernetes
dengan cara memberikan kebebasan untuk mekanisme <em>service discovery</em>. Aplikasi akan
tetap membutuhkan mekanisme <em>self-registration</em> dan <em>adapter service discovery</em>
lain yang dapat digunakan berdasarkan API ini.</p><p>Untuk <code>Service</code> <em>"headless"</em> alokasi <em>cluster IP</em> tidak dilakukan dan <code>kube-proxy</code>
tidak me-<em>manage</em> <em>Service-Service</em>, serta tidak terdapat mekanisme <em>load balancing</em>
yang dilakukan. Bagaimana konfigurasi otomatis bagi DNS dilakukan bergantung pada
apakah <code>Service</code> tersebut memiliki <em>selector</em> yang dispesifikasikan.</p><h3 id=dengan-selector>Dengan <em>selector</em></h3><p>Untuk <code>Service</code> <em>"headless"</em> dengan <em>selector</em>, kontroler <code>Endpoints</code> akan membuat suatu
<em>record</em> <code>Endpoints</code> di API, serta melakukan modifikasi konfigurasi DNS untuk mengembalikan
<em>A records (alamat)</em> yang merujuk secara langsung pada <code>Pod</code> <em>backend</em>.</p><h3 id=tanpa-selector>Tanpa <em>selector</em></h3><p>Untuk <code>Service</code> <em>"headless"</em> tanpa <em>selector</em>, kontroler <code>Endpoints</code>
tidak akan membuat <em>record</em> <em>Enpoints</em>. Meskipun demikian,
sistem DNS tetap melakukan konfigurasi salah satu dari:</p><ul><li><em>record</em> CNAME untuk <a href=#externalname><code>ExternalName</code></a>-tipe services.</li><li><em>record</em> untuk semua <code>Endpoints</code> yang memiliki nama <code>Service</code> yang sama, untuk
tipe lainnya.</li></ul><h2 id=mekanisme-publish-service-jenis-jenis-service>Mekanisme <em>publish</em> <code>Service</code> - jenis-jenis <code>Service</code></h2><p>Untuk beberapa bagian dari aplikasi yang kamu miliki (misalnya saja, <em>frontend</em>),
bisa saja kamu memiliki kebutuhan untuk mengekspos <code>Service</code> yang kamu miliki
ke alamat IP eksternal (di luar klaster Kubernetes).</p><p><code>ServiceTypes</code> yang ada pada Kubernetes memungkinkan kamu untuk menentukan
jenis <code>Service</code> apakah yang kamu butuhkan. Secara <em>default</em>, jenis <code>Service</code>
yang diberikan adalah <code>ClusterIP</code>.</p><p><em>Value</em> dan perilaku dari tipe <code>Service</code> dijelaskan sebagai berikut:</p><ul><li><code>ClusterIP</code>: Mengekspos <code>Service</code> ke <em>range</em> alamat IP di dalam klaster. Apabila kamu memilih <em>value</em> ini
<code>Service</code> yang kamu miliki hanya dapat diakses secara internal. tipe ini adalah
<em>default</em> <em>value</em> dari <em>ServiceType</em>.</li><li><a href=#type-nodeport><code>NodePort</code></a>: Mengekspos <code>Service</code> pada setiap IP <em>node</em> pada <em>port</em> statis
atau <em>port</em> yang sama. Sebuah <code>Service</code> <code>ClusterIP</code>, yang mana <code>Service</code> <code>NodePort</code> akan di-<em>route</em>
, dibuat secara otomatis. Kamu dapat mengakses <code>Service</code> dengan tipe ini,
dari luar klaster melalui <code>&lt;NodeIP>:&lt;NodePort></code>.</li><li><a href=#loadbalancer><code>LoadBalancer</code></a>: Mengekspos <code>Service</code> secara eksternal dengan menggunakan <code>LoadBalancer</code>
yang disediakan oleh penyedia layanan <em>cloud</em>. <code>Service</code> dengan tipe <code>NodePort</code> dan <code>ClusterIP</code>,
dimana trafik akan di-<em>route</em>, akan dibuat secara otomatis.</li><li><a href=#externalname><code>ExternalName</code></a>: Melakukan pemetaan <code>Service</code> ke konten
dari <em>field</em> <code>externalName</code> (misalnya: <code>foo.bar.example.com</code>), dengan cara mengembalikan
catatan <code>CNAME</code> beserta <em>value</em>-nya. Tidak ada metode <em>proxy</em> apa pun yang diaktifkan. Mekanisme ini
setidaknya membutuhkan <code>kube-dns</code> versi 1.7.</li></ul><h3 id=type-nodeport>Type NodePort</h3><p>Jika kamu menerapkan <em>value</em> <code>NodePort</code> pada <em>field</em> <em>type</em>, master Kubernetes akan mengalokasikan
<em>port</em> dari <em>range</em> yang dispesifikasikan oleh penanda <code>--service-node-port-range</code> (secara <em>default</em>, 30000-32767)
dan setiap <em>Node</em> akan memproksikan <em>port</em> tersebut (setiap <em>Node</em> akan memiliki nomor <em>port</em> yang sama) ke <code>Service</code>
yang kamu miliki. <code>Port</code> tersebut akan dilaporkan pada <em>field</em> <code>.spec.ports[*].nodePort</code> di <code>Service</code> kamu.</p><p>Jika kamu ingin memberikan spesifikasi IP tertentu untuk melakukan <em>poxy</em> pada <em>port</em>.
kamu dapat mengatur penanda <code>--nodeport-addresses</code> pada <code>kube-proxy</code> untuk <em>range</em> alamat IP
tertentu (mekanisme ini didukung sejak v1.10). Sebuah daftar yang dipisahkan koma (misalnya, <em>10.0.0.0/8</em>, <em>1.2.3.4/32</em>)
digunakan untuk mem-<em>filter</em> alamat IP lokal ke <em>node</em> ini. Misalnya saja kamu memulai <code>kube-proxy</code> dengan penanda
<code>--nodeport-addresses=127.0.0.0/8</code>, maka <code>kube-proxy</code> hanya akan memilih <em>interface</em> <em>loopback</em> untuk <code>Service</code> dengan tipe
<code>NodePort</code>. Penanda <code>--nodeport-addresses</code> memiliki nilai <em>default</em> kosong (<code>[]</code>), yang artinya akan memilih semua <em>interface</em> yang ada
dan sesuai dengan perilaku <code>NodePort</code> <em>default</em>.</p><p>Jika kamu menginginkan nomor <em>port</em> yang berbeda, kamu dapat memberikan spesifikasi
<em>value</em> dari <em>field</em> <em>nodePort</em>, dan sistem yang ada akan mengalokasikan <em>port</em> tersebut untuk kamu,
jika <em>port</em> tersebut belum digunakan (perhatikan bahwa jika kamu menggunakan teknik ini, kamu perlu
mempertimbangkan <em>collision</em> yang mungkin terjadi dan bagaimana cara mengatasi hal tersebut)
atau transaksi API yang dilakukan akan gagal.</p><p>Hal ini memberikan kebebasan bagi pengembang untuk memilih <em>load balancer</em> yang akan digunakan, terutama apabila
<em>load balancer</em> yang ingin digunakan belum didukung sepenuhnya oleh Kubernetes.</p><p>Perhatikan bahwa <code>Service</code> dapat diakses baik dengan menggunakan <code>&lt;NodeIP>:spec.ports[*].nodePort</code>
atau <code>.spec.clusterIP:spec.ports[*].port</code>. (Jika penanda <code>--nodeport-addresses</code> diterapkan, <nodeip>dapat di-<em>filter</em> dengan salah satu atau lebih <em>NodeIP</em>.)</p><h3 id=loadbalancer>Type LoadBalancer</h3><p>Pada penyedia layanan <em>cloud</em> yang menyediakan pilihan <em>load balancer</em> eksternal, pengaturan <em>field</em> <em>type</em>
ke <code>LoadBalancer</code> akan secara otomatis melakukan proses <em>provision</em> <em>load balancer</em> untuk <code>Service</code> yang kamu buat.
Informasi mengenai <em>load balancer</em> yang dibuat akan ditampilkan pada <em>field</em> <code>.status.loadBalancer</code>
pada <code>Service</code> kamu. Contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.171.239</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancerIP</span>:<span style=color:#bbb> </span><span style=color:#666>78.11.24.19</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>146.148.47.155</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Trafik dari <em>load balancer</em> eksternal akan diarahkan pada <code>Pod</code> <em>backend</em>, meskipun mekanisme
bagaimana hal ini dilakukan bergantung pada penyedia layanan <em>cloud</em>. Beberapa penyedia layanan
<em>cloud</em> mengizinkan konfigurasi untuk <em>value</em> <code>loadBalancerIP</code>. Dalam kasus tersebut, <em>load balancer</em> akan dibuat
dengan <em>loadbalancerIP</em> yang dispesifikasikan. Jika <em>value</em> dari <code>loadBalancerIP</code> tidak dispesifikasikan.
sebuah IP sementara akan diberikan pada <em>loadBalancer</em>. Jika <code>loadBalancerIP</code> dispesifikasikan,
tetapi penyedia layanan <em>cloud</em> tidak mendukung hal ini, maka <em>field</em> yang ada akan diabaikan.</p><p><strong>Catatan Khusus untuk Azure</strong>: Untuk spesifikasi <code>loadBalancerIP</code> publik yang didefinisikan oleh pengguna,
sebuah alamat IP statis publik akan disediakan terlebih dahulu, dan alamat IP tersebut harus berada di
<em>resource group</em> dari <em>resource</em> yang secara otomatis dibuat oleh klaster. Misalnya saja, <code>MC_myResourceGroup_myAKSCluster_eastus</code>.
Berikan spesifikasi alamat IP sebagai <code>loadBalancerIP</code>. Pastikan kamu sudah melakukan <em>update</em> pada
<em>securityGroupName</em> pada <em>file</em> konfigurasi penyedia layanan <em>cloud</em>.
Untuk informasi lebih lanjut mengenai <em>permission</em> untuk <code>CreatingLoadBalancerFailed</code> kamu dapat membaca <em>troubleshooting</em> untuk
<a href=https://docs.microsoft.com/en-us/azure/aks/static-ip>Penggunaan alamat IP statis pada <em>load balancer</em> Azure Kubernetes Service (AKS)</a> atau
<a href=https://github.com/Azure/AKS/issues/357><em>CreatingLoadBalancerFailed</em> pada klaster AKS dengan <em>advanced networking</em></a>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Dukungan untuk SCTP <em>load balancer</em> dari penyedia layanan <em>cloud</em> bergantung pada
implementasi <em>load balancer</em> yang disediakan oleh penyedia layanan <em>cloud</em> tersebut.
Jika SCTP tidak didukung oleh <em>load balancer</em> penyedia layanan publik maka <em>request</em> pembuatan <code>Service</code>
akan tetap diterima, meskipun proses pembuatan <em>load balancer</em> itu sendiri gagal.</div><h4 id=load-balancer-internal><em>Load balancer</em> internal</h4><p>Di dalam <em>environment</em>, terkadang terdapat kebutuhan untuk melakukan <em>route</em> trafik antar
<em>Service</em> yang berada di dalam satu VPC.</p><p>Di dalam <em>environment</em> <em>split-horizon DNS</em> kamu akan membutuhkan dua <em>service</em> yang mampu
melakukan mekanisme <em>route</em> trafik eskternal maupun internal ke <em>endpoints</em> yang kamu miliki.</p><p>Hal ini dapat diraih dengan cara menambahkan anotasi berikut untuk <em>service</em> yang disediakan oleh
penyedia layanan <em>cloud</em>.</p><ul class="nav nav-tabs" id=service-tabs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#service-tabs-0 role=tab aria-controls=service-tabs-0 aria-selected=true>Default</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-1 role=tab aria-controls=service-tabs-1>GCP</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-2 role=tab aria-controls=service-tabs-2>AWS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-3 role=tab aria-controls=service-tabs-3>Azure</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-4 role=tab aria-controls=service-tabs-4>OpenStack</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-5 role=tab aria-controls=service-tabs-5>Baidu Cloud</a></li></ul><div class=tab-content id=service-tabs><div id=service-tabs-0 class="tab-pane show active" role=tabpanel aria-labelledby=service-tabs-0><p><p>Pilih salah satu <em>tab</em>.</p></div><div id=service-tabs-1 class=tab-pane role=tabpanel aria-labelledby=service-tabs-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cloud.google.com/load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Internal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Gunakan <em>cloud.google.com/load-balancer-type: "internal"</em> untuk master dengan versi 1.7.0 to 1.7.3.
Untuk informasi lebih lanjut, dilahkan baca <a href=https://cloud.google.com/kubernetes-engine/docs/internal-load-balancing>dokumentasi</a>.</p></div><div id=service-tabs-2 class=tab-pane role=tabpanel aria-labelledby=service-tabs-2><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#666>0.0.0.0</span>/0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-3 class=tab-pane role=tabpanel aria-labelledby=service-tabs-3><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/azure-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-4 class=tab-pane role=tabpanel aria-labelledby=service-tabs-4><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/openstack-internal-load-balancer</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-5 class=tab-pane role=tabpanel aria-labelledby=service-tabs-5><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/cce-load-balancer-internal-vpc</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h4 id=dukungan-untuk-ssl-di-aws>Dukungan untuk SSL di AWS</h4><p>Dukungan parsial untuk SSL bagi klaster yang dijalankan di AWS mulai diterapkan,
mulai versi 1.3 terdapat 3 anotasi yang dapat ditambahkan pada <code>Service</code> dengan tipe
<code>LoadBalancer</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-cert</span>:<span style=color:#bbb> </span>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012<span style=color:#bbb>
</span></span></span></code></pre></div><p>Anotasi pertama memberikan spesifikasi ARN dari sertifikat yang akan digunakan.
Sertifikat yang digunakan bisa saja berasal dari <em>third party</em> yang diunggah ke IAM atau
sertifikat yang dibuat secara langsung dengan menggunakan sertifikat manajer AWS.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>(https|http|ssl|tcp)<span style=color:#bbb>
</span></span></span></code></pre></div><p>Anotasi kedua memberikan spesifikasi bagi protokol yang digunakan oleh <code>Pod</code> untuk saling berkomunikasi.
Untuk HTTPS dan SSL, ELB membutuhkan <code>Pod</code> untuk melakukan autentikasi terhadap dirinya sendiri melalui
koneksi yang dienkripsi.</p><p>Protokol HTTP dan HTTPS akan memilih mekanisme <em>proxy</em> di tingkatan ke-7:
ELB akan melakukan terminasi koneksi dengan pengguna, melakukan proses <em>parsing</em> <em>headers</em>, serta
memasukkan <em>value</em> bagi <em>header</em> <code>X-Forwarded-For</code> dengan alamat IP pengguna (<em>Pod</em> hanya dapat melihat
alamat IP dari ELB pada akhir koneksi yang diberikan) ketika melakukan <em>forwarding</em> suatu <em>request</em>.</p><p>Protokol TCP dan SSL akan memilih mekanisme <em>proxy</em> pada tingkatan 4: ELB akan melakukan <em>forwarding</em> trafik
tanpa melakukan modifikasi <em>headers</em>.</p><p>Pada <em>environment</em> campuran dimana beberapa <em>port</em> diamankan sementara <em>port</em> lainnya dalam kondisi tidak dienkripsi,
anotasi-anotasi berikut dapat digunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-ports</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;443,8443&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Pada contoh di atas, jika <code>Service</code> memiliki 3 buah <em>port</em>, yaitu: <code>80</code>, <code>443</code>, dan
<code>8443</code>, maka <code>443</code> adan <code>8443</code> akan menggunakan sertifikat SSL, tetapi <code>80</code> hanya akan
di-<em>proxy</em> menggunakan protokol HTTP.</p><p>Mulai versi 1.9, <code>Service</code> juga dapat menggunakan <a href=http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html><em>predefined</em> <em>policy</em></a>
untuk HTTPS atau <em>listener</em> SSL. Untuk melihat <em>policy</em> apa saja yang dapat digunakan, kamu dapat menjalankan perintah <em>awscli</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>aws elb describe-load-balancer-policies --query <span style=color:#b44>&#39;PolicyDescriptions[].PolicyName&#39;</span>
</span></span></code></pre></div><p><em>Policy</em> ini kemudian dapat dispesifikasikan menggunakan anotasi
"<em>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</em>", contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ELBSecurityPolicy-TLS-1-2-2017-01&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=protokol-proxy-pada-aws>Protokol PROXY pada AWS</h4><p>Untuk mengaktifkan dukungan <a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>protokol PROXY</a>
untuk klaster yang dijalankan di AWS, kamu dapat menggunakan anotasi di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Sejak versi 1.3.0, penggunaan anotasi berlaku untuk semua <em>port</em> yang diproksi oleh ELB
dan tidak dapat diatur sebaliknya.</p><h4 id=akses-log-elb-pada-aws>Akses <em>Log</em> ELB pada AWS</h4><p>Terdapat beberapa anotasi yang digunakan untuk melakukan manajemen
akses <em>log</em> untuk ELB pada AWS.</p><p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</code>
mengatur akses <em>log</em> mana sajakah yang diaktifkan.</p><p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</code>
mengatur interval (dalam menit) publikasi akses <em>log</em>. Kamu dapat memberikan spesifikasi interval
diantara <em>range</em> 5-60 menit.</p><p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</code>
mengatur nama <em>bucket</em> Amazon S3 dimana akses <em>log</em> <em>load balancer</em> disimpan.</p><p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</code>
memberikan spesifikasi hierarki logis yang kamu buat untuk <em>bucket</em> Amazon S3 yang kamu buat.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Specifies whether access logs are enabled for the load balancer</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The interval for publishing the access logs. You can specify an interval of either 5 or 60 (minutes).</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The name of the Amazon S3 bucket where the access logs are stored</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket-prefix/prod&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The logical hierarchy you created for your Amazon S3 bucket, for example _my-bucket-prefix/prod_</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=mekanisme-draining-koneksi-pada-aws>Mekanisme <em>Draining</em> Koneksi pada AWS</h4><p>Mekanisme <em>draining</em> untuk ELB klasik dapat dilakukan dengan menggunakan anotasi
<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</code> serta mengatur
<em>value</em>-nya menjadi <code>"true"</code>. Anotasi
<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</code> juga
dapat digunakan untuk mengatur <em>maximum time</em> (dalam detik), untuk menjaga koneksi yang ada
agar selalu terbuka sebelum melakukan <em>deregistering</em> <em>instance</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=anotasi-elb-lainnya>Anotasi ELB lainnya</h4><p>Terdapat beberapa anotasi lain yang dapat digunakan untuk mengatur ELB klasik
sebagaimana dijelaskan seperti di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Specifies whether cross-zone load balancing is enabled for the load balancer</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;environment=prod,owner=devops&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># A comma-separated list of key-value pairs which will be recorded as</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># additional tags in the ELB.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The number of successive successful health checks required for a backend to</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># be considered healthy for traffic. Defaults to 2, must be between 2 and 10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The number of unsuccessful health checks required for a backend to be</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># considered unhealthy for traffic. Defaults to 6, must be between 2 and 10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The approximate interval, in seconds, between health checks of an</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># individual instance. Defaults to 10, must be between 5 and 300</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The amount of time, in seconds, during which no response means a failed</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># health check. This value must be less than the service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># value. Defaults to 5, must be between 2 and 60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-extra-security-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sg-53fae93f,sg-42efd82e&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># A list of additional security groups to be added to ELB</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=dukungan-network-load-balancer-nlb-pada-aws-alpha>Dukungan <em>Network Load Balancer</em> (NLB) pada AWS [alpha]</h4><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Ini merupakan tingkatan <em>alpha</em> dan tidak direkomendasikan untuk digunakan pada <em>environment</em> <em>production</em>.</div><p>Sejak versi 1.9.0, Kubernetes mendukung <em>Network Load Balancer</em> (NLB). Untuk
menggunakan NLB pada AWS, gunakan anotasi <code>service.beta.kubernetes.io/aws-load-balancer-type</code>
dan atur <em>value</em>-nya dengan <code>nlb</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nlb&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Tidak seperti ELB klasik, NLB, melakukan <em>forwarding</em> IP klien melalui <em>node</em>.
Jika <em>field</em> <code>.spec.externalTrafficPolicy</code> diatur <em>value</em>-nya menjadi <code>Cluster</code>, maka
alamat IP klien tidak akan diteruskan pada <code>Pod</code>.</p><p>Dengan mengatur <em>value</em> dari <em>field</em> <code>.spec.externalTrafficPolicy</code> ke <code>Local</code>,
alamat IP klien akan diteruskan ke <code>Pod</code>, tapi hal ini bisa menyebabkan distribusi trafik
yang tidak merata. <em>Node</em> yang tidak memiliki <code>Pod</code> untuk <code>Service</code> dengan tipe <code>LoadBalancer</code>
akan menyebabkan kegagalan <em>health check</em> <em>NLB Target</em> pada tahapan <em>auto-assigned</em> <code>.spec.healthCheckNodePort</code>
dan tidak akan menerima trafik apa pun.</p><p>Untuk menghasilkan distribusi trafik yang merata, kamu dapat menggunakan
<em>DaemonSet</em> atau melakukan spesifikasi
<a href=/id/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity-beta-feature>pod anti-affinity</a>
agar <code>Pod</code> tidak di-<em>assign</em> ke <em>node</em> yang sama.</p><p>NLB juga dapat digunakan dengan anotasi <a href=/id/docs/concepts/services-networking/service/#internal-load-balancer>internal load balancer</a>.</p><p>Agar trafik klien berhasil mencapai <em>instances</em> dibelakang ELB,
<em>security group</em> dari <em>node</em> akan diberikan <em>rules</em> IP sebagai berikut:</p><table><thead><tr><th><em>Rule</em></th><th>Protokol</th><th><code>Port</code></th><th><em>IpRange(s)</em></th><th>Deskripsi <em>IpRange</em></th></tr></thead><tbody><tr><td><em>Health Check</em></td><td>TCP</td><td>NodePort(s) (<code>.spec.healthCheckNodePort</code> for <em>.spec.externalTrafficPolicy = Local</em>)</td><td>VPC CIDR</td><td>kubernetes.io/rule/nlb/health=&lt;loadBalancerName></td></tr><tr><td><em>Client Traffic</em></td><td>TCP</td><td>NodePort(s)</td><td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td><td>kubernetes.io/rule/nlb/client=&lt;loadBalancerName></td></tr><tr><td><em>MTU Discovery</em></td><td>ICMP</td><td>3,4</td><td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td><td>kubernetes.io/rule/nlb/mtu=&lt;loadBalancerName></td></tr></tbody></table><p>Perhatikan bahwa jika <code>.spec.loadBalancerSourceRanges</code> tidak dispesifikasikan,
Kubernetes akan mengizinkan trafik dari <code>0.0.0.0/0</code> ke <em>Node Security Group</em>.
Jika <em>node</em> memiliki akses publik, maka kamu harus memperhatikan tersebut karena trafik yang tidak berasal
dari NLB juga dapat mengakses semua <em>instance</em> di <em>security group</em> tersebut.</p><p>Untuk membatasi klien IP mana yang dapat mengakses NLB,
kamu harus memberikan spesifikasi <em>loadBalancerSourceRanges</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancerSourceRanges</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;143.231.0.0/16&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> NLB hanya dapat digunakan dengan beberapa kelas <em>instance</em> tertentu baca <a href=http://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets>dokumentasi AWS</a>
untuk mengetahui lebih lanjut <em>intance</em> apa saja yang didukung.</div><h3 id=externalname>Tipe ExternalName</h3><p>Service dengan tipe <code>ExternalName</code> melakukan pemetaan antara <code>Service</code> dan DNS, dan bukan
ke <em>selector</em> seperti <code>my-service</code> atau <code>cassandra</code>. Kamu memberikan spesifikasi <code>spec.externalName</code>
pada <code>Service</code> tersebut.</p><p>Definisi <code>Service</code> ini, sebagai contoh, melaukan pemetaan
<code>Service</code> <code>my-service</code> pada <em>namespace</em> <code>prod</code> ke DNS <code>my.database.example.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>prod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ExternalName<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalName</span>:<span style=color:#bbb> </span>my.database.example.com<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <code>ExternalName</code> menerima alamat IPv4 dalam bentuk string,
tapi karena DNS tersusun atas angka dan bukan sebagai alamat IP.
<code>ExternalName</code> yang menyerupai alamat IPv4 tidak bisa di-<em>resolve</em> oleh <em>CoreDNS</em>
atau <em>ingress-nginx</em> karena <code>ExternalName</code> memang ditujukan bagi penamaan <em>canonical</em> DNS.
Untuk melakukan <em>hardcode</em> alamat IP, kamu dapat menggunakan <em>headless</em> <code>Service</code> sebagai alternatif.</div><p>Ketika melakukan pencarian <em>host</em> <code>my-service.prod.svc.cluster.local</code>,
servis DNS klaster akan mengembalikan <em>record</em> <code>CNAME</code> dengan <em>value</em> <code>my.database.example.com</code>.
Mekanisme akses pada <code>my-service</code> bekerja dengan cara yang sama dengan
<code>Service</code> pada umumnya, perbedaan yang krusial untuk hal ini adalah mekanisme <em>redirection</em>
terjadi pada tingkatan DNS dan bukan melalui <em>proxy forward</em>. Apabila kamu berniat memindahkan basis data
yang kamu pakai ke dalam klaster, kamu hanya perlu mengganti instans basis data kamu dan menjalankannya
di dalam <code>Pod</code>, menambahkan <em>selector</em> atau <em>endpoint</em> yang sesuai, serta mengupah <em>type</em> dari
<em>Service</em> yang kamu gunakan.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Bagian ini berasal dari tulisan <a href=https://akomljen.com/kubernetes-tips-part-1/>Tips Kubernetes - Bagian
1</a> oleh <a href=https://akomljen.com/>Alen Komljen</a>.</div><h3 id=ip-eksternal>IP Eksternal</h3><p>Jika terdapat sebuah alamat IP eksternal yang melakukan mekanisme <em>route</em> ke satu atau lebih <em>node</em> yang ada di klaster, <code>Service</code> Kubernetes dapat diekspos
dengan menggunakan <code>externalIP</code>. Trafik yang diarahkan ke klaster dengan IP eksternal
(sebagai destinasi IP), pada <em>port</em> <code>Service</code> akan di-<em>route</em> ke salah satu <em>endpoint</em> <code>Service</code>.
<em>Value</em> dari <code>externalIP</code> tidak diatur oleh Kubernetes dan merupakan tanggung jawab
dari administrator klaster.</p><p>Pada <em>ServiceSpec</em>, kamu dapat memberikan spesifikasi <code>externalIP</code> dan <code>ServiceTypes</code>.
Pada contoh di bawah ini. <code>"my-service"</code> dapat diakses oleh klien pada "<code>80.11.12.10:80</code>" (<code>externalIP:port</code>).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalIPs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#666>80.11.12.10</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=kekurangan>Kekurangan</h2><p>Penggunaan <em>proxy</em> <em>userspace</em> untuk VIP dapat digunakan untuk skala kecil hingga menengah,
meski begitu hal ini tidak <em>scalable</em> untuk klaster yang sangat besar dan memiliki ribuan <code>Service</code>.
Perhatikan <a href=http://issue.k8s.io/1107>Desain proposal orisinil untuk <em>portal</em></a> untuk informasi
lebih lanjut.</p><p>Penggunaan <em>proxy</em> <em>userspace</em> menghilangkan <em>source-IP</em> dari <em>packet</em> yang mengakses
sebuah <code>Service</code>. Hal ini membuat mekanisme <em>firewall</em> menjadi sulit untuk diterapkan.
<em>Proxy</em> <code>iptables</code> tidak menghilangkan <em>source IP</em> yang berasal dari dalam klaster,
meski begitu, hal ini masih berimbas pada klien yang berasal dari <code>Service</code> dengan tipe
<em>load-balancer</em> atau <em>node-port</em>.</p><p><em>Field</em> tipe didesain sebagai fungsionalitas yang berantai - setiap tingkatan
menambahkan tambahan pada tingkatansebelumnya. Hal ini tidak selalu berlaku bagi
semua penyedia layanan <em>cloud</em> (misalnya saja Google Compute Engine tidak perlu
melakukan alokasi <code>NodePort</code> untuk membuat <code>LoadBalancer</code> bekerja sebagaimana mestinya,
hal ini berbeda dengan AWS yang memerlukan hal ini, setidaknya untuk API yang mereka miliki
saat ini).</p><h2 id=pengerjaan-lebih-lanjut>Pengerjaan lebih lanjut</h2><p>Di masa mendatang, kami berencana untuk membuat <em>policy</em> <em>proxy</em> menjadi lebih
bervariasi dan bukan hanya <em>round robin</em>, misalnya saja <em>master-elected</em> atau <em>sharded</em>.
Kami juga berharap bahwa beberapa <code>Service</code> bisa saja memiliki <em>load balancer</em> yang sebenarnya,
suatu kasus dimana VIP akan secara langsung mengantarkan paket.</p><p>Kami ingin meningkatkan dukungan lebih lanjut untuk <code>Service</code> dengan tingkatan <code>Service</code> L7(HTTP).</p><p>Kami ingin memiliki mode <em>ingress</em> yang lebih fleksibel untuk <code>Service</code> yang
mencakup mode <code>ClusterIP</code>, <code>NodePort</code>, dan <code>LoadBalancer</code> dan banyak lagi.</p><h2 id=detail-mendalam-mengenai-ip-virtual>Detail mendalam mengenai IP virtual</h2><p>Informasi sebelumnya sudah cukup bagi sebagian orang yang hanya ingin menggunakan
<em>Service</em>. Meskipun begitu, terdapat banyak hal yang sebenarnya terjadi dan akan
sangat bermanfaat untuk dipelajari lebih lanjut.</p><h3 id=menghindari-collison>Menghindari <em>collison</em></h3><p>Salah satu filosofi Kubernetes adalah pengguna tidak mungkin menghadapi situasi
dimana apa yang mereka mengalami kegagalan tanpa adanya alasan yang jelas. Dalam kasus ini,
kita akan coba memahami lebih lanjut mengenai <em>network port</em> - pengguna tidak seharusnya memilih
nomor <em>port</em> jika hal itu memungkinkan terjadinya <em>collision</em> dengan pengguna lainnya. Hal ini
merupakan mekanisme isolasi kegagalan.</p><p>Agar pengguna dapat menentukan nomor <em>port</em> bagi <code>Service</code> mereka, kita harus
memastikan bahwa tidak ada dua <code>Service</code> yang mengalami <em>collision</em>. Kita melakukan
hal tersebut dengan cara melakukan alokasi alamat IP pada setiap <code>Service</code>.</p><p>Untuk memastikan setiap <code>Service</code> memiliki alamat IP yang unik, sebuah <em>allocator</em>
internal akan secara atomik melakukan pemetaan alokasi global di dalam <em>etcd</em> ketika
membuat sebuah <code>Service</code> baru. Pemetaan objek harus tersedia pada <em>registry</em> <code>Service</code>
dimana <code>Service</code> akan diberikan sebuah IP, jika tidak, proses pembuatan <code>Service</code> akan gagal
dan sebuah pesan akan memberikan informasi bahwa alamat IP tidak dapat dialokasikan.
Sebuah <em>backgroud</em> <em>controller</em> bertanggung jawab terhadap mekanisme pemetaan tersebut (migrasi
dari versi Kubernetes yang digunakan dalam <em>memory locking</em>) sekaligus melakukan pengecekan
terhadap <em>assignment</em> yang tidak valid yang terjadi akibat intervensi administrator dan melakukan
penghapusan daftar IP yang dialokasikan tapi tidak digunakan oleh <code>Service</code> mana pun.</p><h3 id=ip-dan-vip>IP dan VIP</h3><p>Tidak seperti alamat IP <code>Pod</code>, yang akan di <em>route</em> ke destinasi yang "pasti",
IP <code>Service</code> tidak mengarahkan <em>request</em> hanya pada satu <em>host</em>. Sebagai gantinya,
kita mneggunakan <code>iptables</code> (logika pemrosesan paket pada Linux) untuk melakukan definisi
alamat IP virtual yang secara transparan akan diarahkan sesuai kebutuhan. Ketika klien
dihubungkan pada VIP, trafik yang ada akan secara otomatis dialihkan pada <em>endpoint</em> yang sesuai.
Variabel <em>environment</em> dan DNS untuk <code>Service</code> terdiri dalam bentuk VIP dan <em>port</em>.</p><p>Kami mendukung tiga jenis mode <em>proxy</em> - <em>userspace</em>, <code>iptables</code>, dan <em>ipvs</em> yang memiliki
perbedaan cara kerja satu sama lainnya.</p><h4 id=userspace><em>Userspace</em></h4><p>Sebagai contoh, anggaplah kita memiliki aplikasi <em>image processing</em> seperti yang sudah
disebutkan di atas. Ketika <code>Service</code> <em>backend</em> dibuat, <em>master</em> Kubernetes akan mengalokasikan
sebuah alamat IP virtual, misalnya 10.0.0.1. Dengan asumsi <em>port</em> dari <code>Service</code> tersebut adalah <em>1234</em>,
maka <code>Service</code> tersebut akan diamati oleh semua <em>instance</em> <code>kube-proxy</code> yang ada di klaster.
Ketika sebuah <em>proxy</em> mendapati sebuah <code>Service</code> baru, <em>proxy</em> tersebut akan membuka sebuah <em>port</em>
<em>acak</em>, menyediakan <code>iptables</code> yang mengarahkan VIP pada <em>port</em> yang baru saja dibuat, dan mulai
koneksi pada <em>port</em> tersebut.</p><p>Ketika sebuah klien terhubung ke VIP dan terdapat <em>rules</em> <code>iptables</code>
yang diterapkan, paket akan diarahkan ke <em>port</em> dari <em>proxy</em> <code>Service</code> itu sendiri.
<em>Proxy</em> <code>Service</code> akan memilih sebuah <em>backend</em>, dan mulai melakukan mekanisme <em>proxy</em>
trafik dari klien ke <em>backend</em>.</p><p>Dengan demikian, pemilik <code>Service</code> dapat memilih <em>port</em> mana pun yang dia inginkan
tanpa adanya kemungkinan terjadinya <em>collision</em>. Klien dapat dengan mudah mengakses IP dan <em>port</em>,
tanpa harus mengetahui <code>Pod</code> mana yang sebenarnya diakses.</p><h4 id=iptables><em>Iptables</em></h4><p>Kembali, bayangkan apabila kita memiliki aplikasi <em>image processing</em> seperti yang sudah
disebutkan di atas. Ketika <code>Service</code> <em>backend</em> dibuat, <em>master</em> Kubernetes akan mengalokasikan
sebuah alamat IP virtual, misalnya 10.0.0.1. Dengan asumsi <em>port</em> dari <code>Service</code> tersebut adalah <em>1234</em>,
maka <code>Service</code> tersebut akan diamati oleh semua <em>instance</em> <code>kube-proxy</code> yang ada di klaster.
Ketika sebuah <em>proxy</em> mendapati sebuah <code>Service</code> baru, <em>proxy</em> tersebut akan melakukan instalasi
serangkaian <em>rules</em> <code>iptables</code> yang akan melakukan <em>redirect</em> VIP ke <em>rules</em> tiap <code>Service</code>. <em>Rules</em>
untuk tiap <code>Service</code> ini terkait dengan <em>rules</em> tiap <code>Endpoints</code> yang mengarahkan (destinasi NAT)
ke <em>backend</em>.</p><p>Ketika sebuah klien terhubung ke VIP dan terdapat _rules _iptables
yang diterapkan. Sebuah <em>backend</em> akan dipilih (hal ini dapat dilakukan berdasarkan <em>session affinity</em>
maupun secara <em>acak</em>) dan paket-paket yang ada akan diarahkan ke <em>backend</em>. Tidak seperti mekanisme
yang terjadi di <em>userspace</em>, paket-paket yang ada tidak pernah disalin ke <em>userspace</em>, <code>kube-proxy</code>
tidak harus aktif untuk menjamin kerja VIP, serta IP klien juga tidak perlu diubah.</p><p>Tahapan yang dijalankan sama dengan tahapan yang dijalankan ketika trafik masuk melalui sebuah <em>node-port</em>
atau <em>load-balancer</em>, meskipun pada dua kasus di atas klien IP tidak akan mengalami perubahan.</p><h4 id=ipvs><em>Ipvs</em></h4><p>Operasi <code>iptables</code> berlangsung secara lambat pada klaster dengan skala besar (lebih dari 10.000 <code>Service</code>).
<em>IPVS</em> didesain untuk mekanisme <em>load balance</em> dan berbasis pada <em>hash tables</em> yang berada di dalam <em>kernel</em>.
Dengan demikian kita dapat mendapatkan performa yang konsisten pada jumlah <code>Service</code> yang cukup besar dengan
menggunakan <code>kube-proxy</code> berbasis <em>ipvs</em>. Sementara itu, <code>kube-proxy</code> berbasis <em>ipvs</em> memiliki algoritma
<em>load balance</em> yang lebih bervariasi (misalnya saja <em>least conns</em>, <em>locality</em>, <em>weighted</em>, <em>persistence</em>).</p><h2 id=objek-api>Objek API</h2><p><em>Service</em> merupakan <em>resource</em> <em>top-level</em> pada API Kubernetes.
Penjelasan lebih lanjut mengenai objek API dapat ditemukan pada:
<a href=/docs/reference/generated/kubernetes-api/v1.25/#service-v1-core>objek API <code>Service</code></a>.</p><h2 id=protokol-yang-tersedia>Protokol yang didukung</h2><h3 id=tcp>TCP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>Kamu dapat menggunakan TCP untuk <code>Service</code> dengan <em>type</em> apa pun, dan protokol ini merupakan
protokol <em>default</em> yang digunakan.</p><h3 id=udp>UDP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>Kamu dapat menggunakan UDP untuk sebagian besar <code>Service</code>.
Untuk <code>Service</code> dengan <em>type=LoadBalancer</em>, dukungan terhadap UDP
bergantung pada penyedia layanan <em>cloud</em> yang kamu gunakan.</p><h3 id=http>HTTP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.1 [stable]</code></div><p>Apabila penyedia layanan <em>cloud</em> yang kamu gunakan mendukung, kamu dapat menggunakan
<em>Service</em> dengan <em>type</em> <code>LoadBalancer</code> untuk melakukan mekanisme <em>reverse</em> <em>proxy</em>
bagi HTTP/HTTPS, dan melakukan <em>forwarding</em> ke <code>Endpoints</code> dari _Service.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu juga dapat menggunakan <a class=glossary-tooltip title='Sebuah obyek API yang mengatur akses eksternal terhadap Service yang ada di dalam klaster, biasanya dalam bentuk request HTTP.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/ingress/ target=_blank aria-label=Ingress>Ingress</a> sebagai salah satu
alternatif penggunaan <code>Service</code> untuk HTTP/HTTPS.</div><h3 id=protokol-proxy>Protokol PROXY</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.1 [stable]</code></div><p>Apabila penyedia layanan <em>cloud</em> yang kamu gunakan mendukung, (misalnya saja, <a href=/id/docs/concepts/cluster-administration/cloud-providers/#aws>AWS</a>),
<em>Service</em> dengan <em>type</em> <code>LoadBalancer</code> untuk melakukan konfigurasi <em>load balancer</em>
di luar Kubernetes sendiri, serta akan melakukan <em>forwarding</em> koneksi yang memiliki prefiks
<a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>protokol PROXY</a>.</p><p><em>Load balancer</em> akan melakukan serangkaian inisiasi <em>octet</em> yang memberikan
deskripsi koneksi yang datang, dengan bentuk yang menyerupai:</p><pre tabindex=0><code>PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n
</code></pre><p>yang kemudian diikuti data dari klien.</p><h3 id=sctp>SCTP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>Kubernetes memberikan dukungan bagi SCTP sebagai <em>value</em> dari <em>definition</em> yang ada pada
<em>Service</em>, <code>Endpoints</code>, <code>NetworkPolicy</code> dan <code>Pod</code> sebagai fitur <em>alpha</em>. Untuk mengaktifkan fitur ini,
administrator klaster harus mengaktifkan <em>feature gate</em> <em>SCTPSupport</em> pada <em>apiserver</em>, contohnya
<code>“--feature-gates=SCTPSupport=true,...”</code>. Ketika <em>fature gate</em> ini diaktifkan, pengguna dapat
memberikan <em>value</em> SCTP pada <em>field</em> <em>protocol</em> <code>Service</code>, <code>Endpoints</code>, <code>NetworkPolicy</code> dan <code>Pod</code>.
Kubernetes kemudian akan melakukan pengaturan agar jaringan yang digunakan agar jaringan tersebut menggunakan SCTP,
seperti halnya Kubernetes mengatur jaringan agar menggunakan TCP.</p><h4 id=kelemahan-penggunaan-sctp>Perhatian</h4><h5 id=kelemahan-sctp-multihomed>Dukungan untuk asoasiasi <em>multihomed</em> SCTP</h5><p>Dukungan untuk asosiasi <em>multihomed</em> SCTP membutuhkan <em>plugin</em> CNI yang dapat memberikan
pengalokasian <em>multiple interface</em> serta alamat IP pada sebuah <code>Pod</code>.</p><p>NAT untuk asosiasi <em>multihomed</em> SCTP membutuhkan logika khusus pada modul kernel terkait.</p><h5 id=kelemahan-sctp-loadbalancer-service-type><code>Service</code> dengan <em>type=LoadBalancer</em></h5><p>Sebuah <code>Service</code> dengan <em>type</em> <code>LoadBalancer</code> dan protokol SCTP dapat dibuat
hanya jika implementasi <em>load balancer</em> penyedia layanan <em>cloud</em> menyediakan dukungan
bagi protokol SCTP. Apabila hal ini tidak terpenuhi, maka <em>request</em> pembuatan <em>Servixe</em> ini akan ditolak.
<em>Load balancer</em> yang disediakan oleh penyedia layanan <em>cloud</em> yang ada saat ini (<em>Azure</em>, <em>AWS</em>, <em>CloudStack</em>, <em>GCE</em>, <em>OpenStack</em>) tidak mendukung SCTP.</p><h5 id=kelemahan-sctp-windows-os>Windows</h5><p>SCTP tidak didukung pada <em>node</em> berbasis Windows.</p><h5 id=kelemahan-sctp-kube-proxy-userspace><em>Kube-proxy</em> <em>userspace</em></h5><p><em>Kube-proxy</em> tidak mendukung manajemen asosiasi SCTP ketika hal ini dilakukan pada mode
<em>userspace</em></p><h2 id=selanjutnya>Selanjutnya</h2><p>Baca <a href=/docs/tasks/access-application-cluster/connecting-frontend-backend/>Bagaimana cara menghubungkan <em>Front End</em> ke <em>Back End</em> menggunakan sebuah <code>Service</code></a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3a38878244d862dfdb8d7adb32f77584>2 - Topologi Service (Service Topology)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code></div><p>Topologi Service memungkinkan Service untuk
merutekan lalu lintas jaringan berdasarkan topologi Node dalam klaster. Misalnya, suatu
layanan dapat menentukan lalu lintas jaringan yang lebih diutamakan untuk dirutekan ke
beberapa <em>endpoint</em> yang berada pada Node yang sama dengan klien, atau pada
<em>availability zone</em> yang sama.</p><h2 id=pengantar>Pengantar</h2><p>Secara bawaan lalu lintas jaringan yang dikirim ke <code>ClusterIP</code> atau <code>NodePort</code> dari Service
dapat dialihkan ke alamat <em>backend</em> untuk Service tersebut. Sejak Kubernetes 1.7
dimungkinkan untuk merutekan lalu lintas jaringan "eksternal" ke Pod yang berjalan di
Node yang menerima lalu lintas jaringan, tetapi fitur ini tidak didukung untuk <code>ClusterIP</code> dari
Service, dan topologi yang lebih kompleks — seperti rute zonasi —
belum memungkinkan. Fitur topologi Service mengatasi kekurangan ini dengan
mengizinkan pembuat layanan untuk mendefinisikan kebijakan dalam merutekan lalu lintas jaringan
berdasarkan label Node untuk Node-Node asal dan tujuan.</p><p>Dengan menggunakan label Node yang sesuai antara asal dan tujuan, operator dapat
menunjuk kelompok Node mana yang "lebih dekat" dan mana yang "lebih jauh" antara satu sama lain,
dengan menggunakan metrik apa pun yang masuk akal untuk memenuhi persyaratan
dari operator itu. Untuk sebagian besar operator di publik <em>cloud</em>, misalnya, ada
preferensi untuk menjaga layanan lalu lintas jaringan dalam zona yang sama, karena lalu lintas jaringan
antar zona memiliki biaya yang dibebankan, sementara lalu lintas jaringan
dalam zona yang sama tidak ada biaya. Kebutuhan umum lainnya termasuk kemampuan untuk merutekan
lalu lintas jaringan ke Pod lokal yang dikelola oleh sebuah DaemonSet, atau menjaga lalu lintas jaringan ke
Node yang terhubung ke <em>top-of-rack switch</em> yang sama untuk mendapatkan
latensi yang terendah.</p><h2 id=menggunakan-topologi-service>Menggunakan Topologi Service</h2><p>Jika klaster kamu mengaktifkan topologi Service kamu dapat mengontrol rute lalu lintas jaringan Service
dengan mengatur bagian <code>topologyKeys</code> pada spesifikasi Service. Bagian ini
adalah daftar urutan label-label Node yang akan digunakan untuk mengurutkan <em>endpoint</em>
saat mengakses Service ini. Lalu lintas jaringan akan diarahkan ke Node yang nilai
label pertamanya cocok dengan nilai dari Node asal untuk label yang sama. Jika
tidak ada <em>backend</em> untuk Service pada Node yang sesuai, maka label kedua akan
dipertimbangkan, dan seterusnya, sampai tidak ada label yang tersisa.</p><p>Jika tidak ditemukan kecocokan, lalu lintas jaringan akan ditolak, sama seperti jika tidak ada
sama sekali <em>backend</em> untuk Service tersebut. Artinya, <em>endpoint</em> dipilih
berdasarkan kunci topologi yang pertama yang tersedia pada <em>backend</em>. Jika dalam
bagian ini ditentukan dan semua entri tidak memiliki <em>backend</em> yang sesuai dengan
topologi klien, maka Service tidak memiliki <em>backend</em> untuk klien dan koneksi harus
digagalkan. Nilai khusus <code>"*"</code> dapat digunakan untuk mengartikan "topologi
apa saja". Nilai <em>catch-all</em> ini, jika digunakan, maka hanya sebagai
nilai terakhir dalam daftar.</p><p>Jika <code>topologyKeys</code> tidak ditentukan atau kosong, tidak ada batasan topologi
yang akan diterapkan.</p><p>Seandainya sebuah klaster dengan Node yang dilabeli dengan nama <em>host</em> ,
nama zona, dan nama wilayah mereka, maka kamu dapat mengatur nilai
<code>topologyKeys</code> dari sebuah Service untuk mengarahkan lalu lintas jaringan seperti berikut ini.</p><ul><li>Hanya ke <em>endpoint</em> dalam Node yang sama, gagal jika tidak ada <em>endpoint</em> pada Node: <code>["kubernetes.io/hostname"]</code>.</li><li>Lebih memilih ke <em>endpoint</em> dalam Node yang sama, jika tidak ditemukan maka ke <em>endpoint</em> pada zona yang sama, diikuti oleh wilayah yang sama, dan selain itu akan gagal: <code>["kubernetes.io/hostname ", "topology.kubernetes.io/zone", "topology.kubernetes.io/region"]</code>. Ini mungkin berguna, misalnya, dalam kasus di mana lokalitas data sangatlah penting.</li><li>Lebih memilih ke <em>endpoint</em> dalam zona yang sama, tetapi memilih <em>endpoint</em> mana saja yang tersedia apabila tidak ada yang tersedia dalam zona ini: <code>["topology.kubernetes.io/zone ","*"]</code>.</li></ul><h2 id=batasan>Batasan</h2><ul><li>Topologi Service tidak kompatibel dengan <code>externalTrafficPolicy=Local</code>, dan karena itu Service tidak dapat menggunakan kedua fitur ini sekaligus. Dimungkinkan untuk menggunakan kedua fitur pada klaster yang sama untuk Service yang berbeda, bukan untuk Service yang sama.</li><li>Untuk saat ini kunci topologi yang valid hanya terbatas pada <code>kubernetes.io/hostname</code>, <code>topology.kubernetes.io/zone</code>, dan <code>topology.kubernetes.io/region</code>, tetapi akan digeneralisasikan ke label Node yang lain di masa depan.</li><li>Kunci topologi harus merupakan kunci label yang valid dan paling banyak hanya 16 kunci yang dapat ditentukan.</li><li>Nilai <em>catch-all</em>, <code>"*"</code>, harus menjadi nilai terakhir pada kunci topologi, jika nilai itu digunakan.</li></ul><h2 id=contoh>Contoh</h2><p>Berikut ini adalah contoh umum penggunaan fitur topologi Service.</p><h3 id=hanya-pada-endpoint-pada-node-lokal>Hanya pada <em>endpoint</em> pada Node lokal</h3><p>Service yang hanya merutekan ke <em>endpoint</em> pada Node lokal. Jika tidak ada <em>endpoint</em> pada Node, lalu lintas jaringan akan dihentikan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=lebih-memilih-endpoint-pada-node-lokal>Lebih memilih <em>endpoint</em> pada Node lokal</h3><p>Service yang lebih memilih <em>endpoint</em> pada Node lokal, namun akan memilih ke <em>endpoint</em>
dalam klaster jika <em>endpoint</em> pada Node lokal tidak ada:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=hanya-untuk-endpoint-pada-zona-atau-wilayah-yang-sama>Hanya untuk <em>endpoint</em> pada zona atau wilayah yang sama</h3><p>Service yang lebih memilih <em>endpoint</em> dalam zona yang sama daripada wilayah yang sama. Jika tidak ada <em>endpoint</em> pada<br>keduanya, maka lalu lintas jaringan akan dihentikan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=lebih-memilih-endpoint-pada-node-lokal-zona-yang-sama-dan-kemudian-wilayah-yang-sama>Lebih memilih <em>endpoint</em> pada Node lokal, zona yang sama, dan kemudian wilayah yang sama</h3><p>Service yang lebih memilih <em>endpoint</em> pada Node lokal, zona yang sama, dan kemudian baru wilayah yang sama,
namun jika tetap tidak ditemukan maka akan memilih <em>endpoint</em> diseluruh klaster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Baca tentang <a href=/docs/tasks/administer-cluster/enabling-service-topology>mengaktifkan topologi Service</a></li><li>Baca <a href=/id/docs/concepts/services-networking/connect-applications-service/>menghubungkan aplikasi dengan Service</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f51db1097575de8072afe1f5b156a70c>3 - EndpointSlice</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p>EndpointSlice menyediakan sebuah cara yang mudah untuk melacak <em>endpoint</em> jaringan dalam sebuah
klaster Kubernetes. EndpointSlice memberikan alternatif yang lebih <em>scalable</em> dan lebih dapat diperluas dibandingkan dengan Endpoints.</p><h2 id=motivasi>Motivasi</h2><p>Endpoints API telah menyediakan sebuah cara yang mudah dan sederhana untuk
melacak <em>endpoint</em> jaringan pada Kubernetes. Sayangnya, seiring dengan besarnya klaster Kubernetes
dan Service, batasan-batasan yang dimiliki API tersebut semakin terlihat.
Terutama, hal tersebut termasuk kendala-kendala mengenai proses <em>scaling</em> <em>endpoint</em> jaringan
dalam jumlah yang besar.</p><p>Karena semua <em>endpoint</em> jaringan untuk sebuah Service disimpan dalam satu sumber daya
Endpoints, sumber daya tersebut dapat menjadi cukup besar. Hal itu dapat mempengaruhi kinerja
dari komponen-komponen Kubernetes (terutama <em>master control plane</em>) dan menyebabkan
lalu lintas jaringan dan pemrosesan yang cukup besar ketika Endpoints berubah.
EndpointSlice membantu kamu menghindari masalah-masalah tersebut dan juga menyediakan platform
yang dapat diperluas untuk fitur-fitur tambahan seperti <em>topological routing</em>.</p><h2 id=sumber-daya-endpointslice>Sumber daya EndpointSlice</h2><p>Pada Kubernetes, sebuah EndpointSlice memiliki referensi-referensi terhadap sekumpulan <em>endpoint</em>
jaringan. <em>Controller</em> EndpointSlice secara otomatis membuat EndpointSlice
untuk sebuah Service Kubernetes ketika sebuah <a class=glossary-tooltip title='Allows users to filter a list of resources based on labels.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selektor>selektor</a> dituliskan. EndpointSlice tersebut akan memiliki
referensi-referensi menuju Pod manapun yang cocok dengan selektor pada Service tersebut. EndpointSlice mengelompokkan
<em>endpoint</em> jaringan berdasarkan kombinasi Service dan Port yang unik.
Nama dari sebuah objek EndpointSlice haruslah berupa
<a href=/id/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nama subdomain DNS</a> yang sah.</p><p>Sebagai contoh, berikut merupakan sampel sumber daya EndpointSlice untuk sebuah Service Kubernetes
yang bernama <code>example</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>discovery.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EndpointSlice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-abc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>addressType</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>endpoints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>pod-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topology</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>node-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>topology.kubernetes.io/zone</span>:<span style=color:#bbb> </span>us-west2-a<span style=color:#bbb>
</span></span></span></code></pre></div><p>Secara bawaan, setiap EndpointSlice yang dikelola oleh <em>controller</em> EndpointSlice tidak akan memiliki
lebih dari 100 <em>endpoint</em>. Di bawah skala tersebut, EndpointSlice akan memetakan 1:1
dengan Endpoints dan Service dan akan memiliki kinerja yang sama.</p><p>EndpointSlice dapat bertindak sebagai sumber kebenaran untuk kube-proxy sebagai acuan mengenai
bagaimana cara untuk merutekan lalu lintas jaringan internal. Ketika diaktifkan, EndpointSlice semestinya memberikan peningkatan
kinerja untuk Service yang memiliki Endpoints dalam jumlah besar.</p><h3 id=tipe-tipe-alamat>Tipe-tipe Alamat</h3><p>EndpointSlice mendukung tiga tipe alamat:</p><ul><li>IPv4</li><li>IPv6</li><li>FQDN (<em>Fully Qualified Domain Name</em>)</li></ul><h3 id=topologi>Topologi</h3><p>Setiap <em>endpoint</em> pada EndpointSlice dapat memiliki informasi topologi yang relevan.
Hal ini digunakan untuk mengindikasikan di mana <em>endpoint</em> berada, berisi informasi mengenai
Node yang bersangkutan, zona, dan wilayah. Ketika nilai-nilai tersebut tersedia,
label-label Topology berikut akan ditambahkan oleh <em>controller</em> EndpointSlice:</p><ul><li><code>kubernetes.io/hostname</code> - Nama dari Node tempat <em>endpoint</em> berada.</li><li><code>topology.kubernetes.io/zone</code> - Zona tempat <em>endpoint</em> berada.</li><li><code>topology.kubernetes.io/region</code> - Region tempat <em>endpoint</em> berada.</li></ul><p>Nilai-nilai dari label-label berikut berasal dari sumber daya yang diasosiasikan dengan tiap
<em>endpoint</em> pada sebuah <em>slice</em>. Label <em>hostname</em> merepresentasikan nilai dari kolom NodeName
pada Pod yang bersangkutan. Label zona dan wilayah merepresentasikan nilai
dari label-label dengan nama yang sama pada Node yang bersangkutan.</p><h3 id=pengelolaan>Pengelolaan</h3><p>Secara bawaan, EndpointSlice dibuat dan dikelola oleh <em>controller</em>
EndpointSlice. Ada berbagai macam kasus lain untuk EndpointSlice, seperti
implementasi <em>service mesh</em>, yang memungkinkan adanya entitas atau <em>controller</em> lain
yang dapat mengelola beberapa EndpointSlice sekaligus. Untuk memastikan beberapa entitas dapat
mengelola EndpointSlice tanpa mengganggu satu sama lain, sebuah
label <code>endpointslice.kubernetes.io/managed-by</code> digunakan untuk mengindikasikan entitas
yang mengelola sebuah EndpointSlice. <em>Controller</em> EndpointSlice akan menambahkan
<code>endpointslice-controller.k8s.io</code> sebagai nilai dari label tersebut pada seluruh
EndpointSlice yang dikelolanya. Entitas lain yang mengelola EndpointSlice juga diharuskan untuk
menambahkan nilai yang unik untuk label tersebut.</p><h3 id=kepemilikan>Kepemilikan</h3><p>Pada kebanyakan kasus, EndpointSlice akan dimiliki oleh Service yang diikutinya. Hal ini diindikasikan dengan referensi pemilik pada tiap EndpointSlice dan
juga label <code>kubernetes.io/service-name</code> yang memudahkan pencarian seluruh
EndpointSlice yang dimiliki oleh sebuah Service.</p><h2 id=controller-endpointslice><em>Controller</em> EndpointSlice</h2><p><em>Controller</em> EndpointSlice mengamati Service dan Pod untuk memastikan EndpointSlice
yang bersangkutan berada dalam kondisi terkini. <em>Controller</em> EndpointSlice akan mengelola EndpointSlice untuk
setiap Service yang memiliki selektor. Ini akan merepresentasikan IP dari Pod
yang cocok dengan selektor dari Service tersebut.</p><h3 id=ukuran-endpointslice>Ukuran EndpointSlice</h3><p>Secara bawaan, jumlah <em>endpoint</em> yang dapat dimiliki tiap EndpointSlice dibatasi sebanyak 100 <em>endpoint</em>. Kamu dapat
mengaturnya melalui opsi <code>--max-endpoints-per-slice</code> <a class=glossary-tooltip title='Komponen control plane yang menjalankan pengontrol.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> sampai dengan
jumlah maksimum sebanyak 1000 <em>endpoint</em>.</p><h3 id=distribusi-endpointslice>Distribusi EndpointSlice</h3><p>Tiap EndpointSlice memiliki sekumpulan <em>port</em> yang berlaku untuk seluruh <em>endpoint</em> dalam sebuah sumber daya. Ketika nama <em>port</em> digunakan untuk sebuah Service, Pod mungkin mendapatkan
nomor target <em>port</em> yang berbeda-beda untuk nama <em>port</em> yang sama, sehingga membutuhkan
EndpointSlice yang berbeda. Hal ini mirip dengan logika mengenai bagaimana <em>subset</em> dikelompokkan
dengan Endpoints.</p><p><em>Controller EndpointSlice</em> akan mencoba untuk mengisi EndpointSlice sebanyak mungkin, tetapi tidak
secara aktif melakukan <em>rebalance</em> terhadap EndpointSlice tersebut. Logika dari <em>controller</em> cukup sederhana:</p><ol><li>Melakukan iterasi terhadap EndpointSlice yang sudah ada, menghapus <em>endpoint</em> yang sudah tidak lagi
dibutuhkan dan memperbarui <em>endpoint</em> yang sesuai yang mungkin telah berubah.</li><li>Melakukan iterasi terhadap EndpointSlice yang sudah dimodifikasi pada langkah pertama dan
mengisinya dengan <em>endpoint</em> baru yang dibutuhkan.</li><li>Jika masih tersisa <em>endpoint</em> baru untuk ditambahkan, mencoba untuk menambahkannya pada
<em>slice</em> yang tidak berubah sebelumnya dan/atau membuat <em>slice</em> yang baru.</li></ol><p>Terlebih penting, langkah ketiga memprioritaskan untuk membatasi pembaruan EndpointSlice terhadap
distribusi dari EndpointSlice yang benar-benar penuh. Sebagai contoh, jika ada 10
<em>endpoint</em> baru untuk ditambahkan dan ada 2 EndpointSlice yang masing-masing memiliki ruang untuk 5 <em>endpoint</em> baru,
pendekatan ini akan membuat sebuah EndpointSlice baru daripada mengisi 2
EndpointSlice yang sudah ada. Dengan kata lain, pembuatan sebuah EndpointSlice
lebih diutamakan daripada pembaruan beberapa EndpointSlice.</p><p>Dengan kube-proxy yang berjalan pada tiap Node dan mengamati EndpointSlice, setiap perubahan
pada sebuah EndpointSlice menjadi sangat mahal karena hal tersebut akan dikirimkan ke
setiap Node dalam klaster. Pendekatan ini ditujukan untuk membatasi jumlah
perubahan yang perlu dikirimkan ke setiap Node, meskipun hal tersebut berdampak pada banyaknya
EndpointSlice yang tidak penuh.</p><p>Pada praktiknya, distribusi yang kurang ideal seperti ini akan jarang ditemukan. Kebanyakan perubahan yang diproses oleh <em>controller</em> EndpointSlice akan cukup kecil untuk dapat masuk pada
EndpointSlice yang sudah ada, dan jika tidak, cepat atau lambat sebuah EndpointSlice baru
akan segera dibutuhkan. Pembaruan bertahap (<em>rolling update</em>) dari Deployment juga menyediakan sebuah proses
pengemasan ulang EndpointSlice yang natural seiring dengan digantikannya seluruh Pod dan <em>endpoint</em> yang
bersangkutan.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/administer-cluster/enabling-endpointslices>Mengaktifkan EndpointSlice</a></li><li>Baca <a href=/id/docs/concepts/services-networking/connect-applications-service/>Menghubungkan Aplikasi dengan Service</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-91cb8a4438b003df11bc1c426a81b756>4 - DNS untuk Service dan Pod</h1><p>Laman ini menyediakan ikhtisar dari dukungan DNS oleh Kubernetes.</p><h2 id=pendahuluan>Pendahuluan</h2><p>Kubernetes DNS melakukan <em>scheduling</em> DNS Pod dan Service yang ada pada klaster, serta
melakukan konfigurasi kubelet untuk memberikan informasi bagi setiap Container
untuk menggunakan DNS Service IP untuk melakukan resolusi DNS.</p><h3 id=apa-sajakah-yang-mendapatkan-nama-dns>Apa Sajakah yang Mendapatkan Nama DNS?</h3><p>Setiap Service yang didefinisikan di dalam klaster (termasuk server DNS itu sendiri)
memiliki nama DNS. Secara default, sebuah <em>list</em> pencarian DNS pada Pod klien
akan mencantumkan <em>namespace</em> Pod itu sendiri serta domain <em>default</em> klaster. Hal ini dapat diilustrasikan
dengan contoh berikut:</p><p>Asumsikan sebuah Service dengan nama <code>foo</code> pada Kubernetes dengan <em>namespace</em> <code>bar</code>.
Sebuah Pod yang dijalankan di <em>namespace</em> <code>bar</code> dapat melakukan resolusi
terhadap Service ini dengan melakukan <em>query</em> DNS
untuk <code>foo</code>. Sebuah Pod yang dijalankan pada namespace <code>quux</code> dapat melakukan
resolusi Service ini dengan melakukan <em>query</em> DNS untuk <code>foo.bar</code>.</p><p>Bagian di bawah ini akan menampilkan detail tipe rekaman serta <em>layout</em> yang didukung.
<em>Layout</em> atau nama <em>query</em> lain yang dapat digunakan dianggap sebagai detail implementasi
yang bisa saja berubah tanpa adanya pemberitahuan sebelumnya. Untuk informasi spesifikasi
terbaru kamu dapat membaca <a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>Service Discovery pada Kubernetes berbasis DNS</a>.</p><h2 id=service>Service</h2><h3 id=a-record>A record</h3><p>Service "Normal" (bukan <em>headless</em>) akan diberikan sebuah A <em>record</em> untuk sebuah nama dalam bentuk
<code>my-svc.my-namespace.svc.cluster-domain.example</code>. Inilah yang kemudian digunakan untuk melakukan
resolusi IP klaster dari Service tersebut.</p><p>Service "Headless" (tanpa IP klaster) juga memiliki sebuah A <em>record</em> DNS dengan format
<code>my-svc.my-namespace.svc.cluster-domain.example</code>. Tidak seperti halnya Service normal,
DNS ini akan melakukan resolusi pada serangkauan IP dari Pod yang dipilih oleh Service tadi.
Klien diharapkan untuk mengkonsumsi serangkaian IP ini atau cara lain yang digunakan adalah pemilihan
menggunakan penjadwalan Round-Robin dari set yang ada.</p><h3 id=srv-record>SRV <em>record</em></h3><p>SRV <em>record</em> dibuat untuk port bernama yang merupakan bagian dari Service normal maupun <a href=/id/docs/concepts/services-networking/service/#headless-services>Headless
Services</a>.
Untuk setiap port bernama, SRV <em>record</em> akan memiliki format
<code>_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster-domain.example</code>.
Untuk sebuah Service normal, ini akan melakukan resolusi pada nomor port dan
nama domain: <code>my-svc.my-namespace.svc.cluster-domain.example</code>.
Untuk Service headless, ini akan melakukan resolusi pada serangkaian Pod yang merupakan <em>backend</em> dari Service
tersebut yang memiliki format: <code>auto-generated-name.my-svc.my-namespace.svc.cluster-domain.example</code>.</p><h2 id=pod>Pod</h2><h3 id=hostname-pod-dan-field-subdomain>Hostname Pod dan <em>Field</em> Subdomain</h3><p>Saat ini ketika sebuah Pod dibuat, <em>hostname</em>-nya adalah nilai dari <code>metadata.name</code>.</p><p>Spek Pod memiliki <em>field</em> opsional <code>hostname</code>, yang dapat digunakan untuk menspesifikasikan
<em>hostname</em> Pod. Ketika dispesifikasikan, maka nama ini akan didahulukan di atas nama Pod .
Misalnya, sebuah Pod dengan <code>hostname</code> yang diberikan nilai "<code>my-host</code>", maka <em>hostname</em> Pod tersebut akan menjadi "<code>my-host</code>".</p><p>Spek Pod juga memiliki <em>field</em> opsional <code>subdomain</code> yang dapat digunakan untuk menspesifikasikan
subdomain Pod tersebut. Misalnya saja sebuah Pod dengan <code>hostname</code> yang diberi nilai "<code>foo</code>", dan <code>subdomain</code>
yang diberi nilai "<code>bar</code>", pada <em>namespace</em> "<code>my-namespace</code>", akan memiliki <em>fully qualified
domain name</em> (FQDN) "<code>foo.bar.my-namespace.svc.cluster-domain.example</code>".</p><p>Contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Actually, no port is needed.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika terdapat sebuah Service <em>headless</em> memiliki nama yang sama dengan
subdomain dari suatu Pod pada <em>namespace</em> yang sama, server KubeDNS klaster akan mengembalikan
A <em>record</em> untuk FQDN Pod.
Sebagai contoh, misalnya terdapat sebuah Pod dengan <em>hostname</em> "<code>busybox-1</code>" dan
subdomain "<code>default-subdomain</code>", serta sebuah Service <em>headless</em> dengan nama "<code>default-subdomain</code>"<br>berada pada suatu <em>namespace</em> yang sama, maka Pod tersebut akan menerima FQDN dirinya sendiri
sebagai "<code>busybox-1.default-subdomain.my-namespace.svc.cluster-domain.example</code>". DNS mengembalikan
A <em>record</em> pada nama tersebut dan mengarahkannya pada IP Pod. Baik Pod "<code>busybox1</code>" dan
"<code>busybox2</code>" bisa saja memiliki A <em>record</em> yang berbeda.</p><p>Objek Endpoint dapat menspesifikasikan <code>hostname</code> untuk alamat <em>endpoint</em> manapun
beserta dengan alamat IP-nya.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Karena A <em>record</em> tidak dibuat untuk sebuah Pod, maka <code>hostname</code> diperlukan
agar sebuah Pod memiliki A <em>record</em>. Sebuah Pod yang tidak memiliki <code>hostname</code>
tetapi memiliki <code>subdomain</code> hanya akan membuat sebuah A <em>record</em> untuk Service <em>headless</em>
(<code>default-subdomain.my-namespace.svc.cluster-domain.example</code>), yang merujuk pada IP dari
Pod tersebut. Pod juga harus dalam status <em>ready</em> agar dapat memiliki A <em>record</em> kecuali
<em>field</em> <code>publishNotReadyAddresses=True</code> diaktifkan pada Service.</div><h3 id=kebijakan-dns-pod>Kebijakan DNS Pod</h3><p>Kebijakan DNS dapat diaktifkan untuk setiap Pod. Kubernetes saat ini mendukung
kebijakan DNS spesifik Pod (<em>pod-specific DNS policies</em>). Kebijakan ini
dispesifikasikan pada <em>field</em> <code>dnsPolicy</code> yang ada pada spek Pod.</p><ul><li>"<code>Default</code>": Pod akan mewarisi konfigurasi resolusi yang berasal dari Node
dimana Pod tersebut dijalankan.
Silakan baca <a href=/docs/tasks/administer-cluster/dns-custom-nameservers/#inheriting-dns-from-the-node>diskusi terkait</a>
untuk detailnya.</li><li>"<code>ClusterFirst</code>": <em>Query</em> DNS apa pun yang tidak sesuai dengan sufiks domain klaster yang sudah dikonfigurasi
misalnya "<code>www.kubernetes.io</code>", akan di-<em>forward</em> ke <em>nameserver</em> <em>upstream</em> yang diwarisi dari Node.
Administrator klaster bisa saja memiliki <em>stub-domain</em> atau DNS <em>usptream</em> lain yang sudah dikonfigurasi.
Silakan lihat <a href=/docs/tasks/administer-cluster/dns-custom-nameservers/#impacts-on-pods>diskusi terkait</a>
untuk detail lebih lanjut mengenai bagaimana <em>query</em> DNS melakukan hal tersebut.</li><li>"<code>ClusterFirstWithHostNet</code>": Untuk Pod yang dijalankan dengan menggunakan <code>hostNetwork</code>, kamu harus
secara eksplisit mengaktifkan kebijakan DNS-nya menjadi "<code>ClusterFirstWithHostNet</code>".</li><li>"<code>None</code>": Hal ini mengisikan sebuah Pod untuk mengabaikan konfigurasi DNS dari <em>environment</em> Kubernetes
Semua pengaturan DNS disediakan menngunakan <em>field</em> <code>dnsConfig</code> yang ada pada spek Pod.
Silakan lihat <a href=#konfigurasi-dns-pod>konfigurasi DNS Pod</a> di bawah.</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> "Default" bukan merupakan nilai <em>default</em> kebijakan DNS.
Jika <code>dnsPolicy</code> tidak secara eksplisit dispesifikasikan, maka “ClusterFirst” akan digunakan.</div><p>Contoh di bawah ini menunjukkan sebuah Pod dengan kebijakan
DNS yang diubah menjadi "<code>ClusterFirstWithHostNet</code>" karena <em>field</em> <code>hostNetwork</code>
diubah menjadi <code>true</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirstWithHostNet<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=konfigurasi-dns-pod>Konfigurasi DNS Pod</h3><p>Konfigurasi DNS Pod mengizinkan pengguna untuk memiliki
lebih banyak kontrol terhadap pengaturan DNS pada Pod.</p><p><em>Field</em> <code>dnsConfig</code> bersifat opsional dan dapat digunakan dengan
pengaturan <code>dnsPolicy</code> apa pun.
Meskipun begitu, ketika <em>field</em> <code>dnsPolicy</code> pada sebuah Pod diubah menjadi "<code>None</code>",
maka <em>field</em> <code>dnsConfig</code> harus dispesifikasikan.</p><p>Berikut merupakan properti yang dapat dispesifikasikan oleh pengguna
pada <em>field</em> <code>dnsConfig</code>:</p><ul><li><code>nameservers</code>: serangkaian alamat IP yang akan digunakan sebagai server DNS bagi Pod.
Jumlah maksimum dari IP yang dapat didaftarkan pada <em>field</em> ini adalah tiga buah IP.
Ketika sebuah <code>dnsPolicy</code> pada Pod diubah menjadi "<code>None</code>", maka list ini setidaknya
harus mengandung sebuah alamat IP, selain kasus tersebut properti ini bersifat opsional.
Server yang didaftarkan akan digabungkan di dalam <em>nameserver</em> dasar yang dihasilkan dari
kebijakan DNS yang dispesifikasikan, apabila terdapat duplikat terhadap alamat yang didaftarkan
maka alamat tersebut akan dihapus.</li><li><code>searches</code>: merupakan serangkaian domain pencarian DNS yang digunakan untuk proses <em>lookup</em> pada Pod.
Properti ini bersifat opsional. Ketika dispesifikasikan, list yang disediakan akan digabungkan dengan
nama domain pencarian dasar yang dihasilkan dari kebijakan DNS yang dipilih. Alamat yang duplikat akan dihapus.
Nilai maksimum domain pencarian yang dapat didaftarkan adalah 6 domain.</li><li><code>options</code>: merupakan sebuah list opsional yang berisikan objek dimana setiap objek
bisa saja memiliki properti <code>name</code> (yang bersifat wajib). Isi dari properti ini
akan digabungkan dengan opsi yang dihasilkan kebijakan DNS yang digunakan.
Alamat yang duplikat akan dihapus.</li></ul><p>Di bawah ini merupakan contoh sebuah Pod dengan pengaturan DNS kustom:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/custom-dns.yaml download=service/networking/custom-dns.yaml><code>service/networking/custom-dns.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-custom-dns-yaml")' title="Copy service/networking/custom-dns.yaml to clipboard"></img></div><div class=includecode id=service-networking-custom-dns-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dns-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;None&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nameservers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#666>1.2.3.4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>searches</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ns1.svc.cluster-domain.example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- my.dns.search.suffix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>options</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ndots<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>edns0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Ketika Pod diatas dibuat, maka Container <code>test</code>
memiliki isi berkas <code>/etc/resolv.conf</code> sebagai berikut:</p><pre tabindex=0><code>nameserver 1.2.3.4
search ns1.svc.cluster-domain.example my.dns.search.suffix
options ndots:2 edns0
</code></pre><p>Untuk pengaturan IPv6, <em>path</em> pencarian dan name server harus dispesifikasikan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it dns-example -- cat /etc/resolv.conf
</span></span></code></pre></div><p>Keluaran yang dihasilkan akan menyerupai:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>nameserver fd00:79:30::a
</span></span><span style=display:flex><span>search default.svc.cluster-domain.example svc.cluster-domain.example cluster-domain.example
</span></span><span style=display:flex><span>options ndots:5
</span></span></code></pre></div><h3 id=keberadaan-fitur>Keberadaan Fitur (<em>Feature Availability</em>)</h3><p>Keberadaan Pod DNS Config dan DNS Policy "<code>None</code>"" diilustrasikan pada tabel di bawah ini.</p><table><thead><tr><th style=text-align:center>versi k8s</th><th style=text-align:center>Dukungan Fitur</th></tr></thead><tbody><tr><td style=text-align:center>1.14</td><td style=text-align:center>Stable</td></tr><tr><td style=text-align:center>1.10</td><td style=text-align:center>Beta (aktif secara default)</td></tr><tr><td style=text-align:center>1.9</td><td style=text-align:center>Alpha</td></tr></tbody></table><h2 id=selanjutnya>Selanjutnya</h2><p>Untuk petunjuk lebih lanjut mengenai administrasi konfigurasi DNS, kamu dapat membaca
<a href=/docs/tasks/administer-cluster/dns-custom-nameservers/>Cara Melakukan Konfigurasi Service DNS</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-f804ac0532fcade3966ea2e3769ca031>5 - Menghubungkan aplikasi dengan Service</h1><h2 id=model-kubernetes-untuk-menghubungkan-kontainer>Model Kubernetes untuk menghubungkan kontainer</h2><p>Sekarang kamu memiliki aplikasi yang telah direplikasi, kamu dapat mengeksposnya di jaringan. Sebelum membahas pendekatan jaringan di Kubernetes, akan lebih baik jika kamu paham bagaimana jaringan bekerja di dalam <em>Docker</em>.</p><p>Secara <em>default</em>, <em>Docker</em> menggunakan jaringan <em>host</em>, jadi kontainer dapat berkomunikasi dengan kontainer lainnya jika mereka berada di dalam <em>node</em> yang sama. Agar kontainer <em>Docker</em> dapat berkomunikasi antar <em>node</em>, masing-masing kontainer tersebut harus diberikan <em>port</em> yang berbeda di alamat IP <em>node</em> tersebut, yang akan diteruskan (<em>proxied</em>) ke dalam kontainer. Artinya adalah para kontainer di dalam sebuah <em>node</em> harus berkoordinasi <em>port</em> mana yang akan digunakan atau dialokasikan secara otomatis.</p><p>Akan sulit untuk mengkoordinasikan <em>port</em> yang digunakan oleh banyak pengembang. Kubernetes mengasumsikan bahwa <em>Pod</em> dapat berkomunikasi dengan <em>Pod</em> lain, terlepas di <em>Node</em> mana <em>Pod</em> tersebut di <em>deploy</em>. Kubernetes memberikan setiap <em>Pod</em> alamat <em>ClusterIP</em> sehingga kamu tidak perlu secara explisit membuat jalur antara <em>Pod</em> ataupun memetakan <em>port</em> kontainer ke dalam <em>port</em> di dalam <em>Node</em> tersebut. Ini berarti kontainer di dalam sebuah <em>Pod</em> dapat berkomunikasi dengan <em>localhost</em> via <em>port</em>, dan setiap <em>Pod</em> di dalam klaster dapat berkomunikasi tanpa <em>NAT</em>. Panduan ini akan membahas bagaimana kamu dapat menjalankan sebuah layanan atau aplikasi di dalam model jaringan di atas.</p><p>Panduan ini menggunakan server <em>nginx</em> sederhana untuk mendemonstrasikan konsepnya. Konsep yang sama juga ditulis lebih lengkap di <a href=https://kubernetes.io/blog/2015/07/strong-simple-ssl-for-kubernetes>Aplikasi Jenkins CI</a>.</p><h2 id=mengekspos-pod-ke-dalam-klaster>Mengekspos Pod ke dalam klaster</h2><p>Kita melakukan ini di beberapa contoh sebelumnya, tetapi mari kita lakukan sekali lagi dan berfokus pada prespektif jaringannya. Buat sebuah <em>nginx Pod</em>, dan perhatikan bahwa templat tersebut mempunyai spesifikasi <em>port</em> kontainer:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/run-my-nginx.yaml download=service/networking/run-my-nginx.yaml><code>service/networking/run-my-nginx.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-run-my-nginx-yaml")' title="Copy service/networking/run-my-nginx.yaml to clipboard"></img></div><div class=includecode id=service-networking-run-my-nginx-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Ini membuat aplikasi tersebut dapat diakses dari <em>node</em> manapun di dalam klaster kamu. Cek lokasi <em>node</em> dimana <em>Pod</em> tersebut berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./run-my-nginx.yaml
</span></span><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</span></span></code></pre></div><pre tabindex=0><code>NAME                        READY     STATUS    RESTARTS   AGE       IP            NODE
my-nginx-3800858182-jr4a2   1/1       Running   0          13s       10.244.3.4    kubernetes-minion-905m
my-nginx-3800858182-kna2y   1/1       Running   0          13s       10.244.2.5    kubernetes-minion-ljyd
</code></pre><p>Cek IP dari <em>Pod</em> kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o yaml | grep podIP
</span></span><span style=display:flex><span>    podIP: 10.244.3.4
</span></span><span style=display:flex><span>    podIP: 10.244.2.5
</span></span></code></pre></div><p>Kamu dapat melakukan akses dengan <em>ssh</em> ke dalam <em>node</em> di dalam klaster dan mengakses IP <em>Pod</em> tersebut menggunakan <em>curl</em>. Perlu dicatat bahwa kontainer tersebut tidak menggunakan <em>port</em> 80 di dalam <em>node</em>, atau aturan <em>NAT</em> khusus untuk merutekan trafik ke dalam <em>Pod</em>. Ini berarti kamu dapat menjalankan banyak <em>nginx Pod</em> di <em>node</em> yang sama dimana setiap <em>Pod</em> dapat menggunakan <em>containerPort</em> yang sama, kamu dapat mengakses semua itu dari <em>Pod</em> lain ataupun dari <em>node</em> di dalam klaster menggunakan IP. Seperti <em>Docker</em>, <em>port</em> masih dapat di publikasi ke dalam * interface node*, tetapi kebutuhan seperti ini sudah berkurang karena model jaringannya.</p><p>Kamu dapat membaca lebih detail <a href=/id/docs/concepts/cluster-administration/networking/#how-to-achieve-this>bagaimana kita melakukan ini</a> jika kamu penasaran.</p><h2 id=membuat-service>Membuat Service</h2><p>Kita mempunyai <em>Pod</em> yang menjalankan <em>nginx</em> di dalam klaster. Teorinya, kamu dapat berkomunikasi ke <em>Pod</em> tersebut secara langsung, tapi apa yang terjadi jika sebuah <em>node</em> mati? <em>Pod</em> di dalam <em>node</em> tersebut ikut mati, dan <em>Deployment</em> akan membuat <em>Pod</em> baru, dengan IP yang berbeda. Ini adalah masalah yang <em>Service</em> selesaikan.</p><p><em>Service</em> Kubernetes adalah sebuah abstraksi yang mendefinisikan sekumpulan <em>Pod</em> yang menyediakan fungsi yang sama dan berjalan di dalam klaster. Saat dibuat, setiap <em>Service</em> diberikan sebuah alamat IP (disebut juga <em>ClusterIP</em>). Alamat ini akan terus ada, dan tidak akan pernah berubah selama <em>Service</em> hidup. <em>Pod</em> dapat berkomunikasi dengan <em>Service</em> dan trafik yang menuju <em>Service</em> tersebut akan otomatis dilakukan mekanisme <em>load balancing</em> ke <em>Pod</em> yang merupakan anggota dari <em>Service</em> tersebut.</p><p>Kamu dapat membuat <em>Service</em> untuk replika 2 <em>nginx</em> dengan <code>kubectl explose</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment/my-nginx
</span></span></code></pre></div><pre tabindex=0><code>service/my-nginx exposed
</code></pre><p>Perintah di atas sama dengan <code>kubectl apply -f</code> dengan <em>yaml</em> sebagai berikut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/nginx-svc.yaml download=service/networking/nginx-svc.yaml><code>service/networking/nginx-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-nginx-svc-yaml")' title="Copy service/networking/nginx-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-nginx-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Spesifikasi ini akan membuat <em>Service</em> yang membuka <em>TCP port 80</em> di setiap <em>Pod</em> dengan label <code>run: my-nginx</code> dan mengeksposnya ke dalam <em>port Service</em> (<code>targetPort</code>: adalah port kontainer yang menerima trafik, <code>port</code> adalah <em>service port</em> yang dapat berupa <em>port</em> apapun yang digunakan <em>Pod</em> lain untuk mengakses <em>Service</em>).</p><p>Lihat <a href=/docs/reference/generated/kubernetes-api/v1.25/#service-v1-core>Service</a>
objek <em>API</em> untuk melihat daftar <em>field</em> apa saja yang didukung di definisi <em>Service</em>. Cek <em>Service</em> kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc my-nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
my-nginx   ClusterIP   10.0.162.149   &lt;none&gt;        80/TCP    21s
</code></pre><p>Seperti yang disebutkan sebelumnya, sebuah <em>Service</em> berisi sekumpulan <em>Pod</em>. <em>Pod</em> diekspos melalui <code>endpoints</code>. <em>Service selector</em> akan mengecek <em>Pod</em> secara terus-menerus dan hasilnya akan dikirim (<em>POSTed</em>) ke objek <em>endpoint</em> yang bernama <code>my-nginx</code>. Saat sebuah <em>Pod</em> mati, <em>IP Pod</em> di dalam <em>endpoint</em> tersebut akan otomatis dihapus, dan <em>Pod</em> baru yang sesuai dengan <em>Service selector</em> akan otomatis ditambahkan ke dalam <em>endpoint</em>. Cek <em>endpoint</em> dan perhatikan bahwa IP sama dengan <em>Pod</em> yang dibuat di langkah pertama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe svc my-nginx
</span></span></code></pre></div><pre tabindex=0><code>Name:                my-nginx
Namespace:           default
Labels:              run=my-nginx
Annotations:         &lt;none&gt;
Selector:            run=my-nginx
Type:                ClusterIP
IP:                  10.0.162.149
Port:                &lt;unset&gt; 80/TCP
Endpoints:           10.244.2.5:80,10.244.3.4:80
Session Affinity:    None
Events:              &lt;none&gt;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ep my-nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME       ENDPOINTS                     AGE
my-nginx   10.244.2.5:80,10.244.3.4:80   1m
</code></pre><p>Kamu sekarang dapat melakukan <em>curl</em> ke dalam <em>nginx Service</em> di <code>&lt;CLUSTER-IP>:&lt;PORT></code> dari <em>node</em> manapun di klaster. Perlu dicatat bahwa <em>Service IP</em> adalah IP virtual, IP tersebut tidak pernah ada di <em>interface node</em> manapun. Jika kamu penasaran bagaimana konsep ini bekerja, kamu dapat membaca lebih lanjut tentang <a href=/id/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>service proxy</a>.</p><h2 id=mengakses-service>Mengakses Service</h2><p>Kubernetes mendukung 2 mode utama untuk menemukan sebuah <em>Service</em> - variabel <em>environment</em> dan <em>DNS</em>.
<em>DNS</em> membutuhkan <a href=http://releases.k8s.io/main/cluster/addons/dns/coredns>tambahan CoreDNS di dalam klaster</a>.</p><h3 id=variabel-environment>Variabel Environment</h3><p>Saat sebuah <em>Pod</em> berjalan di <em>Node</em>, <em>kubelet</em> akan menambahkan variabel <em>environment</em> untuk setiap <em>Service</em> yang aktif ke dalam <em>Pod</em>. Ini menimbulkan beberapa masalah. Untuk melihatnya, periksa <em>environment</em> dari <em>Pod nginx</em> yang telah kamu buat (nama <em>Pod</em>-mu akan berbeda-beda):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-jr4a2 -- printenv | grep SERVICE
</span></span></code></pre></div><pre tabindex=0><code>KUBERNETES_SERVICE_HOST=10.0.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><p>Perlu dicatat tidak ada variabel <em>environment</em> yang menunjukan <em>Service</em> yang kamu buat. Ini terjadi karena kamu membuat replika terlebih dahulu sebelum membuat <em>Service</em>. Kerugian lain ditimbulkan adalah bahwa komponen <em>scheduler</em> mungkin saja bisa menempatkan semua <em>Pod</em> di dalam satu <em>Node</em>, yang akan membuat keseluruhan <em>Service</em> mati jika <em>Node</em> tersebut mati. Kita dapat menyelesaikan masalah ini dengan menghapus 2 <em>Pod</em> tersebut dan menunggu <em>Deployment</em> untuk membuat <em>Pod</em> kembali. Kali ini <em>Service</em> ada sebelum replika <em>Pod</em> tersebut ada. Ini akan memberikan kamu <em>scheduler-level Service</em> (jika semua <em>Node</em> kamu mempunyai kapasitas yang sama), serta variabel <em>environment</em> yang benar:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>0; kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</span></span></code></pre></div><pre tabindex=0><code>NAME                        READY     STATUS    RESTARTS   AGE     IP            NODE
my-nginx-3800858182-e9ihh   1/1       Running   0          5s      10.244.2.7    kubernetes-minion-ljyd
my-nginx-3800858182-j4rm4   1/1       Running   0          5s      10.244.3.8    kubernetes-minion-905m
</code></pre><p>Kamu mungkin saja melihat <em>Pod</em> dengan nama yang berbeda, hal ini terjadi karena <em>Pod-Pod</em> itu dihapus dan dibuat ulang.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-e9ihh -- printenv | grep SERVICE
</span></span></code></pre></div><pre tabindex=0><code>KUBERNETES_SERVICE_PORT=443
MY_NGINX_SERVICE_HOST=10.0.162.149
KUBERNETES_SERVICE_HOST=10.0.0.1
MY_NGINX_SERVICE_PORT=80
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><h3 id=dns>DNS</h3><p>Kubernetes menawarkan sebuah layanan <em>DNS</em> klaster tambahan yang secara otomatis memberikan sebuah nama <em>dns</em> pada <em>Service</em>. Kamu dapat mengecek jika <em>DNS</em> berjalan di dalam klaster Kubernetes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services kube-dns --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div><pre tabindex=0><code>NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
kube-dns   ClusterIP   10.0.0.10    &lt;none&gt;        53/UDP,53/TCP   8m
</code></pre><p>Jika <em>DNS</em> belum berjalan, kamu dapat <a href=http://releases.k8s.io/main/cluster/addons/dns/kube-dns/README.md#how-do-i-configure-it>mengaktifkannya</a>.</p><p>Sisa panduan ini mengasumsikan kamu mempunyai <em>Service</em> dengan IP (my-nginx), dan sebuah server <em>DNS</em> yang memberikan nama ke dalam IP tersebut (CoreDNS klaster), jadi kamu dapat berkomunikasi dengan <em>Service</em> dari <em>Pod</em> lain di dalam klaster menggunakan metode standar (contohnya <em>gethostbyname</em>). Jalankan aplikasi <em>curl</em> lain untuk melakukan pengujian ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run curl --image<span style=color:#666>=</span>radial/busyboxplus:curl -i --tty
</span></span></code></pre></div><pre tabindex=0><code>Waiting for pod default/curl-131556218-9fnch to be running, status is Pending, pod ready: false
Hit enter for command prompt
</code></pre><p>Lalu tekan <em>enter</em> dan jalankan <code>nslookup my-nginx</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#666>[</span> root@curl-131556218-9fnch:/ <span style=color:#666>]</span>$ nslookup my-nginx
</span></span><span style=display:flex><span>Server:    10.0.0.10
</span></span><span style=display:flex><span>Address 1: 10.0.0.10
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Name:      my-nginx
</span></span><span style=display:flex><span>Address 1: 10.0.162.149
</span></span></code></pre></div><h2 id=mengamankan-service>Mengamankan Service</h2><p>Hingga sekarang kita hanya mengakses <em>nginx</em> server dari dalam klaster. Sebelum mengekspos <em>Service</em> ke internet, kamu harus memastikan bahwa kanal komunikasi aman. Untuk melakukan hal tersebut, kamu membutuhkan:</p><ul><li><em>Self signed certificates</em> untuk <em>https</em> (kecuali jika kamu sudah mempunyai <em>identity certificate</em>)</li><li>Sebuah server <em>nginx</em> yang terkonfigurasi untuk menggunakan <em>certificate</em> tersebut</li><li>Sebuah <a href=/id/docs/concepts/configuration/secret/>secret</a> yang membuat setifikat tersebut dapat diakses oleh <em>pod</em></li></ul><p>Kamu dapat melihat semua itu di <a href=https://github.com/kubernetes/examples/tree/main/staging/https-nginx/>contoh nginx https</a>. Contoh ini mengaharuskan kamu melakukan instalasi <em>go</em> dan <em>make</em>. Jika kamu tidak ingin melakukan instalasi tersebut, ikuti langkah-langkah manualnya nanti, singkatnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make keys <span style=color:#b8860b>KEY</span><span style=color:#666>=</span>/tmp/nginx.key <span style=color:#b8860b>CERT</span><span style=color:#666>=</span>/tmp/nginx.crt
</span></span><span style=display:flex><span>kubectl create secret tls nginxsecret --key /tmp/nginx.key --cert /tmp/nginx.crt
</span></span></code></pre></div><pre tabindex=0><code>secret/nginxsecret created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><pre tabindex=0><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           Opaque                                2         1m
</code></pre><p>Berikut ini adalah langkah-langkah manual yang harus diikuti jika kamu mengalami masalah menjalankan <em>make</em> (pada windows contohnya):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic>#membuat sebuah key-pair public private</span>
</span></span><span style=display:flex><span>openssl req -x509 -nodes -days <span style=color:#666>365</span> -newkey rsa:2048 -keyout /d/tmp/nginx.key -out /d/tmp/nginx.crt -subj <span style=color:#b44>&#34;/CN=my-nginx/O=my-nginx&#34;</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#rubah key tersebut ke dalam pengkodean base64</span>
</span></span><span style=display:flex><span>cat /d/tmp/nginx.crt | base64
</span></span><span style=display:flex><span>cat /d/tmp/nginx.key | base64
</span></span></code></pre></div><p>Gunakan hasil keluaran dari perintah sebelumnya untuk membuat sebuah file <em>yaml</em> seperti berikut. Nilai yang dikodekan <em>base64</em> harus berada di dalam satu baris.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Secret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginxsecret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx.crt</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURIekNDQWdlZ0F3SUJBZ0lKQUp5M3lQK0pzMlpJTUEwR0NTcUdTSWIzRFFFQkJRVUFNQ1l4RVRBUEJnTlYKQkFNVENHNW5hVzU0YzNaak1SRXdEd1lEVlFRS0V3aHVaMmx1ZUhOMll6QWVGdzB4TnpFd01qWXdOekEzTVRKYQpGdzB4T0RFd01qWXdOekEzTVRKYU1DWXhFVEFQQmdOVkJBTVRDRzVuYVc1NGMzWmpNUkV3RHdZRFZRUUtFd2h1CloybHVlSE4yWXpDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSjFxSU1SOVdWM0IKMlZIQlRMRmtobDRONXljMEJxYUhIQktMSnJMcy8vdzZhU3hRS29GbHlJSU94NGUrMlN5ajBFcndCLzlYTnBwbQppeW1CL3JkRldkOXg5UWhBQUxCZkVaTmNiV3NsTVFVcnhBZW50VWt1dk1vLzgvMHRpbGhjc3paenJEYVJ4NEo5Ci82UVRtVVI3a0ZTWUpOWTVQZkR3cGc3dlVvaDZmZ1Voam92VG42eHNVR0M2QURVODBpNXFlZWhNeVI1N2lmU2YKNHZpaXdIY3hnL3lZR1JBRS9mRTRqakxCdmdONjc2SU90S01rZXV3R0ljNDFhd05tNnNTSzRqYUNGeGpYSnZaZQp2by9kTlEybHhHWCtKT2l3SEhXbXNhdGp4WTRaNVk3R1ZoK0QrWnYvcW1mMFgvbVY0Rmo1NzV3ajFMWVBocWtsCmdhSXZYRyt4U1FVQ0F3RUFBYU5RTUU0d0hRWURWUjBPQkJZRUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjcKTUI4R0ExVWRJd1FZTUJhQUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjdNQXdHQTFVZEV3UUZNQU1CQWY4dwpEUVlKS29aSWh2Y05BUUVGQlFBRGdnRUJBRVhTMW9FU0lFaXdyMDhWcVA0K2NwTHI3TW5FMTducDBvMm14alFvCjRGb0RvRjdRZnZqeE04Tzd2TjB0clcxb2pGSW0vWDE4ZnZaL3k4ZzVaWG40Vm8zc3hKVmRBcStNZC9jTStzUGEKNmJjTkNUekZqeFpUV0UrKzE5NS9zb2dmOUZ3VDVDK3U2Q3B5N0M3MTZvUXRUakViV05VdEt4cXI0Nk1OZWNCMApwRFhWZmdWQTRadkR4NFo3S2RiZDY5eXM3OVFHYmg5ZW1PZ05NZFlsSUswSGt0ejF5WU4vbVpmK3FqTkJqbWZjCkNnMnlwbGQ0Wi8rUUNQZjl3SkoybFIrY2FnT0R4elBWcGxNSEcybzgvTHFDdnh6elZPUDUxeXdLZEtxaUMwSVEKQ0I5T2wwWW5scE9UNEh1b2hSUzBPOStlMm9KdFZsNUIyczRpbDlhZ3RTVXFxUlU9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx.key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQ2RhaURFZlZsZHdkbFIKd1V5eFpJWmVEZWNuTkFhbWh4d1NpeWF5N1AvOE9ta3NVQ3FCWmNpQ0RzZUh2dGtzbzlCSzhBZi9WemFhWm9zcApnZjYzUlZuZmNmVUlRQUN3WHhHVFhHMXJKVEVGSzhRSHA3VkpMcnpLUC9QOUxZcFlYTE0yYzZ3MmtjZUNmZitrCkU1bEVlNUJVbUNUV09UM3c4S1lPNzFLSWVuNEZJWTZMMDUrc2JGQmd1Z0ExUE5JdWFubm9UTWtlZTRuMG4rTDQKb3NCM01ZUDhtQmtRQlAzeE9JNHl3YjREZXUraURyU2pKSHJzQmlIT05Xc0RadXJFaXVJMmdoY1kxeWIyWHI2UAozVFVOcGNSbC9pVG9zQngxcHJHclk4V09HZVdPeGxZZmcvbWIvNnBuOUYvNWxlQlkrZStjSTlTMkQ0YXBKWUdpCkwxeHZzVWtGQWdNQkFBRUNnZ0VBZFhCK0xkbk8ySElOTGo5bWRsb25IUGlHWWVzZ294RGQwci9hQ1Zkank4dlEKTjIwL3FQWkUxek1yall6Ry9kVGhTMmMwc0QxaTBXSjdwR1lGb0xtdXlWTjltY0FXUTM5SjM0VHZaU2FFSWZWNgo5TE1jUHhNTmFsNjRLMFRVbUFQZytGam9QSFlhUUxLOERLOUtnNXNrSE5pOWNzMlY5ckd6VWlVZWtBL0RBUlBTClI3L2ZjUFBacDRuRWVBZmI3WTk1R1llb1p5V21SU3VKdlNyblBESGtUdW1vVlVWdkxMRHRzaG9reUxiTWVtN3oKMmJzVmpwSW1GTHJqbGtmQXlpNHg0WjJrV3YyMFRrdWtsZU1jaVlMbjk4QWxiRi9DSmRLM3QraTRoMTVlR2ZQegpoTnh3bk9QdlVTaDR2Q0o3c2Q5TmtEUGJvS2JneVVHOXBYamZhRGR2UVFLQmdRRFFLM01nUkhkQ1pKNVFqZWFKClFGdXF4cHdnNzhZTjQyL1NwenlUYmtGcVFoQWtyczJxWGx1MDZBRzhrZzIzQkswaHkzaE9zSGgxcXRVK3NHZVAKOWRERHBsUWV0ODZsY2FlR3hoc0V0L1R6cEdtNGFKSm5oNzVVaTVGZk9QTDhPTm1FZ3MxMVRhUldhNzZxelRyMgphRlpjQ2pWV1g0YnRSTHVwSkgrMjZnY0FhUUtCZ1FEQmxVSUUzTnNVOFBBZEYvL25sQVB5VWs1T3lDdWc3dmVyClUycXlrdXFzYnBkSi9hODViT1JhM05IVmpVM25uRGpHVHBWaE9JeXg5TEFrc2RwZEFjVmxvcG9HODhXYk9lMTAKMUdqbnkySmdDK3JVWUZiRGtpUGx1K09IYnRnOXFYcGJMSHBzUVpsMGhucDBYSFNYVm9CMUliQndnMGEyOFVadApCbFBtWmc2d1BRS0JnRHVIUVV2SDZHYTNDVUsxNFdmOFhIcFFnMU16M2VvWTBPQm5iSDRvZUZKZmcraEppSXlnCm9RN3hqWldVR3BIc3AyblRtcHErQWlSNzdyRVhsdlhtOElVU2FsbkNiRGlKY01Pc29RdFBZNS9NczJMRm5LQTQKaENmL0pWb2FtZm1nZEN0ZGtFMXNINE9MR2lJVHdEbTRpb0dWZGIwMllnbzFyb2htNUpLMUI3MkpBb0dBUW01UQpHNDhXOTVhL0w1eSt5dCsyZ3YvUHM2VnBvMjZlTzRNQ3lJazJVem9ZWE9IYnNkODJkaC8xT2sybGdHZlI2K3VuCnc1YytZUXRSTHlhQmd3MUtpbGhFZDBKTWU3cGpUSVpnQWJ0LzVPbnlDak9OVXN2aDJjS2lrQ1Z2dTZsZlBjNkQKckliT2ZIaHhxV0RZK2Q1TGN1YSt2NzJ0RkxhenJsSlBsRzlOZHhrQ2dZRUF5elIzT3UyMDNRVVV6bUlCRkwzZAp4Wm5XZ0JLSEo3TnNxcGFWb2RjL0d5aGVycjFDZzE2MmJaSjJDV2RsZkI0VEdtUjZZdmxTZEFOOFRwUWhFbUtKCnFBLzVzdHdxNWd0WGVLOVJmMWxXK29xNThRNTBxMmk1NVdUTThoSDZhTjlaMTltZ0FGdE5VdGNqQUx2dFYxdEYKWSs4WFJkSHJaRnBIWll2NWkwVW1VbGc9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Sekarang buat <em>secrets</em> menggunakan file tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f nginxsecrets.yaml
</span></span><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><pre tabindex=0><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           Opaque                                2         1m
</code></pre><p>Sekarang modifikasi replika <em>nginx</em> untuk menjalankan server <em>https</em> menggunakan <em>certificate</em> di dalam <em>secret</em> dan <em>Service</em> untuk mengekspos semua <em>port</em> (80 dan 443):</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/nginx-secure-app.yaml download=service/networking/nginx-secure-app.yaml><code>service/networking/nginx-secure-app.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-nginx-secure-app-yaml")' title="Copy service/networking/nginx-secure-app.yaml to clipboard"></img></div><div class=includecode id=service-networking-nginx-secure-app-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginxhttps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>bprashanth/nginxhttps:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Berikut catatan penting tentang manifes <em>nginx-secure-app</em>:</p><ul><li>di dalam file tersebut, ada spesifikasi <em>Deployment</em> dan <em>Service</em></li><li>ada <a href=https://github.com/kubernetes/examples/tree/main/staging/https-nginx/default.conf>server nginx</a> yang melayani trafik <em>HTTP</em> di <em>port</em> 80 dan trafik <em>HTTPS</em> di <em>port</em> 443, dan <em>Service nginx</em> yang mengekspos kedua <em>port</em> tersebut.</li><li>Setiap kontainer mempunyai akses ke <em>key</em> melalui <em>volume</em> yang di <em>mount</em> pada <code>/etc/nginx/ssl</code>. Ini adalah konfigurasi sebelum server <em>nginx</em> dijalankan.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployments,svc my-nginx; kubectl create -f ./nginx-secure-app.yaml
</span></span></code></pre></div><p>Pada tahapan ini, kamu dapat berkomunikasi dengan server <em>nginx</em> dari <em>node</em> manapun.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o custom-columns<span style=color:#666>=</span>POD_IP:.status.podIPs
</span></span><span style=display:flex><span>    POD_IP
</span></span><span style=display:flex><span>    <span style=color:#666>[</span>map<span style=color:#666>[</span>ip:10.244.3.5<span style=color:#666>]]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>node $ curl -k https://10.244.3.5
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</span></span></code></pre></div><p>Perlu dicatat bahwa kita menggunakan parameter <code>-k</code> saat menggunakan <em>curl</em>, ini karena kita tidak tau apapun tentang <em>Pod</em> yang menjalankan <em>nginx</em> saat pembuatan seritifikat, jadi kita harus memberitahu <em>curl</em> untuk mengabaikan ketidakcocokan <em>CName</em>. Dengan membuat <em>Service</em>, kita menghubungkan <em>CName</em> yang digunakan pada <em>certificate</em> dengan nama pada <em>DNS</em> yang digunakan <em>Pod</em>. Lakukan pengujian dari sebuah <em>Pod</em> (<em>secret</em> yang sama digunakan untuk agar mudah, <em>Pod</em> tersebut hanya membutuhkan <em>nginx.crt</em> untuk mengakses <em>Service</em>)</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/curlpod.yaml download=service/networking/curlpod.yaml><code>service/networking/curlpod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-curlpod-yaml")' title="Copy service/networking/curlpod.yaml to clipboard"></img></div><div class=includecode id=service-networking-curlpod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curl-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- while true; do sleep 1; done<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>radial/busyboxplus:curl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./curlpod.yaml
</span></span><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>curlpod
</span></span></code></pre></div><pre tabindex=0><code>NAME                               READY     STATUS    RESTARTS   AGE
curl-deployment-1515033274-1410r   1/1       Running   0          1m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> curl-deployment-1515033274-1410r -- curl https://my-nginx --cacert /etc/nginx/ssl/nginx.crt
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=mengekspos-service>Mengekspos Service</h2><p>Kamu mungkin ingin mengekspos <em>Service</em> ke alamat IP eksternal. Kubernetes mendukung dua cara untuk melakukan ini: <em>NodePort</em> dan <em>LoadBalancer</em>. <em>Service</em> yang dibuat tadi sudah menggunakan <code>NodePort</code>, jadi replika <em>nginx</em> sudah siap untuk menerima trafik dari internet jika <em>Node</em> kamu mempunyai IP publik.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc my-nginx -o yaml | grep nodePort -C <span style=color:#666>5</span>
</span></span><span style=display:flex><span>  uid: 07191fb3-f61a-11e5-8ae5-42010af00002
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  clusterIP: 10.0.162.149
</span></span><span style=display:flex><span>  ports:
</span></span><span style=display:flex><span>  - name: http
</span></span><span style=display:flex><span>    nodePort: <span style=color:#666>31704</span>
</span></span><span style=display:flex><span>    port: <span style=color:#666>8080</span>
</span></span><span style=display:flex><span>    protocol: TCP
</span></span><span style=display:flex><span>    targetPort: <span style=color:#666>80</span>
</span></span><span style=display:flex><span>  - name: https
</span></span><span style=display:flex><span>    nodePort: <span style=color:#666>32453</span>
</span></span><span style=display:flex><span>    port: <span style=color:#666>443</span>
</span></span><span style=display:flex><span>    protocol: TCP
</span></span><span style=display:flex><span>    targetPort: <span style=color:#666>443</span>
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    run: my-nginx
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes -o yaml | grep ExternalIP -C <span style=color:#666>1</span>
</span></span><span style=display:flex><span>    - address: 104.197.41.11
</span></span><span style=display:flex><span>      type: ExternalIP
</span></span><span style=display:flex><span>    allocatable:
</span></span><span style=display:flex><span>--
</span></span><span style=display:flex><span>    - address: 23.251.152.56
</span></span><span style=display:flex><span>      type: ExternalIP
</span></span><span style=display:flex><span>    allocatable:
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ curl https://&lt;EXTERNAL-IP&gt;:&lt;NODE-PORT&gt; -k
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</span></span></code></pre></div><p>Mari coba membuat ulang <em>Service</em> menggunakan <em>cloud load balancer</em>, ubah saja <code>type</code> <em>Service</em> <code>my-nginx</code> dari <code>NodePort</code> ke <code>LoadBalancer</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit svc my-nginx
</span></span><span style=display:flex><span>kubectl get svc my-nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME       TYPE        CLUSTER-IP     EXTERNAL-IP        PORT(S)               AGE
my-nginx   ClusterIP   10.0.162.149   162.222.184.144    80/TCP,81/TCP,82/TCP  21s
</code></pre><pre tabindex=0><code>curl https://&lt;EXTERNAL-IP&gt; -k
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</code></pre><p>IP address pada kolom <code>EXTERNAL-IP</code> menunjukan IP yang tersedia di internet. Sedangkan kolom <code>CLUSTER-IP</code> merupakan IP yang hanya tersedia di dalam klaster kamu (<em>IP private</em>).</p><p>Perhatikan pada <em>AWS</em>, tipe <code>LoadBalancer</code> membuat sebuah <em>ELB</em>, yang menggunakan <em>hostname</em> yang panjang, bukan IP. Karena tidak semua keluar pada standar keluaran <code>kubectl get svc</code>. Jadi kamu harus menggunakan <code>kubectl describe service my-nginx</code> untuk melihatnya. Kamu akan melihat seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe service my-nginx
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>LoadBalancer Ingress:   a320587ffd19711e5a37606cf4a74574-1142138393.us-east-1.elb.amazonaws.com
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><p>Kubernetes juga mendukung <em>Federated Service</em>, yang bisa mempengaruhi banyak klaster dan penyedia layanan <em>cloud</em>, untuk meningkatkan ketersediaan, peningkatan toleransi kesalahan, dan pengembangan dari <em>Service</em> kamu. Lihat <a href=/id/docs/concepts/cluster-administration/federation-service-discovery/>Panduan Federated Service</a> untuk informasi lebih lanjut.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-199bcc92443dbc9bed44819467d7eb75>6 - Ingress</h1><p>Sebuah obyek API yang mengatur akses eksternal terhadap <em>Service</em> yang ada di dalam klaster, biasanya dalam bentuk <em>request</em> HTTP.</p><p>Ingress juga menyediakan <em>load balancing</em>, terminasi SSL, serta <em>name-based virtual hosting</em>.</p><h2 id=terminologi>Terminologi</h2><p>Untuk memudahkan, di awal akan dijelaskan beberapa terminologi yang sering dipakai:</p><ul><li>Node: Sebuah mesin fisik atau virtual yang berada di dalam klaster Kubernetes.</li><li>Klaster: Sekelompok node yang merupakan <em>resource</em> komputasi primer yang diatur oleh Kubernetes, biasanya diproteksi dari internet dengan menggunakan <em>firewall</em>.</li><li><em>Edge router</em>: Sebuah <em>router</em> mengatur <em>policy firewall</em> pada klaster kamu. <em>Router</em> ini bisa saja berupa <em>gateway</em> yang diatur oleh penyedia layanan <em>cloud</em> maupun perangkat keras.</li><li>Jaringan klaster: Seperangkat <em>links</em> baik logis maupus fisik, yang memfasilitasi komunikasi di dalam klaster berdasarkan <a href=/id/docs/concepts/cluster-administration/networking/>model jaringan Kubernetes</a>.</li><li><em>Service</em>: Sebuah <a href=/id/docs/concepts/services-networking/service/><em>Service</em></a> yang mengidentifikasi beberapa <em>Pod</em> dengan menggunakan <em>selector label</em>. Secara umum, semua <em>Service</em> diasumsikan hanya memiliki IP virtual yang hanya dapat diakses dari dalam jaringan klaster.</li></ul><h2 id=apakah-ingress-itu>Apakah <em>Ingress</em> itu?</h2><p>Ingress ditambahkan sejak Kubernetes v1.1, mengekspos rute HTTP dan HTTPS ke berbagai
<a href=/docs/concepts/services-networking/service/ target=_blank>services</a> di dalam klaster.
Mekanisme <em>routing</em> trafik dikendalikan oleh aturan-aturan yang didefinisikan pada <em>Ingress</em>.</p><pre tabindex=0><code class=language-none data-lang=none>    internet
        |
   [ Ingress ]
   --|-----|--
   [ Services ]
</code></pre><p>Sebuah <em>Ingress</em> dapat dikonfigurasi agar berbagai <em>Service</em> memiliki URL yang dapat diakses dari eksternal (luar klaster), melakukan <em>load balance</em> pada trafik, terminasi SSL, serta Virtual Host berbasis Nama.
Sebuah <a href=/id/docs/concepts/services-networking/ingress-controllers>kontroler Ingress</a> bertanggung jawab untuk menjalankan fungsi Ingress yaitu sebagai <em>loadbalancer</em>, meskipun dapat juga digunakan untuk mengatur <em>edge router</em> atau <em>frontend</em> tambahan untuk menerima trafik.</p><p>Sebuah <em>Ingress</em> tidak mengekspos sembarang <em>port</em> atau protokol. Mengekspos <em>Service</em> untuk protokol selain HTTP ke HTTPS internet biasanya dilakukan dengan menggunakan
<em>service</em> dengan tipe <a href=/id/docs/concepts/services-networking/service/#nodeport>Service.Type=NodePort</a> atau
<a href=/id/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a>.</p><h2 id=prasyarat>Prasyarat</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.1 [beta]</code></div><p>Sebelum kamu mulai menggunakan <em>Ingress</em>, ada beberapa hal yang perlu kamu ketahui sebelumnya. <em>Ingress</em> merupakan <em>resource</em> dengan tipe beta.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu harus terlebih dahulu memiliki <a href=/id/docs/concepts/services-networking/ingress-controllers>kontroler Ingress</a> untuk dapat memenuhi <em>Ingress</em>. Membuat sebuah <em>Ingress</em> tanpa adanya kontroler <em>Ingres</em> tidak akan berdampak apa pun.</div><p>GCE/Google Kubernetes Engine melakukan deploy kontroler <em>Ingress</em> pada <em>master</em>. Perhatikan laman berikut
<a href=https://github.com/kubernetes/ingress-gce/blob/master/BETA_LIMITATIONS.md#glbc-beta-limitations>keterbatasan versi beta</a>
kontroler ini jika kamu menggunakan GCE/GKE.</p><p>Jika kamu menggunakan <em>environment</em> selain GCE/Google Kubernetes Engine, kemungkinan besar kamu harus
<a href=https://kubernetes.github.io/ingress-nginx/deploy/>melakukan proses deploy kontroler ingress kamu sendiri</a>. Terdapat beberapa jenis
<a href=/id/docs/concepts/services-networking/ingress-controllers>kontroler Ingress</a> yang bisa kamu pilih.</p><h3 id=sebelum-kamu-memulai>Sebelum kamu memulai</h3><p>Secara ideal, semua kontroler Ingress harus memenuhi spesifikasi ini, tetapi beberapa
kontroler beroperasi sedikit berbeda satu sama lain.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pastikan kamu sudah terlebih dahulu memahami dokumentasi kontroler Ingress yang akan kamu pakai sebelum memutuskan untuk memakai kontroler tersebut.</div><h2 id=resource-ingress><em>Resource</em> Ingress</h2><p>Berikut ini merupakan salah satu contoh konfigurasi Ingress yang minimum:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/testpath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Seperti layaknya <em>resource</em> Kubernetes yang lain, sebuah Ingress membutuhkan <em>field</em> <code>apiVersion</code>, <code>kind</code>, dan <code>metadata</code>.
Untuk informasi umum soal bagaimana cara bekerja dengan menggunakan berkas konfigurasi, silahkan merujuk pada <a href=/docs/tasks/run-application/run-stateless-application-deployment/>melakukan deploy aplikasi</a>, <a href=/id/docs/tasks/configure-pod-container/configure-pod-configmap/>konfigurasi kontainer</a>, <a href=/id/docs/concepts/cluster-administration/manage-deployment/>mengatur <em>resource</em></a>.
Ingress seringkali menggunakan anotasi untuk melakukan konfigurasi beberapa opsi yang ada bergantung pada kontroler Ingress yang digunakan, sebagai contohnya
adalah <a href=https://github.com/kubernetes/ingress-nginx/blob/master/docs/examples/rewrite/README.md>anotasi rewrite-target</a>.
<a href=/id/docs/concepts/services-networking/ingress-controllers>Kontroler Ingress</a> yang berbeda memiliki jenis anotasi yang berbeda. Pastikan kamu sudah terlebih dahulu memahami dokumentasi
kontroler Ingress yang akan kamu pakai untuk mengetahui jenis anotasi apa sajakah yang disediakan.</p><p><a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>Spesifikasi</a> Ingress
memiliki segala informasi yang dibutuhkan untuk melakukan proses konfigurasi <em>loadbalancer</em> atau server proxy. Hal yang terpenting adalah
bagian inilah yang mengandung semua <em>rules</em> yang nantinya akan digunakan untuk menyesuaikan trafik yang masuk. <em>Resource</em> Ingress hanya menyediakan
fitur <em>rules</em> untuk mengarahkan trafik dengan protokol HTTP.</p><h3 id=rule-ingress><em>Rule</em> Ingress</h3><p>Setiap <em>rule</em> HTTP mengandung informasi berikut:</p><ul><li><em>Host</em> opsional. Di dalam contoh ini, tidak ada <em>host</em> yang diberikan, dengan kata lain, semua <em>rules</em> berlaku untuk <em>inbound</em>
trafik HTTP bagi alamat IP yang dispesifikasikan. JIka sebuah <em>host</em> dispesifikasikan (misalnya saja,
foo.bar.com), maka <em>rules</em> yang ada akan berlaku bagi <em>host</em> tersebut.</li><li>Sederetan <em>path</em> (misalnya, /testpath), setiap <em>path</em> ini akan memiliki pasangan berupa sebuah <em>backend</em> yang didefinisikan dengan <code>serviceName</code>
dan <code>servicePort</code>. Baik <em>host</em> dan <em>path</em> harus sesuai dengan konten dari <em>request</em> yang masuk sebelum
<em>loadbalancer</em> akan mengarahkan trafik pada <em>service</em> yang sesuai.</li><li>Suatu <em>backend</em> adalah kombinasi <em>service</em> dan <em>port</em> seperti yang dideskripsikan di
<a href=/id/docs/concepts/services-networking/service/>dokumentasi <em>Service</em></a>. <em>Request</em> HTTP (dan HTTPS) yang sesuai dengan
<em>host</em> dan <em>path</em> yang ada pada <em>rule</em> akan diteruskan pada <em>backend</em> terkait.</li></ul><p><em>Backend default</em> seringkali dikonfigurasi pada kontroler kontroler Ingress, tugas <em>backend default</em> ini adalah
mengarahkan <em>request</em> yang tidak sesuai dengan <em>path</em> yang tersedia pada spesifikasi.</p><h3 id=backend-default><em>Backend Default</em></h3><p>Sebuah Ingress yang tidak memiliki <em>rules</em> akan mengarahkan semua trafik pada sebuah <em>backend default</em>. <em>Backend default</em> inilah yang
biasanya bisa dimasukkan sebagai salah satu opsi konfigurasi dari <a href=/id/docs/concepts/services-networking/ingress-controllers>kontroler Ingress</a> dan tidak dimasukkan dalam spesifikasi <em>resource</em> Ingress.</p><p>Jika tidak ada <em>host</em> atau <em>path</em> yang sesuai dengan <em>request</em> HTTP pada objek Ingress, maka trafik tersebut
akan diarahkan pada <em>backend default</em>.</p><h2 id=jenis-ingress>Jenis Ingress</h2><h3 id=ingress-dengan-satu-service>Ingress dengan satu Service</h3><p>Terdapat konsep Kubernetes yang memungkinkan kamu untuk mengekspos sebuah Service, lihat <a href=#alternatif-lain>alternatif lain</a>.
Kamu juga bisa membuat spesifikasi Ingress dengan <em>backend default</em> yang tidak memiliki <em>rules</em>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/ingress.yaml download=service/networking/ingress.yaml><code>service/networking/ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-ingress-yaml")' title="Copy service/networking/ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>testsvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Jika kamu menggunakan <code>kubectl apply -f</code> kamu dapat melihat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress test-ingress
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME           HOSTS     ADDRESS           PORTS     AGE
</span></span><span style=display:flex><span>test-ingress   *         107.178.254.228   <span style=color:#666>80</span>        59s
</span></span></code></pre></div><p>Dimana <code>107.178.254.228</code> merupakan alamat IP yang dialokasikan oleh kontroler Ingress untuk
memenuhi Ingress ini.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kontroler Ingress dan <em>load balancer</em> membutuhkan waktu sekitar satu hingga dua menit untuk mengalokasikan alamat IP.
Hingga alamat IP berhasil dialokasikan, kamu akan melihat tampilan kolom <code>ADDRESS</code> sebagai <code>&lt;pending></code>.</div><h3 id=fanout-sederhana><em>Fanout</em> sederhana</h3><p>Sebuah konfigurasi fanout akan melakukan <em>route</em> trafik dari sebuah alamat IP ke banyak Service,
berdasarkan URI HTTP yang diberikan. Sebuah Ingress memungkinkan kamu untuk memiliki jumlah <em>loadbalancer</em> minimum.
Contohnya, konfigurasi seperti di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>foo.bar.com -&gt; 178.91.123.132 -&gt; / foo    service1:4200
</span></span><span style=display:flex><span>                                 / bar    service2:8080
</span></span></code></pre></div><p>akan memerlukan konfigurasi Ingress seperti:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>simple-fanout-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>4200</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ketika kamu membuat Ingress dengan perintah <code>kubectl apply -f</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress simple-fanout-example
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:             simple-fanout-example
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Address:          178.91.123.132
</span></span><span style=display:flex><span>Default backend:  default-http-backend:80 <span style=color:#666>(</span>10.8.2.3:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Rules:
</span></span><span style=display:flex><span>  Host         Path  Backends
</span></span><span style=display:flex><span>  ----         ----  --------
</span></span><span style=display:flex><span>  foo.bar.com
</span></span><span style=display:flex><span>               /foo   service1:4200 <span style=color:#666>(</span>10.8.0.90:4200<span style=color:#666>)</span>
</span></span><span style=display:flex><span>               /bar   service2:8080 <span style=color:#666>(</span>10.8.0.91:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Annotations:
</span></span><span style=display:flex><span>  nginx.ingress.kubernetes.io/rewrite-target:  /
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type     Reason  Age                From                     Message
</span></span><span style=display:flex><span>  ----     ------  ----               ----                     -------
</span></span><span style=display:flex><span>  Normal   ADD     22s                loadbalancer-controller  default/test
</span></span></code></pre></div><p>Kontroler Ingress akan menyediakan <em>loadbalancer</em> (implementasinya tergantung dari jenis Ingress yang digunakan), selama <em>service-service</em> yang didefinisikan (<code>s1</code>, <code>s2</code>) ada.
Apabila <em>Ingress</em> selesai dibuat, maka kamu dapat melihat alamat IP dari berbagai <em>loadbalancer</em>
pada kolom <code>address</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu mungkin saja membutuhkan konfigurasi default-http-backend <a href=/id/docs/concepts/services-networking/service/>Service</a>
bergantung pada <a href=/id/docs/concepts/services-networking/ingress-controllers>kontroler Ingress</a> yang kamu pakai.</div><h3 id=virtual-host-berbasis-nama>Virtual Host berbasis Nama</h3><p>Virtual Host berbasis Nama memungkinkan mekanisme <em>routing</em> berdasarkan trafik HTTP ke beberapa <em>host name</em> dengan alamat IP yang sama.</p><pre tabindex=0><code class=language-none data-lang=none>foo.bar.com --|                 |-&gt; foo.bar.com s1:80
              | 178.91.123.132  |
bar.foo.com --|                 |-&gt; bar.foo.com s2:80
</code></pre><p>Ingress di bawah ini memberikan perintah pada <em>loadbalancer</em> untuk melakukan mekanisme <em>routing</em> berdasarkan
<a href=https://tools.ietf.org/html/rfc7230#section-5.4>header host</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika kamu membuat sebuah Ingress tanpa mendefinisikan <em>host</em> apa pun, maka
trafik web ke alamat IP dari kontroler Ingress tetap dapat dilakukan tanpa harus
menyesuaikan aturan <em>name based virtual host</em>. Sebagai contoh,
<em>resource</em> Ingress di bawah ini akan melakukan pemetaan trafik
dari <code>first.bar.com</code> ke <code>service1</code>, <code>second.foo.com</code> ke <code>service2</code>, dan trafik lain
ke alamat IP tanpa <em>host name</em> yang didefinisikan di dalam <em>request</em> (yang tidak memiliki <em>request header</em>) ke <code>service3</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>first.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>second.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=tls>TLS</h3><p>Kamu dapat mengamankan <em>Ingress</em> yang kamu miliki dengan memberikan spesifikasi <a href=/id/docs/concepts/configuration/secret>secret</a>
yang mengandung <em>private key</em> dan sertifikat TLS. Saat ini, Ingress hanya
memiliki fitur untuk melakukan konfigurasi <em>single TLS port</em>, yaitu 443, serta melakukan terminasi TLS.
Jika <em>section</em> TLS pada Ingress memiliki spesifikasi <em>host</em> yang berbeda,
<em>rules</em> yang ada akan dimultiplekskan pada <em>port</em> yang sama berdasarkan
<em>hostname</em> yang dispesifikasikan melalui ekstensi TLS SNI. <em>Secret</em> TLS harus memiliki
<code>key</code> bernama <code>tls.crt</code> dan <code>tls.key</code> yang mengandung <em>private key</em> dan sertifikat TLS, contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>base64 encoded cert<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>base64 encoded key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></span></span></code></pre></div><p>Ketika kamu menambahkan <em>secret</em> pada Ingress maka kontroler Ingress akan memberikan perintah untuk
memproteksi <em>channel</em> dari klien ke <em>loadbalancer</em> menggunakan TLS.
Kamu harus memastikan <em>secret</em> TLS yang digunakan memiliki sertifikat yang mengandung
CN untuk <code>sslexample.foo.com</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>tls-example-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>hosts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- sslexample.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>sslexample.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Terdapat perbedaan di antara beberapa fitur TLS
yang disediakan oleh berbagai kontroler Ingress. Perhatikan dokumentasi
<a href=https://git.k8s.io/ingress-nginx/README.md#https>nginx</a>,
<a href=https://git.k8s.io/ingress-gce/README.md#frontend-https>GCE</a>, atau
kontroler Ingress spesifik <em>platform</em> lainnya untuk memahami cara kerja TLS
pada <strong>environment</strong> yang kamu miliki.</div><h3 id=loadbalancing><em>Loadbalancing</em></h3><p>Sebuah kontroler Ingress sudah dibekali dengan beberapa <em>policy</em> terkait mekanisme <em>load balance</em>
yang nantinya akan diterapkan pada semua Ingress, misalnya saja algoritma <em>load balancing</em>, <em>backend
weight scheme</em>, dan lain sebagainya. Beberapa konsep <em>load balance</em> yang lebih <em>advance</em>
(misalnya saja <em>persistent sessions</em>, <em>dynamic weights</em>) belum diekspos melalui Ingress.
Meskipun begitu, kamu masih bisa menggunakan fitur ini melalui
<a href=https://github.com/kubernetes/ingress-nginx>loadbalancer service</a>.</p><p>Perlu diketahui bahwa meskipun <em>health check</em> tidak diekspos secara langsung
melalui Ingress, terdapat beberapa konsep di Kubernetes yang sejalan dengan hal ini, misalnya
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>readiness probes</a>
yang memungkinkan kamu untuk memperoleh hasil yang sama. Silahkan pelajari lebih lanjut dokumentasi
kontroler yang kamu pakai untuk mengetahui bagaimana implementasi <em>health checks</em> pada kontroler yang kamu pilih (<a href=https://git.k8s.io/ingress-nginx/README.md>nginx</a>,
<a href=https://git.k8s.io/ingress-gce/README.md#health-checks>GCE</a>).</p><h2 id=mengubah-ingress>Mengubah Ingress</h2><p>Untuk mengubah Ingress yang sudah ada dan menambahkan <em>host</em> baru, kamu dapat mengubahnya dengan mode <em>edit</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:             <span style=color:#a2f>test</span>
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Address:          178.91.123.132
</span></span><span style=display:flex><span>Default backend:  default-http-backend:80 <span style=color:#666>(</span>10.8.2.3:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Rules:
</span></span><span style=display:flex><span>  Host         Path  Backends
</span></span><span style=display:flex><span>  ----         ----  --------
</span></span><span style=display:flex><span>  foo.bar.com
</span></span><span style=display:flex><span>               /foo   s1:80 <span style=color:#666>(</span>10.8.0.90:80<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Annotations:
</span></span><span style=display:flex><span>  nginx.ingress.kubernetes.io/rewrite-target:  /
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type     Reason  Age                From                     Message
</span></span><span style=display:flex><span>  ----     ------  ----               ----                     -------
</span></span><span style=display:flex><span>  Normal   ADD     35s                loadbalancer-controller  default/test
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><p>Sebuah editor akan muncul dan menampilkan konfigurasi Ingress kamu
dalam format YAML apabila kamu telah menjalankan perintah di atas.
Ubah untuk menambahkan <em>host</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>s1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.baz.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>s2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>..<span style=color:#bbb>
</span></span></span></code></pre></div><p>Menyimpan konfigurasi dalam bentuk YAML ini akan mengubah <em>resource</em> pada API server,
yang kemudian akan memberi tahu kontroler Ingress untuk mengubah konfigurasi <em>loadbalancer</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:             <span style=color:#a2f>test</span>
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Address:          178.91.123.132
</span></span><span style=display:flex><span>Default backend:  default-http-backend:80 <span style=color:#666>(</span>10.8.2.3:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Rules:
</span></span><span style=display:flex><span>  Host         Path  Backends
</span></span><span style=display:flex><span>  ----         ----  --------
</span></span><span style=display:flex><span>  foo.bar.com
</span></span><span style=display:flex><span>               /foo   s1:80 <span style=color:#666>(</span>10.8.0.90:80<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  bar.baz.com
</span></span><span style=display:flex><span>               /foo   s2:80 <span style=color:#666>(</span>10.8.0.91:80<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Annotations:
</span></span><span style=display:flex><span>  nginx.ingress.kubernetes.io/rewrite-target:  /
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type     Reason  Age                From                     Message
</span></span><span style=display:flex><span>  ----     ------  ----               ----                     -------
</span></span><span style=display:flex><span>  Normal   ADD     45s                loadbalancer-controller  default/test
</span></span></code></pre></div><p>Kamu juga dapat mengubah Ingress dengan menggunakan perintah <code>kubectl replace -f</code> pada berkas konfigurasi
Ingress yang ingin diubah.</p><h2 id=mekanisme-failing-pada-beberapa-zona-availability>Mekanisme <em>failing</em> pada beberapa zona <em>availability</em></h2><p>Teknik untuk menyeimbangkan persebaran trafik pada <em>failure domain</em> berbeda antar penyedia layanan <em>cloud</em>.
Kamu dapat mempelajari dokumentasi yang relevan bagi <a href=/id/docs/concepts/services-networking/ingress-controllers>kontoler Ingress</a>
untuk informasi yang lebih detail. Kamu juga dapat mempelajari <a href=/id/docs/concepts/cluster-administration/federation/>dokumentasi federasi</a>
untuk informasi lebih detail soal bagaimana melakukan <em>deploy</em> untuk federasi klaster.</p><h2 id=pengembangan-selanjutnya>Pengembangan selanjutnya</h2><p>Silahkan amati <a href=https://github.com/kubernetes/community/tree/master/sig-network>SIG Network</a>
untuk detail lebih lanjut mengenai perubahan Ingress dan <em>resource</em> terkait lainnya. Kamu juga bisa melihat
<a href=https://github.com/kubernetes/ingress/tree/master>repositori Ingress</a> untuk informasi yang lebih detail
soal perubahan berbagai kontroler.</p><h2 id=alternatif-lain>Alternatif lain</h2><p>Kamu dapat mengekspos sebuah <em>Service</em> dalam berbagai cara, tanpa harus menggunakan <em>resource</em> Ingress, dengan menggunakan:</p><ul><li><a href=/id/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a></li><li><a href=/id/docs/concepts/services-networking/service/#nodeport>Service.Type=NodePort</a></li><li><a href=https://git.k8s.io/contrib/for-demos/proxy-to-service>Port Proxy</a></li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/access-application-cluster/ingress-minikube>Melakukan konfigurasi Ingress pada Minikube dengan kontroler NGINX</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>7 - Kontroler Ingress</h1><p>Agar Ingress dapat bekerja sebagaimana mestinya,
sebuah klaster harus memiliki paling tidak sebuah kontroler Ingress.</p><p>Berbeda dengan kontroler-kontroler lainnya yang dijalankan
sebagai bagian dari <em>binary</em> <code>kube-controller-manager</code>, kontroler Ingress
tidak secara otomatis dijalankan di dalam klaster. Kamu bisa menggunakan
laman ini untuk memilih implementasi kontroler Ingress yang kamu pikir
paling sesuai dengan kebutuhan kamu.</p><p>Kubernetes sebagai sebuah proyek, saat ini, mendukung dan memaintain kontroler-kontroler <a href=https://git.k8s.io/ingress-gce/README.md>GCE</a> dan
<a href=https://git.k8s.io/ingress-nginx/README.md>nginx</a>.</p><h2 id=kontroler-kontroler-lainnya>Kontroler-kontroler lainnya</h2><ul><li><a href=https://www.getambassador.io/>Ambassador</a> <em>API Gateway</em> merupakan ingress berbasis <a href=https://www.envoyproxy.io>Envoy</a>
kontroler dengan dukungan <a href=https://www.getambassador.io/docs>komunitas</a> atau
<a href=https://www.getambassador.io/pro/>komersial</a> dari <a href=https://www.datawire.io/>Datawire</a>.</li><li><a href=https://appscode.com>AppsCode Inc.</a> menawarkan dukungan dan pemeliharaan untuk ingress berbasis <a href=http://www.haproxy.org/>HAProxy</a>, <a href=https://appscode.com/products/voyager>Voyager</a>.</li><li><a href=https://projectcontour.io/>Contour</a> merupakan ingress berbasis <a href=https://www.envoyproxy.io/>Envoy</a>
yang disediakan dan didukung oleh VMware.</li><li>Citrix menyediakan sebuah <a href=https://github.com/citrix/citrix-k8s-ingress-controller>kontroler Ingress</a> untuk perangkat keras (MPX), virtualisasi (VPX) dan <a href=https://www.citrix.com/products/citrix-adc/cpx-express.html>kontainerisasi cuma-cuma (CPX) ADC</a> untuk mesin <a href=https://github.com/citrix/citrix-k8s-ingress-controller/tree/master/deployment/baremetal><em>baremetal</em></a> dan penyedia layanan <a href=https://github.com/citrix/citrix-k8s-ingress-controller/tree/master/deployment><em>cloud</em></a> deployments.</li><li>F5 Networks menyediakan <a href=https://support.f5.com/csp/article/K86859508>dukungan dan pemeliharaan</a>
untuk <a href=http://clouddocs.f5.com/products/connectors/k8s-bigip-ctlr/latest>kontroler F5 BIG-IP bagi Kubernetes</a>.</li><li><a href=https://gloo.solo.io>Gloo</a> adalah sebuah proyek kontroler Ingress <em>open source</em> berbasis <a href=https://www.envoyproxy.io>Envoy</a> yang menawarkan fungsionalitas <em>API Gateway</em> dengan dukungan <em>enterprise</em> dari <a href=https://www.solo.io>solo.io</a>.</li><li>Kontroler Ingress berbasis <a href=http://www.haproxy.org/>HAProxy</a>
<a href=https://github.com/jcmoraisjr/haproxy-ingress>jcmoraisjr/haproxy-ingress</a> yang disebutkan di dalam artikel
<a href=https://www.haproxy.com/blog/haproxy_ingress_controller_for_kubernetes/>HAProxy Ingress Controller for Kubernetes</a>.
<a href=https://www.haproxy.com/>HAProxy Technologies</a> menawarkan dukungan dan pemeliharaan bagi HAProxy Enterprise dan
Ingress kontroler <a href=https://github.com/jcmoraisjr/haproxy-ingress>jcmoraisjr/haproxy-ingress</a>.</li><li>Kontroler Ingress berbasis <a href=https://istio.io/>Istio</a>
<a href=https://istio.io/docs/tasks/traffic-management/ingress/>Control Ingress Traffic</a>.</li><li><a href=https://konghq.com/>Kong</a> menawarkan dukungan dan pemeliharaan <a href=https://discuss.konghq.com/c/kubernetes>komunitas</a> atau
<a href=https://konghq.com/kong-enterprise/>komersial</a>
<a href=https://github.com/Kong/kubernetes-ingress-controller>Kontroler Ingress untuk Kubernetes</a>.</li><li><a href=https://www.nginx.com/>NGINX, Inc.</a> menawarkan dukungan dan pemeliharaan <a href=https://www.nginx.com/products/nginx/kubernetes-ingress-controller>Kontroler Ingress NGINX untuk Kubernetes</a>.</li><li><a href=https://github.com/containous/traefik>Traefik</a> adalah sebuah kontroler Ingress yang menyediakan semua fitur secara lengkap (fully featured)
(<a href=https://letsencrypt.org>Let's Encrypt</a>, <em>secrets</em>, <em>http2</em>, <em>websocket</em>), dengan tambahan dukungan
komersial oleh <a href=https://containo.us/services>Containous</a>.</li></ul><h2 id=menggunakan-beberapa-jenis-kontroler-ingress-sekaligus>Menggunakan beberapa jenis kontroler Ingress sekaligus</h2><p>Kamu dapat melakukan <em>deploy</em> <a href=https://git.k8s.io/ingress-nginx/docs/user-guide/multiple-ingress.md#multiple-ingress-controllers>berapa pun banyaknya kontroler Ingress</a>
dalam sebuah klaster. Jika kamu ingin membuat Ingress, kamu tinggal memberikan anotasi setiap Ingress sesuai dengan
<a href=https://git.k8s.io/ingress-gce/docs/faq/README.md#how-do-i-run-multiple-ingress-controllers-in-the-same-cluster><code>ingress.class</code></a>
yang sesuai untuk menandai kontroler Ingress mana yang digunakan jika terdapat lebih dari satu kontroler Ingress yang ada di
klaster kamu.</p><p>Apabila kamu tidak mendefinisikan <code>class</code> yang dipakai, penyedia layanan <em>cloud</em> kamu akan menggunakan kontroler Ingress <em>default</em> yang mereka miliki.</p><p>Idealnya, semua ingress harus memenuhi spesifikasi ini, tetapi berbagai jenis
kontroler Ingress bisa saja memiliki sedikit perbedaan cara kerja.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pastikan kamu sudah terlebih dahulu memahami dokumentasi kontroler Ingress yang akan kamu pakai sebelum memutuskan untuk memakai kontroler tersebut.</div><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari <a href=/id/docs/concepts/services-networking/ingress/>Ingress</a> lebih lanjut.</li><li><a href=/docs/tasks/access-application-cluster/ingress-minikube>Melakukan konfigurasi Ingress pada Minikube dengan kontroler NGINX</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ded1daafdcd293023ee333728007ca61>8 - NetworkPolicy</h1><nav id=TableOfContents><ul><li><a href=#prasyarat>Prasyarat</a></li><li><a href=#pod-yang-terisolasi-dan-tidak-terisolasi>Pod yang terisolasi dan tidak terisolasi</a></li><li><a href=#resource-networkpolicy><em>Resource</em> <code>NetworkPolicy</code></a></li><li><a href=#perilaku-selektor-to-dan-from>Perilaku selektor <code>to</code> dan <code>from</code></a></li><li><a href=#policy-default><em>Policy</em> <em>Default</em></a><ul><li><a href=#default-tolak-semua-trafik-ingress><em>Default</em>: tolak semua trafik <em>ingress</em></a></li><li><a href=#default-izinkan-semua-trafik-ingress><em>Default</em>: izinkan semua trafik <em>ingress</em></a></li><li><a href=#default-tolak-semua-trafik-egress><em>Default</em>: tolak semua trafik <em>egress</em></a></li><li><a href=#default-izinkan-semua-trafik-egress><em>Default</em>: izinkan semua trafik <em>egress</em></a></li><li><a href=#default-tolak-semua-trafik-ingress-dan-egress><em>Default</em>: tolak semua trafik <em>ingress</em> dan <em>egress</em></a></li></ul></li><li><a href=#dukungan-terhadap-sctp>Dukungan terhadap SCTP</a></li><li><a href=#selanjutnya>Selanjutnya</a></li></ul></nav><p>Sebuah NetworkPolicy adalah spesifikasi dari sekelompok Pod atau <em>endpoint</em> yang diizinkan untuk saling berkomunikasi.</p><p><code>NetworkPolicy</code> menggunakan label untuk memilih Pod serta mendefinisikan serangkaian <em>rule</em> yang digunakan
untuk mendefinisikan trafik yang diizinkan untuk suatu Pod tertentu.</p><h2 id=prasyarat>Prasyarat</h2><p>NetworkPolicy diimplementasikan dengan menggunakan <em>plugin</em> jaringan,
dengan demikian kamu harus memiliki penyedia jaringan yang mendukung <code>NetworkPolicy</code> -
membuat <em>resource</em> tanpa adanya <em>controller</em> tidak akan berdampak apa pun.</p><h2 id=pod-yang-terisolasi-dan-tidak-terisolasi>Pod yang terisolasi dan tidak terisolasi</h2><p>Secara <em>default</em>, Pod bersifat tidak terisolasi; Pod-Pod tersebut
menerima trafik dari <em>resource</em> apa pun.</p><p>Pod menjadi terisolasi apabila terdapat <code>NetworkPolicy</code> yang dikenakan pada Pod-Pod tersebut.
Apabila terdapat <code>NetworkPolicy</code> di dalam <em>namespace</em> yang dikenakan pada suatu Pod, Pod tersebut
akan menolak koneksi yang tidak diizinkan <code>NetworkPolicy</code>. (Pod lain dalam <em>namespace</em>
yang tidak dikenakan <code>NetworkPolicy</code> akan tetap menerima trafik dari semua <em>resource</em>.)</p><h2 id=resource-networkpolicy><em>Resource</em> <code>NetworkPolicy</code></h2><p>Lihat <a href=/docs/reference/generated/kubernetes-api/v1.25/#networkpolicy-v1-networking-k8s-io><code>NetworkPolicy</code></a> untuk definisi lengkap <em>resource</em>.</p><p>Sebuah contoh <code>NetworkPolicy</code> akan terlihat seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-network-policy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.0</span>/16<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>except</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#666>172.17.1.0</span>/24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>project</span>:<span style=color:#bbb> </span>myproject<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>to</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.0.0</span>/24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>5978</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Mengirimkan ini ke API server dengan metode POST tidak akan berdampak apa pun
kecuali penyedia jaringan mendukung network policy.</p><p><strong><em>Field-field</em> yang bersifat wajib</strong>: Sama dengan seluruh <em>config</em> Kubernetes lainnya, sebuah <code>NetworkPolicy</code>
membutuhkan <em>field-field</em> <code>apiVersion</code>, <code>kind</code>, dan <code>metadata</code>. Informasi generik mengenai
bagaimana bekerja dengan <em>file</em> <code>config</code>, dapat dilihat di
<a href=/id/docs/tasks/configure-pod-container/configure-pod-configmap/>Konfigurasi Kontainer menggunakan <code>ConfigMap</code></a>,
serta <a href=/id/docs/tasks/manage-kubernetes-objects/>Manajemen Objek</a>.</p><p><strong>spec</strong>: <code>NetworkPolicy</code> <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>spec</a> memiliki semua informasi yang harus diberikan untuk memberikan definisi <em>network policy</em> yang ada pada <em>namespace</em> tertentu.</p><p><strong>podSelector</strong>: Setiap <code>NetworkPolicy</code> memiliki sebuah <code>podSelector</code> yang bertugas memfilter Pod-Pod yang dikenai <em>policy</em> tersebut. Contoh yang ada memfilter Pod dengan label <code>"role=db"</code>. Sebuah <code>podSelector</code> yang empty akan memilih semua Pod yang ada di dalam <em>namespace</em>.</p><p><strong>policyTypes</strong>: Setiap <code>NetworkPolicy</code> memiliki sebuah daftar <code>policyTypes</code> yang dapat berupa <code>Ingress</code>, <code>Egress</code>, atau keduanya. <em>Field</em> <code>policyTypes</code> mengindikasikan apakah suatu <em>policy</em> diberikan pada trafik <em>ingress</em>, <em>egress</em>, atau camputan <em>ingress</em> dan <em>egress</em> pada Pod tertentu. Jika tidak ada <code>policyTypes</code> tyang diberikan pada <code>NetworkPolicy</code> maka <code>Ingress</code> <em>default</em> akan diterapkan dan <code>Egress</code> akan diterapkan apabila <em>policy</em> tersebut memberikan spesifikasi <em>egress</em>.</p><p><strong>ingress</strong>: Setiap <code>NetworkPolicy</code> bisa saja memberikan serangkaian whitelist <em>rule-rule</em> <code>ingress</code>. Setiap <em>rule</em> mengizinkan trafik yang sesuai dengan <em>section</em> <code>from</code> dan <code>ports</code>. Contoh <em>policy</em> yang diberikan memiliki sebuah <em>rule</em>, yang sesuai dengan trafik pada sebuah <code>port</code> <em>single</em>, bagian pertama dispesifikasikan melalui <code>ipBlock</code>, yang kedua melalui <code>namespaceSelector</code> dan yang ketiga melalui <code>podSelector</code>.</p><p><strong>egress</strong>: Setiap <code>NetworkPolicy</code> bisa saja meliputi serangkaian <em>whitelist</em> <em>rule-rule</em> <code>egress</code>. Setiap <em>rule</em> mengizinkan trafik yang sesuai dengan <em>section</em> <code>to</code> dan <code>ports</code>. Contoh <em>policy</em> yang diberikan memiliki sebuah <em>rule</em>, yang sesuai dengan <code>port</code> <em>single</em> pada destinasi <code>10.0.0.0/24</code>.</p><p>Pada contoh, <code>NetworkPolicy</code> melakukan hal berikut:</p><ol><li><p>Mengisolasi Pod-Pod dengan label <code>"role=db"</code> pada <em>namespace</em> <code>"default"</code> baik untuk <code>ingress</code> atau <code>egress</code>.</p></li><li><p>(<em>Rule</em> <code>Ingress</code>) mengizinkan koneksi ke semua Pod pada <em>namespace</em> <code>“default”</code> dengan label <code>“role=db”</code> untuk protokol TCP <code>port</code> <code>6379</code> dari:</p><ul><li>semua Pod pada <em>namespace</em> <code>"default"</code> dengan label <code>"role=frontend"</code></li><li>semua Pod dalam sebuah <em>namespace</em> dengan label <code>"project=myproject"</code></li><li>alamat IP pada <em>range</em> <code>172.17.0.0–172.17.0.255</code> dan <code>172.17.2.0–172.17.255.255</code> (yaitu, semua <code>172.17.0.0/16</code> kecuali <code>172.17.1.0/24</code>)</li></ul></li><li><p>(<em>Rule</em> Egress) mengizinkan koneksi dari semua Pod pada <em>namespace</em> <code>"default"</code> dengan label <code>"role=db"</code> ke CIDR <code>10.0.0.0/24</code> untuk protokol TCP pada <code>port</code> <code>5978</code></p></li></ol><p>Lihat mekanisme <a href=/docs/tasks/administer-cluster/declare-network-policy/>Deklarasi <em>Network Policy</em></a> untuk penjelasan lebih mendalam.</p><h2 id=perilaku-selektor-to-dan-from>Perilaku selektor <code>to</code> dan <code>from</code></h2><p>Terdapat empat jenis selektor yang dapat dispesifikasikan dalam <code>section</code> <code>ingress</code> <code>from</code> atau <code>section</code> <code>egress</code> <code>to</code>:</p><p><strong>podSelector</strong>: Ini digunakan untuk memfilter Pod tertentu pada <em>namespace</em> dimana <code>NetworkPolicy</code> berada yang akan mengatur destinasi <em>ingress</em> atau <em>egress</em>.</p><p><strong>namespaceSelector</strong>: Ini digunakan untuk memfilter <em>namespace</em> tertentu dimana semua Pod diperbolehkan sebagai <em>source</em> <code>ingress</code> atau destinasi <code>egress</code>.</p><p><strong>namespaceSelector</strong> <em>and</em> <strong>podSelector</strong>: Sebuah entri <code>to</code>/<code>from</code> yang memberikan spesifikasi <code>namespaceSelector</code> dan <code>podSelector</code> serta memilih Pod-Pod tertentu yang ada di dalam <em>namespace</em>. Pastikan kamu menggunakan sintaks YAML yang tepat; <code>policy</code> ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>mengandung sebuah elemen <code>from</code> yang mengizinkan koneksi dari Pod-Pod dengan label <code>role=client</code> di <em>namespace</em> dengan label <code>user=alice</code>. Akan tetapi, <em>policy</em> <em>ini</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>mengandung dua elemen pada <em>array</em> <code>from</code>, dan mengizinkan koneksi dari Pod pada Namespace lokal dengan label
<code>role=client</code>, <em>atau</em> dari Pod di <em>namespace</em> apa pun dengan label <code>user=alice</code>.</p><p>Ketika kamu merasa ragu, gunakan <code>kubectl describe</code> untuk melihat bagaimana Kubernetes
menginterpretasikan <em>policy</em> tersebut.</p><p><strong>ipBlock</strong>: Ini digunakan untuk memilih <em>range</em> IP CIDR tertentu untuk berperan sebagai
<em>source</em> <em>ingress</em> atau destinasi <em>egress</em>. Alamat yang digunakan harus merupakan
alamat IP eksternal klaster, karena alamat IP Pod bersifat <em>ephemeral</em> dan tidak dapat ditebak.</p><p>Mekanisme <em>ingress</em> dan <em>egress</em> klaster seringkali membutuhkan mekanisme <em>rewrite</em> alamat IP <em>source</em> dan destinasi
paket. Pada kasus-kasus dimana hal ini, tidak dapat dipastikan bahwa apakah hal ini
terjadi sebelum atau setelah pemrosesan <code>NetworkPolicy</code>, dan perilaku yang ada mungkin saja berbeda
untuk kombinasi <em>plugin</em> jaringan, penyedia layanan <em>cloud</em>, serta implementasi <code>Service</code> yang berbeda.</p><p>Pada <em>ingress</em>, artinya bisa saja kamu melakukan <em>filter</em> paket yang masuk berdasarkan <code>source IP</code>,
sementara di kasus lain "source IP" yang digunakan oleh Network Policy adalah alamat IP <code>LoadBalancer</code>,
<em>node</em> dimana Pod berada, dsb.</p><p>Pada <em>egress</em>, bisa saja sebuah koneksi dari Pod ke IP <code>Service</code> di-<em>rewrite</em> ke IP eksternal klaster
atau bahkan tidak termasuk di dalam <code>ipBlock</code> <em>policy</em>.</p><h2 id=policy-default><em>Policy</em> <em>Default</em></h2><p>Secara <em>default</em>, jika tidak ada <em>policy</em> yang ada dalam suatu <em>namespace</em>, maka semua trafik <em>ingress</em> dan <em>egress</em> yang diizinkan ke atau dari Pod dalam <em>namespace</em>.
Contoh di bawah ini akan memberikan gambaran bagaimana kamu dapat mengubah perilaku <em>default</em> pada sebuah <em>namespace</em>.</p><h3 id=default-tolak-semua-trafik-ingress><em>Default</em>: tolak semua trafik <em>ingress</em></h3><p>Kamu dapat membuat <em>policy</em> isolasi <code>"default"</code> untuk sebuah <em>namespace</em>
dengan membuat sebuah <code>NetworkPolicy</code> yang memilih semua Pod tapi tidak mengizinkan
trafik <em>ingress</em> masuk ke Pod-Pod tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span></code></pre></div><p>Hal ini menjamin bahwa bahkan Pod yang tidak dipilih oleh <code>NetworkPolicy</code> lain masih terisolasi.
<em>Policy</em> ini tidak mengubah perilaku <em>default</em> dari <em>egress</em>.</p><h3 id=default-izinkan-semua-trafik-ingress><em>Default</em>: izinkan semua trafik <em>ingress</em></h3><p>Jika kamu ingin mengizinkan semua trafik <em>ingress</em> pada semua Pod dalam sebuah <em>namespace</em>
(bahkan jika <em>policy</em> ditambahkan dan menyebabkan beberapa Pod menjadi terisolasi), kamu
dapat secara eksplisit mengizinkan semua trafik bagi <em>namespace</em> tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=default-tolak-semua-trafik-egress><em>Default</em>: tolak semua trafik <em>egress</em></h3><p>Kamu dapat membuat <em>policy</em> isolasi <code>"default"</code> untuk sebuah <em>namespace</em>
dengan membuat sebuah <code>NetworkPolicy</code> yang memilih semua Pod tapi tidak mengizinkan
trafik <em>egress</em> keluar dari Pod-Pod tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div><p>Hal ini menjamin bahwa bahkan Pod yang tidak dipilih oleh <code>NetworkPolicy</code> lain masih terisolasi.
<em>Policy</em> ini tidak mengubah perilaku <em>default</em> dari <em>ingress</em>.</p><h3 id=default-izinkan-semua-trafik-egress><em>Default</em>: izinkan semua trafik <em>egress</em></h3><p>Jika kamu ingin mengizinkan semua trafik <em>egress</em> pada semua Pod dalam sebuah <em>namespace</em>
(bahkan jika <em>policy</em> ditambahkan dan menyebabkan beberapa Pod menjadi terisolasi), kamu
dapat secara eksplisit mengizinkan semua trafik bagi <em>namespace</em> tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=default-tolak-semua-trafik-ingress-dan-egress><em>Default</em>: tolak semua trafik <em>ingress</em> dan <em>egress</em></h3><p>Kamu dapat membuat sebuah <em>policy</em> <em>"default"</em> jika kamu ingin menolak semua trafik <em>ingress</em> maupun <em>egress</em> pada semua Pod dalam sebuah <em>namespace</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div><p>Hal ini menjamin bahwa bahkan Pod yang tidak dipilih oleh <code>NetworkPolicy</code> tidak akan mengizinkan trafik <em>ingress</em> atau <em>egress</em>.</p><h2 id=dukungan-terhadap-sctp>Dukungan terhadap SCTP</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>Kubernetes mendukung SCTP sebagai <em>value</em> <code>protocol</code> pada definisi <code>NetworkPolicy</code> sebagai fitur alpha. Untuk mengaktifkan fitur ini, administrator klaster harus mengaktifkan gerbang fitur <code>SCTPSupport</code> pada <code>apiserver</code>, contohnya <code>“--feature-gates=SCTPSupport=true,...”</code>. Ketika gerbang fitur ini diaktifkan, pengguna dapat menerapkan <code>value</code> dari <em>field</em> <code>protocol</code> pada <code>NetworkPolicy</code> menjadi <code>SCTP</code>. Kubernetes akan mengatur jaringan sesuai dengan SCTP, seperti halnya koneksi TCP.</p><p><em>Plugin</em> CNI harus mendukung SCTP sebagai <em>value</em> dari <code>protocol</code> pada <code>NetworkPolicy</code>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Lihat <a href=/docs/tasks/administer-cluster/declare-network-policy/>Deklarasi <em>Network Policy</em></a> untuk melihat lebih banyak contoh penggunaan.</li><li>Baca lebih lanjut soal <a href=https://github.com/ahmetb/kubernetes-network-policy-recipes>panduan</a> bagi skenario generik <em>resource</em> <code>NetworkPolicy</code>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-509638b5ca0e420fa426f14f34e2d3b1>9 - Menambahkan Entry pada /etc/hosts Pod dengan HostAliases</h1><nav id=TableOfContents><ul><li><a href=#isi-default-pada-berkas-hosts>Isi Default pada Berkas <code>Hosts</code></a></li><li><a href=#menambahkan-entri-tambahan-dengan-hostaliases>Menambahkan Entri Tambahan dengan HostAliases</a></li><li><a href=#kenapa-kubelet-melakukan-mekanisme-manajemen-berkas-hosts>Kenapa Kubelet Melakukan Mekanisme Manajemen Berkas <code>Hosts</code>?</a></li></ul></nav><p>Menambahkan entri pada berkas /etc/hosts Pod akan melakukan <em>override</em>
resolusi <em>hostname</em> pada level Pod ketika DNS dan opsi lainnya tidak tersedia.
Pada versi 1.7, pengguna dapat menambahkan entri yang diinginkan beserta <em>field</em> HostAliases
pada PodSpec.</p><p>Modifikasi yang dilakukan tanpa menggunakan HostAliases tidaklah disarankan
karena berkas ini diatur oleh Kubelet dan dapat di-<em>override</em> ketika Pod dibuat/di-<em>restart</em>.</p><h2 id=isi-default-pada-berkas-hosts>Isi Default pada Berkas <code>Hosts</code></h2><p>Misalnya saja kamu mempunyai sebuah Pod Nginx yang memiliki sebuah IP Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image nginx --generator<span style=color:#666>=</span>run-pod/v1
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pod/nginx created
</span></span></code></pre></div><p>Perhatikan IP Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
</span></span><span style=display:flex><span>nginx    1/1       Running   <span style=color:#666>0</span>          13s    10.200.0.4   worker0
</span></span></code></pre></div><p><em>File</em> <code>hosts</code> yang ada akan tampak sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> nginx -- cat /etc/hosts
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none># Berkas hosts yang dikelola Kubernetes
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.4	nginx
</code></pre><p>Secara default, berkas <code>hosts</code> hanya berisikan <em>boilerplate</em> alamat IP IPv4 and IPv6 seperti
<code>localhost</code> dan hostname dari Pod itu sendiri.</p><h2 id=menambahkan-entri-tambahan-dengan-hostaliases>Menambahkan Entri Tambahan dengan HostAliases</h2><p>Selain <em>boilerplate default</em>, kita dapat menambahkan entri pada berkas
<code>hosts</code> untuk melakukan resolusi <code>foo.local</code>, <code>bar.local</code> pada <code>127.0.0.1</code> dan <code>foo.remote</code>,
<code>bar.remote</code> pada <code>10.1.2.3</code>, kita dapat melakukannya dengan cara menambahkan
HostAliases pada Pod di bawah <em>field</em> <code>.spec.hostAliases</code>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/hostaliases-pod.yaml download=service/networking/hostaliases-pod.yaml><code>service/networking/hostaliases-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-hostaliases-pod-yaml")' title="Copy service/networking/hostaliases-pod.yaml to clipboard"></img></div><div class=includecode id=service-networking-hostaliases-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostaliases-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostAliases</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;127.0.0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.local&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.local&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.remote&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.remote&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cat-hosts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/hosts&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Pod ini kemudian dapat dihidupkan dengan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f hostaliases-pod.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pod/hostaliases-pod created
</span></span></code></pre></div><p>Perhatikan IP dan status Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                           READY     STATUS      RESTARTS   AGE       IP              NODE
</span></span><span style=display:flex><span>hostaliases-pod                0/1       Completed   <span style=color:#666>0</span>          6s        10.200.0.5      worker0
</span></span></code></pre></div><p><em>File</em> <code>hosts</code> yang ada akan tampak sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs hostaliases-pod
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none># Berkas hosts yang dikelola Kubernetes
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.5	hostaliases-pod

# Entries added by HostAliases.
127.0.0.1	foo.local	bar.local
10.1.2.3	foo.remote	bar.remote
</code></pre><p>Dengan tambahan entri yang telah dispesifikasikan sebelumnya.</p><h2 id=kenapa-kubelet-melakukan-mekanisme-manajemen-berkas-hosts>Kenapa Kubelet Melakukan Mekanisme Manajemen Berkas <code>Hosts</code>?</h2><p>Kubelet <a href=https://github.com/kubernetes/kubernetes/issues/14633>melakukan proses manajemen</a>
berkas <code>hosts</code> untuk setiap container yang ada pada Pod untuk mencegah Docker melakukan
<a href=https://github.com/moby/moby/issues/17190>modifikasi</a> pada berkas tersebut
setelah kontainer dihidupkan.</p><p>Karena sifat dari berkas tersebut yang secara otomatis di-<em>manage</em>,
semua hal yang didefinisikan oleh pengguna akan ditimpa (<em>overwrite</em>) ketika berkas
<code>hosts</code> di-<em>mount</em> kembali oleh Kubelet ketika ada kontainer yang di-<em>restart</em>
atau Pod di-<em>schedule</em> ulang. Dengan demikian tidak dianjurkan untuk
memodifikasi berkas tersebut secara langsung.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-21f8d19c60c33914baab66224c3d46a7>10 - Dual-stack IPv4/IPv6</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p><em>Dual-stack</em> IPv4/IPv6 memungkinkan pengalokasian alamat IPv4 dan IPv6 untuk
<a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> dan <a class=glossary-tooltip title='Sebuah Cara untuk mengekspos aplikasi yang berjalan pada sebuah kumpulan Pod sebagai layanan jaringan.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>.</p><p>Jika kamu mengaktifkan jaringan <em>dual-stack</em> IPv4/IPv6 untuk klaster Kubernetes
kamu, klaster akan mendukung pengalokasian kedua alamat IPv4 dan IPv6 secara
bersamaan.</p><h2 id=fitur-fitur-yang-didukung>Fitur-fitur yang didukung</h2><p>Mengaktifkan <em>dual-stack</em> IPv4 / IPv6 pada klaster Kubernetes kamu untuk
menyediakan fitur-fitur berikut ini:</p><ul><li>Jaringan Pod <em>dual-stack</em> (pengalokasian sebuah alamat IPv4 dan IPv6 untuk setiap Pod)</li><li>Service yang mendukung IPv4 dan IPv6 (setiap Service hanya untuk satu keluarga alamat)</li><li>Perutean Pod ke luar klaster (misalnya Internet) melalui antarmuka IPv4 dan IPv6</li></ul><h2 id=prasyarat>Prasyarat</h2><p>Prasyarat berikut diperlukan untuk menggunakan <em>dual-stack</em> IPv4/IPv6 pada
klaster Kubernetes :</p><ul><li>Kubernetes versi 1.16 atau yang lebih baru</li><li>Dukungan dari penyedia layanan untuk jaringan <em>dual-stack</em> (Penyedia layanan <em>cloud</em> atau yang lainnya harus dapat menyediakan antarmuka jaringan IPv4/IPv6 yang dapat dirutekan) untuk Node Kubernetes</li><li>Sebuah <em>plugin</em> jaringan yang mendukung <em>dual-stack</em> (seperti Kubenet atau Calico)</li><li>Kube-proxy yang berjalan dalam mode IPVS</li></ul><h2 id=mengaktifkan-dual-stack-ipv4-ipv6>Mengaktifkan <em>dual-stack</em> IPv4/IPv6</h2><p>Untuk mengaktifkan <em>dual-stack</em> IPv4/IPv6, aktifkan <a href=/docs/reference/command-line-tools-reference/feature-gates/>gerbang fitur (<em>feature gate</em>)</a> <code>IPv6DualStack</code>
untuk komponen-komponen yang relevan dari klaster kamu, dan tetapkan jaringan
<em>dual-stack</em> pada klaster:</p><ul><li>kube-controller-manager:<ul><li><code>--feature-gates="IPv6DualStack=true"</code></li><li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code> misalnya <code>--cluster-cidr=10.244.0.0/16,fc00::/24</code></li><li><code>--service-cluster-ip-range=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li><li><code>--node-cidr-mask-size-ipv4|--node-cidr-mask-size-ipv6</code> nilai bawaannya adalah /24
untuk IPv4 dan /64 untuk IPv6</li></ul></li><li>kubelet:<ul><li><code>--feature-gates="IPv6DualStack=true"</code></li></ul></li><li>kube-proxy:<ul><li><code>--proxy-mode=ipvs</code></li><li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li><li><code>--feature-gates="IPv6DualStack=true"</code></li></ul></li></ul><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Jika kamu menentukan blok alamat IPv6 yang lebih besar dari /24 melalui
<code>--cluster-cidr</code> pada baris perintah, maka penetapan tersebut akan gagal.</div><h2 id=service>Service</h2><p>Jika klaster kamu mengaktifkan jaringan <em>dual-stack</em> IPv4/IPv6, maka kamu dapat
membuat <a class=glossary-tooltip title='Sebuah Cara untuk mengekspos aplikasi yang berjalan pada sebuah kumpulan Pod sebagai layanan jaringan.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a> dengan
alamat IPv4 atau IPv6. Kamu dapat memilih keluarga alamat untuk clusterIP<br>Service kamu dengan mengatur bagian, <code>.spec.ipFamily</code>, pada Service tersebut.
Kamu hanya dapat mengatur bagian ini saat membuat Service baru. Mengatur bagian
<code>.spec.ipFamily</code> bersifat opsional dan hanya boleh digunakan jika kamu berencana
untuk mengaktifkan <a class=glossary-tooltip title='Sebuah Cara untuk mengekspos aplikasi yang berjalan pada sebuah kumpulan Pod sebagai layanan jaringan.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label='Service '>Service</a>
dan <a class=glossary-tooltip title='Sebuah obyek API yang mengatur akses eksternal terhadap Service yang ada di dalam klaster, biasanya dalam bentuk request HTTP.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/ingress/ target=_blank aria-label='Ingress '>Ingress</a> IPv4 dan IPv6
pada klaster kamu. Konfigurasi bagian ini bukanlah syarat untuk lalu lintas
[<em>egress</em>] (#lalu-lintas-egress).</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Keluarga alamat bawaan untuk klaster kamu adalah keluarga alamat dari rentang
clusterIP Service pertama yang dikonfigurasi melalui opsi
<code>--service-cluster-ip-range</code> pada kube-controller-manager.</div><p>Kamu dapat mengatur <code>.spec.ipFamily</code> menjadi salah satu dari:</p><ul><li><code>IPv4</code>: Dimana server API akan mengalokasikan IP dari <code>service-cluster-ip-range</code> yaitu <code>ipv4</code></li><li><code>IPv6</code>: Dimana server API akan mengalokasikan IP dari <code>service-cluster-ip-range</code> yaitu <code>ipv6</code></li></ul><p>Spesifikasi Service berikut ini tidak memasukkan bagian <code>ipFamily</code>.
Kubernetes akan mengalokasikan alamat IP (atau yang dikenal juga sebagai
"<em>cluster IP</em>") dari <code>service-cluster-ip-range</code> yang dikonfigurasi pertama kali
untuk Service ini.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-default-svc-yaml")' title="Copy service/networking/dual-stack-default-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-default-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span></span></span></code></pre></div></div></div><p>Spesifikasi Service berikut memasukkan bagian <code>ipFamily</code>. Sehingga Kubernetes
akan mengalokasikan alamat IPv6 (atau yang dikenal juga sebagai "<em>cluster IP</em>")
dari <code>service-cluster-ip-range</code> yang dikonfigurasi untuk Service ini.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/dual-stack-ipv6-svc.yaml download=service/networking/dual-stack-ipv6-svc.yaml><code>service/networking/dual-stack-ipv6-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-ipv6-svc-yaml")' title="Copy service/networking/dual-stack-ipv6-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-ipv6-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamily</span>:<span style=color:#bbb> </span>IPv6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span></span></span></code></pre></div></div></div><p>Sebagai perbandingan, spesifikasi Service berikut ini akan dialokasikan sebuah alamat
IPv4 (atau yang dikenal juga sebagai "<em>cluster IP</em>") dari <code>service-cluster-ip-range</code>
yang dikonfigurasi untuk Service ini.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/dual-stack-ipv4-svc.yaml download=service/networking/dual-stack-ipv4-svc.yaml><code>service/networking/dual-stack-ipv4-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-ipv4-svc-yaml")' title="Copy service/networking/dual-stack-ipv4-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-ipv4-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamily</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span></span></span></code></pre></div></div></div><h3 id=tipe-loadbalancer>Tipe <em>LoadBalancer</em></h3><p>Penyedia layanan <em>cloud</em> yang mendukung IPv6 untuk pengaturan beban eksternal,
Mengatur bagian <code>type</code> menjadi <code>LoadBalancer</code> sebagai tambahan terhadap mengatur bagian
<code>ipFamily</code> menjadi <code>IPv6</code> menyediakan sebuah <em>cloud load balancer</em> untuk Service kamu.</p><h2 id=lalu-lintas-egress>Lalu lintas <em>egress</em></h2><p>Penggunaan blok alamat IPv6 yang dapat dirutekan dan yang tidak dapat dirutekan
secara publik diperbolehkan selama <a class=glossary-tooltip title='Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification.' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/ target=_blank aria-label=CNI>CNI</a>
dari penyedia layanan dapat mengimplementasikan transportasinya. Jika kamu memiliki
Pod yang menggunakan IPv6 yang dapat dirutekan secara publik dan ingin agar Pod
mencapai tujuan di luar klaster (misalnya Internet publik), kamu harus mengatur
IP samaran untuk lalu lintas keluar dan balasannya. <a href=https://github.com/kubernetes-incubator/ip-masq-agent><em>ip-masq-agent</em></a>
bersifat <em>dual-stack aware</em>, jadi kamu bisa menggunakan ip-masq-agent untuk
<em>masquerading</em> IP dari klaster <em>dual-stack</em>.</p><h2 id=masalah-masalah-yang-diketahui>Masalah-masalah yang diketahui</h2><ul><li>Kubenet memaksa pelaporan posisi IP untuk IPv4,IPv6 IP (--cluster-cidr)</li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/network/validate-dual-stack>Validasi jaringan <em>dual-stack</em> IPv4/IPv6</a></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>