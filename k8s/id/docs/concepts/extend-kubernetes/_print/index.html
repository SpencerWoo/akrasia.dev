<!doctype html><html lang=id class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/extend-kubernetes/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Memperluas Kubernetes | Kubernetes</title><meta property="og:title" content="Memperluas Kubernetes"><meta property="og:description" content="Orkestrasi Kontainer dengan Skala Produksi"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/extend-kubernetes/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Memperluas Kubernetes"><meta itemprop=description content="Orkestrasi Kontainer dengan Skala Produksi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Memperluas Kubernetes"><meta name=twitter:description content="Orkestrasi Kontainer dengan Skala Produksi"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/extend-kubernetes/"><meta property="og:title" content="Memperluas Kubernetes"><meta name=twitter:title content="Memperluas Kubernetes"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/id/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/id/docs/concepts/extend-kubernetes/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/concepts/extend-kubernetes/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/concepts/extend-kubernetes/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/concepts/extend-kubernetes/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/extend-kubernetes/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/extend-kubernetes/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/extend-kubernetes/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/extend-kubernetes/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/extend-kubernetes/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/extend-kubernetes/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/extend-kubernetes/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/extend-kubernetes/>Português (Portuguese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/concepts/extend-kubernetes/>Return to the regular view of this page</a>.</p></div><h1 class=title>Memperluas Kubernetes</h1><ul><li>1: <a href=#pg-5c2b36cd0ddbe006b575d4e54c63d508>Memperluas Klaster Kubernetes Kamu</a></li><li>2: <a href=#pg-0af41d3bd7c785621b58b7564793396a>Memperluas API Kubernetes</a></li><ul><li>2.1: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>Memperluas Kubernetes API dengan Lapisan Agregasi</a></li><li>2.2: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>Custom Resource</a></li></ul><li>3: <a href=#pg-c8937cdc9df96f3328becf04f8211292>Ekstensi Komputasi, Penyimpanan, dan Jaringan</a></li><ul><li>3.1: <a href=#pg-1ac2260db9ecccbf0303a899bc27ce6d>Plugin Jaringan</a></li><li>3.2: <a href=#pg-53e1ea8892ceca307ba19e8d6a7b8d32>Plugin Perangkat</a></li></ul><li>4: <a href=#pg-3131452556176159fb269593c1a52012>Pola Operator</a></li><li>5: <a href=#pg-b26fcf43d01abc16c8110766026dafed>Service Catalog</a></li><li>6: <a href=#pg-bad3c3629d0ab48ed84b6caf66d02f89>Poseidon-Firmament - Sebuah Penjadwal Alternatif</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-5c2b36cd0ddbe006b575d4e54c63d508>1 - Memperluas Klaster Kubernetes Kamu</h1><p>Kubernetes sangat mudah dikonfigurasi dan diperluas. Sehingga,
jarang membutuhkan <em>fork</em> atau menambahkan <em>patch</em> ke kode proyek Kubernetes.</p><p>Panduan ini menjelaskan pilihan untuk menyesuaikan klaster Kubernetes.
Dokumen ini ditujukan kepada <a class=glossary-tooltip title='Seseorang yang mengonfigurasi, mengontrol, dan memonitor klaster.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-cluster-operator' target=_blank aria-label='operator klaster'>operator klaster</a> yang ingin
memahami bagaimana menyesuaikan klaster Kubernetes dengan kebutuhan lingkungan kerja mereka.</p><p>Developer yang prospektif <a class=glossary-tooltip title='Seseorang yang menyesuaikan platform Kubernetes agar sesuai dengan kebutuhan proyek mereka.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-platform-developer' target=_blank aria-label='Developer Platform'>Developer Platform</a> atau <a class=glossary-tooltip title='Seseorang yang menyumbangkan kode, dokumentasi, atau waktu mereka untuk membantu proyek atau komunitas Kubernetes.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-contributor' target=_blank aria-label=Kontributor>Kontributor</a> Proyek Kubernetes juga mendapatkan manfaat dari
dokumen ini sebagai pengantar apa saja poin-poin dan pola-pola perluasan yang ada, untung-rugi, dan batasan-batasannya.</p><h2 id=ikhtisar>Ikhtisar</h2><p>Pendekatan-pendekatan kostumisasi secara umum dapat dibagi atas <em>konfigurasi</em>, yang hanya melibatkan perubahan <em>flag</em>, konfigurasi berkas lokal, atau objek-objek sumber daya API; dan <em>perluasan</em>, yang melibatkan berjalannya program atau layanan tambahan. Dokumen ini sebagian besar membahas tentang perluasan.</p><h2 id=konfigurasi>Konfigurasi</h2><p><em>Flag-flag</em> dan <em>berkas-berkas konfigurasi</em> didokumentasikan di bagian Referensi dari dokumentasi daring, didalam setiap <em>binary</em>:</p><ul><li><a href=/docs/admin/kubelet/>kubelet</a></li><li><a href=/docs/admin/kube-apiserver/>kube-apiserver</a></li><li><a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a></li><li><a href=/docs/admin/kube-scheduler/>kube-scheduler</a>.</li></ul><p><em>Flag-flag</em> dan berkas-berkas konfigurasi mungkin tidak selalu dapat diubah pada layanan Kubernetes yang <em>hosted</em> atau pada distribusi dengan instalasi yang dikelola. Ketika mereka dapat diubah, mereka biasanya hanya dapat diubah oleh Administrator Klaster. Dan juga, mereka dapat sewaktu-waktu diubah dalam versi Kubernetes di masa depan, dan menyetel mereka mungkin memerlukan proses pengulangan kembali. Oleh karena itu, mereka harus digunakan hanya ketika tidak ada pilihan lain.</p><p><em>API kebijakan bawaan</em>, seperti <a href=/id/docs/concepts/policy/resource-quotas/>ResourceQuota</a>, <a href=/id/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>, <a href=/id/docs/concepts/services-networking/network-policies/>NetworkPolicy</a> dan Role-based Access Control (<a href=/id/docs/reference/access-authn-authz/rbac/>RBAC</a>), adalah API bawaan Kubernetes. API biasanya digunakan oleh layanan Kubernetes yang <em>hosted</em> dan diatur oleh instalasi Kubernetes. Mereka bersifat deklaratif dan menggunakan konvensi yang sama dengan sumber daya Kubernetes lainnya seperti pod-pod, jadi konfigurasi klaster baru dapat diulang-ulang dan dapat diatur dengan cara yang sama dengan aplikasi. Dan, ketika mereka stabil, mereka mendapatkan keuntungan dari <a href=/docs/reference/deprecation-policy/>kebijakan pendukung yang jelas</a> seperti API Kubernetes lainnya. Oleh karena itu, mereka lebih disukai daripada <em>berkas konfigurasi</em> dan <em>flag-flag</em> saat mereka cocok dengan situasi yang dibutuhkan.</p><h2 id=perluasan>Perluasan</h2><p>Perluasan adalah komponen perangkat lunak yang memperluas dan berintegrasi secara mendalam dengan Kubernetes.
Mereka mengadaptasi Kubernetes untuk mendukung perangkat keras tipe baru dan jenis baru.</p><p>Kebanyakan administrator klaster akan menggunakan instansi Kubernetes yang didistribusikan atau yang <em>hosted</em>.
Sebagai hasilnya, kebanyakan pengguna Kubernetes perlu menginstal perluasan dan lebih sedikit yang perlu untuk membuat perluasan-perluasan yang baru.</p><h2 id=pola-pola-perluasan>Pola-pola Perluasan</h2><p>Kubernetes didesain untuk dapat diotomasi dengan menulis program-program klien. Program apapun yang membaca dan/atau menulis ke API Kubernetes dapat menyediakan otomasi yang berguna.</p><p><em>Otomasi</em> dapat berjalan di dalam klaster atau di luar klaster. Dengan mengikuti panduan
di dalam dokumen ini, kamu dapat menulis otomasi yang sangat tersedia dan kuat.
Otomasi pada umumnya dapat bekerja dengan berbagai macam klaster Kubernetes, termasuk
klaster yang <em>hosted</em> dan instalasi yang dikelola.</p><p>Ada pola spesifik untuk menulis program klien yang bekerja dengan baik bersama Kubernetes yang disebut pola <em>Controller</em>. <em>Controller-controller</em> biasanya membaca kolom <code>.spec</code> milik sebuah objek, kemungkinan melakukan sesuatu, dan kemudian memperbarui objek milik <code>.status</code>.</p><p><em>Controller</em> adalah klien dari Kubernetes. Ketika Kubernetes adalah klien dan memanggil layanan
terpisah, hal tersebut disebut <em>Webhook</em>. Layanan terpisah tersebut disebut sebuah <em>Webhook Backend</em>. Seperti <em>Controller-controller</em>, <em>Webhook-webhook</em> memang menambah sebuah titik untuk terjadinya kegagalan.</p><p>Di dalam model <em>Webhook</em>, Kubernetes membuat sebuah <em>network request</em> kepada sebuah layanan terpisah.</p><p>Di dalam model <em>Binary Plugin</em>, Kubernetes mengeksekusi sebuah program.
<em>Binary Plugin</em> digunakan oleh kubelet (misalnya <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md><em>Plugin Flex Volume</em></a>
dan oleh <a href=/docs/concepts/cluster-administration/network-plugins/><em>Plugin</em> Jaringan</a>) dan oleh kubectl.</p><p>Berikut ini adalah diagram yang menunjukkan bagaimana titik-titik perluasan berinteraksi dengan <em>control plane</em> Kubernetes.</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vQBRWyXLVUlQPlp7BvxvV9S1mxyXSM6rAc_cbLANvKlu6kCCf-kGTporTMIeG5GZtUdxXz1xowN7RmL/pub?w=960&h=720"><h2 id=titik-titik-perluasan>Titik-titik Perluasan</h2><p>Diagram berikut menunjukkan titik-titik perluasan di sebuah Kubernetes.</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vSH5ZWUO2jH9f34YHenhnCd14baEb4vT-pzfxeFC7NzdNqRDgdz4DDAVqArtH4onOGqh0bhwMX0zGBb/pub?w=425&h=809"><ol><li>Pengguna biasanya berinteraksi dengan API Kubernetes menggunakan <code>kubectl</code>. <a href=/docs/tasks/extend-kubectl/kubectl-plugins/><em>Plugin-plugin</em> Kubectl</a> memperluas <em>binari</em> kubectl. Mereka hanya memengaruhi lingkungan lokal pengguna, dan tidak dapat memaksakan kebijakan yang menyeluruh di seluruh situs.</li><li>apiserver menangani semua permintaan. Beberapa tipe titik perluasan di apiserver memperbolehkan otentikasi permintaan, atau memblokir mereka berdasarkan konten mereka, menyunting konten, dan menangani penghapusan. Hal ini dideskripsikan di bagian <a href=/docs/concepts/overview/extending#perluasan-perluasan-akses-api>Perluasan Akses API</a></li><li>apiserver melayani berbagai macam sumber daya, <em>tipe-tipe sumber daya bawaan</em>, seperti <code>pod</code>, didefinisikan oleh proyek kubernetes dan tidak dapat diubah. kamu juga dapat menambahkan sumber daya yang kamu definisikan sendiri, atau yang proyek lain definisikan, disebut <em>Custom Resources</em>, seperti dijelaskan di bagian <a href=/docs/concepts/overview/extending#tipe-tipe-yang-ditentukan-pengguna>Sumber Daya <em>Custom</em></a>. Sumber daya <em>Custom</em> sering digunakan dengan Perluasan Akses API.</li><li>Penjadwal Kubernetes memutuskan ke Node mana Pod akan ditempatkan. Ada beberapa cara untuk memperluas penjadwalan. Hal ini dibahas pada bagian <a href=/docs/concepts/overview/extending#perluasan-perluasan-penjadwal>Perluasan-perluasan Penjadwal</a>.</li><li>Sebagian besar perilaku Kubernetes diimplementasi oleh program yang disebut <em>Controller-controller</em> yang merupakan klien dari API-Server. <em>Controller-controller</em> sering digunakan bersama dengan Sumber Daya <em>Custom</em>.</li><li>Kubelet berjalan di server, dan membantu Pod-pod terlihat seperti server virtual dengan IP mereka sendiri di jaringan klaster. <a href=/docs/concepts/overview/extending#plugin-plugin-jaringan><em>Plugin</em> Jaringan</a> memungkinkan adanya perbedaan implementasi pada jaringan Pod.</li><li>Kubelet juga melakukan penambatan dan pelepasan tambatan volume untuk kontainer. Tipe-tipe penyimpanan baru dapat didukung via <a href=/docs/concepts/overview/extending#plugin-plugin-penyimpanan><em>Plugin</em> Penyimpanan</a>.</li></ol><p>Jika kamu tidak yakin untuk memulai dari mana, diagram alir di bawah ini dapat membantu kamu. Ingat lah bahwa beberapa solusi mungkin melibatkan beberapa tipe perluasan.</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vRWXNNIVWFDqzDY0CsKZJY3AR8sDeFDXItdc5awYxVH8s0OLherMlEPVUpxPIB1CSUu7GPk7B2fEnzM/pub?w=1440&h=1080"><h2 id=perluasan-api>Perluasan API</h2><h3 id=tipe-tipe-yang-ditentukan-pengguna>Tipe-tipe yang Ditentukan Pengguna</h3><p>Pertimbangkan untuk menambahkan Sumber Daya <em>Custom</em> ke Kubernetes jika kamu ingin mendefinisikan pengontrol baru, objek konfigurasi aplikasi atau API deklaratif lainnya, dan untuk mengelolanya menggunakan alat Kubernetes, seperti <code>kubectl</code>.</p><p>Jangan menggunakan Sumber Daya <em>Custom</em> sebagai penyimpanan data untuk aplikasi, pengguna, atau untuk memonitor data.</p><p>Untuk lebih jelasnya tentang Sumber Daya <em>Custom</em>, lihat <a href=/docs/concepts/api-extension/custom-resources/>Panduan Konsep Sumber Daya <em>Custom</em></a>.</p><h3 id=menggabungkan-api-baru-dengan-otomasi>Menggabungkan API Baru dengan Otomasi</h3><p>Kombinasi antara sebuah API sumber daya <em>custom</em> dan <em>loop</em> kontrol disebut <a href=/id/docs/concepts/extend-kubernetes/operator/>Pola Operator</a>. Pola Operator digunakan untuk mengelola aplikasi yang spesifik dan biasanya <em>stateful</em>. API-API <em>custom</em> dan <em>loop</em> kontrol ini dapat digunakan untuk mengatur sumber daya lainnya, seperti penyimpanan dan kebijakan-kebijakan.</p><h3 id=mengubah-sumber-daya-bawaan>Mengubah Sumber Daya Bawaan</h3><p>Ketika kamu memperluas API Kubernetes dengan menambahkan sumber daya <em>custom</em>, sumber daya yang ditambahkan akan selalu masuk ke Grup API baru. Kamu tidak dapat mengganti atau mengubah Grup API yang sudah ada. Menambah sebuah API tidak secara langsung membuat kamu memengaruhi perilaku API yang sudah ada (seperti Pod), tetapi Perluasan Akses API dapat memengaruhinya secara langsung.</p><h3 id=perluasan-perluasan-akses-api>Perluasan-Perluasan Akses API</h3><p>Ketika sebuah permintaan sampai ke Server API Kubernetes, permintaan tersebut diotentikasi terlebih dahulu, kemudian diotorisasi, kemudian diarahkan ke berbagai jenis <em>Admission Control</em>. Lihat dokumentasi <a href=/docs/reference/access-authn-authz/controlling-access/>Mengatur Akses ke API Kubernetes</a> untuk lebih jelasnya tentang alur ini.</p><p>Setiap langkah berikut menawarkan titik-titik perluasan.</p><p>Kubernetes memiliki beberapa metode otentikasi bawaan yang didukungnya. Metode ini bisa berada di belakang proksi yang mengotentikasi, dan metode ini dapat mengirim sebuah token dari <em>header</em> Otorisasi ke layanan terpisah untuk verifikasi (sebuah <em>webhook</em>). Semua metode ini tercakup dalam <a href=/docs/reference/access-authn-authz/authentication/>Dokumentasi Otentikasi</a>.</p><h3 id=otentikasi>Otentikasi</h3><p><a href=/docs/reference/access-authn-authz/authentication/>Otentikasi</a> memetakan <em>header</em> atau sertifikat dalam semua permintaan ke <em>username</em> untuk klien yang mebuat permintaan.</p><p>Kubernetes menyediakan beberapa metode otentikasi bawaan, dan sebuah metode <a href=/docs/reference/access-authn-authz/authentication/#webhook-token-authentication><em>Webhook</em> Otentikasi</a> jika metode bawaan tersebut tidak mencukupi kebutuhan kamu.</p><h3 id=otorisasi>Otorisasi</h3><p><a href=/docs/reference/access-authn-authz/webhook/>Otorisasi</a> menentukan apakah pengguna tertentu dapat membaca, menulis, dan melakukan operasi lainnya terhadap sumber daya API. Hal ini hanya bekerja pada tingkat sumber daya secara keseluruhan -- tidak membeda-bedakan berdasarkan field objek sembarang. Jika pilihan otorisasi bawaan tidak mencukupi kebutuhan kamu, <a href=/docs/reference/access-authn-authz/webhook/><em>Webhook</em> Otorisasi</a> memungkinkan pemanggilan kode yang disediakan pengguna untuk membuat keputusan otorisasi.</p><h3 id=kontrol-admisi-dinamis>Kontrol Admisi Dinamis</h3><p>Setalah permintaan diotorisasi, jika ini adalah operasi penulisan, permintaan ini akan melalui langkah <a href=/docs/reference/access-authn-authz/admission-controllers/>Kontrol Admisi</a>. Sebagai tambahan untuk step bawaan, ada beberapa perluasan:</p><ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook><em>Webhook</em> Kebijakan <em>Image</em></a> membatasi <em>image</em> mana saja yang dapat berjalan di kontainer.</li><li>Untuk membuat keputusan kontrol admisi sembarang, <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks><em>Webhook</em> Admisi</a> umum dapat digunakan. <em>Webhook</em> Admisi dapat menolak pembuatan atau pembaruan.</li></ul><h2 id=perluasan-infrastruktur>Perluasan Infrastruktur</h2><h3 id=plugin-plugin-penyimpanan><em>Plugin-plugin</em> Penyimpanan</h3><p><a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md>Flex Volume</a> memungkinkan pengguna untuk memasang tipe-tipe volume tanpa dukungan bawaan dengan cara membiarkan Kubelet memanggil sebuah <em>Plugin Binary</em> untuk menambatkan volume.</p><h3 id=plugin-perangkat><em>Plugin</em> Perangkat</h3><p><em>Plugin</em> perangkat memungkinkan sebuah node untuk menemukan sumber daya Node baru (sebagai tambahan dari bawaannya seperti CPU dan memori) melalui sebuah <a href=/docs/concepts/cluster-administration/device-plugins/><em>Plugin</em> Perangkat</a>.</p><h3 id=plugin-plugin-jaringan><em>Plugin-plugin</em> Jaringan</h3><p>Struktur-struktur jaringan yang berbeda dapat didukung melalui <a href=/docs/admin/network-plugins/><em>Plugin</em> Jaringan</a> pada tingkat Node.</p><h3 id=perluasan-perluasan-penjadwal>Perluasan-perluasan Penjadwal</h3><p>Penjadwal adalah jenis pengatur spesial yang mengawasi Pod, dan menempatkan Pod ke Node. Penjadwal bawaan dapat digantikan seluruhnya, sementara terus menggunakan komponen Kubernetes lainnya, atau <a href=/docs/tasks/administer-cluster/configure-multiple-schedulers/>penjadwal ganda</a> dapat berjalan dalam waktu yang bersamaan.</p><p>Ini adalah usaha yang signifikan, dan hampir semua pengguna Kubernetes merasa mereka tidak perlu memodifikasi penjadwal tersebut.</p><p>Penjadwal juga mendukung <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md><em>webhook</em></a> yang memperbolehkan sebuah <em>webhook backend</em> (perluasan penjadwal) untuk menyaring dan memprioritaskan Node yang terpilih untuk sebuah Pod.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang <a href=/docs/concepts/api-extension/custom-resources/>Sumber Daya <em>Custom</em></a></li><li>Pelajari tentang <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>Kontrol Admisi Dinamis</a></li><li>Pelajari lebih lanjut tentang perluasan Infrastruktur<ul><li><a href=/docs/concepts/cluster-administration/network-plugins/><em>Plugin</em> Jaringan</a></li><li><a href=/docs/concepts/cluster-administration/device-plugins/><em>Plugin</em> Perangkat</a></li></ul></li><li>Pelajari tentang <a href=/docs/tasks/extend-kubectl/kubectl-plugins/><em>Plugin</em> kubectl</a></li><li>Pelajari tentang <a href=/id/docs/concepts/extend-kubernetes/operator/>Pola Operator</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0af41d3bd7c785621b58b7564793396a>2 - Memperluas API Kubernetes</h1></div><div class=td-content><h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>2.1 - Memperluas Kubernetes API dengan Lapisan Agregasi</h1><p>Lapisan agregasi memungkinkan Kubernetes untuk diperluas dengan API tambahan, selain dari yang ditawarkan oleh API inti Kubernetes.</p><h2 id=ikhtisar>Ikhtisar</h2><p>Lapisan agregasi memungkinkan instalasi tambahan beragam API <em>Kubernetes-style</em> di kluster kamu. Tambahan-tambahan ini dapat berupa solusi-solusi yang sudah dibangun (<em>prebuilt</em>) oleh pihak ke-3 yang sudah ada, seperti <a href=https://github.com/kubernetes-incubator/service-catalog/blob/master/README.md><em>service-catalog</em></a>, atau API yang dibuat oleh pengguna seperti <a href=https://github.com/kubernetes-incubator/apiserver-builder/blob/master/README.md>apiserver-builder</a>, yang dapat membantu kamu memulainya.</p><p>Lapisan agregasi berjalan di dalam proses bersama dengan kube-apiserver. Hingga sebuah sumber daya ekstensi terdaftar, lapisan agregasi tidak akan melakukan apapun. Untuk mendaftarkan sebuah API, pengguna harus menambahkan sebuah objek <em>APIService</em>, yang "mengklaim" jalur URL di API Kubernetes. Pada titik tersebut, lapisan agregasi akan mem-<em>proxy</em> apapun yang dikirim ke jalur API tersebut (misalnya /apis/myextension.mycompany.io/v1/…) ke <em>APIService</em> yang terdaftar.</p><p>Biasanya, <em>APIService</em> akan diimplementasikan oleh sebuah ekstensi-apiserver di dalam sebuah Pod yang berjalan di kluster. Ekstensi-apiserver ini biasanya perlu di pasangkan dengan satu atau lebih <em>controller</em> apabila manajemen aktif dari sumber daya tambahan diperlukan. Sebagai hasilnya, apiserver-builder sebenarnya akan memberikan kerangka untuk keduanya. Sebagai contoh lain, ketika service-catalog diinstal, ia menyediakan ekstensi-apiserver dan <em>controller</em> untuk layanan-layanan yang disediakannya.</p><p>Ekstensi-apiserver harus memiliki latensi koneksi yang rendah dari dan ke kube-apiserver.
Secara Khusus, permintaan pencarian diperlukan untuk bolak-balik dari kube-apiserver dalam 5 detik atau kurang.
Jika implementasi kamu tidak dapat menyanggupinya, kamu harus mempertimbangkan cara mengubahnya. Untuk sekarang, menyetel
<em>feature-gate</em> <code>EnableAggregatedDiscoveryTimeout=false</code> di kube-apiserver
akan menonaktifkan batasan waktu tersebut. Fitur ini akan dihapus dalam rilis mendatang.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Untuk mengaktifkan agregator di lingkungan kamu, aktifkan<a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/>konfigurasi lapisan agregasi</a>.</li><li>Kemudian, <a href=/docs/tasks/access-kubernetes-api/setup-extension-api-server/>siapkan ekstensi api-server</a> untuk bekerja dengan lapisan agregasi.</li><li>Selain itu, pelajari caranya <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>mengembangkan API Kubernetes menggunakan <em>Custom Resource Definition</em></a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-342388440304e19ce30c0f8ada1c77ce>2.2 - Custom Resource</h1><p><em>Custom Resource</em> adalah ekstensi dari Kubernetes API. Laman ini mendiskusikan kapan kamu melakukan penambahan sebuah <em>Custom Resource</em> ke klaster Kubernetes dan kapan kamu menggunakan sebuah layanan mandiri. Laman ini mendeskripsikan dua metode untuk menambahkan <em>Custom Resource</em> dan bagaimana cara memilihnya.</p><h2 id=custom-resource><em>Custom Resource</em></h2><p>Sebuah sumber daya adalah sebuah <em>endpoint</em> pada <a href=/docs/reference/using-api/api-overview/>Kubernetes API</a> yang menyimpan sebuah koleksi <a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects/>objek API</a> dari sebuah jenis tertentu. Sebagai contoh, sumber daya bawaan Pod mengandung sebuah koleksi objek-objek Pod.</p><p>Sebuah <em>Custom Resource</em> adalah sebuah ekstensi dari Kubernetes API yang tidak seharusnya tersedia pada pemasangan default Kubernetes. Namun, banyak fungsi-fungsi inti Kubernetes yang sekarang dibangun menggunakan <em>Custom Resource</em>, membuat Kubernetes lebih modular.</p><p><em>Custom Resource</em> bisa muncul dan menghilang dalam sebuah klaster yang berjalan melalui registrasi dinamis (<em>dynamic registration</em>), dan admin-admin klaster bisa memperbaharui <em>Custom Resource</em> secara independen dari klaster itu sendiri. Ketika sebuah <em>Custom Resource</em>
dipasang, pengguna dapat membuat dan mengakses objek-objek <em>Custom Resource</em> menggunakan <a href=/docs/user-guide/kubectl-overview/>kubectl</a>, seperti yang mereka lakukan untuk sumber daya bawaan seperti Pod.</p><h2 id=controller-khusus><em>Controller</em> Khusus</h2><p>Dengan sendirinya, <em>Custom Resource</em> memungkinkan kamu untuk menyimpan dan mengambil data terstruktur. Ketika kamu menggabungkan sebuah <em>Custom Resource</em> dengan <em>controller</em> khusus, <em>Custom Resource</em> akan memberikan sebuah API deklaratif yang sebenarnya.</p><p>Sebuah <a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects/#memahami-konsep-objek-objek-yang-ada-pada-kubernetes>API deklaratif</a>
memungkinkan kamu untuk mendeklarasikan atau menspesifikasikan keadaan dari sumber daya kamu dan mencoba untuk menjaga agar keadaan saat itu tersinkronisasi dengan keadaan yang diinginkan. <em>Controller</em> menginterpretasikan data terstruktur sebagai sebuah rekaman dari keadaan yang diinginkan pengguna, dan secara kontinu menjaga keadaan ini.</p><p>Kamu bisa men-<em>deploy</em> dan memperbaharui sebuah <em>controller</em> khusus pada sebuah klaster yang berjalan, secara independen dari siklus hidup klaster itu sendiri. <em>Controller</em> khusus dapat berfungsi dengan sumber daya jenis apapun, tetapi mereka sangat efektif ketika dikombinasikan dengan <em>Custom Resource</em>. <a href=https://coreos.com/blog/introducing-operators.html><em>Operator pattern</em></a> mengkombinasikan <em>Custom Resource</em> dan <em>controller</em> khusus. Kamu bisa menggunakan <em>controller</em> khusus untuk menyandi pengetahuan domain untuk aplikasi spesifik menjadi sebuah ekstensi dari Kubernetes API.</p><h2 id=haruskah-custom-resource-ditambahkan-ke-dalam-klaster-kubernetes-saya>Haruskah <em>Custom Resource</em> ditambahkan ke dalam klaster Kubernetes saya?</h2><p>Ketika membuat sebuah API baru, pikirkan apakah kamu ingin <a href=/docs/concepts/api-extension/apiserver-aggregation/>mengagregasikan API kamu dengan API klaster Kubernetes</a> atau membiarkan API kamu berdiri sendiri.</p><table><thead><tr><th>Pilih agregasi API jika:</th><th>Pilih sebuah API yang berdiri sendiri jika:</th></tr></thead><tbody><tr><td>API kamu bersifat <a href=#api-deklaratif>Deklaratif</a>.</td><td>API kamu tidak cocok dengan model <a href=#api-deklaratif>Deklaratif</a>.</td></tr><tr><td>Kamu mau tipe baru yang dapat dibaca dan ditulis dengan <code>kubectl</code>.</td><td>Dukungan <code>kubectl</code> tidak diperlukan</td></tr><tr><td>Kamu mau melihat tipe baru pada sebuah Kubernetes UI, seperti dasbor, bersama dengan tipe-tipe bawaan.</td><td>Dukungan Kubernetes UI tidak diperlukan.</td></tr><tr><td>Kamu mengembangkan sebuah API baru.</td><td>Kamu memiliki sebuah program yang melayani API kamu dan dapat berkerja dengan baik.</td></tr><tr><td>Kamu bersedia menerima pembatasan format yang Kubernetes terapkan pada jalur sumber daya API (Lihat <a href=/id/docs/concepts/overview/kubernetes-api/>Ikhtisar API</a>.)</td><td>Kamu perlu memiliki jalur REST spesifik agar menjadi cocok dengan REST API yang telah didefinisikan.</td></tr><tr><td>Sumber daya kamu secara alami mencakup hingga sebuah klaster atau sebuah <em>namespace</em> dari sebuah klaster.</td><td>Sumber daya yang mencakup klaster atau <em>namespace</em> adalah sebuah ketidakcocokan; kamu perlu mengendalikan jalur sumber daya spesifik.</td></tr><tr><td>Kamu ingin menggunakan kembali <a href=#fitur-umum>dukungan fitur Kubernetes API</a>.</td><td>Kamu tidak membutuhkan fitur tersebut.</td></tr></tbody></table><h3 id=api-deklaratif>API Deklaratif</h3><p>Dalam sebuah API Deklaratif, biasanya:</p><ul><li>API kamu terdiri dari sejumlah kecil dari objek yang berukuran relatif kecil (sumber daya).</li><li>Objek-objek mendefinisikan pengaturan dari aplikasi atau infrastruktur.</li><li>Objek-objek relatif tidak sering diperbaharui.</li><li>Manusia sering diperlukan untuk membaca dan menulis objek-objek tersebut.</li><li>Operasi utama terhadap objek bersifat CRUD (<em>creating, reading, updating,</em> dan <em>deleting</em>).</li><li>Transaksi antar objek tidak dibutuhkan; API merepresentasikan sebuah keadaan yang diinginkan, bukan keadaan yang eksak.</li></ul><p>API imperatif bersifat tidak deklaratif.
Tanda-tanda apabila API kamu tidak deklaratif termasuk:</p><ul><li>klien berkata "lakukan ini", dan kemudian mendapat sebuah respon serempak ketika selesai.</li><li>klien berkata "lakukan ini", dan kemudian mendapat sebuah ID operasi kembali, dan harus melakukan sebuah cek terhadap objek <em>Operation</em> terpisah untuk menentukan selesainya sebuah permintaan.</li><li>Kamu berbicara tentang <em>Remote Procedure Call</em> (RPC).</li><li>Menyimpan secara langsung sejumlah data (mis. > beberapa kB per objek, atau >1000-an objek).</li><li>Membutuhkan akses dengan <em>bandwidth</em> tinggi (10-an permintaan per detik dapat ditopang).</li><li>Menyimpan data pengguna (seperti gambar, PII, dll) atau data berskala besar yang diproses oleh aplikasi.</li><li>Operasi-operasi natural terhadap objek yang tidak bersifat CRUD.</li><li>API yang tidak mudah dimodelkan dengan objek.</li><li>Kamu memilih untuk merepresentasikan operasi tertunda dengan sebuah ID operasi atau sebuah objek operasi.</li></ul><h2 id=apakah-saya-harus-menggunakan-sebuah-configmap-atau-sebuah-custom-resource>Apakah saya harus menggunakan sebuah ConfigMap atau sebuah <em>Custom Resource</em>?</h2><p>Gunakan ConfigMap jika salah satu hal berikut berlaku:</p><ul><li>Terdapat sebuah format berkas pengaturan yang sudah ada, yang terdokumentasi dengan baik seperti sebuah <code>mysql.cnf</code> atau <code>pom.xml</code>.</li><li>Kamu ingin menaruh seluruh berkas pengaturan kedalam sebuah <em>key</em> dari sebuah ConfigMap.</li><li>Kegunaan utama dari berkas pengaturan adalah untuk dikonsumsi sebuah program yang berjalan di dalam sebuah Pod di dalam klaster kamu untuk mengatur dirinya sendiri.</li><li>Konsumen dari berkas lebih suka untuk mengkonsumsi lewat berkas dalam sebuah Pod atau variabel lingkungan dalam sebuah Pod, dibandingkan melalui Kubernetes API.</li><li>Kamu ingin melakukan pembaharuan bergulir lewat Deployment, dll, ketika berkas diperbaharui.</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Gunakan sebuah <a href=/id/docs/concepts/configuration/secret/>Secret</a> untuk data sensitif, yang serupa dengan ConfigMap tetapi lebih aman.</div><p>Gunakan sebuah <em>Custom Resource</em> (CRD atau <em>Aggregated API</em>) jika kebanyakan dari hal berikut berlaku:</p><ul><li>Kamu ingin menggunakan pustaka klien Kubernetes dan CLI untuk membuat dan memperbaharui sumber daya baru.</li><li>Kamu ingin dukungan tingkat tinggi dari kubectl (sebagai contoh: <code>kubectl get my-object object-name</code>).</li><li>Kamu ingin membangun sebuah otomasi baru yang mengawasi pembaharuan terhadap objek baru, dan kemudian melakukan CRUD terhadap objek lainnya, atau sebaliknya.</li><li>Kamu ingin menulis otomasi yang menangani pembaharuan untuk objek.</li><li>Kamu ingin menggunakan kesepakatan API Kubernetes seperti <code>.spec</code>, <code>.status</code>, dan <code>.metadata</code>.</li><li>Kamu ingin objek tersebut untuk menjadi sebuah abstraksi terhadap sebuah kumpulan dari sumber daya terkontrol, atau peringkasan dari sumber daya lainnya.</li></ul><h2 id=menambahkan-custom-resource>Menambahkan <em>Custom Resource</em></h2><p>Kubernetes menyediakan dua cara untuk menambahkan sumber daya ke klaster kamu:</p><ul><li>CRD cukup sederhana dan bisa diciptakan tanpa pemrograman apapun.</li><li><a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Agregasi API</a> membutuhkan pemrograman, tetapi memungkinkan kendali lebih terhadap perilaku API seperti bagaimana data disimpan dan perubahan antar versi API.</li></ul><p>Kubernetes menyediakan kedua opsi tersebut untuk memenuhi kebutuhan pengguna berbeda, jadi tidak ada kemudahan penggunaan atau fleksibilitas yang dikompromikan.</p><p><em>Aggregated API</em> adalah bawahan dari APIServer yang duduk dibelakang API server utama, yang bertindak sebagai sebuah <em>proxy</em>. Pengaturan ini disebut <a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Agregasi API</a> (AA). Untuk pengguna, yang terlihat adalah Kubernetes API yang diperluas.</p><p>CRD memungkinkan pengguna untuk membuat tipe baru sumber daya tanpa menambahkan APIserver lain. Kamu tidak perlu mengerti Agregasi API untuk menggunakan CRD.</p><p>Terlepas dari bagaimana cara mereka dipasang, sumber daya baru disebut sebagai <em>Custom Resource</em> untuk memisahkan mereka dari sumber daya bawaan Kubernetes (seperti Pod).</p><h2 id=customresourcedefinition>CustomResourceDefinition</h2><p>Sumber daya API <a href=/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a> memungkinkan kamu untuk medefinisikan <em>Custom Resource</em>. Mendefinisikan sebuah objek CRD akan membuat sebuah <em>Custom Resource</em> dengan sebuah nama dan skema yang kamu spesifikasikan. Kubernetes API melayani dan menangani penyimpanan dari <em>Custom Resource</em> kamu.</p><p>Ini membebaskan kamu dari menulis server API kamu sendiri untuk menangani <em>Custom Resource</em>, tetapi sifat dasar dari implementasi menyebabkan kamu memiliki fleksibilitas yang berkurang dibanding <a href=#agregasi-server-api>agregasi server API</a>).</p><p>Lihat <a href=https://github.com/kubernetes/sample-controller>contoh <em>controller</em> khusus</a> sebagai sebuah contoh dari bagaimana cara untuk mendaftarkan sebuah <em>Custom Resource</em>, bekerja dengan instans dari tipe baru sumber daya kamu, dan menggunakan sebuah <em>controller</em> untuk menangani <em>event</em>.</p><h2 id=agregasi-server-api>Agregasi server API</h2><p>Biasanya, tiap sumber daya di API Kubernetes membutuhkan kode yang menangani permintaan REST dan mengatur peyimpanan tetap dari objek-objek. Server Kubernetes API utama menangani sumber daya bawaan seperti Pod dan Service, dan juga menangani <em>Custom Resource</em> dalam sebuah cara yang umum melalui <a href=#customresourcedefinition>CRD</a>.</p><p><a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Lapisan agregasi</a> memungkinkan kamu untuk menyediakan implementasi khusus untuk <em>Custom Resource</em> dengan menulis dan men-<em>deploy</em> API server kamu yang berdiri sendiri. API server utama menlimpahkan permintaan kepada kamu untuk <em>Custom Resource</em> yang kamu tangani, membuat mereka tersedia untuk semua kliennya.</p><h2 id=memilih-sebuah-metode-untuk-menambahkan-custom-resource>Memilih sebuah metode untuk menambahkan <em>Custom Resource</em></h2><p>CRD lebih mudah digunakan. <em>Aggregated API</em> lebih fleksibel. Pilih metode yang paling baik untuk kebutuhan kamu.</p><p>Biasanya, CRD cocok jika:</p><ul><li>Kamu memiliki <em>field</em> yang banyak</li><li>Kamu menggunakan sumber daya dalam perusahaan kamu, atau sebagai bagian dari proyek <em>open-source</em> kecil (berlawanan dengan sebuah produk komersil)</li></ul><h3 id=membandingkan-kemudahan-penggunaan>Membandingkan kemudahan penggunaan</h3><p>CRD lebih mudah dibuat dibandingkan dengan <em>Aggregated API</em>.</p><table><thead><tr><th>CRD</th><th>Aggregated API</th></tr></thead><tbody><tr><td>Tidak membutuhkan pemrograman. Pengguna dapat memilih bahasa apapun untuk sebuah <em>controller</em> CRD.</td><td>Membutuhkan pemrograman dalam Go dan membangun <em>binary</em> dan <em>image</em>. Pengguna dapat memilih bahasa apapun untuk sebuah CRD <em>controller</em>.</td></tr><tr><td>Tidak ada servis tambahan yang dijalankan; CR ditangani oleh server API.</td><td>Sebuah servis tambahan untuk menciptakan dan dapat gagal.</td></tr><tr><td>Todal ada dukungan berjalan ketika CRD dibuat. Perbaikan <em>bug</em> apapun akan dianggap sebagai bagian dari peningkatan Kubernetes Master normal.</td><td>Mungkin dibutuhkan untuk secara berkala mengambil perbaikan <em>bug</em> dari sumber dan membangun ulang dan memeperbaharui APIserver teragregasi.</td></tr><tr><td>Tidak butuh untuk menangani banyak versi dari API kamu. Sebagai contoh: ketika kamu mengendalikan klien untuk sumber daya ini, kamu bisa meningkatkannya selaras dengan API.</td><td>Kamu perlu menangani banyak versi dari API kamu, sebagai contoh: ketika mengembangkan sebuah ekstensi untuk dibagikan kepada dunia.</td></tr></tbody></table><h3 id=fitur-lanjutan-dan-fleksibilitas>Fitur lanjutan dan fleksibilitas</h3><p><em>Aggregated API</em> menawarkan fitur API lebih lanjut dan kustomisasi dari fitur lain, sebagai contoh: lapisan penyimpanan.</p><table><thead><tr><th>Fitur</th><th>Deskripsi</th><th>CRD</th><th>Aggregated API</th></tr></thead><tbody><tr><td>Validation</td><td>Membantu pengguna-pengguna mencegah error dan memungkinkan kamu untuk mengembangkan API kamu secara independen dari klien-klien kamu. Fitur ini sangan berguna ketika ada banyak klien yang tidak semua bisa memperbaharui secara bersamaan pada waktu yang sama.</td><td>Ya. Sebagian besar validasi dapat dipesifikasikan di dalam CRD <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#validation>OpenAPI v3.0 <em>validation</em></a>. Validasi bentuk lainnya didukung dengan penambahan sebuah <a href=/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9><em>Validating Webhook</em></a>.</td><td>Ya, cek validasi secara arbitrer</td></tr><tr><td>Defaulting</td><td>Lihat diatas</td><td>Ya, baik melalui <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#defaulting>OpenAPI v3.0 <em>validation</em></a> <code>default</code> keyword (GA in 1.17), maupun melalui sebuah <a href=/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook><em>Mutating Webhook</em></a> (meskipun tidak akan dijalankan ketika membaca dari etcd untuk objek-objek lama)</td><td>Ya</td></tr><tr><td>Multi-versioning</td><td>Memungkinkan menyajikan objek yang sama lwat dua versi API. Bisa membantu memudahkan perubahan API seperti menamai ulang <em>field-field</em>. Tidak terlalu penting jika kamu mengendalikan versi-versi klien kamu.</td><td><a href=/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definition-versioning>Ya</a></td><td>Ya</td></tr><tr><td>Custom Storage</td><td>Jika kamu membutuhkan penyimpanan dengan sebuah mode performa (sebagai contoh, basis data <em>time-series</em> dibanding penyimpanan <em>key-value</em>) atau isolasi untuk keamanan (sebagau contoh, rahasia penyandian atau berkas berbeda)</td><td>Tidak</td><td>Ya</td></tr><tr><td>Custom Business Logic</td><td>Melakukan cek arbitrer atau tindakan-tindakan ketika membuat, membaca, atau memperbaharui sebuah objek</td><td>Ya, menggunakan <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks><em>Webhooks</em></a>.</td><td>Ya</td></tr><tr><td>Scale Subresource</td><td>Memungkinkan sistem-sistem seperti HorizontalPodAutoscaler dan PodDisruptionBudget untuk berinteraksi dengan sumber daya baru</td><td><a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#scale-subresource>Ya</a></td><td>Ya</td></tr><tr><td>Status Subresource</td><td><ul><li>kontrol akses yang lebih baik: pengguna menulis bagian <em>spec</em>, <em>controller</em> menulis bagian status.</li><li>Memungkinkan pembuatan objek bertambah pada mutasi data <em>Custom Resource</em> (membutuhkan <em>spec</em> terpisah dan bagian status pada sumber daya)</li></ul></td><td><a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#status-subresource>Ya</a></td><td>Ya</td></tr><tr><td>Other Subresources</td><td>Menambahkan operasi selain CRUD, seperti "logs" atau "exec".</td><td>Tidak</td><td>Ya</td></tr><tr><td>strategic-merge-patch</td><td><em>Endpoint-endpoint</em> baru yang mendukung PATCH dengan <code>Content-Type: application/strategic-merge-patch+json</code>. Berguna untuk memperbaharui objek-objek yang mungkin dapat dimodifikasi baik secara lokal, dan maupun lewat server. Untuk informasi lebih lanjut, lihat <a href=/docs/tasks/run-application/update-api-object-kubectl-patch/>"Update API Objects in Place Using kubectl patch"</a></td><td>Tidak</td><td>Ya</td></tr><tr><td>Protocol Buffers</td><td>sumber daya baru mendukung klien-klien yang ingin menggunakan <em>Protocol Buffer</em></td><td>Tidak</td><td>Ya</td></tr><tr><td>OpenAPI Schema</td><td>Apakah ada sebuah skema OpenAPI (swagger) untuk tipe yang bisa secara dinamis diambil dari server? Apakah pengguna terlindungi dari kesalahan pengejaan nama-nama <em>field</em> dengan memastikan bahwa hanya <em>field</em> yang diperbolehkan yang boleh diisi? Apakah tipe-tipe diberlakukan (dengan kata lain, jangan menaruh sebuah <code>int</code> di dalam <em>field</em> <code>string</code>?)</td><td>Ya, berdasarkan pada skema <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#validation>OpenAPI v3.0 validation</a> (GA pada 1.16)</td><td>Ya</td></tr></tbody></table><h3 id=fitur-umum>Fitur Umum</h3><p>Ketika kamu membuat sebuah <em>Custom Resource</em>, baik melalui sebuah CRD atau sebuah AA, kamu mendapat banyak fitur untuk API kamu, dibandingkan dengan mengimplementasikannya diluar platform Kubernetes.</p><table><thead><tr><th>Fitur</th><th>Apa yang dilakukannya</th></tr></thead><tbody><tr><td>CRUD</td><td><em>Endpoint-endpoint</em> baru yang mendukung operasi dasar melalui HTTP dan <code>kubectl</code></td></tr><tr><td>Watch</td><td><em>Endpoint-endpoint</em> baru yang mendukung operasi Kubernetes Watch melalui HTTP</td></tr><tr><td>Discovery</td><td>Klien seperti kubectl dan dasbor yang secara otomatis menawarkan operasi <em>list</em>, <em>display</em>, dan pembaharuan <em>field</em> pada sumber daya kamu.</td></tr><tr><td>json-patch</td><td><em>Endpoint-endpoint</em> baru yang mendukung PATCH dengan <code>Content-Type: application/json-patch+json</code></td></tr><tr><td>merge-patch</td><td><em>Endpoint-endpoint</em> baru yang mendukung PATCH dengan <code>Content-Type: application/merge-patch+json</code></td></tr><tr><td>HTTPS</td><td><em>Endpoint-endpoint</em> menggunakan HTTPS</td></tr><tr><td>Built-in Authentication</td><td>Akses ke ekstensi yang menggunakan <em>apiserver</em> inti (lapisan agregasi) untuk otentikasi</td></tr><tr><td>Built-in Authorization</td><td>Akses ke ekstensi dapat menggunakan ulang otorisasi yang digunakan oleh <em>apiserver</em> inti (mis. RBAC)</td></tr><tr><td>Finalizers</td><td>Penghapusan blok dari ekstensi sumber daya hingga pembersihan eksternal terjadi.</td></tr><tr><td>Admission Webhooks</td><td>Menentukan nilai default dan memvalidasi ekstensi sumber daya saat terjadi operasi <em>create/update/delete</em> apapun.</td></tr><tr><td>UI/CLI Display</td><td>Kubectl, dasbor dapat menampilkan ekstensi sumber daya</td></tr><tr><td>Unset vs Empty</td><td>Klien-klien dapat membedakan <em>field-field</em> yang tidak diisi dari <em>field-field</em> yang memiliki nilai nol.</td></tr><tr><td>Client Libraries Generation</td><td>Kubernetes menyediakan pustaka klien dasar, juga alat-alat untuk membuat pustaka klien dengan tipe spesifik.</td></tr><tr><td>Labels and annotations</td><td>Metadata umum lintas objek yang cara untuk memperbaharui sumber daya inti dan <em>Custom Resource</em>-nya diketahui oleh alat-alat.</td></tr></tbody></table><h2 id=persiapan-pemasangan-sebuah-custom-resource>Persiapan pemasangan sebuah <em>Custom Resource</em></h2><p>Ada beberapa poin yang harus diperhatikan sebelum menambahkan sebuah <em>Custom Resource</em> ke klaster kamu.</p><h3 id=kode-pihak-ketiga-dan-poin-kegagalan-baru>Kode pihak ketiga dan poin kegagalan baru</h3><p>Saat membuat sebuah CRD tidak secara otomatis menambahkan titik-titik kegagalan baru (sebagai contoh, dengan menyebabkan kode pihak ketiga untuk berjalan di API server kamu), paket-paket (sebagai contoh, <em>Chart</em>) atau bundel pemasangan lain seringkali sudah termasuk CRD dan juga sebagai Deployment dari kode pihak ketiga yang mengimplementasi logika bisnis untuk sebuah <em>Custom Resource</em>.</p><p>Memasang sebuah APIserver teragregasi selalu melibatkan tindakan menjalankan Deployment baru.</p><h3 id=penyimpanan>Penyimpanan</h3><p><em>Custom Resource</em> mengkonsumsi ruang penyimpanan dengan cara yang sama dengan ConfigMap. Membuat terlalu banyak sumber daya mungkin akan memenuhi ruang penyimpanan server API kamu.</p><p>Server <em>Aggregated API</em> dapat menggunakan penyimpanan yang sama dengan server API utama, dimana peringatan yang sama berlaku.</p><h3 id=authentication-authorization-and-auditing>Authentication, authorization, and auditing</h3><p>CRD selalu menggunakan otentikasi, otorisasi, dan audit pencatatan yang sama sebagai sumber daya bawaan dari server API kamu.</p><p>Jika kamu menggunakan RBAC untuk otorisasi, sebagian besar <em>role</em> RBAC tidak akan mengizinkan akses ke sumber daya baru (kecuali <em>role cluster-admin</em> atau <em>role</em> apapun yang dibuat menggunakan aturan <em>wildcard</em>). Kamu akan dibutuhkan untuk secara eksplisit mengizinkan akses ke sumber daya baru. CRD dan <em>Aggregated API</em> seringkali dibundel dengan definisi <em>role</em> baru untuk tipe yang mereka tambahkan.</p><p>API server teragregasi dapat atau tidak dapat menggunakan otentikasi, otorisasi, dan pengauditan yang sama dengan server API utama.</p><h2 id=mengakses-sebuah-custom-resource>Mengakses sebuah <em>Custom Resource</em></h2><p><a href=/docs/reference/using-api/client-libraries/>Pustaka klien</a> Kubernetes dapat digunakan untuk mengakses <em>Custom Resource</em>. Tidak semua pustaka klien mendukung <em>Custom Resource</em>. Pustaka klien go dan python melakukannya.</p><p>Ketika kamu menambahkan sebuah <em>Custom Resource</em>, kamu dapat mengaksesnya dengan menggunakan:</p><ul><li>kubectl</li><li>Klien dinamis kubernetes.</li><li>Sebuah klien REST yang kamu tulis</li><li>Sebuah klien yang dibuat menggunakan <a href=https://github.com/kubernetes/code-generator>Kubernetes client generation tools</a> (membuat satu adalah usaha lanjutan, tetapi beberapa proyek mungkin menyajikan sebuah klien bersama dengan CRD atau AA).</li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Belajar bagaimana untuk <a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Memperluas Kubernetes API dengan lapisan agregasi</a>.</p></li><li><p>Belajar bagaimana untuk <a href=/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/>Memperluas Kubernetes API dengan CustomResourceDefinition</a>.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c8937cdc9df96f3328becf04f8211292>3 - Ekstensi Komputasi, Penyimpanan, dan Jaringan</h1></div><div class=td-content><h1 id=pg-1ac2260db9ecccbf0303a899bc27ce6d>3.1 - Plugin Jaringan</h1><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [alpha]</code></div><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Fitur-fitur Alpha berubah dengan cepat.</div></p><p><em>Plugin</em> jaringan di Kubernetes hadir dalam beberapa varian:</p><ul><li><em>Plugin</em> CNI : mengikuti spesifikasi appc / CNI, yang dirancang untuk interoperabilitas.</li><li><em>Plugin</em> Kubenet : mengimplementasi <code>cbr0</code> sederhana menggunakan <em>plugin</em> <code>bridge</code> dan <code>host-local</code> CNI</li></ul><h2 id=instalasi>Instalasi</h2><p>Kubelet memiliki <em>plugin</em> jaringan bawaan tunggal, dan jaringan bawaan umum untuk seluruh kluster. <em>Plugin</em> ini memeriksa <em>plugin-plugin</em> ketika dijalankan, mengingat apa yang ditemukannya, dan mengeksekusi <em>plugin</em> yang dipilih pada waktu yang tepat dalam siklus pod (ini hanya berlaku untuk Docker, karena rkt mengelola <em>plugin</em> CNI sendiri). Ada dua parameter perintah Kubelet yang perlu diingat saat menggunakan <em>plugin</em>:</p><ul><li><code>cni-bin-dir</code>: Kubelet memeriksa direktori ini untuk <em>plugin-plugin</em> saat <em>startup</em></li><li><code>network-plugin</code>: <em>Plugin</em> jaringan untuk digunakan dari <code>cni-bin-dir</code>. Ini harus cocok dengan nama yang dilaporkan oleh <em>plugin</em> yang diperiksa dari direktori <em>plugin</em>. Untuk <em>plugin</em> CNI, ini (nilainya) hanyalah "cni".</li></ul><h2 id=persyaratan-plugin-jaringan>Persyaratan <em>Plugin</em> Jaringan</h2><p>Selain menyediakan <a href=https://github.com/kubernetes/kubernetes/tree/v1.25.0/pkg/kubelet/dockershim/network/plugins.go>antarmuka <code>NetworkPlugin</code></a> untuk mengonfigurasi dan membersihkan jaringan Pod, <em>plugin</em> ini mungkin juga memerlukan dukungan khusus untuk kube-proxy. Proksi <em>iptables</em> jelas tergantung pada <em>iptables</em>, dan <em>plugin</em> ini mungkin perlu memastikan bahwa lalu lintas kontainer tersedia untuk <em>iptables</em>. Misalnya, jika plugin menghubungkan kontainer ke <em>bridge</em> Linux, <em>plugin</em> harus mengatur nilai sysctl <code>net/bridge/bridge-nf-call-iptables</code> menjadi <code>1</code> untuk memastikan bahwa proksi <em>iptables</em> berfungsi dengan benar. Jika <em>plugin</em> ini tidak menggunakan <em>bridge</em> Linux (melainkan sesuatu seperti Open vSwitch atau mekanisme lainnya), <em>plugin</em> ini harus memastikan lalu lintas kontainer dialihkan secara tepat untuk proksi.</p><p>Secara bawaan jika tidak ada <em>plugin</em> jaringan Kubelet yang ditentukan, <em>plugin</em> <code>noop</code> digunakan, yang menetapkan <code>net/bridge/bridge-nf-call-iptables=1</code> untuk memastikan konfigurasi sederhana (seperti Docker dengan sebuah <em>bridge</em>) bekerja dengan benar dengan proksi <em>iptables</em>.</p><h3 id=cni>CNI</h3><p><em>Plugin</em> CNI dipilih dengan memberikan opsi <em>command-line</em> <code>--network-plugin=cni</code> pada Kubelet. Kubelet membaca berkas dari <code>--cni-conf-dir</code> (bawaan <code>/etc/cni/net.d</code>) dan menggunakan konfigurasi CNI dari berkas tersebut untuk mengatur setiap jaringan Pod. Berkas konfigurasi CNI harus sesuai dengan <a href=https://github.com/containernetworking/cni/blob/master/SPEC.md#network-configuration>spesifikasi CNI</a>, dan setiap <em>plugin</em> CNI yang diperlukan oleh konfigurasi harus ada di <code>--cni-bin-dir</code> (nilai bawaannya adalah <code>/opt/cni/bin</code>).</p><p>Jika ada beberapa berkas konfigurasi CNI dalam direktori, Kubelet menggunakan berkas yang pertama dalam urutan abjad.</p><p>Selain plugin CNI yang ditentukan oleh berkas konfigurasi, Kubernetes memerlukan <em>plugin</em> CNI standar <a href=https://github.com/containernetworking/plugins/blob/master/plugins/main/loopback/loopback.go><code>lo</code></a> <em>plugin</em> , minimal pada versi 0.2.0.</p><h4 id=dukungan-hostport>Dukungan hostPort</h4><p><em>Plugin</em> jaringan CNI mendukung <code>hostPort</code>. Kamu dapat menggunakan <em>plugin</em> <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/portmap>portmap</a> resmi yang ditawarkan oleh tim <em>plugin</em> CNI atau menggunakan <em>plugin</em> kamu sendiri dengan fungsionalitas <em>portMapping</em>.</p><p>Jika kamu ingin mengaktifkan dukungan <code>hostPort</code>, kamu harus menentukan <code>portMappings capability</code> di <code>cni-conf-dir</code> kamu.
Contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;portmap&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;portMappings&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=dukungan-pembentukan-lalu-lintas>Dukungan pembentukan lalu-lintas</h4><p><em>Plugin</em> jaringan CNI juga mendukung pembentukan lalu-lintas yang masuk dan keluar dari Pod. Kamu dapat menggunakan <em>plugin</em> resmi <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/bandwidth><em>bandwidth</em></a> yang ditawarkan oleh tim <em>plugin</em> CNI atau menggunakan <em>plugin</em> kamu sendiri dengan fungsionalitas kontrol <em>bandwidth</em>.</p><p>Jika kamu ingin mengaktifkan pembentukan lalu-lintas, kamu harus menambahkan <em>plugin</em> <code>bandwidth</code> ke berkas konfigurasi CNI kamu (nilai bawaannya adalah <code>/etc/cni/ net.d</code>).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;bandwidth&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;bandwidth&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sekarang kamu dapat menambahkan anotasi <code>kubernetes.io/ingress-bandwidth</code> dan <code>kubernetes.io/egress-bandwidth</code> ke Pod kamu.
Contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/ingress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/egress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=kubenet>Kubenet</h3><p>Kubenet adalah <em>plugin</em> jaringan yang sangat mendasar dan sederhana, hanya untuk Linux. Ia, tidak dengan sendirinya, mengimplementasi fitur-fitur yang lebih canggih seperti jaringan <em>cross-node</em> atau kebijakan jaringan. Ia biasanya digunakan bersamaan dengan penyedia layanan cloud yang menetapkan aturan <em>routing</em> untuk komunikasi antar Node, atau dalam lingkungan Node tunggal.</p><p>Kubenet membuat <em>bridge</em> Linux bernama <code>cbr0</code> dan membuat pasangan <em>veth</em> untuk setiap Pod dengan ujung <em>host</em> dari setiap pasangan yang terhubung ke <code>cbr0</code>. Ujung Pod dari pasangan diberi alamat IP yang dialokasikan dari rentang yang ditetapkan untuk Node baik melalui konfigurasi atau oleh controller-manager. <code>cbr0</code> memiliki MTU yang cocok dengan MTU terkecil dari antarmuka normal yang diaktifkan pada <em>host</em>.</p><p><em>Plugin</em> ini memerlukan beberapa hal:</p><ul><li><em>Plugin</em> CNI <code>bridge</code>, <code>lo</code> dan <code>host-local</code> standar diperlukan, minimal pada versi 0.2.0. Kubenet pertama-tama akan mencari mereka di <code>/opt/cni/bin</code>. Tentukan <code>cni-bin-dir</code> untuk menyediakan lokasi pencarian tambahan. Hasil pencarian pertama akan digunakan.</li><li>Kubelet harus dijalankan dengan argumen <code>--network-plugin=kubenet</code> untuk mengaktifkan <em>plugin</em></li><li>Kubelet juga harus dijalankan dengan argumen <code>--non-masquerade-cidr=&lt;clusterCidr></code> untuk memastikan lalu-lintas ke IP-IP di luar rentang ini akan menggunakan <em>masquerade</em> IP.</li><li>Node harus diberi subnet IP melalui perintah kubelet <code>--pod-cidr</code> atau perintah controller-manager <code>--allocate-node-cidrs=true --cluster-cidr=&lt;cidr></code>.</li></ul><h3 id=menyesuaikan-mtu-dengan-kubenet>Menyesuaikan MTU (dengan kubenet)</h3><p>MTU harus selalu dikonfigurasi dengan benar untuk mendapatkan kinerja jaringan terbaik. <em>Plugin</em> jaringan biasanya akan mencoba membuatkan MTU yang masuk akal, tetapi terkadang logika tidak akan menghasilkan MTU yang optimal. Misalnya, jika <em>bridge</em> Docker atau antarmuka lain memiliki MTU kecil, kubenet saat ini akan memilih MTU tersebut. Atau jika kamu menggunakan enkapsulasi IPSEC, MTU harus dikurangi, dan perhitungan ini di luar cakupan untuk sebagian besar <em>plugin</em> jaringan.</p><p>Jika diperlukan, kamu dapat menentukan MTU secara eksplisit dengan opsi <code>network-plugin-mtu</code> kubelet. Sebagai contoh, pada AWS <code>eth0</code> MTU biasanya adalah 9001, jadi kamu dapat menentukan <code>--network-plugin-mtu=9001</code>. Jika kamu menggunakan IPSEC, kamu dapat menguranginya untuk memungkinkan/mendukung <em>overhead</em> enkapsulasi pada IPSEC, contoh: <code>--network-plugin-mtu=8873</code>.</p><p>Opsi ini disediakan untuk <em>plugin</em> jaringan; Saat ini <strong>hanya kubenet yang mendukung <code>network-plugin-mtu</code></strong>.</p><h2 id=ringkasan-penggunaan>Ringkasan Penggunaan</h2><ul><li><code>--network-plugin=cni</code> menetapkan bahwa kita menggunakan <em>plugin</em> jaringan <code>cni</code> dengan <em>binary-binary plugin</em> CNI aktual yang terletak di <code>--cni-bin-dir</code> (nilai bawaannya <code>/opt/cni/bin</code>) dan konfigurasi <em>plugin</em> CNI yang terletak di <code>--cni-conf-dir</code> (nilai bawaannya <code>/etc/cni/net.d</code>).</li><li><code>--network-plugin=kubenet</code> menentukan bahwa kita menggunakan <em>plugin</em> jaringan <code>kubenet</code> dengan <code>bridge</code> CNI dan <em>plugin-plugin</em> <code>host-local</code> yang terletak di <code>/opt/cni/bin</code> atau <code>cni-bin-dir</code>.</li><li><code>--network-plugin-mtu=9001</code> menentukan MTU yang akan digunakan, saat ini hanya digunakan oleh <em>plugin</em> jaringan <code>kubenet</code>.</li></ul><h2 id=selanjutnya>Selanjutnya</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-53e1ea8892ceca307ba19e8d6a7b8d32>3.2 - Plugin Perangkat</h1><div class=lead>Gunakan kerangka kerja <em>plugin</em> perangkat Kubernetes untuk mengimplementasikan plugin untuk GPU, NIC, FPGA, InfiniBand, dan sumber daya sejenis yang membutuhkan setelan spesifik vendor.</div><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code></div><p>Kubernetes menyediakan <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md>kerangka kerja <em>plugin</em> perangkat</a>
sehingga kamu dapat memakainya untuk memperlihatkan sumber daya perangkat keras sistem ke dalam <a class=glossary-tooltip title='Agen yang dijalankan pada setiap node di klaster yang bertugas untuk memastikan kontainer dijalankan di dalam Pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>.</p><p>Daripada menkustomisasi kode Kubernetes itu sendiri, vendor dapat mengimplementasikan
<em>plugin</em> perangkat yang di-<em>deploy</em> secara manual atau sebagai <a class=glossary-tooltip title='Memastikan salinan Pod dijalankan pada sekumpulan Node dalam satu klaster.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>.
Perangkat yang dituju termasuk GPU, NIC berkinerja tinggi, FPGA, adaptor InfiniBand,
dan sumber daya komputasi sejenis lainnya yang perlu inisialisasi dan setelan spesifik vendor.</p><h2 id=pendaftaran-plugin-perangkat>Pendaftaran <em>plugin</em> perangkat</h2><p>Kubelet mengekspor servis gRPC <code>Registration</code>:</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>service Registration {
	rpc Register(RegisterRequest) returns (Empty) {}
}
</code></pre><p>Plugin perangkat bisa mendaftarkan dirinya sendiri dengan kubelet melalui servis gRPC.
Dalam pendaftaran, <em>plugin</em> perangkat perlu mengirim:</p><ul><li>Nama Unix socket-nya.</li><li>Versi API Plugin Perangkat yang dipakai.</li><li><code>ResourceName</code> yang ingin ditunjukkan. <code>ResourceName</code> ini harus mengikuti
<a href=/id/docs/concepts/configuration/manage-compute-resources-container/#extended-resources>skema penamaan sumber daya ekstensi</a>
sebagai <code>vendor-domain/tipe-sumber-daya</code>.
(Contohnya, NVIDIA GPU akan dinamai <code>nvidia.com/gpu</code>.)</li></ul><p>Setelah registrasi sukses, <em>plugin</em> perangkat mengirim daftar perangkat yang diatur
ke kubelet, lalu kubelet kemudian bertanggung jawab untuk mengumumkan sumber daya tersebut
ke peladen API sebagai bagian pembaruan status node kubelet.
Contohnya, setelah <em>plugin</em> perangkat mendaftarkan <code>hardware-vendor.example/foo</code> dengan kubelet
dan melaporkan kedua perangkat dalam node dalam kondisi sehat, status node diperbarui
untuk menunjukkan bahwa node punya 2 perangkat “Foo” terpasang dan tersedia.</p><p>Kemudian, pengguna dapat meminta perangkat dalam spesifikasi
<a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Kontainer</a>
seperti meminta tipe sumber daya lain, dengan batasan berikut:</p><ul><li>Sumber daya ekstensi hanya didukung sebagai sumber daya integer dan tidak bisa <em>overcommitted</em>.</li><li>Perangkat tidak bisa dibagikan antar Kontainer.</li></ul><p>Semisal klaster Kubernetes menjalankan <em>plugin</em> perangkat yang menunjukkan sumber daya <code>hardware-vendor.example/foo</code>
pada node tertentu. Berikut contoh Pod yang meminta sumber daya itu untuk menjalankan demo beban kerja:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-container-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>hardware-vendor.example/foo</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Pod ini perlu 2 perangkat perangkat-vendor.example/foo</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># dan hanya dapat menjadwalkan ke Node yang bisa memenuhi</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kebutuhannya.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Jika Node punya lebih dari 2 perangkat tersedia,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># maka kelebihan akan dapat digunakan Pod lainnya.</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=implementasi-plugin-perangkat>Implementasi <em>plugin</em> perangkat</h2><p>Alur kerja umum dari <em>plugin</em> perangkat adalah sebagai berikut:</p><ul><li><p>Inisiasi. Selama fase ini, <em>plugin</em> perangkat melakukan inisiasi spesifik vendor
dan pengaturan untuk memastikan perangkat pada status siap.</p></li><li><p>Plugin memulai servis gRPC, dengan Unix socket pada lokasi
<code>/var/lib/kubelet/device-plugins/</code>, yang mengimplementasi antarmuka berikut:</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>service DevicePlugin {
      // ListAndWatch mengembalikan aliran dari List of Devices
      // Kapanpun Device menyatakan perubahan atau kehilangan Device, ListAndWatch
      // mengembalikan daftar baru
      rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) {}

      // Allocate dipanggil saat pembuatan kontainer sehingga Device
      // Plugin dapat menjalankan operasi spesifik perangkat dan menyuruh Kubelet
      // dari operasi untuk membuat Device tersedia di kontainer
      rpc Allocate(AllocateRequest) returns (AllocateResponse) {}
}
</code></pre></li><li><p>Plugin mendaftarkan dirinya sendiri dengan kubelet melalui Unix socket pada lokasi host
<code>/var/lib/kubelet/device-plugins/kubelet.sock</code>.</p></li><li><p>Seteleh sukses mendaftarkan dirinya sendiri, <em>plugin</em> perangkat berjalan dalam mode peladen, dan selama itu
dia tetap mengawasi kesehatan perangkat dan melaporkan balik ke kubelet terhadap perubahan status perangkat.
Dia juga bertanggung jawab untuk melayani <em>request</em> gRPC <code>Allocate</code>. Selama <code>Allocate</code>, <em>plugin</em> perangkat dapat
membuat persiapan spesifik-perangkat; contohnya, pembersihan GPU atau inisiasi QRNG.
Jika operasi berhasil, <em>plugin</em> perangkat mengembalikan <code>AllocateResponse</code> yang memuat konfigurasi
runtime kontainer untuk mengakses perangkat teralokasi. Kubelet memberikan informasi ini ke runtime kontainer.</p></li></ul><h3 id=menangani-kubelet-yang-restart>Menangani kubelet yang <em>restart</em></h3><p>Plugin perangkat diharapkan dapat mendeteksi kubelet yang <em>restart</em> dan mendaftarkan dirinya sendiri kembali dengan
<em>instance</em> kubelet baru. Pada implementasi sekarang, sebuah <em>instance</em> kubelet baru akan menghapus semua socket Unix yang ada
di dalam <code>/var/lib/kubelet/device-plugins</code> ketika dijalankan. Plugin perangkat dapat mengawasi penghapusan
socket Unix miliknya dan mendaftarkan dirinya sendiri kembali ketika hal tersebut terjadi.</p><h2 id=deployment-plugin-perangkat>Deployment <em>plugin</em> perangkat</h2><p>Kamu dapat melakukan <em>deploy</em> sebuah <em>plugin</em> perangkat sebagai DaemonSet, sebagai sebuah paket untuk sistem operasi node-mu,
atau secara manual.</p><p>Direktori <em>canonical</em> <code>/var/lib/kubelet/device-plugins</code> membutuhkan akses berprivilese,
sehingga <em>plugin</em> perangkat harus berjalan dalam konteks keamanan dengan privilese.
Jika kamu melakukan <em>deploy</em> <em>plugin</em> perangkat sebagai DaemonSet, <code>/var/lib/kubelet/device-plugins</code>
harus dimuat sebagai <a class=glossary-tooltip title='Sebuah direktori yang mengandung data, dapat diakses o;eh kontainer-kontainer di dalam pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a> pada
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>
plugin.</p><p>Jika kamu memilih pendekatan DaemonSet, kamu dapat bergantung pada Kubernetes untuk meletakkan Pod
<em>plugin</em> perangkat ke Node, memulai-ulang Pod daemon setelah kegagalan, dan membantu otomasi pembaruan.</p><h2 id=kecocokan-api>Kecocokan API</h2><p>Dukungan pada <em>plugin</em> perangkat Kubernetes sedang dalam beta. API dapat berubah hingga stabil,
dalam cara yang tidak kompatibel. Sebagai proyek, Kubernetes merekomendasikan para developer <em>plugin</em> perangkat:</p><ul><li>Mengamati perubahan pada rilis mendatang.</li><li>Mendukung versi API <em>plugin</em> perangkat berbeda untuk kompatibilitas-maju/mundur.</li></ul><p>Jika kamu menyalakan fitur DevicePlugins dan menjalankan <em>plugin</em> perangkat pada node yang perlu diperbarui
ke rilis Kubernetes dengan versi API plugin yang lebih baru, perbarui <em>plugin</em> perangkatmu
agar mendukung kedua versi sebelum membarui para node ini. Memilih pendekatan demikian akan
menjamin fungsi berkelanjutan dari alokasi perangkat selama pembaruan.</p><h2 id=mengawasi-sumber-daya-plugin-perangkat>Mengawasi Sumber Daya Plugin Perangkat</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code></div><p>Dalam rangka mengawasi sumber daya yang disediakan <em>plugin</em> perangkat, agen monitoring perlu bisa
menemukan kumpulan perangkat yang terpakai dalam node dan mengambil metadata untuk mendeskripsikan
pada kontainer mana metrik harus diasosiasikan. Metrik <a href=https://prometheus.io/>prometheus</a>
diekspos oleh agen pengawas perangkat harus mengikuti
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/instrumentation.md>Petunjuk Instrumentasi Kubernetes</a>,
mengidentifikasi kontainer dengan label prometheus <code>pod</code>, <code>namespace</code>, dan <code>container</code>.</p><p>Kubelet menyediakan servis gRPC untuk menyalakan pencarian perangkat yang terpakai, dan untuk menyediakan metadata
untuk perangkat berikut:</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>// PodResourcesLister adalah layanan yang disediakan kubelet untuk menyediakan informasi tentang
// sumber daya node yang dikonsumsi Pod dan kontainer pada node
service PodResourcesLister {
    rpc List(ListPodResourcesRequest) returns (ListPodResourcesResponse) {}
}
</code></pre><p>Servis gRPC dilayani lewat socket unix pada <code>/var/lib/kubelet/pod-resources/kubelet.sock</code>.
Agen pengawas untuk sumber daya <em>plugin</em> perangkat dapat di-<em>deploy</em> sebagai daemon, atau sebagai DaemonSet.
Direktori <em>canonical</em> <code>/var/lib/kubelet/pod-resources</code> perlu akses berprivilese,
sehingga agen pengawas harus berjalan dalam konteks keamanan dengan privilese. Jika agen pengawas perangkat berjalan
sebagai DaemonSet, <code>/var/lib/kubelet/pod-resources</code> harus dimuat sebagai
<a class=glossary-tooltip title='Sebuah direktori yang mengandung data, dapat diakses o;eh kontainer-kontainer di dalam pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a> pada plugin
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>.</p><p>Dukungan untuk "servis PodResources" butuh <a href=/docs/reference/command-line-tools-reference/feature-gates/>gerbang fitur</a>
<code>KubeletPodResources</code> untuk dinyalakan. Mulai dari Kubernetes 1.15 nilai bawaannya telah dinyalakan.</p><h2 id=integrasi-plugin-perangkat-dengan-topology-manager>Integrasi Plugin Perangkat dengan Topology Manager</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code></div><p>Topology Manager adalah komponen Kubelet yang membolehkan sumber daya untuk dikoordinasi secara selaras dengan Topology. Untuk melakukannya, API Plugin Perangkat telah dikembangkan untuk memasukkan struct <code>TopologyInfo</code>.</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>message TopologyInfo {
	repeated NUMANode nodes = 1;
}

message NUMANode {
    int64 ID = 1;
}
</code></pre><p>Plugin Perangkat yang ingin memanfaatkan Topology Manager dapat mengembalikan beberapa <em>struct</em> TopologyInfo sebagai bagian dari pendaftaran perangkat, bersama dengan ID perangkat dan status kesehatan perangkat. Manajer perangkat akan memakai informasi ini untuk konsultasi dengan Topology Manager dan membuat keputusan alokasi sumber daya.</p><p><code>TopologyInfo</code> mendukung kolom <code>nodes</code> yang bisa <code>nil</code> (sebagai bawaan) atau daftar node NUMA. Ini membuat Plugin Perangkat mengumumkan apa saja yang bisa meliputi node NUMA.</p><p>Contoh <em>struct</em> <code>TopologyInfo</code> untuk perangkat yang dipopulate oleh Plugin Perangkat:</p><pre tabindex=0><code>pluginapi.Device{ID: &#34;25102017&#34;, Health: pluginapi.Healthy, Topology:&amp;pluginapi.TopologyInfo{Nodes: []*pluginapi.NUMANode{&amp;pluginapi.NUMANode{ID: 0,},}}}
</code></pre><h2 id=contoh>Contoh <em>plugin</em> perangkat</h2><p>Berikut beberapa contoh implementasi <em>plugin</em> perangkat:</p><ul><li><a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>Plugin perangkat AMD GPU</a></li><li><a href=https://github.com/intel/intel-device-plugins-for-kubernetes>Plugin perangkat Intel</a> untuk perangkat GPU, FPGA, dan QuickAssist Intel</li><li><a href=https://github.com/kubevirt/kubernetes-device-plugins>Plugin perangkat KubeVirt</a> untuk virtualisasi hardware-assisted</li><li><a href=https://github.com/NVIDIA/k8s-device-plugin>Plugin perangkat NVIDIA GPU</a><ul><li>Perlu <a href=https://github.com/NVIDIA/nvidia-docker>nvidia-docker</a> versi 2.0 yang memungkinkan untuk menjalakan kontainer Docker yang memuat GPU.</li></ul></li><li><a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu>Plugin perangkat NVIDIA GPU untuk Container-Optimized OS</a></li><li><a href=https://github.com/hustcat/k8s-rdma-device-plugin>Plugin perangkat RDMA</a></li><li><a href=https://github.com/vikaschoudhary16/sfc-device-plugin>Plugin perangkat Solarflare</a></li><li><a href=https://github.com/intel/sriov-network-device-plugin>Plugin perangkat SR-IOV Network</a></li><li><a href=https://github.com/Xilinx/FPGA_as_a_Service/tree/master/k8s-fpga-device-plugin>Plugin perangkat Xilinx FPGA</a> untuk perangkat Xilinx FPGA</li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari bagaimana <a href=/docs/tasks/manage-gpus/scheduling-gpus/>menjadwalkan sumber daya GPU</a> dengan <em>plugin</em> perangkat</li><li>Pelajari bagaimana <a href=/docs/tasks/administer-cluster/extended-resource-node/>mengumumkan sumber daya ekstensi</a> pada node</li><li>Baca tentang penggunaan <a href=https://kubernetes.io/blog/2019/04/24/hardware-accelerated-ssl/tls-termination-in-ingress-controllers-using-kubernetes-device-plugins-and-runtimeclass/>akselerasi perangkat keras untuk ingress TLS</a> dengan Kubernetes</li><li>Pelajari tentang [Topology Manager] (/docs/tasks/adminster-cluster/topology-manager/)</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3131452556176159fb269593c1a52012>4 - Pola Operator</h1><p>Operator adalah ekstensi perangkat lunak untuk Kubernetes yang memanfaatkan
<a href=/id/docs/concepts/extend-kubernetes/api-extension/custom-resources/><em>custom resource</em></a>
untuk mengelola aplikasi dan komponen-komponennya. Operator mengikuti prinsip
Kubernetes, khususnya dalam hal <a href=/docs/concepts/#kubernetes-control-plane><em>control loop</em></a>.</p><h2 id=motivasi>Motivasi</h2><p>Pola dari Operator bertujuan untuk menangkap tujuan utama dari Operator manusia
yang mengelola layanan atau suatu kumpulan layanan. Operator manusia yang
menjaga spesifik aplikasi dan layanan memiliki pengetahuan yang mendalam tentang
bagaimana sistem harus berperilaku, bagaimana cara menyebarkannya, dan
bagaimana bereaksi jika ada masalah.</p><p>Orang-orang yang menjalankan <em>workload-workload</em> di Kubernetes pada umumnya suka
menggunakan otomatisasi untuk menangani tugas-tugas yang berulang. Pola
Operator menangkap bagaimana kamu dapat menulis kode untuk mengotomatiskan
sebuah tugas di luar batas apa yang dapat disediakan oleh Kubernetes itu
sendiri.</p><h2 id=operator-di-kubernetes>Operator di Kubernetes</h2><p>Kubernetes didesain untuk otomasi. Secara di luar nalar, kamu mendapatkan banyak
otomatisasi bawaan dari komponen inti Kubernetes. Kamu dapat menggunakan
Kubernetes untuk mengotomasikan penyebaran dan menjalankan <em>workload-workload</em>, <em>dan</em>
kamu juga dapat mengotomasikan cara Kubernetes melakukan pekerjaan itu.</p><p>Konsep dari <a class=glossary-tooltip title='Kontrol tertutup yang mengawasi kondisi bersama dari klaster melalui apiserver dan membuat perubahan yang mencoba untuk membawa kondisi saat ini ke kondisi yang diinginkan.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>
Kubernetes memungkinkan kamu memperluas perilaku klaster tanpa harus mengubah
kode dari Kubernetes itu sendiri.</p><p>Operator adalah klien API dari Kubernetes yang bertindak sebagai <em>controller</em>
untuk <a href=/docs/concepts/api-extension/custom-resources/><em>custome resource</em></a>.</p><h2 id=contoh>Contoh Operator</h2><p>Beberapa hal yang dapat kamu gunakan untuk mengotomasi Operator meliputi:</p><ul><li>menyebarkan aplikasi sesuai dengan permintaan</li><li>mengambil dan memulihkan backup status dari sebuah aplikasi</li><li>menangani pembaruan kode aplikasi termasuk dengan perubahan terkait seperti
skema basis data atau pengaturan konfigurasi tambahan</li><li>mempublikasikan layanan ke sebuah aplikasi yang tidak mendukung API Kubernetes
untuk menemukan mereka</li><li>mensimulasikan kegagalan pada seluruh atau sebagian klaster kamu untuk
menguji resiliensinya</li><li>memilih suatu pemimpin untuk aplikasi yang terdistribusi tanpa adanya proses
pemilihan anggota secara internal</li></ul><p>Seperti apa sebuah Operator dalam kasus yang lebih terperinci? Berikut ini
adalah contoh yang lebih detail:</p><ol><li>Sebuah <em>custom resource</em> bernama SampleDB, bisa kamu konfigurasi ke
dalam klaster.</li><li>Sebuah Deployment memastikan sebuah Pod berjalan dimana didalamnya
berisi bagian <em>controller</em> dari Operator.</li><li>Kontainer Image dari kode Operator.</li><li>Kode <em>controller</em> yang menanyakan pada <em>control-plane</em> untuk mencari tahu
apakah itu sumber daya SampleDB telah dikonfigurasi.</li><li>Inti dari Operator adalah kode untuk memberi tahu server API bagaimana
membuatnya kondisi sebenarnya sesuai dengan sumber daya yang dikonfigurasi.
   * Jika kamu menambahkan SampleDB baru, Operator menyiapkan
PersistentVolumeClaims untuk menyediakan penyimpanan basis data yang
tahan lama, sebuah StatefulSet untuk menjalankan SampleDB dan pekerjaan
untuk menangani konfigurasi awal.
   * Jika kamu menghapusnya, Operator mengambil <em>snapshot</em>, lalu memastikannya
     StatefulSet dan Volume juga dihapus.</li><li>Operator juga mengelola backup basis data yang reguler. Untuk setiap resource
SampleDB, Operator menentukan kapan membuat Pod yang dapat terhubung
   ke database dan mengambil backup. Pod-Pod ini akan bergantung pada ConfigMap
   dan / atau sebuah Secret yang memiliki basis data koneksi dan kredensial.</li><li>Karena Operator bertujuan untuk menyediakan otomatisasi yang kuat untuk
resource yang dikelola, maka akan ada kode pendukung tambahan. Sebagai contoh
, kode memeriksa untuk melihat apakah basis data menjalankan versi yang
lama dan, jika demikian, kode membuat objek Job yang melakukan pembaruan untuk
kamu.</li></ol><h2 id=menyebarkan-operator>Menyebarkan Operator</h2><p>Cara paling umum untuk menyebarkan Operator adalah dengan menambahkan
CustomResourceDefinition dan <em>controller</em> yang berkaitan ke dalam klaster kamu.
<em>Controller</em> biasanya akan berjalan di luar
<a class=glossary-tooltip title='Merupakan lapisan orkestrasi Container yang mengekspos API dan antarmuka untuk mendefinisikan, menggelar, dan mengelola siklus hidup suatu Container.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>,
seperti kamu akan menjalankan aplikasi apa pun yang dikontainerisasi.
Misalnya, kamu bisa menjalankan <em>controller</em> di klaster kamu sebagai sebuah
Deployment.</p><h2 id=menggunakan-operator-menggunakan-operator>Menggunakan Operator {#menggunakan operator}</h2><p>Setelah Operator disebarkan, kamu akan menggunakannya dengan menambahkan,
memodifikasi, atau menghapus jenis sumber daya yang digunakan Operator tersebut.
Melanjutkan contoh diatas, kamu akan menyiapkan Deployment untuk Operator itu
sendiri, dan kemudian:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get SampleDB                   <span style=color:#080;font-style:italic># find configured databases</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl edit SampleDB/example-database <span style=color:#080;font-style:italic># manually change some settings</span>
</span></span></code></pre></div><p>…dan itu saja! Operator akan berhati-hati dalam menerapkan perubahan
serta menjaga layanan yang ada dalam kondisi yang baik.</p><h2 id=menulis-operator>Menulis Operator Kamu Sendiri</h2><p>Jika tidak ada Operator dalam ekosistem yang mengimplementasikan perilaku kamu
inginkan, kamu dapat kode kamu sendiri. Dalam <a href=#selanjutnya>Selanjutnya</a> kamu
akan menemukan beberapa tautan ke <em>library</em> dan perangkat yang dapat kamu gunakan
untuk menulis Operator <em>Cloud Native</em> kamu sendiri.</p><p>Kamu juga dapat mengimplementasikan Operator (yaitu, <em>Controller</em>) dengan
menggunakan bahasa / <em>runtime</em> yang dapat bertindak sebagai
<a href=/docs/reference/using-api/client-libraries/>klien dari API Kubernetes</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Memahami lebih lanjut tentang <a href=/id/docs/concepts/extend-kubernetes/api-extension/custom-resources/><em>custome resources</em></a></li><li>Temukan "ready-made" <em>operators</em> dalam <a href=https://operatorhub.io/>OperatorHub.io</a>
untuk memenuhi use case kamu</li><li>Menggunakan perangkat yang ada untuk menulis Operator kamu sendiri, misalnya:<ul><li>menggunakan <a href=https://kudo.dev/>KUDO</a> (Kubernetes Universal Declarative Operator)</li><li>menggunakan <a href=https://book.kubebuilder.io/>kubebuilder</a></li><li>menggunakan <a href=https://metacontroller.github.io/metacontroller/intro.html>Metacontroller</a> bersama dengan
<code>WebHooks</code> yang kamu implementasikan sendiri</li><li>menggunakan the <a href=https://github.com/operator-framework/getting-started>Operator <em>Framework</em></a></li></ul></li><li><a href=https://operatorhub.io/>Terbitkan</a> Operator kamu agar dapat digunakan oleh
orang lain</li><li>Baca <a href=https://coreos.com/blog/introducing-operators.html>artikel asli dari CoreOS</a>
yang memperkenalkan pola Operator</li><li>Baca sebuah <a href=https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps>artikel</a>
dari Google Cloud soal panduan terbaik membangun Operator</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b26fcf43d01abc16c8110766026dafed>5 - Service Catalog</h1><p><p>Service Catalog adalah sebuah ekstensi API yang memungkinkan aplikasi berjalan pada klaster Kubernetes untuk
mempermudah penggunaan perangkat lunak yang dikelola eksternal, seperti servis penyimpanan
data yang ditawarkan oleh penyedia layanan komputasi awan.</p></p><p>Ini menyediakan cara untuk membuat daftar, melakukan pembuatan, dan mengikat dengan
<a class=glossary-tooltip title='Sebuah perangkat lunak yang dikelola oleh penyedia layanan pihak ketiga.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-managed-service' target=_blank aria-label='servis terkelola'>servis terkelola</a> eksternal
dari <a class=glossary-tooltip title='Sebuah endpoint untuk kumpulan servis terlola yang ditawarkan dan dikelola oleh penyedia layanan pihak ketiga.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-service-broker' target=_blank aria-label='makelar servis'>makelar servis</a> tanpa membutuhkan
pengetahuan mendalam mengenai cara servis tersebut dibuat dan diatur.</p><p>Sebuah makelar servis (<em>service broker</em>), seperti yang didefinisikan oleh [spesifikasi API makelar servis terbuka]
(<a href=https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md)>https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md)</a>, adalah sebuah
<em>endpoint</em> untuk beberapa layanan terkelola yang ditawarkan dan dikelola oleh pihak ketiga,
yang bisa jadi sebuah penyedia layanan <em>cloud</em> seperti AWS, GCP atau Azure.</p><p>Beberapa contoh dari servis terkelola adalah Microsoft Azure Cloud Queue, Amazon Simple Queue Service, dan
Google Cloud Pub/Sub, selain itu, bisa juga penawaran perangkat lunak apa pun yang dapat digunakan oleh suatu aplikasi.</p><p>Dengan menggunakan Service Catalog,
seorang <a class=glossary-tooltip title='Seseorang yang mengonfigurasi, mengontrol, dan memonitor klaster.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-cluster-operator' target=_blank aria-label='pengelola klaster'>pengelola klaster</a> dapat melihat
daftar servis terkelola yang ditawarkan oleh makelar servis, melakukan pembuatan terhadap
sebuah servis terkelola, dan menghubungkan (<em>bind</em>) untuk membuat tersedia terhadap aplikasi pada suatu klaster Kubernetes.</p><h2 id=contoh-kasus-penggunaan>Contoh kasus penggunaan</h2><p>Seorang <a class=glossary-tooltip title='A person who writes an application that runs in a Kubernetes cluster.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-application-developer' target=_blank aria-label='pengembang aplikasi'>pengembang aplikasi</a> ingin menggunakan
sistem antrian pesan sebagai bagian dari aplikasinya yang berjalan dalam klaster Kubernetes.
Namun, mereka tidak ingin berurusan dengan kesulitan dalam pengaturan, misalnya menjaga servis tetap
berjalan dan mengatur itu oleh mereka sendiri. Beruntungnya, sudah tersedia penyedia layanan <em>cloud</em>
yang menawarkan sistem antrian pesan sebagai servis terkelola melalui makelar servisnya.</p><p>Seorang pengelola klaster dapat membuat Service Catalog dan menggunakannya untuk berkomunikasi dengan
makelar servis milik penyedia layanan <em>cloud</em> untuk menyediakan sebuah servis antrian pesan dan membuat
servis ini tersedia kepada aplikasi dalam klaster Kubernetes.
Seorang pengembang aplikasi tidak perlu memikirkan detail implementasi atau mengatur sistem antrian pesan tersebut.
Aplikasi dapat langsung menggunakan servis tersebut.</p><h2 id=arsitektur>Arsitektur</h2><p>Service Catalog menggunakan <a href=https://github.com/openservicebrokerapi/servicebroker>API dari Open Service Broker</a>
untuk berkomunikasi dengan makelar servis, bertindak sebagai perantara untuk API Server Kubernetes untuk
merundingkan penyediaan awal dan mengambil kredensial untuk aplikasi bisa menggunakan servis terkelola tersebut.</p><p>Ini terimplementasi sebagai ekstensi API Server dan pengontrol, menggunakan etcd sebagai media penyimpanan.
Ini juga menggunakan <a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>lapisan agregasi</a>
yang tersedia pada Kubernetes versi 1.7+ untuk menampilkan API-nya.</p><br><p><img src=/images/docs/service-catalog-architecture.svg alt="Arsitektur Service Catalog"></p><h3 id=sumber-daya-api>Sumber Daya API</h3><p>Service Catalog memasang API <code>servicecatalog.k8s.io</code> dan menyediakan beberapa sumber daya Kubernetes berikut:</p><ul><li><code>ClusterServiceBroker</code>: Sebuah representasi dalam klaster untuk makelar servis, membungkus detail koneksi peladen.
Ini dibuat dan dikelola oleh pengelola klaster yang berharap untuk menggunakan makelar peladen untuk membuat
tipe baru dari sebuah servis terkelola yang tersedia dalam klaster mereka.</li><li><code>ClusterServiceClass</code>: Sebuah servis terkelola ditawarkan oleh beberapa makelar servis.
Ketika sumber daya <code>ClusterServiceBroker</code> ditambahkan ke dalam klaster, kontroler Service Catalog terhubung
ke makelar servis untuk mendapatkan daftar servis terkelola yang tersedia. Kemudian membuat sumber daya
<code>ClusterServiceClass</code> sesuai dengan masing-masing servis terkelola.</li><li><code>ClusterServicePlan</code>: Sebuah penawaran khusus dari servis terkelola. Sebagai contoh, sebuah servis terkelola
bisa memiliki model harga, yaitu gratis atau berbayar, atau ini mungkin juga memiliki konfigurasi pilihan berbeda,
misal menggunakan penyimpanan SSD atau memiliki sumber daya lebih. Mirip dengan <code>ClusterServiceClass</code>, ketika
<code>ClusterServiceBroker</code> baru ditambahkan ke dalam klaster, Service Catalog akan membuat sumber daya
<code>ClusterServicePlan</code> sesuai dengan <em>Service Plan</em> yang tersedia untuk masing-masing servis terkelola.</li><li><code>ServiceInstance</code>: Sebuah objek dari <code>ClusterServiceClass</code>.
Ini dibuat oleh operator klaster untuk membuat bentuk spesifik dari servis terkelola yang tersedia untuk
digunakan oleh salah satu atau lebih aplikasi dalam klaster.
Ketika sumber daya <code>ServiceInstance</code> baru terbuat, pengontrol Service Catalog terhubung ke makelar servis yang
sesuai dan menginstruksikan untuk menyediakan sebuah objek servis.</li><li><code>ServiceBinding</code>: Kredensial untuk mengakses suatu <code>ServiceInstance</code>.
Ini dibuat oleh operator klaster yang ingin aplikasinya untuk menggunakan sebuah <code>ServiceInstance</code>.
Saat dibuat, kontroler Service Catalog membuat sebuah <code>Secret</code> Kubernetes yang berisikan detail koneksi
dan kredensial untuk objek servis, yang bisa dimuat ke dalam Pod.</li></ul><h3 id=autentikasi>Autentikasi</h3><p>Service Catalog mendukung beberapa metode autentikasi, yaitu:</p><ul><li>Basic (nama pengguna/kata sandi)</li><li><a href=https://tools.ietf.org/html/rfc6750>OAuth 2.0 Bearer Token</a></li></ul><h2 id=penggunaan>Penggunaan</h2><p>Seorang operator klaster dapat menggunakan API sumber daya Service Catalog untuk membuat servis terkelola
dan membuatnya tersedia dalam klaster Kubernetes. Langkah yang dilalui adalah sebagai berikut:</p><ol><li>Membuat daftar servis terkelola dan model pembayaran yang tersedia dari makelar servis.</li><li>Membuat sebuah objek dari suatu servis terkelola.</li><li>Menghubungkan ke servis terkelola, yang mengembalikan kredensial koneksi.</li><li>Memetakan kredensial koneksi ke dalam aplikasi.</li></ol><h3 id=membuat-daftar-servis-terkelola-dan-model-pembayaran>Membuat daftar servis terkelola dan model pembayaran</h3><p>Pertama, seorang operator klaster harus membuat sumber daya <code>ClusterServiceBroker</code> dalam kelompok
<code>servicecatalog.k8s.io</code>. Sumber daya ini memiliki URL dan detail koneksi untuk mengakses makelar servis.</p><p>Ini ada contoh dari suatu sumber daya <code>ClusterServiceBroker</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterServiceBroker<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-broker<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Merujuk pada titik akhir dari makelar servis. (Ini adalah contoh URL yang tidak nyata)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>url</span>:<span style=color:#bbb>  </span>https://servicebroker.somecloudprovider.com/v1alpha1/projects/service-catalog/brokers/default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Nilai tambahan dapat ditambahkan disini, yang mungkin bisa digunakan untuk berkomunikasi</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># dengan makelar servis, misalnya saja informasi bearer token atau sebuah caBundle untuk TLS.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Berikut adalah sebuah diagram urutan yang mengilustrasikan langkah-langkah dalam mendaftarkan
servis terkelola dan model pembayaran yang tersedia dari makelar servis:</p><p><img src=/images/docs/service-catalog-list.svg alt="Daftar Servis"></p><ol><li><p>Setelah sumber daya <code>ClusterServiceBroker</code> ditambahkan ke dalam Service Catalog, ini membuat panggilan
makelar servis luar untuk membuat daftar servis yang tersedia.</p></li><li><p>Makelar servis akan mengembalikan daftar servis terkelola yang tersedia dan daftar model pembayaran,
yang akan disimpan sementara sebagai <code>ClusterServiceClass</code> dan <code>ClusterServicePlan</code>.</p></li><li><p>Seorang operator klaster bisa mendapatkan daftar servis terkelola dengan menggunakan perintah berikut ini:</p><pre><code> kubectl get clusterserviceclasses -o=custom-columns=SERVICE\ NAME:.metadata.name,EXTERNAL\ NAME:.spec.externalName
</code></pre><p>Itu seharusnya memberikan daftar nama servis dengan format yang mirip dengan berikut:</p><pre><code> SERVICE NAME                           EXTERNAL NAME
 4f6e6cf6-ffdd-425f-a2c7-3c9258ad2468   cloud-provider-service
 ...                                    ...
</code></pre><p>Mereka juga dapat melihat model pembayaran yang tersedia menggunakan perintah berikut:</p><pre><code> kubectl get clusterserviceplans -o=custom-columns=PLAN\ NAME:.metadata.name,EXTERNAL\ NAME:.spec.externalName
</code></pre><p>Itu seharusnya memberikan daftar nama model pembayaran dengan format mirip dengan berikut:</p><pre><code> PLAN NAME                              EXTERNAL NAME
 86064792-7ea2-467b-af93-ac9694d96d52   service-plan-name
 ...                                    ...
</code></pre></li></ol><h3 id=pembuatan-sebuah-objek>Pembuatan sebuah objek</h3><p>Seorang operator klaster dapat memulai pembuatan sebuah objek dengan membuat sumber daya <code>ServiceInstance</code>.</p><p>Ini adalah contoh dari sumber daya <code>ServiceInstance</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceInstance<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-instance<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cloud-apps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Referensi untuk salah satu servis yang pernah dikembalikan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterServiceClassExternalName</span>:<span style=color:#bbb> </span>cloud-provider-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterServicePlanExternalName</span>:<span style=color:#bbb> </span>service-plan-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Parameter tambahan dapat ditambahkan disini,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># yang mungkin akan digunakan oleh makelar servis.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Berikut adalah diagram urutan yang mengilustrasikan langkah-langkah dalam pembuatan sebuah objek dari
servis terkelola:</p><p><img src=/images/docs/service-catalog-provision.svg alt="Pembuatan sebuah servis"></p><ol><li>Ketika sumber daya <code>ServiceInstance</code> sudah terbuat, Service Catalog memulai pemanggilan ke makelar servis
luar untuk membuat sebuah objek dari suatu servis.</li><li>Makelar servis membuat sebuah objek baru dari suatu servis terkelola dan mengembalikan sebuah respons HTTP.</li><li>Seorang operator klaster dapat mengecek status dari objek untuk melihat apakah sudah siap atau belum.</li></ol><h3 id=menghubungkan-ke-servis-terkelola>Menghubungkan ke servis terkelola</h3><p>Setelah sebuah objek terbuat, klaster operator harus menghubungkan ke servis terkelola untuk mendapatkan
kredensial koneksi dan detail pengguna servis untuk aplikasi bisa mengguakan servis tersebut. Ini dilakukan
dengan membuat sebuah sumber daya <code>ServiceBinding</code>.</p><p>Berikut adalah contoh dari sumber daya <code>ServiceBinding</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-binding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cloud-apps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>instanceRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-instance<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Informasi tambahan dapat ditambahkan disini, seperti misalnya secretName atau</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># parameter pengguna servis, yang mungkin akan digunakan oleh makelar servis.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Berikut ada diagram urutan yang mengilustrasikan langkah-langkah dalam menghubungkan objek servis terkelola.</p><p><img src=/images/docs/service-catalog-bind.svg alt="Menghubungkan ke servis terkelola"></p><ol><li>Setelah <code>ServiceBinding</code> terbuat, Service Catalog memanggil makelar servis luar untuk meminta
informasi yang dibutuhkan untuk terhubung dengan objek servis.</li><li>Makelar servis memberikan izin atau peran kepada aplikasi sesuai dengan pengguna servis.</li><li>Makelar servis mengembalikan informasi untuk bisa terhubung dan mengakses servis terkelola.
Ini tergantung pada penyedia layanan dan servis, sehingga informasi yang dikembalikan mungkin berbeda
antara suatu penyedia layanan dan servis terkelolanya.</li></ol><h3 id=memetakan-kredensial-koneksi>Memetakan kredensial koneksi</h3><p>Setelah menghubungkan, langkah terakhir melibatkan pemetaan kredensial koneksi dan informasi spesifik mengenai
servis kedalam aplikasi. Informasi ini disimpan dalam Secrets yang mana aplikasi dalam klaster dapat mengakses
dan menggunakan untuk bisa terkoneksi secara langsung dengan servis terkelola.</p><br><p><img src=/images/docs/service-catalog-map.svg alt="Pemetaan kredensial koneksi"></p><h4 id=berkas-konfigurasi-pod>Berkas konfigurasi Pod</h4><p>Salah satu metode untuk melakukan pemetaan ini adalah dengan menggunakan deklarasi konfigurasi Pod.</p><p>Berikut adalah contoh yang mendekripsikan bagaimana pemetaan kredensial pengguna servis ke dalam aplikasi.
Sebuah kunci yang disebut <code>sa-key</code> disimpan dalam media bernama <code>provider-cloud-key</code>, dan aplikasi memasang
media ini pada <code>/var/secrets/provider/key.json</code>. <em>Environment variable</em> <code>PROVIDER_APPLICATION_CREDENTIALS</code>
dipetakan dari nilai pada berkas yang dipasang.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-cloud-key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>sa-key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-cloud-key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/secrets/provider<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PROVIDER_APPLICATION_CREDENTIALS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/secrets/provider/key.json&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Berikut adalah contoh yang mendeskripsikan cara memetakan nilai rahasia ke dalam <em>environment variable</em> aplikasi.
Dalam contoh ini, nama topik dari sistem antrian pesan dipetakan dari <em>secret</em> bernama <code>provider-queue-credentials</code>
dengan nama <code>topic</code> ke dalam <em>environment variable</em> <code>TOPIC</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;TOPIC&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                   </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-queue-credentials<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                   </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>topic<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Jika kamu terbiasa dengan <a class=glossary-tooltip title='A package of pre-configured Kubernetes resources that can be managed with the Helm tool.' data-toggle=tooltip data-placement=top href=https://helm.sh/docs/topics/charts/ target=_blank aria-label='Helm Charts'>Helm Charts</a>,
<a href=/docs/tasks/service-catalog/install-service-catalog-using-helm/>pasang Service Catalog menggunakan Helm</a>
ke dalam klaster Kubernetes. Alternatif lain, kamu dapat <a href=/docs/tasks/service-catalog/install-service-catalog-using-sc/>memasang Service Catalog dengan SC tool</a>.</li><li>Lihat <a href=https://github.com/openservicebrokerapi/servicebroker/blob/master/gettingStarted.md#sample-service-brokers>contoh makelar servis</a>.</li><li>Pelajari mengenai <a href=https://github.com/kubernetes-incubator/service-catalog>kubernetes-incubator/service-catalog</a> proyek.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bad3c3629d0ab48ed84b6caf66d02f89>6 - Poseidon-Firmament - Sebuah Penjadwal Alternatif</h1><p><strong>Rilis saat ini dari Penjadwal Poseidon-Firmament adalah rilis <code>alpha </code>.</strong></p><p>Penjadwal Poseidon-Firmament adalah penjadwal alternatif yang dapat digunakan bersama penjadwal Kubernetes bawaan.</p><h2 id=pengenalan>Pengenalan</h2><p>Poseidon adalah sebuah layanan yang berperan sebagai pemersatu antara <a href=https://github.com/Huawei-PaaS/firmament>Penjadwal Firmament</a> dengan Kubernetes. Penjadwal Poseidon-Firmament menambah kapabilitas penjadwal Kubernetes saat ini. Penjadwal ini menggabungkan kemampuan penjadwalan berbasis grafik jaringan grafis (<em>flow network graph</em>) baru bersama penjadwal Kubernetes bawaan. Penjadwal Firmament memodelkan beban-beban kerja dan klaster-klaster sebagai jaringan aliran dan menjalankan optimisasi aliran biaya-minimum kepada jaringan ini untuk membuat keputusan penjadwalan.</p><p>Penjadwal ini memodelkan masalah penjadwalan sebagai optimasi berbasis batasan atas grafik jaringan aliran. Hal ini dicapai dengan mengurangi penjadwalan ke masalah optimisasi biaya-minimum aliran-maksimum. Penjadwal Poseidon-Firmament secara dinamis memperbaiki penempatan beban kerja.</p><p>Penjadwal Poseidon-Firmament berjalan bersamaan dengan penjadwal Kubernetes bawaan sebagai penjadwal alternatif, sehingga beberapa penjadwal dapat berjalan secara bersamaan.</p><h2 id=keuntungan-utama>Keuntungan Utama</h2><h3 id=penjadwalan-grafik-jaringan-network-graph-berbasis-penjadwalan-poseidon-firmament-memberikan-beberapa-keuntungan-utama-sebagai-berikut>Penjadwalan grafik jaringan (<em>network graph</em>) berbasis penjadwalan Poseidon-Firmament memberikan beberapa keuntungan utama sebagai berikut:</h3><ul><li>Beban kerja (Pod) dijadwalkan secara kolektif untuk memungkinkan penjadwalan dalam skala besar.</li><li>Berdasarkan hasil tes kinerja yang ekstensif, skala Poseidon-Firmament jauh lebih baik daripada penjadwal bawaan Kubernetes dilihat dari jumlah node meningkat dalam sebuah klaster. Hal ini disebabkan oleh fakta bahwa Poseidon-Firmament mampu mengamortisasi lebih banyak pekerjaan di seluruh beban kerja.</li><li>Penjadwal Poseidon-Firmament mengungguli penjadwal bawaan Kubernetes dengan margin lebar ketika menyangkut jumlah kinerja <em>throughput</em> untuk skenario di mana kebutuhan sumber daya komputasi agak seragam di seluruh pekerjaan (Replicaset / Deployment / Job). Angka kinerja <em>throughput</em> <em>end-to-end</em> penjadwal Poseidon-Firmament , termasuk waktu <em>bind</em>, secara konsisten menjadi lebih baik seiring jumlah Node dalam sebuah klaster meningkat. Misalnya, untuk klaster 2.700 Node (ditampilkan dalam grafik <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/benchmark/README.md>di sini</a>), penjadwal Poseidon-Firmament berhasil mencapai 7X atau lebih <em>throughput</em> <em>end-to-end</em> yang lebih besar dibandingkan dengan penjadwal bawaan Kubernetes, yang mencakup waktu <em>bind</em>.</li><li>Tersedianya pembatasan aturan yang kompleks.</li><li>Penjadwalan dalam Poseidon-Firmament bersifat dinamis; ini membuat sumber daya klaster dalam keadaan optimal secara global selama setiap berjalannya penjadwalan.</li><li>Pemanfaatan sumber daya yang sangat efisien.</li></ul><h2 id=penjadwal-poseidon-firmament-bagaimana-cara-kerjanya>Penjadwal Poseidon-Firmament - Bagaimana cara kerjanya</h2><p>Sebagai bagian dari pendukung penjadwal-penjadwal Kubernetes, setiap Pod baru biasanya dijadwalkan oleh penjadwal bawaan. Kubernetes dapat diinstruksikan untuk menggunakan penjadwal lain dengan menentukan nama penjadwal <em>custom</em> lain ("poseidon" dalam kasus ini) di <em>field</em> <strong>schedulerName</strong> dari PodSpec pada saat pembuatan pod. Dalam kasus ini, penjadwal bawaan akan mengabaikan Pod itu dan memungkinkan penjadwal Poseidon untuk menjadwalkan Pod pada Node yang relevan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>poseidon<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk detail tentang desain proyek ini, lihat <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/design/README.md>dokumen desain</a>.</div><h2 id=kemungkinan-skenario-kasus-penggunaan-kapan-menggunakannya>Kemungkinan Skenario Kasus Penggunaan - Kapan menggunakannya</h2><p>Seperti yang disebutkan sebelumnya, penjadwal Poseidon-Firmament memungkinkan lingkungan penjadwalan dengan <em>throughput</em> yang sangat tinggi bahkan pada ukuran klaster dengan beban kerja besar, dikarenakan pendekatan penjadwalannya yang sekaligus dalam jumlah besar, dibandingkan dengan pendekatan bawaan <em>pod-at-a-time</em> Kubernetes. Dalam pengujian ekstensif kami, kami telah mengamati manfaat <em>throughput</em> substansial selama kebutuhan sumber daya (CPU / Memori) untuk Pod yang masuk seragam di seluruh tugas (Replicaset / Deployment / Job), terutama karena amortisasi pekerjaan yang efisien di seluruh tugas.</p><p>Meskipun penjadwal Poseidon-Firmament mampu menjadwalkan berbagai jenis beban kerja, seperti layanan-layanan, <em>batch</em>, dll., berikut ini adalah beberapa kasus penggunaan yang paling unggul:</p><ol><li>Untuk pekerjaan "Big Data / AI" yang terdiri dari sejumlah besar tugas, manfaat dari <em>throughput</em> luar biasa.</li><li>Pekerjaan layanan atau <em>batch job</em> di mana kebutuhan sumber dayanya seragam di seluruh pekerjaan (Replicaset / Deployment / Job).</li></ol><h2 id=tahap-proyek-saat-ini>Tahap Proyek Saat Ini</h2><ul><li><strong>Rilis Alpha - Repo Inkubasi.</strong> di <a href=https://github.com/kubernetes-sigs/poseidon>https://github.com/kubernetes-sigs/poseidon</a>.</li><li>Saat ini, penjadwal Poseidon-Firmament <strong>tidak memberikan dukungan untuk ketersediaan tinggi</strong>, implementasi kami mengasumsikan bahwa penjadwal tidak mungkin gagal. <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/design/README.md>Dokumen desain</a> menjelaskan cara-cara yang memungkinkan untuk mengaktifkan ketersediaan tinggi, tetapi kami membiarkannya untuk pekerjaan mendatang.</li><li>Kami <strong>tidak mengetahui adanya <em>production deployment</em></strong> dari penjadwal Poseidon-Firmament saat ini.</li><li>Poseidon-Firmament didukung dari rilis Kubernetes 1.6 dan bekerja dengan semua rilis berikutnya.</li><li>Proses rilis untuk <em>repo</em> Poseidon dan Firmament berjalan secara serentak. Rilis Poseidon saat ini dapat ditemukan <a href=https://github.com/kubernetes-sigs/poseidon/releases>di sini</a> dan rilis Firmament yang sesuai dapat ditemukan <a href=https://github.com/Huawei-PaaS/firmament/releases>di sini</a>.</li></ul><h2 id=matriks-perbandingan-fitur>Matriks Perbandingan Fitur</h2><table><thead><tr><th>Fitur</th><th>Penjadwal Bawaan Kubernetes</th><th>Penjadwal Poseidon-Firmament</th><th>Catatan</th></tr></thead><tbody><tr><td><em>Node Affinity</em>/<em>Anti-Affinity</em></td><td>Y</td><td>Y</td><td></td></tr><tr><td><em>Pod Affinity</em> / <em>Anti-Affinity</em> - termasuk dukungan untuk simetri <em>anti-affinity</em> Pod</td><td>Y</td><td>Y</td><td>Saat ini penjadwal bawaan mengungguli penjadwal Poseidon-Firmament Pod dalam segi fungsionalitas <em>affinity</em>/<em>anti-affinity</em>. Kami sedang berupaya menyelesaikan ini.</td></tr><tr><td><em>Taints</em> & <em>Toleration</em></td><td>Y</td><td>Y</td><td></td></tr><tr><td>Kemampuan Penjadwalan Dasar sesuai dengan sumber daya komputasi yang tersedia (CPU & Memori) pada sebuah Node</td><td>Y</td><td>Y**</td><td>Tidak semua Predikat & Prioritas sudah didukung saat ini.</td></tr><tr><td><em>Throughput</em> ekstrim pada skala besar</td><td>Y**</td><td>Y</td><td>Pendekatan penjadwalan massal mengukur atau meningkatkan penempatan beban kerja. Manfaat <em>throughput</em> substansial menggunakan penjadwal Firmament selama persyaratan sumber daya (CPU / Memori) untuk Pod yang masuk seragam di seluruh Replicaset / Deployment / Job. Hal ini terutama disebabkan oleh amortisasi pekerjaan yang efisien di seluruh Replicaset / Deployment / Job. 1) Untuk pekerjaan "Big Data / AI" yang terdiri dari jumlah tugas yang besar, manfaat <em>throughput</em> yang luar biasa. 2) Manfaat <em>throughput</em> substansial juga untuk skenario layanan atau sekumpulan pekerjaan di mana persyaratan sumber daya beban kerja seragam di seluruh Replicaset / Deployment / Job.</td></tr><tr><td>Penjadwalan Optimal</td><td>Penjadwalan <em>Pod-by-Pod</em>, memproses satu Pod pada satu waktu (dapat mengakibatkan penjadwalan sub-optimal)</td><td>Penjadwalan Massal (Penjadwalan optimal)</td><td>Penjadwal bawaan <em>Pod-by-Pod</em> Kubernetes dapat menetapkan tugas ke mesin sub-optimal. Sebaliknya, Firmament mempertimbangkan semua tugas yang tidak terjadwal pada saat yang bersamaan bersama dengan batasan lunak dan kerasnya.</td></tr><tr><td>Penghindaran Gangguan Kolokasi</td><td>N</td><td>N**</td><td>Direncanakan di Poseidon-Firmament.</td></tr><tr><td><em>Pre-emption</em> Prioritas</td><td>Y</td><td>N**</td><td>Tersedia secara parsial pada Poseidon-Firmament, dibandingkan dengan dukungan ekstensif di penjadwal bawaan Kubernetes.</td></tr><tr><td>Penjadwalan Ulang yang Inheren</td><td>N</td><td>Y**</td><td>Penjadwal Poseidon-Firmament mendukung penjadwalan ulang beban kerja. Dalam setiap penjadwalan, penjadwal Poseidon-Firmament mempertimbangkan semua Pod, termasuk Pod yang sedang berjalan, dan sebagai hasilnya dapat melakukan migrasi atau mengeluarkan Pod - sebuah lingkungan penjadwalan yang optimal secara global.</td></tr><tr><td>Penjadwalan Berkelompok</td><td>N</td><td>Y</td><td></td></tr><tr><td>Dukungan untuk Penjadwalan Volume Persisten Pra-terikat</td><td>Y</td><td>Y</td><td></td></tr><tr><td>Dukungan untuk Volume Lokal & Penjadwalan <em>Binding</em> Volume Persisten Dinamis</td><td>Y</td><td>N**</td><td>Direncanakan.</td></tr><tr><td>Ketersediaan Tinggi</td><td>Y</td><td>N**</td><td>Direncanakan.</td></tr><tr><td>Penjadwalan berbasis metrik <em>real-time</em></td><td>N</td><td>Y**</td><td>Awalnya didukung menggunakan Heapster (sekarang tidak digunakan lagi) untuk menempatkan Pod menggunakan statistik penggunaan klaster aktual ketimbang reservasi. Rencananya akan dialihkan ke "server metrik".</td></tr><tr><td>Dukungan untuk <em>Max-Pod</em> per Node</td><td>Y</td><td>Y</td><td>Penjadwal Poseidon-Firmament secara mulus berdampingan dengan penjadwal bawaan Kubernetes.</td></tr><tr><td>Dukungan untuk Penyimpanan <em>Ephemeral</em>, selain CPU / Memori</td><td>Y</td><td>Y</td><td></td></tr></tbody></table><h2 id=instalasi>Instalasi</h2><p>Untuk instalasi Poseidon dalam-klaster, silakan mulai dari <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/install/README.md>Petunjuk Instalasi</a>.</p><h2 id=pengembangan>Pengembangan</h2><p>Untuk developer, silakan merujuk ke <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/devel/README.md>Instruksi <em>Setup</em> Developer</a>.</p><h2 id=hasil-pengujian-kinerja-throughput-terbaru>Hasil Pengujian Kinerja <em>Throughput</em> Terbaru</h2><p>Penjadwal <em>pod-by-pod</em>, seperti penjadwal bawaan Kubernetes, biasanya memproses satu Pod pada satu waktu. Penjadwal ini memiliki kelemahan penting berikut:</p><ol><li>Penjadwal berkomitmen untuk penempatan Pod lebih awal dan membatasi pilihan untuk Pod lain yang menunggu untuk ditempatkan.</li><li>Ada peluang terbatas untuk amortisasi pekerjaan lintas Pod karena mereka dipertimbangkan untuk ditempatkan secara individual.</li></ol><p>Kelemahan dari penjadwal <em>pod-by-pod</em> ini diatasi dengan penjadwalan secara terkumpul atau dalam jumlah banyak secara bersamaan di penjadwal Poseidon-Firmament. Memproses beberapa Pod dalam satu kumpulan memungkinkan penjadwal untuk bersama-sama mempertimbangkan penempatan mereka, dan dengan demikian untuk menemukan untung-rugi terbaik untuk seluruh kumpulan ketimbang satu Pod saja. Pada saat yang sama, amortisasi berfungsi lintas Pod yang menghasilkan <em>throughput</em> yang jauh lebih tinggi.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Silakan merujuk ke <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/benchmark/README.md>hasil <em>benchmark</em> terbaru</a> untuk hasil uji perbandingan kinerja <em>throughput</em> terperinci antara penjadwal Poseidon-Firmament dan Penjadwal bawaan Kubernetes.</div></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>