<!doctype html><html lang=id class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/extend-kubernetes/api-extension/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/api-extension/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Memperluas API Kubernetes | Kubernetes</title><meta property="og:title" content="Memperluas API Kubernetes"><meta property="og:description" content="Orkestrasi Kontainer dengan Skala Produksi"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/extend-kubernetes/api-extension/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Memperluas API Kubernetes"><meta itemprop=description content="Orkestrasi Kontainer dengan Skala Produksi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Memperluas API Kubernetes"><meta name=twitter:description content="Orkestrasi Kontainer dengan Skala Produksi"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/extend-kubernetes/api-extension/"><meta property="og:title" content="Memperluas API Kubernetes"><meta name=twitter:title content="Memperluas API Kubernetes"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/id/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/api-extension/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/id/docs/concepts/extend-kubernetes/api-extension/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/concepts/extend-kubernetes/api-extension/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/concepts/extend-kubernetes/api-extension/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/concepts/extend-kubernetes/api-extension/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/extend-kubernetes/api-extension/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/extend-kubernetes/api-extension/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/extend-kubernetes/api-extension/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/extend-kubernetes/api-extension/>Français (French)</a>
<a class=dropdown-item href=/es/docs/concepts/extend-kubernetes/api-extension/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/extend-kubernetes/api-extension/>Português (Portuguese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/concepts/extend-kubernetes/api-extension/>Return to the regular view of this page</a>.</p></div><h1 class=title>Memperluas API Kubernetes</h1><ul><li>1: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>Memperluas Kubernetes API dengan Lapisan Agregasi</a></li><li>2: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>Custom Resource</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>1 - Memperluas Kubernetes API dengan Lapisan Agregasi</h1><p>Lapisan agregasi memungkinkan Kubernetes untuk diperluas dengan API tambahan, selain dari yang ditawarkan oleh API inti Kubernetes.</p><h2 id=ikhtisar>Ikhtisar</h2><p>Lapisan agregasi memungkinkan instalasi tambahan beragam API <em>Kubernetes-style</em> di kluster kamu. Tambahan-tambahan ini dapat berupa solusi-solusi yang sudah dibangun (<em>prebuilt</em>) oleh pihak ke-3 yang sudah ada, seperti <a href=https://github.com/kubernetes-incubator/service-catalog/blob/master/README.md><em>service-catalog</em></a>, atau API yang dibuat oleh pengguna seperti <a href=https://github.com/kubernetes-incubator/apiserver-builder/blob/master/README.md>apiserver-builder</a>, yang dapat membantu kamu memulainya.</p><p>Lapisan agregasi berjalan di dalam proses bersama dengan kube-apiserver. Hingga sebuah sumber daya ekstensi terdaftar, lapisan agregasi tidak akan melakukan apapun. Untuk mendaftarkan sebuah API, pengguna harus menambahkan sebuah objek <em>APIService</em>, yang "mengklaim" jalur URL di API Kubernetes. Pada titik tersebut, lapisan agregasi akan mem-<em>proxy</em> apapun yang dikirim ke jalur API tersebut (misalnya /apis/myextension.mycompany.io/v1/…) ke <em>APIService</em> yang terdaftar.</p><p>Biasanya, <em>APIService</em> akan diimplementasikan oleh sebuah ekstensi-apiserver di dalam sebuah Pod yang berjalan di kluster. Ekstensi-apiserver ini biasanya perlu di pasangkan dengan satu atau lebih <em>controller</em> apabila manajemen aktif dari sumber daya tambahan diperlukan. Sebagai hasilnya, apiserver-builder sebenarnya akan memberikan kerangka untuk keduanya. Sebagai contoh lain, ketika service-catalog diinstal, ia menyediakan ekstensi-apiserver dan <em>controller</em> untuk layanan-layanan yang disediakannya.</p><p>Ekstensi-apiserver harus memiliki latensi koneksi yang rendah dari dan ke kube-apiserver.
Secara Khusus, permintaan pencarian diperlukan untuk bolak-balik dari kube-apiserver dalam 5 detik atau kurang.
Jika implementasi kamu tidak dapat menyanggupinya, kamu harus mempertimbangkan cara mengubahnya. Untuk sekarang, menyetel
<em>feature-gate</em> <code>EnableAggregatedDiscoveryTimeout=false</code> di kube-apiserver
akan menonaktifkan batasan waktu tersebut. Fitur ini akan dihapus dalam rilis mendatang.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Untuk mengaktifkan agregator di lingkungan kamu, aktifkan<a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/>konfigurasi lapisan agregasi</a>.</li><li>Kemudian, <a href=/docs/tasks/access-kubernetes-api/setup-extension-api-server/>siapkan ekstensi api-server</a> untuk bekerja dengan lapisan agregasi.</li><li>Selain itu, pelajari caranya <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>mengembangkan API Kubernetes menggunakan <em>Custom Resource Definition</em></a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-342388440304e19ce30c0f8ada1c77ce>2 - Custom Resource</h1><p><em>Custom Resource</em> adalah ekstensi dari Kubernetes API. Laman ini mendiskusikan kapan kamu melakukan penambahan sebuah <em>Custom Resource</em> ke klaster Kubernetes dan kapan kamu menggunakan sebuah layanan mandiri. Laman ini mendeskripsikan dua metode untuk menambahkan <em>Custom Resource</em> dan bagaimana cara memilihnya.</p><h2 id=custom-resource><em>Custom Resource</em></h2><p>Sebuah sumber daya adalah sebuah <em>endpoint</em> pada <a href=/docs/reference/using-api/api-overview/>Kubernetes API</a> yang menyimpan sebuah koleksi <a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects/>objek API</a> dari sebuah jenis tertentu. Sebagai contoh, sumber daya bawaan Pod mengandung sebuah koleksi objek-objek Pod.</p><p>Sebuah <em>Custom Resource</em> adalah sebuah ekstensi dari Kubernetes API yang tidak seharusnya tersedia pada pemasangan default Kubernetes. Namun, banyak fungsi-fungsi inti Kubernetes yang sekarang dibangun menggunakan <em>Custom Resource</em>, membuat Kubernetes lebih modular.</p><p><em>Custom Resource</em> bisa muncul dan menghilang dalam sebuah klaster yang berjalan melalui registrasi dinamis (<em>dynamic registration</em>), dan admin-admin klaster bisa memperbaharui <em>Custom Resource</em> secara independen dari klaster itu sendiri. Ketika sebuah <em>Custom Resource</em>
dipasang, pengguna dapat membuat dan mengakses objek-objek <em>Custom Resource</em> menggunakan <a href=/docs/user-guide/kubectl-overview/>kubectl</a>, seperti yang mereka lakukan untuk sumber daya bawaan seperti Pod.</p><h2 id=controller-khusus><em>Controller</em> Khusus</h2><p>Dengan sendirinya, <em>Custom Resource</em> memungkinkan kamu untuk menyimpan dan mengambil data terstruktur. Ketika kamu menggabungkan sebuah <em>Custom Resource</em> dengan <em>controller</em> khusus, <em>Custom Resource</em> akan memberikan sebuah API deklaratif yang sebenarnya.</p><p>Sebuah <a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects/#memahami-konsep-objek-objek-yang-ada-pada-kubernetes>API deklaratif</a>
memungkinkan kamu untuk mendeklarasikan atau menspesifikasikan keadaan dari sumber daya kamu dan mencoba untuk menjaga agar keadaan saat itu tersinkronisasi dengan keadaan yang diinginkan. <em>Controller</em> menginterpretasikan data terstruktur sebagai sebuah rekaman dari keadaan yang diinginkan pengguna, dan secara kontinu menjaga keadaan ini.</p><p>Kamu bisa men-<em>deploy</em> dan memperbaharui sebuah <em>controller</em> khusus pada sebuah klaster yang berjalan, secara independen dari siklus hidup klaster itu sendiri. <em>Controller</em> khusus dapat berfungsi dengan sumber daya jenis apapun, tetapi mereka sangat efektif ketika dikombinasikan dengan <em>Custom Resource</em>. <a href=https://coreos.com/blog/introducing-operators.html><em>Operator pattern</em></a> mengkombinasikan <em>Custom Resource</em> dan <em>controller</em> khusus. Kamu bisa menggunakan <em>controller</em> khusus untuk menyandi pengetahuan domain untuk aplikasi spesifik menjadi sebuah ekstensi dari Kubernetes API.</p><h2 id=haruskah-custom-resource-ditambahkan-ke-dalam-klaster-kubernetes-saya>Haruskah <em>Custom Resource</em> ditambahkan ke dalam klaster Kubernetes saya?</h2><p>Ketika membuat sebuah API baru, pikirkan apakah kamu ingin <a href=/docs/concepts/api-extension/apiserver-aggregation/>mengagregasikan API kamu dengan API klaster Kubernetes</a> atau membiarkan API kamu berdiri sendiri.</p><table><thead><tr><th>Pilih agregasi API jika:</th><th>Pilih sebuah API yang berdiri sendiri jika:</th></tr></thead><tbody><tr><td>API kamu bersifat <a href=#api-deklaratif>Deklaratif</a>.</td><td>API kamu tidak cocok dengan model <a href=#api-deklaratif>Deklaratif</a>.</td></tr><tr><td>Kamu mau tipe baru yang dapat dibaca dan ditulis dengan <code>kubectl</code>.</td><td>Dukungan <code>kubectl</code> tidak diperlukan</td></tr><tr><td>Kamu mau melihat tipe baru pada sebuah Kubernetes UI, seperti dasbor, bersama dengan tipe-tipe bawaan.</td><td>Dukungan Kubernetes UI tidak diperlukan.</td></tr><tr><td>Kamu mengembangkan sebuah API baru.</td><td>Kamu memiliki sebuah program yang melayani API kamu dan dapat berkerja dengan baik.</td></tr><tr><td>Kamu bersedia menerima pembatasan format yang Kubernetes terapkan pada jalur sumber daya API (Lihat <a href=/id/docs/concepts/overview/kubernetes-api/>Ikhtisar API</a>.)</td><td>Kamu perlu memiliki jalur REST spesifik agar menjadi cocok dengan REST API yang telah didefinisikan.</td></tr><tr><td>Sumber daya kamu secara alami mencakup hingga sebuah klaster atau sebuah <em>namespace</em> dari sebuah klaster.</td><td>Sumber daya yang mencakup klaster atau <em>namespace</em> adalah sebuah ketidakcocokan; kamu perlu mengendalikan jalur sumber daya spesifik.</td></tr><tr><td>Kamu ingin menggunakan kembali <a href=#fitur-umum>dukungan fitur Kubernetes API</a>.</td><td>Kamu tidak membutuhkan fitur tersebut.</td></tr></tbody></table><h3 id=api-deklaratif>API Deklaratif</h3><p>Dalam sebuah API Deklaratif, biasanya:</p><ul><li>API kamu terdiri dari sejumlah kecil dari objek yang berukuran relatif kecil (sumber daya).</li><li>Objek-objek mendefinisikan pengaturan dari aplikasi atau infrastruktur.</li><li>Objek-objek relatif tidak sering diperbaharui.</li><li>Manusia sering diperlukan untuk membaca dan menulis objek-objek tersebut.</li><li>Operasi utama terhadap objek bersifat CRUD (<em>creating, reading, updating,</em> dan <em>deleting</em>).</li><li>Transaksi antar objek tidak dibutuhkan; API merepresentasikan sebuah keadaan yang diinginkan, bukan keadaan yang eksak.</li></ul><p>API imperatif bersifat tidak deklaratif.
Tanda-tanda apabila API kamu tidak deklaratif termasuk:</p><ul><li>klien berkata "lakukan ini", dan kemudian mendapat sebuah respon serempak ketika selesai.</li><li>klien berkata "lakukan ini", dan kemudian mendapat sebuah ID operasi kembali, dan harus melakukan sebuah cek terhadap objek <em>Operation</em> terpisah untuk menentukan selesainya sebuah permintaan.</li><li>Kamu berbicara tentang <em>Remote Procedure Call</em> (RPC).</li><li>Menyimpan secara langsung sejumlah data (mis. > beberapa kB per objek, atau >1000-an objek).</li><li>Membutuhkan akses dengan <em>bandwidth</em> tinggi (10-an permintaan per detik dapat ditopang).</li><li>Menyimpan data pengguna (seperti gambar, PII, dll) atau data berskala besar yang diproses oleh aplikasi.</li><li>Operasi-operasi natural terhadap objek yang tidak bersifat CRUD.</li><li>API yang tidak mudah dimodelkan dengan objek.</li><li>Kamu memilih untuk merepresentasikan operasi tertunda dengan sebuah ID operasi atau sebuah objek operasi.</li></ul><h2 id=apakah-saya-harus-menggunakan-sebuah-configmap-atau-sebuah-custom-resource>Apakah saya harus menggunakan sebuah ConfigMap atau sebuah <em>Custom Resource</em>?</h2><p>Gunakan ConfigMap jika salah satu hal berikut berlaku:</p><ul><li>Terdapat sebuah format berkas pengaturan yang sudah ada, yang terdokumentasi dengan baik seperti sebuah <code>mysql.cnf</code> atau <code>pom.xml</code>.</li><li>Kamu ingin menaruh seluruh berkas pengaturan kedalam sebuah <em>key</em> dari sebuah ConfigMap.</li><li>Kegunaan utama dari berkas pengaturan adalah untuk dikonsumsi sebuah program yang berjalan di dalam sebuah Pod di dalam klaster kamu untuk mengatur dirinya sendiri.</li><li>Konsumen dari berkas lebih suka untuk mengkonsumsi lewat berkas dalam sebuah Pod atau variabel lingkungan dalam sebuah Pod, dibandingkan melalui Kubernetes API.</li><li>Kamu ingin melakukan pembaharuan bergulir lewat Deployment, dll, ketika berkas diperbaharui.</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Gunakan sebuah <a href=/id/docs/concepts/configuration/secret/>Secret</a> untuk data sensitif, yang serupa dengan ConfigMap tetapi lebih aman.</div><p>Gunakan sebuah <em>Custom Resource</em> (CRD atau <em>Aggregated API</em>) jika kebanyakan dari hal berikut berlaku:</p><ul><li>Kamu ingin menggunakan pustaka klien Kubernetes dan CLI untuk membuat dan memperbaharui sumber daya baru.</li><li>Kamu ingin dukungan tingkat tinggi dari kubectl (sebagai contoh: <code>kubectl get my-object object-name</code>).</li><li>Kamu ingin membangun sebuah otomasi baru yang mengawasi pembaharuan terhadap objek baru, dan kemudian melakukan CRUD terhadap objek lainnya, atau sebaliknya.</li><li>Kamu ingin menulis otomasi yang menangani pembaharuan untuk objek.</li><li>Kamu ingin menggunakan kesepakatan API Kubernetes seperti <code>.spec</code>, <code>.status</code>, dan <code>.metadata</code>.</li><li>Kamu ingin objek tersebut untuk menjadi sebuah abstraksi terhadap sebuah kumpulan dari sumber daya terkontrol, atau peringkasan dari sumber daya lainnya.</li></ul><h2 id=menambahkan-custom-resource>Menambahkan <em>Custom Resource</em></h2><p>Kubernetes menyediakan dua cara untuk menambahkan sumber daya ke klaster kamu:</p><ul><li>CRD cukup sederhana dan bisa diciptakan tanpa pemrograman apapun.</li><li><a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Agregasi API</a> membutuhkan pemrograman, tetapi memungkinkan kendali lebih terhadap perilaku API seperti bagaimana data disimpan dan perubahan antar versi API.</li></ul><p>Kubernetes menyediakan kedua opsi tersebut untuk memenuhi kebutuhan pengguna berbeda, jadi tidak ada kemudahan penggunaan atau fleksibilitas yang dikompromikan.</p><p><em>Aggregated API</em> adalah bawahan dari APIServer yang duduk dibelakang API server utama, yang bertindak sebagai sebuah <em>proxy</em>. Pengaturan ini disebut <a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Agregasi API</a> (AA). Untuk pengguna, yang terlihat adalah Kubernetes API yang diperluas.</p><p>CRD memungkinkan pengguna untuk membuat tipe baru sumber daya tanpa menambahkan APIserver lain. Kamu tidak perlu mengerti Agregasi API untuk menggunakan CRD.</p><p>Terlepas dari bagaimana cara mereka dipasang, sumber daya baru disebut sebagai <em>Custom Resource</em> untuk memisahkan mereka dari sumber daya bawaan Kubernetes (seperti Pod).</p><h2 id=customresourcedefinition>CustomResourceDefinition</h2><p>Sumber daya API <a href=/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a> memungkinkan kamu untuk medefinisikan <em>Custom Resource</em>. Mendefinisikan sebuah objek CRD akan membuat sebuah <em>Custom Resource</em> dengan sebuah nama dan skema yang kamu spesifikasikan. Kubernetes API melayani dan menangani penyimpanan dari <em>Custom Resource</em> kamu.</p><p>Ini membebaskan kamu dari menulis server API kamu sendiri untuk menangani <em>Custom Resource</em>, tetapi sifat dasar dari implementasi menyebabkan kamu memiliki fleksibilitas yang berkurang dibanding <a href=#agregasi-server-api>agregasi server API</a>).</p><p>Lihat <a href=https://github.com/kubernetes/sample-controller>contoh <em>controller</em> khusus</a> sebagai sebuah contoh dari bagaimana cara untuk mendaftarkan sebuah <em>Custom Resource</em>, bekerja dengan instans dari tipe baru sumber daya kamu, dan menggunakan sebuah <em>controller</em> untuk menangani <em>event</em>.</p><h2 id=agregasi-server-api>Agregasi server API</h2><p>Biasanya, tiap sumber daya di API Kubernetes membutuhkan kode yang menangani permintaan REST dan mengatur peyimpanan tetap dari objek-objek. Server Kubernetes API utama menangani sumber daya bawaan seperti Pod dan Service, dan juga menangani <em>Custom Resource</em> dalam sebuah cara yang umum melalui <a href=#customresourcedefinition>CRD</a>.</p><p><a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Lapisan agregasi</a> memungkinkan kamu untuk menyediakan implementasi khusus untuk <em>Custom Resource</em> dengan menulis dan men-<em>deploy</em> API server kamu yang berdiri sendiri. API server utama menlimpahkan permintaan kepada kamu untuk <em>Custom Resource</em> yang kamu tangani, membuat mereka tersedia untuk semua kliennya.</p><h2 id=memilih-sebuah-metode-untuk-menambahkan-custom-resource>Memilih sebuah metode untuk menambahkan <em>Custom Resource</em></h2><p>CRD lebih mudah digunakan. <em>Aggregated API</em> lebih fleksibel. Pilih metode yang paling baik untuk kebutuhan kamu.</p><p>Biasanya, CRD cocok jika:</p><ul><li>Kamu memiliki <em>field</em> yang banyak</li><li>Kamu menggunakan sumber daya dalam perusahaan kamu, atau sebagai bagian dari proyek <em>open-source</em> kecil (berlawanan dengan sebuah produk komersil)</li></ul><h3 id=membandingkan-kemudahan-penggunaan>Membandingkan kemudahan penggunaan</h3><p>CRD lebih mudah dibuat dibandingkan dengan <em>Aggregated API</em>.</p><table><thead><tr><th>CRD</th><th>Aggregated API</th></tr></thead><tbody><tr><td>Tidak membutuhkan pemrograman. Pengguna dapat memilih bahasa apapun untuk sebuah <em>controller</em> CRD.</td><td>Membutuhkan pemrograman dalam Go dan membangun <em>binary</em> dan <em>image</em>. Pengguna dapat memilih bahasa apapun untuk sebuah CRD <em>controller</em>.</td></tr><tr><td>Tidak ada servis tambahan yang dijalankan; CR ditangani oleh server API.</td><td>Sebuah servis tambahan untuk menciptakan dan dapat gagal.</td></tr><tr><td>Todal ada dukungan berjalan ketika CRD dibuat. Perbaikan <em>bug</em> apapun akan dianggap sebagai bagian dari peningkatan Kubernetes Master normal.</td><td>Mungkin dibutuhkan untuk secara berkala mengambil perbaikan <em>bug</em> dari sumber dan membangun ulang dan memeperbaharui APIserver teragregasi.</td></tr><tr><td>Tidak butuh untuk menangani banyak versi dari API kamu. Sebagai contoh: ketika kamu mengendalikan klien untuk sumber daya ini, kamu bisa meningkatkannya selaras dengan API.</td><td>Kamu perlu menangani banyak versi dari API kamu, sebagai contoh: ketika mengembangkan sebuah ekstensi untuk dibagikan kepada dunia.</td></tr></tbody></table><h3 id=fitur-lanjutan-dan-fleksibilitas>Fitur lanjutan dan fleksibilitas</h3><p><em>Aggregated API</em> menawarkan fitur API lebih lanjut dan kustomisasi dari fitur lain, sebagai contoh: lapisan penyimpanan.</p><table><thead><tr><th>Fitur</th><th>Deskripsi</th><th>CRD</th><th>Aggregated API</th></tr></thead><tbody><tr><td>Validation</td><td>Membantu pengguna-pengguna mencegah error dan memungkinkan kamu untuk mengembangkan API kamu secara independen dari klien-klien kamu. Fitur ini sangan berguna ketika ada banyak klien yang tidak semua bisa memperbaharui secara bersamaan pada waktu yang sama.</td><td>Ya. Sebagian besar validasi dapat dipesifikasikan di dalam CRD <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#validation>OpenAPI v3.0 <em>validation</em></a>. Validasi bentuk lainnya didukung dengan penambahan sebuah <a href=/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9><em>Validating Webhook</em></a>.</td><td>Ya, cek validasi secara arbitrer</td></tr><tr><td>Defaulting</td><td>Lihat diatas</td><td>Ya, baik melalui <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#defaulting>OpenAPI v3.0 <em>validation</em></a> <code>default</code> keyword (GA in 1.17), maupun melalui sebuah <a href=/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook><em>Mutating Webhook</em></a> (meskipun tidak akan dijalankan ketika membaca dari etcd untuk objek-objek lama)</td><td>Ya</td></tr><tr><td>Multi-versioning</td><td>Memungkinkan menyajikan objek yang sama lwat dua versi API. Bisa membantu memudahkan perubahan API seperti menamai ulang <em>field-field</em>. Tidak terlalu penting jika kamu mengendalikan versi-versi klien kamu.</td><td><a href=/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definition-versioning>Ya</a></td><td>Ya</td></tr><tr><td>Custom Storage</td><td>Jika kamu membutuhkan penyimpanan dengan sebuah mode performa (sebagai contoh, basis data <em>time-series</em> dibanding penyimpanan <em>key-value</em>) atau isolasi untuk keamanan (sebagau contoh, rahasia penyandian atau berkas berbeda)</td><td>Tidak</td><td>Ya</td></tr><tr><td>Custom Business Logic</td><td>Melakukan cek arbitrer atau tindakan-tindakan ketika membuat, membaca, atau memperbaharui sebuah objek</td><td>Ya, menggunakan <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks><em>Webhooks</em></a>.</td><td>Ya</td></tr><tr><td>Scale Subresource</td><td>Memungkinkan sistem-sistem seperti HorizontalPodAutoscaler dan PodDisruptionBudget untuk berinteraksi dengan sumber daya baru</td><td><a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#scale-subresource>Ya</a></td><td>Ya</td></tr><tr><td>Status Subresource</td><td><ul><li>kontrol akses yang lebih baik: pengguna menulis bagian <em>spec</em>, <em>controller</em> menulis bagian status.</li><li>Memungkinkan pembuatan objek bertambah pada mutasi data <em>Custom Resource</em> (membutuhkan <em>spec</em> terpisah dan bagian status pada sumber daya)</li></ul></td><td><a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#status-subresource>Ya</a></td><td>Ya</td></tr><tr><td>Other Subresources</td><td>Menambahkan operasi selain CRUD, seperti "logs" atau "exec".</td><td>Tidak</td><td>Ya</td></tr><tr><td>strategic-merge-patch</td><td><em>Endpoint-endpoint</em> baru yang mendukung PATCH dengan <code>Content-Type: application/strategic-merge-patch+json</code>. Berguna untuk memperbaharui objek-objek yang mungkin dapat dimodifikasi baik secara lokal, dan maupun lewat server. Untuk informasi lebih lanjut, lihat <a href=/docs/tasks/run-application/update-api-object-kubectl-patch/>"Update API Objects in Place Using kubectl patch"</a></td><td>Tidak</td><td>Ya</td></tr><tr><td>Protocol Buffers</td><td>sumber daya baru mendukung klien-klien yang ingin menggunakan <em>Protocol Buffer</em></td><td>Tidak</td><td>Ya</td></tr><tr><td>OpenAPI Schema</td><td>Apakah ada sebuah skema OpenAPI (swagger) untuk tipe yang bisa secara dinamis diambil dari server? Apakah pengguna terlindungi dari kesalahan pengejaan nama-nama <em>field</em> dengan memastikan bahwa hanya <em>field</em> yang diperbolehkan yang boleh diisi? Apakah tipe-tipe diberlakukan (dengan kata lain, jangan menaruh sebuah <code>int</code> di dalam <em>field</em> <code>string</code>?)</td><td>Ya, berdasarkan pada skema <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#validation>OpenAPI v3.0 validation</a> (GA pada 1.16)</td><td>Ya</td></tr></tbody></table><h3 id=fitur-umum>Fitur Umum</h3><p>Ketika kamu membuat sebuah <em>Custom Resource</em>, baik melalui sebuah CRD atau sebuah AA, kamu mendapat banyak fitur untuk API kamu, dibandingkan dengan mengimplementasikannya diluar platform Kubernetes.</p><table><thead><tr><th>Fitur</th><th>Apa yang dilakukannya</th></tr></thead><tbody><tr><td>CRUD</td><td><em>Endpoint-endpoint</em> baru yang mendukung operasi dasar melalui HTTP dan <code>kubectl</code></td></tr><tr><td>Watch</td><td><em>Endpoint-endpoint</em> baru yang mendukung operasi Kubernetes Watch melalui HTTP</td></tr><tr><td>Discovery</td><td>Klien seperti kubectl dan dasbor yang secara otomatis menawarkan operasi <em>list</em>, <em>display</em>, dan pembaharuan <em>field</em> pada sumber daya kamu.</td></tr><tr><td>json-patch</td><td><em>Endpoint-endpoint</em> baru yang mendukung PATCH dengan <code>Content-Type: application/json-patch+json</code></td></tr><tr><td>merge-patch</td><td><em>Endpoint-endpoint</em> baru yang mendukung PATCH dengan <code>Content-Type: application/merge-patch+json</code></td></tr><tr><td>HTTPS</td><td><em>Endpoint-endpoint</em> menggunakan HTTPS</td></tr><tr><td>Built-in Authentication</td><td>Akses ke ekstensi yang menggunakan <em>apiserver</em> inti (lapisan agregasi) untuk otentikasi</td></tr><tr><td>Built-in Authorization</td><td>Akses ke ekstensi dapat menggunakan ulang otorisasi yang digunakan oleh <em>apiserver</em> inti (mis. RBAC)</td></tr><tr><td>Finalizers</td><td>Penghapusan blok dari ekstensi sumber daya hingga pembersihan eksternal terjadi.</td></tr><tr><td>Admission Webhooks</td><td>Menentukan nilai default dan memvalidasi ekstensi sumber daya saat terjadi operasi <em>create/update/delete</em> apapun.</td></tr><tr><td>UI/CLI Display</td><td>Kubectl, dasbor dapat menampilkan ekstensi sumber daya</td></tr><tr><td>Unset vs Empty</td><td>Klien-klien dapat membedakan <em>field-field</em> yang tidak diisi dari <em>field-field</em> yang memiliki nilai nol.</td></tr><tr><td>Client Libraries Generation</td><td>Kubernetes menyediakan pustaka klien dasar, juga alat-alat untuk membuat pustaka klien dengan tipe spesifik.</td></tr><tr><td>Labels and annotations</td><td>Metadata umum lintas objek yang cara untuk memperbaharui sumber daya inti dan <em>Custom Resource</em>-nya diketahui oleh alat-alat.</td></tr></tbody></table><h2 id=persiapan-pemasangan-sebuah-custom-resource>Persiapan pemasangan sebuah <em>Custom Resource</em></h2><p>Ada beberapa poin yang harus diperhatikan sebelum menambahkan sebuah <em>Custom Resource</em> ke klaster kamu.</p><h3 id=kode-pihak-ketiga-dan-poin-kegagalan-baru>Kode pihak ketiga dan poin kegagalan baru</h3><p>Saat membuat sebuah CRD tidak secara otomatis menambahkan titik-titik kegagalan baru (sebagai contoh, dengan menyebabkan kode pihak ketiga untuk berjalan di API server kamu), paket-paket (sebagai contoh, <em>Chart</em>) atau bundel pemasangan lain seringkali sudah termasuk CRD dan juga sebagai Deployment dari kode pihak ketiga yang mengimplementasi logika bisnis untuk sebuah <em>Custom Resource</em>.</p><p>Memasang sebuah APIserver teragregasi selalu melibatkan tindakan menjalankan Deployment baru.</p><h3 id=penyimpanan>Penyimpanan</h3><p><em>Custom Resource</em> mengkonsumsi ruang penyimpanan dengan cara yang sama dengan ConfigMap. Membuat terlalu banyak sumber daya mungkin akan memenuhi ruang penyimpanan server API kamu.</p><p>Server <em>Aggregated API</em> dapat menggunakan penyimpanan yang sama dengan server API utama, dimana peringatan yang sama berlaku.</p><h3 id=authentication-authorization-and-auditing>Authentication, authorization, and auditing</h3><p>CRD selalu menggunakan otentikasi, otorisasi, dan audit pencatatan yang sama sebagai sumber daya bawaan dari server API kamu.</p><p>Jika kamu menggunakan RBAC untuk otorisasi, sebagian besar <em>role</em> RBAC tidak akan mengizinkan akses ke sumber daya baru (kecuali <em>role cluster-admin</em> atau <em>role</em> apapun yang dibuat menggunakan aturan <em>wildcard</em>). Kamu akan dibutuhkan untuk secara eksplisit mengizinkan akses ke sumber daya baru. CRD dan <em>Aggregated API</em> seringkali dibundel dengan definisi <em>role</em> baru untuk tipe yang mereka tambahkan.</p><p>API server teragregasi dapat atau tidak dapat menggunakan otentikasi, otorisasi, dan pengauditan yang sama dengan server API utama.</p><h2 id=mengakses-sebuah-custom-resource>Mengakses sebuah <em>Custom Resource</em></h2><p><a href=/docs/reference/using-api/client-libraries/>Pustaka klien</a> Kubernetes dapat digunakan untuk mengakses <em>Custom Resource</em>. Tidak semua pustaka klien mendukung <em>Custom Resource</em>. Pustaka klien go dan python melakukannya.</p><p>Ketika kamu menambahkan sebuah <em>Custom Resource</em>, kamu dapat mengaksesnya dengan menggunakan:</p><ul><li>kubectl</li><li>Klien dinamis kubernetes.</li><li>Sebuah klien REST yang kamu tulis</li><li>Sebuah klien yang dibuat menggunakan <a href=https://github.com/kubernetes/code-generator>Kubernetes client generation tools</a> (membuat satu adalah usaha lanjutan, tetapi beberapa proyek mungkin menyajikan sebuah klien bersama dengan CRD atau AA).</li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Belajar bagaimana untuk <a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Memperluas Kubernetes API dengan lapisan agregasi</a>.</p></li><li><p>Belajar bagaimana untuk <a href=/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/>Memperluas Kubernetes API dengan CustomResourceDefinition</a>.</p></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>